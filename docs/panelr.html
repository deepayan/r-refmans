<!DOCTYPE html><html><head><title>Help for package panelr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {panelr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#are_varying'><p>Check if variables are constant or variable over time.</p></a></li>
<li><a href='#asym'><p>Estimate asymmetric effects models using first differences</p></a></li>
<li><a href='#asym_gee'><p>Asymmetric effects models fit with GEE</p></a></li>
<li><a href='#complete_data'><p>Filter out entities with too few observations</p></a></li>
<li><a href='#fdm'><p>Estimate first differences models using GLS</p></a></li>
<li><a href='#formula.wbm'><p>Retrieve model formulas from <code>wbm</code> objects</p></a></li>
<li><a href='#get_wave'><p>Retrieve panel_data metadata</p></a></li>
<li><a href='#heise'><p>Estimate Heise stability and reliability coefficients</p></a></li>
<li><a href='#is_panel'><p>Check if object is panel_data</p></a></li>
<li><a href='#line_plot'><p>Plot trends in longitudinal variables</p></a></li>
<li><a href='#long_panel'><p>Convert wide panels to long format</p></a></li>
<li><a href='#make_diff_data'><p>Generate differenced and asymmetric effects data</p></a></li>
<li><a href='#make_wb_data'><p>Prepare data for within-between modeling</p></a></li>
<li><a href='#model_frame'><p>Make model frames for panel_data objects</p></a></li>
<li><a href='#nlsy'><p>National Longitudinal Survey of Youth data</p></a></li>
<li><a href='#nobs.wbm'><p>Number of observations used in <code>wbm</code> models</p></a></li>
<li><a href='#panel_data'><p>Create panel data frames</p></a></li>
<li><a href='#predict.wbgee'><p>Predictions and simulations from within-between GEE models</p></a></li>
<li><a href='#predict.wbm'><p>Predictions and simulations from within-between models</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#summary.panel_data'><p>Summarize panel data frames</p></a></li>
<li><a href='#teen_poverty'><p>National Longitudinal Survey of Youth teenage women poverty data</p></a></li>
<li><a href='#tidy.asym'><p>Tidy methods for <code>fdm</code> and <code>asym</code> models</p></a></li>
<li><a href='#tidy.asym_gee'><p>Tidy methods for <code>wbgee</code> models</p></a></li>
<li><a href='#tidy.wbm'><p>Tidy methods for <code>wbm</code> models</p></a></li>
<li><a href='#unpanel'><p>Convert panel_data to regular data frame</p></a></li>
<li><a href='#WageData'><p>Earnings data from the Panel Study of Income Dynamics</p></a></li>
<li><a href='#wbgee'><p>Panel regression models fit with GEE</p></a></li>
<li><a href='#wbm'><p>Panel regression models fit via multilevel modeling</p></a></li>
<li><a href='#wbm_stan'><p>Bayesian estimation of within-between models</p></a></li>
<li><a href='#wbm-class'><p>Within-Between Model (<code>wbm</code>) class</p></a></li>
<li><a href='#widen_panel'><p>Convert long panel data to wide format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression Models and Utilities for Repeated Measures and Panel
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an object type and associated tools for storing and 
  wrangling panel data. Implements several methods for creating regression
  models that take advantage of the unique aspects of 
  panel data. Among other capabilities, automates the "within-between" 
  (also known as "between-within" and "hybrid") panel regression specification
  that combines the desirable aspects of both fixed effects and random effects 
  econometric models and fits them as multilevel models 
  (Allison, 2009 &lt;<a href="https://doi.org/10.4135%2F9781412993869.d33">doi:10.4135/9781412993869.d33</a>&gt;; 
  Bell &amp; Jones, 2015 &lt;<a href="https://doi.org/10.1017%2Fpsrm.2014.7">doi:10.1017/psrm.2014.7</a>&gt;). These models can also be 
  estimated via generalized estimating equations 
  (GEE; McNeish, 2019 &lt;<a href="https://doi.org/10.1080%2F00273171.2019.1602504">doi:10.1080/00273171.2019.1602504</a>&gt;) and Bayesian 
  estimation is (optionally) supported via 'Stan'. 
  Supports estimation of asymmetric effects models via first differences
  (Allison, 2019 &lt;<a href="https://doi.org/10.1177%2F2378023119826441">doi:10.1177/2378023119826441</a>&gt;) as well as a generalized
  linear model extension thereof using GEE. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://panelr.jacob-long.com">https://panelr.jacob-long.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jacob-long/panelr">https://github.com/jacob-long/panelr</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), lme4</td>
</tr>
<tr>
<td>Imports:</td>
<td>crayon, dplyr, Formula, ggplot2, jtools (&ge; 2.0.1), lmerTest,
magrittr, methods, purrr, rlang (&ge; 0.3.0), stringr, tibble (&ge;
2.0.0), tidyr (&ge; 0.8.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brms, broom.mixed, car, clubSandwich, geepack, generics,
nlme, plm, sandwich, skimr, testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 16:59:59 UTC; jacoblong</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob A. Long <a href="https://orcid.org/0000-0002-1582-6214"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob A. Long &lt;jacob.long@sc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 15:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='are_varying'>Check if variables are constant or variable over time.</h2><span id='topic+are_varying'></span>

<h3>Description</h3>

<p>This function is designed for use with <code><a href="#topic+panel_data">panel_data()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_varying(data, ..., type = "time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_varying_+3A_data">data</code></td>
<td>
<p>A data frame, typically of <code><a href="#topic+panel_data">panel_data()</a></code> class.</p>
</td></tr>
<tr><td><code id="are_varying_+3A_...">...</code></td>
<td>
<p>Variable names. If none are given, all variables are checked.</p>
</td></tr>
<tr><td><code id="are_varying_+3A_type">type</code></td>
<td>
<p>Check for variance over time or across individuals? Default
is <code>"time"</code>. <code>"individual"</code> considers variables like age to be non-varying
because everyone ages at the same speed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named logical vector. If TRUE, the variable is varying.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wages &lt;- panel_data(WageData, id = id, wave = t)
wages %&gt;% are_varying(occ, ind, fem, blk)

</code></pre>

<hr>
<h2 id='asym'>Estimate asymmetric effects models using first differences</h2><span id='topic+asym'></span>

<h3>Description</h3>

<p>The function fits the asymmetric effects first difference
model described in Allison (2019) using GLS estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asym(
  formula,
  data,
  id = NULL,
  wave = NULL,
  use.wave = FALSE,
  min.waves = 1,
  variance = c("toeplitz-1", "constrained", "unconstrained"),
  error.type = c("CR2", "CR1S"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asym_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="asym_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="asym_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="asym_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="asym_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="asym_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="asym_+3A_variance">variance</code></td>
<td>
<p>One of <code>"toeplitz-1"</code>, <code>"constrained"</code>, or <code>"unconstrained"</code>.
The toeplitz variance specification estimates a single error variance and
a single lag-1 error correlation with other lags having zero correlation.
The constrained model assumes no autocorrelated errors or heteroskedastic
errors. The unconstrained option allows separate variances for every
period as well as every lag of autocorrelation. This can be very
computationally taxing as periods increase and will be inefficient when
not necessary. See Allison (2019) for more.</p>
</td></tr>
<tr><td><code id="asym_+3A_error.type">error.type</code></td>
<td>
<p>Either &quot;CR2&quot; or &quot;CR1S&quot;. See the <code>clubSandwich</code> package for
more details.</p>
</td></tr>
<tr><td><code id="asym_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Allison, P. D. (2019). Asymmetric fixed-effects models for panel data.
<em>Socius</em>, <em>5</em>, 1-12. https://doi.org/10.1177/2378023119826441
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data("teen_poverty")
# Convert to long format
teen &lt;- long_panel(teen_poverty, begin = 1, end = 5)
model &lt;- asym(hours ~ lag(pov) + spouse, data = teen)
summary(model)

## End(Not run)

</code></pre>

<hr>
<h2 id='asym_gee'>Asymmetric effects models fit with GEE</h2><span id='topic+asym_gee'></span>

<h3>Description</h3>

<p>Fit &quot;within-between&quot; and several other regression variants
for panel data via generalized estimating equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asym_gee(
  formula,
  data,
  id = NULL,
  wave = NULL,
  cor.str = c("ar1", "exchangeable", "unstructured"),
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 1,
  family = gaussian,
  weights = NULL,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asym_gee_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_cor.str">cor.str</code></td>
<td>
<p>Any correlation structure accepted by <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.
Default is &quot;ar1&quot;, most useful alternative is &quot;exchangeable&quot;. &quot;unstructured&quot;
may cause problems due to its computational complexity.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_wave.factor">wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_family">family</code></td>
<td>
<p>Use this to specify GLM link families. Default is <code>gaussian</code>,
the linear model.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="asym_gee_+3A_...">...</code></td>
<td>
<p>Additional arguments provided to <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation for <code><a href="#topic+wbm">wbm()</a></code> for many details on formula syntax and
other arguments.
</p>


<h3>Value</h3>

<p>An <code>asym_gee</code> object, which inherits from <code>wbgee</code> and <code>geeglm</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob A. Long
</p>


<h3>References</h3>

<p>Allison, P. D. (2019). Asymmetric fixed-effects models for panel data.
<em>Socius</em>, <em>5</em>, 1-12. https://doi.org/10.1177/2378023119826441
</p>
<p>McNeish, D. (2019). Effect partitioning in cross-sectionally clustered data
without multilevel models. <em>Multivariate Behavioral Research</em>,
Advance online publication. https://doi.org/10.1080/00273171.2019.1602504
</p>
<p>McNeish, D., Stapleton, L. M., &amp; Silverman, R. D. (2016). On the unnecessary
ubiquity of hierarchical linear modeling. <em>Psychological Methods</em>, <em>22</em>,
114-140. https://doi.org/10.1037/met0000078
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("geepack")) {
  data("WageData")
  wages &lt;- panel_data(WageData, id = id, wave = t)
  model &lt;- asym_gee(lwage ~ lag(union) + wks, data = wages)
  summary(model)
}

</code></pre>

<hr>
<h2 id='complete_data'>Filter out entities with too few observations</h2><span id='topic+complete_data'></span>

<h3>Description</h3>

<p>This function allows you to define a minimum number of
waves/periods and exclude all individuals with fewer observations than
that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_data(data, ..., formula = NULL, vars = NULL, min.waves = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_data_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+panel_data">panel_data()</a></code> frame.</p>
</td></tr>
<tr><td><code id="complete_data_+3A_...">...</code></td>
<td>
<p>Optionally, unquoted variable names/expressions separated by
commas to be passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Otherwise, all columns are
included if <code>formula</code> and <code>vars</code> are also NULL.</p>
</td></tr>
<tr><td><code id="complete_data_+3A_formula">formula</code></td>
<td>
<p>A formula, like the one you'll be using to specify your model.</p>
</td></tr>
<tr><td><code id="complete_data_+3A_vars">vars</code></td>
<td>
<p>As an alternative to formula, a vector of variable names.</p>
</td></tr>
<tr><td><code id="complete_data_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of observations to be kept?
Default is <code>"all"</code>, but it can be any number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>...</code> (that is, unquoted variable name(s)) are included, then <code>formula</code>
and <code>vars</code> are ignored. Likewise, <code>formula</code> takes precedence over <code>vars</code>.
These are just different methods for selecting variables and you can choose
whichever you prefer/are comfortable with. <code>...</code> corresponds with the
&quot;tidyverse&quot; way, <code>formula</code> is useful for programming or working with
model formulas, and <code>vars</code> is a &quot;standard&quot; evaluation method for when you
are working with strings.
</p>


<h3>Value</h3>

<p>A <code>panel_data</code> frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
complete_data(wages, wks, lwage, min.waves = 3)

</code></pre>

<hr>
<h2 id='fdm'>Estimate first differences models using GLS</h2><span id='topic+fdm'></span>

<h3>Description</h3>

<p>The function fits first difference models using GLS estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdm(
  formula,
  data,
  id = NULL,
  wave = NULL,
  use.wave = FALSE,
  min.waves = 1,
  variance = c("toeplitz-1", "constrained", "unconstrained"),
  error.type = c("CR2", "CR1S"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdm_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="fdm_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="fdm_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="fdm_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="fdm_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="fdm_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="fdm_+3A_variance">variance</code></td>
<td>
<p>One of <code>"toeplitz-1"</code>, <code>"constrained"</code>, or <code>"unconstrained"</code>.
The toeplitz variance specification estimates a single error variance and
a single lag-1 error correlation with other lags having zero correlation.
The constrained model assumes no autocorrelated errors or heteroskedastic
errors. The unconstrained option allows separate variances for every
period as well as every lag of autocorrelation. This can be very
computationally taxing as periods increase and will be inefficient when
not necessary. See Allison (2019) for more.</p>
</td></tr>
<tr><td><code id="fdm_+3A_error.type">error.type</code></td>
<td>
<p>Either &quot;CR2&quot; or &quot;CR1S&quot;. See the <code>clubSandwich</code> package for
more details.</p>
</td></tr>
<tr><td><code id="fdm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Allison, P. D. (2019). Asymmetric fixed-effects models for panel data.
<em>Socius</em>, <em>5</em>, 1-12. https://doi.org/10.1177/2378023119826441
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("clubSandwich")) {
  data("teen_poverty")
  # Convert to long format
  teen &lt;- long_panel(teen_poverty, begin = 1, end = 5)
  model &lt;- fdm(hours ~ lag(pov) + spouse, data = teen)
  summary(model)
}

</code></pre>

<hr>
<h2 id='formula.wbm'>Retrieve model formulas from <code>wbm</code> objects</h2><span id='topic+formula.wbm'></span>

<h3>Description</h3>

<p>This S3 method allows you to retrieve the formula used to
fit <code>wbm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wbm'
formula(x, raw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.wbm_+3A_x">x</code></td>
<td>
<p>A <code>wbm</code> model.</p>
</td></tr>
<tr><td><code id="formula.wbm_+3A_raw">raw</code></td>
<td>
<p>Return the formula used in the call to <code>lmerMod</code>/<code>glmerMod</code>?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="formula.wbm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks, data = wages)
# Returns the original model formula rather than the one sent to lme4
formula(model)
</code></pre>

<hr>
<h2 id='get_wave'>Retrieve panel_data metadata</h2><span id='topic+get_wave'></span><span id='topic+get_id'></span><span id='topic+get_periods'></span>

<h3>Description</h3>

<p><code>get_id()</code>, <code>get_wave()</code>, and <code>get_periods()</code> are extractor
functions that can be used to retrieve the names of the id and wave
variables or time periods of a <code>panel_data</code> frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wave(data)

get_id(data)

get_periods(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wave_+3A_data">data</code></td>
<td>
<p>A <code>panel_data</code> frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panel_data</code> frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
get_wave(wages)
get_id(wages)
get_periods(wages)

</code></pre>

<hr>
<h2 id='heise'>Estimate Heise stability and reliability coefficients</h2><span id='topic+heise'></span>

<h3>Description</h3>

<p>This function uses three waves of data to estimate stability
and reliability coefficients as described in Heise (1969).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heise(data, ..., waves = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heise_+3A_data">data</code></td>
<td>
<p>A <code>panel_data</code> frame.</p>
</td></tr>
<tr><td><code id="heise_+3A_...">...</code></td>
<td>
<p>unquoted variable names that are passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code></p>
</td></tr>
<tr><td><code id="heise_+3A_waves">waves</code></td>
<td>
<p>Which 3 waves should be used? If NULL (the default), the
first, middle, and last waves are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with reliability (<code>rel</code>), waves 1-3 stability (<code>stab13</code>),
waves 1-2 stability (<code>stab12</code>), and waves 2-3 stability (<code>stab23</code>) and
the variable these values refer to (<code>var</code>).
</p>


<h3>References</h3>

<p>Heise, D. R. (1969). Separating reliability and stability in test-retest
correlation. <em>American Sociological Review</em>, <em>34</em>, 93–101.
https://doi.org/10.2307/2092790
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
heise(wages, wks, lwage) # will use waves 1, 4, and 7 by default
</code></pre>

<hr>
<h2 id='is_panel'>Check if object is panel_data</h2><span id='topic+is_panel'></span>

<h3>Description</h3>

<p>This is a convenience function that checks whether an object
is a <code>panel_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_panel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_panel_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> data("WageData")
 is_panel(WageData) # FALSE
 wages &lt;- panel_data(WageData, id = id, wave = t)
 is_panel(wages) # TRUE
</code></pre>

<hr>
<h2 id='line_plot'>Plot trends in longitudinal variables</h2><span id='topic+line_plot'></span>

<h3>Description</h3>

<p><code>line_plot</code> allows for flexible visualization of repeated
measures variables from <code>panel_data</code> frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_plot(
  data,
  var,
  id = NULL,
  wave = NULL,
  overlay = TRUE,
  show.points = TRUE,
  subset.ids = FALSE,
  n.random.subset = 9,
  add.mean = FALSE,
  mean.function = "lm",
  line.size = 1,
  alpha = if (overlay) 0.5 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_plot_+3A_data">data</code></td>
<td>
<p>Either a <code>panel_data</code> frame or another data frame.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_var">var</code></td>
<td>
<p>The unquoted name of the variable of interest.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the id variable.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the wave variable.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_overlay">overlay</code></td>
<td>
<p>Should the lines be plotted in the same panel or each in
their own facet/panel? Default is TRUE, meaning they are plotted in the
same panel.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_show.points">show.points</code></td>
<td>
<p>Plot a point at each wave? Default is TRUE.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_subset.ids">subset.ids</code></td>
<td>
<p>Plot only a subset of the entities' lines? Default is NULL,
meaning plot all ids. If TRUE, a random subset (the number defined by
<code>n.random.subset</code>) are plotted. You may also supply a vector of ids to
choose them yourself.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_n.random.subset">n.random.subset</code></td>
<td>
<p>How many entities to randomly sample when <code>subset.ids</code>
is TRUE.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_add.mean">add.mean</code></td>
<td>
<p>Add a line representing the mean trend? Default is FALSE.
Cannot be combined with <code>overlay</code>.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_mean.function">mean.function</code></td>
<td>
<p>The mean function to supply to <code>geom_smooth</code> when
<code>add.mean</code> is TRUE. Default is <code>"lm"</code>, but another option of interest is
<code>"loess"</code>.</p>
</td></tr>
<tr><td><code id="line_plot_+3A_line.size">line.size</code></td>
<td>
<p>The thickness of the plotted lines. Default: 0.5</p>
</td></tr>
<tr><td><code id="line_plot_+3A_alpha">alpha</code></td>
<td>
<p>The transparency for the lines and points. When
<code>overlay = TRUE</code>, it is set to 0.5, otherwise 1, which means
non-transparent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
line_plot(wages, lwage, add.mean = TRUE, subset.ids = TRUE, overlay = FALSE)

</code></pre>

<hr>
<h2 id='long_panel'>Convert wide panels to long format</h2><span id='topic+long_panel'></span>

<h3>Description</h3>

<p>This function takes wide format panels as input and
converts them to long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_panel(
  data,
  prefix = NULL,
  suffix = NULL,
  begin = NULL,
  end = NULL,
  id = "id",
  wave = "wave",
  periods = NULL,
  label_location = c("end", "beginning"),
  as_panel_data = TRUE,
  match = ".*",
  use.regex = FALSE,
  check.varying = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long_panel_+3A_data">data</code></td>
<td>
<p>The wide data frame.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_prefix">prefix</code></td>
<td>
<p>What character(s) go before the period indicator? If none,
set this argument to NULL.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_suffix">suffix</code></td>
<td>
<p>What character(s) go after the period indicator? If none,
set this argument to NULL.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_begin">begin</code></td>
<td>
<p>What is the label for the first period? Could be <code>1</code>, <code>"A"</code>,
or anything that can be sequenced.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_end">end</code></td>
<td>
<p>What is the label for the final period? Could be <code>2</code>, <code>"B"</code>,
or anything that can be sequenced and lies further along the sequence
than the <code>begin</code> argument.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_id">id</code></td>
<td>
<p>The name of the ID variable as a string. If there is no ID
variable, then this will be the name of the newly-created ID variable.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_wave">wave</code></td>
<td>
<p>This will be the name of the newly-created wave variable.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_periods">periods</code></td>
<td>
<p>If you period indicator does not lie in a sequence or is
not understood by the function, then you can supply them as a vector
instead. For instance, you could give <code>c("one","three","five")</code> if
your variables are labeled <code>var_one</code>, <code>var_three</code>, and <code>var_five</code>.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_label_location">label_location</code></td>
<td>
<p>Where does the period label go on the variable?
If the variables are labeled like <code>var_1</code>, <code>var_2</code>, etc., then it is
<code>"end"</code>. If the labels are more like <code>A_var</code>, <code>B_var</code>, and so on, then
it is <code>"beginning"</code>.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_as_panel_data">as_panel_data</code></td>
<td>
<p>Should the return object be a <code><a href="#topic+panel_data">panel_data()</a></code> object?
Default is TRUE.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_match">match</code></td>
<td>
<p>The regex that will match the part of the variable names other
than the wave indicator. By default it will match any character any
amount of times. Sometimes you might know that the variable names should
start with a digit, for instance, and you might use <code>"\\d.*"</code> instead.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_use.regex">use.regex</code></td>
<td>
<p>Should the <code>begin</code> and <code>end</code> arguments be treated as
regular expressions? Default is FALSE.</p>
</td></tr>
<tr><td><code id="long_panel_+3A_check.varying">check.varying</code></td>
<td>
<p>Should the function check to make sure that every
variable in the wide data with a wave indicator is actually time-varying?
Default is TRUE, meaning that a constant like &quot;race_W1&quot; only measured in
wave 1 will be defined in each wave in the long data. With very large
datasets, however, sometimes setting this to FALSE can save memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no easy way to convert panel data from wide to long format because
the both formats are basically non-standard for other applications.
This function can handle the common case in which the wide data frame
has a regular labeling system for each period. The key thing is
providing enough information for the function to understand the pattern.
</p>
<p>In the end, this function calls <code><a href="stats.html#topic+reshape">stats::reshape()</a></code> but should be easier
to use and able to handle more situations, such as when the label occurs
at the beginning of the variable name. Also, just as important, this
function has built-in utilities to handle unbalanced data &mdash; when
variables occur more than once but every single period, which breaks
<code><a href="stats.html#topic+reshape">stats::reshape()</a></code>.
</p>


<h3>Value</h3>

<p>Either a <code>data.frame</code> or <code>panel_data</code> frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+widen_panel">widen_panel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## We need a wide data frame, so we will make one from the long-format 
## data included in the package.

# Convert WageData to panel_data object
wages &lt;- panel_data(WageData, id = id, wave = t)
# Convert wages to wide format
wide_wages &lt;- widen_panel(wages)

# Note: wide_wages has variables in the following format:
# var1_1, var1_2, var1_3, var2_1, var2_2, var2_3, etc.
## Not run: 
long_wages &lt;- long_panel(wide_wages, prefix = "_", begin = 1, end = 7,
                         id = "id", label_location = "end")

## End(Not run)
# Note that in this case, the prefix and label_location arguments are
# the defaults but are included just for clarity.


</code></pre>

<hr>
<h2 id='make_diff_data'>Generate differenced and asymmetric effects data</h2><span id='topic+make_diff_data'></span>

<h3>Description</h3>

<p>This is an interface to the internal functions that process data for
<code><a href="#topic+fdm">fdm()</a></code>, <code><a href="#topic+asym">asym()</a></code>, and <code><a href="#topic+asym_gee">asym_gee()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_diff_data(
  formula,
  data,
  id = NULL,
  wave = NULL,
  use.wave = FALSE,
  min.waves = 1,
  weights = NULL,
  offset = NULL,
  asym = FALSE,
  cumulative = FALSE,
  escape.names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_diff_data_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_asym">asym</code></td>
<td>
<p>Return asymmetric effects transformed data? Default is FALSE.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_cumulative">cumulative</code></td>
<td>
<p>Return cumulative positive/negative differences, most
useful for fixed effects estimation and/or generalized linear models?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_escape.names">escape.names</code></td>
<td>
<p>Return only syntactically valid variable names?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="make_diff_data_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
make_diff_data(wks ~ lwage + union, data = wages)
 
</code></pre>

<hr>
<h2 id='make_wb_data'>Prepare data for within-between modeling</h2><span id='topic+make_wb_data'></span>

<h3>Description</h3>

<p>This function allows users to make the changes to their data
that occur in <code><a href="#topic+wbm">wbm()</a></code> without having to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_wb_data(
  formula,
  data,
  id = NULL,
  wave = NULL,
  model = "w-b",
  detrend = FALSE,
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 2,
  balance.correction = FALSE,
  dt.random = TRUE,
  dt.order = 1,
  weights = NULL,
  offset = NULL,
  interaction.style = c("double-demean", "demean", "raw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_wb_data_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_model">model</code></td>
<td>
<p>One of <code>"w-b"</code>, <code>"within"</code>, <code>"between"</code>,
<code>"contextual"</code>. See details for more on these options.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_detrend">detrend</code></td>
<td>
<p>Adjust within-subject effects for trends in the predictors?
Default is FALSE, but some research suggests this is a better idea
(see Curran and Bauer (2011) reference).</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_wave.factor">wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_balance.correction">balance.correction</code></td>
<td>
<p>Correct between-subject effects for unbalanced
panels following the procedure in Curran and Bauer (2011)? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_dt.random">dt.random</code></td>
<td>
<p>Should the detrending procedure be performed with a
random slope for each entity? Default is TRUE but for short panels
FALSE may be better, fitting a trend for all entities.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_dt.order">dt.order</code></td>
<td>
<p>If detrending using <code>detrend</code>, what order polynomial
would you like to specify for the relationship between time and the
predictors? Default is 1, a linear model.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_interaction.style">interaction.style</code></td>
<td>
<p>The best way to calculate interactions in within
models is in some dispute. The conventional way (<code>"demean"</code>) is to first
calculate the product of the variables involved in the interaction before
those variables have their means subtracted and then subtract the mean of
the product from the product term (see Schunk and Perales (2017)).
Giesselmann and Schmidt-Catran (2020) show this method carries
between-entity differences that within models are designed to model out.
They suggest an alternate method (<code>"double-demean"</code>) in which the product
term is first calculated using the de-meaned lower-order variables and
then the subject means are subtracted from this product term. Another
option is to simply use the product term of the de-meaned variables
(<code>"raw"</code>), but Giesselmann and Schmidt-Catran (2020) show this method
biases the results towards zero effect. The default is <code>"double-demean"</code>
but if emulating other software is the goal, <code>"demean"</code> might be
preferred.</p>
</td></tr>
<tr><td><code id="make_wb_data_+3A_...">...</code></td>
<td>
<p>Additional arguments provided to <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>,
<code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code>, or <code><a href="lme4.html#topic+glmer.nb">lme4::glmer.nb()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panel_data</code> object with the requested specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
make_wb_data(lwage ~ wks + union | fem, data = wages)

</code></pre>

<hr>
<h2 id='model_frame'>Make model frames for panel_data objects</h2><span id='topic+model_frame'></span>

<h3>Description</h3>

<p>This is similar to model.frame, but is designed specifically
for <code><a href="#topic+panel_data">panel_data()</a></code> data frames. It's a workhorse in <code><a href="#topic+wbm">wbm()</a></code>
but may be useful in scripting use as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_frame(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_frame_+3A_formula">formula</code></td>
<td>
<p>A formula. Note that to get an individual-level mean with
incomplete data (e.g., panel attrition), you should use <code>imean()</code> rather
than <code>mean()</code>.</p>
</td></tr>
<tr><td><code id="model_frame_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+panel_data">panel_data()</a></code> frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+panel_data">panel_data()</a></code> frame with only the columns needed to fit
a model as described by the formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model_frame(lwage ~ wks + exp, data = wages)

</code></pre>

<hr>
<h2 id='nlsy'>National Longitudinal Survey of Youth data</h2><span id='topic+nlsy'></span>

<h3>Description</h3>

<p>These data come from the years 1990-1994 in the National Longitudinal
Survey of Youth, with information about 581 individuals. These data are in
the &quot;wide&quot; format for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsy
</code></pre>


<h3>Format</h3>

<p>A data frame with 581 rows and 16 variables:
</p>

<dl>
<dt>momage</dt><dd><p>Mother's age at birth</p>
</dd>
<dt>gender</dt><dd><p>0 if boy, 1 if girl</p>
</dd>
<dt>momwork</dt><dd><p>1 if mother works, 0 if not)</p>
</dd>
<dt>married</dt><dd><p>1 if parents are married, 0 if not</p>
</dd>
<dt>hispanic</dt><dd><p>1 if child is Hispanic, 0 if not</p>
</dd>
<dt>black</dt><dd><p>1 if child is black, 0 if not</p>
</dd>
<dt>childage</dt><dd><p>Child's age at first interview</p>
</dd>
<dt>anti90</dt><dd><p>A measure of anti-social behavior antisocial behavior
measured on a scale from 0 to 6, taken in 1990</p>
</dd>
<dt>anti92</dt><dd><p>A measure of anti-social behavior antisocial behavior
measured on a scale from 0 to 6, taken in 1992</p>
</dd>
<dt>anti94</dt><dd><p>A measure of anti-social behavior antisocial behavior
measured on a scale from 0 to 6, taken in 1994</p>
</dd>
<dt>self90</dt><dd><p>A measure of self-esteem measured on a scale from 6 to 24,
taken in 1990</p>
</dd>
<dt>self92</dt><dd><p>A measure of self-esteem measured on a scale from 6 to 24,
taken in 1992</p>
</dd>
<dt>self94</dt><dd><p>A measure of self-esteem measured on a scale from 6 to 24,
taken in 1994</p>
</dd>
<dt>pov90</dt><dd><p>1 if family is in poverty, 0 if not, in 1990</p>
</dd>
<dt>pov92</dt><dd><p>1 if family is in poverty, 0 if not, in 1992</p>
</dd>
<dt>pov94</dt><dd><p>1 if family is in poverty, 0 if not, in 1994</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data originate with the U.S. Department of Labor. The particular
subset used here come from Paul Allison via Statistical Horizons:
<a href="https://statisticalhorizons.com/wp-content/uploads/nlsy.dta">https://statisticalhorizons.com/wp-content/uploads/nlsy.dta</a>
</p>

<hr>
<h2 id='nobs.wbm'>Number of observations used in <code>wbm</code> models</h2><span id='topic+nobs.wbm'></span>

<h3>Description</h3>

<p>This S3 method allows you to retrieve either the number of
observations or number of entities in the data used to fit <code>wbm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wbm'
nobs(object, entities = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.wbm_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="nobs.wbm_+3A_entities">entities</code></td>
<td>
<p>Should <code>nobs</code> return the number of entities in the panel
or the number of rows in the <code>panel_data</code> frame? Default is TRUE, returning
the number of entities.</p>
</td></tr>
<tr><td><code id="nobs.wbm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks, data = wages)
nobs(model)
</code></pre>

<hr>
<h2 id='panel_data'>Create panel data frames</h2><span id='topic+panel_data'></span><span id='topic+as_pdata.frame'></span><span id='topic+as_panel_data'></span><span id='topic+as_panel_data.default'></span><span id='topic+as_panel_data.pdata.frame'></span><span id='topic+as_panel'></span>

<h3>Description</h3>

<p>Format your data for use with <span class="pkg">panelr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel_data(data, id = id, wave = wave, ...)

as_pdata.frame(data)

as_panel_data(data, ...)

## Default S3 method:
as_panel_data(data, id = id, wave = wave, ...)

## S3 method for class 'pdata.frame'
as_panel_data(data, ...)

as_panel(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_data_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="panel_data_+3A_id">id</code></td>
<td>
<p>The name of the column (unquoted) that identifies
participants/entities. A new column will be created called <code>id</code>,
overwriting any column that already has that name.</p>
</td></tr>
<tr><td><code id="panel_data_+3A_wave">wave</code></td>
<td>
<p>The name of the column (unquoted) that identifies
waves or periods. A new column will be created called <code>wave</code>,
overwriting any column that already has that name.</p>
</td></tr>
<tr><td><code id="panel_data_+3A_...">...</code></td>
<td>
<p>Attributes for adding onto this method. See
<code><a href="tibble.html#topic+new_tibble">tibble::new_tibble()</a></code> for a run-through of the logic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panel_data</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)

</code></pre>

<hr>
<h2 id='predict.wbgee'>Predictions and simulations from within-between GEE models</h2><span id='topic+predict.wbgee'></span>

<h3>Description</h3>

<p>These methods facilitate fairly straightforward predictions
from <code>wbgee</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wbgee'
predict(
  object,
  newdata = NULL,
  se.fit = FALSE,
  raw = FALSE,
  type = c("link", "response"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.wbgee_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"lm"</code></p>
</td></tr>
<tr><td><code id="predict.wbgee_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict.  If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.wbgee_+3A_se.fit">se.fit</code></td>
<td>
<p>A switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.wbgee_+3A_raw">raw</code></td>
<td>
<p>Is <code>newdata</code> a <code>geeglm</code> model frame or <code>panel_data</code>? TRUE
indicates a <code>geeglm</code>-style newdata, with all of the extra columns
created by <code>wbgee</code>.</p>
</td></tr>
<tr><td><code id="predict.wbgee_+3A_type">type</code></td>
<td>
<p>Type of prediction (response or model term).  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="predict.wbgee_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("geepack")) {
  data("WageData")
  wages &lt;- panel_data(WageData, id = id, wave = t)
  model &lt;- wbgee(lwage ~ lag(union) + wks, data = wages)
  # By default, assumes you're using the processed data for newdata
  predict(model)
}
</code></pre>

<hr>
<h2 id='predict.wbm'>Predictions and simulations from within-between models</h2><span id='topic+predict.wbm'></span><span id='topic+simulate.wbm'></span>

<h3>Description</h3>

<p>These methods facilitate fairly straightforward predictions
and simulations from <code>wbm</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wbm'
predict(
  object,
  newdata = NULL,
  se.fit = FALSE,
  raw = FALSE,
  use.re.var = FALSE,
  re.form = NULL,
  type = c("link", "response"),
  allow.new.levels = TRUE,
  na.action = na.pass,
  ...
)

## S3 method for class 'wbm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  use.u = FALSE,
  newdata = NULL,
  raw = FALSE,
  newparams = NULL,
  re.form = NA,
  type = c("link", "response"),
  allow.new.levels = FALSE,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.wbm_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_newdata">newdata</code></td>
<td>
<p>data frame for which to evaluate
predictions.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_se.fit">se.fit</code></td>
<td>
<p>Include standard errors with the predictions? Note that
these standard errors by default include only fixed effects variance.
See details for more info. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_raw">raw</code></td>
<td>
<p>Is <code>newdata</code> a <code>merMod</code> model frame or <code>panel_data</code>? TRUE
indicates a <code>merMod</code>-style newdata, with all of the extra columns
created by <code>wbm</code>.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_use.re.var">use.re.var</code></td>
<td>
<p>If <code>se.fit</code> is TRUE, include random effects variance in
standard errors? Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_re.form">re.form</code></td>
<td>
<p>(formula, <code>NULL</code>, or <code>NA</code>) specify which random effects to condition on when predicting.  If <code>NULL</code>,
include all random effects; if <code>NA</code> or <code>~0</code>,
include no random effects.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_type">type</code></td>
<td>
<p>character string - either <code>"link"</code>, the default, or
<code>"response"</code> indicating the type of prediction object returned.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>logical if new levels (or NA values) in
<code>newdata</code> are allowed. If FALSE (default), such new values in
<code>newdata</code> will trigger an error; if TRUE, then the prediction
will use the unconditional (population-level) values for data with
previously unobserved levels (or NAs).</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_na.action">na.action</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> determining what should be done
with missing values for fixed effects in <code>newdata</code>.
The default is to predict <code>NA</code>: see <code><a href="stats.html#topic+na.pass">na.pass</a></code>.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_...">...</code></td>
<td>
<p>When <code>boot</code> and <code>se.fit</code> are TRUE, any additional arguments are
passed to <code>lme4::bootMer()</code>.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_nsim">nsim</code></td>
<td>
<p>positive integer scalar - the number of responses to simulate.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_seed">seed</code></td>
<td>
<p>an optional seed to be used in <code><a href="base.html#topic+set.seed">set.seed</a></code>
immediately before the simulation so as to generate a reproducible sample.</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_use.u">use.u</code></td>
<td>
<p>(logical) if <code>TRUE</code>, generate a simulation
conditional on the current random-effects estimates; if <code>FALSE</code>
generate new Normally distributed random-effects values. (Redundant
with <code>re.form</code>, which is preferred: <code>TRUE</code> corresponds to
<code>re.form = NULL</code> (condition on all random effects), while
<code>FALSE</code> corresponds to <code>re.form = ~0</code> (condition on none
of the random effects).)</p>
</td></tr>
<tr><td><code id="predict.wbm_+3A_newparams">newparams</code></td>
<td>
<p>new parameters to use in evaluating predictions,
specified as in the <code>start</code> parameter for <code><a href="lme4.html#topic+lmer">lmer</a></code> or
<code><a href="lme4.html#topic+glmer">glmer</a></code> &ndash; a list with components <code>theta</code> and
<code>beta</code> and (for LMMs or GLMMs that estimate a scale parameter)
<code>sigma</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks, data = wages)
# By default, assumes you're using the processed data for newdata
predict(model)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+filter'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+compound">%&lt;&gt;%</a></code>, <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='summary.panel_data'>Summarize panel data frames</h2><span id='topic+summary.panel_data'></span>

<h3>Description</h3>

<p><code>summary</code> method for <code>panel_data</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'panel_data'
summary(object, ..., by.wave = TRUE, by.id = FALSE, skim_with = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.panel_data_+3A_object">object</code></td>
<td>
<p>A <code>panel_data</code> frame.</p>
</td></tr>
<tr><td><code id="summary.panel_data_+3A_...">...</code></td>
<td>
<p>Optionally, unquoted variable names/expressions separated by
commas to be passed to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. Otherwise, all columns are
included.</p>
</td></tr>
<tr><td><code id="summary.panel_data_+3A_by.wave">by.wave</code></td>
<td>
<p>(if <code>skimr</code> is installed) Separate descriptives by wave?
Default is TRUE.</p>
</td></tr>
<tr><td><code id="summary.panel_data_+3A_by.id">by.id</code></td>
<td>
<p>(if <code>skimr</code> is installed) Separate descriptives by entity?
Default is FALSE. Be careful if you have a large number of entities as
the output will be massive.</p>
</td></tr>
<tr><td><code id="summary.panel_data_+3A_skim_with">skim_with</code></td>
<td>
<p>A closure from <code><a href="skimr.html#topic+skim_with">skimr::skim_with()</a></code>. If set, skim</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
summary(wages, lwage, exp, wks)

</code></pre>

<hr>
<h2 id='teen_poverty'>National Longitudinal Survey of Youth teenage women poverty data</h2><span id='topic+teen_poverty'></span>

<h3>Description</h3>

<p>These data come from the years 1979-1983 in the National Longitudinal
Survey of Youth, with information about 1141 teenage women. These data are in
the &quot;wide&quot; format for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teen_poverty
</code></pre>


<h3>Format</h3>

<p>A data frame with 1141 rows and 28 variables:
</p>

<dl>
<dt>id</dt><dd><p>Unique identifier for the respondent</p>
</dd>
<dt>age</dt><dd><p>Age at first interview</p>
</dd>
<dt>black</dt><dd><p>1 if subject is black, 0 if not</p>
</dd>
<dt>pov1</dt><dd><p>1 if subject is in poverty, 0 if not, at time 1</p>
</dd>
<dt>pov2</dt><dd><p>1 if subject is in poverty, 0 if not, at time 2</p>
</dd>
<dt>pov3</dt><dd><p>1 if subject is in poverty, 0 if not, at time 3</p>
</dd>
<dt>pov4</dt><dd><p>1 if subject is in poverty, 0 if not, at time 4</p>
</dd>
<dt>pov5</dt><dd><p>1 if subject is in poverty, 0 if not, at time 5</p>
</dd>
<dt>mother1</dt><dd><p>1 if subject has had a child, 0 if not, at time 1</p>
</dd>
<dt>mother2</dt><dd><p>1 if subject has had a child, 0 if not, at time 2</p>
</dd>
<dt>mother3</dt><dd><p>1 if subject has had a child, 0 if not, at time 3</p>
</dd>
<dt>mother4</dt><dd><p>1 if subject has had a child, 0 if not, at time 4</p>
</dd>
<dt>mother5</dt><dd><p>1 if subject has had a child, 0 if not, at time 5</p>
</dd>
<dt>spouse1</dt><dd><p>1 if subject lives with a spouse, 0 if not, at time 1</p>
</dd>
<dt>spouse2</dt><dd><p>1 if subject lives with a spouse, 0 if not, at time 2</p>
</dd>
<dt>spouse3</dt><dd><p>1 if subject lives with a spouse, 0 if not, at time 3</p>
</dd>
<dt>spouse4</dt><dd><p>1 if subject lives with a spouse, 0 if not, at time 4</p>
</dd>
<dt>spouse5</dt><dd><p>1 if subject lives with a spouse, 0 if not, at time 5</p>
</dd>
<dt>inschool1</dt><dd><p>1 if subject is in school, 0 if not, at time 1</p>
</dd>
<dt>inschool2</dt><dd><p>1 if subject is in school, 0 if not, at time 2</p>
</dd>
<dt>inschool3</dt><dd><p>1 if subject is in school, 0 if not, at time 3</p>
</dd>
<dt>inschool4</dt><dd><p>1 if subject is in school, 0 if not, at time 4</p>
</dd>
<dt>inschool5</dt><dd><p>1 if subject is in school, 0 if not, at time 5</p>
</dd>
<dt>hours1</dt><dd><p>Hours worked during the week of the survey, at time 1</p>
</dd>
<dt>hours2</dt><dd><p>Hours worked during the week of the survey, at time 2</p>
</dd>
<dt>hours3</dt><dd><p>Hours worked during the week of the survey, at time 3</p>
</dd>
<dt>hours4</dt><dd><p>Hours worked during the week of the survey, at time 4</p>
</dd>
<dt>hours5</dt><dd><p>Hours worked during the week of the survey, at time 5</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data originate with the U.S. Department of Labor. The particular
subset used here come from Paul Allison via Statistical Horizons:
<a href="https://statisticalhorizons.com/wp-content/uploads/teenpov.dta">https://statisticalhorizons.com/wp-content/uploads/teenpov.dta</a>
</p>

<hr>
<h2 id='tidy.asym'>Tidy methods for <code>fdm</code> and <code>asym</code> models</h2><span id='topic+tidy.asym'></span><span id='topic+tidy.fdm'></span><span id='topic+glance.fdm'></span>

<h3>Description</h3>

<p><code>panelr</code> provides methods to access <code>fdm</code> and <code>asym</code> data in a
tidy format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asym'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'fdm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'fdm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.asym_+3A_x">x</code></td>
<td>
<p>An <code>fdm</code> or <code>asym</code> object.</p>
</td></tr>
<tr><td><code id="tidy.asym_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.asym_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval if
<code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1. Defaults
to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.asym_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("clubSandwich")) {
  data("WageData")
  wages &lt;- panel_data(WageData, id = id, wave = t)
  model &lt;- fdm(lwage ~ wks + union, data = wages)
  if (requireNamespace("generics")) {
    generics::tidy(model)
  }
}

</code></pre>

<hr>
<h2 id='tidy.asym_gee'>Tidy methods for <code>wbgee</code> models</h2><span id='topic+tidy.asym_gee'></span><span id='topic+tidy.wbgee'></span><span id='topic+glance.wbgee'></span>

<h3>Description</h3>

<p><code>panelr</code> provides methods to access <code>wbgee</code> data in a tidy format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asym_gee'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'wbgee'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'wbgee'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.asym_gee_+3A_x">x</code></td>
<td>
<p>A <code>wbgee</code> object.</p>
</td></tr>
<tr><td><code id="tidy.asym_gee_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.asym_gee_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval if
<code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1. Defaults
to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.asym_gee_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("geepack")) {
  data("WageData")
  wages &lt;- panel_data(WageData, id = id, wave = t)
  model &lt;- wbgee(lwage ~ lag(union) + wks, data = wages)
  if (requireNamespace("generics")) {
    generics::tidy(model)
  }
}
</code></pre>

<hr>
<h2 id='tidy.wbm'>Tidy methods for <code>wbm</code> models</h2><span id='topic+tidy.wbm'></span><span id='topic+glance.wbm'></span><span id='topic+glance.summ.wbm'></span><span id='topic+tidy.summ.wbm'></span>

<h3>Description</h3>

<p><code>panelr</code> provides methods to access <code>wbm</code> data in a tidy format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wbm'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  effects = c("fixed", "ran_pars"),
  conf.method = "Wald",
  ran_prefix = NULL,
  ...
)

## S3 method for class 'wbm'
glance(x, ...)

## S3 method for class 'summ.wbm'
glance(x, ...)

## S3 method for class 'summ.wbm'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.wbm_+3A_x">x</code></td>
<td>
<p>An object of class <code>merMod</code>, such as those from <code>lmer</code>,
<code>glmer</code>, or <code>nlmer</code></p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_conf.int">conf.int</code></td>
<td>
<p>whether to include a confidence interval</p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_effects">effects</code></td>
<td>
<p>A character vector including one or more of &quot;fixed&quot;
(fixed-effect parameters); &quot;ran_pars&quot; (variances and covariances or
standard deviations and correlations of random effect terms);
&quot;ran_vals&quot; (conditional modes/BLUPs/latent variable estimates); or
&quot;ran_coefs&quot; (predicted parameter values for each group, as returned by
<code>coef.merMod</code>.</p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_conf.method">conf.method</code></td>
<td>
<p>method for computing confidence intervals (see <code>lme4::confint.merMod</code>)</p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_ran_prefix">ran_prefix</code></td>
<td>
<p>a length-2 character vector specifying the strings to use as prefixes for self- (variance/standard deviation) and cross- (covariance/correlation) random effects terms</p>
</td></tr>
<tr><td><code id="tidy.wbm_+3A_...">...</code></td>
<td>
<p>Additional arguments (passed to <code>confint.merMod</code> for <code>tidy</code>; <code>augment_columns</code> for <code>augment</code>; ignored for <code>glance</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks, data = wages)
if (requireNamespace("broom.mixed")) {
  broom.mixed::tidy(model)
}
</code></pre>

<hr>
<h2 id='unpanel'>Convert panel_data to regular data frame</h2><span id='topic+unpanel'></span>

<h3>Description</h3>

<p>This convenience function removes the special features of
<code>panel_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpanel(panel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpanel_+3A_panel">panel</code></td>
<td>
<p>A <code>panel_data</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ungrouped <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData") 
wages &lt;- panel_data(WageData, id = id, wave = t)
wages_non_panel &lt;- unpanel(wages)
</code></pre>

<hr>
<h2 id='WageData'>Earnings data from the Panel Study of Income Dynamics</h2><span id='topic+WageData'></span>

<h3>Description</h3>

<p>These data come from the years 1976-1982 in the Panel Study of
Income Dynamics (PSID), with information about the demographics
and earnings of 595 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WageData
</code></pre>


<h3>Format</h3>

<p>A data frame with 4165 rows and 14 variables:
</p>

<dl>
<dt>id</dt><dd><p>Unique identifier for each survey respondent</p>
</dd>
<dt>t</dt><dd><p>A number corresponding to each wave of the survey, 1 through 7</p>
</dd>
<dt>wks</dt><dd><p>Weeks worked in the past year</p>
</dd>
<dt>lwage</dt><dd><p>Natural logarithm of earnings in the past year</p>
</dd>
<dt>union</dt><dd><p>Binary indicator whether respondent is a member of union
(1 = union member)</p>
</dd>
<dt>ms</dt><dd><p>Binary indicator for whether respondent is married (1 = married)</p>
</dd>
<dt>occ</dt><dd><p>Binary indicator for whether respondent is a blue collar (= 0) or
white collar (= 1) worker.</p>
</dd>
<dt>ind</dt><dd><p>Binary indicator for whether respondent works in
manufacturing (= 1)</p>
</dd>
<dt>south</dt><dd><p>Binary indicator for whether respondent lives in the South (= 1)</p>
</dd>
<dt>smsa</dt><dd><p>Binary indicator for whether respondent lives in a
standard metropolitan area (SMSA; = 1)</p>
</dd>
<dt>fem</dt><dd><p>Binary indicator for whether respondent is female (= 1)</p>
</dd>
<dt>blk</dt><dd><p>Binary indicator for whether respondent is African-American (= 1)</p>
</dd>
<dt>ed</dt><dd><p>Years of education</p>
</dd>
<dt>exp</dt><dd><p>Years in the workforce.</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data are all over the place. This particular file was
downloaded from Richard Williams at
<a href="https://www3.nd.edu/~rwilliam/statafiles/wages.dta">https://www3.nd.edu/~rwilliam/statafiles/wages.dta</a>, though he doesn't
claim ownership of these data.
</p>
<p>The data were shared as a supplement to Baltagi (2005) at
<a href="https://www.wiley.com/legacy/wileychi/baltagi3e/data_sets.html">https://www.wiley.com/legacy/wileychi/baltagi3e/data_sets.html</a>.
</p>
<p>They were also shared as a supplement to Greene (2008) at
<a href="https://pages.stern.nyu.edu/~wgreene/Text/Edition6/tablelist6.htm">https://pages.stern.nyu.edu/~wgreene/Text/Edition6/tablelist6.htm</a>.
</p>
<p>The data are also available in numerous other locations, including in
slightly different formats as <code><a href="plm.html#topic+Wages">Wages</a></code> in the <span class="pkg">plm</span>
package and <code><a href="AER.html#topic+PSID7682">PSID7682</a></code> in the <code>AER</code> package.
</p>

<hr>
<h2 id='wbgee'>Panel regression models fit with GEE</h2><span id='topic+wbgee'></span>

<h3>Description</h3>

<p>Fit &quot;within-between&quot; and several other regression variants
for panel data via generalized estimating equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbgee(
  formula,
  data,
  id = NULL,
  wave = NULL,
  model = "w-b",
  cor.str = c("ar1", "exchangeable", "unstructured"),
  detrend = FALSE,
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 2,
  family = gaussian,
  balance.correction = FALSE,
  dt.random = TRUE,
  dt.order = 1,
  weights = NULL,
  offset = NULL,
  interaction.style = c("double-demean", "demean", "raw"),
  scale = FALSE,
  scale.response = FALSE,
  n.sd = 1,
  calc.fit.stats = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wbgee_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_model">model</code></td>
<td>
<p>One of <code>"w-b"</code>, <code>"within"</code>, <code>"between"</code>,
<code>"contextual"</code>. See details for more on these options.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_cor.str">cor.str</code></td>
<td>
<p>Any correlation structure accepted by <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.
Default is &quot;ar1&quot;, most useful alternative is &quot;exchangeable&quot;. &quot;unstructured&quot;
may cause problems due to its computational complexity.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_detrend">detrend</code></td>
<td>
<p>Adjust within-subject effects for trends in the predictors?
Default is FALSE, but some research suggests this is a better idea
(see Curran and Bauer (2011) reference).</p>
</td></tr>
<tr><td><code id="wbgee_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_wave.factor">wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_family">family</code></td>
<td>
<p>Use this to specify GLM link families. Default is <code>gaussian</code>,
the linear model.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_balance.correction">balance.correction</code></td>
<td>
<p>Correct between-subject effects for unbalanced
panels following the procedure in Curran and Bauer (2011)? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_dt.random">dt.random</code></td>
<td>
<p>Should the detrending procedure be performed with a
random slope for each entity? Default is TRUE but for short panels
FALSE may be better, fitting a trend for all entities.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_dt.order">dt.order</code></td>
<td>
<p>If detrending using <code>detrend</code>, what order polynomial
would you like to specify for the relationship between time and the
predictors? Default is 1, a linear model.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_interaction.style">interaction.style</code></td>
<td>
<p>The best way to calculate interactions in within
models is in some dispute. The conventional way (<code>"demean"</code>) is to first
calculate the product of the variables involved in the interaction before
those variables have their means subtracted and then subtract the mean of
the product from the product term (see Schunk and Perales (2017)).
Giesselmann and Schmidt-Catran (2020) show this method carries
between-entity differences that within models are designed to model out.
They suggest an alternate method (<code>"double-demean"</code>) in which the product
term is first calculated using the de-meaned lower-order variables and
then the subject means are subtracted from this product term. Another
option is to simply use the product term of the de-meaned variables
(<code>"raw"</code>), but Giesselmann and Schmidt-Catran (2020) show this method
biases the results towards zero effect. The default is <code>"double-demean"</code>
but if emulating other software is the goal, <code>"demean"</code> might be
preferred.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, reports standardized regression
coefficients by scaling and mean-centering input data (the latter can be
changed via the <code>scale.only</code> argument). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_scale.response">scale.response</code></td>
<td>
<p>Should the response variable also be rescaled? Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_n.sd">n.sd</code></td>
<td>
<p>How many standard deviations should you divide by for
standardization? Default is 1, though some prefer 2.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_calc.fit.stats">calc.fit.stats</code></td>
<td>
<p>Calculate fit statistics? Default is TRUE, but
occasionally poor-fitting models might trip up here.</p>
</td></tr>
<tr><td><code id="wbgee_+3A_...">...</code></td>
<td>
<p>Additional arguments provided to <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the documentation for <code><a href="#topic+wbm">wbm()</a></code> for many details on formula syntax and
other arguments.
</p>


<h3>Value</h3>

<p>A <code>wbgee</code> object, which inherits from <code>geeglm</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob A. Long
</p>


<h3>References</h3>

<p>Allison, P. (2009). <em>Fixed effects regression models</em>.
Thousand Oaks, CA: SAGE Publications.
https://doi.org/10.4135/9781412993869.d33
</p>
<p>Bell, A., &amp; Jones, K. (2015). Explaining fixed effects: Random effects
modeling of time-series cross-sectional and panel data.
<em>Political Science Research and Methods</em>, <em>3</em>, 133–153.
https://doi.org/10.1017/psrm.2014.7
</p>
<p>Curran, P. J., &amp; Bauer, D. J. (2011). The disaggregation of within-person
and between-person effects in longitudinal models of change.
<em>Annual Review of Psychology</em>, <em>62</em>, 583–619.
https://doi.org/10.1146/annurev.psych.093008.100356
</p>
<p>Giesselmann, M., &amp; Schmidt-Catran, A. W. (2020). Interactions in fixed
effects regression models. <em>Sociological Methods &amp; Research</em>, 1–28.
https://doi.org/10.1177/0049124120914934
</p>
<p>McNeish, D. (2019). Effect partitioning in cross-sectionally clustered data
without multilevel models. <em>Multivariate Behavioral Research</em>,
Advance online publication. https://doi.org/10.1080/00273171.2019.1602504
</p>
<p>McNeish, D., Stapleton, L. M., &amp; Silverman, R. D. (2016). On the unnecessary
ubiquity of hierarchical linear modeling. <em>Psychological Methods</em>, <em>22</em>,
114-140. https://doi.org/10.1037/met0000078
</p>
<p>Schunck, R., &amp; Perales, F. (2017). Within- and between-cluster effects in
generalized linear mixed models: A discussion of approaches and the
<code>xthybrid</code> command. <em>The Stata Journal</em>, <em>17</em>, 89–115.
https://doi.org/10.1177/1536867X1701700106
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("geepack")) {
  data("WageData")
  wages &lt;- panel_data(WageData, id = id, wave = t)
  model &lt;- wbgee(lwage ~ lag(union) + wks | blk + fem | blk * lag(union),
           data = wages)
  summary(model)
}

</code></pre>

<hr>
<h2 id='wbm'>Panel regression models fit via multilevel modeling</h2><span id='topic+wbm'></span>

<h3>Description</h3>

<p>Fit &quot;within-between&quot; and several other regression variants
for panel data in a multilevel modeling framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbm(
  formula,
  data,
  id = NULL,
  wave = NULL,
  model = "w-b",
  detrend = FALSE,
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 2,
  family = gaussian,
  balance.correction = FALSE,
  dt.random = TRUE,
  dt.order = 1,
  pR2 = TRUE,
  pvals = TRUE,
  t.df = "Satterthwaite",
  weights = NULL,
  offset = NULL,
  interaction.style = c("double-demean", "demean", "raw"),
  scale = FALSE,
  scale.response = FALSE,
  n.sd = 1,
  dt_random = dt.random,
  dt_order = dt.order,
  balance_correction = balance.correction,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wbm_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="wbm_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbm_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbm_+3A_model">model</code></td>
<td>
<p>One of <code>"w-b"</code>, <code>"within"</code>, <code>"between"</code>,
<code>"contextual"</code>. See details for more on these options.</p>
</td></tr>
<tr><td><code id="wbm_+3A_detrend">detrend</code></td>
<td>
<p>Adjust within-subject effects for trends in the predictors?
Default is FALSE, but some research suggests this is a better idea
(see Curran and Bauer (2011) reference).</p>
</td></tr>
<tr><td><code id="wbm_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbm_+3A_wave.factor">wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td></tr>
<tr><td><code id="wbm_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="wbm_+3A_family">family</code></td>
<td>
<p>Use this to specify GLM link families. Default is <code>gaussian</code>,
the linear model.</p>
</td></tr>
<tr><td><code id="wbm_+3A_balance.correction">balance.correction</code></td>
<td>
<p>Correct between-subject effects for unbalanced
panels following the procedure in Curran and Bauer (2011)? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbm_+3A_dt.random">dt.random</code></td>
<td>
<p>Should the detrending procedure be performed with a
random slope for each entity? Default is TRUE but for short panels
FALSE may be better, fitting a trend for all entities.</p>
</td></tr>
<tr><td><code id="wbm_+3A_dt.order">dt.order</code></td>
<td>
<p>If detrending using <code>detrend</code>, what order polynomial
would you like to specify for the relationship between time and the
predictors? Default is 1, a linear model.</p>
</td></tr>
<tr><td><code id="wbm_+3A_pr2">pR2</code></td>
<td>
<p>Calculate a pseudo R-squared? Default is TRUE, but in some cases
may cause errors or add computation time.</p>
</td></tr>
<tr><td><code id="wbm_+3A_pvals">pvals</code></td>
<td>
<p>Calculate p values? Default is TRUE but for some complex
linear models, this may take a long time to compute using the <code>pbkrtest</code>
package.</p>
</td></tr>
<tr><td><code id="wbm_+3A_t.df">t.df</code></td>
<td>
<p>For linear models only. User may choose the method for
calculating the degrees of freedom in t-tests. Default is
<code>"Satterthwaite"</code>, but you may also choose <code>"Kenward-Roger"</code>.
Kenward-Roger standard errors/degrees of freedom requires the <code>pbkrtest</code>
package.</p>
</td></tr>
<tr><td><code id="wbm_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="wbm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_interaction.style">interaction.style</code></td>
<td>
<p>The best way to calculate interactions in within
models is in some dispute. The conventional way (<code>"demean"</code>) is to first
calculate the product of the variables involved in the interaction before
those variables have their means subtracted and then subtract the mean of
the product from the product term (see Schunk and Perales (2017)).
Giesselmann and Schmidt-Catran (2020) show this method carries
between-entity differences that within models are designed to model out.
They suggest an alternate method (<code>"double-demean"</code>) in which the product
term is first calculated using the de-meaned lower-order variables and
then the subject means are subtracted from this product term. Another
option is to simply use the product term of the de-meaned variables
(<code>"raw"</code>), but Giesselmann and Schmidt-Catran (2020) show this method
biases the results towards zero effect. The default is <code>"double-demean"</code>
but if emulating other software is the goal, <code>"demean"</code> might be
preferred.</p>
</td></tr>
<tr><td><code id="wbm_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code>, reports standardized regression
coefficients by scaling and mean-centering input data (the latter can be
changed via the <code>scale.only</code> argument). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_scale.response">scale.response</code></td>
<td>
<p>Should the response variable also be rescaled? Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_n.sd">n.sd</code></td>
<td>
<p>How many standard deviations should you divide by for
standardization? Default is 1, though some prefer 2.</p>
</td></tr>
<tr><td><code id="wbm_+3A_dt_random">dt_random</code></td>
<td>
<p>Deprecated. Equivalent to <code>dt.random</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_dt_order">dt_order</code></td>
<td>
<p>Deprecated. Equivalent to <code>dt.order</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_balance_correction">balance_correction</code></td>
<td>
<p>Deprecated. Equivalent to <code>balance.correction</code>.</p>
</td></tr>
<tr><td><code id="wbm_+3A_...">...</code></td>
<td>
<p>Additional arguments provided to <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>,
<code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code>, or <code><a href="lme4.html#topic+glmer.nb">lme4::glmer.nb()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Formula syntax</strong>
</p>
<p>The within-between models, and multilevel panel models more generally,
distinguish between time-varying and time-invariant predictors. These are,
as they sound, variables that are either measured repeatedly (in every wave)
in the case of time-varying predictors or only once in the case of
time-invariant predictors. You need to specify these separately in the
formula to tell the model which variables you expect to change over time and
which will not. The primary way of doing so is via the <code>|</code> operator.
</p>
<p>As an example, we can look at the <a href="#topic+WageData">WageData</a> included in this
package. We will create a model that predicts the logarithm of the
individual's wages (<code>lwage</code>) with their union status (<code>union</code>), which can
change over time, and their race (<code>blk</code>; dichotomized as black or
non-black),
which does not change throughout the period of study. Our formula will look
like this:
</p>
<p><code>lwage ~ union | blk</code>
</p>
<p>Put time-varying variables before the first <code>|</code> and time-invariant
variables afterwards. You can specify lags like <code>lag(union)</code> for time-varying
variables; for more than 1 lag, include the number: <code>lag(union, 2)</code>.
</p>
<p>After the first <code>|</code> go the time-invariant variables. Note that if you put a
time-varying variable here, what you get is the observed value rather than
one adjusted to isolate within-entity effects. You may also take a
time-varying variable &mdash; let's say weeks worked (<code>wks</code>) &mdash; and use
<code>imean(wks)</code> to include the individual's mean across all waves as a
predictor while omitting the per-wave measures.
</p>
<p>There is also a place for a second <code>|</code>. Here you can specify cross-level
interactions (within-level interactions can be specified here as well).
If I wanted the interaction term for <code>union</code> and <code>blk</code> &mdash; to see whether
the effect of union status depended on one's race &mdash; I would specify the
formula this way:
</p>
<p><code>lwage ~ union | blk | union * blk</code>
</p>
<p>Another use for the post-second <code>|</code> section of the formula is for changing
the random effects specification. By default, only a random intercept is
specified in the call to <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code>/<code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code>. If you would like
to specify other random slopes, include them here using the typical <code>lme4</code>
syntax:
</p>
<p><code>lwage ~ union | blk | (union | id)</code>
</p>
<p>You can also include the wave variable in a random effects term to
specify a latent growth curve model:
</p>
<p><code>lwage ~ union | blk + t | (t | id)</code>
</p>
<p>One last thing to know: If you want to use the second <code>|</code> but not the first,
put a 1 or 0 after the first, like this:
</p>
<p><code>lwage ~ union | 1 | (union | id)</code>
</p>
<p>Of course, with no time-invariant variables, you need no <code>|</code> operators at
all.
</p>
<p><strong>Models</strong>
</p>
<p>As a convenience, <code>wbm</code> does the heavy lifting for specifying the
within-between model correctly. As a side effect it only
takes a few easy tweaks to specify the model slightly differently. You
can change this behavior with the <code>model</code> argument.
</p>
<p>By default, the argument is <code>"w-b"</code> (equivalently, <code>"within-between"</code>).
This means, for each time-varying predictor, you have two types of
variables in the model. The &quot;between&quot; effect is represented by the
individual-level mean for each entity (e.g., each respondent to a panel
survey). The &quot;within&quot; effect is represented by each wave's measure <em>with
the individual-level mean</em> subtracted. Some refer to this as &quot;de-meaning.&quot;
Thinking in a Hausman test framework &mdash; with the within-between model as
described here &mdash; you should expect the within and between
coefficients to be the same if a random effects model were appropriate.
</p>
<p>The contextual model is very similar (use argument <code>"contextual"</code>). In
some situations, this will be more intuitive to interpret. Empirically,
the only difference compared to the within-between specification is that
the contextual model does not subtract the individual-level means from the
wave-level measures. This also changes the interpretation of the
between-subject coefficients: In the contextual model, they are the
<em>difference</em> between the within and between effects. If there's no
difference between within and between effects, then, the coefficients will
be 0.
</p>
<p>To fit a random effects model, use either <code>"between"</code> or <code>"random"</code>. This
involves no de-meaning and no individual-level means whatsoever.
</p>
<p>To fit a fixed effects model, use either <code>"within"</code> or <code>"fixed"</code>. Any
between-subjects terms in the formula will be ignored. The time-varying
variables will be de-meaned, but the individual-level mean is not included
in the model.
</p>


<h3>Value</h3>

<p>A <code>wbm</code> object, which inherits from <code>merMod</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob A. Long
</p>


<h3>References</h3>

<p>Allison, P. (2009). <em>Fixed effects regression models</em>.
Thousand Oaks, CA: SAGE Publications.
https://doi.org/10.4135/9781412993869.d33
</p>
<p>Bell, A., &amp; Jones, K. (2015). Explaining fixed effects: Random effects
modeling of time-series cross-sectional and panel data.
<em>Political Science Research and Methods</em>, <em>3</em>, 133–153.
https://doi.org/10.1017/psrm.2014.7
</p>
<p>Curran, P. J., &amp; Bauer, D. J. (2011). The disaggregation of within-person
and between-person effects in longitudinal models of change.
<em>Annual Review of Psychology</em>, <em>62</em>, 583–619.
https://doi.org/10.1146/annurev.psych.093008.100356
</p>
<p>Giesselmann, M., &amp; Schmidt-Catran, A. (2018). Interactions in fixed effects
regression models (Discussion Papers of DIW Berlin No. 1748).
<em>DIW Berlin, German Institute for Economic Research</em>.
Retrieved from https://ideas.repec.org/p/diw/diwwpp/dp1748.html
</p>
<p>Schunck, R., &amp; Perales, F. (2017). Within- and between-cluster effects in
generalized linear mixed models: A discussion of approaches and the
<code>xthybrid</code> command. <em>The Stata Journal</em>, <em>17</em>, 89–115.
https://doi.org/10.1177/1536867X1701700106
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wbm_stan">wbm_stan()</a></code> for a Bayesian estimation option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("WageData")
wages &lt;- panel_data(WageData, id = id, wave = t)
model &lt;- wbm(lwage ~ lag(union) + wks | blk + fem | blk * lag(union),
         data = wages)
summary(model)

</code></pre>

<hr>
<h2 id='wbm_stan'>Bayesian estimation of within-between models</h2><span id='topic+wbm_stan'></span>

<h3>Description</h3>

<p>A near-equivalent of <code><a href="#topic+wbm">wbm()</a></code> that instead uses Stan,
via <span class="pkg">rstan</span> and <span class="pkg">brms</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbm_stan(
  formula,
  data,
  id = NULL,
  wave = NULL,
  model = "w-b",
  detrend = FALSE,
  use.wave = FALSE,
  wave.factor = FALSE,
  min.waves = 2,
  model.cor = FALSE,
  family = gaussian,
  fit_model = TRUE,
  balance.correction = FALSE,
  dt.random = TRUE,
  dt.order = 1,
  chains = 3,
  iter = 2000,
  scale = FALSE,
  save_ranef = FALSE,
  interaction.style = c("double-demean", "demean", "raw"),
  weights = NULL,
  offset = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wbm_stan_+3A_formula">formula</code></td>
<td>
<p>Model formula. See details for crucial
info on <code>panelr</code>'s formula syntax.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_data">data</code></td>
<td>
<p>The data, either a <code>panel_data</code> object or <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_id">id</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
individual id column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_wave">wave</code></td>
<td>
<p>If <code>data</code> is not a <code>panel_data</code> object, then the name of the
panel wave column as a string. Otherwise, leave as NULL, the default.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_model">model</code></td>
<td>
<p>One of <code>"w-b"</code>, <code>"within"</code>, <code>"between"</code>,
<code>"contextual"</code>. See details for more on these options.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_detrend">detrend</code></td>
<td>
<p>Adjust within-subject effects for trends in the predictors?
Default is FALSE, but some research suggests this is a better idea
(see Curran and Bauer (2011) reference).</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_use.wave">use.wave</code></td>
<td>
<p>Should the wave be included as a predictor? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_wave.factor">wave.factor</code></td>
<td>
<p>Should the wave variable be treated as an unordered
factor instead of continuous? Default is FALSE.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_min.waves">min.waves</code></td>
<td>
<p>What is the minimum number of waves an individual must
have participated in to be included in the analysis? Default is <code>2</code> and
any valid number is accepted. <code>"all"</code> is also acceptable if you want to
include only complete panelists.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_model.cor">model.cor</code></td>
<td>
<p>Do you want to model residual autocorrelation?
This is often appropriate for linear models (<code>family = gaussian</code>).
Default is FALSE to be consistent with <code><a href="#topic+wbm">wbm()</a></code>, reduce
runtime, and avoid warnings for non-linear models.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_family">family</code></td>
<td>
<p>Use this to specify GLM link families. Default is <code>gaussian</code>,
the linear model.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_fit_model">fit_model</code></td>
<td>
<p>Fit the model? Default is TRUE. If FALSE, only the model
code is returned.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_balance.correction">balance.correction</code></td>
<td>
<p>Correct between-subject effects for unbalanced
panels following the procedure in Curran and Bauer (2011)? Default is
FALSE.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_dt.random">dt.random</code></td>
<td>
<p>Should the detrending procedure be performed with a
random slope for each entity? Default is TRUE but for short panels
FALSE may be better, fitting a trend for all entities.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_dt.order">dt.order</code></td>
<td>
<p>If detrending using <code>detrend</code>, what order polynomial
would you like to specify for the relationship between time and the
predictors? Default is 1, a linear model.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_chains">chains</code></td>
<td>
<p>How many Markov chains should be used? Default is 3, to leave
you with one unused thread if you're on a typical dual-core machine.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_iter">iter</code></td>
<td>
<p>How many iterations, including warmup? Default is 2000, leaving
1000 per chain after warmup. For some models and data, you may need quite
a few more.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_scale">scale</code></td>
<td>
<p>Standardize predictors? This can speed up model fit. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_save_ranef">save_ranef</code></td>
<td>
<p>Save random effect estimates? This can be crucial for
predicting from the model and for certain post-estimation procedures.
On the other hand, it drastically increases the size of the resulting
model. Default is FALSE.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_interaction.style">interaction.style</code></td>
<td>
<p>The best way to calculate interactions in within
models is in some dispute. The conventional way (<code>"demean"</code>) is to first
calculate the product of the variables involved in the interaction before
those variables have their means subtracted and then subtract the mean of
the product from the product term (see Schunk and Perales (2017)).
Giesselmann and Schmidt-Catran (2020) show this method carries
between-entity differences that within models are designed to model out.
They suggest an alternate method (<code>"double-demean"</code>) in which the product
term is first calculated using the de-meaned lower-order variables and
then the subject means are subtracted from this product term. Another
option is to simply use the product term of the de-meaned variables
(<code>"raw"</code>), but Giesselmann and Schmidt-Catran (2020) show this method
biases the results towards zero effect. The default is <code>"double-demean"</code>
but if emulating other software is the goal, <code>"demean"</code> might be
preferred.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_weights">weights</code></td>
<td>
<p>If using weights, either the name of the column in the data
that contains the weights or a vector of the weights.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="wbm_stan_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="brms.html#topic+brm">brms::brm()</a></code>. This can include
specification of priors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+wbm">wbm()</a></code> for details on the formula syntax, model types,
and some other stuff.
</p>


<h3>Value</h3>

<p>A <code>wbm_stan</code> object, which is a list containing a <code>model</code> object
with the <code>brm</code> model and a <code>stan_code</code> object with the model code.
</p>
<p>If <code>fit_model = FALSE</code>, instead a list is returned containing a <code>stan_code</code>
object and a <code>stan_data</code> object, leaving you with the tools you need to
run the model yourself using <code>rstan</code>.
</p>


<h3>Author(s)</h3>

<p>Jacob A. Long
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wbm">wbm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data("WageData")
 wages &lt;- panel_data(WageData, id = id, wave = t)
 model &lt;- wbm_stan(lwage ~ lag(union) + wks | blk + fem | blk * lag(union),
           data = wages, chains = 1, iter = 2000)
 summary(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='wbm-class'>Within-Between Model (<code>wbm</code>) class</h2><span id='topic+wbm-class'></span>

<h3>Description</h3>

<p>Models fit using <code><a href="#topic+wbm">wbm()</a></code> return values of this class, which
inherits from <code><a href="lme4.html#topic+merMod-class">merMod-class</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call_info</code></dt><dd><p>A list of metadata about the arguments used.</p>
</dd>
<dt><code>call</code></dt><dd><p>The actual function call.</p>
</dd>
<dt><code>summ</code></dt><dd><p>The <code><a href="jtools.html#topic+summ">jtools::summ()</a></code> object returned from calling it on the
<code>merMod</code> object.</p>
</dd>
<dt><code>summ_atts</code></dt><dd><p>The attributes of the <code>summ</code> object.</p>
</dd>
<dt><code>orig_data</code></dt><dd><p>The data provided to the <code>data</code> argument in the function
call.</p>
</dd>
</dl>

<hr>
<h2 id='widen_panel'>Convert long panel data to wide format</h2><span id='topic+widen_panel'></span>

<h3>Description</h3>

<p>This function takes <code><a href="#topic+panel_data">panel_data()</a></code> objects as input as converts
them to wide format for use in SEM and other situations when such a format
is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>widen_panel(data, separator = "_", ignore.attributes = FALSE, varying = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="widen_panel_+3A_data">data</code></td>
<td>
<p>The <code>panel_data</code> frame.</p>
</td></tr>
<tr><td><code id="widen_panel_+3A_separator">separator</code></td>
<td>
<p>When the variables are labeled with the wave number,
what should separate the variable name and wave number? By default,
it is &quot;_&quot;. In other words, a variable named <code>var</code> will be
<code>var_1</code>, <code>var_2</code>, and so on in the wide data frame.</p>
</td></tr>
<tr><td><code id="widen_panel_+3A_ignore.attributes">ignore.attributes</code></td>
<td>
<p>If the <code>data</code> was created by <code><a href="#topic+long_panel">long_panel()</a></code>,
it stores information about which variables vary over time and which
are constants. Sometimes, though, this information is not accurate (
it is only based on the wide data's variable names) and you may want to
force this function to check again based on the actual values of the
variables.</p>
</td></tr>
<tr><td><code id="widen_panel_+3A_varying">varying</code></td>
<td>
<p>If you want to skip the checks for whether variables are
varying and specify yourself, as is done with <code><a href="stats.html#topic+reshape">stats::reshape()</a></code>, you
can supply them as a vector here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code><a href="stats.html#topic+reshape">stats::reshape()</a></code>, which is renowned for being
pretty confusing to use. This function automatically detects which of the
variables vary over time and which don't, not appending wave information
to constants.
</p>


<h3>Value</h3>

<p>A data.frame with 1 row per respondent.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+reshape">reshape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wages &lt;- panel_data(WageData, id = id, wave = t)
wide_wages &lt;- widen_panel(wages)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
