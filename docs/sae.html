<!DOCTYPE html><html><head><title>Help for package sae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bxcx'><p>Box-Cox Transformation and its Inverse</p>
</a></li>
<li><a href='#cornsoybean'><p> Corn and soy beans survey and satellite data in 12 counties in Iowa.</p></a></li>
<li><a href='#cornsoybeanmeans'><p>Corn and soy beans mean number of pixels per segment for 12 counties in Iowa.</p></a></li>
<li><a href='#diagonalizematrix'><p>It constructs a block-diagonal matrix.</p></a></li>
<li><a href='#direct'><p>Direct estimators.</p></a></li>
<li><a href='#ebBHF'><p>EB estimators of an indicator with non-sample values of auxiliary variables.</p></a></li>
<li><a href='#eblupBHF'><p>EBLUPs of domain means based on a nested error linear regression model.</p></a></li>
<li><a href='#eblupFH'><p> EBLUPs based on a Fay-Herriot model.</p></a></li>
<li><a href='#eblupSFH'><p> EBLUPs based on a spatial Fay-Herriot model.</p></a></li>
<li><a href='#eblupSTFH'><p>EBLUPs based on a spatio-temporal Fay-Herriot model.</p></a></li>
<li><a href='#grapes'><p> Synthetic data on grape production for the region of Tuscany.</p></a></li>
<li><a href='#grapesprox'><p> Proximity matrix for the spatial Fay-Herriot model.</p></a></li>
<li><a href='#incomedata'><p> Synthetic income data.</p></a></li>
<li><a href='#milk'><p> Data on fresh milk expenditure.</p></a></li>
<li><a href='#mseFH'><p>Mean squared error estimator of the EBLUP under a Fay-Herriot model.</p></a></li>
<li><a href='#mseSFH'><p>Mean squared error estimator of the spatial EBLUP under a spatial Fay-Herriot model.</p></a></li>
<li><a href='#npbmseSFH'><p>Nonparametric bootstrap mean squared error estimator of the spatial EBLUPs under a spatial Fay-Herriot model.</p></a></li>
<li><a href='#pbmseBHF'><p>Parametric bootstrap mean squared error estimators of the EBLUPs of means obtained under a nested error linear regression model.</p></a></li>
<li><a href='#pbmseebBHF'><p>Parametric bootstrap mean squared error estimators of EB estimators.</p></a></li>
<li><a href='#pbmseSFH'><p>Parametric bootstrap mean squared error estimators of the spatial EBLUPs under a spatial Fay-Herriot model.</p></a></li>
<li><a href='#pbmseSTFH'><p>Parametric bootstrap mean squared error estimator of a spatio-temporal Fay-Herriot model.</p></a></li>
<li><a href='#pssynt'><p>Post-stratified synthetic estimators of domain means.</p></a></li>
<li><a href='#sae-package'><p>Small area estimation</p></a></li>
<li><a href='#sizeprov'><p>Domain population sizes.</p></a></li>
<li><a href='#sizeprovage'><p>Domain population sizes by age.</p></a></li>
<li><a href='#sizeprovedu'><p>Domain population sizes by level of education.</p></a></li>
<li><a href='#sizeprovlab'><p>Domain population sizes by labor force status.</p></a></li>
<li><a href='#sizeprovnat'><p>Domain population sizes for Spanish or non Spanish nationality.</p></a></li>
<li><a href='#spacetime'><p> Synthetic area level data with spatial and temporal correlation.</p></a></li>
<li><a href='#spacetimeprox'><p>Proximity matrix for the spatio-temporal Fay-Herriot model.</p></a></li>
<li><a href='#ssd'><p>Sample size dependent estimator.</p></a></li>
<li><a href='#Xoutsamp'><p>Out-of-sample values of auxiliary variables for 5 domains.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Small Area Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Isabel Molina, Yolanda Marhuenda</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yolanda Marhuenda &lt;y.marhuenda@umh.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, MASS, lme4</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for small area estimation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-01 10:55:38 UTC; hp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-01 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bxcx'>Box-Cox Transformation and its Inverse 

</h2><span id='topic+bxcx'></span>

<h3>Description</h3>


<p>Box-Cox or power transformation or its inverse. For lambda!=0, the Box-Cox transformation of x is (x^lambda-1)/lambda, whereas the regular power transformation is simply x^lambda. When lambda=0, it is log in both cases. The inverse of the Box-Cox and the power transform can also be obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bxcx(x, lambda, InverseQ = FALSE, type = "BoxCox")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bxcx_+3A_x">x</code></td>
<td>
<p>a vector or time series</p>
</td></tr>
<tr><td><code id="bxcx_+3A_lambda">lambda</code></td>
<td>
<p>power transformation parameter</p>
</td></tr>
<tr><td><code id="bxcx_+3A_inverseq">InverseQ</code></td>
<td>
<p>if TRUE, the inverse transformation is done</p>
</td></tr>
<tr><td><code id="bxcx_+3A_type">type</code></td>
<td>
<p>either &quot;BoxCox&quot; or &quot;power&quot;</p>
</td></tr>
</table>


<h3>Value</h3>






<p>A vector or time series of the transformed data 
</p>


<h3>Author(s)</h3>


<p>A.I. McLeod. R package <code>FitAR</code>
</p>


<h3>References</h3>


<p>- Box, G.E.P. and Cox, D.R. (1964). An analysis of transformations. Journal of Royal Statistical Society  Series B 26, 211-246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#lambda=0.5
z&lt;-AirPassengers; lambda&lt;-0.5
y&lt;-bxcx(z, lambda)
z2&lt;-bxcx(y, lambda, InverseQ=TRUE)
sum(abs(z2-z))
#
z&lt;-AirPassengers; lambda&lt;-0.0
y&lt;-bxcx(z, lambda)
z2&lt;-bxcx(y, lambda, InverseQ=TRUE)
sum(abs(z2-z))

</code></pre>

<hr>
<h2 id='cornsoybean'> Corn and soy beans survey and satellite data in 12 counties in Iowa.</h2><span id='topic+cornsoybean'></span>

<h3>Description</h3>

<p> Survey and satellite data for corn and soy beans in 12 Iowa counties, obtained from the 1978 June Enumerative Survey of the U.S. Department of Agriculture and from land observatory satellites (LANDSAT) during the 1978 growing season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cornsoybean)</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on the following 5 variables.
</p>

<dl>
<dt><code>County</code>:</dt><dd><p> numeric county code.</p>
</dd>
<dt><code>CornHec</code>:</dt><dd><p> reported hectares of corn from the survey.</p>
</dd>
<dt><code>SoyBeansHec</code>:</dt><dd><p> reported hectares of soy beans from the survey.</p>
</dd>
<dt><code>CornPix</code>:</dt><dd><p> number of pixels of corn in sample segment within county, from satellite data. </p>
</dd>
<dt><code>SoyBeansPix</code>:</dt><dd><p> number of pixels of soy beans in sample segment within county, from satellite data.</p>
</dd>
</dl>



<h3>Source</h3>

 
<p>- Battesse, G.E., Harter, R.M. and Fuller, W.A. (1988). An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data. Journal of the American Statistical Association 83, 28-36. 
</p>

<hr>
<h2 id='cornsoybeanmeans'>Corn and soy beans mean number of pixels per segment for 12 counties in Iowa.</h2><span id='topic+cornsoybeanmeans'></span>

<h3>Description</h3>

<p> County means of number of pixels per segment of corn and soy beans, from satellite data, for 12 counties in Iowa. Population size, sample size and means of auxiliary variables in data set <code><a href="#topic+cornsoybean">cornsoybean</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cornsoybeanmeans)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 6 variables.
</p>

<dl>
<dt><code>CountyIndex</code>:</dt><dd><p> numeric county code.</p>
</dd>
<dt><code>CountyName</code>:</dt><dd><p> name of the county.</p>
</dd>
<dt><code>SampSegments</code>:</dt><dd><p> number of sample segments in the county (sample size).</p>
</dd>
<dt><code>PopnSegments</code>:</dt><dd><p> number of population segments in the county (population size).</p>
</dd>
<dt><code>MeanCornPixPerSeg</code>:</dt><dd><p> mean number of corn pixels per segment in the county.</p>
</dd>
<dt><code>MeanSoyBeansPixPerSeg</code>:</dt><dd><p> mean number of soy beans pixels per segment in the county.</p>
</dd>
</dl>



<h3>Source</h3>

 
<p>- Battesse, G.E., Harter, R.M. and Fuller, W.A. (1988). An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data. Journal of the American Statistical Association 83, 28-36.
</p>

<hr>
<h2 id='diagonalizematrix'>It constructs a block-diagonal matrix.</h2><span id='topic+diagonalizematrix'></span>

<h3>Description</h3>

<p>Using a <code>n*m</code> matrix <code>A</code>, this function constructs a block-diagonal matrix with dimension <code>(n*ntimes) *</code> <code>(m*ntimes)</code>, with all blocks equal to matrix <code>A</code> and the rest of entries equal to <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagonalizematrix(A, ntimes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagonalizematrix_+3A_a">A</code></td>
<td>
<p><code>n*m</code> matrix with the values.</p>
</td></tr>
<tr><td><code id="diagonalizematrix_+3A_ntimes">ntimes</code></td>
<td>
<p>number of times.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(data=c(1,2,3,4,5,6), nrow=3, ncol=2)
diagonalizematrix(X,3)
</code></pre>

<hr>
<h2 id='direct'>Direct estimators.</h2><span id='topic+direct'></span>

<h3>Description</h3>

<p>This function calculates direct estimators of domain means.</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct(y, dom, sweight, domsize, data, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct_+3A_y">y</code></td>
<td>
<p> vector specifying the individual values of the variable for which we want to estimate the domain means. </p>
</td></tr>
<tr><td><code id="direct_+3A_dom">dom</code></td>
<td>
<p> vector or factor (same size as <code>y</code>) with domain codes. </p>
</td></tr>
<tr><td><code id="direct_+3A_sweight">sweight</code></td>
<td>
<p> optional vector (same size as <code>y</code>) with sampling weights. When this argument is not included, by default estimators 
are obtained under simple random sampling (SRS). </p>
</td></tr>
<tr><td><code id="direct_+3A_domsize">domsize</code></td>
<td>
 <p><code>D*2</code> data frame with domain codes in the first column and the corresponding domain population sizes in the second column. This argument is not required when <code>sweight</code> is not included and <code>replace=TRUE</code> (SRS with replacement).</p>
</td></tr>
<tr><td><code id="direct_+3A_data">data</code></td>
<td>
<p> optional data frame containing the variables named in <code>y</code>, <code>dom</code> and <code>sweight</code>. By default the variables are taken from the environment from which <code>direct</code> is called.</p>
</td></tr>
<tr><td><code id="direct_+3A_replace">replace</code></td>
<td>
<p> logical variable with default value <code>FALSE</code> for random sampling without replacement within each domain is considered 
and <code>TRUE</code> for random sampling with replacement within each domain.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>The function returns a data frame of size <code>D*5</code> with the following columns:
</p>
<table>
<tr><td><code>Domain</code></td>
<td>
<p> domain codes in ascending order.</p>
</td></tr>
<tr><td><code>SampSize</code></td>
<td>
<p> domain sample sizes.</p>
</td></tr>
<tr><td><code>Direct</code></td>
<td>
<p> direct estimators of domain means of variable <code>y</code>.</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p> estimated standard deviations of domain direct estimators. If sampling design is SRS or Poisson sampling, estimated variances are unbiased. Otherwise, estimated variances are obtained under the approximation that second order inclusion probabilities are the product of first order inclusion probabilities.</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p> absolute value of percent coefficients of variation of domain direct estimators.</p>
</td></tr>
</table>
<p>Cases with NA values in <code>y</code>, <code>dom</code> or <code>sweight</code> are ignored.

</p>


<h3>References</h3>

<p>- Cochran, W.G. (1977). Sampling techniques. Wiley, New York.
</p>
<p>- Rao, J.N.K. (2003). Small Area Estimation. Wiley, London.
</p>
<p>- Sarndal, C.E., Swensson, B. and Wretman, J. (1992). Model Assisted Survey Sampling. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pssynt">pssynt</a></code> for post-stratified synthetic estimator, <code><a href="#topic+ssd">ssd</a></code> for sample size dependent estimator. 
</p>
<p>In case that the sampling design is known, see packages <code>survey</code> or <code>sampling</code> for more exact variance estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set with synthetic income data for provinces (domains)
data(incomedata)

# Load population sizes of provinces
data(sizeprov)   

# Compute Horvitz-Thompson direct estimator of mean income for each 
# province under random sampling without replacement within each province.
result1 &lt;- direct(y=income, dom=prov, sweight=weight,
                   domsize=sizeprov[,2:3], data=incomedata)
result1

# The same but using province labels as domain codes
result2 &lt;- direct(y=incomedata$income, dom=incomedata$provlab,
                  sweight=incomedata$weight, domsize=sizeprov[,c(1,3)])
result2

# The same, under SRS without replacement within each province.
result3 &lt;- direct(y=income ,dom=provlab, domsize=sizeprov[,c(1,3)],
                  data=incomedata)
result3

# Compute direct estimator of mean income for each province
# under SRS with replacement within each province
result4 &lt;- direct(y=income, dom=provlab, data=incomedata, replace=TRUE)
result4
</code></pre>

<hr>
<h2 id='ebBHF'>EB estimators of an indicator with non-sample values of auxiliary variables.</h2><span id='topic+ebBHF'></span>

<h3>Description</h3>

<p>Fits by REML method the unit level model of Battese, Harter and Fuller (1988) to a transformation of the specified dependent variable by a Box-Cox family or power family and obtains Monte Carlo approximations 
of EB estimators of the specified small area indicators, when the values of auxiliary variables for out-of-sample units are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebBHF(formula, dom, selectdom, Xnonsample, MC = 100, data,
      transform = "BoxCox", lambda = 0, constant = 0, indicator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ebBHF_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The details of model 
specification are given under Details.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_dom">dom</code></td>
<td>
<p><code>n*1</code> vector or factor (same size as <code>y</code> in <code>formula</code>) with domain codes.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_selectdom">selectdom</code></td>
<td>
<p><code>I*1</code> optional vector or factor with the domain codes for which we 
want to estimate the indicators. It must be a subset of the domain codes in <code>dom</code>. 
If this parameter is not included, the unique domain codes included in <code>dom</code> 
are considered.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_xnonsample">Xnonsample</code></td>
<td>
<p>matrix or data frame containing in the first column the domain codes and in the rest of columns the values of each of <code>p</code> auxiliary variables for the out-of-sample units in each selected domain. The domains considered in <code>Xnonsample</code> must contain at least those specified in <code>selectdom</code>.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_mc">MC</code></td>
<td>
<p>number of Monte Carlo replicates for the empirical approximation of the EB estimator. Default value is <code>MC=100</code>.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>dom</code>. By default the variables are taken from the environment from which <code>ebBHF</code> is called.</p>
</td></tr>   
<tr><td><code id="ebBHF_+3A_transform">transform</code></td>
<td>
<p>type of transformation for the dependent variable to be chosen between the <code>"BoxCox"</code> and <code>"power"</code> families so that the dependent variable in <code>formula</code> follows approximately a Normal distribution. Default value is <code>"BoxCox"</code>.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_lambda">lambda</code></td>
<td>
<p>value for the parameter of the family of transformations specified in <code>transform</code>. Default value is <code>0</code>, which gives the log transformation for the two possible families.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_constant">constant</code></td>
<td>
<p>constant added to the dependent variable before doing the transformation, to achieve a distribution close to Normal. Default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="ebBHF_+3A_indicator">indicator</code></td>
<td>
<p>function of the (untransformed) variable on the left hand side of <code>formula</code> that we want to estimate in each domain.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae. 
</p>


<h3>Value</h3>

<p> The function returns a list with the following objects:
</p>
<table>
<tr><td><code>eb</code></td>
<td>
<p>data frame with number of rows equal to number of selected domains,
containing in its columns the domain codes (<code>domain</code>), the EB 
estimators of <code>indicator</code> (<code>eb</code>) and the sample sizes (<code>sampsize</code>). 
For domains with zero sample size, the EB estimators are based on the synthetic regression. For domains in <code>selectdom</code> not included in <code>Xnonsample</code> the EB estimators are NA.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects: 
</p>

<ul>
<li><p><code>summary</code>: summary of the unit level model fitting.
</p>
</li>
<li><p><code>fixed</code>: vector with the estimated values of the fixed regression coefficient.
</p>
</li>
<li><p><code>random</code>: vector with the predicted random effects.
</p>
</li>
<li><p><code>errorvar</code>: estimated model error variance.
</p>
</li>
<li><p><code>refvar</code>: estimated random effects variance.
</p>
</li>
<li><p><code>loglike</code>: log-likelihood.
</p>
</li>
<li><p><code>residuals</code>: vector with raw residuals from the model fit.
</p>
</li></ul>
  
</td></tr> 
</table>
<p>Cases with NA values in <code>formula</code> or <code>dom</code> are ignored. 
</p>


<h3>References</h3>

 
<p>- Molina, I. and Rao, J.N.K. (2010). Small Area Estimation of Poverty Indicators. The Canadian Journal of Statistics 38, 369-385.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+pbmseebBHF">pbmseebBHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(incomedata)         # Load data set
attach(incomedata)

# Construct design matrix for sample elements
Xs &lt;- cbind(age2, age3, age4, age5, nat1, educ1, educ3, labor1, labor2)

# Select the domains to compute EB estimators. 
data(Xoutsamp)
domains &lt;- unique(Xoutsamp[,"domain"])

# Poverty gap indicator
povertyline &lt;- 0.6*median(income)
povertyline                         # 6477.484
povgap &lt;- function(y)     
{
   z &lt;- 6477.484
   result &lt;- mean((y&lt;z) * (z-y) / z) 
   return (result)
}

# Compute EB predictors of poverty gap. The value constant=3600 is selected
# to achieve approximately symmetric residuals.
set.seed(123)
result &lt;- ebBHF(income ~ Xs, dom=prov, selectdom=domains,
                Xnonsample=Xoutsamp, MC=10, constant=3600, indicator=povgap)
result$eb
result$fit$summary
result$fit$fixed
result$fit$random[,1]
result$fit$errorvar
result$fit$refvar
result$fit$loglike
result$fit$residuals[1:10]

detach(incomedata)
</code></pre>

<hr>
<h2 id='eblupBHF'>EBLUPs of domain means based on a nested error linear regression model.</h2><span id='topic+eblupBHF'></span>

<h3>Description</h3>

<p> This function calculates, for selected domains, EBLUPs of domain means based on the 
nested error linear regression model of Battese, Harter and Fuller (1988).</p>


<h3>Usage</h3>

<pre><code class='language-R'>eblupBHF(formula, dom, selectdom, meanxpop, popnsize, method = "REML", data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eblupBHF_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The details of model 
specification are given under Details.</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_dom">dom</code></td>
<td>
<p><code>n*1</code> vector or factor (same size as <code>y</code> in <code>formula</code>) with domain codes.</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_selectdom">selectdom</code></td>
<td>
<p><code>I*1</code> optional vector or factor with the domain codes for which we 
want to estimate the means. It must be a subset of the domain codes in <code>dom</code>. 
If this parameter is not included all the domain codes included in <code>dom</code> 
are considered.</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_meanxpop">meanxpop</code></td>
<td>
<p><code>D*(p+1)</code> data frame with domain codes in the first column. Each remaining column contains the  
population means of each of the <code>p</code> auxiliary variables for the D domains. 
The domains considered in <code>meanxpop</code> must contain those specified in <code>selectdom</code> (D&gt;=I).</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_popnsize">popnsize</code></td>
<td>
<p><code>D*2</code> data frame with domain codes in the first column
and the corresponding domain population sizes in the second column. 
The domains considered in <code>popnsize</code> must contain those specified in <code>selectdom</code> (D&gt;=I).</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_method">method</code></td>
<td>
<p>a character string. If <code>"REML"</code>, the model is fitted by maximizing the restricted 
log-likelihood. If <code>"ML"</code> the log-likelihood is maximized. Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="eblupBHF_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>dom</code>. By default the variables are taken from the environment from which <code>eblupBHF</code> is called.</p>
</td></tr>                
</table>


<h3>Details</h3>

<p>A typical model has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae.
</p>


<h3>Value</h3>

<p> The function returns a list with the following objects:
</p>
<table>
<tr><td><code>eblup</code></td>
<td>
<p>data frame with number of rows equal to number of selected domains (<code>selectdom</code>),
containing in its columns the domain codes (<code>domain</code>) and the EBLUPs 
of the means of selected domains based on the nested error linear regression 
model (<code>eblup</code>). For domains with zero sample size, the EBLUPs are the synthetic regression estimators.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects: 
</p>

<ul>
<li><p><code>summary</code>: summary of the unit level model fitting.
</p>
</li>
<li><p><code>fixed</code>: vector with the estimated values of the fixed regression coefficient.
</p>
</li>
<li><p><code>random</code>: vector with the predicted random effects.
</p>
</li>
<li><p><code>errorvar</code>: estimated model error variance.
</p>
</li>
<li><p><code>refvar</code>: estimated random effects variance.
</p>
</li>
<li><p><code>loglike</code>: log-likelihood.
</p>
</li>
<li><p><code>residuals</code>: vector with raw residuals.
</p>
</li></ul>
  
</td></tr>    
</table>
<p>Cases with NA values in <code>formula</code> or <code>dom</code> are ignored. 
</p>


<h3>References</h3>

 
<p>- Battese, G.E., Harter, R.M. and Fuller, W.A. (1988). An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data, Journal of the American Statistical Association 83, 28-36. 
</p>
<p>- Rao, J.N.K. (2003). Small Area Estimation. New York: John Wiley and Sons.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pbmseBHF">pbmseBHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set for segments (units within domains)
data(cornsoybean)

# Load data set for counties
data(cornsoybeanmeans)
attach(cornsoybeanmeans)

# Construct data frame with county means of auxiliary variables for 
# domains. First column must include the county code
Xmean &lt;- data.frame(CountyIndex, MeanCornPixPerSeg, MeanSoyBeansPixPerSeg)
Popn  &lt;- data.frame(CountyIndex, PopnSegments)

# Compute EBLUPs of county means of corn crop areas for all counties
resultCorn &lt;- eblupBHF(CornHec ~ CornPix + SoyBeansPix, dom=County, 
                       meanxpop=Xmean, popnsize=Popn, data=cornsoybean)
resultCorn$eblup

# Compute EBLUPs of county means of soy beans crop areas for
# a subset of counties using ML method
domains &lt;- c(10,1,5)
resultBean &lt;- eblupBHF(SoyBeansHec ~ CornPix + SoyBeansPix, dom=County, 
                       selectdom=domains, meanxpop=Xmean, popnsize=Popn,
                       method="ML", data=cornsoybean)
resultBean$eblup
resultBean$fit

detach(cornsoybeanmeans)
</code></pre>

<hr>
<h2 id='eblupFH'> EBLUPs based on a Fay-Herriot model.</h2><span id='topic+eblupFH'></span>

<h3>Description</h3>

<p> This function gives the EBLUP (or EB predictor under normality) based on a Fay-Herriot model. Fitting method can be chosen between ML, REML and FH methods.</p>


<h3>Usage</h3>

<pre><code class='language-R'>eblupFH(formula, vardir, method = "REML", MAXITER = 100, PRECISION = 0.0001, 
        B = 0, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eblupFH_+3A_formula">formula</code></td>
<td>
<p> an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model 
specification are given under Details.</p>
</td></tr>
<tr><td><code id="eblupFH_+3A_vardir">vardir</code></td>
<td>
<p> vector containing the <code>D</code> sampling variances of direct estimators for each domain. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="eblupFH_+3A_method">method</code></td>
<td>
<p> type of fitting method, to be chosen between <code>"ML"</code>, <code>"REML"</code> or <code>"FH"</code> methods.</p>
</td></tr>
<tr><td><code id="eblupFH_+3A_maxiter">MAXITER</code></td>
<td>
<p> maximum number of iterations allowed in the Fisher-scoring algorithm.
Default is 100 iterations.</p>
</td></tr>
<tr><td><code id="eblupFH_+3A_precision">PRECISION</code></td>
<td>
<p> convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="eblupFH_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates to calculate the goodness-of-fit measures proposed by Marhuenda et al. (2014). Default value is <code>0</code> indicating that these measures are not calculated.</p>
</td></tr>  
<tr><td><code id="eblupFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>eblupFH</code> is called.</p>
</td></tr>                  
</table>


<h3>Details</h3>

<p>A typical model has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code>  for more details of allowed formulae. 
</p>


<h3>Value</h3>

 
<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>eblup</code></td>
<td>
<p>vector with the values of the estimators for the domains.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects:
</p>

<ul>
<li><p><code>method</code>: type of fitting method applied (<code>"REML"</code>, <code>"ML"</code>or <code>"FH"</code>).
</p>
</li>
<li><p><code>convergence</code>: a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li><p><code>iterations</code>: number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li><p><code>estcoef</code>: a data frame with the estimated model coefficients in the first column (<code>beta</code>), 
their asymptotic standard errors in the second column (<code>std.error</code>), 
the <code class="reqn">t</code> statistics in the third column <code>(tvalue)</code> and the p-values of the significance 
of each coefficient in last column <code>(pvalue)</code>.
</p>
</li>
<li><p><code>refvar</code>: estimated random effects variance.
</p>
</li>
<li><p><code>goodness</code>: vector containing several goodness-of-fit measures: loglikehood, AIC, BIC, KIC and the measures proposed by Marhuenda et al. (2014): AICc, AICb1, AICb2, KICc, KICb1, KICb2. <code>B</code> must be must be greater than 0 to obtain these last measures.
</p>
</li></ul>

</td></tr>
</table>
<p>In case that <code>formula</code> or <code>vardir</code> contain NA values a message is printed and no action is done.
</p>


<h3>References</h3>

<p>- Fay, R.E. and Herriot, R.A. (1979). Estimation of income from small places: An application of James-Stein procedures to census data. Journal of the American Statistical Association 74, 269-277.
</p>
<p>- Marhuenda, Y., Morales, D. and Pardo, M.C. (2014). Information criteria for Fay-Herriot model selection. Computational Statistics and Data Analysis 70, 268-280.
</p>
<p>- Rao, J.N.K. (2003). Small Area Estimation. Wiley, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mseFH">mseFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set  
data(milk)   
attach(milk)

# Fit FH model using REML method with indicators of 4 Major Areas as 
# explanatory variables.
resultREML &lt;- eblupFH(yi ~ as.factor(MajorArea), SD^2)
resultREML

#Fit FH model using FH method
resultFH &lt;- eblupFH(yi ~ as.factor(MajorArea), SD^2, method="FH")
resultFH

detach(milk)
</code></pre>

<hr>
<h2 id='eblupSFH'> EBLUPs based on a spatial Fay-Herriot model.</h2><span id='topic+eblupSFH'></span>

<h3>Description</h3>

<p>This function gives small area estimators based on a spatial Fay-Herriot model, where area effects follow a SAR(1) process. Fitting method can be chosen between REML and ML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eblupSFH(formula, vardir, proxmat, method = "REML", MAXITER = 100, 
         PRECISION = 0.0001, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eblupSFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D</code> sampling variances of direct estimators for each domain. 
The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and column domains. The rows add up to 1. The rows and columns of this matrix must be sorted as the elements in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_method">method</code></td>
<td>
<p>type of fitting method, to be chosen between <code>"REML"</code> or <code>"ML"</code>. Default value is <code>REML</code>.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="eblupSFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>eblupSHF</code> is called.</p>
</td></tr>                 
</table>


<h3>Details</h3>

<p>A typical model has the form response ~ terms where response is the (numeric) response vector and terms is a series of terms which specifies a linear predictor for response. A terms specification of the form first + second indicates all the terms in first together with all the terms in second with duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae.  
</p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>eblup</code></td>
<td>
<p>vector with the values of the estimators for the domains.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects:
</p>

<ul>
<li><p><code>method</code>: type of fitting method applied (<code>"REML"</code> or <code>"ML"</code>).
</p>
</li>
<li><p><code>convergence</code>: a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li><p><code>iterations</code>: number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li><p><code>estcoef</code>: a data frame with the estimated model coefficients in the first column (<code>beta</code>), 
their asymptotic standard errors in the second column (<code>std.error</code>), 
the <code class="reqn">t</code> statistics in the third column <code>(tvalue)</code> and the p-values of the significance 
of each coefficient in last column <code>(pvalue)</code>.    
</p>
</li>
<li><p><code>refvar</code>: estimated random effects variance.
</p>
</li>
<li><p><code>spatialcorr</code>: estimated spatial correlation parameter.    
</p>
</li>
<li><p><code>goodness</code>: vector containing three goodness-of-fit measures: loglikehood, AIC and BIC.
</p>
</li></ul>

</td></tr>
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Isabel Molina, Monica Pratesi and Nicola Salvati.</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Molina, I., Salvati, N. and Pratesi, M. (2009). Bootstrap for estimating the MSE of the Spatial EBLUP. Computational Statistics 24, 441-458.
</p>
<p>- Petrucci, A. and Salvati, N. (2006). Small area estimation for spatial correlation in watershed erosion assessment.
Journal of Agricultural, Biological and Environmental Statistics 11, 169-182.
</p>
<p>- Pratesi, M. and Salvati, N. (2008). Small area estimation: the EBLUP estimator based on spatially correlated random area effects. 
Statistical Methods &amp; Applications 17, 113-141.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mseSFH">mseSFH</a></code>, <code><a href="#topic+npbmseSFH">npbmseSFH</a></code>, <code><a href="#topic+pbmseSFH">pbmseSFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grapes)       # Load data set
data(grapesprox)   # Load proximity matrix 

# Fit Spatial Fay-Herriot model using ML method
resultML &lt;- eblupSFH(grapehect ~ area + workdays - 1, var, grapesprox,
                     method="ML", data=grapes)
resultML

# Fit Spatial Fay-Herriot model using REML method
resultREML &lt;- eblupSFH(grapehect ~ area + workdays - 1, var, grapesprox,
                       data=grapes)
resultREML
</code></pre>

<hr>
<h2 id='eblupSTFH'>EBLUPs based on a spatio-temporal Fay-Herriot model.</h2><span id='topic+eblupSTFH'></span>

<h3>Description</h3>

<p>Fits a spatio-temporal Fay-Herriot model with area effects following a SAR(1) process
and with either uncorrelated or AR(1) time effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eblupSTFH(formula, D, T, vardir, proxmat, model = "ST", MAXITER = 100, 
          PRECISION = 0.0001, theta_iter = FALSE,
          sigma21_start = 0.5 * median(vardir), rho1_start = 0.5, 
          sigma22_start = 0.5 * median(vardir), rho2_start = 0.5, 
          data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eblupSTFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to <code>D*T</code> and sorted in the ascending order by the time instant within each domain. 
Details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_d">D</code></td>
<td>
<p>total number of domains.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_t">T</code></td>
<td>
<p>total number of time instants (constant for all domains).</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D*T</code> sampling variances of direct estimators for each domain and time instant. 
The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and                       column domains. The rows add up to 1. The rows and columns of this matrix must be sorted by domain as the variables in  
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_model">model</code></td>
<td>
<p>type of model to be chosen between <code>"ST"</code> (AR(1) time-effects within each domain) or <code>"S"</code> (uncorrelated time effects within each domain). Default model is &quot;ST&quot;.  </p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_theta_iter">theta_iter</code></td>
<td>
<p>If <code>TRUE</code> the estimated values of area effects variance, area effects spatial autocorrelation, area-time effects variance and time autocorrelation parameter of the area-time effects of each iteration of the fitting algorithm are returned in <code>estvarcomp_iterations</code> variable.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_sigma21_start">sigma21_start</code></td>
<td>
<p>Starting value of the area effects variance in the fitting algorithm. Default value is <code>0.5*median(vardir)</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_rho1_start">rho1_start</code></td>
<td>
<p>Starting value of the area effects spatial autocorrelation parameter in the fitting algorithm. Default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_sigma22_start">sigma22_start</code></td>
<td>
<p>Starting value of the area-time effects variance in the fitting algorithm. Default value is <code>0.5*median(vardir)</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_rho2_start">rho2_start</code></td>
<td>
<p>Starting value of the time autocorrelation parameter of the area-time effects in the fitting algorithm. Default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="eblupSTFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>eblupSTFH</code> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae.  
</p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>eblup</code></td>
<td>
<p>a column vector with length <code>D*T</code> with the values of the estimators 
for the <code>D</code> domains and <code>T</code> time instants.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects:
</p>
               
<ul>
<li><p><code>model</code>: type of model <code>"S"</code> or <code>"ST"</code>.
</p>
</li>
<li><p><code>convergence</code>: a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li><p><code>iterations</code>: number of iterations performed by the Fisher-scoring algorithm. 
</p>
</li>
<li><p><code>estcoef</code>: a data frame with the estimated model coefficients in the first column (<code>beta</code>), 
their asymptotic standard errors in the second column (<code>std.error</code>), 
the <code class="reqn">t</code> statistics in the third column <code>(tvalue)</code> and the p-values of the significance 
of each coefficient in last column <code>(pvalue)</code>.     
</p>
</li>
<li><p><code>estvarcomp</code>: a data frame with the estimated values of the variances and correlation coefficients in the first column (<code>estimate</code>) and their asymptotic standard errors in the second column (<code>std.error</code>).
</p>
</li>
<li><p><code>estvarcomp_iterations</code>: if <code>theta_iter=TRUE</code>, this component contains a data frame with the estimated values of the variances and correlation coefficients obtained for each iteration of the fitting algorithm.    
</p>
</li>
<li><p><code>goodness</code>: vector containing three goodness-of-fit measures: loglikehood, AIC and BIC.
</p>
</li></ul>

</td></tr>   
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Yolanda Marhuenda, Isabel Molina and Domingo Morales.</p>


<h3>References</h3>

  
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Marhuenda, Y., Molina, I. and Morales, D. (2013). Small area estimation with spatio-temporal
Fay-Herriot models. Computational Statistics and Data Analysis 58, 308-325. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbmseSTFH">pbmseSTFH</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spacetime)      # Load data set 
data(spacetimeprox)  # Load proximity matrix 

D &lt;- nrow(spacetimeprox)            # number of domains
T &lt;- length(unique(spacetime$Time)) # number of time instant

# Fit model S with uncorrelated time effects for each domain
resultS &lt;- eblupSTFH(Y ~ X1 + X2, D, T, Var, spacetimeprox, "S",
                     theta_iter=TRUE, data=spacetime)
rowsT &lt;- seq(T, T*D, by=T)
data.frame(Domain=spacetime$Area[rowsT], EBLUP_S=resultS$eblup[rowsT])
resultS$fit

# Fit model ST with AR(1) time effects for each domain
resultST &lt;- eblupSTFH(Y ~ X1 + X2, D, T, Var, spacetimeprox,
                      theta_iter=TRUE, data=spacetime)
data.frame(Domain=spacetime$Area[rowsT], EBLUP_ST=resultS$eblup[rowsT])
resultST$fit
</code></pre>

<hr>
<h2 id='grapes'> Synthetic data on grape production for the region of Tuscany. </h2><span id='topic+grapes'></span>

<h3>Description</h3>

<p> Synthetic data on grape production with spatial correlation for 274 municipalities in the region of Tuscany. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grapes)</code></pre>


<h3>Format</h3>

<p>A data frame with 274 observations on the following 4 variables.
</p>

<dl>
<dt><code>grapehect</code>:</dt><dd><p> direct estimators of the mean agrarian surface area used for production of grape (in hectares) for each Tuscany municipality.</p>
</dd>
<dt><code>area</code>:</dt><dd><p> agrarian surface area used for production (in hectares).</p>
</dd>
<dt><code>workdays</code>:</dt><dd><p> average number of working days in the reference year (2000).</p>
</dd>
<dt><code>var</code>:</dt><dd><p> sampling variance of the direct estimators for each Tuscany municipality.</p>
</dd>
</dl>


<hr>
<h2 id='grapesprox'> Proximity matrix for the spatial Fay-Herriot model.</h2><span id='topic+grapesprox'></span>

<h3>Description</h3>

<p> A data frame containing the proximity values for the 274 municipalities in the region of Tuscany included in data set <code><a href="#topic+grapes">grapes</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grapesprox)</code></pre>


<h3>Format</h3>

<p>The values are numbers in the interval <code>[0,1]</code> containing the proximity of the row and column domains. The sum of the values of each row is equal to 1.
</p>

<hr>
<h2 id='incomedata'> Synthetic income data.</h2><span id='topic+incomedata'></span>

<h3>Description</h3>

<p> Synthetic data on income and other related variables for Spanish provinces.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(incomedata)</code></pre>


<h3>Format</h3>

<p>A data frame with 17199 observations on the following 21 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>
<dt><code>ac</code>:</dt><dd><p> region of the province.</p>
</dd>
<dt><code>gen</code>:</dt><dd><p> gender: 1:male, 2:female.</p>
</dd>
<dt><code>age</code>:</dt><dd><p> age group: 0:&lt;=13, 1:14-15, 2:16-24, 3:25-49, 4:50-64, 5: &gt;=65.</p>
</dd>
<dt><code>nat</code>:</dt><dd><p> nationality: 1:Spanish, 2:other.</p>
</dd>
<dt><code>educ</code>:</dt><dd><p> education level: 0:age&lt;16, 1:primary education (compulsory educ.), 2:secondary education, 3:post-secondary education.</p>
</dd>
<dt><code>labor</code>:</dt><dd><p> labor force status: 0:age&lt;16, 1:employed, 2:unemployed, 3:inactive.</p>
</dd>
<dt><code>age2</code>:</dt><dd><p> indicator of age group 16-24.</p>
</dd>
<dt><code>age3</code>:</dt><dd><p> indicator of age group 25-49.</p>
</dd>
<dt><code>age4</code>:</dt><dd><p> indicator of age group 50-64.</p>
</dd>
<dt><code>age5</code>:</dt><dd><p> indicator of age group &gt;=65.</p>
</dd>
<dt><code>educ1</code>:</dt><dd><p> indicator of education level 1 (primary education).</p>
</dd>
<dt><code>educ2</code>:</dt><dd><p> indicator of education level 2 (secondary education.</p>
</dd>
<dt><code>educ3</code>:</dt><dd><p> indicator of education level 3 (post-secondary education).</p>
</dd>
<dt><code>nat1</code>:</dt><dd><p> indicator of Spanish nationality.</p>
</dd>
<dt><code>labor1</code>:</dt><dd><p> indicator of being employed.</p>
</dd>
<dt><code>labor2</code>:</dt><dd><p> indicator of being unemployed.</p>
</dd>
<dt><code>labor3</code>:</dt><dd><p> indicator of being inactive.</p>
</dd>
<dt><code>income</code>:</dt><dd><p> normalized income.</p>
</dd>
<dt><code>weight</code>:</dt><dd><p> sampling weight.</p>
</dd>
</dl>


<hr>
<h2 id='milk'> Data on fresh milk expenditure.</h2><span id='topic+milk'></span>

<h3>Description</h3>

<p>Data on fresh milk expenditure, used by Arora and Lahiri (1997) and by You and Chapman (2006). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(milk)</code></pre>


<h3>Format</h3>

<p>A data frame with 43 observations on the following 6 variables.
</p>

<dl>
<dt><code>SmallArea</code>:</dt><dd><p>areas of inferential interest.</p>
</dd>
<dt><code>ni</code>:</dt><dd><p>sample sizes of small areas.</p>
</dd>
<dt><code>yi</code>:</dt><dd><p>average expenditure on fresh milk for the year 1989 (direct estimates for the small areas).</p>
</dd>
<dt><code>SD</code>:</dt><dd><p>estimated standard deviations of <code>yi</code>.</p>
</dd>
<dt><code>CV</code>:</dt><dd><p>estimated coefficients of variation of <code>yi</code>.</p>
</dd>
<dt><code>MajorArea</code>:</dt><dd><p>major areas created by You and Chapman (2006). These areas have similar direct estimates and produce a large CV reduction when using a FH model.</p>
</dd>
</dl>



<h3>References</h3>

<p>- Arora, V. and Lahiri, P. (1997). On the superiority of the Bayesian method over the BLUP in small area estimation problems. Statistica Sinica 7, 1053-1063.
</p>
<p>- You, Y. and Chapman, B. (2006). Small area estimation using area level models and estimated sampling variances. Survey Methodology 32, 97-103.
</p>

<hr>
<h2 id='mseFH'>Mean squared error estimator of the EBLUP under a Fay-Herriot model.</h2><span id='topic+mseFH'></span>

<h3>Description</h3>

<p>Calculates the mean squared error estimator of the EBLUP under a Fay-Herriot model.
The EBLUP might have been obtained by either ML, REML or by FH 
fitting methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseFH(formula, vardir, method = "REML", MAXITER = 100, PRECISION = 0.0001, B = 0, 
      data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model 
specification are given under Details.</p>
</td></tr>                  
<tr><td><code id="mseFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D</code> sampling variances of direct estimators for each domain. The values must be sorted as the 
variables in <code>formula</code>.</p>
</td></tr>  
<tr><td><code id="mseFH_+3A_method">method</code></td>
<td>
<p>method used to fit the Fay-Herriot model, which can be either <code>"ML"</code>, <code>"REML"</code> or <code>"FH"</code> methods.
Default is <code>"REML"</code> method.</p>
</td></tr>
<tr><td><code id="mseFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm.
Default is 100 iterations.</p>
</td></tr>
<tr><td><code id="mseFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>   
<tr><td><code id="mseFH_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates to calculate the goodness-of-fit measures proposed by Marhuenda et al. (2014). Default value is <code>0</code> indicating that these measures are not calculated.</p>
</td></tr>  
<tr><td><code id="mseFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>mseFH</code> is called.</p>
</td></tr>                 
</table>


<h3>Details</h3>

<p>A typical model has the form response ~ terms where response is the (numeric) response vector
and terms is a series of terms which specifies a linear predictor for response. A terms specification
of the form first + second indicates all the terms in first together with all the terms in second with duplicates removed.
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae
</p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+eblupFH">eblupFH</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>a vector with the estimated mean squared errors of the EBLUPs for the small domains.</p>
</td></tr>
</table>
<p>In case that <code>formula</code> or <code>vardir</code> contain NA values a message is printed and no action is done.
</p>


<h3>References</h3>

<p>- Datta, G.S. and Lahiri, P. (2000). A unified measure of uncertainty of estimated
best linear unbiased predictors in small area estimation problems. Statistica Sinica 10, 613-627.
</p>
<p>- Datta, G.S., Rao, J.N.K. and Smith D.D. (2005). On measuring the variability of small area estimators under a basic area level model. Biometrika 92, 183-196.
</p>
<p>- Fay, R.E. and Herriot, R.A. (1979). Estimation of income from small places: An application of James-Stein procedures to census data. Journal of the American Statistical Association 74, 269-277.
</p>
<p>- Jiang, J. (1996). REML estimation: asymptotic behavior and related topics.
Annals of Statistics 24, 255-286.
</p>
<p>- Marhuenda, Y., Morales, D. and Pardo, M.C. (2014). Information criteria for Fay-Herriot model selection. Computational Statistics and Data Analysis 70, 268-280.
</p>
<p>- Prasad, N. and Rao, J. (1990). The estimation of the mean squared error of small-area estimators. Journal of the American Statistical Association 85, 163-171.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eblupFH">eblupFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set  
data(milk)   
attach(milk)

# Fit Fay-Herriot model using ML method with indicators 
# of 4 Major Areas as explanatory variables and compute
# estimated MSEs of EB estimators
resultML &lt;- mseFH(yi ~ as.factor(MajorArea), SD^2, method="ML")
resultML

# Fit Fay-Herriot model using REML method and compute 
# estimated MSEs of EB estimators
resultREML &lt;- mseFH(yi ~ as.factor(MajorArea), SD^2)
resultREML

# Fit Fay-Herriot model using FH method and compute 
# estimated MSEs of EB estimators
resultFH &lt;- mseFH(yi ~ as.factor(MajorArea), SD^2, method="FH")
resultFH

detach(milk)
</code></pre>

<hr>
<h2 id='mseSFH'>Mean squared error estimator of the spatial EBLUP under a spatial Fay-Herriot model.</h2><span id='topic+mseSFH'></span>

<h3>Description</h3>

<p>Calculates analytical mean squared error estimates of the spatial EBLUPs obtained from the fit of a spatial Fay-Herriot model, in which area effects follow a Simultaneously Autorregressive (SAR) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseSFH(formula, vardir, proxmat, method = "REML", MAXITER = 100, 
       PRECISION = 0.0001, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseSFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D</code> sampling variances of direct estimators for each domain. 
The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and column domains. The rows add up to 1. The rows and columns of this matrix must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_method">method</code></td>
<td>
<p> type of fitting method, to be chosen between <code>"REML"</code> or <code>"ML"</code>. Default value is <code>REML</code>.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="mseSFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>mseSFH</code> is called.</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+eblupSFH">eblupSFH</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>a vector with the analytical mean squared error estimates of the spatial EBLUPs.</p>
</td></tr>
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Isabel Molina, Monica Pratesi and Nicola Salvati.</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Molina, I., Salvati, N. and Pratesi, M. (2009). Bootstrap for estimating the MSE of
the Spatial EBLUP. Computational Statistics 24, 441-458.
</p>
<p>- Singh, B., Shukla, G. and Kundu, D. (2005). Spatio-temporal models in small area estimation. Survey Methodology 31, 183-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eblupSFH">eblupSFH</a></code>, <code><a href="#topic+npbmseSFH">npbmseSFH</a></code>, <code><a href="#topic+pbmseSFH">pbmseSFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grapes)       # Load data set
data(grapesprox)   # Load proximity matrix 

# Calculate analytical MSE estimates using REML method
result &lt;- mseSFH(grapehect ~ area + workdays - 1, var, grapesprox, data=grapes)
result
</code></pre>

<hr>
<h2 id='npbmseSFH'>Nonparametric bootstrap mean squared error estimator of the spatial EBLUPs under a spatial Fay-Herriot model.</h2><span id='topic+npbmseSFH'></span>

<h3>Description</h3>

<p>Calculates nonparametric bootstrap mean squared error estimates of the spatial EBLUPs obtained by fitting a spatial Fay-Herriot model, in which area 
effects follow a Simultaneously Autorregressive (SAR) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npbmseSFH(formula, vardir, proxmat, B = 100, method = "REML", MAXITER = 100,
          PRECISION = 0.0001, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npbmseSFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D</code> sampling variances of direct estimators for each domain. 
The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and column domains. The rows add up to 1. The rows and columns of this matrix must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_method">method</code></td>
<td>
<p>type of fitting method. Currently only <code>"REML"</code> method is available.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="npbmseSFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>npbmseSFH</code> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. A terms specification of the form first + second indicates all the terms in first 
together with all the terms in second with any duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> for more details of allowed formulae. </p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+eblupSFH">eblupSFH</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>data frame containing the naive nonparametric bootstrap mean squared error estimates of the spatial EBLUPs (<code>mse</code>) and the bias-corrected nonparametric bootstrap mean squared error estimates of the spatial EBLUPs (<code>msebc</code>).</p>
</td></tr>
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Isabel Molina, Monica Pratesi and Nicola Salvati.</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Molina, I., Salvati, N. and Pratesi, M. (2009). Bootstrap for estimating the MSE of the Spatial EBLUP. Computational Statistics 24, 441-458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eblupSFH">eblupSFH</a></code>, <code><a href="#topic+pbmseSFH">pbmseSFH</a></code>, <code><a href="#topic+mseSFH">mseSFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grapes)       # Load data set
data(grapesprox)   # Load proximity matrix

# Obtain the naive and bias-corrected non parametric bootstrap MSE 
# estimates using REML 
set.seed(123)
result &lt;- npbmseSFH(grapehect ~ area + workdays - 1, var, grapesprox, B=2, data=grapes)
result
</code></pre>

<hr>
<h2 id='pbmseBHF'>Parametric bootstrap mean squared error estimators of the EBLUPs of means obtained under a nested error linear regression model.</h2><span id='topic+pbmseBHF'></span>

<h3>Description</h3>

<p>Calculates, for selected domains, parametric bootstrap mean squared error  
estimators of the EBLUPs of means, when EBLUPs are obtained from a nested error linear regression model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmseBHF(formula, dom, selectdom, meanxpop, popnsize, B = 200, method = "REML", 
         data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbmseBHF_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The details of model 
specification are given under Details.</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_dom">dom</code></td>
<td>
<p><code>n*1</code> vector or factor (same size as <code>y</code> in <code>formula</code>) with domain codes.</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_selectdom">selectdom</code></td>
<td>
<p><code>I*1</code> optional vector or factor with the domain codes for which we 
want to estimate the means. It must be a subset of the domain codes in <code>dom</code>. 
If this parameter is not included all the domain codes included in <code>dom</code> 
are considered.</p>
</td></tr>  
<tr><td><code id="pbmseBHF_+3A_meanxpop">meanxpop</code></td>
<td>
<p><code>D*(p+1)</code> data frame with domain codes in the first column. Each remaining column contains the  
population means of each of the <code>p</code> auxiliary variables for the D domains. 
The domains considered in <code>meanxpop</code> must contain those specified in <code>selectdom</code> (D&gt;=I).</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_popnsize">popnsize</code></td>
<td>
<p><code>D*2</code> data frame with domain codes in the first column
and the corresponding domain population sizes in the second column. 
The domains considered in <code>popnsize</code> must contain those specified in <code>selectdom</code> (D&gt;=I).</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Default is <code>50</code>.</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_method">method</code></td>
<td>
<p>a character string. If <code>"REML"</code> the model is fitted by maximizing the restricted 
log-likelihood. If <code>"ML"</code> the log-likelihood is maximized. Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="pbmseBHF_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>dom</code>. By default the variables are taken from the environment from which <code>pbmseBHF</code> is called.</p>
</td></tr>                
</table>


<h3>Details</h3>

<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae. 
</p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+eblupBHF">eblupBHF</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>data frame with number of rows equal to number of selected domains, containing in its columns the domain codes (<code>domain</code>) and the parametric bootstrap mean squared error estimators (<code>mse</code>).</p>
</td></tr>
</table>
<p>Cases with NA values in <code>formula</code> or <code>dom</code> are ignored. 
</p>


<h3>References</h3>

<p>- Gonzalez-Manteiga, W., Lombardia, M., Molina, I., Morales, D. and Santamaria, L. (2008). Analytic and bootstrap approximations of prediction errors under a multivariate Fay-Herriot model. Computational Statistics and Data Analysis 52, 5242-5252.
</p>
<p>- Molina, I. and Rao, J.N.K. (2010). Small Area Estimation of Poverty Indicators. The Canadian Journal of Statistics 38, 369-385.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+eblupBHF">eblupBHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data set for segments (units within domains)
data(cornsoybean)

# Load data set for counties
data(cornsoybeanmeans)
attach(cornsoybeanmeans)

# Construct data frame with county means of auxiliary variables for 
# domains. First column must include the county code
Xmean &lt;- data.frame(CountyIndex, MeanCornPixPerSeg, MeanSoyBeansPixPerSeg)
Popn  &lt;- data.frame(CountyIndex, PopnSegments)

# Compute parametric bootstrap MSEs of the EBLUPs of means of crop areas 
# for each county.
set.seed(123) 
result &lt;- pbmseBHF(CornHec ~ CornPix + SoyBeansPix, dom=County,
                   selectdom=c(10,1,5), meanxpop=Xmean, popnsize=Popn,
                   B=50, data=cornsoybean)
result

detach(cornsoybeanmeans)
</code></pre>

<hr>
<h2 id='pbmseebBHF'>Parametric bootstrap mean squared error estimators of EB estimators.
</h2><span id='topic+pbmseebBHF'></span>

<h3>Description</h3>

<p>This function obtains estimators of the mean squared errors of the EB estimators of domain parameters by a parametric bootstrap method. Population values of auxiliary variables are required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmseebBHF(formula, dom, selectdom, Xnonsample, B = 100, MC = 100, data, 
           transform = "BoxCox", lambda = 0, constant = 0, indicator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbmseebBHF_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The details of model 
specification are given under Details.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_dom">dom</code></td>
<td>
<p><code>n*1</code> vector or factor (same size as <code>y</code> in <code>formula</code>) with domain codes.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_selectdom">selectdom</code></td>
<td>
<p><code>I*1</code> optional vector or factor with the domain codes for which we 
want to estimate the indicators. It must be a subset of the domain codes in <code>dom</code>. 
If this parameter is not included, the unique domain codes included in <code>dom</code> 
are considered.</p>
</td></tr>                   
<tr><td><code id="pbmseebBHF_+3A_xnonsample">Xnonsample</code></td>
<td>
<p>matrix or data frame containing in the first column the domain codes and in the rest of columns the values of each of 
<code>p</code> auxiliary variables for the out-of-sample units in each selected domain.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Default value is <code>100</code>.</p>
</td></tr>  
<tr><td><code id="pbmseebBHF_+3A_mc">MC</code></td>
<td>
<p>number of Monte Carlo replicates for the empirical approximation of the EB estimator. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>dom</code>. By default the variables are taken from the 
environment from which <code>pbmseebBHF</code> is called.</p>
</td></tr> 
<tr><td><code id="pbmseebBHF_+3A_transform">transform</code></td>
<td>
<p>type of transformation for the dependent variable to be chosen between the <code>"BoxCox"</code> and <code>"power"</code> families so that the dependent variable in <code>formula</code> follows approximately a Normal distribution. Default value is <code>"BoxCox"</code>.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_lambda">lambda</code></td>
<td>
<p>value for the parameter of the family of transformations specified in <code>transform</code>. Default value is <code>0</code>, which gives the log transformation for the two possible families.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_constant">constant</code></td>
<td>
<p>constant added to the dependent variable before doing the transformation, to achieve a distribution close to Normal. Default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="pbmseebBHF_+3A_indicator">indicator</code></td>
<td>
<p>function of the (untransformed) variable on the left hand side of <code>formula</code> that we want to estimate in each domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. A terms specification of the form first + second indicates all the terms in first 
together with all the terms in second with any duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae. </p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eb</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+ebBHF">ebBHF</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>data frame with number of rows equal to number of selected domains, containing in its columns the domain codes (<code>domain</code>) and the parametric bootstrap mean squared error estimates of <code>indicator</code> (<code>mse</code>).</p>
</td></tr>
</table>
<p>Cases with NA values in <code>formula</code> or <code>dom</code> are ignored. 
</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Molina, I. and Rao, J.N.K. (2010). Small Area Estimation of Poverty Indicators. The Canadian Journal of Statistics 38, 369-385.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ebBHF">ebBHF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(incomedata)         # Load data set
attach(incomedata)

# Construct design matrix for sample elements
Xs&lt;-cbind(age2,age3,age4,age5,nat1,educ1,educ3,labor1,labor2)

# Select the domains to compute EB estimators
data(Xoutsamp)
domains &lt;- c(5)

# Poverty incidence indicator
povertyline &lt;- 0.6*median(incomedata$income)
povertyline                         # 6477.484
povinc &lt;- function(y)    
{
   z &lt;- 6477.484
   result &lt;- mean(y&lt;z)
   return (result)
}

# Compute parametric bootstrap MSE estimators of the EB 
# predictors of poverty incidence. Take constant=3600 to achieve 
# approximately symmetric residuals.
set.seed(123)
result &lt;- pbmseebBHF(income~Xs, dom=prov, selectdom=domains,
                     Xnonsample=Xoutsamp, B=2, MC=2, constant=3600,
                     indicator=povinc)
result$est$eb
result$mse
result$est$fit$refvar

detach(incomedata)
</code></pre>

<hr>
<h2 id='pbmseSFH'>Parametric bootstrap mean squared error estimators of the spatial EBLUPs under a spatial Fay-Herriot model.</h2><span id='topic+pbmseSFH'></span>

<h3>Description</h3>

<p>Calculates the parametric bootstrap mean squared error estimates of the spatial EBLUPs obtained by fitting the spatial Fay-Herriot model, in which area effects follow a Simultaneously Autorregressive (SAR) process.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmseSFH(formula, vardir, proxmat, B = 100, method = "REML", MAXITER = 100,
         PRECISION = 0.0001, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbmseSFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to the number of domains <code>D</code>. Details of model specification are given under Details.</p>
</td></tr>                  
<tr><td><code id="pbmseSFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>D</code> sampling variances of direct estimators for each domain. 
The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and column domains. The rows add up to 1. The rows and columns of this matrix must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_method">method</code></td>
<td>
<p>type of fitting method, to be chosen between <code>"REML"</code> or <code>"ML"</code>. Default value is <code>REML</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="pbmseSFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>pbmseSFH</code> is called.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. A terms specification of the form first + second indicates all the terms in first 
together with all the terms in second with any duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae. </p>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  <code><a href="#topic+eblupSFH">eblupSFH</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>data frame containing the naive parametric bootstrap mean squared error estimates (<code>mse</code>) and the bias-corrected parametric bootstrap mean squared error estimates of the spatial EBLUPs (<code>msebc</code>).</p>
</td></tr>
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Isabel Molina, Monica Pratesi and Nicola Salvati.</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- Molina, I., Salvati, N. and Pratesi, M. (2009). Bootstrap for estimating the MSE of the Spatial EBLUP. Computational Statistics 24, 441-458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eblupSFH">eblupSFH</a></code>, <code><a href="#topic+npbmseSFH">npbmseSFH</a></code>, <code><a href="#topic+mseSFH">mseSFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grapes)       # Load data set
data(grapesprox)   # Load proximity matrix

# Obtain the fitting values, naive and bias-corrected parametric bootstrap MSE estimates
# using REML method 
set.seed(123)
result &lt;- pbmseSFH(grapehect ~ area + workdays - 1, var, grapesprox, B=2, data=grapes)
result
</code></pre>

<hr>
<h2 id='pbmseSTFH'>Parametric bootstrap mean squared error estimator of a spatio-temporal Fay-Herriot model.</h2><span id='topic+pbmseSTFH'></span>

<h3>Description</h3>

<p>Calculates parametric bootstrap mean squared error estimates of the EBLUPs based on a spatio-temporal Fay-Herriot model with area effects following a SAR(1) process and with either uncorrelated or correlated time effects within each domain following an AR(1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmseSTFH(formula, D, T, vardir, proxmat, B = 100, model = "ST", 
          MAXITER = 100, PRECISION = 0.0001, theta_iter = FALSE,
          sigma21_start = 0.5 * median(vardir), rho1_start = 0.5, 
          sigma22_start = 0.5 * median(vardir), rho2_start = 0.5, 
          data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbmseSTFH_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): 
a symbolic description of the model to be fitted. The variables included in <code>formula</code>
must have a length equal to <code>D*T</code> and sorted in the ascending order by the time instant within each domain. 
Details of model specification are given under Details.</p>
</td></tr>                  
<tr><td><code id="pbmseSTFH_+3A_d">D</code></td>
<td>
<p>total number of domains.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_t">T</code></td>
<td>
<p>total number of time instants (constant for each domain).</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the <code>n=D*T</code> sampling variances for each domain and time instant. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_proxmat">proxmat</code></td>
<td>
<p><code>D*D</code> proximity matrix or data frame with values in the interval <code>[0,1]</code> containing the proximities between the row and                       column domains. The rows add up to 1. The rows and columns of this matrix must be sorted by domain as the variables in 
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_model">model</code></td>
<td>
<p>type of model to be chosen between <code>"ST"</code> (correlated time-effects within domains) or <code>"S"</code> (uncorrelated time-effects 
within domains).</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed for the Fisher-scoring algorithm. Default value is <code>100</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm. Default value is <code>0.0001</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_theta_iter">theta_iter</code></td>
<td>
<p>If <code>TRUE</code> the estimated values of area effects variance, area effects spatial autocorrelation, area-time effects variance and time autocorrelation parameter of the area-time effects of each iteration of the fitting algorithm are returned in <code>est$estvarcomp_iterations</code>.</p>
</td></tr>  
<tr><td><code id="pbmseSTFH_+3A_sigma21_start">sigma21_start</code></td>
<td>
<p>Starting value of the area effects variance in the fitting algorithm. Default value is <code>0.5*median(vardir)</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_rho1_start">rho1_start</code></td>
<td>
<p>Starting value of the area effects spatial autocorrelation parameter in the fitting algorithm. Default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_sigma22_start">sigma22_start</code></td>
<td>
<p>Starting value of the area-time effects variance in the fitting algorithm. Default value is <code>0.5*median(vardir)</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_rho2_start">rho2_start</code></td>
<td>
<p>Starting value of the time autocorrelation parameter of the area-time effects in the fitting algorithm. Default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="pbmseSTFH_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>. By default the variables are taken from the environment from which <code>pbmseSTFH</code> is called.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>This function uses random number generation. To fix the seed, use <code>set.seed</code>.
</p>
<p>A typical model has the form response ~ terms where response is the (numeric) response vector and 
terms is a series of terms which specifies a linear predictor for response. A terms specification of 
the form first + second indicates all the terms in first together with all the terms in second with 
duplicates removed. 
</p>
<p>A formula has an implied intercept term. To remove this use either y ~ x - 1 or y ~ 0 + x. See <code><a href="stats.html#topic+formula">formula</a></code> 
for more details of allowed formulae.  
</p>


<h3>Value</h3>

 
<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list with the results of the estimation process: <code>eblup</code> and <code>fit</code>. For the description of these objects, see Value of  
<code><a href="#topic+eblupSTFH">eblupSTFH</a></code> function.</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>a vector of length <code>D*T</code> containing the parametric bootstrap mean squared error estimates for the <code>D</code> domains and <code>T</code> time instants.</p>
</td></tr>
</table>
<p>In case that <code>formula</code>, <code>vardir</code> or <code>proxmat</code> contain NA values a message is printed and no action is done.
</p>


<h3>Author(s)</h3>

<p>Yolanda Marhuenda, Isabel Molina and Domingo Morales.</p>


<h3>References</h3>

 
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), 
funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1. 
</p>
<p>- Marhuenda, Y., Molina, I. and Morales, D. (2013). Small area estimation with spatio-temporal
Fay-Herriot models. Computational Statistics and Data Analysis 58, 308-325. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eblupSTFH">eblupSTFH</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spacetime)      # Load data set 
data(spacetimeprox)  # Load proximity matrix 

D &lt;- nrow(spacetimeprox)            # number of domains
T &lt;- length(unique(spacetime$Time)) # number of time instant

# Calculate MSEs of EBLUPs under the spatio-temporal Fay-Herriot model
# with uncorrelated time effects nested within domains (model S)
set.seed(123)
resultS &lt;- pbmseSTFH(Y ~ X1 + X2, D, T, Var, spacetimeprox, B=10, 
                     model="S", data=spacetime)

# Print direct estimates, variance, "S" model estimates, mse and 
# residuals of the last time instant.
output &lt;- data.frame(Domain=spacetime$Area, Period=spacetime$Time, 
                     Direct=spacetime$Y, EBLUP_S=resultS$est$eblup, 
                     VarDirect=spacetime$Var, MSE_S=resultS$mse, 
                     Residuals=spacetime$Y-resultS$est$eblup) 
periods &lt;- unique(spacetime$Time)                  
lastperiod &lt;- periods[length(periods)]   
print(output[output[,"Period"]==lastperiod,], row.names=FALSE)


# Calculate MSEs of the EBLUPs based on the spatio-temporal Fay-Herriot model
# with AR(1) time effects nested within each area
attach(spacetime)
set.seed(123)
resultST &lt;- pbmseSTFH(Y ~ X1 + X2, D, T, vardir=Var, spacetimeprox, B=10)  

# Print direct estimates, variance, "ST" model estimates, mse and 
# residuals of the last time instant.
output &lt;- data.frame(Domain=Area, Period=Time, Direct=Y, 
                     EBLUP_ST=resultST$est$eblup, VarDirect=Var, 
                     MSE_ST=resultST$mse, 
                     Residuals=Y-resultST$est$eblup) 
periods &lt;- unique(Time)                  
lastperiod &lt;- periods[length(periods)]                     
print(output[output[,"Period"]==lastperiod,], row.names=FALSE)

detach(spacetime)
</code></pre>

<hr>
<h2 id='pssynt'>Post-stratified synthetic estimators of domain means.</h2><span id='topic+pssynt'></span>

<h3>Description</h3>

<p>Calculates post-stratified synthetic estimators of domain means 
using the categories of a cualitative variable as post-strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pssynt(y, sweight, ps, domsizebyps, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pssynt_+3A_y">y</code></td>
<td>
<p> vector specifying the individual values of the variable for which we want to estimate the domain means. </p>
</td></tr>
<tr><td><code id="pssynt_+3A_sweight">sweight</code></td>
<td>
<p> vector (same size as <code>y</code>) with the sampling weights of the units.</p>
</td></tr>
<tr><td><code id="pssynt_+3A_ps">ps</code></td>
<td>
<p> vector (same size as <code>y</code>) of factor with post-strata codes.</p>
</td></tr>
<tr><td><code id="pssynt_+3A_domsizebyps">domsizebyps</code></td>
<td>
<p> data frame with domain codes in the first column. Each remaining column contains the domain population sizes for each post-strata. Names of these columns must be the post-strata identifiers specified in <code>ps</code>.</p>
</td></tr>
<tr><td><code id="pssynt_+3A_data">data</code></td>
<td>
<p> optional data frame containing the variables named in <code>y</code>, <code>sweight</code> and <code>ps</code>. By default the variables are taken from the environment from which <code>pssynt</code> is called.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p> The function returns a data frame of size <code>D*2</code> with the following columns:
</p>
<table>
<tr><td><code>Domain</code></td>
<td>
<p> domain codes in ascending order.</p>
</td></tr>
<tr><td><code>PsSynthetic</code></td>
<td>
<p> post-stratified synthetic estimators of domain means of variable <code>y</code>.</p>
</td></tr>
</table>
<p>Cases with NA values in <code>y</code>, <code>sweight</code> or <code>ps</code> are ignored.
</p>


<h3>References</h3>

 
<p>- Rao, J.N.K. (2003). &quot;Small Area Estimation&quot;. Wiley, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direct">direct</a>, <a href="#topic+ssd">ssd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute post-stratified synthetic estimators of mean income 
# for provinces considering the education levels codes 
# (variable educ) as post-strata.

# Load data set
data(incomedata)   

# Load province sizes by education levels
data(sizeprovedu)

# Compute post-stratified synthetic estimators with province labels 
# as domain codes
colnames(sizeprovedu) &lt;- c("provlab", "prov", "0", "1", "2", "3")
result1 &lt;- pssynt(y=income, sweight=weight, ps=educ,
                  domsizebyps=sizeprovedu[,-2], data=incomedata)
result1

# Now with province codes as domain codes
colnames(sizeprovedu) &lt;- c("provlab", "prov", "0", "1", "2", "3")
result2 &lt;- pssynt(y=income, sweight=weight, ps=educ,
                  domsizebyps=sizeprovedu[,-1], data=incomedata)
result2
</code></pre>

<hr>
<h2 id='sae-package'>Small area estimation</h2><span id='topic+sae-package'></span><span id='topic+sae'></span>

<h3>Description</h3>

<p>This package provides a variety of functions for small area estimation, including functions for mean squared error estimation. Basic estimators include direct, poststratified synthetic and sample size dependent. Model-based estimators include the EBLUP based on a Fay-Herriot model and the EBLUP based on a unit level nested error model. Estimators obtained from spatial and spatio-temporal Fay-Herriot models and the EB method based on the unit level nested error model for estimation of general non linear parameters are also included.</p>


<h3>Details</h3>

<p>This package provides functions for estimation in domains with small sample sizes. For a complete list of functions, see library(help=sae).
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> sae</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-01</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> stats, lmer</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>





<h3>Author(s)</h3>

<p>Isabel Molina &lt;isabel.molina@uc3m.es&gt; and 
Yolanda Marhuenda &lt;y.marhuenda@umh.es&gt;	
</p>


<h3>References</h3>

<p>- Arora, V. and Lahiri, P. (1997). On the superiority of the Bayesian method over the BLUP in small area estimation problems. Statistica Sinica 7, 1053-1063.
</p>
<p>- Battesse, G.E., Harter, R.M. and Fuller, W.A. (1988). An Error-Components Model for Prediction of County Crop Areas Using Survey and Satellite Data. Journal of the American Statistical Association 83, 28-36.
</p>
<p>- Box, G.E.P. and Cox, D.R. (1964). An analysis of transformations. Journal of Royal Statistical Society  Series B 26, 211-246. 
</p>
<p>- Cochran, W.G. (1977). Sampling techniques. Wiley, New York.
</p>
<p>- Datta, G.S. and Lahiri, P. (2000). A unified measure of uncertainty of estimated best linear unbiased predictors in small area estimation problems. Statistica Sinica 10, 613-627.
</p>
<p>- Datta, G.S., Rao, J.N.K. and Smith D.D. (2005). On measuring the variability of small area estimators under a basic area level model. Biometrika 92, 183-196.
</p>
<p>- Drew, D., Singh, M.P. and Choudhry, G.H. (1982). Evaluation of small area estimation techniques for the Canadian Labour Force Survey. Survey Methodology 8, 17-47.
</p>
<p>- Fay, R.E. and Herriot, R.A. (1979). Estimation of income from small places: An application of James-Stein procedures to census data. Journal of the American Statistical Association 74, 269-277.
</p>
<p>- Gonzalez-Manteiga, W., Lombardia, M., Molina, I., Morales, D. and Santamaria, L. (2008). Analytic and bootstrap approximations of prediction errors under a multivariate Fay-Herriot model. Computational Statistics and Data Analysis 52, 5242-5252.
</p>
<p>- Jiang, J. (1996). REML estimation: asymptotic behavior and related topics.
Annals of Statistics 24, 255-286.
</p>
<p>- Marhuenda, Y., Molina, I. and Morales, D. (2013). Small area estimation with spatio-temporal Fay-Herriot models. Computational Statistics and Data Analysis 58, 308-325. 
</p>
<p>- Marhuenda, Y., Morales, D. and Pardo, M.C. (2014). Information criteria for Fay-Herriot model selection. Computational Statistics and Data Analysis 70, 268-280. 
</p>
<p>- Molina, I., Salvati, N. and Pratesi, M. (2009). Bootstrap for estimating the MSE of the Spatial EBLUP. Computational Statistics 24, 441-458.
</p>
<p>- Molina, I. and Rao, J.N.K. (2010). Small Area Estimation of Poverty Indicators. The Canadian Journal of Statistics 38, 369-385.
</p>
<p>- Petrucci, A. and Salvati, N. (2006). Small area estimation for spatial correlation in watershed erosion assessment.
Journal of Agricultural, Biological and Environmental Statistics 11, 169-182.
</p>
<p>- Prasad, N. and Rao, J. (1990). The estimation of the mean squared error of small-area estimators. Journal of the American Statistical Association 85, 163-171.
</p>
<p>- Pratesi, M. and Salvati, N. (2008). Small area estimation: the EBLUP estimator based on spatially correlated random area effects. 
Statistical Methods &amp; Applications 17, 113-141.
</p>
<p>- Rao, J.N.K. (2003). Small Area Estimation. Wiley, London.
</p>
<p>- Sarndal, C.E., Swensson, B. and Wretman, J. (1992). Model Assisted Survey Sampling. Springer-Verlag.
</p>
<p>- Singh, B., Shukla, G. and Kundu, D. (2005). Spatio-temporal models in small area estimation. Survey Methodology 31, 183-195.
</p>
<p>- Small Area Methods for Poverty and Living Conditions Estimates (SAMPLE), funded by European Commission, Collaborative Project 217565, Call identifier FP7-SSH-2007-1.
</p>
<p>- You, Y. and Chapman, B. (2006). Small area estimation using area level models and estimated sampling variances. Survey Methodology 32, 97-103.
</p>

<hr>
<h2 id='sizeprov'>Domain population sizes.</h2><span id='topic+sizeprov'></span>

<h3>Description</h3>

<p>Identifiers and population sizes for domains in data set <code><a href="#topic+incomedata">incomedata</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sizeprov)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 3 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>  
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>
<dt><code>Nd</code>:</dt><dd><p> province population count.</p>
</dd>
</dl>


<hr>
<h2 id='sizeprovage'>Domain population sizes by age.</h2><span id='topic+sizeprovage'></span>

<h3>Description</h3>

<p>Names, codes and population sizes by age for domains in data set <code><a href="#topic+incomedata">incomedata</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sizeprovage)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 7 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>  
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>    
<dt><code>age1</code>:</dt><dd><p>province count for age group &lt;16.</p>
</dd>
<dt><code>age2</code>:</dt><dd><p>province count for age group 16-24.</p>
</dd>
<dt><code>age3</code>:</dt><dd><p>province count for age group 25-49.</p>
</dd>
<dt><code>age4</code>:</dt><dd><p>province count for age group 50-64.</p>
</dd>
<dt><code>age5</code>:</dt><dd><p>province count for age group &gt;=65.</p>
</dd>
</dl>


<hr>
<h2 id='sizeprovedu'>Domain population sizes by level of education.</h2><span id='topic+sizeprovedu'></span>

<h3>Description</h3>

<p>Identifiers and population sizes by level of education for domains in data set <code><a href="#topic+incomedata">incomedata</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sizeprovedu)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 6 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>  
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>
<dt><code>educ0</code>:</dt><dd><p> province count for education level 0 (age&lt;16).</p>
</dd>
<dt><code>educ1</code>:</dt><dd><p> province count for education level 1 (primary education).</p>
</dd>
<dt><code>educ2</code>:</dt><dd><p> province count for education level 2 (secondary education).</p>
</dd>
<dt><code>educ3</code>:</dt><dd><p> province count for education level 3 (post-secondary education).</p>
</dd>
</dl>


<hr>
<h2 id='sizeprovlab'>Domain population sizes by labor force status.</h2><span id='topic+sizeprovlab'></span>

<h3>Description</h3>

<p>Names, codes and population sizes by labor force status for domains in data set <code><a href="#topic+incomedata">incomedata</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sizeprovlab)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 6 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>  
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>    
<dt><code>labor0</code></dt><dd><p>province count for labor force status 0 (age&lt;16).</p>
</dd>
<dt><code>labor1</code></dt><dd><p>province count for labor force status 1 (employed).</p>
</dd>
<dt><code>labor2</code></dt><dd><p>province count for labor force status 2 (unemployed).</p>
</dd>
<dt><code>labor3</code></dt><dd><p>province count for labor force status 3 (inactive).</p>
</dd>
</dl>


<hr>
<h2 id='sizeprovnat'>Domain population sizes for Spanish or non Spanish nationality.</h2><span id='topic+sizeprovnat'></span>

<h3>Description</h3>

<p>Names, codes and population sizes for Spanish or non Spanish nationality for domains in data set <code><a href="#topic+incomedata">incomedata</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sizeprovnat)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 4 variables.
</p>

<dl>
<dt><code>provlab</code>:</dt><dd><p> province name.</p>
</dd>  
<dt><code>prov</code>:</dt><dd><p> province code.</p>
</dd>
<dt><code>nat1</code>:</dt><dd><p>province count for Spanish nationality.</p>
</dd>
<dt><code>nat2</code>:</dt><dd><p>province count for non Spanish nationality.</p>
</dd>
</dl>


<hr>
<h2 id='spacetime'> Synthetic area level data with spatial and temporal correlation. </h2><span id='topic+spacetime'></span>

<h3>Description</h3>

<p> Synthetic area level data with spatial and temporal correlation. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spacetime)</code></pre>


<h3>Format</h3>

<p>A data frame with 33 observations on the following 6 variables.
</p>

<dl>
<dt><code>Area</code>:</dt><dd><p> numeric domain indicator.</p>
</dd>
<dt><code>Time</code>:</dt><dd><p> numeric time instant indicator.</p>
</dd>
<dt><code>X1</code>:</dt><dd><p> first auxiliary variable at domain level.</p>
</dd>
<dt><code>X2</code>:</dt><dd><p> second auxiliary variable at domain level.</p>
</dd>
<dt><code>Y</code>:</dt><dd><p> direct estimators of the target variable in the domains.</p>
</dd>
<dt><code>Var</code>:</dt><dd><p> sampling variances of direct estimators for each domain.</p>
</dd>
</dl>


<hr>
<h2 id='spacetimeprox'>Proximity matrix for the spatio-temporal Fay-Herriot model.</h2><span id='topic+spacetimeprox'></span>

<h3>Description</h3>

<p> Example of proximity matrix for the domains included in data set <code><a href="#topic+spacetime">spacetime</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spacetimeprox)</code></pre>


<h3>Format</h3>

<p>The values are numbers in the interval <code>[0,1]</code> containing the
proximity of the row and column domains.
The sum of the values of each row is equal to 1. 
</p>

<hr>
<h2 id='ssd'>Sample size dependent estimator.</h2><span id='topic+ssd'></span>

<h3>Description</h3>

<p>Calculates sample size dependent estimators of domain means, 
as composition of direct and synthetic estimators. The estimators
involved in the composition must be given as function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssd(dom, sweight, domsize, direct, synthetic, delta = 1, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssd_+3A_dom">dom</code></td>
<td>
<p> vector or factor (same size as <code>y</code>) with domain codes. </p>
</td></tr>
<tr><td><code id="ssd_+3A_sweight">sweight</code></td>
<td>
<p> vector (same size as <code>dom</code>) with sampling weights of the units.</p>
</td></tr>
<tr><td><code id="ssd_+3A_domsize">domsize</code></td>
<td>
<p> matrix or data frame with domain codes in the first column and the corresponding domain population sizes in the second column.</p>
</td></tr>
<tr><td><code id="ssd_+3A_direct">direct</code></td>
<td>
<p> matrix or data frame with domain codes in the first column and the corresponding direct estimators of domain means in the second column.</p>
</td></tr>
<tr><td><code id="ssd_+3A_synthetic">synthetic</code></td>
<td>
<p> matrix or data frame with domain codes in the first column and the corresponding synthetic estimators of domain means in the second column.</p>
</td></tr>
<tr><td><code id="ssd_+3A_delta">delta</code></td>
<td>
<p> constant involved in sample size dependent estimator,
controlling how much strength to borrow. Default value is 1. </p>
</td></tr>
<tr><td><code id="ssd_+3A_data">data</code></td>
<td>
<p> optional data frame containing the variables named in <code>dom</code> and <code>sweight</code>. By default the variables are taken from the environment from which <code>ssd</code> is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data frame of size <code>D*2</code> with the following columns:
</p>
<table>
<tr><td><code>Domain</code></td>
<td>
<p> domain codes in ascending order.</p>
</td></tr>
<tr><td><code>ssd</code></td>
<td>
<p> sample size dependent estimators of domain means.</p>
</td></tr>
<tr><td><code>CompWeight</code></td>
<td>
<p> weights attached to direct estimators in the composition.</p>
</td></tr>
</table>
<p>Cases with NA values in <code>dom</code> or <code>sweight</code> are ignored.  
</p>


<h3>References</h3>

<p>- Drew, D., Singh, M.P. and Choudhry, G.H. (1982). Evaluation of small area estimation techniques for the Canadian Labour Force Survey. Survey Methodology 8, 17-47.
</p>
<p>- Rao, J. N. K. (2003). Small Area Estimation. Wiley, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direct">direct</a>, <a href="#topic+pssynt">pssynt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We compute sample size dependent estimators of mean income by  
# composition of the Horvitz-Thompson direct estimator and the  
# post-stratified synthetic estimator with age groups as post-strata.

# Load data set
data(incomedata)

# Load population sizes of provinces (domains)
data(sizeprov)  

# First we compute Horvitz-Thompson direct estimators
dir &lt;- direct(y=income, dom=provlab, sweight=weight,
              domsize=sizeprov[,c(1,3)], data=incomedata)

# Now we compute post-stratified synthetic estimators with education 
# levels as post-strata
# Load province sizes by education levels
data(sizeprovedu)

# Compute post-stratified synthetic estimators
colnames(sizeprovedu) &lt;- c("provlab", "prov", "0", "1", "2", "3")
synth &lt;- pssynt(y=income, sweight=weight, ps=educ,
                domsizebyps=sizeprovedu[,-2], data=incomedata)
                
# Compute sample size dependent estimators of province mean income
# by composition of Horvitz-Thompson direct estimators and 
# post-stratified estimators for delta=1
comp &lt;- ssd(dom=provlab, sweight=weight, domsize=sizeprov[,c(1,3)],
            direct=dir[,c("Domain","Direct")], synthetic=synth, data=incomedata)
comp
</code></pre>

<hr>
<h2 id='Xoutsamp'>Out-of-sample values of auxiliary variables for 5 domains.</h2><span id='topic+Xoutsamp'></span>

<h3>Description</h3>

<p>Values of p auxiliary variables for out-of-sample units within 5 domains of data set <code><a href="#topic+incomedata">incomedata</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Xoutsamp)</code></pre>


<h3>Format</h3>

<p>A data frame with 713301 observations on the following 10 variables.
</p>

<dl>
<dt><code>domain</code>:</dt><dd><p>a numeric vector with the domain codes.</p>
</dd>
<dt><code>age2</code>:</dt><dd><p> indicator of age group 16-24.</p>
</dd>
<dt><code>age3</code>:</dt><dd><p> indicator of age group 25-49.</p>
</dd>
<dt><code>age4</code>:</dt><dd><p> indicator of age group 50-64.</p>
</dd>
<dt><code>age5</code>:</dt><dd><p> indicator of age group &gt;=65.</p>
</dd>
<dt><code>nat1</code>:</dt><dd><p> indicator of Spanish nationality.</p>
</dd>
<dt><code>educ1</code>:</dt><dd><p> indicator of education level 1 (primary education).</p>
</dd>
<dt><code>educ3</code>:</dt><dd><p> indicator of education level 3 (post-secondary education).</p>
</dd>
<dt><code>labor1</code>:</dt><dd><p> indicator of being employed.</p>
</dd>
<dt><code>labor2</code>:</dt><dd><p> indicator of being unemployed.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
