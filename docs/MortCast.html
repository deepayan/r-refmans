<!DOCTYPE html><html><head><title>Help for package MortCast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MortCast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MortCast-package'><p>MortCast: Estimation and Projection of Age-Specific Mortality Rates</p></a></li>
<li><a href='#cokannisto'><p>Coherent Kannisto Method</p></a></li>
<li><a href='#cokannisto.estimate'><p>Coherent Kannisto Estimation</p></a></li>
<li><a href='#kannisto'><p>Kannisto Method</p></a></li>
<li><a href='#kannisto.estimate'><p>Kannisto Estimation</p></a></li>
<li><a href='#kannisto.predict'><p>Kannisto Prediction</p></a></li>
<li><a href='#leecarter.estimate'><p>Lee-Carter Estimation</p></a></li>
<li><a href='#life.table'><p>Life Table Function</p></a></li>
<li><a href='#lileecarter.estimate'><p>Coherent Lee-Carter Estimation</p></a></li>
<li><a href='#logquad'><p>Log-Quadratic Mortality Model</p></a></li>
<li><a href='#LQcoef'><p>Coefficients for the Log-Quadratic Mortality Model</p></a></li>
<li><a href='#mlt'><p>Model Life Tables Mortality Patterns</p></a></li>
<li><a href='#MLTlookup'><p>Model Life Tables Lookup</p></a></li>
<li><a href='#mortcast'><p>Coherent Rotated Lee-Carter Prediction</p></a></li>
<li><a href='#mortcast.blend'><p>Mortality Prediction by Method Blending</p></a></li>
<li><a href='#pmd'><p>Pattern of Mortality Decline Prediction</p></a></li>
<li><a href='#PMDadjcoef'><p>Coefficients for Sex Ratio Adjustments in the PMD Method</p></a></li>
<li><a href='#PMDrho'><p>Pattern Mortality Decline Lookup Tables</p></a></li>
<li><a href='#rotate.leecarter'><p>Rotated Lee-Carter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Projection of Age-Specific Mortality Rates</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova, Nan Li and Patrick Gerland</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Age-specific mortality rates are estimated and projected using 
    the Kannisto, Lee-Carter and related methods as described in 
    Sevcikova et al. (2016) &lt;<a href="https://doi.org/10.1007%2F978-3-319-26603-9_15">doi:10.1007/978-3-319-26603-9_15</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), wpp2017</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>True</td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-31 21:03:18 UTC; hana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-31 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MortCast-package'>MortCast: Estimation and Projection of Age-Specific Mortality Rates</h2><span id='topic+MortCast'></span><span id='topic+MortCast-package'></span>

<h3>Description</h3>

<p>Age-specific mortality rates are estimated and projected using 
the Kannisto, Lee-Carter and related methods as described in 
Sevcikova et al. (2016) &lt;doi:10.1007/978-3-319-26603-9_15&gt;.
</p>


<h3>Details</h3>

<p>The package implements methodology described in Sevcikova et al. (2016) that is related to 
estimating and predicting age-specific mortality rates. The main functions are:
</p>

<ul>
<li> <p><code><a href="#topic+cokannisto">cokannisto</a></code>: Extrapolates given mortality rates into higher ages
using the Coherent Kannisto method. The original Kannisto method 
(with sex-independent extrapolation) is avalable in the function 
<code><a href="#topic+kannisto">kannisto</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code>: Estimates the coherent Lee-Carter parameters
for male and female mortality rates (Li and Lee 2005), i.e. sex-independent parameters <code class="reqn">a_x</code> and <code class="reqn">k_t</code>, and 
the coherent parameter <code class="reqn">b_x</code>. In addition, it 
computes the ultimate <code class="reqn">b^u_x</code> for rotation (Li et al. 2013). 
The underlying sex-independent estimation is implemented in the function <code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+mortcast">mortcast</a></code>: Using estimated coherent Lee-Carter parameters 
and given future sex-specific life expectancies,
it projects age-specific mortality rates, while (by default) rotating the <code class="reqn">b_x</code> 
parameter as described in Li et al. (2013).
</p>
</li></ul>

<p>Functions contained in the package can be used to apply Algorithm 2 in 
Sevcikova et al. (2016) as shown in the Example below. It can be used for both, 5-year and 1-year age groups.
</p>
<p>Other methods for forecasting mortality rates are available:
</p>

<ul>
<li> <p><code><a href="#topic+pmd">pmd</a></code>: pattern of mortality decline
</p>
</li>
<li> <p><code><a href="#topic+mlt">mlt</a></code>: model life tables
</p>
</li>
<li> <p><code><a href="#topic+logquad">logquad</a></code>: log-quadratic mortality model 
</p>
</li>
<li> <p><code><a href="#topic+mortcast.blend">mortcast.blend</a></code>: combining two different methods
</p>
</li></ul>

<p>A life table can be constructed using the <code><a href="#topic+life.table">life.table</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Nan Li and Patrick Gerland
</p>


<h3>References</h3>

<p>Li, N. and Lee, R. D. (2005). Coherent mortality forecasts for a group of populations: 
An extension of the Lee-Carter method. Demography, 42, 575-594.
</p>
<p>Li, N., Lee, R. D. and Gerland, P. (2013). Extending the Lee-Carter method to model the rotation 
of age patterns of mortality decline for long-term projections. Demography, 50, 2037-2051.
</p>
<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham. <a href="https://arxiv.org/abs/1503.05215">Earlier version</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example applies Algorithm 2 in Sevcikova et al. (2016) 
# on data from WPP2017 for China
#
data(mxM, mxF, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "China"

# extract observed mortality rates for male and female
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))

# Step 1: extrapolate from 100+ to 130+ using Coherent Kannisto
mx130 &lt;- cokannisto(mxm, mxf)
 
# Steps 2-5: estimate coherent Lee-Carter parameters
# (here ax is computed from the last observed period 
# and smoothened over ages)
lc.est &lt;- lileecarter.estimate(mx130$male, mx130$female, 
            ax.index = ncol(mx130$male), ax.smooth = TRUE)
        
# Steps 6-9: project future mortality rates based on future 
# life expectancies from WPP2017
e0f &lt;- as.numeric(subset(e0Fproj, name == country)[-(1:2)])
e0m &lt;- as.numeric(subset(e0Mproj, name == country)[-(1:2)])
names(e0f) &lt;- names(e0m) &lt;- colnames(e0Fproj)[-(1:2)]
pred &lt;- mortcast(e0m, e0f, lc.est)

# plot projection for the first and last future time period
plot(pred$female$mx[,"2015-2020"], type="l", log="y", 
    ylim=range(pred$female$mx, pred$male$mx), xaxt="n",
    ylab="mx", xlab="Age", main=country, col="red")
axis(1, at=1:nrow(pred$female$mx),
    labels=rownames(pred$female$mx))
lines(pred$male$mx[,"2015-2020"], col="blue")
lines(pred$female$mx[,"2095-2100"], col="red", lty=2)
lines(pred$male$mx[,"2095-2100"], col="blue", lty=2)
legend("topleft", legend=c("male 2015-2020", "female 2015-2020",
    "male 2095-2100", "female 2095-2100"), bty="n",
    col=rep(c("blue", "red"),2), lty=c(1,1,2,2))

</code></pre>

<hr>
<h2 id='cokannisto'>Coherent Kannisto Method</h2><span id='topic+cokannisto'></span>

<h3>Description</h3>

<p>Extrapolate given mortality rates into higher ages 
using the Coherent Kannisto method as described in Sevcikova et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cokannisto(
  mxM,
  mxF,
  est.ages = seq(80, 95, by = 5),
  proj.ages = seq(100, 130, by = 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cokannisto_+3A_mxm">mxM</code></td>
<td>
<p>A vector or matrix of male mortality rates. If it is a matrix,
rows correspond to age groups with rownames identifying the corresponding age as integers.
By default five-years age groups are assigned to rows if rownames are not given.</p>
</td></tr>
<tr><td><code id="cokannisto_+3A_mxf">mxF</code></td>
<td>
<p>A vector or matrix of female mortality rates. Its length or dimension 
should be the same <code>mxM</code>.</p>
</td></tr>
<tr><td><code id="cokannisto_+3A_est.ages">est.ages</code></td>
<td>
<p>A vector of integers identifying the ages to be used 
for estimation. It should be a subset of rownames of <code>mxM</code>. Change the defaults if 
1-year age groups are used (see Example in <code><a href="#topic+kannisto">kannisto</a></code>).</p>
</td></tr>
<tr><td><code id="cokannisto_+3A_proj.ages">proj.ages</code></td>
<td>
<p>A vector of integers identifying the age groups for which mortality rates 
are to be projected. Change the defaults if 
1-year age groups are used (see Example in <code><a href="#topic+kannisto">kannisto</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first estimates the coherent Kannisto parameters 
by passing mortality rates for age groups <code>est.ages</code> into 
the <code><a href="#topic+cokannisto.estimate">cokannisto.estimate</a></code> function.
The estimated parameters are then passed to the projection function
<code><a href="#topic+kannisto.predict">kannisto.predict</a></code> to extrapolate into ages <code>proj.ages</code>.
Lastly, the input mortality objects are extended by results for the extrapolated ages. 
If <code>proj.ages</code> contains age groups that are included in <code>mxM</code> and <code>mxF</code>,
values for those age groups are overwritten.
</p>


<h3>Value</h3>

<p>A list of two vectors or matrices (for male and female) containing the input motality 
objects extended by the extrapolated age groups.
</p>


<h3>References</h3>

<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cokannisto.estimate">cokannisto.estimate</a></code>, <code><a href="#topic+kannisto.predict">kannisto.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, mxF, package = "wpp2017")
country &lt;- "South Africa"
mxm &lt;- subset(mxM, name == country)[,-(1:3)]
mxf &lt;- subset(mxF, name == country)[,-(1:3)]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
mxnew &lt;- cokannisto(mxm, mxf)
ages &lt;- as.integer(rownames(mxnew$male))
plot(ages, mxnew$male[,"2095-2100"], type="l", log="y", 
    xlab="age", ylab="mx", col="blue", main=country)
lines(ages, mxnew$female[,"2095-2100"], col="red")
lines(ages, mxnew$male[,"2010-2015"], lty=2, col="blue")
lines(ages, mxnew$female[,"2010-2015"], lty=2, col="red")
legend("bottomright", legend=c("male 2010-2015", "female 2010-2015",
    "male 2095-2100", "female 2095-2100"), bty="n",
    col=rep(c("blue", "red"),2), lty=c(2,2,1,1))

</code></pre>

<hr>
<h2 id='cokannisto.estimate'>Coherent Kannisto Estimation</h2><span id='topic+cokannisto.estimate'></span>

<h3>Description</h3>

<p>Estimate the coherent Kannisto parameters as described in Sevcikova et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cokannisto.estimate(mxM, mxF, ages, fitted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cokannisto.estimate_+3A_mxm">mxM</code></td>
<td>
<p>A vector of male mortality rates.</p>
</td></tr>
<tr><td><code id="cokannisto.estimate_+3A_mxf">mxF</code></td>
<td>
<p>A vector of female mortality rates.</p>
</td></tr>
<tr><td><code id="cokannisto.estimate_+3A_ages">ages</code></td>
<td>
<p>A vector of ages corresponding to <code>mxM</code> and <code>mxF</code>.</p>
</td></tr>
<tr><td><code id="cokannisto.estimate_+3A_fitted">fitted</code></td>
<td>
<p>Logical. If <code>TRUE</code> the fitted values and residuals are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the Kannisto equation <code class="reqn">logit(m_x) = \log(c) + dx</code>,
the Coherent Kannisto method estimates the <code class="reqn">d</code> parameter jointly for male and female 
data, in order to prevent mortality crossovers in higher ages.
</p>


<h3>Value</h3>

<p>List of two lists, one for male and one for female. Each of the two lists contains the following components:
</p>

<dl>
<dt><code>coefficients</code>:</dt><dd><p>named vector with the coherent Kannisto coefficients <code class="reqn">c</code> and <code class="reqn">d</code>. The <code class="reqn">d</code> values are the same in both lists.</p>
</dd>
<dt><code>fitted.values</code>:</dt><dd><p>the fitted values (not included if <code>fitted</code> is <code>FALSE</code>)</p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>input rates minus the fitted values (not included if <code>fitted</code> is <code>FALSE</code>)</p>
</dd>
</dl>



<h3>References</h3>

<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cokannisto">cokannisto</a></code>, <code><a href="#topic+kannisto.predict">kannisto.predict</a></code>, <code><a href="#topic+kannisto">kannisto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, mxF, package = "wpp2017")
country &lt;- "Brazil"
mxm &lt;- subset(mxM, name == country)[,"2010-2015"]
mxf &lt;- subset(mxF, name == country)[,"2010-2015"]
cokannisto.estimate(mxm[18:21], mxf[18:21], ages = 18:21)

</code></pre>

<hr>
<h2 id='kannisto'>Kannisto Method</h2><span id='topic+kannisto'></span>

<h3>Description</h3>

<p>Extrapolate given mortality rates using the original Kannisto method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kannisto(mx, est.ages = seq(80, 95, by = 5), proj.ages = seq(100, 130, by = 5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kannisto_+3A_mx">mx</code></td>
<td>
<p>A vector or matrix of mortality rates. If it is a matrix,
rows correspond to age groups with rownames identifying the corresponding age as integers.
By default five-years age groups are assigned to rows if rownames are not given.</p>
</td></tr>
<tr><td><code id="kannisto_+3A_est.ages">est.ages</code></td>
<td>
<p>A vector of integers identifying the ages to be used 
for estimation. It should be a subset of rownames of <code>mx</code>. Change the defaults if 
1-year age groups are used (see Example).</p>
</td></tr>
<tr><td><code id="kannisto_+3A_proj.ages">proj.ages</code></td>
<td>
<p>A vector of integers identifying the age groups for which mortality rates 
are to be projected. Change the defaults if 1-year age groups are used (see Example).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first estimates the original Kannisto parameters 
by passing mortality rates for age groups <code>est.ages</code> into 
the <code><a href="#topic+kannisto.estimate">kannisto.estimate</a></code> function.
The estimated parameters are then passed to the projection function
<code><a href="#topic+kannisto.predict">kannisto.predict</a></code> to extrapolate into ages <code>proj.ages</code>.
Lastly, the input mortality object is extended by results for the extrapolated ages. 
If <code>proj.ages</code> contains age groups that are included in <code>mx</code>,
values for those age groups are overwritten.
</p>


<h3>Value</h3>

<p>A vector or matrix containing the input mortality object <code>mx</code>
extended by the extrapolated age groups.
</p>


<h3>References</h3>

<p>Thatcher, A. R., Kannisto, V. and Vaupel, J. W. (1998). The Force of Mortality at Ages 80 to 120, 
volume 5 of Odense Monographs on Population Aging Series. Odense, Denmark: Odense University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kannisto.estimate">kannisto.estimate</a></code>, <code><a href="#topic+kannisto.predict">kannisto.predict</a></code>, <code><a href="#topic+cokannisto">cokannisto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, package = "wpp2017")
mx &lt;- subset(mxM, name == "Burkina Faso")[,-(1:3)]
rownames(mx) &lt;- c(0,1, seq(5, 100, by=5))
mxnew &lt;- kannisto(mx)
ages &lt;- as.integer(rownames(mxnew))
plot(ages, mxnew[,"2095-2100"], type="l", log="y", 
    xlab="age", ylab="mx", col="red")
lines(ages, mxnew[,"2010-2015"])

# Kannisto for 1-year age groups
# derive toy 1-year mx using model life tables at e0 of 70
mx1y &lt;- mlt(70, sex = "male", nx = 1)
# Pretend we only observed mx for ages 0:100. 
# Use 90-99 for estimation and extend mx from 100 to 140
mx1ynew &lt;- kannisto(mx1y[1:100, , drop = FALSE], est.ages = 90:99, proj.ages = 100:140)
# Plot the new mx for old ages
plot(80:140, mx1ynew[81:141], type = "l", xlab="age", ylab="mx", col="red")
# Check how it compares to the original mx that was not used in the estimation
lines(100:130, mx1y[101:nrow(mx1y)])

</code></pre>

<hr>
<h2 id='kannisto.estimate'>Kannisto Estimation</h2><span id='topic+kannisto.estimate'></span>

<h3>Description</h3>

<p>Estimate the Kannisto parameters (Thatcher et al. 1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kannisto.estimate(mx, ages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kannisto.estimate_+3A_mx">mx</code></td>
<td>
<p>A vector of mortality rates.</p>
</td></tr>
<tr><td><code id="kannisto.estimate_+3A_ages">ages</code></td>
<td>
<p>A vector of ages corresponding to <code>mx</code>. These can be indices of age groups or raw ages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the Kannisto equation <code class="reqn">logit(m_x) = \log(c) + dx</code>,
the function estimates the <code class="reqn">c</code> and <code class="reqn">d</code> parameters using 
values of <code>ages</code> as the covariate <code class="reqn">x</code>.
</p>


<h3>Value</h3>

<p>List with the following components:
</p>

<dl>
<dt><code>coefficients</code>:</dt><dd><p>named vector with Kannisto coefficients <code class="reqn">c</code> and <code class="reqn">d</code>.</p>
</dd>
<dt><code>fitted.values</code>:</dt><dd><p>the fitted values</p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>input rates minus the fitted values</p>
</dd>
</dl>



<h3>References</h3>

<p>Thatcher, A. R., Kannisto, V. and Vaupel, J. W. (1998). The Force of Mortality at Ages 80 to 120, 
volume 5 of Odense Monographs on Population Aging Series. Odense, Denmark: Odense University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kannisto.predict">kannisto.predict</a></code>, <code><a href="#topic+kannisto">kannisto</a></code>, <code><a href="#topic+cokannisto.estimate">cokannisto.estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, package = "wpp2017")
mx &lt;- subset(mxM, name == "Canada")[,"2010-2015"]
kannisto.estimate(mx[18:21], ages = 18:21)

</code></pre>

<hr>
<h2 id='kannisto.predict'>Kannisto Prediction</h2><span id='topic+kannisto.predict'></span>

<h3>Description</h3>

<p>Given estimated Kannisto parameters (coherent or original), 
it predicts mortality rates for given ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kannisto.predict(pars, ages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kannisto.predict_+3A_pars">pars</code></td>
<td>
<p>A named vector with Kanisto coefficients <code class="reqn">c</code> and <code class="reqn">d</code> 
(e.g. result of <code><a href="#topic+kannisto.estimate">kannisto.estimate</a></code> or <code><a href="#topic+cokannisto.estimate">cokannisto.estimate</a></code>).</p>
</td></tr>
<tr><td><code id="kannisto.predict_+3A_ages">ages</code></td>
<td>
<p>A vector of ages to make prediction for. These can be indices of age groups or raw ages, 
but on the same scale as used in the estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given parameters <code class="reqn">c</code> and <code class="reqn">d</code> in <code>pars</code>, 
the function uses the Kannisto equation <code class="reqn">logit(m_x) = \log(c) + dx</code>,
to predict mortality rates for age groups <code class="reqn">x</code> given by <code>ages</code>.
</p>


<h3>Value</h3>

<p>Vector of predicted mortality rates.
</p>


<h3>References</h3>

<p>Thatcher, A. R., Kannisto, V. and Vaupel, J. W. (1998). The Force of Mortality at Ages 80 to 120, 
volume 5 of Odense Monographs on Population Aging Series. Odense, Denmark: Odense University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cokannisto">cokannisto</a></code>, <code><a href="#topic+kannisto.estimate">kannisto.estimate</a></code>, <code><a href="#topic+cokannisto.estimate">cokannisto.estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, mxF, package = "wpp2017")
mxm &lt;- subset(mxM, name == "Germany")[,"2010-2015"]
ages &lt;- c(0, 1, seq(5, 130, by=5))

# using original Kannisto parameters
pars &lt;- kannisto.estimate(mxm[18:21], ages = ages[18:21])
mxm.pred &lt;- kannisto.predict(pars$coefficients, ages = ages[22:28])
plot(ages, c(mxm[1:21], mxm.pred), type="l", log="y", 
    xlab="age", ylab="mx")
    
# Coherent Kannisto
mxf &lt;- subset(mxF, name == "Germany")[,"2010-2015"]
copars &lt;- cokannisto.estimate(
   mxm[18:21], mxf[18:21], ages = ages[18:21])
cmxm.pred &lt;- kannisto.predict(copars[["male"]]$coefficients, ages = ages[22:28])
cmxf.pred &lt;- kannisto.predict(copars[["female"]]$coefficients, ages = ages[22:28])
plot(ages, c(mxm[1:21], cmxm.pred), type="l", log="y", 
    xlab="age", ylab="mx", col="blue")
lines(ages, c(mxf[1:21], cmxf.pred), col="red")

</code></pre>

<hr>
<h2 id='leecarter.estimate'>Lee-Carter Estimation</h2><span id='topic+leecarter.estimate'></span>

<h3>Description</h3>

<p>Estimate Lee-Carter parameters (Lee and Carter 1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leecarter.estimate(
  mx,
  ax.index = NULL,
  ax.smooth = FALSE,
  ax.smooth.df = NULL,
  bx.postprocess = TRUE,
  nx = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leecarter.estimate_+3A_mx">mx</code></td>
<td>
<p>A matrix of age-specific mortality rates where rows correspond to age groups
and columns correspond to time periods. Rownames define the starting ages of the age groups.</p>
</td></tr>
<tr><td><code id="leecarter.estimate_+3A_ax.index">ax.index</code></td>
<td>
<p>A vector of column indices of <code>mx</code> to be used to estimate the <code class="reqn">a_x</code> parameter.
By default all time periods are used.</p>
</td></tr>
<tr><td><code id="leecarter.estimate_+3A_ax.smooth">ax.smooth</code></td>
<td>
<p>Logical allowing to smooth the <code class="reqn">a_x</code> over ages.</p>
</td></tr>
<tr><td><code id="leecarter.estimate_+3A_ax.smooth.df">ax.smooth.df</code></td>
<td>
<p>Degree of freedom for smoothing if <code>ax.smooth</code> is <code>TRUE</code>. 
Default is half the length of <code class="reqn">a_x</code>.</p>
</td></tr>
<tr><td><code id="leecarter.estimate_+3A_bx.postprocess">bx.postprocess</code></td>
<td>
<p>Logical determining if numerical anomalies in <code class="reqn">b_x</code> should be dealt with.</p>
</td></tr>
<tr><td><code id="leecarter.estimate_+3A_nx">nx</code></td>
<td>
<p>Size of age groups. By default ages are determined by rownames of <code>mx</code>. This argument is only used if 
<code>mx</code> has no rownames. If <code>nx</code> is 5, the age groups are interpreted as 0, 1, 5, 10, .... For <code>nx</code> equals 1, 
the age groups are interpreted as 0, 1, 2, 3, ....</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates parameters of <code class="reqn">\log(m_x(t)) = a_x + b_x k(t) + \epsilon_x(t)</code> (Lee and Carter 1992). 
The argument <code>ax.index</code> determines which time periods to use to 
estimate the <code class="reqn">a_x</code> parameter, while <code>ax.smooth</code> controls if 
the resulting <code class="reqn">a_x</code> should be smoothened over ages (see Sevcikova et al. 2016 for details).
</p>


<h3>Value</h3>

<p>List with elements <code>ax</code>, <code>bx</code> and <code>kt</code> corresponding to the estimated parameters.
</p>


<h3>References</h3>

<p>Lee, R. D. and Carter, L. (1992). Modeling and forecasting the time series of 
US mortality. Journal of the American Statistical Association, 87, 659-671.
</p>
<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mortcast">mortcast</a></code>, <code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, package = "wpp2017")
mx &lt;- subset(mxM, name == "Netherlands")[,4:16]
rownames(mx) &lt;- c(0,1, seq(5, 100, by=5))
lc.ax.avg &lt;- leecarter.estimate(mx)
lc.ax.last &lt;- leecarter.estimate(mx, ax.index=ncol(mx))
plot(lc.ax.avg$ax, type="l")
lines(lc.ax.last$ax, col="blue")

</code></pre>

<hr>
<h2 id='life.table'>Life Table Function</h2><span id='topic+life.table'></span>

<h3>Description</h3>

<p>Function for obtaining life table quantities from mortality rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>life.table(
  mx,
  sex = c("male", "female", "total"),
  abridged = TRUE,
  a0rule = c("ak", "cd"),
  radix = 1,
  open.age = 130
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="life.table_+3A_mx">mx</code></td>
<td>
<p>Vector of age-specific mortality rates nmx. If <code>abridged</code> is <code>TRUE</code> (default), 
the elements correspond to 1m0, 4m1, 5m5, 5m10, .... 
If <code>abridged</code> is <code>FALSE</code>, they correspond to 1m0, 1m1, 1m2, 1m3, ....</p>
</td></tr>
<tr><td><code id="life.table_+3A_sex">sex</code></td>
<td>
<p>Which sex the mortality rates correspond to.</p>
</td></tr>
<tr><td><code id="life.table_+3A_abridged">abridged</code></td>
<td>
<p>Is it an abridged life table (<code>TRUE</code>, default) or not (<code>FALSE</code>). 
In the former case, the <code>mx</code> vector is interpreted as corresponding to age groups 0, 1-4, 5-9, 10-14, ....
If <code>FALSE</code>, the <code>mx</code> vector is interpreted as corresponding to one-year age groups, i.e. 0, 1, 2, 3, ....</p>
</td></tr>
<tr><td><code id="life.table_+3A_a0rule">a0rule</code></td>
<td>
<p>Rule for approximation of a0. &quot;ak&quot; (default) uses the Andreev-Kingkade method (Andreev and Kingkade, 2015), &quot;cd&quot; uses the 
Coale-Demeany method.</p>
</td></tr>
<tr><td><code id="life.table_+3A_radix">radix</code></td>
<td>
<p>Base of the life table.</p>
</td></tr>
<tr><td><code id="life.table_+3A_open.age">open.age</code></td>
<td>
<p>Open age group. If smaller than the last age group of <code>mx</code>, the life table is truncated. 
It does not have any effect if larger than the last age group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a life table corresponding to given mortality rates for either 5- or 1-year age groups. The implementation follows
Preston et al. (2001).
</p>


<h3>Value</h3>

<p>Data frame with rows corresponding to age groups and the following columns:
</p>

<dl>
<dt>age</dt><dd><p>Starting year of the age group.</p>
</dd>
<dt>mx</dt><dd><p>Age-specific mortality rates as passed into the <code>mx</code> argument.</p>
</dd>
<dt>qx</dt><dd><p>Probability of dying between ages x and x+n.</p>
</dd>
<dt>lx</dt><dd><p>Number of survivors at age x.</p>
</dd>
<dt>dx</dt><dd><p>Number of deaths between ages x and x+n.</p>
</dd>
<dt>Lx</dt><dd><p>Person-years lived between ages x and x+n.</p>
</dd>
<dt>sx</dt><dd><p>Survival rate from age x to x+n. Note that in an abridged life table, sx always refers to 5-year intervals. 
Here, sx in the first row is the survival from births to the second age group, sx in the second row 
is the survival from age 0-4 to age 5-9, third row has the survival from 5-9 to 10-14 etc.</p>
</dd>
<dt>Tx</dt><dd><p>Person-years lived after age x.</p>
</dd>
<dt>ex</dt><dd><p>Life expectancy at age x.</p>
</dd>
<dt>ax</dt><dd><p>Average person-years lived in the interval by those dying in the interval. For young ages, 
it follows Preston et al. (2001), Table 3.3 on page 48. If <code>a0rule</code> is &quot;ak&quot; (default) 
the Andreev-Kingkade method is used for a0. 
For compatibility with computations done at the UN, we set ax for ages 5 and 10 in the abridged version
to 2.5. For an unabridged life table, ax is set to 0.5 for all but first and last age groups.</p>
</dd>
</dl>



<h3>References</h3>

<p>Preston, S.H., Heuveline, P., Guillot, M. (2001). Demography: Measuring and Modeling Population Processes. Oxford: Blackwell Publishers Ltd.
</p>
<p>Andreev, E.M. and Kingkade, W.W. (2015). <a href="https://www.demographic-research.org/volumes/vol33/13/33-13.pdf">Average age at death in infancy and infant mortality level: Reconsidering the Coale-Demeny formulas at current levels of low mortality.</a>
Demographic Research, 33(13), p.363-390. DOI: 10.4054/DemRes.2015.33.13
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxF, e0Fproj, package = "wpp2017")
# get female mortality of Mexico for the current year
country &lt;- "Mexico"
mxf &lt;- subset(mxF, name == country)[,"2010-2015"]
life.table(mxf, sex = "female")

</code></pre>

<hr>
<h2 id='lileecarter.estimate'>Coherent Lee-Carter Estimation</h2><span id='topic+lileecarter.estimate'></span>

<h3>Description</h3>

<p>Estimate coherent Lee-Carter parameters (Li and Lee 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lileecarter.estimate(mxM, mxF, nx = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lileecarter.estimate_+3A_mxm">mxM</code></td>
<td>
<p>A matrix of male age-specific mortality rates where rows correspond to age groups
and columns correspond to time periods. For 5-year age groups, the first and second rows corresponds to 
0-1 and 1-5 age groups, respectively. Rownames define the starting ages of the respective groups.</p>
</td></tr>
<tr><td><code id="lileecarter.estimate_+3A_mxf">mxF</code></td>
<td>
<p>A matrix of female mortality rates of the same shape as <code>mxM</code>.</p>
</td></tr>
<tr><td><code id="lileecarter.estimate_+3A_nx">nx</code></td>
<td>
<p>Size of age groups. Should be either 5 or 1.</p>
</td></tr>
<tr><td><code id="lileecarter.estimate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coherent Lee-Carter parameters for male and female mortality rates 
share the same <code class="reqn">b_x</code> which is the average of the age-specific 
<code class="reqn">b_x</code> parameters. 
</p>
<p>The function in addition computes the ultimate <code class="reqn">b^u_x</code> as defined in 
Li et al. (2013) based on the coherent <code class="reqn">b_x</code>.
</p>


<h3>Value</h3>

<p>List containing elements <code>bx</code> (coherent <code class="reqn">b_x</code> parameter), 
<code>ultimate.bx</code> (ultimate <code class="reqn">b^u_x</code> parameter), <code>ages</code> (age groups), <code>nx</code> (age group interval), and
lists <code>female</code> and <code>male</code>, each with the Lee-Carter parameters.
</p>


<h3>References</h3>

<p>Li, N. and Lee, R. D. (2005). Coherent mortality forecasts for a group of populations: 
An extension of the Lee-Carter method. Demography, 42, 575-594.
</p>
<p>Li, N., Lee, R. D. and Gerland, P. (2013). Extending the Lee-Carter method to model the rotation 
of age patterns of mortality decline for long-term projections. Demography, 50, 2037-2051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, mxF, package = "wpp2017")
country &lt;- "Germany"
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
lc &lt;- lileecarter.estimate(mxm, mxf)
plot(lc$bx, type="l")
lines(lc$ultimate.bx, lty=2)

</code></pre>

<hr>
<h2 id='logquad'>Log-Quadratic Mortality Model</h2><span id='topic+logquad'></span><span id='topic+logquadj'></span>

<h3>Description</h3>

<p>Predict age-specific mortality rates using the Log-Quadratic Mortality Model (Wilmoth et al. 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logquad(
  e0,
  sex = c("male", "female", "total"),
  my.coefs = NULL,
  q5ranges = c(1e-04, 0.9),
  k = 0,
  keep.lt = FALSE,
  ...
)

logquadj(e0m, e0f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logquad_+3A_e0">e0</code></td>
<td>
<p>Vector of target life expectancies.</p>
</td></tr>
<tr><td><code id="logquad_+3A_sex">sex</code></td>
<td>
<p>Which sex does the give <code>e0</code> corresponds to.</p>
</td></tr>
<tr><td><code id="logquad_+3A_my.coefs">my.coefs</code></td>
<td>
<p>Data frame with columns &ldquo;sex&rdquo;, &ldquo;age&rdquo;, &ldquo;ax&rdquo;, &ldquo;bx&rdquo;, &ldquo;cx&rdquo;, &ldquo;vx&rdquo;.
The &ldquo;sex&rdquo; column should contain values &ldquo;female&rdquo;, &ldquo;male&rdquo; and/or &ldquo;total&rdquo;.
The &ldquo;age&rdquo; column must be sorted so that it assures that rows correspond to ages in increasing order.
Any <code>NA</code>s are internally converted to zeros. If not given, the dataset <code><a href="#topic+LQcoef">LQcoef</a></code> is used.</p>
</td></tr>
<tr><td><code id="logquad_+3A_q5ranges">q5ranges</code></td>
<td>
<p>A vector of size two, giving the min and max of 5q0 used in the bisection method.</p>
</td></tr>
<tr><td><code id="logquad_+3A_k">k</code></td>
<td>
<p>Value of the <code class="reqn">k</code> parameter.</p>
</td></tr>
<tr><td><code id="logquad_+3A_keep.lt">keep.lt</code></td>
<td>
<p>Logical. If <code>TRUE</code> additional life table columns are kept in the 
resulting object.</p>
</td></tr>
<tr><td><code id="logquad_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying function.</p>
</td></tr>
<tr><td><code id="logquad_+3A_e0m">e0m</code></td>
<td>
<p>A time series of target male life expectancy.</p>
</td></tr>
<tr><td><code id="logquad_+3A_e0f">e0f</code></td>
<td>
<p>A time series of target female life expectancy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LogQuad method in this implementation projects mortality rates using the equation
</p>
<p style="text-align: center;"><code class="reqn">\log(m_x) = a_x + b_x h + c_x h^2 + v_x k</code>
</p>

<p>where <code class="reqn">a_x</code>, <code class="reqn">b_x</code>, <code class="reqn">c_x</code> and <code class="reqn">v_x</code> are age-specific coefficients, <code class="reqn">h = \log( 5q0 )</code> 
(i.e. reflects child mortality), 
and <code class="reqn">k</code> should be chosen to match 45q15 (adult mortality) or set to 0 (default). The coefficients
can be passed as inputs, or taken from the package default dataset <code><a href="#topic+LQcoef">LQcoef</a></code> which 
are taken from <a href="https://u.demog.berkeley.edu/~jrw/LogQuad/">https://u.demog.berkeley.edu/~jrw/LogQuad/</a>.
</p>
<p>For the given inputs and values of life expectancy e0, the function finds values of <code class="reqn">h</code> that 
best match e0, using life tables and the bisection method. It returns the corresponding mortality schedule
for each value of e0.
</p>
<p>Function <code>logquad</code> is for one sex, while <code>logquadj</code> can be used for both sexes.
</p>


<h3>Value</h3>

<p>Function <code>logquad</code> returns a list with the following elements: a matrix <code>mx</code>
with the predicted mortality rates. If <code>keep.lt</code> is <code>TRUE</code>, it also 
contains matrices <code>sr</code> (survival rates), and life table quantities <code>Lx</code> and <code>lx</code>.
Function <code>logquadj</code> returns a list of objects, one for each sex.
</p>


<h3>References</h3>

<p>Wilmoth, J., Zureick, S., Canudas-Romo, V., Inoue, M., Sawyer, C. (2012). 
A Flexible Two-Dimensional Mortality Model for Use in Indirect Estimation. 
Population studies, 66(1), 1-28. doi: <a href="https://doi.org/10.1080/00324728.2011.611411">10.1080/00324728.2011.611411</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LQcoef">LQcoef</a></code>, <code><a href="#topic+mortcast.blend">mortcast.blend</a></code>, <code><a href="#topic+mortcast">mortcast</a></code>, <code><a href="#topic+pmd">pmd</a></code>, <code><a href="#topic+mlt">mlt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(e0Mproj, package = "wpp2017")
country &lt;- "Brazil"
# get target e0
e0m &lt;- as.numeric(subset(e0Mproj, name == country)[-(1:2)])
# project into future
pred &lt;- logquad(e0m, sex = "male")
# plot first projection in black and the remaining ones in heat colors 
plot(pred$mx[,1], type = "l", log = "y", ylim = range(pred$mx),
    ylab = "male mx", xlab = "Age", main = country)
for(i in 2:ncol(pred$mx)) lines(pred$mx[,i], 
    col = heat.colors(20)[i])
    
</code></pre>

<hr>
<h2 id='LQcoef'>Coefficients for the Log-Quadratic Mortality Model</h2><span id='topic+LQcoef'></span>

<h3>Description</h3>

<p>Data object containing a table of coefficients to be used in the Log-Quadratic Model 
as implemented in the <code><a href="#topic+logquad">logquad</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LQcoef)
</code></pre>


<h3>Format</h3>

<p>Data frame containing columns &ldquo;sex&rdquo;, &ldquo;age&rdquo;, &ldquo;ax&rdquo;, &ldquo;bx&rdquo;, &ldquo;cx&rdquo;, &ldquo;vx&rdquo;. 
Rows correspond to sex and age groups.
</p>


<h3>Source</h3>

<p><a href="https://u.demog.berkeley.edu/~jrw/LogQuad/">https://u.demog.berkeley.edu/~jrw/LogQuad/</a>
</p>


<h3>References</h3>

<p>Wilmoth, J., Zureick, S., Canudas-Romo, V., Inoue, M., Sawyer, C. (2012). 
A Flexible Two-Dimensional Mortality Model for Use in Indirect Estimation. 
Population studies, 66(1), 1-28. doi: <a href="https://doi.org/10.1080/00324728.2011.611411">10.1080/00324728.2011.611411</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logquad">logquad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LQcoef)
head(LQcoef)


</code></pre>

<hr>
<h2 id='mlt'>Model Life Tables Mortality Patterns</h2><span id='topic+mlt'></span><span id='topic+mltj'></span>

<h3>Description</h3>

<p>Predict age-specific mortality rates using Coale-Demeny and UN model life tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlt(e0, sex = c("male", "female"), type = "CD_West", nx = 5, ...)

mltj(e0m, e0f, ..., nx = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlt_+3A_e0">e0</code></td>
<td>
<p>A time series of target life expectancy.</p>
</td></tr>
<tr><td><code id="mlt_+3A_sex">sex</code></td>
<td>
<p>Either &quot;male&quot; or &quot;female&quot;.</p>
</td></tr>
<tr><td><code id="mlt_+3A_type">type</code></td>
<td>
<p>Type of the model life table. Available options are &ldquo;CD_East&rdquo;, &ldquo;CD_North&rdquo;, 
&ldquo;CD_South&rdquo;, &ldquo;CD_West&rdquo;, &ldquo;UN_Chilean&rdquo;, &ldquo;UN_Far_Eastern&rdquo;, 
&ldquo;UN_General&rdquo;, &ldquo;UN_Latin_American&rdquo;, &ldquo;UN_South_Asian&rdquo;.</p>
</td></tr>
<tr><td><code id="mlt_+3A_nx">nx</code></td>
<td>
<p>Size of age groups. Should be either 5 or 1.</p>
</td></tr>
<tr><td><code id="mlt_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying function.</p>
</td></tr>
<tr><td><code id="mlt_+3A_e0m">e0m</code></td>
<td>
<p>A time series of target male life expectancy.</p>
</td></tr>
<tr><td><code id="mlt_+3A_e0f">e0f</code></td>
<td>
<p>A time series of target female life expectancy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a level of life expectancy (e0), sex and a type of model life table, the function 
extracts the corresponding mortality pattern from <code><a href="#topic+MLTlookup">MLTlookup</a></code> (for abridged LT) 
or <code><a href="#topic+MLT1Ylookup">MLT1Ylookup</a></code> (for 1-year LT), 
while interpolating between neighboring e0 groups.
Function <code>mlt</code> is for one sex, while <code>mltj</code> can be used for both sexes.
</p>


<h3>Value</h3>

<p>Function <code>mlt</code> returns a matrix with the predicted mortality rates. Columns correspond 
to the values in the <code>e0</code> vector and rows correspond to age groups. 
Function <code>mltj</code> returns a list of such matrices, one for each sex.
</p>


<h3>References</h3>

<p><a href="https://www.un.org/development/desa/pd/data/extended-model-life-tables">https://www.un.org/development/desa/pd/data/extended-model-life-tables</a>
</p>
<p>Coale, A., P. Demeny, and B. Vaughn. 1983. Regional model life tables and stable 
populations. 2nd ed. New York: Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mortcast">mortcast</a></code>, <code><a href="#topic+mortcast.blend">mortcast.blend</a></code>, <code><a href="#topic+pmd">pmd</a></code>, <code><a href="#topic+MLTlookup">MLTlookup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(e0Fproj, package = "wpp2017")
country &lt;- "Uganda"
# get target e0
e0f &lt;- subset(e0Fproj, name == country)[-(1:2)]
# project into future using life table Cole-Demeny North
mx &lt;- mlt(e0f, sex = "female", type = "CD_North")
# plot first projection in black and the remaining ones in grey 
plot(mx[,1], type = "l", log = "y", ylim = range(mx),
    ylab = "female mx", xlab = "Age", 
    main = paste(country, "5-year age groups"))
for(i in 2:ncol(mx)) lines(mx[,i], col = "grey")

# MLT for 1-year age groups
mx1y &lt;- mlt(e0f, sex = "female", type = "CD_North", nx = 1)
plot(mx1y[,1], type = "l", log = "y", ylim = range(mx1y),
    ylab = "female mx", xlab = "Age", 
    main = paste(country, "1-year age groups"))
for(i in 2:ncol(mx1y)) lines(mx1y[,i], col = "grey")
    
</code></pre>

<hr>
<h2 id='MLTlookup'>Model Life Tables Lookup</h2><span id='topic+MLTlookup'></span><span id='topic+MLT1Ylookup'></span>

<h3>Description</h3>

<p>Lookup tables containing values for various model life tables, including 
Coale-Demeny and UN life tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MLTlookup)
data(MLT1Ylookup)
</code></pre>


<h3>Format</h3>

<p>Data frame with the following columns:
</p>

<dl>
<dt>type</dt><dd><p>Type of the model life table. Available options are &ldquo;CD_East&rdquo;, &ldquo;CD_North&rdquo;, 
&ldquo;CD_South&rdquo;, &ldquo;CD_West&rdquo;, &ldquo;UN_Chilean&rdquo;, &ldquo;UN_Far_Eastern&rdquo;, 
&ldquo;UN_General&rdquo;, &ldquo;UN_Latin_American&rdquo;, &ldquo;UN_South_Asian&rdquo;. 
For the CD types, see Coale et al. (1983). For the UN types, see the link in References below.
</p>
</dd>
<dt>sex</dt><dd><p>Code for distinguishing sexes. 1 is for male, 2 is for female.</p>
</dd>
<dt>age</dt><dd><p>Starting age of an age group. In <code>MLTlookup</code> these are 0, 1, 5, 10, ... 130. 
The <code>MLT1Ylookup</code> table contains 1-year ages ranging from 0 to 130.</p>
</dd>
<dt>e0</dt><dd><p>Level of life expectancy, starting at 20 and going by steps of 2.5 up to 115.</p>
</dd>
<dt>mx</dt><dd><p>Mortality rates.</p>
</dd>
<dt>lx, Lx, sx</dt><dd><p>Other life table columns.</p>
</dd>
</dl>



<h3>Source</h3>

<p>An updated version of these datasets were provided by Sara Hertog, United Nations Population Division, in October 2021 (package version &gt;= 2.6-0).
For previous version of the tables, install MortCast 2.5-0: 'devtools::install_github(&quot;PPgp/MortCast@v2.5-0&quot;)'
</p>


<h3>References</h3>

<p>Coale, A., P. Demeny, and B. Vaughn. 1983. Regional model life tables and stable 
populations. 2nd ed. New York: Academic Press.
</p>
<p><a href="https://www.un.org/development/desa/pd/data/extended-model-life-tables">https://www.un.org/development/desa/pd/data/extended-model-life-tables</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mlt">mlt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MLTlookup)
str(MLTlookup)
# CD West life table for male at e0 of 80
subset(MLTlookup, type == "CD_West" &amp; sex == 1 &amp; e0 == 80)

</code></pre>

<hr>
<h2 id='mortcast'>Coherent Rotated Lee-Carter Prediction</h2><span id='topic+mortcast'></span>

<h3>Description</h3>

<p>Predict age-specific mortality rates using the coherent rotated Lee-Carter method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortcast(
  e0m,
  e0f,
  lc.pars,
  rotate = TRUE,
  keep.lt = FALSE,
  constrain.all.ages = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mortcast_+3A_e0m">e0m</code></td>
<td>
<p>A time series of future male life expectancy.</p>
</td></tr>
<tr><td><code id="mortcast_+3A_e0f">e0f</code></td>
<td>
<p>A time series of future female life expectancy.</p>
</td></tr>
<tr><td><code id="mortcast_+3A_lc.pars">lc.pars</code></td>
<td>
<p>A list of coherent Lee-Carter parameters with elements <code>bx</code>, <code>ultimate.bx</code>,
<code>ages</code>, <code>nx</code>, 
<code>female</code> and <code>male</code> as returned by <code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code>. 
The <code>female</code> and <code>male</code> objects are again lists that should contain a vector
<code>ax</code> and optionally a matrix <code>axt</code> if the <code class="reqn">a_x</code> parameter 
needs to be defined as time dependent. In such a case, rows are age groups and columns are 
time periods corresponding to the length of the <code>e0f</code> and <code>e0m</code> vectors.</p>
</td></tr>
<tr><td><code id="mortcast_+3A_rotate">rotate</code></td>
<td>
<p>If <code>TRUE</code> the rotation method of <code class="reqn">b_x</code> is used as described in Li et al. (2013).</p>
</td></tr>
<tr><td><code id="mortcast_+3A_keep.lt">keep.lt</code></td>
<td>
<p>Logical. If <code>TRUE</code> additional life table columns are kept in the 
resulting object.</p>
</td></tr>
<tr><td><code id="mortcast_+3A_constrain.all.ages">constrain.all.ages</code></td>
<td>
<p>By default the method constrains the male mortality to be above female 
mortality for old ages if the male life expectancy is below the female life expectancy. Setting 
this argument to <code>TRUE</code> causes this constraint to be applied to all ages.</p>
</td></tr>
<tr><td><code id="mortcast_+3A_...">...</code></td>
<td>
<p>Additional life table arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Steps 6-9 of Algorithm 2 in Sevcikova et al. (2016). 
It uses the abridged or unabridged life table function to find the level of mortality that coresponds to the given 
life expectancy. Thus, it can be used for both, mortality for 5- or 1-year age groups.
</p>


<h3>Value</h3>

<p>List with elements <code>female</code> and <code>male</code>, each of which contains a matrix <code>mx</code>
with the predicted mortality rates. If <code>keep.lt</code> is <code>TRUE</code>, it also 
contains matrices <code>sr</code> (survival rates), and life table quantities <code>Lx</code> and <code>lx</code>.
</p>


<h3>References</h3>

<p>Li, N., Lee, R. D. and Gerland, P. (2013). Extending the Lee-Carter method to model the rotation 
of age patterns of mortality decline for long-term projections. Demography, 50, 2037-2051.
</p>
<p>Sevcikova H., Li N., Kantorova V., Gerland P., Raftery A.E. (2016). 
Age-Specific Mortality and Fertility Rates for Probabilistic Population Projections. 
In: Schoen R. (eds) Dynamic Demographic Analysis. The Springer Series on Demographic Methods
and Population Analysis, vol 39. Springer, Cham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate.leecarter">rotate.leecarter</a></code>, <code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>, <code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code>,
<code><a href="#topic+mortcast.blend">mortcast.blend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># estimate parameters from historical mortality data (5-year age groups)
data(mxM, mxF, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "Brazil"
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
lc &lt;- lileecarter.estimate(mxm, mxf)

# project into future for given levels of life expectancy
e0f &lt;- as.numeric(subset(e0Fproj, name == country)[-(1:2)])
e0m &lt;- as.numeric(subset(e0Mproj, name == country)[-(1:2)])
pred &lt;- mortcast(e0m, e0f, lc)

# plot first projection in black and the remaining ones in grey 
plot(lc$ages, pred$female$mx[,1], type="b", log="y", ylim=range(pred$female$mx),
    ylab="female mx", xlab="Age", main=paste(country, "(5-year age groups)"), cex=0.5)
for(i in 2:ncol(pred$female$mx)) lines(lc$ages, pred$female$mx[,i], col="grey")

# similarly for 1-year age groups
# derive toy 1-year mx using model life tables at given level of e0
mxm1y &lt;- mlt(seq(65, 71, length = 4), sex = "male", nx = 1)
mxf1y &lt;- mlt(seq(73, 78, length = 4), sex = "female", nx = 1)

# estimate parameters
lc1y &lt;- lileecarter.estimate(mxm1y, mxf1y, nx = 1)
 
# project into the future 
pred1y &lt;- mortcast(e0m, e0f, lc1y)

# plot first projection in black and the remaining ones in grey 
plot(lc1y$ages, pred1y$female$mx[,1], type="b", log="y", ylim=range(pred1y$female$mx),
    ylab="female mx", xlab="Age", main="1-year age groups", cex=0.5)
for(i in 2:ncol(pred1y$female$mx)) lines(lc1y$ages, pred1y$female$mx[,i], col="grey")

</code></pre>

<hr>
<h2 id='mortcast.blend'>Mortality Prediction by Method Blending</h2><span id='topic+mortcast.blend'></span>

<h3>Description</h3>

<p>Predict age-specific mortality rates using a blend of two different methods (Coherent Lee-Carter, 
Coherent Pattern Mortality Decline, Log-Quadratic model, or Model Life Tables). Weights can be applied to fine-tune the blending mix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortcast.blend(
  e0m,
  e0f,
  meth1 = "lc",
  meth2 = "mlt",
  weights = c(1, 0.5),
  nx = 5,
  apply.kannisto = TRUE,
  min.age.groups = 28,
  match.e0 = TRUE,
  keep.lt = FALSE,
  meth1.args = NULL,
  meth2.args = NULL,
  kannisto.args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mortcast.blend_+3A_e0m">e0m</code></td>
<td>
<p>A time series of future male life expectancy.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_e0f">e0f</code></td>
<td>
<p>A time series of future female life expectancy.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_meth1">meth1</code></td>
<td>
<p>Character string giving the name of the first method to blend. It is one of 
&ldquo;lc&rdquo;, &ldquo;pmd&rdquo;, &ldquo;mlt&rdquo; or &ldquo;logquad&rdquo;, corresponding to Coherent Lee-Carter (function <code><a href="#topic+mortcast">mortcast</a></code>), 
Pattern Mortality Decline (function <code><a href="#topic+copmd">copmd</a></code>), Log-Quadratic model (function <code><a href="#topic+logquadj">logquadj</a></code>), and 
Model Life Tables (function <code><a href="#topic+mltj">mltj</a></code>), respectively. The &ldquo;logquad&rdquo; method can only be used 
with 5-year age groups.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_meth2">meth2</code></td>
<td>
<p>Character string giving the name of the second method to blend. 
One of the same choices as <code>meth1</code>.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_weights">weights</code></td>
<td>
<p>Numeric vector with values between 0 and 1 giving the weight of <code>meth1</code>.
If it is a single value, the same weight is applied for all time periods. 
If it is a vector of size two, it is assumed these are weights for the first and the last
time period. Remaining weights will be interpolated. Note that <code>meth2</code> is weighted 
by <code>1 - weights</code>.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_nx">nx</code></td>
<td>
<p>Size of age groups. Should be either 5 or 1.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_apply.kannisto">apply.kannisto</code></td>
<td>
<p>Logical. If <code>TRUE</code> and if any of the methods results in less than 
<code>min.age.groups</code> age categories, the coherent Kannisto method (<code><a href="#topic+cokannisto">cokannisto</a></code>) 
is applied to extend the age groups into old ages.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_min.age.groups">min.age.groups</code></td>
<td>
<p>Minimum number of age groups. Triggers the application of Kannisto, see above. 
Change the default value if 1-year age groups are used (see Example).</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_match.e0">match.e0</code></td>
<td>
<p>Logical. If <code>TRUE</code> the blended mx is scaled so that it matches the input e0.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_keep.lt">keep.lt</code></td>
<td>
<p>Logical. If <code>TRUE</code> additional life table columns are kept in the 
resulting object. Only used if <code>match.e0</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_meth1.args">meth1.args</code></td>
<td>
<p>List of arguments passed to the function that corresponds to <code>meth1</code>.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_meth2.args">meth2.args</code></td>
<td>
<p>List of arguments passed to the function that corresponds to <code>meth2</code>.</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_kannisto.args">kannisto.args</code></td>
<td>
<p>List of arguments passed to the <code><a href="#topic+cokannisto">cokannisto</a></code> function if Kannisto is applied. 
If 1-year age groups are used various defaults in the Kannisto function need to be changed (see Example).</p>
</td></tr>
<tr><td><code id="mortcast.blend_+3A_...">...</code></td>
<td>
<p>Additional life table arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to combine two different methods using given weights.
The weights can change over time - by default they are interpolated from the starting weight 
to the end weight. As the blended mortality rates do not necessarily match the target life expectancy, 
scaling is applied to improve the match, controlled by the <code>match.e0</code> argument. 
The projection is done for both sexes, so that coherent methods can be applied.
</p>


<h3>Value</h3>

<p>List with elements <code>female</code> and <code>male</code>, each of which contains a matrix <code>mx</code>
with the predicted mortality rates. If the result has been scaled (<code>match.e0</code> is <code>TRUE</code>), the element 
<code>mx.rawblend</code> contains the mx before scaling. Also in such a case, if <code>keep.lt</code> is <code>TRUE</code>, it also 
contains matrices <code>sr</code> (survival rates), and life table quantities <code>Lx</code> and <code>lx</code>.
In addition, the return object contains elements <code>meth1res</code> and <code>meth2res</code>
which contain the results of the functions corresponding to the two methods. 
Elements <code>meth1</code> and <code>meth2</code> contain the names of the methods. 
A vector <code>weights</code> contains the final (possibly interpolated) weights.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mortcast">mortcast</a></code>, <code><a href="#topic+copmd">copmd</a></code>, <code><a href="#topic+mltj">mltj</a></code>, <code><a href="#topic+logquad">logquad</a></code>,
<code><a href="#topic+cokannisto">cokannisto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxM, mxF, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "Brazil"
# estimate parameters from historical mortality data
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
lcest &lt;- lileecarter.estimate(mxm, mxf)
# project into future
e0f &lt;- subset(e0Fproj, name == country)[-(1:2)]
e0m &lt;- subset(e0Mproj, name == country)[-(1:2)]

# Blend LC and MLT
pred1 &lt;- mortcast.blend(e0m, e0f, meth1 = "lc", meth2 = "mlt",
    meth1.args = list(lc.pars = lcest),
    meth2.args = list(type = "CD_North"),
    weights = c(1,0.25))
    
# Blend PMD and MLT
pred2 &lt;- mortcast.blend(e0m, e0f, meth1 = "pmd", meth2 = "mlt",
    meth1.args = list(mxm0 = mxm[, "2010-2015"],
                      mxf0 = mxf[, "2010-2015"]))
                      
# plot projection by time
plotmx &lt;- function(pred, iage, main) 
    with(pred, {
        # blended projections 
        plot(female$mx[iage,], type="l", 
            ylim=range(meth1res$female$mx[iage,], 
                       meth2res$female$mx[iage,]),
            ylab="female mx", xlab="Time", main=main, col = "red")
        lines(meth1res$female$mx[iage,], lty = 2)
        lines(meth2res$female$mx[iage,], lty = 3)
        legend("topright", legend=c("blend", meth1, meth2),
               lty = 1:3, col = c("red", "black", "black"), bty = "n")
    })
age.group &lt;- 3 # 5-9 years old
par(mfrow=c(1,2))
plotmx(pred1, age.group, "LC-MLT (age 5-9)")
plotmx(pred2, age.group, "PMD-MLT (age 5-9)")

# Blend LC and MLT for 1-year age groups
#########################################
# First interpolate e0 to get 1-year life expectancies (for first five years)
e0m1y &lt;- approx(as.double(e0m[,1:2]), n = 5)$y
e0f1y &lt;- approx(as.double(e0f[,1:2]), n = 5)$y
# derive toy mx in order to get some LC parameters
mxm1y &lt;- mlt(seq(70, 72, length = 4), sex = "male", nx = 1)
mxf1y &lt;- mlt(seq(78, 79, length = 4), sex = "female", nx = 1)
lcest1y &lt;- lileecarter.estimate(mxm1y, mxf1y, nx = 1)

# projections
pred3 &lt;- mortcast.blend(e0m1y, e0f1y, meth1 = "lc", meth2 = "mlt",
    weights = c(1,0.25), min.age.groups = 131, nx = 1, 
    meth1.args = list(lc.pars = lcest1y),
    kannisto.args = list(est.ages = 90:99, proj.ages = 100:130))
    
# plot results
par(mfrow=c(1,1))
plot(0:130, pred3$female$mx[,5], log = "y", type = "l", col = "red")
lines(0:130, pred3$male$mx[,5], col = "blue")

</code></pre>

<hr>
<h2 id='pmd'>Pattern of Mortality Decline Prediction</h2><span id='topic+pmd'></span><span id='topic+modpmd'></span><span id='topic+copmd'></span>

<h3>Description</h3>

<p>Predict age-specific mortality rates using the Pattern of mortality decline (PMD) method (Andreev et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmd(
  e0,
  mx0,
  sex = c("male", "female"),
  nx = 5,
  interp.rho = FALSE,
  kranges = c(0, 25),
  keep.lt = FALSE,
  keep.rho = FALSE,
  ...
)

modpmd(
  e0,
  mx0,
  sex = c("male", "female"),
  nx = 5,
  interp.rho = FALSE,
  kranges = c(0, 25),
  ax.index = NULL,
  ax.smooth = FALSE,
  ax.smooth.df = NULL,
  keep.lt = FALSE,
  keep.rho = FALSE,
  ...
)

copmd(
  e0m,
  e0f,
  mxm0,
  mxf0,
  nx = 5,
  interp.rho = FALSE,
  keep.rho = FALSE,
  use.modpmd = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmd_+3A_e0">e0</code></td>
<td>
<p>A vector of target life expectancy, one element for each predicted time point.</p>
</td></tr>
<tr><td><code id="pmd_+3A_mx0">mx0</code></td>
<td>
<p>A vector with starting age-specific mortality rates. In case of <code>modpmd</code> it can be 
a matrix where rows correspond to age groups
and columns correspond to time periods. Rownames define the starting ages of the age groups.</p>
</td></tr>
<tr><td><code id="pmd_+3A_sex">sex</code></td>
<td>
<p>Either &quot;male&quot; or &quot;female&quot;.</p>
</td></tr>
<tr><td><code id="pmd_+3A_nx">nx</code></td>
<td>
<p>Size of age groups. Should be either 5 or 1.</p>
</td></tr>
<tr><td><code id="pmd_+3A_interp.rho">interp.rho</code></td>
<td>
<p>Logical controlling if the <code class="reqn">\rho</code> coefficients should be interpolated 
(<code>TRUE</code>) or if the raw (binned) version should be used (<code>FALSE</code>), as stored in 
the dataset <code><a href="#topic+PMDrho">PMDrho</a></code>.</p>
</td></tr>
<tr><td><code id="pmd_+3A_kranges">kranges</code></td>
<td>
<p>A vector of size two, giving the min and max of the <code class="reqn">k</code> parameter which is 
estimated to match the target <code>e0</code> using the bisection method.</p>
</td></tr>
<tr><td><code id="pmd_+3A_keep.lt">keep.lt</code></td>
<td>
<p>Logical. If <code>TRUE</code> additional life table columns are kept in the 
resulting object.</p>
</td></tr>
<tr><td><code id="pmd_+3A_keep.rho">keep.rho</code></td>
<td>
<p>Logical. If <code>TRUE</code> the <code class="reqn">\rho</code> coefficients are included in the resulting object.</p>
</td></tr>
<tr><td><code id="pmd_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying functions. For <code>copmd</code>, in addition to
<code>kranges</code> and <code>keep.lt</code>, it can be <code>sexratio.adjust</code> which is 
a logical controlling if a sex-ratio adjustment should be applied to prevent crossovers 
between male and female mx. In such a case it uses coefficients from the <code><a href="#topic+PMDadjcoef">PMDadjcoef</a></code> dataset. 
However, if the argument <code>adjust.with.mxf</code> is set to <code>TRUE</code> (in addition to <code>sexratio.adjust</code>),
the adjustment is done using the 
female mortality rates as the lower constraint for male mortality rates. 
If the argument <code>adjust.sr.if.needed</code> is set to <code>TRUE</code>, a sex-ratio adjustment
is performed dynamically, using the sex ratio in the previous time point. 
In such a case, an adjustment in time t is applied only if there was a drop of sex ratio 
below one at time t-1. Other arguments passed here in <code>copmd</code> can be <code>ax.index</code>, <code>ax.smooth</code> and
<code>ax.smooth.df</code> which control the estimation of the initial mx if <code>use.modpmd</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pmd_+3A_ax.index">ax.index</code></td>
<td>
<p>A vector of column indices of <code>mx</code> to be used to estimate the <code class="reqn">a_x = E[log(mx(t_0))]</code> parameter.
By default it is estimated as the average over all observed time periods, but this argument can restrict the time periods 
to use.</p>
</td></tr>
<tr><td><code id="pmd_+3A_ax.smooth">ax.smooth</code></td>
<td>
<p>Logical allowing to smooth the <code class="reqn">a_x</code> over ages.</p>
</td></tr>
<tr><td><code id="pmd_+3A_ax.smooth.df">ax.smooth.df</code></td>
<td>
<p>Degree of freedom for smoothing if <code>ax.smooth</code> is <code>TRUE</code>. 
Default is half the length of <code class="reqn">a_x</code>.</p>
</td></tr>
<tr><td><code id="pmd_+3A_e0m">e0m</code></td>
<td>
<p>A time series of target male life expectancy.</p>
</td></tr>
<tr><td><code id="pmd_+3A_e0f">e0f</code></td>
<td>
<p>A time series of target female life expectancy.</p>
</td></tr>
<tr><td><code id="pmd_+3A_mxm0">mxm0</code>, <code id="pmd_+3A_mxf0">mxf0</code></td>
<td>
<p>A vector with starting age-specific male/female mortality rates. If <code>use.modpmd</code> is <code>TRUE</code>,
this can be a matrix of historical mx (age x time) from which the starting values are estimated.</p>
</td></tr>
<tr><td><code id="pmd_+3A_use.modpmd">use.modpmd</code></td>
<td>
<p>Logical determining if the modified version of PMD (<code>modpmd</code>) should be used. 
In such a case the starting values of mortality rates are estimated similarly to <code class="reqn">a_x</code> in 
<code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>, possibly from more than one time periods. In addition, a smoothing can be applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implements the PMD method introduced in Andreev et al. (2013) and its modifications. 
It assumes that the future decline in age-specific mortality will follow a certain pattern 
with the increase in life expectancy at birth (e0): 
</p>
<p style="text-align: center;"><code class="reqn">log[mx(t)] = log[mx(t-1)] - k(t) \rho_x(t)</code>
</p>

<p>Here, <code class="reqn">\rho_x(t)</code> is the age-specific pattern of mortality decline between <code class="reqn">t-1</code>
and <code class="reqn">t</code>. Such patterns for each sex and various levels of e0 
are stored in the dataset <code><a href="#topic+PMDrho">PMDrho</a></code>. The <code>pmd</code> function can be instructed 
to interpolate between neighboring levels of e0 by setting the argument <code>interp.rho</code> 
to <code>TRUE</code>. The <code class="reqn">k</code> parameter is estimated to match the e0 level using the bisection 
method.
</p>
<p>Function <code>pmd</code> evaluates the method for a single sex, while  <code>copmd</code> does it
coherently for both sexes. In the latter case, the same <code class="reqn">\rho_x</code> 
(namely the average over sex-specific <code class="reqn">\rho_x</code>) is used 
for both, male and female.
</p>
<p>Function <code>modpmd</code> implements a modified version of <code>pmd</code> where the initial <code class="reqn">log[mx(t_0)]</code>
is replaced by an <code class="reqn">a_x</code> estimated as in <code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>, i.e. using possibly 
multiple years of historical <code>mx</code> and optionally smoothed. Arguments <code>ax.index</code>, <code>ax.smooth</code> and 
<code>ax.smooth.df</code> determine the estimation years and parameters of the smoothing.
</p>


<h3>Value</h3>

<p>Function <code>pmd</code> and <code>modpmd</code> return a list with the following elements: a matrix <code>mx</code>
with the predicted mortality rates. If <code>keep.lt</code> is <code>TRUE</code>, it also 
contains matrices <code>sr</code> (survival rates), and life table quantities <code>Lx</code> and <code>lx</code>.
If <code>keep.rho</code> is <code>TRUE</code>, it contains a matrix <code>rho</code> where columns correpond 
to the values in the <code>e0</code> vector and rows correspond to age groups.
</p>
<p>Function <code>copmd</code> returns a list with one element for each sex 
(<code>male</code> and <code>female</code>) where each of them is a list as described above.
In addition if <code>keep.rho</code> is <code>TRUE</code>, element <code>rho.sex</code> 
gives the sex-dependent (i.e. not averaged) <code class="reqn">\rho_x</code> coefficient.
</p>


<h3>References</h3>

<p>Andreev, K., Gu, D., Gerland, P. (2013). Age Patterns of Mortality Improvement by Level of Life Expectancy at Birth with Applications to Mortality Projections. Paper presented at the Annual Meeting
of the Population Association of America, New Orleans, LA. <a href="https://paa2013.princeton.edu/papers/132554">https://paa2013.princeton.edu/papers/132554</a>.
</p>
<p>Gu, D., Pelletier, F., Sawyer, C. (2017). Projecting Age-sex-specific Mortality: A Comparison of the Modified Lee-Carter and Pattern of Mortality Decline Methods, UN Population Division, 
Technical Paper No. 6. New York: United Nations. <a href="https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf">https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mortcast">mortcast</a></code>, <code><a href="#topic+mortcast.blend">mortcast.blend</a></code>, <code><a href="#topic+PMDrho">PMDrho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxF, e0Fproj, package = "wpp2017")
country &lt;- "Hungary"
# get initial mortality for the current year
mxf &lt;- subset(mxF, name == country)[,"2010-2015"]
names(mxf) &lt;- c(0,1, seq(5, 100, by=5))
# get target e0
e0f &lt;- subset(e0Fproj, name == country)[-(1:2)]
# project into future
pred &lt;- pmd(e0f, mxf, sex = "female")
# plot first projection in black and the remaining ones in grey 
plot(pred$mx[,1], type = "l", log = "y", ylim = range(pred$mx),
    ylab = "female mx", xlab = "Age", main = country)
for(i in 2:ncol(pred$mx)) lines(pred$mx[,i], col = "grey")

</code></pre>

<hr>
<h2 id='PMDadjcoef'>Coefficients for Sex Ratio Adjustments in the PMD Method</h2><span id='topic+PMDadjcoef'></span>

<h3>Description</h3>

<p>Data object containing a table of coefficients to be used to adjust the sex ratio in the 
coherent Pattern Mortality Decline method as implemented in the <code><a href="#topic+copmd">copmd</a></code> function. To invoke 
the adjustment, argument <code>sexratio.adjust</code> should be set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PMDadjcoef)
</code></pre>


<h3>Format</h3>

<p>Data frame containing columns &ldquo;age&rdquo;,  &ldquo;intercept&rdquo;, &ldquo;lmxf&rdquo;, &ldquo;e0f&rdquo;, &ldquo;e0f2&rdquo;, and &ldquo;gap&rdquo;. 
Rows correspond to age groups. The values are estimates of the following  regression 
</p>
<p style="text-align: center;"><code class="reqn">\log_{10} mx^M = \beta_0 + \beta_1\log_{10} mx^F + \beta_2 e_0^F + \beta_3 (e_0^F)^2 + \beta_4(e_0^F - e_0^M)</code>
</p>

<p>The order of the columns starting with intercept corresponds to the order of the coefficients in the above equation.
</p>


<h3>Source</h3>

<p>The coefficients were estimated and provided by Danan Gu, UN Population Division.
</p>


<h3>References</h3>

<p>Gu, D., Pelletier, F. and Sawyer, C. (2017). Projecting Age-sex-specific Mortality: A Comparison of the Modified Lee-Carter and Pattern of Mortality Decline Methods, UN Population Division, 
Technical Paper No. 6. New York: United Nations. <a href="https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf">https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+copmd">copmd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PMDadjcoef)
PMDadjcoef


</code></pre>

<hr>
<h2 id='PMDrho'>Pattern Mortality Decline Lookup Tables</h2><span id='topic+PMDrho'></span><span id='topic+RhoFemales'></span><span id='topic+RhoMales'></span>

<h3>Description</h3>

<p>Data object containing two tables with <code class="reqn">\rho</code> coefficients for the 
Pattern Mortality Decline method as implemented in the <code><a href="#topic+pmd">pmd</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PMDrho)
</code></pre>


<h3>Format</h3>

<p>Using <code>data(PMDrho)</code> loads two objects into memory: <code>RhoFemales</code> and
<code>RhoMales</code>. They both are data frames with 22 rows corresponding to age groups, 
and 17 columns corresponding to different levels of life expectancy in 5-years intervals 
(from 50 to 135). The names of the columns reflect the middle of the respective interval.
</p>


<h3>References</h3>

<p>Andreev, K. Gu, D., Gerland, P. (2013). Age Patterns of Mortality Improvement by Level of Life Expectancy at Birth with Applications to Mortality Projections. Paper presented at the Annual Meeting
of the Population Association of America, New Orleans, LA. <a href="https://paa2013.princeton.edu/papers/132554">https://paa2013.princeton.edu/papers/132554</a>.
</p>
<p>Gu, D., Pelletier, F. and Sawyer, C. (2017). Projecting Age-sex-specific Mortality: A Comparison of the Modified Lee-Carter and Pattern of Mortality Decline Methods, UN Population Division, 
Technical Paper No. 6. New York: United Nations. <a href="https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf">https://population.un.org/wpp/Publications/Files/WPP2017_TechnicalPaperNo6.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pmd">pmd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PMDrho)
head(RhoFemales)
head(RhoMales)

# plot a few male patterns
e0lev &lt;- colnames(RhoMales)[c(1, 5, 9, 13, 17)]
plot(RhoMales[, e0lev[1]], type="l", log="y", ylim=range(RhoMales[,e0lev]),
    ylab="male rho", xlab="Age")
for(i in 2:length(e0lev)) lines(RhoMales[,e0lev[i]], lty = i)
legend("bottomleft", legend = e0lev, lty = 1:length(e0lev), bty= "n")


</code></pre>

<hr>
<h2 id='rotate.leecarter'>Rotated Lee-Carter</h2><span id='topic+rotate.leecarter'></span><span id='topic+ultimate.bx'></span>

<h3>Description</h3>

<p>Rotate the Lee-Carter parameter <code class="reqn">b_x</code> over time to reach an ultimate <code class="reqn">b^u_x</code>, 
as described in Li et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate.leecarter(bx, ultimate.bx, e0, e0l = 80, e0u = 102, p = 0.5)

ultimate.bx(bx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate.leecarter_+3A_bx">bx</code></td>
<td>
<p>A vector of the Lee-Carter <code class="reqn">b_x</code> parameter
(from e.g. <code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code> or <code><a href="#topic+leecarter.estimate">leecarter.estimate</a></code>).</p>
</td></tr>
<tr><td><code id="rotate.leecarter_+3A_ultimate.bx">ultimate.bx</code></td>
<td>
<p>A vector of the ultimate <code class="reqn">b^u_x</code> parameter as defined in Li, Lee, Gerland (2013)
(obtained using <code><a href="#topic+lileecarter.estimate">lileecarter.estimate</a></code> or <code><a href="#topic+ultimate.bx">ultimate.bx</a></code>).</p>
</td></tr>
<tr><td><code id="rotate.leecarter_+3A_e0">e0</code></td>
<td>
<p>A time series of life expectancies.</p>
</td></tr>
<tr><td><code id="rotate.leecarter_+3A_e0l">e0l</code></td>
<td>
<p>Level of life expectancy at which the rotation starts.</p>
</td></tr>
<tr><td><code id="rotate.leecarter_+3A_e0u">e0u</code></td>
<td>
<p>Level of life expectancy at which the rotation finishes.</p>
</td></tr>
<tr><td><code id="rotate.leecarter_+3A_p">p</code></td>
<td>
<p>Exponent of the smooth function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>rotate.leecarter</code> returns a matrix of rotated <code class="reqn">B_x(t)</code> where rows correspond to age groups and columns 
correspond to time periods (given by the vector <code>e0</code>).
</p>
<p>Function <code>ultimate.bx</code> returns a vector of the ultimate <code class="reqn">b^u_x</code>.
</p>


<h3>References</h3>

<p>Li, N., Lee, R. D. and Gerland, P. (2013). Extending the Lee-Carter method to model the rotation 
of age patterns of mortality decline for long-term projections. Demography, 50, 2037-2051.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mxF, mxM, e0Fproj, e0Mproj, package = "wpp2017")
country &lt;- "Japan"
mxm &lt;- subset(mxM, name == country)[,4:16]
mxf &lt;- subset(mxF, name == country)[,4:16]
e0f &lt;- as.numeric(subset(e0Fproj, name == country)[-(1:2)])
e0m &lt;- as.numeric(subset(e0Mproj, name == country)[-(1:2)])
rownames(mxm) &lt;- rownames(mxf) &lt;- c(0,1, seq(5, 100, by=5))
lc &lt;- lileecarter.estimate(mxm, mxf)
rotlc &lt;- rotate.leecarter(lc$bx, lc$ultimate.bx, (e0f + e0m)/2)
plot(lc$bx, type="l")
lines(lc$ultimate.bx, col="red")
for(i in 1:ncol(rotlc)) lines(rotlc[,i], col="grey")
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
