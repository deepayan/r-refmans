<!DOCTYPE html><html><head><title>Help for package flocker</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flocker}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#example_flocker_model_single'><p>Example single-season flocker model</p></a></li>
<li><a href='#fitted_flocker'><p>Posterior predictive distributions for modeled probabilities</p></a></li>
<li><a href='#flock'><p>Fit an occupancy model</p></a></li>
<li><a href='#flocker_stancode'><p>Generate stan code for an occupancy model</p></a></li>
<li><a href='#flocker_standata'><p>Generate stan data for an occupancy model</p></a></li>
<li><a href='#get_flocker_prior'><p>Get prior for occupancy model</p></a></li>
<li><a href='#get_Z'><p>Get posterior distribution of the Z matrix</p></a></li>
<li><a href='#log_inv_logit'><p>Numerically stable log inverse logit</p></a></li>
<li><a href='#log_lik_flocker'><p>Compute unit-wise or series-wise log-likelihood matrix for a flocker_fit object</p></a></li>
<li><a href='#log1m_inv_logit'><p>Numerically stable log one-minus inverse logit</p></a></li>
<li><a href='#loo_compare_flocker'><p>LOO comparisons for flocker models.</p></a></li>
<li><a href='#loo_flocker'><p>Compute loo for flocker_fit objects</p></a></li>
<li><a href='#make_flocker_data'><p>Format data for occupancy model with <code>flock()</code>.</p></a></li>
<li><a href='#make_flocker_data_augmented'><p>#' Format data for data-augmented occupancy model, to be passed to</p>
<code>flock()</code>.</a></li>
<li><a href='#make_flocker_data_dynamic'><p>Format data for dynamic (multi-season) occupancy model, to be passed to</p>
<code>flock()</code>.</a></li>
<li><a href='#make_flocker_data_static'><p>Format data for single-season occupancy model, to be passed to</p>
<code>flock()</code>.</a></li>
<li><a href='#predict_flocker'><p>Get posterior predictions from a flocker model</p></a></li>
<li><a href='#simulate_flocker_data'><p>Simulate data for use with <code>make_flocker_data()</code> and downstream</p>
functions.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Occupancy Estimation with Stan</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit occupancy models in 'Stan' via 'brms'. The full variety
    of 'brms' formula-based effects structures are available to use in
    multiple classes of occupancy model, including single-season
    models, models with data augmentation for never-observed species,
    dynamic (multiseason) models with explicit colonization and extinction
    processes, and dynamic models with autologistic occupancy dynamics.
    Formulas can be specified for all relevant distributional terms,
    including detection and one or more of occupancy, colonization,
    extinction, and autologistic depending on the model type. Several
    important forms of model post-processing are provided.  References:
    Bürkner (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v080.i01">doi:10.18637/jss.v080.i01</a>&gt;; Carpenter et al. (2017)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v076.i01">doi:10.18637/jss.v076.i01</a>&gt;; Socolar &amp; Mills (2023)
    &lt;<a href="https://doi.org/10.1101%2F2023.10.26.564080">doi:10.1101/2023.10.26.564080</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jsocolar/flocker">https://github.com/jsocolar/flocker</a>,
<a href="https://jsocolar.github.io/flocker/">https://jsocolar.github.io/flocker/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jsocolar/flocker/issues">https://github.com/jsocolar/flocker/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, assertthat, boot, brms (&ge; 2.20.3), loo (&ge; 2.0.0),
MASS, matrixStats, stats, utils, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BH (&ge; 1.75.0-0), knitr, RcppEigen (&ge; 0.3.3.9.3), rmarkdown,
rstan (&ge; 2.26.0), spelling, testthat (&ge; 2.1.0), tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-03 22:58:15 UTC; jacob</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob B. Socolar [aut, cre, cph],
  Simon C. Mills [aut],
  Paul-Christian Bürkner [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob B. Socolar &lt;jacob.socolar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 20:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='example_flocker_model_single'>Example single-season flocker model</h2><span id='topic+example_flocker_model_single'></span>

<h3>Description</h3>

<p>A fitted single-season occupancy model from flocker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_flocker_model_single
</code></pre>


<h3>Format</h3>

<p>## 'example_flocker_model_single'
A flocker_fit and brmsfit object
</p>


<h3>Source</h3>

<p>data-raw/example_flocker_model.R
</p>

<hr>
<h2 id='fitted_flocker'>Posterior predictive distributions for modeled probabilities</h2><span id='topic+fitted_flocker'></span>

<h3>Description</h3>

<p>Get expected values of the posterior predictive distribution for the modeled
probabilities (occupancy, detection, colonization, extinction, autologistic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitted_flocker(
  flocker_fit,
  components = c("occ", "det", "col", "ex", "auto", "Omega"),
  new_data = NULL,
  unit_level = FALSE,
  summarise = FALSE,
  CI = c(0.05, 0.95),
  draw_ids = NULL,
  response = TRUE,
  re_formula = NULL,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_flocker_+3A_flocker_fit">flocker_fit</code></td>
<td>
<p>A flocker_fit object.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_components">components</code></td>
<td>
<p>a character vector specifying one or more of &quot;occ&quot;,
&quot;det&quot;, &quot;col&quot;, &quot;ex&quot;, &quot;auto&quot;, and &quot;Omega&quot; for which to obtain fitted values.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_new_data">new_data</code></td>
<td>
<p>Optional new data at which to evaluate occupancy predictions. 
New data can be passed as a flocker_data object produced by 
<code>make_flocker_data</code> or as a dataframe with one row per desired
prediction. If 'NULL' (the default) expected values are generated for the 
original data as formatted by make_flocker_data.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_unit_level">unit_level</code></td>
<td>
<p>Logical; defaults to FALSE. Relevant only when 'new_data'
is not a dataframe (i.e. it is 'NULL' or a flocker_data object), and useful
only for multiseason models with missing seasons. If FALSE, returns in the 
shape of the observation matrix/array with NAs for missing visits. If
TRUE, returns in the shape of the first visit, and returns values for all
units that are not part of a trailing block of never-visited units,
including never-visited units that are part of series with subsequent 
visits.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_summarise">summarise</code></td>
<td>
<p>if TRUE, return the expected value and upper and lower bound 
of the credible interval, otherwise return posterior draws.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_ci">CI</code></td>
<td>
<p>A vector of length 2 specifying the upper and lower bounds of the 
credible interval.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_draw_ids">draw_ids</code></td>
<td>
<p>Vector of indices of the posterior draws to be 
used. If 'NULL' (the default) all draws are used in their native order.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_response">response</code></td>
<td>
<p>Should results be returned on the response or logit scale? 
Defaults to 'TRUE', i.e. response scale. However, the autologistic
parameter is not interpretable as a probability and is always returned
on the logit scale regardless of the value of 'response'</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_re_formula">re_formula</code></td>
<td>
<p>formula containing group-level effects to be considered in 
the prediction. If 'NULL' (default), include all group-level effects; if 
NA, include no group-level effects.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>allow new levels for random effect terms in 'new_data'?
Will error if set to 'FALSE' and new levels are provided in 'new_data'.</p>
</td></tr>
<tr><td><code id="fitted_flocker_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>If new_data is provided and contains random effect
levels not present in the original data, how should predictions be
handled? Passed directly to 'brms::prepare_predictions', which see.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probabilities returned are conditional probabilities (e.g. detection 
conditional on occupancy, colonization conditional on previous 
non-occupancy, etc). These probabilities are not conditioned on the 
observed histories (e.g. the occupancy probability is not fixed to one 
at sites with a detection; it is estimated only based on the covariates).
</p>


<h3>Value</h3>

<p>A list of sets of expected values (one per component). If 'new_data' 
is a dataframe, each element contains one row per row of 'new_data'.
Otherwise, returns in the shape of the observation matrix/array used 
to format the flocker_data (but see 'unit_level' parameter for further
details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fitted_flocker(
  example_flocker_model_single, 
  summarise = TRUE
)

</code></pre>

<hr>
<h2 id='flock'>Fit an occupancy model</h2><span id='topic+flock'></span>

<h3>Description</h3>

<p>Fit an occupancy model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flock(
  f_occ = NULL,
  f_det,
  flocker_data,
  data2 = NULL,
  multiseason = NULL,
  f_col = NULL,
  f_ex = NULL,
  multi_init = NULL,
  f_auto = NULL,
  augmented = FALSE,
  threads = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flock_+3A_f_occ">f_occ</code></td>
<td>
<p>A brms-type model formula for occupancy. If provided, must begin 
with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flock_+3A_f_det">f_det</code></td>
<td>
<p>A brms-type model formula for detection. Must begin with &quot;~&quot;. 
OR, a <code>brmsformula</code> object including formulas for all of the relevant
distributional parameters in the desired model (det and at least one of occ, 
colo, ex, autologistic, and Omega). The <code>$formula</code> element of the 
<code>brmsformula</code> must be the detection formula, beginning with <code>det ~</code>.
This latter option unadvisable except when necessary (e.g. when a nonlinear 
formula is desired), as input checking is less thorough.</p>
</td></tr>
<tr><td><code id="flock_+3A_flocker_data">flocker_data</code></td>
<td>
<p>data, generally the output of <code>make_flocker_data()</code>.</p>
</td></tr>
<tr><td><code id="flock_+3A_data2">data2</code></td>
<td>
<p>additional data (e.g. a covariance matrix for a phylogenetic 
effect)</p>
</td></tr>
<tr><td><code id="flock_+3A_multiseason">multiseason</code></td>
<td>
<p>Must be NULL (the default) or one of &quot;colex&quot; or 
&quot;autologistic&quot;. If NULL, data must be formatted for a single-season model.
Otherwise, the data must be formatted for a multiseason model. If &quot;colex&quot;, a 
colonization-extinction model will be fit, and 'f_col' and 'f_ex' must be 
specified. If &quot;autologistic&quot;, an autologistic model will be fit, and 'f_col'
and 'f_ex' must both be NULL.</p>
</td></tr>
<tr><td><code id="flock_+3A_f_col">f_col</code></td>
<td>
<p>A brms-type model formula for colonization in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flock_+3A_f_ex">f_ex</code></td>
<td>
<p>A brms-type model formula for extinction probabilities in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flock_+3A_multi_init">multi_init</code></td>
<td>
<p>Must be NULL unless the model is a dynamic (multiseason)
model, in which case must be either &quot;explicit&quot; or &quot;equilibrium&quot;. 
If &quot;explicit&quot;, then 'f_occ' must be provided to model occupancy
probabilities in the first timestep. If &quot;equilibrium&quot;, then 'f_occ' must be
'NULL' and the initial occupancy probabilities are assumed to be the 
(possibly site-specific) equilibrium probabilities from the colonization-
extinction dynamics.</p>
</td></tr>
<tr><td><code id="flock_+3A_f_auto">f_auto</code></td>
<td>
<p>Relevant only for autologistic models. A brms-type model 
formula for the autologistic offset parameter (theta). If provided, must 
begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flock_+3A_augmented">augmented</code></td>
<td>
<p>Logical. Must be TRUE if data are formatted for a 
data-augmented multi-species model, and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="flock_+3A_threads">threads</code></td>
<td>
<p>NULL or positive integer. If integer, the number of threads
to use per chain in within chain parallelization. Currently available only
with single-season rep-constant models, and must be set to NULL otherwise.</p>
</td></tr>
<tr><td><code id="flock_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>brms::brm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>brmsfit</code> containing the fitted occupancy model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfd &lt;- simulate_flocker_data()
fd &lt;- make_flocker_data(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
flock(
  f_occ = ~ s(uc1) + (1|species),
  f_det = ~ uc1 + ec1 + (1|species),
  flocker_data = fd,
  refresh = 50, chains = 1, warmup = 5, iter = 200,
  control = list(adapt_engaged = FALSE, stepsize = .05, max_treedepth = 5),
  seed = 123
  )

</code></pre>

<hr>
<h2 id='flocker_stancode'>Generate stan code for an occupancy model</h2><span id='topic+flocker_stancode'></span>

<h3>Description</h3>

<p>Generate stan code for an occupancy model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flocker_stancode(
  f_occ = NULL,
  f_det,
  flocker_data,
  data2 = NULL,
  multiseason = NULL,
  f_col = NULL,
  f_ex = NULL,
  multi_init = NULL,
  f_auto = NULL,
  augmented = FALSE,
  threads = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flocker_stancode_+3A_f_occ">f_occ</code></td>
<td>
<p>A brms-type model formula for occupancy. If provided, must begin 
with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_f_det">f_det</code></td>
<td>
<p>A brms-type model formula for detection. Must begin with &quot;~&quot;. 
OR, a <code>brmsformula</code> object including formulas for all of the relevant
distributional parameters in the desired model (det and at least one of occ, 
colo, ex, autologistic, and Omega). The <code>$formula</code> element of the 
<code>brmsformula</code> must be the detection formula, beginning with <code>det ~</code>.
This latter option unadvisable except when necessary (e.g. when a nonlinear 
formula is desired), as input checking is less thorough.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_flocker_data">flocker_data</code></td>
<td>
<p>data, generally the output of <code>make_flocker_data()</code>.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_data2">data2</code></td>
<td>
<p>additional data (e.g. a covariance matrix for a phylogenetic 
effect)</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_multiseason">multiseason</code></td>
<td>
<p>Must be NULL (the default) or one of &quot;colex&quot; or 
&quot;autologistic&quot;. If NULL, data must be formatted for a single-season model.
Otherwise, the data must be formatted for a multiseason model. If &quot;colex&quot;, a 
colonization-extinction model will be fit, and 'f_col' and 'f_ex' must be 
specified. If &quot;autologistic&quot;, an autologistic model will be fit, and 'f_col'
and 'f_ex' must both be NULL.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_f_col">f_col</code></td>
<td>
<p>A brms-type model formula for colonization in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_f_ex">f_ex</code></td>
<td>
<p>A brms-type model formula for extinction probabilities in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_multi_init">multi_init</code></td>
<td>
<p>Must be NULL unless the model is a dynamic (multiseason)
model, in which case must be either &quot;explicit&quot; or &quot;equilibrium&quot;. 
If &quot;explicit&quot;, then 'f_occ' must be provided to model occupancy
probabilities in the first timestep. If &quot;equilibrium&quot;, then 'f_occ' must be
'NULL' and the initial occupancy probabilities are assumed to be the 
(possibly site-specific) equilibrium probabilities from the colonization-
extinction dynamics.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_f_auto">f_auto</code></td>
<td>
<p>Relevant only for autologistic models. A brms-type model 
formula for the autologistic offset parameter (theta). If provided, must 
begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_augmented">augmented</code></td>
<td>
<p>Logical. Must be TRUE if data are formatted for a 
data-augmented multi-species model, and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_threads">threads</code></td>
<td>
<p>NULL or positive integer. If integer, the number of threads
to use per chain in within chain parallelization. Currently available only
with single-season rep-constant models, and must be set to NULL otherwise.</p>
</td></tr>
<tr><td><code id="flocker_stancode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>brms::brm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>generated stancode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sfd &lt;- simulate_flocker_data()
fd &lt;- make_flocker_data(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
flocker_stancode(
  f_occ = ~ s(uc1) + (1|species),
  f_det = ~ uc1 + ec1 + (1|species),
  flocker_data = fd,
  refresh = 50, chains = 1, warmup = 5, iter = 200,
  control = list(adapt_engaged = FALSE, stepsize = .05, max_treedepth = 5),
  seed = 123
  )
  
</code></pre>

<hr>
<h2 id='flocker_standata'>Generate stan data for an occupancy model</h2><span id='topic+flocker_standata'></span>

<h3>Description</h3>

<p>Generate stan data for an occupancy model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flocker_standata(
  f_occ = NULL,
  f_det,
  flocker_data,
  data2 = NULL,
  multiseason = NULL,
  f_col = NULL,
  f_ex = NULL,
  multi_init = NULL,
  f_auto = NULL,
  augmented = FALSE,
  threads = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flocker_standata_+3A_f_occ">f_occ</code></td>
<td>
<p>A brms-type model formula for occupancy. If provided, must begin 
with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_f_det">f_det</code></td>
<td>
<p>A brms-type model formula for detection. Must begin with &quot;~&quot;. 
OR, a <code>brmsformula</code> object including formulas for all of the relevant
distributional parameters in the desired model (det and at least one of occ, 
colo, ex, autologistic, and Omega). The <code>$formula</code> element of the 
<code>brmsformula</code> must be the detection formula, beginning with <code>det ~</code>.
This latter option unadvisable except when necessary (e.g. when a nonlinear 
formula is desired), as input checking is less thorough.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_flocker_data">flocker_data</code></td>
<td>
<p>data, generally the output of <code>make_flocker_data()</code>.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_data2">data2</code></td>
<td>
<p>additional data (e.g. a covariance matrix for a phylogenetic 
effect)</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_multiseason">multiseason</code></td>
<td>
<p>Must be NULL (the default) or one of &quot;colex&quot; or 
&quot;autologistic&quot;. If NULL, data must be formatted for a single-season model.
Otherwise, the data must be formatted for a multiseason model. If &quot;colex&quot;, a 
colonization-extinction model will be fit, and 'f_col' and 'f_ex' must be 
specified. If &quot;autologistic&quot;, an autologistic model will be fit, and 'f_col'
and 'f_ex' must both be NULL.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_f_col">f_col</code></td>
<td>
<p>A brms-type model formula for colonization in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_f_ex">f_ex</code></td>
<td>
<p>A brms-type model formula for extinction probabilities in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_multi_init">multi_init</code></td>
<td>
<p>Must be NULL unless the model is a dynamic (multiseason)
model, in which case must be either &quot;explicit&quot; or &quot;equilibrium&quot;. 
If &quot;explicit&quot;, then 'f_occ' must be provided to model occupancy
probabilities in the first timestep. If &quot;equilibrium&quot;, then 'f_occ' must be
'NULL' and the initial occupancy probabilities are assumed to be the 
(possibly site-specific) equilibrium probabilities from the colonization-
extinction dynamics.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_f_auto">f_auto</code></td>
<td>
<p>Relevant only for autologistic models. A brms-type model 
formula for the autologistic offset parameter (theta). If provided, must 
begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_augmented">augmented</code></td>
<td>
<p>Logical. Must be TRUE if data are formatted for a 
data-augmented multi-species model, and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_threads">threads</code></td>
<td>
<p>NULL or positive integer. If integer, the number of threads
to use per chain in within chain parallelization. Currently available only
with single-season rep-constant models, and must be set to NULL otherwise.</p>
</td></tr>
<tr><td><code id="flocker_standata_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>brms::brm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>generated stan data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfd &lt;- simulate_flocker_data()
fd &lt;- make_flocker_data(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
flocker_standata(
  f_occ = ~ s(uc1) + (1|species),
  f_det = ~ uc1 + ec1 + (1|species),
  flocker_data = fd,
  refresh = 50, chains = 1, warmup = 5, iter = 200,
  control = list(adapt_engaged = FALSE, stepsize = .05, max_treedepth = 5),
  seed = 123
  )
</code></pre>

<hr>
<h2 id='get_flocker_prior'>Get prior for occupancy model</h2><span id='topic+get_flocker_prior'></span>

<h3>Description</h3>

<p>Get prior for occupancy model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_flocker_prior(
  f_occ = NULL,
  f_det,
  flocker_data,
  data2 = NULL,
  multiseason = NULL,
  f_col = NULL,
  f_ex = NULL,
  multi_init = NULL,
  f_auto = NULL,
  augmented = FALSE,
  threads = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_flocker_prior_+3A_f_occ">f_occ</code></td>
<td>
<p>A brms-type model formula for occupancy. If provided, must begin 
with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_f_det">f_det</code></td>
<td>
<p>A brms-type model formula for detection. Must begin with &quot;~&quot;. 
OR, a <code>brmsformula</code> object including formulas for all of the relevant
distributional parameters in the desired model (det and at least one of occ, 
colo, ex, autologistic, and Omega). The <code>$formula</code> element of the 
<code>brmsformula</code> must be the detection formula, beginning with <code>det ~</code>.
This latter option unadvisable except when necessary (e.g. when a nonlinear 
formula is desired), as input checking is less thorough.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_flocker_data">flocker_data</code></td>
<td>
<p>data, generally the output of <code>make_flocker_data()</code>.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_data2">data2</code></td>
<td>
<p>additional data (e.g. a covariance matrix for a phylogenetic 
effect)</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_multiseason">multiseason</code></td>
<td>
<p>Must be NULL (the default) or one of &quot;colex&quot; or 
&quot;autologistic&quot;. If NULL, data must be formatted for a single-season model.
Otherwise, the data must be formatted for a multiseason model. If &quot;colex&quot;, a 
colonization-extinction model will be fit, and 'f_col' and 'f_ex' must be 
specified. If &quot;autologistic&quot;, an autologistic model will be fit, and 'f_col'
and 'f_ex' must both be NULL.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_f_col">f_col</code></td>
<td>
<p>A brms-type model formula for colonization in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_f_ex">f_ex</code></td>
<td>
<p>A brms-type model formula for extinction probabilities in 
colonization-extinction dynamic models. If provided, must begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_multi_init">multi_init</code></td>
<td>
<p>Must be NULL unless the model is a dynamic (multiseason)
model, in which case must be either &quot;explicit&quot; or &quot;equilibrium&quot;. 
If &quot;explicit&quot;, then 'f_occ' must be provided to model occupancy
probabilities in the first timestep. If &quot;equilibrium&quot;, then 'f_occ' must be
'NULL' and the initial occupancy probabilities are assumed to be the 
(possibly site-specific) equilibrium probabilities from the colonization-
extinction dynamics.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_f_auto">f_auto</code></td>
<td>
<p>Relevant only for autologistic models. A brms-type model 
formula for the autologistic offset parameter (theta). If provided, must 
begin with &quot;~&quot;.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_augmented">augmented</code></td>
<td>
<p>Logical. Must be TRUE if data are formatted for a 
data-augmented multi-species model, and FALSE otherwise.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_threads">threads</code></td>
<td>
<p>NULL or positive integer. If integer, the number of threads
to use per chain in within chain parallelization. Currently available only
with single-season rep-constant models, and must be set to NULL otherwise.</p>
</td></tr>
<tr><td><code id="get_flocker_prior_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>brms::brm()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe summarizing the parameters on which priors can
be specified and giving the default priors for those parameters.
See <code>?brms::get_prior</code> for further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfd &lt;- simulate_flocker_data()
fd &lt;- make_flocker_data(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
get_flocker_prior(
 f_occ = ~ s(uc1) + + (1|species),
 f_det = ~ uc1 + ec1 + (1|species),
 flocker_data = fd
)
</code></pre>

<hr>
<h2 id='get_Z'>Get posterior distribution of the Z matrix</h2><span id='topic+get_Z'></span>

<h3>Description</h3>

<p>Get posterior distribution of the Z matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Z(
  flocker_fit,
  draw_ids = NULL,
  history_condition = TRUE,
  sample = FALSE,
  new_data = NULL,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Z_+3A_flocker_fit">flocker_fit</code></td>
<td>
<p>A flocker_fit object</p>
</td></tr>
<tr><td><code id="get_Z_+3A_draw_ids">draw_ids</code></td>
<td>
<p>Vector of indices of the posterior draws to be 
used. If 'NULL' (the default) all draws are used in their native order.</p>
</td></tr>
<tr><td><code id="get_Z_+3A_history_condition">history_condition</code></td>
<td>
<p>Should the posterior distribution for Z directly 
condition on the observed detection history ('TRUE') or not ('FALSE')?
For example, at sites with at least one detection, the true occupancy 
state conditioned on the history is one with absolute certainty. Without 
directly conditioning on the history, the occupancy state is controlled 
by the posterior distribution for the occupancy probability psi.</p>
</td></tr>
<tr><td><code id="get_Z_+3A_sample">sample</code></td>
<td>
<p>Should the return be posterior probabilities of occupancy (FALSE),
or bernoulli samples from those probabilities (TRUE)</p>
</td></tr>
<tr><td><code id="get_Z_+3A_new_data">new_data</code></td>
<td>
<p>Optional new data at which to predict the Z matrix. Can be 
the output of 'make_flocker_data' or the 'unit_covs' input to 
'make_flocker_data' provided that 'history_condition' is 'FALSE' and the 
occupancy model is a single-season, non-augmented model.</p>
</td></tr>
<tr><td><code id="get_Z_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>allow new levels for random effect terms in 'new_data'?
Will error if set to 'FALSE' and new levels are provided in 'new_data'.</p>
</td></tr>
<tr><td><code id="get_Z_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>If 'new_data' is provided and contains random effect
levels not present in the original data, how should predictions be
handled? Passed directly to 'brms::prepare_predictions', which see.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The posterior Z matrix in the shape of the first visit in 'obs' as
passed to make_flocker_data, with posterior iterations stacked along the
final dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_Z(example_flocker_model_single)

</code></pre>

<hr>
<h2 id='log_inv_logit'>Numerically stable log inverse logit</h2><span id='topic+log_inv_logit'></span>

<h3>Description</h3>

<p>Numerically stable log inverse logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_inv_logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_inv_logit_+3A_x">x</code></td>
<td>
<p>real number or vector of reals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the logarithm of the inverse logit of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_inv_logit(0)
</code></pre>

<hr>
<h2 id='log_lik_flocker'>Compute unit-wise or series-wise log-likelihood matrix for a flocker_fit object</h2><span id='topic+log_lik_flocker'></span>

<h3>Description</h3>

<p>Compute unit-wise or series-wise log-likelihood matrix for a flocker_fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lik_flocker(flocker_fit, draw_ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_lik_flocker_+3A_flocker_fit">flocker_fit</code></td>
<td>
<p>A flocker_fit object</p>
</td></tr>
<tr><td><code id="log_lik_flocker_+3A_draw_ids">draw_ids</code></td>
<td>
<p>the draw ids to compute log-likelihoods for. Defaults to using the full posterior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In single-season models, rows are units (e.g. points or 
species-points; suitable for leave-one-unit-out CV). In multiseason models, 
rows are series (i.e. points or species-points, suitable for 
leave-one-series-out CV). In augmented models, rows are species (suitable
for leave-one-species-out CV).
</p>


<h3>Value</h3>

<p>A posterior log-likelihood matrix, where iterations are rows and 
units, series, or species are columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_lik_flocker(example_flocker_model_single)
</code></pre>

<hr>
<h2 id='log1m_inv_logit'>Numerically stable log one-minus inverse logit</h2><span id='topic+log1m_inv_logit'></span>

<h3>Description</h3>

<p>Numerically stable log one-minus inverse logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log1m_inv_logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log1m_inv_logit_+3A_x">x</code></td>
<td>
<p>real number or vector of reals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the logarithm of one minus the inverse logit of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log1m_inv_logit(0)
</code></pre>

<hr>
<h2 id='loo_compare_flocker'>LOO comparisons for flocker models.</h2><span id='topic+loo_compare_flocker'></span>

<h3>Description</h3>

<p>LOO comparisons for flocker models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_compare_flocker(model_list, model_names = NULL, thin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_compare_flocker_+3A_model_list">model_list</code></td>
<td>
<p>a list of flocker_fit objects.</p>
</td></tr>
<tr><td><code id="loo_compare_flocker_+3A_model_names">model_names</code></td>
<td>
<p>An optional vector of names for the models.</p>
</td></tr>
<tr><td><code id="loo_compare_flocker_+3A_thin">thin</code></td>
<td>
<p>specify the amount of thinning required. 1 or NULL results in no 
thinning, 2 retains every other value, 3 every third, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'compare.loo' matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ml &lt;- rep(list(example_flocker_model_single), 3)
loo_compare_flocker(ml)

</code></pre>

<hr>
<h2 id='loo_flocker'>Compute loo for flocker_fit objects</h2><span id='topic+loo_flocker'></span>

<h3>Description</h3>

<p>Compute loo for flocker_fit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_flocker(x, thin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_flocker_+3A_x">x</code></td>
<td>
<p>a flocker_fit object or a list of flocker_fit objects</p>
</td></tr>
<tr><td><code id="loo_flocker_+3A_thin">thin</code></td>
<td>
<p>specify the amount of thinning required. 1 or NULL implies no thinning, 2 implies every other value, 3 every third, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a loo object or a list of loo objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
loo_flocker(example_flocker_model_single)

## End(Not run)
</code></pre>

<hr>
<h2 id='make_flocker_data'>Format data for occupancy model with <code>flock()</code>.</h2><span id='topic+make_flocker_data'></span>

<h3>Description</h3>

<p>Format data for occupancy model with <code>flock()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_flocker_data(
  obs,
  unit_covs = NULL,
  event_covs = NULL,
  type = "single",
  n_aug = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_flocker_data_+3A_obs">obs</code></td>
<td>
<p>If <code>type = "single"</code>, an I x J matrix-like object where 
closure is assumed across rows and columns are repeated sampling events. 
If <code>type = "multi"</code>, an I x J x K array where rows are sites or 
species-sites, columns are repeated sampling events, and slices along the 
third dimension are seasons. Allowable values are 1 (detection), 0 (no 
detection), and NA (no sampling event).
If <code>type = "augmented"</code>, an L x J x K array where rows L are sites, 
columns J are repeat sampling events, and slices K are species. 
The data must be packed so that, for a given unit (site, site-species, 
site-timestep, site-species-timestep) all realized visits come before any 
missing visits (NAs are trailing within their rows).</p>
</td></tr>
<tr><td><code id="make_flocker_data_+3A_unit_covs">unit_covs</code></td>
<td>
<p>If <code>type = "single"</code> a dataframe of covariates for each 
closure-unit that are constant across repeated sampling events within units.
If <code>type = "multi"</code>, a list of such dataframes, one per timestep. All 
dataframes must have identical column names and types, and all
dataframes must have I rows.
If <code>type = "augmented"</code>, a dataframe of covariates for each site that
are constant across repeated sampling events within sites (no dependence on
species is allowed).</p>
</td></tr>
<tr><td><code id="make_flocker_data_+3A_event_covs">event_covs</code></td>
<td>
<p>If <code>type = "single"</code>, a named list of I x J matrices, 
each one corresponding to a covariate that varies across repeated sampling 
events within closure-units.
If <code>type = "multi"</code>, a named list of I x J x K arrays, each one 
corresponding to a covariate that varies across repeated sampling events 
within closure-units.
If <code>type = "augmented"</code>, a named list of L x J matrices, each one
corresponding to a covariate that varies across repeated sampling events
within sites (no dependence on species is allowed).</p>
</td></tr>
<tr><td><code id="make_flocker_data_+3A_type">type</code></td>
<td>
<p>The type of occupancy model desired. Options are:
<code>"single"</code> for a single_season model,
<code>"multi"</code> for a multi-season (dynamic) model, or
<code>"augmented"</code> for a single-season multi-species model with 
data-augmentation for never-observed pseudospecies.</p>
</td></tr>
<tr><td><code id="make_flocker_data_+3A_n_aug">n_aug</code></td>
<td>
<p>Number of pseudo-species to augment. Only applicable if 
<code>type = "augmented"</code>.</p>
</td></tr>
<tr><td><code id="make_flocker_data_+3A_quiet">quiet</code></td>
<td>
<p>Hide progress bars and informational messages?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flocker_data list that can be passed as data to <code>flock()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfd &lt;- simulate_flocker_data()
make_flocker_data(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
</code></pre>

<hr>
<h2 id='make_flocker_data_augmented'>#' Format data for data-augmented occupancy model, to be passed to 
<code>flock()</code>.</h2><span id='topic+make_flocker_data_augmented'></span>

<h3>Description</h3>

<p>#' Format data for data-augmented occupancy model, to be passed to 
<code>flock()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_flocker_data_augmented(
  obs,
  n_aug,
  site_covs = NULL,
  event_covs = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_flocker_data_augmented_+3A_obs">obs</code></td>
<td>
<p>An I x J x K array where rows I are sites, columns J are 
repeat sampling events, and slices K are species. Allowable values are 1 
(detection), 0 (no detection), and NA (no sampling event).
The data must be formatted so that all NAs are trailing within their rows.</p>
</td></tr>
<tr><td><code id="make_flocker_data_augmented_+3A_n_aug">n_aug</code></td>
<td>
<p>Number of pseudospecies to augment</p>
</td></tr>
<tr><td><code id="make_flocker_data_augmented_+3A_site_covs">site_covs</code></td>
<td>
<p>A dataframe of covariates for each site that are constant 
across repeated sampling events.</p>
</td></tr>
<tr><td><code id="make_flocker_data_augmented_+3A_event_covs">event_covs</code></td>
<td>
<p>A named list of I x J matrices, each one corresponding to a 
covariate that varies across repeated sampling events within sites</p>
</td></tr>
<tr><td><code id="make_flocker_data_augmented_+3A_quiet">quiet</code></td>
<td>
<p>Hide progress bars and informational messages?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flocker_data list that can be passed as data to <code>flocker()</code>.
</p>

<hr>
<h2 id='make_flocker_data_dynamic'>Format data for dynamic (multi-season) occupancy model, to be passed to 
<code>flock()</code>.</h2><span id='topic+make_flocker_data_dynamic'></span>

<h3>Description</h3>

<p>Format data for dynamic (multi-season) occupancy model, to be passed to 
<code>flock()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_flocker_data_dynamic(
  obs,
  unit_covs = NULL,
  event_covs = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_flocker_data_dynamic_+3A_obs">obs</code></td>
<td>
<p>An I x J x K array where closure is assumed across rows, columns 
are repeated sampling events, and slices along the third dimension are 
seasons. Allowable values are 1 (detection), 0 (no detection), and NA (no 
sampling event).
The data must be formatted so that all NAs are trailing within their rows
across repeat visits, but not necessarily across seasons.</p>
</td></tr>
<tr><td><code id="make_flocker_data_dynamic_+3A_unit_covs">unit_covs</code></td>
<td>
<p>A list of dataframes (one per season) of covariates for 
each closure-unit that are constant across repeated sampling events within 
units. All dataframes must have identical column names and types, and all
dataframes must have I rows.</p>
</td></tr>
<tr><td><code id="make_flocker_data_dynamic_+3A_event_covs">event_covs</code></td>
<td>
<p>A named list of I x J x K arrays, each one corresponding to 
a covariate that varies across repeated sampling events within closure-units</p>
</td></tr>
<tr><td><code id="make_flocker_data_dynamic_+3A_quiet">quiet</code></td>
<td>
<p>Hide progress bars and informational messages?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flocker_data list that can be passed as data to <code>flock()</code>.
</p>

<hr>
<h2 id='make_flocker_data_static'>Format data for single-season occupancy model, to be passed to 
<code>flock()</code>.</h2><span id='topic+make_flocker_data_static'></span>

<h3>Description</h3>

<p>Format data for single-season occupancy model, to be passed to 
<code>flock()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_flocker_data_static(
  obs,
  unit_covs = NULL,
  event_covs = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_flocker_data_static_+3A_obs">obs</code></td>
<td>
<p>An I x J matrix-like object where closure is assumed across rows 
and columns are repeated sampling events. Allowable values are 1 (detection), 
0 (no detection), and NA (no sampling event).</p>
</td></tr>
<tr><td><code id="make_flocker_data_static_+3A_unit_covs">unit_covs</code></td>
<td>
<p>A dataframe of covariates for each unit that are constant 
across repeated sampling events within closure-units.</p>
</td></tr>
<tr><td><code id="make_flocker_data_static_+3A_event_covs">event_covs</code></td>
<td>
<p>A named list of I x J matrices, each one corresponding to a covariate
that varies across repeated sampling events within closure-units</p>
</td></tr>
<tr><td><code id="make_flocker_data_static_+3A_quiet">quiet</code></td>
<td>
<p>Hide progress bars and informational messages?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flocker_data list that can be passed as data to <code>flock()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sfd &lt;- simulate_flocker_data()
make_flocker_data_static(
 sfd$obs, 
 sfd$unit_covs,
 sfd$event_covs
)
</code></pre>

<hr>
<h2 id='predict_flocker'>Get posterior predictions from a flocker model</h2><span id='topic+predict_flocker'></span>

<h3>Description</h3>

<p>Get posterior predictions from a flocker model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_flocker(
  flocker_fit,
  draw_ids = NULL,
  history_condition = FALSE,
  new_data = NULL,
  mixed = FALSE,
  allow_new_levels = FALSE,
  sample_new_levels = "uncertainty"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_flocker_+3A_flocker_fit">flocker_fit</code></td>
<td>
<p>A 'flocker_fit' object</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_draw_ids">draw_ids</code></td>
<td>
<p>Vector of indices of the posterior draws to be 
used. If 'NULL' (the default) all draws are used in their native order.</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_history_condition">history_condition</code></td>
<td>
<p>Logical indicator of whether to directly condition the 
posterior for the occupancy state on the observed detection histories.
For example, at sites with at least one detection, the true occupancy 
state conditioned on the history is one with absolute certainty. Without 
directly conditioning on the history, the occupancy state is controlled 
exclusively by the posterior distribution for the occupancy probability 
psi.</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_new_data">new_data</code></td>
<td>
<p>Optional new data at which to predict. If 'NULL', predictions
are given at the data points used for model fitting. Otherwise, must
be a flocker_data object produced by 'make_flocker_data'.</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_mixed">mixed</code></td>
<td>
<p>When 'new_data' is not provided, should random effect levels be
drawn from their posteriors ('FALSE', the default) or re-sampled from 
their fitted hyperparameters ('TRUE'). The latter can be useful for mixed
predictive checking. Note that setting to TRUE is not available for
grouping terms involved in phylogenetic random effects or other random 
effects with specified covariance structures.</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_allow_new_levels">allow_new_levels</code></td>
<td>
<p>Should new_data be allowed to contain new levels for
random effects?</p>
</td></tr>
<tr><td><code id="predict_flocker_+3A_sample_new_levels">sample_new_levels</code></td>
<td>
<p>If new_data is provided and contains random effect
levels not present in the original data, how should predictions be
handled? Passed directly to brms::prepare_predictions, which see.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of posterior predictions in the same shape as the
observations passed to 'make_flocker_data()' with posterior iterations
stacked along the final dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
unconditioned_preds &lt;- predict_flocker(example_flocker_model_single)
conditioned_preds &lt;- predict_flocker(
 example_flocker_model_single, 
 history_condition = TRUE
)

</code></pre>

<hr>
<h2 id='simulate_flocker_data'>Simulate data for use with <code>make_flocker_data()</code> and downstream 
functions.</h2><span id='topic+simulate_flocker_data'></span>

<h3>Description</h3>

<p>Data will be simulated with one unit covariate that affects all 
relevant terms, one event covariate that affects detection (unless 
'rep_constant' is 'TRUE'), and one grouping factor representing species
with correlated effects on all terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_flocker_data(
  n_rep = 4,
  n_pt = 50,
  n_sp = 30,
  n_season = 1,
  multiseason = NULL,
  multi_init = NULL,
  augmented = FALSE,
  rep_constant = FALSE,
  params = NULL,
  covariates = NULL,
  seed = 123,
  ragged_rep = FALSE,
  missing_seasons = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_flocker_data_+3A_n_rep">n_rep</code></td>
<td>
<p>number of replicate visits to simulate per closure unit</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_n_pt">n_pt</code></td>
<td>
<p>number of points to simulate. The number of units for single-
season models will be 'n_pt*n_sp'. The number of units for multi-season
models will be 'n_pt*n_sp*n_season'.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_n_sp">n_sp</code></td>
<td>
<p>number of levels to include in random effect. For compatibility
with multispecies models where the random effect represents species,
the data get expanded such that there's a row (closure-unit) for each
combination of sampling point and effect level (i.e. species)</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_n_season">n_season</code></td>
<td>
<p>Number of seasons desired. 1 yields data for a single-season 
model; all other positive integers yield data for multiseason models.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_multiseason">multiseason</code></td>
<td>
<p>if n_season is NULL, must be NULL. Otherwise, one of
&quot;colex&quot; or &quot;autologistic&quot;.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_multi_init">multi_init</code></td>
<td>
<p>if n_season is NULL, must be NULL. Otherwise, one of 
&quot;explicit&quot; or &quot;equilibrium&quot;.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_augmented">augmented</code></td>
<td>
<p>logical. If 'TRUE' data will be formatted for an augmented
model, which requires that 'n_season == 1'. All never-observed 
species will be trimmed out of the data, and the default parameters will be
modified to increase random effect variances for the detection and occupancy,
intercepts and to decrease random effect variances for detection slopes, thus
encouraging the existence of never-observed species. Furthermore, the data will
be simulated without any covariate influence on occupancy.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_rep_constant">rep_constant</code></td>
<td>
<p>logical: create data with unit covariates only (TRUE) 
or data that includes event covariates (FALSE)</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_params">params</code></td>
<td>
<p>a named list containing of parameter values to use in simulation.
Any required parameters whose names are not in this list will be assigned their
default values. To see the parameter names and structures required, run with 
'params = NULL' (the default) and examine the '$params' element of the output.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_covariates">covariates</code></td>
<td>
<p>a dataframe of covariate values to use in simulation, or
NULL to simulate values. To see the covariate names and structures required,
run with 'covariates = NULL' (the default) and examine the '$covariates' element
of the output.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_seed">seed</code></td>
<td>
<p>random seed. NULL uses (and updates) the existing RNG state. Other values
do not update the global RNG state.</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_ragged_rep">ragged_rep</code></td>
<td>
<p>logical: create data with variable (TRUE) or constant 
(FALSE) numbers of visits per unit.  If TRUE, approximately half of units 
will be missing approximately half of 'n_rep' visits. Intended primarily for 
development purposes (bug-checking models with missing data).</p>
</td></tr>
<tr><td><code id="simulate_flocker_data_+3A_missing_seasons">missing_seasons</code></td>
<td>
<p>logical; relevant only if n_season is greater than 1. 
create data with variable (TRUE) or constant (FALSE) numbers of seasons per 
series (TRUE). If TRUE, approximately half of series will be missing their
even-numbered seasons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the observation matrix/array ($obs), the unit covariate 
dataframe(s) ($unit_covs), the event covariate list ($event_covs), the parameters
used in simulation ($params) and the covariate list used in simulation ($covariates). 
If rep_constant is TRUE, then $event_covs will be NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate_flocker_data()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
