<!DOCTYPE html><html lang="en"><head><title>Help for package autoFRK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {autoFRK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.matrix.mrts'><p> internal function</p></a></li>
<li><a href='#autoFRK'><p>Automatic Fixed Rank Kriging</p></a></li>
<li><a href='#checkDiag'><p> internal function</p></a></li>
<li><a href='#cMLE'><p> internal function</p></a></li>
<li><a href='#cMLEimat'><p> internal function</p></a></li>
<li><a href='#cMLElk'><p> internal function</p></a></li>
<li><a href='#cMLEsp'><p> internal function</p></a></li>
<li><a href='#diag.spam'><p> internal function</p></a></li>
<li><a href='#DIST'>
<p>internal function</p></a></li>
<li><a href='#EM0miss'>
<p>internal function</p></a></li>
<li><a href='#extractLK'><p>internal function</p></a></li>
<li><a href='#getASCeigens'><p> internal function</p></a></li>
<li><a href='#getEigen'><p> internal function</p></a></li>
<li><a href='#getHalf'><p> internal function</p></a></li>
<li><a href='#getLikelihood'><p> internal function</p></a></li>
<li><a href='#ifElse'><p>internal function</p></a></li>
<li><a href='#indeMLE'><p> internal function</p></a></li>
<li><a href='#initializeLKnFRK'><p> internal function</p></a></li>
<li><a href='#invCz'><p> internal function</p></a></li>
<li><a href='#log'><p> internal function</p></a></li>
<li><a href='#mkpd'><p> internal function</p></a></li>
<li><a href='#mrts'><p>Multi-Resolution Thin-plate Spline Basis Functions</p></a></li>
<li><a href='#mrtsrcpp'><p> internal function</p></a></li>
<li><a href='#mrtsrcpp_predict'><p> internal function</p></a></li>
<li><a href='#mrtsrcpp_predict0'><p> internal function</p></a></li>
<li><a href='#predict.FRK'><p>Predict method for Fixed Rank Kriging</p></a></li>
<li><a href='#predict.mrts'><p>Multi-Resolution Thin-plate Spline Basis Functions</p></a></li>
<li><a href='#print.FRK'><p> internal function</p></a></li>
<li><a href='#print.mrts'><p> internal function</p></a></li>
<li><a href='#ramSize'><p> internal function</p></a></li>
<li><a href='#rlimit'><p> internal function</p></a></li>
<li><a href='#selectBasis'><p> internal function</p></a></li>
<li><a href='#setLKnFRKOption'><p> internal function</p></a></li>
<li><a href='#setNC'><p> internal function</p></a></li>
<li><a href='#subKnot'><p> internal function</p></a></li>
<li><a href='#systemRam'><p> internal function</p></a></li>
<li><a href='#toSpMat'><p> internal function</p></a></li>
<li><a href='#uniquecombs'><p> internal function</p></a></li>
<li><a href='#ZinvC'><p> internal function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Fixed Rank Kriging</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic fixed rank kriging for (irregularly located)
    spatial data using a class of basis functions with multi-resolution features
    and ordered in terms of their resolutions. The model parameters are estimated
    by maximum likelihood (ML) and the number of basis functions is determined
    by Akaike's information criterion (AIC). For spatial data with either one
    realization or independent replicates, the ML estimates and AIC are efficiently
    computed using their closed-form expressions when no missing value occurs. Details 
    regarding the basis function construction, parameter estimation, and AIC calculation  
    can be found in Tzeng and Huang (2018) &lt;<a href="https://doi.org/10.1080%2F00401706.2017.1345701">doi:10.1080/00401706.2017.1345701</a>&gt;. For
    data with missing values, the ML estimates are obtained using the expectation-
    maximization algorithm. Apart from the number of basis functions, there are
    no other tuning parameters, making the method fully automatic. Users can also
    include a stationary structure in the spatial covariance, which utilizes
    'LatticeKrig' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spam</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields (&ge; 6.9.1), filehashSQLite, filehash, MASS, mgcv,
LatticeKrig (&ge; 5.4), FNN, filematrix, Rcpp, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RSpectra, RcppEigen, RcppParallel</td>
</tr>
<tr>
<td>Author:</td>
<td>ShengLi Tzeng [aut, cre], Hsin-Cheng Huang [aut], Wen-Ting Wang [ctb], Douglas Nychka [ctb], Colin Gillespie [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>ShengLi Tzeng &lt;slt.cmu@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-12 21:10:07 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-12 11:53:57 UTC; h0h1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
</table>
<hr>
<h2 id='as.matrix.mrts'> internal function </h2><span id='topic+as.matrix.mrts'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='autoFRK'>Automatic Fixed Rank Kriging</h2><span id='topic+autoFRK'></span>

<h3>Description</h3>

<p>This function performs resolution adaptive fixed rank kriging based on
spatial data observed at one or multiple time points via the following
spatial random-effects model:
</p>
<p style="text-align: center;"><code class="reqn">z[t]=\mu + G \cdot w[t]+\eta[t]+e[t], w[t] \sim N(0,M), e[t] \sim N(0, s \cdot D); t=1,...,T,</code>
</p>

<p>where <code class="reqn">z[t]</code> is an <em>n</em>-vector of (partially) observed data at <em>n</em> locations,
<code class="reqn">\mu</code> is an <em>n</em>-vector of deterministic mean values,
<code class="reqn">D</code> is a given n by n matrix,
<code class="reqn">G</code> is a given <em>n</em> by <em>K</em> matrix,
<code class="reqn">\eta[t]</code> is an n-vector of random variables corresponding to a spatial stationary process,
and <code class="reqn">w[t]</code> is a K-vector of unobservable random weights.
Parameters are estimated by maximum likelihood in a closed-form expression. The matrix <code class="reqn">G</code> corresponding to basis functions is
given by an ordered class of thin-plate spline functions, with the number of basis functions
selected by  Akaike's information criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoFRK(
  Data,
  loc,
  mu = 0,
  D = diag.spam(NROW(Data)),
  G = NULL,
  finescale = FALSE,
  maxit = 50,
  tolerance = 0.1^6,
  maxK = NULL,
  Kseq = NULL,
  method = c("fast", "EM"),
  n.neighbor = 3,
  maxknot = 5000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoFRK_+3A_data">Data</code></td>
<td>
<p><em>n</em> by <em>T</em> data matrix (NA allowed) with
<code class="reqn">z[t]</code> as the <em>t</em>-th column.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_loc">loc</code></td>
<td>
<p><em>n</em> by <em>d</em> matrix of coordinates corresponding to <em>n</em> locations.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_mu">mu</code></td>
<td>
<p><em>n</em>-vector or scalar for <code class="reqn">\mu</code>; Default is 0.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_d">D</code></td>
<td>
<p><em>n</em> by <em>n</em> matrix (preferably sparse) for the covariance matrix of the measurement errors up to a constant scale.
Default is an identity matrix.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_g">G</code></td>
<td>
<p><em>n</em> by <em>K</em> matrix of basis function values with each column being a basis function taken values at <code>loc</code>.
Default is NULL, which is automatic determined.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_finescale">finescale</code></td>
<td>
<p>logical; if <code>TRUE</code> then a (approximate) stationary finer scale process <code class="reqn">\eta[t]</code> will be included
based on <code>LatticeKrig</code> pacakge.
In such a case, only the diagonals of <code class="reqn">D</code> would be taken into account. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. Default is 50.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_tolerance">tolerance</code></td>
<td>
<p>precision tolerance for convergence check. Default is 0.1^6.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_maxk">maxK</code></td>
<td>
<p>maximum number of basis functions considered. Default is
<code class="reqn">10 \cdot \sqrt{n}</code> for <em>n&gt;100</em> or <em>n</em> for <em>n&lt;=100</em>.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_kseq">Kseq</code></td>
<td>
<p>user-specified vector of numbers of basis functions considered. Default is
<code>NULL</code>, which is determined from <code>maxK</code>.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_method">method</code></td>
<td>
<p>&quot;fast&quot; or &quot; EM&quot;; if &quot;fast&quot; then the missing data are filled in using k-nearest-neighbor imputation;
if &quot;EM&quot; then the missing data are taken care by the EM algorithm. Default is &quot;fast&quot;.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_n.neighbor">n.neighbor</code></td>
<td>
<p>number of neighbors to be used in the &quot;fast&quot; imputation method. Default is 3.</p>
</td></tr>
<tr><td><code id="autoFRK_+3A_maxknot">maxknot</code></td>
<td>
<p>maximum number of knots to be used in
generating basis functions. Default is 5000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the ML estimate of M using the closed-form expression in Tzeng and Huang (2018).
If the user would like to specify
a <code>D</code> other than an identity matrix for a large <em>n</em>, it is better to provided via <code>spam</code> function
in <code>spam</code> package.
</p>


<h3>Value</h3>

<p>an object of class <code>FRK</code> is returned, which is a list of the following components:
</p>
<table role = "presentation">
<tr><td><code>M</code></td>
<td>
<p>ML estimate of <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>estimate for the scale parameter of measurement errors.</p>
</td></tr>
<tr><td><code>negloglik</code></td>
<td>
<p> negative  log-likelihood.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p><em>K</em> by <em>T</em> matrix with <code class="reqn">w[t]</code> as the <em>t</em>-th column.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p><em>K</em> by <em>K</em> matrix of the prediction error covariance matrix of <code class="reqn">w[t]</code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>user specified basis function matrix or an automatically generated <code>mrts</code> object.</p>
</td></tr>
<tr><td><code>LKobj</code></td>
<td>
<p>a list from calling <code>LKrig.MLE</code> in <code>LatticeKrig</code> package if <code>useLK=TRUE</code>;
otherwise <code>NULL</code>. See that package for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>ShengLi Tzeng and Hsin-Cheng Huang.
</p>


<h3>References</h3>

<p>Tzeng, S., &amp; Huang, H.-C. (2018). Resolution Adaptive Fixed Rank Kriging, Technometrics, https://doi.org/10.1080/00401706.2017.1345701.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.FRK">predict.FRK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### generating data from two eigenfunctions
originalPar &lt;- par(no.readonly = TRUE)
set.seed(0)
n &lt;- 150
s &lt;- 5
grid1 &lt;- grid2 &lt;- seq(0, 1, l = 30)
grids &lt;- expand.grid(grid1, grid2)
fn &lt;- matrix(0, 900, 2)
fn[, 1] &lt;- cos(sqrt((grids[, 1] - 0)^2 + (grids[, 2] - 1)^2) * pi)
fn[, 2] &lt;- cos(sqrt((grids[, 1] - 0.75)^2 + (grids[, 2] - 0.25)^2) * 2 * pi)

#### single realization simulation example
w &lt;- c(rnorm(1, sd = 5), rnorm(1, sd = 3))
y &lt;- fn %*% w
obs &lt;- sample(900, n)
z &lt;- y[obs] + rnorm(n) * sqrt(s)
X &lt;- grids[obs, ]

#### method1: automatic selection and prediction
one.imat &lt;- autoFRK(Data = z, loc = X, maxK = 15)
yhat &lt;- predict(one.imat, newloc = grids)

#### method2: user-specified basis functions
G &lt;- mrts(X, 15)
Gpred &lt;- predict(G, newx = grids)
one.usr &lt;- autoFRK(Data = z, loc = X, G = G)
yhat2 &lt;- predict(one.usr, newloc = grids, basis = Gpred)

require(fields)
par(mfrow = c(2, 2))
image.plot(matrix(y, 30, 30), main = "True")
points(X, cex = 0.5, col = "grey")
image.plot(matrix(yhat$pred.value, 30, 30), main = "Predicted")
points(X, cex = 0.5, col = "grey")
image.plot(matrix(yhat2$pred.value, 30, 30), main = "Predicted (method 2)")
points(X, cex = 0.5, col = "grey")
plot(yhat$pred.value, yhat2$pred.value, mgp = c(2, 0.5, 0))
par(originalPar)
#### end of single realization simulation example

#### independent multi-realization simulation example
set.seed(0)
wt &lt;- matrix(0, 2, 20)
for (tt in 1:20) wt[, tt] &lt;- c(rnorm(1, sd = 5), rnorm(1, sd = 3))
yt &lt;- fn %*% wt
obs &lt;- sample(900, n)
zt &lt;- yt[obs, ] + matrix(rnorm(n * 20), n, 20) * sqrt(s)
X &lt;- grids[obs, ]
multi.imat &lt;- autoFRK(Data = zt, loc = X, maxK = 15)
Gpred &lt;- predict(multi.imat$G, newx = grids)

G &lt;- multi.imat$G
Mhat &lt;- multi.imat$M
dec &lt;- eigen(G %*% Mhat %*% t(G))
fhat &lt;- Gpred %*% Mhat %*% t(G) %*% dec$vector[, 1:2]
par(mfrow = c(2, 2))
image.plot(matrix(fn[, 1], 30, 30), main = "True Eigenfn 1")
image.plot(matrix(fn[, 2], 30, 30), main = "True Eigenfn 2")
image.plot(matrix(fhat[, 1], 30, 30), main = "Estimated Eigenfn 1")
image.plot(matrix(fhat[, 2], 30, 30), main = "Estimated Eigenfn 2")
par(originalPar)
#### end of independent multi-realization simulation example
</code></pre>

<hr>
<h2 id='checkDiag'> internal function </h2><span id='topic+checkDiag'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='cMLE'> internal function </h2><span id='topic+cMLE'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='cMLEimat'> internal function </h2><span id='topic+cMLEimat'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='cMLElk'> internal function </h2><span id='topic+cMLElk'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='cMLEsp'> internal function </h2><span id='topic+cMLEsp'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='diag.spam'> internal function </h2><span id='topic+diag.spam'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='DIST'>
internal function
</h2><span id='topic+DIST'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='EM0miss'>
internal function
</h2><span id='topic+EM0miss'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='extractLK'>internal function</h2><span id='topic+extractLK'></span>

<h3>Description</h3>

<p>internal function</p>

<hr>
<h2 id='getASCeigens'> internal function </h2><span id='topic+getASCeigens'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='getEigen'> internal function </h2><span id='topic+getEigen'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='getHalf'> internal function </h2><span id='topic+getHalf'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='getLikelihood'> internal function </h2><span id='topic+getLikelihood'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='ifElse'>internal function</h2><span id='topic+ifElse'></span>

<h3>Description</h3>

<p>internal function</p>

<hr>
<h2 id='indeMLE'> internal function </h2><span id='topic+indeMLE'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='initializeLKnFRK'> internal function </h2><span id='topic+initializeLKnFRK'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='invCz'> internal function </h2><span id='topic+invCz'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='log'> internal function </h2><span id='topic+log'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='mkpd'> internal function </h2><span id='topic+mkpd'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='mrts'>Multi-Resolution Thin-plate Spline Basis Functions</h2><span id='topic+mrts'></span>

<h3>Description</h3>

<p>This function generates multi-resolution thin-plate spline basis functions.
The basis functions are (descendingly) ordered
in terms of their degrees of smoothness with a higher-order function corresponding
to larger-scale features and a lower-order one corresponding to smaller-scale details.
They are useful in the spatio-temporal random effects model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrts(knot, k, x = NULL, maxknot = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrts_+3A_knot">knot</code></td>
<td>
<p><em>m</em> by <em>d</em> matrix (<em>d&lt;=3</em>) for <em>m</em> locations of <em>d</em>-dimensional knots as in ordinary splines.
Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="mrts_+3A_k">k</code></td>
<td>
<p>the number (<em>&lt;=m</em>) of basis functions.</p>
</td></tr>
<tr><td><code id="mrts_+3A_x">x</code></td>
<td>
<p><em>n</em> by <em>d</em> matrix of coordinates corresponding to <em>n</em> locations where the values of basis functions to be evaluated.
Default is <code>NULL</code>, which uses the <em>m</em> by <em>d</em> matrix in <code>knot</code>.</p>
</td></tr>
<tr><td><code id="mrts_+3A_maxknot">maxknot</code></td>
<td>
<p>maximum number of knots to be used in generating basis functions. If  <code>maxknot</code> &lt; <em>m</em>, a deterministic subset selection of knots will be used.  For using all knots, set <code>maxknot</code>&gt;=<em>m</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>mrts</code> object is generated. If <code>x=NULL</code> (default) it returns
an <em>m</em> by <em>k</em> matrix of <em>k</em> basis function taken values at knots.
With <code>x</code> given, it returns <em>n</em> by <em>k</em> matrix for basis functions taken values at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>ShengLi Tzeng and Hsin-Cheng Huang.
</p>


<h3>References</h3>

<p>Tzeng, S., &amp; Huang, H. C. (2018). Resolution Adaptive Fixed Rank Kriging. Technometrics, https://doi.org/10.1080/00401706.2017.1345701.
Tzeng, S., &amp; Huang, H. C. (2015). Multi-Resolution Spatial Random-Effects Models
for Irregularly Spaced Data. arXiv preprint arXiv:1504.05659.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.mrts">predict.mrts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>originalPar &lt;- par(no.readonly = TRUE)
knot &lt;- seq(0, 1, l = 30)
b &lt;- mrts(knot, 30)
x0 &lt;- seq(0, 1, l = 200)
bx &lt;- predict(b, x0)
par(mfrow = c(5, 6), mar = c(0, 0, 0, 0))
for (i in 1:30) {
  plot(bx[, i], type = "l", axes = FALSE)
  box()
}
par(originalPar)
</code></pre>

<hr>
<h2 id='mrtsrcpp'> internal function </h2><span id='topic+mrtsrcpp'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='mrtsrcpp_predict'> internal function </h2><span id='topic+mrtsrcpp_predict'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='mrtsrcpp_predict0'> internal function </h2><span id='topic+mrtsrcpp_predict0'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='predict.FRK'>Predict method for Fixed Rank Kriging</h2><span id='topic+predict.FRK'></span>

<h3>Description</h3>

<p>Predicted values and estimate of standard errors based on an &quot;<code>autoFRK</code>&quot; model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FRK'
predict(
  object,
  obsData = NULL,
  obsloc = NULL,
  mu.obs = 0,
  newloc = obsloc,
  basis = NULL,
  mu.new = 0,
  se.report = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.FRK_+3A_object">object</code></td>
<td>
<p>a model object obtained from &quot;<code>autoFRK</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_obsdata">obsData</code></td>
<td>
<p>a vector with observed data used for prediction.
Default is <code>NULL</code>, which uses the <code>Data</code> input from <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_obsloc">obsloc</code></td>
<td>
<p>a matrix with rows being coordinates of observation locations for <code>obsData</code>.
Only <code>object</code> using <code>mrts</code> basis functions can have
<code>obsloc</code> different from the <code>loc</code> input of <code>object</code>;
not applicable for user-specified basis functions.
Default is <code>NULL</code>, which uses the <code>loc</code> input of <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_mu.obs">mu.obs</code></td>
<td>
<p>a vector or scalar for the deterministic mean values at <code>obsloc</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_newloc">newloc</code></td>
<td>
<p>a matrix with rows being coordinates of new locations for prediction.
Default is <code>NULL</code>, which gives prediction at the locations of the observed data.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_basis">basis</code></td>
<td>
<p>a matrix with each column being a basis function taken values at <code>newloc</code>.
It can be omitted if <code>object</code> was fitted using  default <code>mrts</code> basis functions.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_mu.new">mu.new</code></td>
<td>
<p>a vector or scalar for the deterministic mean values at <code>newloc</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_se.report">se.report</code></td>
<td>
<p>logical; if <code>TRUE</code> then the standard error of prediction is reported.</p>
</td></tr>
<tr><td><code id="predict.FRK_+3A_...">...</code></td>
<td>
<p>not used but needed for the S3 generic/method compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components described below.
</p>
<table role = "presentation">
<tr><td><code>pred.value</code></td>
<td>
<p>a matrix with the <em>(i,t)</em> element being the predicted value at <em>i</em>-th location and time <em>t</em>.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>a vector with the <em>i</em>-th element being the standard error of the predicted value at the <em>i</em>-th location.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>ShengLi Tzeng and Hsin-Cheng Huang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoFRK">autoFRK</a></code>
</p>

<hr>
<h2 id='predict.mrts'>Multi-Resolution Thin-plate Spline Basis Functions</h2><span id='topic+predict.mrts'></span>

<h3>Description</h3>

<p>Evaluate multi-resolution thin-plate spline basis  functions at given locations.
This function provides a generic prediction method for <code>mrts</code> objects,
in a similar way as <code>predict.ns</code> and <code>predict.bs</code> in <code>splines</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrts'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mrts_+3A_object">object</code></td>
<td>
<p>object produced from calling mrts.</p>
</td></tr>
<tr><td><code id="predict.mrts_+3A_newx">newx</code></td>
<td>
<p>an <em>n</em> by <em>d</em> matrix of coordinates corresponding to <em>n</em> locations.</p>
</td></tr>
<tr><td><code id="predict.mrts_+3A_...">...</code></td>
<td>
<p>not used but needed for the S3 generic/method compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <em>n</em> by <em>k</em> matrix of the <em>k</em> basis function in <code>object</code> taken values at <code>newx</code>.
</p>


<h3>Author(s)</h3>

<p>ShengLi Tzeng and Hsin-Cheng Huang.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mrts">mrts</a></code>
</p>

<hr>
<h2 id='print.FRK'> internal function </h2><span id='topic+print.FRK'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='print.mrts'> internal function </h2><span id='topic+print.mrts'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='ramSize'> internal function </h2><span id='topic+ramSize'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='rlimit'> internal function </h2><span id='topic+rlimit'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='selectBasis'> internal function </h2><span id='topic+selectBasis'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='setLKnFRKOption'> internal function </h2><span id='topic+setLKnFRKOption'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='setNC'> internal function </h2><span id='topic+setNC'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='subKnot'> internal function </h2><span id='topic+subKnot'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='systemRam'> internal function </h2><span id='topic+systemRam'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='toSpMat'> internal function </h2><span id='topic+toSpMat'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='uniquecombs'> internal function </h2><span id='topic+uniquecombs'></span>

<h3>Description</h3>

<p> internal function </p>

<hr>
<h2 id='ZinvC'> internal function </h2><span id='topic+ZinvC'></span>

<h3>Description</h3>

<p> internal function </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
