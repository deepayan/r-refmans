<!DOCTYPE html><html><head><title>Help for package regRSM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {regRSM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ImpPlot.regRSM'>
<p>Variable importance plot from 'regRSM' object.</p></a></li>
<li><a href='#plot.regRSM'>
<p>Plot from 'regRSM' object.</p></a></li>
<li><a href='#predict.regRSM'>
<p>Predictions from a 'regRSM' object.</p></a></li>
<li><a href='#print.regRSM'>
<p>Print 'regRSM' object.</p></a></li>
<li><a href='#regRSM'>
<p>Random Subspace Method (RSM) for linear regression.</p></a></li>
<li><a href='#roc.regRSM'>
<p>ROC curve and AUC parameter.</p></a></li>
<li><a href='#summary.regRSM'>
<p>Print 'regRSM' object.</p></a></li>
<li><a href='#validate.regRSM'>
<p>Selects the new final model from existing 'regRSM' object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Random Subspace Method (RSM) for Linear Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-09-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Pawel Teisseyre, Robert A. Klopotek</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pawel Teisseyre &lt;teisseyrep@ipipan.waw.pl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs Random Subspace Method (RSM) for high-dimensional linear regression to obtain variable importance measures. The final model is chosen based on validation set or Generalized Information Criterion.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpi, doParallel, parallel, foreach</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.ipipan.eu/~teisseyrep/SOFTWARE/">http://www.ipipan.eu/~teisseyrep/SOFTWARE/</a></td>
</tr>
<tr>
<td>Archs:</td>
<td>x64</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-11 12:09:51 UTC; pt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-11 16:38:15</td>
</tr>
</table>
<hr>
<h2 id='ImpPlot.regRSM'>
Variable importance plot from 'regRSM' object.
</h2><span id='topic+ImpPlot.regRSM'></span><span id='topic+ImpPlot'></span>

<h3>Description</h3>

<p>This function produces a dot plot showing final scores from RSM procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
ImpPlot(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImpPlot.regRSM_+3A_object">object</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a dot plot showing final scores from RSM procedure.
Final scores describe importances of explanatory variables.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=100
n=100
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)  
x = matrix(0,ncol=p,nrow=n)
for(j in 1:p){ 
    x[,j]=rnorm(n,0,1)
}
y = x %*% beta1 + rnorm(n)

p1=regRSM(x,y)
ImpPlot(p1)
</code></pre>

<hr>
<h2 id='plot.regRSM'>
Plot from 'regRSM' object.
</h2><span id='topic+plot.regRSM'></span>

<h3>Description</h3>

<p>This function produces a plot showing prediction errors on validation set (or the value of Generalized Information Criterion)
with respect to the number of variables included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.regRSM_+3A_x">x</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
<tr><td><code id="plot.regRSM_+3A_...">...</code></td>
<td>

<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Generalized Information Criterion (GIC) was used in the second step of RSM procedure (<code>useGIC=TRUE</code>) then the function
produces a plot showing the value of GIC with respect to the number of variables included in the model. Model corresponding to
the minimal value of GIC is chosen as a final one.
If GIC was not used (<code>useGIC=FALSE</code>) and the validation set is supplied then the function
produces a plot showing prediction errors on validation set with respect to the number of variables included in the model. Model corresponding to
the minimal value of the prediction error is chosen as a final one.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=500
n=50
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)  
x = matrix(0,ncol=p,nrow=n)
xval = matrix(0,ncol=p,nrow=n)
xtest = matrix(0,ncol=p,nrow=n)
for(j in 1:p){ 
    x[,j]=rnorm(n,0,1)
    xval[,j]=rnorm(n,0,1)  
}
y = x %*% beta1 + rnorm(n)
yval = xval %*% beta1 + rnorm(n)

p1=regRSM(x,y)
plot(p1)

p2 = regRSM(x,y,yval,xval,useGIC=FALSE)
plot(p2)
</code></pre>

<hr>
<h2 id='predict.regRSM'>
Predictions from a 'regRSM' object.
</h2><span id='topic+predict.regRSM'></span>

<h3>Description</h3>

<p>This function makes predictions from a 'regRSM' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
predict(object, xnew,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.regRSM_+3A_object">object</code></td>
<td>

<p>Fitted 'regRSM' model object
</p>
</td></tr>
<tr><td><code id="predict.regRSM_+3A_xnew">xnew</code></td>
<td>

<p>Matrix of new values for x at which predictions are to be made.
</p>
</td></tr>
<tr><td><code id="predict.regRSM_+3A_...">...</code></td>
<td>

<p>Additional arguments not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction is made based on a final model which is chosen using validation set or Generalized Information Criterion (GIC).
</p>


<h3>Value</h3>

<p>predict.regRSM produces a vector of predictions.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = 100
n = 100
beta1 = numeric(p)
beta1[c(1,5,10)] = c(1,1,1)  
x = matrix(0,ncol=p,nrow=n)
xtest = matrix(0,ncol=p,nrow=n)
for(j in 1:p){ 
    x[,j] = rnorm(n,0,1)
    xtest[,j] = rnorm(n,0,1)    
}
y = x %*% beta1 + rnorm(n)
p1 = regRSM(x,y)
predict(p1,xtest)
</code></pre>

<hr>
<h2 id='print.regRSM'>
Print 'regRSM' object.
</h2><span id='topic+print.regRSM'></span>

<h3>Description</h3>

<p>This function print the summary of the RSM procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.regRSM_+3A_x">x</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
<tr><td><code id="print.regRSM_+3A_...">...</code></td>
<td>

<p>Additional arguments not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints out information about the selection method, screening, initial weights, version (sequential or parallel),
size of the random subpace, number of simulations.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=100
n=100
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)
x = matrix(0,ncol=p,nrow=n)
xval = matrix(0,ncol=p,nrow=n)
xtest = matrix(0,ncol=p,nrow=n)
for(j in 1:p){
    x[,j]=rnorm(n,0,1)
}
y = x %*% beta1 + rnorm(n)

p1=regRSM(x,y)
print(p1)
</code></pre>

<hr>
<h2 id='regRSM'>
Random Subspace Method (RSM) for linear regression.
</h2><span id='topic+regRSM.default'></span><span id='topic+regRSM.formula'></span><span id='topic+regRSM'></span>

<h3>Description</h3>

<p>Performs Random Subspace Method (RSM) for high-dimensional linear regression to obtain variable importance measures.
The final model is chosen based on validation set or Generalized Information Criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
regRSM(formula, data=NULL, ...)
## Default S3 method:
regRSM(x, y, yval, xval, m, B, parallel, nslaves, store_data, screening,
init_weights, useGIC, thrs, penalty,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regRSM_+3A_formula">formula</code></td>
<td>

<p>Formula describing the model to be fitted.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_data">data</code></td>
<td>

<p>Data frame containing the variables in the model
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_y">y</code></td>
<td>

<p>Quatitative response vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> is a number of observations.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_x">x</code></td>
<td>

<p>Input matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">p</code> is a number of variables. Each row is an observation vector.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_yval">yval</code></td>
<td>

<p>Optional quatitative response vector from validation set. Default is <code>NULL</code>. 
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_xval">xval</code></td>
<td>

<p>Optional input matrix from validation set. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_m">m</code></td>
<td>

<p>The size of the random subspace. Default is <code class="reqn">min(n-1,p)/2</code>. Parameter <code>m</code> cannot be larger than the number of observations minus two. 
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_b">B</code></td>
<td>

<p>Number of repetitions in RSM procedure. Default is 1000.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_parallel">parallel</code></td>
<td>

<p>This argument indicates which version should be used. Default is <code>NO</code>, which indicates that sequential version isused. See also in details.  
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_nslaves">nslaves</code></td>
<td>

<p>Number of slaves. Default is 4.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_store_data">store_data</code></td>
<td>

<p>Logical argument indicating whether matrix <code>x</code> and vector <code>y</code> should be stored. Default is <code>FALSE</code>. This argument must be <code>TRUE</code> when
function <code>validate.regRSM</code> is used.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_screening">screening</code></td>
<td>

<p>If the screeing argument is in <code class="reqn">(0,1)</code>, the initial screening of variables is performed and 'screening %' 
of variables least correlated with the response are discarded. Then the RSM procedure is performaed on the remaining variables.
Default is NULL, which indicates that no screening is used. 
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_init_weights">init_weights</code></td>
<td>

<p>This argument indicates whether weighted version of the procedure should be used.   
If the <code>init_weights</code> argument is <code>TRUE</code>, weighted version of the RSM procedure is used (called WRSM). In WRSM,
variables are drawn to random subspaces with probabilities proportional to their correlations with the response <code>y</code>. 
Default is <code>FALSE</code>, which indicates that variables are drawn to subspaces with equal probabilities. 
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_usegic">useGIC</code></td>
<td>

<p>Logical argument indicating whether Generalized Information Criterion (GIC) should be used in the second step of the procedure.
Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_thrs">thrs</code></td>
<td>

<p>Cut off threshold. The hierarchical list of models given by the ordering of variables is cut off at level <code>thrs</code>
in order to avoid fitting linear models which are close to saturated model. Default is <code>thrs=p</code> if <code class="reqn">p&lt;n/2</code> and <code>thrs=n/2</code>
if <code class="reqn">p&gt;n/2</code>. 
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_penalty">penalty</code></td>
<td>

<p>Penalty in Generalized Information Criterion (GIC). Default is <code class="reqn">log(n)</code> which corresponds to Bayesian Information Criterion (BIC).
</p>
</td></tr>
<tr><td><code id="regRSM_+3A_...">...</code></td>
<td>

<p>other arguments not available now.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Random Subspace Method (RSM) is used to compute importance measures of explanatory variables (RSM final scores).
In the second step the variables are ordered with respect to the final scores. 
From the nested list of models, given by the ordering, the final model is selected (the list is truncated at the level <code>thrs</code>
to avoid fitting models which are close to saturated model).
By default the final model that minimizes Generalized Information Criterion (GIC) is chosen.
If the validation set is supplied and <code>useGIC=FALSE</code> then the final model that minimizes prediction error on validation set is selected.    
</p>
<p>When screening and weighted version are used together, in the first step screening is performed and then the weighted version (WRSM) is used on the reamining variables.
</p>
<p>When <code>parallel=NO</code> sequential code is used for computaion. Else in our implementation the most costly operation (number of repetitions in RSM procedure) is parallelized. It is very inefficient to
use parallelisation on machine with only single processor with singe core.
</p>
<p><code>regRSM</code> function in parallel mode does not close created <code>slaves</code>, because creation of slaves is usually very time consuming. Next parallel call will reuse existing <code>slave</code> processes. If you want change the number of <code>slaves</code> please execute <code>mpi.close.Rslaves()</code> (if <code>parallel=MPI</code>) and then call function <code>regRSM</code> with new parameter <code>nslaves</code>. 
</p>
<p>When <code>parallel=POSIX</code> then <code>OpenMP</code> like parallel implementation is used. This parallel execution is handled by <code>doParallel</code> library. It uses parallelisation of loops. The optimal value of <code>nslaves</code> is the number of prosessor cores in a machine.  
</p>
<p>When <code>parallel=MPI</code> then MPI parallel implementation is used. This parallel execution is handled by <code>Rmpi</code> library. MPI (Message Passing Interface) uses messages to send job tasks from main process (master) to other processes (slaves). These processes can be running not nessesery on one machine. In our implementation the most costly operation (number of repetitions in RSM procedure) is parallelized. The optimal value of <code>nslaves</code> is the number of computing cores of all machines configured in MPI framework. If only one machine is used, the best value is number of prosessor cores. If you don't want to use this kind of parallel computations any more remember to close MPI framework by calling <code>mpi.close.Rslaves()</code>. 
</p>
<p><code>regRSM</code> function in parallel mode does not close created <code>slaves</code>, because creation and destruction of slaves is usually very time consuming. Next parallel call will reuse existing <code>slave</code> processes. If you want change number of <code>slaves</code> please execute <code>mpi.close.Rslaves()</code> and then call function <code>regRSM</code> with new parameter <code>nslaves</code>.
If you don't want to use parallel computations any more remember to close MPI framework by calling <code>mpi.close.Rslaves()</code>.
</p>
<p>Installing MPI for multiple machines:
</p>
<p>In the following we give some guidelines how to install and configure MPI framework on multiple machines.
MPI configuration on multiple machines is straightforward. Each machine must be connected to the main machine (master). While using <span class="pkg">Rmpi</span> package we must remember that it works a little bit different than typical C MPI application. Usually master process transfers through MPI the whole application and replicates it on available slots (slaves). <span class="pkg">Rmpi</span> uses existing R installation, so on each machine all required packages must be installed. Only R source code and data are transferred. 
We present the required steps under Ubuntu operating system (we use Ubuntu 12.04 LTS version).
To install Open MPI on Ubuntu type:
</p>
<p><code>
sudo apt-get install libopenmpi-dev openmpi-bin
</code>
</p>
<p>On Ubuntu with installed Open MPI and R one may just run R and type: 
</p>
<p><code>
install.packages("Rmpi")
</code>
</p>
<p>Consider a case when we have several (2 or more) machines with Ubuntu 12.04 LTS operating system, R 3.0, <span class="pkg">Rmpi</span> and <span class="pkg">regRSM</span> installed and all machines are connected to the same network. Moreover let's assume we have one network card which is mapped to <code>eth0</code>. With command <code>ifconfig</code> we can check what ip addresses our machines have. For simplicity, to avoid changing the configuration, we assign a static address to each machine.
In our network we have 4 PCs with 4 core processor each. We give them the following names and ip addresses: 
</p>
<p><code>
node09: 10.200.1.159
</code>
</p>
<p><code>
node08: 10.200.1.158
</code>
</p>
<p><code>
node07: 10.200.1.157
</code>
</p>
<p><code>
node06: 10.200.1.156
</code>
</p>
<p>We create text file with ip and number of slots in each line. Slot is an instance of our application working in a slave mode. For example if we have a line <code>127.0.0.1 slots=4</code> then on our machine (localhost) MPI should run up to 4 slave processes. If we request more slaves than slots then  there will be oversubscription of the node and the performance can drop. We can limit the number of slots to 4 by changing the line to <code>127.0.0.1 slots=4 max_slots=4</code>. In this case request on more than 4 processes on this node will result in an error. While setting hard limits one should remember that the total number of processes created by <span class="pkg">Rmpi</span> package is equal to the number of slaves plus one (master process). For example if we want each computer to run 4 parallel tasks then we assign 4 slots to each machine. 
Example of our hostfile <code>myhosts</code>:
</p>
<p><code>
10.200.1.159 slots=4
</code>
</p>
<p><code>
10.200.1.157 slots=4
</code>
</p>
<p><code>
10.200.1.158 slots=4
</code>
</p>
<p><code>
10.200.1.156 slots=4
</code>
</p>
<p>We run MPI application by executing:
</p>
<p><code>
mpiexec -n &lt;no_of_program_copies&gt; -hosts &lt;file_with_hosts&gt; &lt;program_name&gt;
</code>
</p>
<p>Parameter <code>-n</code> can be misleading when working with <code>Rmpi</code> package. We want to start one R instance on which we run our experiment. Thus this value should be set to 1. 
To give <span class="pkg">Rmpi</span> our hostfile just run command: 
</p>
<p><code>mpiexec -n 1 -hostfile myhosts R --no-save</code>
</p>
<p>which means we run one <code>Rscript</code> process with given hostfile for MPI configuration. In R terminal we type:
</p>
<p><code>
&gt; library(Rmpi)
</code>
</p>
<p><code>
library(Rmpi)
</code>
</p>
<p><code>
&gt; mpi.spawn.Rslaves()
</code>
</p>
<p><code>
mpi.spawn.Rslaves()
</code>
</p>
<p><code>
    16 slaves are spawned successfully. 0 failed.
</code>
</p>
<p><code>    
master  (rank 0 , comm 1) of size 17 is running on: node09
</code>
</p>
<p><code>
slave1  (rank 1 , comm 1) of size 17 is running on: node09
</code>
</p>
<p><code>
slave2  (rank 2 , comm 1) of size 17 is running on: node09
</code>
</p>
<p><code>
slave3  (rank 3 , comm 1) of size 17 is running on: node09
</code>
</p>
<p><code>
... ... ...
</code>
</p>
<p><code>
slave15 (rank 15, comm 1) of size 17 is running on: node06
</code>
</p>
<p><code>
slave16 (rank 16, comm 1) of size 17 is running on: node09
</code>
</p>
<p>The above lines indicate that all MPI processes are launched successfully. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>scores</code></td>
<td>
<p>RSM final scores.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The final model chosen from the list given by the ordering of variables according to the RSM scores.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Computational time.</p>
</td></tr>
<tr><td><code>data_transfer</code></td>
<td>
<p>Data transfer time.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Coefficients in the selected linear model.</p>
</td></tr>
<tr><td><code>input_data</code></td>
<td>
<p>Input data <code>x</code> and <code>y</code>. These objects are stored only if <code>store_data=TRUE</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>List constining information about input parameters.</p>
</td></tr>
<tr><td><code>informationCriterion</code></td>
<td>
<p>Values of Generalized Information Criterion calculated for all models from the nested list given by the ordering.</p>
</td></tr>
<tr><td><code>predError</code></td>
<td>
<p>Prediction errors on validation set calculated for all models from the nested list given by the ordering.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>References</h3>

<p>Mielniczuk, J., Teisseyre, P., 
<em>Using random subspace method for prediction and variable importance assessment in linear regression, Computational Statistics and Data Analysis, Vol. 71, 725-742, 2014.</em>
</p>


<h3>See Also</h3>

<p><code>predict</code>, <code>plot</code>, <code>ImpPlot</code>, <code>validate</code>, <code>roc</code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = 500
n = 50
beta1 = numeric(p)
beta1[c(1,5,10)] = c(1,1,1)  
x = matrix(0,ncol=p,nrow=n)
xtest = matrix(0,ncol=p,nrow=n)
for(j in 1:p){ 
    x[,j] = rnorm(n,0,1)
    xtest[,j] = rnorm(n,0,1)    
}
y = x %*% beta1 + rnorm(n)
p1 = regRSM(x,y)

data1 = data.frame(y,x)
p2 = regRSM(y~.,data=data1)
</code></pre>

<hr>
<h2 id='roc.regRSM'>
ROC curve and AUC parameter.
</h2><span id='topic+roc.regRSM'></span><span id='topic+roc'></span>

<h3>Description</h3>

<p>This function produces ROC curve and computes AUC parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
roc(object, truemodel, plotit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.regRSM_+3A_object">object</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
<tr><td><code id="roc.regRSM_+3A_truemodel">truemodel</code></td>
<td>

<p>User specified vector containing indexes of all significant variables. 
</p>
</td></tr>
<tr><td><code id="roc.regRSM_+3A_plotit">plotit</code></td>
<td>

<p>Logical argument indicating whether a plot should be produced. If the value is <code>FALSE</code>, then the value of parameter AUC is returned. 
Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="roc.regRSM_+3A_...">...</code></td>
<td>

<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">i_1,\ldots,i_p</code> be the ordering of variables (e.g. given by the RSM final scores), <code class="reqn">p</code> is the number of all variables.
ROC curve for ordering is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\textrm{ROC}(s):=(FPR(s),TPR(s)),\quad s\in\{1,\ldots,p\},</code>
</p>

<p>where  
</p>
<p style="text-align: center;"><code class="reqn">FPR(s):=\frac{|SelectedModel(s)\setminus truemodel|}{|truemodel^{C}|},</code>
</p>

<p style="text-align: center;"><code class="reqn">TPR(s):=\frac{|SelectedModel(s)\cap truemodel|}{|truemodel|},</code>
</p>

<p style="text-align: center;"><code class="reqn">SelectedModel(s):=\{i_1,\ldots,i_s\},</code>
</p>

<p><code class="reqn">|A|</code> denotes cardinality of <code class="reqn">A</code> and <code class="reqn">A^C</code> denotes a complement of <code class="reqn">A</code>.
</p>
<p>This function is useful for the evaluation of the ranking produced by the RSM procedure,
when the set of significant variables is known (e.g. in the simulation experiments on artificial datasets). When AUC is equal one it means that all significant
variables, suplied by the user in argment <code>truemodel</code>, are placed on the top of the ranking list.
</p>


<h3>Value</h3>

<p>ROC curve is produced and the value of parameter AUC is returned.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=100
n=100
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)
x = matrix(0,ncol=p,nrow=n)
for(j in 1:p){
    x[,j]=rnorm(n,0,1)
}
y = x %*% beta1 + rnorm(n)
p1 = regRSM(x,y,store_data=TRUE)
true = c(1,5,10)
roc(p1,true,plotit=TRUE)
</code></pre>

<hr>
<h2 id='summary.regRSM'>
Print 'regRSM' object.
</h2><span id='topic+summary.regRSM'></span>

<h3>Description</h3>

<p>This function print the summary of the RSM procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.regRSM_+3A_object">object</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
<tr><td><code id="summary.regRSM_+3A_...">...</code></td>
<td>

<p>Additional arguments not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints out information about the selection method, screening, initial weights, version (sequential or parallel),
size of the random subpace, number of simulations.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=100
n=100
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)
x = matrix(0,ncol=p,nrow=n)
xval = matrix(0,ncol=p,nrow=n)
xtest = matrix(0,ncol=p,nrow=n)
for(j in 1:p){
    x[,j]=rnorm(n,0,1)
}
y = x %*% beta1 + rnorm(n)

p1=regRSM(x,y)
summary(p1)
</code></pre>

<hr>
<h2 id='validate.regRSM'>
Selects the new final model from existing 'regRSM' object.
</h2><span id='topic+validate.regRSM'></span><span id='topic+validate'></span>

<h3>Description</h3>

<p>This function selects the new final model based on the previously computed final scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regRSM'
validate(object, yval, xval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.regRSM_+3A_object">object</code></td>
<td>

<p>Fitted 'regRSM' model object.
</p>
</td></tr>
<tr><td><code id="validate.regRSM_+3A_yval">yval</code></td>
<td>

<p>Quantitative response vector from validation set.
</p>
</td></tr>
<tr><td><code id="validate.regRSM_+3A_xval">xval</code></td>
<td>

<p>Input matrix from validation set.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use the function, the argument store_data in the 'regRSM' object must be TRUE.
The function uses final scores from 'regRSM' object to create a ranking of variables. Then the final model which
minimizes the prediction error on specified validation set is chosen.
Object of class 'regRSM' is returned. The final scores in the original 'regRSM' object and in the new one coincide. However the
final models can be different. 
</p>


<h3>Value</h3>

<p>Object of class 'regRSM' is returned.
</p>


<h3>Author(s)</h3>

<p>Pawel Teisseyre, Robert A. Klopotek.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=100
n=100
beta1 = numeric(p)
beta1[c(1,5,10)]=c(1,1,1)  
x = matrix(0,ncol=p,nrow=n)
xval = matrix(0,ncol=p,nrow=n)
for(j in 1:p){ 
    x[,j]=rnorm(n,0,1)
    xval[,j]=rnorm(n,0,1)  
}
y = x %*% beta1 + rnorm(n)
yval = xval %*% beta1 + rnorm(n)

p1 = regRSM(x,y,store_data=TRUE)
p2 = validate(p1,yval,xval)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
