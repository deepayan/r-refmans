<!DOCTYPE html><html><head><title>Help for package BayesLN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesLN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add'><p>Addend SMNG density function</p></a></li>
<li><a href='#add_MGF'><p>Addend SMNG moment generating function</p></a></li>
<li><a href='#EPA09'><p>Chrysene concentration data</p></a></li>
<li><a href='#fatigue'><p>Low cycle fatigue data</p></a></li>
<li><a href='#functional_delta'><p>Target functional to minimize with respect to delta</p></a></li>
<li><a href='#functional_gamma'><p>Target functional to minimize with respect to gamma</p></a></li>
<li><a href='#g_V'><p>Integral of the target functional to minimize</p></a></li>
<li><a href='#g_V_vec'><p>Vectorization of the function <code>g_V</code></p></a></li>
<li><a href='#GH_MGF'><p>GH Moment Generating Function</p></a></li>
<li><a href='#inf_sum'><p>Summation SMNG density function</p></a></li>
<li><a href='#inf_sum_MGF'><p>Summation SMNG moment generating function</p></a></li>
<li><a href='#integral'><p>Integrand SMNG density function</p></a></li>
<li><a href='#integral_MGF'><p>Integrand SMNG moment generating function</p></a></li>
<li><a href='#laminators'><p>Laminators</p></a></li>
<li><a href='#LN_hier_existence'><p>Numerical evaluation of the log-normal conditioned means posterior moments</p></a></li>
<li><a href='#LN_hierarchical'><p>Bayesian estimation of a log - normal hierarchical model</p></a></li>
<li><a href='#LN_Mean'><p>Bayesian Estimate of the Log-normal Mean</p></a></li>
<li><a href='#LN_MeanReg'><p>Bayesian Estimate of the conditional Log-normal Mean</p></a></li>
<li><a href='#LN_Quant'><p>Bayesian estimate of the log-normal quantiles</p></a></li>
<li><a href='#LN_QuantReg'><p>Bayesian estimate of the log-normal conditioned quantiles</p></a></li>
<li><a href='#momentRecursion'><p>Recursion used for SMNG moments</p></a></li>
<li><a href='#NCBC'><p>Naval Construction Battalion Center data</p></a></li>
<li><a href='#RatioBesselK'><p>Ratio of Bessel K functions</p></a></li>
<li><a href='#ReadingTime'><p>Reading Times data</p></a></li>
<li><a href='#SMNGdistribution'><p>SMNG and logSMNG Distributions</p></a></li>
<li><a href='#SMNGmoments'><p>SMNG Moments and Moment Generating Function</p></a></li>
<li><a href='#SMNGZmoment'><p>SMNG moments centered in <code>mu</code></p></a></li>
<li><a href='#zerfun'><p>Function for finding SMNG quantiles</p></a></li>
<li><a href='#zerfun_log'><p>Function for finding logSMNG quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Inference for Log-Normal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference under log-normality assumption must be performed very carefully. In fact, under the common priors for the variance, useful quantities in the original data scale (like mean and quantiles) do not have posterior moments that are finite (Fabrizi et al. 2012 &lt;<a href="https://doi.org/10.1214%2F12-BA733">doi:10.1214/12-BA733</a>&gt;). This package allows to easily carry out a proper Bayesian inferential procedure by fixing a suitable distribution (the generalized inverse Gaussian) as prior for the variance. Functions to estimate several kind of means (unconditional, conditional and conditional under a mixed model) and quantiles (unconditional and conditional) are provided. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>optimx, GeneralizedHyperbolic, gsl, coda, Rcpp (&ge; 0.12.17),
MASS, lme4, data.table, Matrix, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 14:55:50 UTC; aldo.gardini2</td>
</tr>
<tr>
<td>Author:</td>
<td>Aldo Gardini <a href="https://orcid.org/0000-0002-2164-5815"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Enrico Fabrizi <a href="https://orcid.org/0000-0003-2504-7043"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Carlo Trivisano <a href="https://orcid.org/0000-0002-5991-4902"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aldo Gardini &lt;aldo.gardini2@unibo.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 15:20:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='add'>Addend SMNG density function</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>Function that implements the j-th addend of the SMNG density function expressed as an infinite sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(j, delta_bar, r, lambda, delta, gamma, beta, mu)
</code></pre>

<hr>
<h2 id='add_MGF'>Addend SMNG moment generating function</h2><span id='topic+add_MGF'></span>

<h3>Description</h3>

<p>Function that implements the j-th addend of the SMNG moment generating function expressed as an infinite sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_MGF(j, r = r, lambda, delta, gamma, beta)
</code></pre>

<hr>
<h2 id='EPA09'>Chrysene concentration data</h2><span id='topic+EPA09'></span>

<h3>Description</h3>

<p>Vector of 8 observations of chrysene concentration (ppb) found in water samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPA09
</code></pre>


<h3>Format</h3>

<p>Numeric vector.
</p>


<h3>Source</h3>

<p>USEPA. <em>Statistical analysis of groundwater monitoring data at rcra facilities: Unifed guidance.</em>
Technical report, Office of Resource Conservation and Recovery, Program Implementation
and Information Division, U.S. Environmental Protection Agency, Washington,
D.C. (2009).
</p>

<hr>
<h2 id='fatigue'>Low cycle fatigue data</h2><span id='topic+fatigue'></span>

<h3>Description</h3>

<p>Data frame of 22 observations in 2 variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatigue
</code></pre>


<h3>Format</h3>

<p>Dataframe with variables:
</p>
<p><code>stress</code>: stress factor.
</p>
<p><code>cycle</code>: number of test cycles.
</p>


<h3>Source</h3>

<p>Upadhyay, S. K., and M. Peshwani. <em>Posterior analysis of lognormal regression models using
the Gibbs sampler.</em> Statistical Papers 49.1 (2008): 59-85.
</p>

<hr>
<h2 id='functional_delta'>Target functional to minimize with respect to delta</h2><span id='topic+functional_delta'></span>

<h3>Description</h3>

<p>Function that evaluate the target functional to minimize allowing
for a different value of the parameter <code>delta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional_delta(x, n, quant, gamma, sigma2, lambda, nreg = 1, rel_tol = 1e-04)
</code></pre>

<hr>
<h2 id='functional_gamma'>Target functional to minimize with respect to gamma</h2><span id='topic+functional_gamma'></span>

<h3>Description</h3>

<p>Function that evaluate the target functional to minimize
allowing for a different value of the parameter <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional_gamma(x, n, quant, delta, sigma2, lambda, nreg = 1, rel_tol = 1e-04)
</code></pre>

<hr>
<h2 id='g_V'>Integral of the target functional to minimize</h2><span id='topic+g_V'></span>

<h3>Description</h3>

<p>Function that implements the integrand of the target functional to minimize in order to
obtain hyperparameters that produces optimal estimates in the frequentist context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_V(Y, lambda, delta, gamma, quant, sigma2, n, nreg, rel_tol = 1e-04)
</code></pre>


<h3>Details</h3>

<p>It is implemented exploiting the infinite sum representation of the estimator.
</p>

<hr>
<h2 id='g_V_vec'>Vectorization of the function <code><a href="#topic+g_V">g_V</a></code></h2><span id='topic+g_V_vec'></span>

<h3>Description</h3>

<p>It allows to use the integrand of the target functional to
minimize as the argument of the function <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_V_vec(
  Y,
  lambda,
  delta,
  gamma,
  quant,
  sigma2,
  n,
  nreg = nreg,
  rel_tol = 1e-04
)
</code></pre>

<hr>
<h2 id='GH_MGF'>GH Moment Generating Function</h2><span id='topic+GH_MGF'></span>

<h3>Description</h3>

<p>Function that implements the moment generating function of the Generalized Hyperbolyc (GH) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GH_MGF(r, mu = 0, delta, alpha, lambda, beta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GH_MGF_+3A_r">r</code></td>
<td>
<p>Coefficient of the MGF. Can be viewd also as the order of the log-GH moments.</p>
</td></tr>
<tr><td><code id="GH_MGF_+3A_mu">mu</code></td>
<td>
<p>Location parameter, default set to 0.</p>
</td></tr>
<tr><td><code id="GH_MGF_+3A_delta">delta</code></td>
<td>
<p>Concentration parameter, must be positive.</p>
</td></tr>
<tr><td><code id="GH_MGF_+3A_alpha">alpha</code></td>
<td>
<p>Tail parameter, must be positive and greater than the modulus of <code>beta</code>.</p>
</td></tr>
<tr><td><code id="GH_MGF_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="GH_MGF_+3A_beta">beta</code></td>
<td>
<p>Skewness parameter, default set to 0 (symmetric case).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to evaluate the moment generating function of the GH distribution in the point <code>r</code>.
It is defined only for points that are lower than the value of <code class="reqn">\gamma</code>, that is defined as:
<code class="reqn">\gamma^2=\alpha^2-\beta^2.</code>
For integer values of <code>r</code>, it could also be considered as the
<em>r</em>-th raw moment of the log-GH distribution.
</p>

<hr>
<h2 id='inf_sum'>Summation SMNG density function</h2><span id='topic+inf_sum'></span>

<h3>Description</h3>

<p>Function that adds terms to the infinite sum of the SMNG density function until the relative
error reaches the requested threshold fixed by <code>rel_tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf_sum(x, lambda, delta, gamma, beta, mu, rel_tol)
</code></pre>

<hr>
<h2 id='inf_sum_MGF'>Summation SMNG moment generating function</h2><span id='topic+inf_sum_MGF'></span>

<h3>Description</h3>

<p>Function that adds terms to the infinite sum of the SMNG moment generating function until the relative
error reaches the requested threshold fixed by <code>rel_tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf_sum_MGF(r, lambda, delta, gamma, beta, rel_tol)
</code></pre>

<hr>
<h2 id='integral'>Integrand SMNG density function</h2><span id='topic+integral'></span>

<h3>Description</h3>

<p>Function that implements the integral part that appears in the SMNG density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral(t, a, b, c, l)
</code></pre>

<hr>
<h2 id='integral_MGF'>Integrand SMNG moment generating function</h2><span id='topic+integral_MGF'></span>

<h3>Description</h3>

<p>Function that implements the integral part that appears in the SMNG moment generating function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral_MGF(t, a, b, c, l)
</code></pre>

<hr>
<h2 id='laminators'>Laminators</h2><span id='topic+laminators'></span>

<h3>Description</h3>

<p>Data frame of 39 observations in 2 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laminators
</code></pre>


<h3>Format</h3>

<p>Dataframe with variables:
</p>
<p><code>Worker</code>: label of the measured worker.
</p>
<p><code>log_Y</code>: logarithm of the measured Styrene concentration.
</p>


<h3>Source</h3>

<p>R. H. Lyles, L. L. Kupper, and S. M. Rappaport. <em>Assessing regulatory compliance of occupational exposures via the balanced one-way random effects ANOVA model</em> Journal of Agricultural, Biological, and Environmental Statistics (1997).
</p>

<hr>
<h2 id='LN_hier_existence'>Numerical evaluation of the log-normal conditioned means posterior moments</h2><span id='topic+LN_hier_existence'></span>

<h3>Description</h3>

<p>Function that evaluates the existence conditions for moments of useful quantities in the original data scale
when a log-normal linear mixed model is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_hier_existence(X, Z, Xtilde, order_moment = 2, s = 1, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_hier_existence_+3A_x">X</code></td>
<td>
<p>Design matrix for fixed effects.</p>
</td></tr>
<tr><td><code id="LN_hier_existence_+3A_z">Z</code></td>
<td>
<p>Design matrix for random effects.</p>
</td></tr>
<tr><td><code id="LN_hier_existence_+3A_xtilde">Xtilde</code></td>
<td>
<p>Covariate patterns used for the leverage computation.</p>
</td></tr>
<tr><td><code id="LN_hier_existence_+3A_order_moment">order_moment</code></td>
<td>
<p>Order of the posterior moments required to be finite.</p>
</td></tr>
<tr><td><code id="LN_hier_existence_+3A_s">s</code></td>
<td>
<p>Number of variances of the random effects.</p>
</td></tr>
<tr><td><code id="LN_hier_existence_+3A_m">m</code></td>
<td>
<p>Vector of size <code>s</code> (if s&gt;1) that indicates the dimensions of the random effect vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the existence conditions for the moments up to order fixed by <code>order_moment</code> of the log-normal
linear mixed model specified by the design matrices <code>X</code> and <code>Z</code>. It considers the prediction based on multiple
covariate patterns stored in the rows of the <code>Xtilde</code> matrix.
</p>


<h3>Value</h3>

<p>Both the values of the factors determining the existence condition and the values of the gamma parameters for the different
variance components are provided.
</p>

<hr>
<h2 id='LN_hierarchical'>Bayesian estimation of a log - normal hierarchical model</h2><span id='topic+LN_hierarchical'></span>

<h3>Description</h3>

<p>Function that estimates a log-normal linear mixed model with GIG priors on the variance components,
in order to assure the existence of the posterior moments of key functionals in the original data scale like conditioned means
or the posterior predictive distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_hierarchical(
  formula_lme,
  data_lme,
  y_transf = TRUE,
  functional = c("Subject", "Marginal", "PostPredictive"),
  data_pred = NULL,
  order_moment = 2,
  nsamp = 10000,
  par_tau = NULL,
  par_sigma = NULL,
  var_pri_beta = 10000,
  inits = list(NULL),
  verbose = TRUE,
  burnin = 0.1 * nsamp,
  n_thin = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_hierarchical_+3A_formula_lme">formula_lme</code></td>
<td>
<p>A two-sided linear formula object describing
both the fixed-effects and random-effects part of the model is required. For details see <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_data_lme">data_lme</code></td>
<td>
<p>Optional data frame containing the variables named in <code>formula_lme</code>.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_y_transf">y_transf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the response variable is assumed already as log-transformed.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_functional">functional</code></td>
<td>
<p>Functionals of interest: <code>"Subject"</code> for subject-specific conditional mean,
<code>"Marginal"</code> for the overall expectation and <code>"PostPredictive"</code> for the posterior predictive distribution.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_data_pred">data_pred</code></td>
<td>
<p>Data frame with the covariate patterns of interest for prediction. All the covariates present in the <code>data_lme</code> object must be included. If <code>NULL</code> the design matrix of the model is used.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_order_moment">order_moment</code></td>
<td>
<p>Order of the posterior moments that are required to be finite.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_nsamp">nsamp</code></td>
<td>
<p>Number of Monte Carlo iterations.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_par_tau">par_tau</code></td>
<td>
<p>List of vectors defining the triplets of hyperparaemters for each random effect variance (as many vectors as the number of specified random effects variances).</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_par_sigma">par_sigma</code></td>
<td>
<p>Vector containing the tiplet of hyperparameters for the prior of the data variance.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_var_pri_beta">var_pri_beta</code></td>
<td>
<p>Prior variance for the model coefficients.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_inits">inits</code></td>
<td>
<p>List of object for initializing the chains. Objects with compatible dimensions must be named with <code>beta</code>, <code>sigma2</code> and <code>tau2</code>.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the messages from the Gibbs sampler are not shown.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to consider as burn-in.</p>
</td></tr>
<tr><td><code id="LN_hierarchical_+3A_n_thin">n_thin</code></td>
<td>
<p>Number of thinning observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to estimate a log-normal linear mixed model through a Gibbs sampler. The model equation is specified as in <code><a href="lme4.html#topic+lmer">lmer</a></code> model and the target functionals to estimate need to be declared.
A weakly informative prior setting is automatically assumed, always keeping the finiteness of the posterior moments of the target functionals.
</p>


<h3>Value</h3>

<p>The output list provided is composed of three parts. The object <code>$par_prior</code> contains the parameters fixed for the variance components priors. The object <code>$samples</code> contains the posterior samples for all the paramters.
They are returned as a <code><a href="coda.html#topic+mcmc">mcmc</a></code> object and they can be analysed trough the functions contained in the
<code>coda</code> package in order to check for the convergence of the algorithm. Finally, in <code>$summaries</code> an overview of the posteriors of the model parameters and of the target functionals is provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesLN)
# Load the dataset included in the package
data("laminators")
data_pred_new &lt;- data.frame(Worker = unique(laminators$Worker))
Mod_est&lt;-LN_hierarchical(formula_lme = log_Y~(1|Worker),
                         data_lme = laminators,
                         data_pred = data_pred_new,
                         functional = c("Subject","Marginal"),
                         order_moment = 2, nsamp = 50000, burnin = 10000)


</code></pre>

<hr>
<h2 id='LN_Mean'>Bayesian Estimate of the Log-normal Mean</h2><span id='topic+LN_Mean'></span>

<h3>Description</h3>

<p>This function produces a Bayesian estimate of the log-normal mean, assuming a GIG prior for the variance and an
improper flat prior for the mean in the log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_Mean(
  x,
  method = "weak_inf",
  x_transf = TRUE,
  CI = TRUE,
  alpha_CI = 0.05,
  type_CI = "two-sided",
  nrep = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_Mean_+3A_x">x</code></td>
<td>
<p>Vector containing the sample.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_method">method</code></td>
<td>
<p>String that indicates the prior setting to adopt. Choosing <code>"weak_inf"</code> a weakly informative prior setting is adopted, whereas selecting
<code>"optimal"</code> the hyperparameters are aimed at minimizing the frequentist MSE.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_x_transf">x_transf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code>x</code> vector is assumed already log-transformed.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_ci">CI</code></td>
<td>
<p>Logical. With the default choice <code>TRUE</code>, the posterior credibility interval is computed.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_alpha_ci">alpha_CI</code></td>
<td>
<p>Level of alpha that determines the credibility (1-<code>alpha_CI</code>) of the posterior interval.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_type_ci">type_CI</code></td>
<td>
<p>String that indicates the type of interval to compute: <code>"two-sided"</code> (default),
<code>"UCL"</code> (i.e. Upper Credible Limit) for upper one-sided intervals or <code>"LCL"</code> (i.e. Lower
Credible Limit) for lower one-sided intervals.</p>
</td></tr>
<tr><td><code id="LN_Mean_+3A_nrep">nrep</code></td>
<td>
<p>Number of simulations for the computation of the credible intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizing the posterior mean of the log-normal expectation might be delicate since several
common priors used for the variance do not produces posteriors with finite moments. The proposal by Fabrizi and Trivisano (2012) of adopting a generalized inverse Gaussian (GIG)
prior for the variance in the log scale <code class="reqn">\sigma^2</code> has been implemented. Moreover, they discussed how to specify the hyperparameters according to two different aims.
</p>
<p>Firstly, a weakly informative
prior allowed to produce posterior credible intervals with good frequentist properties, whereas a prior aimed at minimizing the point estimator
MSE was proposed too. The choice between the two priors can be made through the argument <code>method</code>.
</p>
<p>The point estimates are exact values, whereas the credible intervals are provided through simulations from the posterior distribution.
</p>


<h3>Value</h3>

<p>The function returns a list which includes the prior and posterior parameters, the point estimate of the log-normal mean that consists in the mean of the posterior
distribution of the functional <code class="reqn">\exp\{\mu+\sigma^2/2\}</code> and the posterior variance.
</p>


<h3>Source</h3>

<p>Fabrizi, E., &amp; Trivisano, C. <em>Bayesian estimation of log-normal means with finite quadratic expected loss</em>. Bayesian Analysis, 7(4), 975-996. (2012).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data("NCBC")
# Optimal point estimator
LN_Mean(x = NCBC$al, x_transf = FALSE, method = "optimal", CI = FALSE)
# Weakly informative prior and interval estimation
LN_Mean(x = NCBC$al, x_transf = FALSE, type_CI = "UCL")

</code></pre>

<hr>
<h2 id='LN_MeanReg'>Bayesian Estimate of the conditional Log-normal Mean</h2><span id='topic+LN_MeanReg'></span>

<h3>Description</h3>

<p>This function produces a bayesian estimate of the conditional log-normal mean assuming a GIG prior for the variance and an
improper prior for the regression coefficients of the linear regression in the log scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_MeanReg(
  y,
  X,
  Xtilde,
  method = "weak_inf",
  y_transf = TRUE,
  h = NULL,
  CI = TRUE,
  alpha_CI = 0.05,
  type_CI = "two-sided",
  nrep = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_MeanReg_+3A_y">y</code></td>
<td>
<p>Vector of observations of the response variable.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_x">X</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_xtilde">Xtilde</code></td>
<td>
<p>Matrix of covariate patterns for which an estimate is required.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_method">method</code></td>
<td>
<p>String that indicates the prior setting to adopt. Choosing <code>"weak_inf"</code> a weakly
informative prior setting is adopted, whereas selecting
<code>"optimal"</code> the hyperparameters are aimed at minimizing the frequentist MSE.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_y_transf">y_transf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code>y</code> vector is already assumed as log-transformed.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_h">h</code></td>
<td>
<p>Leverage. With the default option <code>NULL</code>, the average leverage is used.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_ci">CI</code></td>
<td>
<p>Logical. With the default choice <code>TRUE</code>, the posterior credibility interval is computed.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_alpha_ci">alpha_CI</code></td>
<td>
<p>Level of alpha that determines the credibility (1-<code>alpha_CI</code>) of the posterior interval.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_type_ci">type_CI</code></td>
<td>
<p>String that indicates the type of interval to compute: <code>"two-sided"</code> (default),
<code>"UCL"</code> (i.e. Upper Credible Limit) for upper one-sided intervals  or <code>"LCL"</code> (i.e. Lower
Credible Limit) for lower one-sided intervals.</p>
</td></tr>
<tr><td><code id="LN_MeanReg_+3A_nrep">nrep</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function the same procedure as <a href="#topic+LN_Mean">LN_Mean</a> is implemented allowing for the inclusion of covariates.
Bayesian point and interval estimates for the response variabile in the original scale are provided considering the model:
<code class="reqn">log(y_i)=X\beta</code>.
</p>


<h3>Value</h3>

<p>The function returns a list including the prior and posterior parameters, the point estimate of the log-normal mean conditioned with respect to the covariate
points included in <code>Xtilde</code>. It consists of the mean of the posterior
distribution for the functional <code class="reqn">\exp\{\tilde{x}_i^T\beta+\sigma^2/2\}</code> and the posterior variance.
</p>


<h3>Source</h3>

<p>Fabrizi, E., &amp; Trivisano, C. <em>Bayesian Conditional Mean Estimation in Log-Normal Linear Regression Models with Finite
Quadratic Expected Loss.</em> Scandinavian Journal of Statistics, 43(4), 1064-1077. (2016).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesLN)
data("fatigue")

# Design matrices
Xtot &lt;- cbind(1, log(fatigue$stress), log(fatigue$stress)^2)
X &lt;- Xtot[-c(1,13,22),]
y &lt;- fatigue$cycle[-c(1,13,22)]
Xtilde &lt;- Xtot[c(1,13,22),]
#Estimation
LN_MeanReg(y = y,
           X = X, Xtilde = Xtilde,
           method = "weak_inf", y_transf = FALSE)


</code></pre>

<hr>
<h2 id='LN_Quant'>Bayesian estimate of the log-normal quantiles</h2><span id='topic+LN_Quant'></span>

<h3>Description</h3>

<p>This function produces an estimate for the log-normal distribution quantile of fixed level <code>quant</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_Quant(
  x,
  quant,
  method = "weak_inf",
  x_transf = TRUE,
  guess_s2 = NULL,
  CI = TRUE,
  alpha_CI = 0.05,
  type_CI = "two-sided",
  method_CI = "exact",
  rel_tol_CI = 1e-05,
  nrep_CI = 1e+06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_Quant_+3A_x">x</code></td>
<td>
<p>Vector of data used to estimate the quantile.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_quant">quant</code></td>
<td>
<p>Number between 0 and 1 that indicates the quantile of interest.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_method">method</code></td>
<td>
<p>String that indicates the prior setting to adopt. Choosing <code>"weak_inf"</code>
a weakly informative prior setting is adopted, whereas selecting
<code>"optimal"</code> the hyperparameters are fixed trough a numerical optimization algorithm
aimed at minimizing the frequentist MSE.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_x_transf">x_transf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code>x</code> vector is assumed already log-transformed.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_guess_s2">guess_s2</code></td>
<td>
<p>Specification of a guess for the variance if available. If not, the sample estimate is used.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_ci">CI</code></td>
<td>
<p>Logical. With the default choice <code>TRUE</code>, the posterior credibility interval is computed.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_alpha_ci">alpha_CI</code></td>
<td>
<p>Level of alpha that determines the credibility (1-<code>alpha_CI</code>) of the posterior interval.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_type_ci">type_CI</code></td>
<td>
<p>String that indicates the type of interval to compute: <code>"two-sided"</code> (default),
<code>"UCL"</code> (i.e. Upper Credible Limit) for upper one-sided intervals  or <code>"LCL"</code> (i.e. Lower
Credible Limit) for lower one-sided intervals.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_method_ci">method_CI</code></td>
<td>
<p>String that indicates if the limits should be computed through the logSMNG
quantile function <code><a href="#topic+qlSMNG">qlSMNG</a></code> (option <code>"exact"</code>, default), or by randomly generating a sample
(<code>"simulation"</code>) using the function <code><a href="#topic+rlSMNG">rlSMNG</a></code>.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_rel_tol_ci">rel_tol_CI</code></td>
<td>
<p>Level of relative tolerance required for the <code>integrate</code> procedure or for the infinite sum.
Default set to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="LN_Quant_+3A_nrep_ci">nrep_CI</code></td>
<td>
<p>Number of simulations in case of <code>method="simulation"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to carry out Bayesian inference for the unconditional quantiles of a sample that is assumed log-normally distributed.
</p>
<p>A generalized inverse Gaussian prior is assumed for the variance in the log scale <code class="reqn">\sigma^2</code>, whereas a
flat improper prior is assumed for the mean in the log scale <code class="reqn">\xi</code>.
</p>
<p>Two alternative hyperparamters setting are implemented (choice controlled by the argument <code>method</code>): a weakly
informative proposal and an optimal one.
</p>


<h3>Value</h3>

<p>The function returns the prior parameters and their posterior values, summary statistics of the log-scale parameters and the estimate of the specified quantile:
the posterior mean and variance are provided by default. Moreover, the user can control the computation of posterior intervals.
</p>


<h3>Source</h3>

<p>Gardini, A., C. Trivisano, and E. Fabrizi. <em>Bayesian inference for quantiles of the log-normal distribution.</em> Biometrical Journal (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesLN)
data("EPA09")
# The optimization algorithm might require time:
# LN_Quant(x = EPA09, x_transf = FALSE, quant = 0.95, method = "optimal", CI = FALSE)
LN_Quant(x = EPA09, x_transf = FALSE, quant = 0.95, method = "weak_inf",
        alpha_CI = 0.05, type_CI = "UCL", nrep_CI = 1e3) # increase nrep_CI

</code></pre>

<hr>
<h2 id='LN_QuantReg'>Bayesian estimate of the log-normal conditioned quantiles</h2><span id='topic+LN_QuantReg'></span>

<h3>Description</h3>

<p>This function produces a point estimate for the log-normal distribution quantile of fixed level <code>quant</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LN_QuantReg(
  y,
  X,
  Xtilde,
  quant,
  method = "weak_inf",
  guess_s2 = NULL,
  y_transf = TRUE,
  CI = TRUE,
  method_CI = "exact",
  alpha_CI = 0.05,
  type_CI = "two-sided",
  rel_tol_CI = 1e-05,
  nrep_CI = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LN_QuantReg_+3A_y">y</code></td>
<td>
<p>Vector of observations of the response variable.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_x">X</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_xtilde">Xtilde</code></td>
<td>
<p>Covariate patterns of the units to estimate.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_quant">quant</code></td>
<td>
<p>Number between 0 and 1 that indicates the quantile of interest.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_method">method</code></td>
<td>
<p>String that indicates the prior setting to adopt. Choosing <code>"weak_inf"</code>
a weakly informative prior setting is adopted, whereas selecting
<code>"optimal"</code> the hyperparameters are fixed trough a numerical optimization algorithm
aimed at minimizing the frequentist MSE.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_guess_s2">guess_s2</code></td>
<td>
<p>Specification of a guess for the variance if available. If not, the sample estimate is used.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_y_transf">y_transf</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <code>y</code> vector is assumed already log-transformed.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_ci">CI</code></td>
<td>
<p>Logical. With the default choice <code>TRUE</code>, the posterior credibility interval is computed.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_method_ci">method_CI</code></td>
<td>
<p>String that indicates if the limits should be computed through the logSMNG
quantile function <code><a href="#topic+qlSMNG">qlSMNG</a></code> (option <code>"exact"</code>, default), or by randomly generating
(<code>"simulation"</code>) using the function <code><a href="#topic+rlSMNG">rlSMNG</a></code>.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_alpha_ci">alpha_CI</code></td>
<td>
<p>Level of credibility of the posterior interval.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_type_ci">type_CI</code></td>
<td>
<p>String that indicates the type of interval to compute: <code>"two-sided"</code> (default),
<code>"UCL"</code> (i.e. Upper Credible Limit) for upper one-sided intervals  or <code>"LCL"</code> (i.e. Lower
Credible Limit) for lower one-sided intervals.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_rel_tol_ci">rel_tol_CI</code></td>
<td>
<p>Level of relative tolerance required for the <code>integrate</code> procedure or for the infinite sum.
Default set to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="LN_QuantReg_+3A_nrep_ci">nrep_CI</code></td>
<td>
<p>Number of simulations for the C.I. in case of <code>method="simulation"</code> and for the posterior of the coefficients vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to carry out Bayesian inference for the conditional quantiles of a sample that is assumed log-normally distributed.
The design matrix containing the covariate patterns of the sampled units is <code>X</code>, whereas <code>Xtilde</code>
contains the covariate patterns of the unit to predict.
</p>
<p>The classical log-normal linear mixed model is assumed and the quantiles are estimated as:
</p>
<p style="text-align: center;"><code class="reqn">\theta_p(x)=exp(x^T\beta+\Phi^{-1}(p))</code>
</p>
<p>.
</p>
<p>A generalized inverse Gaussian prior is assumed for the variance in the log scale <code class="reqn">\sigma^2</code>, whereas a
flat improper prior is assumed for the vector of coefficients <code class="reqn">\beta</code>.
</p>
<p>Two alternative hyperparamters setting are implemented (choice controlled by the argument <code>method</code>): a weakly
informative proposal and an optimal one.
</p>


<h3>Value</h3>

<p>The function returns the prior parameters and their posterior values, summary statistics of the parameters <code class="reqn">\beta</code> and <code class="reqn">\sigma^2</code>, and the estimate of the specified quantile:
the posterior mean and variance are provided by default. Moreover the user can control the computation of posterior intervals.
</p>
<p>#'@source
</p>
<p>Gardini, A., C. Trivisano, and E. Fabrizi. <em>Bayesian inference for quantiles of the log-normal distribution.</em> Biometrical Journal (2020).
</p>

<hr>
<h2 id='momentRecursion'>Recursion used for SMNG moments</h2><span id='topic+momentRecursion'></span>

<h3>Description</h3>

<p>Recursive forumla that allowas to obtain both the raw and the centered moments starting form the
moments centered with respect to <code>mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentRecursion(center, j, mu, d, g, l, beta)
</code></pre>

<hr>
<h2 id='NCBC'>Naval Construction Battalion Center data</h2><span id='topic+NCBC'></span>

<h3>Description</h3>

<p>Data frame of 17 observations in 2 variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCBC
</code></pre>


<h3>Format</h3>

<p>Dataframe with 2 variables:
</p>
<p><code>al</code>: aluminium concentration measures.
</p>
<p><code>mn</code>: manganese concentration measures.
</p>


<h3>Source</h3>

<p>Singh, Ashok K., Anita Singh, and Max Engelhardt. <em>The lognormal distribution
in environmental applications.</em> Technology Support Center Issue Paper. (1997).
</p>

<hr>
<h2 id='RatioBesselK'>Ratio of Bessel K functions</h2><span id='topic+RatioBesselK'></span>

<h3>Description</h3>

<p>Ratio of Bessel K functions with equal argument. The difference between the two orders is <code>nu_diff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RatioBesselK(x, nu, nu_diff)
</code></pre>

<hr>
<h2 id='ReadingTime'>Reading Times data</h2><span id='topic+ReadingTime'></span>

<h3>Description</h3>

<p>Data frame of 547 observations in 4 variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadingTime
</code></pre>


<h3>Format</h3>

<p>Dataframe with variables:
</p>
<p><code>subj</code>: label indicating the subject.
</p>
<p><code>item</code>: label indicating the item read.
</p>
<p><code>so</code>: variable assuming value 1 (object relative condition) and -1 (subject relative condition).
</p>
<p><code>log_rt</code>: logarithm of the reading time measured.
</p>


<h3>Source</h3>

<p>E. Gibson and H.-H. I. Wu. <em>Processing chinese relative clauses in context.</em> Language and Cognitive Processes, 28(1-2):125-155. (2008).
</p>

<hr>
<h2 id='SMNGdistribution'>SMNG and logSMNG Distributions</h2><span id='topic+SMNGdistribution'></span><span id='topic+dSMNG'></span><span id='topic+pSMNG'></span><span id='topic+qSMNG'></span><span id='topic+rSMNG'></span><span id='topic+dlSMNG'></span><span id='topic+plSMNG'></span><span id='topic+qlSMNG'></span><span id='topic+rlSMNG'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random generator for the SMNG distribution and the logSMNG.
It requires the specification of a five prameters vector: <code>mu</code>, <code>delta</code>, <code>gamma</code>, <code>lambda</code> and
<code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSMNG(
  x,
  mu = 0,
  delta,
  gamma,
  lambda,
  beta = 0,
  inf_sum = FALSE,
  rel_tol = 1e-05
)

pSMNG(q, mu, delta, gamma, lambda, beta, rel_tol = 1e-05)

qSMNG(p, mu, delta, gamma, lambda, beta, rel_tol = 1e-05)

rSMNG(n, mu, delta, gamma, lambda, beta)

dlSMNG(x, mu = 0, delta, gamma, lambda, beta, inf_sum = FALSE, rel_tol = 1e-05)

plSMNG(q, mu, delta, gamma, lambda, beta, rel_tol = 1e-05)

qlSMNG(p, mu, delta, gamma, lambda, beta, rel_tol = 1e-05)

rlSMNG(n, mu, delta, gamma, lambda, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMNGdistribution_+3A_x">x</code>, <code id="SMNGdistribution_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_mu">mu</code></td>
<td>
<p>Location parameter, default set to 0.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_delta">delta</code></td>
<td>
<p>Concentration parameter, must be positive.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_gamma">gamma</code></td>
<td>
<p>Tail parameter, must be positive.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_beta">beta</code></td>
<td>
<p>Skewness parameter, default set to 0 (symmetric case).</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_inf_sum">inf_sum</code></td>
<td>
<p>Logical: if FALSE (default) the integral representation of the SMNG density is used,
otherwise the infinite sum is employed.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_rel_tol">rel_tol</code></td>
<td>
<p>Level of relative tolerance required for the <code>integrate</code> procedure or for the infinite sum convergence check.
Default set to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="SMNGdistribution_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SMNG distribution is a normal scale-mean mixture distribution with a GIG as mixing distribution. The
density can be expressed as an infinite sum of Bessel K functions and it is characterized by 5 parameters.
</p>
<p>Moreover, if X is SMNG distributed, then <code class="reqn">Z=exp(X)</code> is distributed as a log-SMNG distribution.
</p>


<h3>Value</h3>

<p><code>dSMNG</code> and <code>dlSMNG</code> provide the values of the density function at a quantile <code>x</code> for, respectively
a SMNG distribution and a log-SMNG.
</p>
<p><code>pSMNG</code> and <code>plSMNG</code> provide the cumulative distribution function at a quantile <code>q</code>.
</p>
<p><code>qSMNG</code> and <code>qlSMNG</code> provide the quantile corresponding to a probability level <code>p</code>.
</p>
<p><code>rSMNG</code> and <code>rlSMNG</code> generate <code>n</code> independent samples from the desired distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Plots of density and cumulative functions of the SMNG distribution
x&lt;-seq(-10,10,length.out = 500)

plot(x,dSMNG(x = x,mu = 0,delta = 1,gamma = 1,lambda = 1,beta= 2),
    type="l",ylab="f(x)")
lines(x,dSMNG(x = x,mu = 0,delta = 1,gamma = 1,lambda = 1,beta= -2),col=2)
title("SMNG density function")

plot(x,pSMNG(q = x,mu = 0,delta = 1,gamma = 1,lambda = 1,beta= 2),
    type="l",ylab="F(x)")
lines(x,pSMNG(q = x,mu = 0,delta = 1,gamma = 1,lambda = 1,beta= -2),col=2)
title("SMNG cumulative function")


### Plots of density and cumulative functions of the logSMNG distribution
x&lt;-seq(0,20,length.out = 500)

plot(x,dlSMNG(x = x,mu = 0,delta = 1,gamma = 1,lambda = 2,beta = 1),
    type="l",ylab="f(x)",ylim = c(0,1.5))
lines(x,dlSMNG(x = x,mu = 0,delta = 1,gamma = 1,lambda = 2,beta = -1),col=2)
title("logSMNG density function")

plot(x,plSMNG(q = x,mu = 0,delta = 1,gamma = 1,lambda = 2,beta = 1),
    type="l",ylab="F(x)",ylim = c(0,1))
lines(x,plSMNG(q = x,mu = 0,delta = 1,gamma = 1,lambda = 2,beta = -1),col=2)
title("logSMNG cumulative function")


</code></pre>

<hr>
<h2 id='SMNGmoments'>SMNG Moments and Moment Generating Function</h2><span id='topic+SMNGmoments'></span><span id='topic+SMNG_MGF'></span><span id='topic+meanSMNG'></span><span id='topic+SMNGmoment'></span>

<h3>Description</h3>

<p>Functions that implement the mean, the generic moments (both raw and centered) and the moment generating function of the SMNG distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMNG_MGF(
  r,
  mu = 0,
  delta,
  gamma,
  lambda,
  beta = 0,
  inf_sum = FALSE,
  rel_tol = 1e-05
)

meanSMNG(mu, delta, gamma, lambda, beta)

SMNGmoment(j, mu, delta, gamma, lambda, beta, type = "central")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMNGmoments_+3A_r">r</code></td>
<td>
<p>Coefficient of the MGF. Can be viewed also as the order of the logSMNG moments.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_mu">mu</code></td>
<td>
<p>Location parameter, default set to 0.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_delta">delta</code></td>
<td>
<p>Concentration parameter, must be positive.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_gamma">gamma</code></td>
<td>
<p>Tail parameter, must be positive.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_lambda">lambda</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_beta">beta</code></td>
<td>
<p>Skewness parameter, default set to 0 (symmetric case).</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_inf_sum">inf_sum</code></td>
<td>
<p>Logical: if FALSE (default), the integral representation of the SMNG density is used,
otherwise the infinite sum is employed.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_rel_tol">rel_tol</code></td>
<td>
<p>Level of relative tolerance required for the <code>integrate</code> procedure or for the infinite sum.
Default set to <code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_j">j</code></td>
<td>
<p>Order of the moment.</p>
</td></tr>
<tr><td><code id="SMNGmoments_+3A_type">type</code></td>
<td>
<p>String that indicate the kind of moment to comupute. Could be <code>"central"</code> (default) or <code>"raw"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the mean (i.e. the first order raw moment) of the SMNG distribution is required, then the function <code>meanSMNG</code> could be use.
</p>
<p>On the other hand, to obtain the generic <em>j</em>-th moment both <code>"raw"</code> or <code>"centered"</code> around the mean, the function <code>momentSMNG</code> could be used.
</p>
<p>Finally, to evaluate the Moment Generating Function (MGF) of the SMNG distribution in the point <code>r</code>, the function <code>SMNG_MGF</code> is provided.
It is defined only for points that are lower then the parameter <code>gamma</code>, and for integer values of <code>r</code> it could also considered as the
<em>r</em>-th raw moment of the logSMNG distribution. The last function is implemented both in the integral form, which uses the routine <code><a href="stats.html#topic+integrate">integrate</a></code>,
or in the infinite sum structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Comparisons sample quantities vs true values
sample &lt;- rSMNG(n=50000,mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2)
mean(sample)
meanSMNG(mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2)

var(sample)
SMNGmoment(j = 2,mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2,type = "central")
SMNGmoment(j = 2,mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2,type = "raw")-
                        meanSMNG(mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2)^2

mean(exp(sample))
SMNG_MGF(r = 1,mu = 0,delta = 2,gamma = 2,lambda = 1,beta = 2)


</code></pre>

<hr>
<h2 id='SMNGZmoment'>SMNG moments centered in <code>mu</code></h2><span id='topic+SMNGZmoment'></span>

<h3>Description</h3>

<p>Function that implements the formula of the SMNG moments ceneterd with respect to the location parameter <code>mu</code>.
It is used to compute all the moments through the function <code>momentRecursion</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMNGZmoment(j, mu, d, g, l, beta)
</code></pre>

<hr>
<h2 id='zerfun'>Function for finding SMNG quantiles</h2><span id='topic+zerfun'></span>

<h3>Description</h3>

<p>Non-linear function whose zero can be fuond by the <code>uniroot</code> procedure in order to obtain the SMNG quantile
corresponding to probability <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zerfun(x, mu, delta, gamma, lambda, beta, p, rel_tol)
</code></pre>

<hr>
<h2 id='zerfun_log'>Function for finding logSMNG quantiles</h2><span id='topic+zerfun_log'></span>

<h3>Description</h3>

<p>Non-linear function whose zero can be fuond by the <code>uniroot</code> procedure in order to obtain the logSMNG quantile
corresponding to probability <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zerfun_log(x, mu, delta, gamma, lambda, beta, p, rel_tol)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
