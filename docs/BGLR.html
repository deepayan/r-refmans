<!DOCTYPE html><html><head><title>Help for package BGLR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BGLR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BFDR'><p>BFDR</p></a></li>
<li><a href='#BGLR'><p>Bayesian Generalized Linear Regression</p></a></li>
<li><a href='#BLR'><p>Bayesian Linear Regression</p></a></li>
<li><a href='#BLRCross'><p>Bayesian Linear Regression</p></a></li>
<li><a href='#BLRXy'><p>Bayesian Linear Regression</p></a></li>
<li><a href='#getGCovar'><p>getGCovar</p></a></li>
<li><a href='#getVariances'><p>getVariances</p></a></li>
<li><a href='#mice'><p>mice dataset</p></a></li>
<li><a href='#mice.A'><p>Pedigree info for the mice dataset</p></a></li>
<li><a href='#mice.map'><p>Genetic map info for the mice dataset</p></a></li>
<li><a href='#mice.pheno'><p>Phenotypical data for the mice dataset</p></a></li>
<li><a href='#mice.X'><p>Molecular markers</p></a></li>
<li><a href='#Multitrait'><p>Multi trait models</p></a></li>
<li><a href='#plot.BGLR'><p>Plots for BGLR Analysis</p></a></li>
<li><a href='#predict.BGLR'><p>Model Predictions</p></a></li>
<li><a href='#read_bed'><p>read_bed</p></a></li>
<li><a href='#read_ped'><p>read_ped</p></a></li>
<li><a href='#readBinMat'><p>readBinMat</p></a></li>
<li><a href='#readBinMatMultitrait'><p>readBinMatMultitrait</p></a></li>
<li><a href='#residuals.BGLR'><p>Extracts models residuals</p></a></li>
<li><a href='#simulated3t'><p>simulated data for 3 traits</p></a></li>
<li><a href='#simulated3t.pheno'><p>Phenotypical data for simulated dataset with 3 traits</p></a></li>
<li><a href='#simulated3t.X'><p>Molecular markers</p></a></li>
<li><a href='#summary.BGLR'><p>summary for BGLR fitted models</p></a></li>
<li><a href='#vech'><p>Extract Lower Triangular Elements from a Symmetric Matrix</p></a></li>
<li><a href='#wheat'><p>wheat dataset</p></a></li>
<li><a href='#wheat.A'><p>Pedigree info for the wheat dataset</p></a></li>
<li><a href='#wheat.sets'><p>Sets for cross validation (CV)</p></a></li>
<li><a href='#wheat.X'><p>Molecular markers</p></a></li>
<li><a href='#wheat.Y'><p>Grain yield</p></a></li>
<li><a href='#write_bed'><p>write_bed</p></a></li>
<li><a href='#xpnd'><p>Expand a Vector into a Symmetric Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Generalized Linear Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Gustavo de los Campos, Paulino Perez Rodriguez</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paulino Perez Rodriguez &lt;perpdgo@colpos.mx&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>truncnorm, MASS, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian Generalized Linear Regression.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-01 22:16:52 UTC; pperez</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-02 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BFDR'>BFDR</h2><span id='topic+BFDR'></span>

<h3>Description</h3>

<p>Convert probabilities to Bayesian false discovery rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BFDR(prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BFDR_+3A_prob">prob</code></td>
<td>
<p>(numeric), the vector of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of Bayesian false discovery rates.
</p>

<hr>
<h2 id='BGLR'>Bayesian Generalized Linear Regression</h2><span id='topic+BGLR'></span>

<h3>Description</h3>

<p>The BGLR (&lsquo;Bayesian Generalized Linear Regression&rsquo;) function
fits various types of parametric and semi-parametric Bayesian regressions to continuos 
(censored or not), binary and ordinal outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BGLR(y, response_type = "gaussian", a=NULL, b=NULL,ETA = NULL, nIter = 1500,
       burnIn = 500, thin = 5, saveAt = "", S0 = NULL, 
       df0 =5, R2 = 0.5, weights = NULL,
       verbose = TRUE, rmExistingFiles = TRUE, groups=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGLR_+3A_y">y</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) the data-vector (NAs allowed).</p>
</td></tr>
<tr><td><code id="BGLR_+3A_response_type">response_type</code></td>
<td>
<p>(string) admits values <code>"gaussian"</code> or <code>"ordinal"</code>. The Gaussian outcome may be censored or not (see below). 
If <code>response_type="gaussian"</code>, <code>y</code> should be coercible to numeric. If <code>response_type="ordinal"</code>, <code>y</code>
should be coercible to character, and the order of the outcomes is determined based on the
alphanumeric order <code>(0&lt;1&lt;2..&lt;a&lt;b..)</code>. For ordinal traits the probit link is used.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_a">a</code>, <code id="BGLR_+3A_b">b</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) only requiered for censored outcomes, <code>a</code> and <code>b</code> are vectors specifying lower and 
upper bounds for censored observations, respectively. The default value, for non-censored and ordinal 
outcomes, is <code>NULL</code> (see details).</p>
</td></tr>
<tr><td><code id="BGLR_+3A_eta">ETA</code></td>
<td>
<p> (list) This is a two-level list used to specify the regression function (or linear predictor). By default the linear predictor 
(the conditional expectation function in case of Gaussian outcomes) includes only an intercept.
Regression on covariates and other types of random effects are specified in this two-level list. For instance:
</p>
<pre>
ETA=list(list(X=W, model="FIXED"), 
              list(X=Z,model="BL"), 
              list(K=G,model="RKHS")),
</pre> 
<p>specifies that the linear predictor should include: an intercept (included by default) plus a linear regression on W with regression 
coefficients treated as fixed effects (i.e., flat prior), plus regression on Z, with regression coefficients modeled as in the 
Bayesian Lasso of Park and Casella (2008) plus and a random effect with co-variance structure G.
</p>
<p>For linear regressions the following options are implemented: FIXED (Flat prior), BRR (Gaussian prior), BayesA (scaled-t prior), BL (Double-Exponential prior), 
BayesB (two component mixture prior with a point of mass at zero and a scaled-t slab), BayesC (two component mixture prior with a point of
mass at zero and a Gaussian slab). In linear regressions X can be the incidence matrix for effects or a formula (e.g. <code>~factor(sex) + age</code>)
in which case the incidence matrix is created internally using the <code>model.matrix</code> function of R. For Gaussian processes (RKHS) a co-variance matrix
(K) must be provided. Further details about the models implemented in BGLR see the vignettes in the package. 
</p>
</td></tr>
<tr><td><code id="BGLR_+3A_weights">weights</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) a vector of weights, may be <code>NULL</code>. If weights is not <code>NULL</code>, the 
residual variance of each data-point is set to be proportional to the inverse of the squared-weight. Only
used with Gaussian outcomes.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_niter">nIter</code>, <code id="BGLR_+3A_burnin">burnIn</code>, <code id="BGLR_+3A_thin">thin</code></td>
<td>
<p>(integer) the number of iterations, burn-in and thinning.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_saveat">saveAt</code></td>
<td>
<p>(string) this may include a path and a pre-fix that will be added to the name of the files that are saved as the program runs.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_s0">S0</code>, <code id="BGLR_+3A_df0">df0</code></td>
<td>
<p> (numeric) The scale parameter for the scaled inverse-chi squared prior assigned to the residual variance, only used with Gaussian outcomes. 
In the parameterization of the scaled-inverse chi square in BGLR the expected values is <code>S0/(df0-2)</code>. The default value for the 
df parameter is 5. If the scale is not specified a value is calculated so that the prior mode of the residual 
variance  equals <code>var(y)*R2</code> (see below). For further details see the vignettes in the package.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_r2">R2</code></td>
<td>
<p>(numeric, <code>0&lt;R2&lt;1</code>) The proportion of variance that one expects, a priori, to be explained by the regression. Only used if 
the hyper-parameters are not specified; if that is the case, internaly, hyper-paramters are set so that the prior modes are consistent with the 
variance partition specified by R2 and the prior distribution is relatively flat at the mode. For 
further details see the vignettes in the package.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_verbose">verbose</code></td>
<td>
<p>(logical) if TRUE the iteration history is printed, default TRUE.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_rmexistingfiles">rmExistingFiles</code></td>
<td>
<p>(logical) if TRUE removes existing output files from previous runs, default TRUE.</p>
</td></tr>
<tr><td><code id="BGLR_+3A_groups">groups</code></td>
<td>
<p>(factor) a vector of the same length of y that associates observations with groups, each group will have an associated variance component for the error term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BGLR implements a Gibbs sampler for a Bayesian regresion model. The linear predictor (or regression function)
includes an intercept (introduced by default) plus a number of user-specified regression components (X) and 
random effects (u), that is:
</p>
&eta;=1&mu; + X<sub>1</sub>&beta;<sub>1</sub>+...+X<sub>p</sub>&beta;<sub>p</sub>+u<sub>1</sub>+...+u<sub>q</sub>
<p>The components of the linear predictor are specified in the argument ETA (see above). 
The user can specify as many linear terms as desired, and for each component the user can choose the 
prior density to be assigned. The distribution of the response is modeled as a function of the 
linear predictor.
</p>
<p>For Gaussian outcomes, the linear predictor is the conditional expectation, and censoring is allowed. For censored data points the actual response value (<code class="reqn">y_i</code>)
is missing, and the entries of the vectors a and b (see above) give the lower an upper vound for <code class="reqn">y_i</code>. The
following table shows the configuration of the triplet (y, a, b) for un-censored, right-censored, 
left-censored and interval censored.
</p>

<table>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: center;"> a             </td><td style="text-align: center;"> y          </td><td style="text-align: center;"> b  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Un-censored       </td><td style="text-align: center;"> NULL          </td><td style="text-align: center;"> <code class="reqn">y_i</code>  </td><td style="text-align: center;"> NULL </td>
</tr>
<tr>
 <td style="text-align: left;">
   Right censored    </td><td style="text-align: center;"> <code class="reqn">a_i</code>     </td><td style="text-align: center;"> NA         </td><td style="text-align: center;"> <code class="reqn">\infty</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Left censored     </td><td style="text-align: center;"> <code class="reqn">-\infty</code> </td><td style="text-align: center;"> NA         </td><td style="text-align: center;"> <code class="reqn">b_i</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Interval censored </td><td style="text-align: center;"> <code class="reqn">a_i</code>     </td><td style="text-align: center;"> NA         </td><td style="text-align: center;"> <code class="reqn">b_i</code>
 </td>
</tr>

</table>
 
<p>Internally, censoring is dealt with as a missing data problem.
</p>
<p><em>Ordinal outcomes</em> are modelled using the probit link, implemented via data augmentation. 
In this case the linear predictor becomes the mean of the underlying liability variable which is 
normal with mean equal to the linear predictor and variance equal to one. In case of only two classes 
(binary outcome) the threshold is set equal to zero, for more than two classess thresholds are estimated 
from the data. Further details about this approach can be found in Albert and Chib (1993).
</p>


<h3>Value</h3>

<p>A list with estimated posterior means, estimated posterior standard deviations, and the parameters used to fit the model.
See the vignettes in the package for further details.
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>References</h3>

<p>Albert J,. S. Chib. 1993. Bayesian Analysis of Binary and Polychotomus Response Data. <em>JASA</em>, <b>88</b>: 669-679.
</p>
<p>de los Campos G., H. Naya, D. Gianola, J. Crossa, A. Legarra, E. Manfredi, K. Weigel and J. Cotes. 2009.
Predicting Quantitative Traits with Regression Models for Dense Molecular Markers and Pedigree. <em>Genetics</em> <b>182</b>: 375-385.
</p>
<p>de los Campos, G., D. Gianola, G. J. M., Rosa, K. A., Weigel, and J. Crossa. 2010.  Semi-parametric genomic-enabled prediction of genetic values using 
reproducing kernel Hilbert spaces methods. <em>Genetics Research</em>, <b>92</b>:295-308.
</p>
<p>Park T. and G. Casella. 2008. The Bayesian LASSO. <em>Journal of the American Statistical Association</em> <b>103</b>: 681-686.
</p>
<p>Spiegelhalter, D.J., N.G. Best, B.P. Carlin and A. van der Linde. 2002. Bayesian measures of model complexity and 
fit (with discussion). <em>Journal of the Royal Statistical Society</em>, Series B (Statistical Methodology) <b>64</b> (4): 583-639.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Demos
library(BGLR)

#BayesA
demo(BA)

#BayesB
demo(BB)

#Bayesian LASSO
demo(BL)

#Bayesian Ridge Regression
demo(BRR)

#BayesCpi
demo(BayesCpi)

#RKHS
demo(RKHS)

#Binary traits
demo(Bernoulli)

#Ordinal traits
demo(ordinal)

#Censored traits
demo(censored)


## End(Not run)

</code></pre>

<hr>
<h2 id='BLR'>Bayesian Linear Regression</h2><span id='topic+BLR'></span>

<h3>Description</h3>

<p>The BLR (&lsquo;Bayesian Linear Regression&rsquo;) function
was designed to fit parametric regression models using different
types of shrinkage methods. An earlier version of this program was presented in de los Campos <em>et al.</em> (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BLR(y, XF, XR, XL, GF, prior, nIter, burnIn, thin,thin2,saveAt,
      minAbsBeta,weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLR_+3A_y">y</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) the data-vector (NAs allowed).</p>
</td></tr>
<tr><td><code id="BLR_+3A_xf">XF</code></td>
<td>
<p>(numeric, <code class="reqn">n \times pF</code>) incidence matrix for <code class="reqn">\boldsymbol \beta_F</code>, may be NULL.</p>
</td></tr>
<tr><td><code id="BLR_+3A_xr">XR</code></td>
<td>
<p>(numeric, <code class="reqn">n \times pR</code>) incidence matrix for <code class="reqn">\boldsymbol \beta_R</code>, may be NULL.</p>
</td></tr>
<tr><td><code id="BLR_+3A_xl">XL</code></td>
<td>
<p>(numeric, <code class="reqn">n \times pL</code>) incidence matrix for <code class="reqn">\boldsymbol \beta_L</code>, may be NULL.</p>
</td></tr>
<tr><td><code id="BLR_+3A_gf">GF</code></td>
<td>
<p>(list) providing an <code class="reqn">\$</code>ID (integer, <code class="reqn">n</code>) linking observations to groups
(e.g., lines or sires) and a (co)variance structure (<code class="reqn">\$</code>A, numeric, <code class="reqn">pU \times pU</code>) between effects of the grouping factor
(e.g., line or sire effects). Note: ID must be an integer taking values from 1 to <code class="reqn">pU</code>; ID[i]=<code class="reqn">q</code> indicates that
the ith observation in <code class="reqn">\boldsymbol y</code> belongs to cluster <code class="reqn">q</code> whose (co)variance function is in the qth row (column) of <code class="reqn">\boldsymbol A</code>.
GF may be NULL.</p>
</td></tr>
<tr><td><code id="BLR_+3A_weights">weights</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) a vector of weights, may be NULL.</p>
</td></tr>
<tr><td><code id="BLR_+3A_niter">nIter</code>, <code id="BLR_+3A_burnin">burnIn</code>, <code id="BLR_+3A_thin">thin</code></td>
<td>
<p>(integer) the number of iterations, burn-in and thinning.</p>
</td></tr>
<tr><td><code id="BLR_+3A_saveat">saveAt</code></td>
<td>
<p>(string) this may include a path and a pre-fix that will be added to the name of the files that are saved as the program runs.</p>
</td></tr>
<tr><td><code id="BLR_+3A_prior">prior</code></td>
<td>
<p>(list) containing the following elements,
</p>

<ul>
<li><p> prior$varE, prior$varBR, prior$varU: (list) each providing degree of freedom ($df) and scale ($S). These are the parameters of the scaled inverse-<code class="reqn">\chi^2</code>
distributions assigned to variance components, see Eq. (2) below. In the parameterization used by BLR() the prior expectation of variance parameters is <code class="reqn">S/(df-2)</code>.
</p>
</li>
<li><p> prior$lambda: (list) providing $value (initial value for <code class="reqn">\lambda</code>); $type (&lsquo;random&rsquo; or &lsquo;fixed&rsquo;) this argument specifies
whether <code class="reqn">\lambda</code> should be kept fixed at the value provided by $value or updated with samples from the posterior
distribution; and, either $shape and $rate (this when a Gamma prior is desired on <code class="reqn">\lambda^2</code>) or $shape1, $shape2 and
$max, in this case <code class="reqn">p(\lambda |\max, \alpha_1, \alpha_2) \propto Beta \left(\frac{\lambda}{\max} | \alpha_1, \alpha_2 \right)</code>. For detailed description of these priors see de los Campos <em>et al.</em> (2009).
</p>
</li></ul>

</td></tr>
<tr><td><code id="BLR_+3A_thin2">thin2</code></td>
<td>
<p>This value controls wether the running means are saved to disk or not. If thin2 is greater than nIter the running 
means are not saved (default, thin2=<code class="reqn">1 \times 10^{10}</code>).</p>
</td></tr>
<tr><td><code id="BLR_+3A_minabsbeta">minAbsBeta</code></td>
<td>
<p>The minimum absolute value of the components of <code class="reqn">\boldsymbol \beta_L</code> to avoid numeric problems when sampling from <code class="reqn">\boldsymbol \tau^2</code>, default <code class="reqn">1 \times 10^{-9}</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program runs a Gibbs sampler for the Bayesian regression model described below.
</p>
<p><b>Likelihood</b>. The equation for the data is:
</p>
<p style="text-align: center;"><code class="reqn"> 
 \begin{array}{lr}
 \boldsymbol y= \boldsymbol 1 \mu + \boldsymbol X_F \boldsymbol \beta_F + \boldsymbol X_R \boldsymbol \beta_R + \boldsymbol X_L \boldsymbol \beta_L + \boldsymbol{Zu}  + \boldsymbol \varepsilon &amp; (1) 
 \end{array}
     </code>
</p>

<p>where <code class="reqn">\boldsymbol y</code>, the response is a <code class="reqn">n \times 1</code> vector (NAs allowed); <code class="reqn">\mu</code> is
an intercept; <code class="reqn">\boldsymbol X_F, \boldsymbol X_R, \boldsymbol X_L</code> and <code class="reqn">\boldsymbol Z</code> are incidence matrices 
used to accommodate different 
types of effects (see below), and; <code class="reqn">\boldsymbol \varepsilon</code> is a vector of model residuals assumed to be 
distributed as <code class="reqn">\boldsymbol \varepsilon \sim N(\boldsymbol 0,Diag(\sigma_{\boldsymbol \varepsilon}^2/w_i^2))</code>, 
here <code class="reqn">\sigma_{\boldsymbol \varepsilon}^2</code> is an (unknown) 
variance parameter and <code class="reqn">w_i</code> are (known) weights that allow for heterogeneous-residual variances.
</p>
<p>Any of the elements in the right-hand side of the linear predictor, except <code class="reqn">\mu</code> and <code class="reqn">\boldsymbol \varepsilon</code> , can be omitted; 
by default the program runs an intercept model.
</p>
<p><b>Prior</b>. The residual variance is assigned a scaled inverse-<code class="reqn">\chi^2</code> prior with degree of freedom and scale parameter
provided by the user, that is, <code class="reqn">\sigma_{\boldsymbol \varepsilon}^2 \sim \chi^{-2} (\sigma_{\boldsymbol \varepsilon}^2 | df_{\boldsymbol \varepsilon}, S_{\boldsymbol \varepsilon})</code>. The regression coefficients <code class="reqn">\left\{\mu, \boldsymbol \beta_F, \boldsymbol \beta_R, \boldsymbol \beta_L, \boldsymbol u \right\}</code> are assigned priors
that yield different type of shrinkage. The intercept and the vector of regression coefficients <code class="reqn">\boldsymbol \beta_F</code> are assigned flat priors
(i.e., estimates are not shrunk). The vector of regression coefficients <code class="reqn">\boldsymbol \beta_R</code> is assigned a
Gaussian prior with variance common to all effects, that is,
<code class="reqn">\beta_{R,j} \mathop \sim \limits^{iid} N(0, \sigma_{\boldsymbol \beta_R}^2)</code>. This prior is 
the Bayesian counterpart of Ridge Regression. The variance parameter <code class="reqn">\sigma_{\boldsymbol \beta_R}^2</code>, 
is treated as unknown and it is assigned a scaled inverse-<code class="reqn">\chi^2</code> prior, that is,
<code class="reqn">\sigma_{\boldsymbol \beta_R}^2 \sim \chi^{-2} (\sigma_{\boldsymbol \beta_R}^2 | df_{\boldsymbol \beta_R}, S_{\boldsymbol \beta_R})</code> with degrees of freedom 
<code class="reqn">df_{\boldsymbol \beta_R}</code>, and scale <code class="reqn">S_{\boldsymbol \beta_R}</code> provided by the user.
</p>
<p>The vector of regression coefficients <code class="reqn">\boldsymbol \beta_L</code> is treated as in
the Bayesian LASSO of Park and Casella (2008). Specifically,
</p>
<p style="text-align: center;"><code class="reqn">p(\boldsymbol \beta_L, \boldsymbol \tau^2, \lambda | \sigma_{\boldsymbol \varepsilon}^2) = \left\{\prod_k N(\beta_{L,k} | 0, \sigma_{\boldsymbol \varepsilon}^2 \tau_k^2) Exp\left(\tau_k^2 | \lambda^2\right) \right\} p(\lambda),</code>
</p>

<p>where, <code class="reqn">Exp(\cdot|\cdot)</code> is an exponential prior and <code class="reqn">p(\lambda)</code> can either be: (a)
a mass-point at some value (i.e., fixed <code class="reqn">\lambda</code>); (b) <code class="reqn">p(\lambda^2) \sim Gamma(r,\delta)</code> this 
is the prior suggested by Park and Casella (2008); or, (c) <code class="reqn">p(\lambda | \max, \alpha_1, \alpha_2) \propto Beta\left(\frac{\lambda}{\max} | \alpha_1,\alpha_2 \right)</code>, see de los Campos <em>et al</em>. (2009) for details. It can be shown that the marginal prior of regression coefficients <code class="reqn">\beta_{L,k}, \int N(\beta_{L,k} | 0, \sigma_{\boldsymbol \varepsilon}^2 \tau_k^2) Exp\left(\tau_k^2 | \lambda^2\right) \partial \tau_k^2</code>, is Double-Exponential. This prior has thicker tails and higher peak of mass at zero than the Gaussian prior used for <code class="reqn">\boldsymbol \beta_R</code>, inducing a different type of shrinkage.
</p>
<p>The vector <code class="reqn">\boldsymbol u </code> is used to model the so called &lsquo;infinitesimal effects&rsquo;, and is assigned a prior <code class="reqn">\boldsymbol u \sim N(\boldsymbol 0, \boldsymbol A\sigma_{\boldsymbol u}^2)</code>, 
where, <code class="reqn">\boldsymbol A</code> is a positive-definite matrix (usually a relationship matrix computed from a pedigree) and <code class="reqn">\sigma_{\boldsymbol u}^2</code> is an unknow variance, whose prior is
<code class="reqn">\sigma_{\boldsymbol u}^2 \sim \chi^{-2} (\sigma_{\boldsymbol u}^2 | df_{\boldsymbol u}, S_{\boldsymbol u})</code>.
</p>
<p>Collecting the above mentioned assumptions, the posterior distribution of model unknowns, 
<code class="reqn">\boldsymbol \theta= \left\{\mu, \boldsymbol \beta_F, \boldsymbol \beta_R, \sigma_{\boldsymbol \beta_R}^2, \boldsymbol \beta_L, \boldsymbol \tau^2, \lambda, \boldsymbol u, \sigma_{\boldsymbol u}^2, \sigma_{\boldsymbol \varepsilon}^2, \right\}</code>, is, 
</p>
<p style="text-align: center;"><code class="reqn">\begin{array}{lclr}
        p(\boldsymbol \theta | \boldsymbol y) &amp; \propto &amp; N\left( \boldsymbol y | \boldsymbol 1 \mu + \boldsymbol X_F \boldsymbol \beta_F + \boldsymbol X_R \boldsymbol \beta_R + \boldsymbol X_L \boldsymbol \beta_L + \boldsymbol{Zu}; Diag\left\{ \frac{\sigma_\varepsilon^2}{w_i^2}\right\}\right) &amp; \\
                                              &amp;         &amp; \times  \left\{ \prod\limits_j N\left(\beta_{R,j} | 0, \sigma_{\boldsymbol \beta_R}^2 \right) \right\} \chi^{-2} \left(\sigma_{\boldsymbol \beta_R}^2  | df_{\boldsymbol \beta_R}, S_{\boldsymbol \beta_R}\right)  &amp; \\
                                              &amp;         &amp; \times \left\{ \prod\limits_k N \left( \beta_{L,k} |0,\sigma_{\boldsymbol \varepsilon}^2 \tau_k^2 \right) Exp \left(\tau_k^2 | \lambda^2\right)\right\} p(\lambda) &amp; (2)\\
                                              &amp;         &amp; \times N(\boldsymbol u | \boldsymbol 0,\boldsymbol A\sigma_{\boldsymbol u}^2) \chi^{-2} (\sigma_{\boldsymbol u}^2 | df_{\boldsymbol u}, S_{\boldsymbol u}) \chi^{-2} (\sigma_{\boldsymbol \varepsilon}^2 | df_{\boldsymbol \varepsilon}, S_{\boldsymbol \varepsilon}) &amp; 
      \end{array}
     </code>
</p>



<h3>Value</h3>

<p>A list with posterior means, posterior standard deviations, and the parameters used to fit the model:
</p>
<table>
<tr><td><code>$yHat</code></td>
<td>
<p>the posterior mean of <code class="reqn">\boldsymbol 1 \mu + \boldsymbol X_F \boldsymbol \beta_F + \boldsymbol X_R \boldsymbol \beta_R + \boldsymbol X_L \boldsymbol \beta_L + \boldsymbol{Zu}  + \boldsymbol\varepsilon</code>.</p>
</td></tr>
<tr><td><code>$SD.yHat</code></td>
<td>
<p>the corresponding posterior standard deviation.</p>
</td></tr>
<tr><td><code>$mu</code></td>
<td>
<p>the posterior mean of the intercept.</p>
</td></tr>
<tr><td><code>$varE</code></td>
<td>
<p>the posterior mean of <code class="reqn">\sigma_{\boldsymbol \varepsilon}^2</code>.</p>
</td></tr>
<tr><td><code>$bR</code></td>
<td>
<p>the posterior mean of <code class="reqn">\boldsymbol \beta_R</code>.</p>
</td></tr>
<tr><td><code>$SD.bR</code></td>
<td>
<p>the corresponding posterior standard deviation.</p>
</td></tr>
<tr><td><code>$varBr</code></td>
<td>
<p>the posterior mean of <code class="reqn">\sigma_{\boldsymbol \beta_R}^2</code>.</p>
</td></tr>
<tr><td><code>$bL</code></td>
<td>
<p>the posterior mean of <code class="reqn">\boldsymbol \beta_L</code>.</p>
</td></tr>
<tr><td><code>$SD.bL</code></td>
<td>
<p>the corresponding posterior standard deviation.</p>
</td></tr>
<tr><td><code>$tau2</code></td>
<td>
<p>the posterior mean of <code class="reqn">\boldsymbol \tau^2</code>.</p>
</td></tr>
<tr><td><code>$lambda</code></td>
<td>
<p>the posterior mean of <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code>$u</code></td>
<td>
<p>the posterior mean of <code class="reqn">\boldsymbol u</code>.</p>
</td></tr>
<tr><td><code>$SD.u</code></td>
<td>
<p>the corresponding posterior standard deviation.</p>
</td></tr>
<tr><td><code>$varU</code></td>
<td>
<p>the posterior mean of <code class="reqn">\sigma_{\boldsymbol u}^2</code>.</p>
</td></tr>
<tr><td><code>$fit</code></td>
<td>
<p>a list with evaluations of effective number of parameters and DIC (Spiegelhalter <em>et al.</em>, 2002).</p>
</td></tr>
<tr><td><code>$whichNa</code></td>
<td>
<p>a vector indicating which entries in <code class="reqn">\boldsymbol y</code> were missing.</p>
</td></tr>
<tr><td><code>$prior</code></td>
<td>
<p>a list containig the priors used during the analysis.</p>
</td></tr>
<tr><td><code>$weights</code></td>
<td>
<p>vector of weights.</p>
</td></tr>
<tr><td><code>$fit</code></td>
<td>
<p>list containing the following elements,
</p>

<ul>
<li><p> $logLikAtPostMean: log-likelihood evaluated at posterior mean.
</p>
</li>
<li><p> $postMeanLogLik: the posterior mean of the Log-Likelihood.
</p>
</li>
<li><p> $pD: estimated effective number of parameters, Spiegelhalter <em>et al.</em> (2002).
</p>
</li>
<li><p> $DIC: the deviance information criterion, Spiegelhalter <em>et al.</em> (2002).                        
</p>
</li></ul>
</td></tr>
<tr><td><code>$nIter</code></td>
<td>
<p>the number of iterations made in the Gibbs sampler.</p>
</td></tr>
<tr><td><code>$burnIn</code></td>
<td>
<p>the nuber of iteratios used as burn-in.</p>
</td></tr>
<tr><td><code>$thin</code></td>
<td>
<p>the thin used.</p>
</td></tr>
<tr><td><code>$y</code></td>
<td>
<p>original data-vector.</p>
</td></tr>
</table>
<p>The posterior means returned by BLR are calculated after burnIn is
passed and at a thin as specified by the user.
</p>
<p><b>Save</b>. The routine will save samples of <code class="reqn">\mu</code>, variance components and <code class="reqn">\lambda</code> and running means
(rm*.dat). Running means are computed using the thinning specified by
the user (see argument thin above); however these running means are
saved at a thinning specified by argument thin2 (by default, thin2=<code class="reqn">1 \times 10^{10}</code> so that running means are computed 
as the sampler runs but not saved to the disc).
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>References</h3>

<p>de los Campos G., H. Naya, D. Gianola, J. Crossa, A. Legarra, E. Manfredi, K. Weigel and J. Cotes. 2009.
Predicting Quantitative Traits with Regression Models for Dense Molecular Markers and Pedigree. <em>Genetics</em> <b>182</b>: 375-385.
</p>
<p>Park T. and G. Casella. 2008. The Bayesian LASSO. <em>Journal of the American Statistical Association</em> <b>103</b>: 681-686.
</p>
<p>Spiegelhalter, D.J., N.G. Best, B.P. Carlin and A. van der Linde. 2002. Bayesian measures of model complexity and 
fit (with discussion). <em>Journal of the Royal Statistical Society</em>, Series B (Statistical Methodology) <b>64</b> (4): 583-639.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
########################################################################
##Example 1:
########################################################################

rm(list=ls())
setwd(tempdir())
library(BGLR)
data(wheat)     #Loads the wheat dataset

y=wheat.Y[,1]
### Creates a testing set with 100 observations
whichNa&lt;-sample(1:length(y),size=100,replace=FALSE)
yNa&lt;-y
yNa[whichNa]&lt;-NA

### Runs the Gibbs sampler
fm&lt;-BLR(y=yNa,XL=wheat.X,GF=list(ID=1:nrow(wheat.A),A=wheat.A),
                           prior=list(varE=list(df=3,S=0.25),
                           varU=list(df=3,S=0.63),
                           lambda=list(shape=0.52,rate=1e-4,
                           type='random',value=30)),
                           nIter=5500,burnIn=500,thin=1)

MSE.tst&lt;-mean((fm$yHat[whichNa]-y[whichNa])^2)
MSE.tst
MSE.trn&lt;-mean((fm$yHat[-whichNa]-y[-whichNa])^2)
MSE.trn
COR.tst&lt;-cor(fm$yHat[whichNa],y[whichNa])
COR.tst
COR.trn&lt;-cor(fm$yHat[-whichNa],y[-whichNa])
COR.trn

plot(fm$yHat~y,xlab="Phenotype",
     ylab="Pred. Gen. Value" ,cex=.8)
points(x=y[whichNa],y=fm$yHat[whichNa],col=2,cex=.8,pch=19)

x11()
plot(scan('varE.dat'),type="o",
        ylab=expression(paste(sigma[epsilon]^2)))

########################################################################
#Example 2: Ten fold, Cross validation, environment 1,
########################################################################

rm(list=ls())
setwd(tempdir())
library(BGLR)
data(wheat)     #Loads the wheat dataset
nIter&lt;-1500     #For real data sets more samples are needed
burnIn&lt;-500     
thin&lt;-10
folds&lt;-10
y&lt;-wheat.Y[,1]
A&lt;-wheat.A

priorBL&lt;-list(
               varE=list(df=3,S=2.5),
               varU=list(df=3,S=0.63),
               lambda = list(shape=0.52,rate=1e-5,value=20,type='random')
             )
             
set.seed(123)  #Set seed for the random number generator
sets&lt;-rep(1:10,60)[-1]
sets&lt;-sets[order(runif(nrow(A)))]
COR.CV&lt;-rep(NA,times=(folds+1))
names(COR.CV)&lt;-c(paste('fold=',1:folds,sep=''),'Pooled')
w&lt;-rep(1/nrow(A),folds) ## weights for pooled correlations and MSE
yHatCV&lt;-numeric()

for(fold in 1:folds)
{
   yNa&lt;-y
   whichNa&lt;-which(sets==fold)
   yNa[whichNa]&lt;-NA
   prefix&lt;-paste('PM_BL','_fold_',fold,'_',sep='')
   fm&lt;-BLR(y=yNa,XL=wheat.X,GF=list(ID=(1:nrow(wheat.A)),A=wheat.A),prior=priorBL,
               nIter=nIter,burnIn=burnIn,thin=thin)
   yHatCV[whichNa]&lt;-fm$yHat[fm$whichNa]
   w[fold]&lt;-w[fold]*length(fm$whichNa)
   COR.CV[fold]&lt;-cor(fm$yHat[fm$whichNa],y[whichNa])
}

COR.CV[11]&lt;-mean(COR.CV[1:10])
COR.CV

########################################################################

## End(Not run)
</code></pre>

<hr>
<h2 id='BLRCross'>Bayesian Linear Regression</h2><span id='topic+BLRCross'></span>

<h3>Description</h3>

<p>The BLR (&lsquo;Bayesian Linear Regression&rsquo;) function
fits various types of parametric Bayesian regressions to continuos outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
BLRCross(y=NULL,my=NULL,vy=NULL,n=NULL,
         XX,Xy,nIter=1500,burnIn=500,
         thin=5,R2=0.5,
         S0=NULL,df0=5,
         priors=NULL,
         idPriors=NULL,
         verbose=TRUE,
         saveAt = "", 
         rmExistingFiles=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLRCross_+3A_y">y</code></td>
<td>
<p>A numeric vector of length n, NAs not allowed, if NULL you must provide my, vy and n.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_my">my</code></td>
<td>
<p>numeric, sample mean of y. If NULL you must provide y.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_vy">vy</code></td>
<td>
<p>numeric, sample variance of y. If NULL you must provide y.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_n">n</code></td>
<td>
<p>integer, sample size. If NULL you must provide y.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_xx">XX</code></td>
<td>
<p>A matrix, XX=crossprod(X), with X an incidence matrix of dimension n times p.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_xy">Xy</code></td>
<td>
<p>A numeric vector of length p, Xy=crossprod(X,y).</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_niter">nIter</code>, <code id="BLRCross_+3A_burnin">burnIn</code>, <code id="BLRCross_+3A_thin">thin</code></td>
<td>
<p>(integer) the number of iterations, burn-in and thinning.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_r2">R2</code></td>
<td>
<p>(numeric, <code>0&lt;R2&lt;1</code>) The proportion of variance that one expects, a priori, to be explained by the regression. Only used if
the hyper-parameters are not specified; if that is the case, internally, hyper-parameters are set so that the prior modes 
are consistent with the variance partition specified by R2 and the prior distribution is relatively flat at the mode.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_s0">S0</code>, <code id="BLRCross_+3A_df0">df0</code></td>
<td>
<p>(numeric) The scale parameter for the scaled inverse-chi squared prior assigned to the residual variance.
In the parameterization of the scaled-inverse chi square in BLRCross the expected values is <code>S0/(df0-2)</code>. The default value for the 
df parameter is 5. If the scale is not specified a value is calculated so that the prior mode of the residual 
variance  equals <code>var(y)*R2</code>.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_priors">priors</code></td>
<td>
<p>(list) This is a two-level list used to specify the regression function (or linear predictor). 
Regression on covariates and other types of random effects are specified in this two-level list.
</p>
<p>For linear regressions the following options are implemented: FIXED (flat prior),
BayesA, BayesB, BRR (Gaussian prior), BayesC, SSVS and RKHS. 
</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_idpriors">idPriors</code></td>
<td>
<p>(numeric) an integer vector that allow us to specify the priors for the columns of matrix X.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_verbose">verbose</code></td>
<td>
<p>(logical) if TRUE the iteration history is printed, default TRUE.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_saveat">saveAt</code></td>
<td>
<p>(string) this may include a path and a pre-fix that will be added to the name of the files that are saved as the program runs.</p>
</td></tr>
<tr><td><code id="BLRCross_+3A_rmexistingfiles">rmExistingFiles</code></td>
<td>
<p>(logical) if TRUE removes existing output files from previous runs, default TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez.
</p>


<h3>References</h3>

<p>de los Campos G., H. Naya, D. Gianola, J. Crossa, A. Legarra, E. Manfredi, K. Weigel and J. Cotes. 2009.
Predicting Quantitative Traits with Regression Models for Dense Molecular Markers and Pedigree. <em>Genetics</em> <b>182</b>: 375-385.
</p>
<p>de los Campos, G., D. Gianola, G. J. M., Rosa, K. A., Weigel, and J. Crossa. 2010.  Semi-parametric genomic-enabled prediction of genetic values using 
reproducing kernel Hilbert spaces methods. <em>Genetics Research</em>, <b>92</b>:295-308.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(BGLR)

p=1000
n=1500

data(mice)
X=scale(mice.X[1:n,1:p],center=TRUE)
QTL=seq(from=50,to=p-50,by=80)

b=rep(0,p)
b[QTL]=1
signal=as.vector(X%*%b)
 
error=rnorm(sd=sd(signal),n=n)
y=error+signal
y=y-mean(y)

XX=crossprod(X)
Xy=as.vector(crossprod(X,y))

#Example 1

## BayesA ################################################################################
priors=list(list(model="BayesA"))
idPriors=rep(1,p)
fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)

## BayesB ################################################################################
priors=list(list(model="BayesB"))
idPriors=idPriors=rep(1,p)
fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)
plot(fm1$ETA[[1]]$b)
points(QTL,b[QTL],col="red")

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)
plot(fm1s$ETA[[1]]$b)
points(QTL,b[QTL],col="red")

## BayesC ################################################################################
priors=list(list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=1/100,counts=1E6))
idPriors=rep(1,p)

fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)
plot(fm1$ETA[[1]]$b)
points(QTL,b[QTL],col="red")

plot(fm1$ETA[[1]]$d)
points(QTL,b[QTL],col="red")

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)
plot(fm1s$ETA[[1]]$b)
points(QTL,b[QTL],col="red")


## SSVS (Absolutely Continuous Spike Slab) ###############################################
priors=list(list(model="SSVS",R2=NULL,df0=NULL,S0=NULL,probIn=NULL,counts=NULL))
idPriors=rep(1,p)

fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)
plot(fm1$ETA[[1]]$b)

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)
plot(fm1s$ETA[[1]]$b)

priors=list(list(model="SSVS",R2=NULL,df0=NULL,S0=NULL,probIn=NULL,
                      counts=NULL,cprobIn=0.5,ccounts=2))
idPriors=rep(1,p)

fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)
plot(fm1$ETA[[1]]$b)

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)

plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)
plot(fm1s$ETA[[1]]$b)

## Ridge Regression ######################################################################
priors=list(list(model="BRR",R2=NULL,df0=NULL,S0=NULL))
idPriors=rep(1,p)

fm1=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1$ETA[[1]]$b),y)

#summary statistics
fm1s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
plot(as.vector(X%*%fm1s$ETA[[1]]$b),y)

#Example 2
priors=list(list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=NULL,counts=NULL),
            list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=NULL,counts=NULL))

idPriors=c(rep(1,p/2),rep(2,p/2))

fm2=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
bHat=c(fm2$ETA[[1]]$b,fm2$ETA[[2]]$b)
plot(as.vector(X%*%bHat),y)
plot(bHat)

#summary statistics
fm2s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
bHat=c(fm2s$ETA[[1]]$b,fm2s$ETA[[2]]$b)
plot(as.vector(X%*%bHat),y)
plot(bHat)

#Example 3
priors=list(list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=NULL,counts=NULL),
            list(model="BRR",R2=NULL,df0=NULL,S0=NULL))
idPriors=c(rep(1,p/2),rep(2,p/2))

fm3=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
bHat=c(fm3$ETA[[1]]$b,fm3$ETA[[2]]$b)
plot(as.vector(X%*%bHat),y)
plot(bHat)

#summary statistics
fm3s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,priors=priors,idPriors=idPriors)
bHat=c(fm3s$ETA[[1]]$b,fm3s$ETA[[2]]$b)
plot(as.vector(X%*%bHat),y)
plot(bHat)

#Example 4 Fixed effects

y=y+3

X=cbind(1,X)

XX=crossprod(X)
Xy=as.vector(crossprod(X,y))

priors=list(list(model="FIXED"),
            list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=1/100,counts=1e6),
            list(model="BRR",R2=NULL,df0=NULL,S0=NULL))
idPriors=c(1,rep(2,p/2),rep(3,p/2))

fm0=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0$ETA[[1]]$b,fm0$ETA[[2]]$b,fm0$ETA[[3]]$b)
plot(y,X%*%bHat)
plot(bHat)

#summary statistics
fm0s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0s$ETA[[1]]$b,fm0s$ETA[[2]]$b,fm0s$ETA[[3]]$b)
plot(y,X%*%bHat)
plot(bHat)

priors=list(list(model="FIXED"),
            list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=1/100,counts=1e6),
            list(model="BRR",R2=NULL,df0=NULL,S0=NULL),
            list(model="BayesA"))
idPriors=c(1,rep(2,333),rep(3,333),rep(4,334))

fm0=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0$ETA[[1]]$b,fm0$ETA[[2]]$b,fm0$ETA[[3]]$b,fm0$ETA[[4]]$b)
plot(y,X%*%bHat)
plot(bHat)

#summary statistics
fm0s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)

bHat=c(fm0s$ETA[[1]]$b,fm0s$ETA[[2]]$b,fm0s$ETA[[3]]$b,fm0$ETA[[4]]$b)
plot(y,X%*%bHat)
plot(bHat)
              

priors=list(list(model="FIXED"),
            list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=1/100,counts=1e6),
            list(model="BRR",R2=NULL,df0=NULL,S0=NULL),
            list(model="BayesA"),
            list(model="BayesB"))
idPriors=c(1,rep(2,250),rep(3,250),rep(4,250),rep(5,250))

fm0=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0$ETA[[1]]$b,fm0$ETA[[2]]$b,fm0$ETA[[3]]$b,fm0$ETA[[4]]$b,fm0$ETA[[5]]$b)
plot(y,X%*%bHat)
plot(bHat)

#summary statistics
fm0s=BLRCross(my=mean(y),vy=var(y),n=length(y),
              XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0s$ETA[[1]]$b,fm0s$ETA[[2]]$b,fm0s$ETA[[3]]$b,fm0s$ETA[[4]]$b,fm0s$ETA[[5]]$b)
plot(y,X%*%bHat)
plot(bHat)

priors=list(list(model="FIXED"),
            list(model="BayesC",R2=NULL,df0=NULL,S0=NULL,probIn=1/100,counts=1e6),
            list(model="BRR",R2=NULL,df0=NULL,S0=NULL),
            list(model="BayesA"),
            list(model="BayesB"),
            list(model="SSVS"))
idPriors=c(1,rep(2,200),rep(3,200),rep(4,200),rep(5,200),rep(6,200))

fm0=BLRCross(y=y,XX=XX,Xy=Xy,nIter=10000,burnIn=5000,priors=priors,idPriors=idPriors)
bHat=c(fm0$ETA[[1]]$b,fm0$ETA[[2]]$b,fm0$ETA[[3]]$b,fm0$ETA[[4]]$b,fm0$ETA[[5]]$b,fm0$ETA[[6]]$b)
plot(y,X%*%bHat)
plot(bHat)

#summary statistics
fm0s=BLRCross(my=mean(y),vy=var(y),n=length(y),XX=XX,Xy=Xy,nIter=10000,burnIn=5000,
              priors=priors,idPriors=idPriors)
bHat=c(fm0s$ETA[[1]]$b,fm0s$ETA[[2]]$b,fm0s$ETA[[3]]$b,fm0s$ETA[[4]]$b,
       fm0s$ETA[[5]]$b,fm0s$ETA[[6]]$b)
plot(y,X%*%bHat)
plot(bHat)


## End(Not run)

</code></pre>

<hr>
<h2 id='BLRXy'>Bayesian Linear Regression</h2><span id='topic+BLRXy'></span>

<h3>Description</h3>

<p>The BLRXy(&lsquo;Bayesian Linear Regression&rsquo;) function
fits various types of parametric Bayesian regressions to continuos outcomes.
This is a wrapper for function BLRCross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
BLRXy(y, intercept=TRUE, ETA, 
             nIter = 1500, burnIn = 500, thin = 5, 
             S0 = NULL, df0 = 5, R2 = 0.5, 
             verbose = TRUE, saveAt="",
             rmExistingFiles = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLRXy_+3A_y">y</code></td>
<td>
<p>(numeric, <code class="reqn">n</code>) the data-vector (NAs allowed).</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_intercept">intercept</code></td>
<td>
<p>(logical) indicates if an intercept is included.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_eta">ETA</code></td>
<td>
<p> (list) This is a two-level list used to specify the regression function (or linear predictor). 
Regression on covariates and other types of random effects are specified in this two-level list. For instance:
</p>
<pre>
ETA=list(list(X=W, model="FIXED"), 
              list(X=Z,model="BRR")),
</pre> 
<p>specifies that the linear predictor should include: an intercept (included by default), 
a linear regression on W with regression coefficients treated as fixed effects (i.e., flat prior), 
plus regression on Z, with regression coefficients modeled as in the 
Bayesian Ridge Regression.
</p>
<p>The following options are implemented for linear regressions: FIXED (flat prior),
BayesA, BayesB, BRR (Gaussian prior), BayesC, SSVS and RKHS. 
</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_niter">nIter</code>, <code id="BLRXy_+3A_burnin">burnIn</code>, <code id="BLRXy_+3A_thin">thin</code></td>
<td>
<p>(integer) the number of iterations, burn-in and thinning.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_saveat">saveAt</code></td>
<td>
<p>(string) this may include a path and a pre-fix that will be added to the name of the files that are saved as the program runs.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_s0">S0</code>, <code id="BLRXy_+3A_df0">df0</code></td>
<td>
<p> (numeric) The scale parameter for the scaled inverse-chi squared prior assigned to the residual variance, only used with Gaussian outcomes. 
In the parameterization of the scaled-inverse chi square in BGLR the expected values is <code>S0/(df0-2)</code>. The default value for the 
df parameter is 5. If the scale is not specified a value is calculated so that the prior mode of the residual 
variance  equals <code>var(y)*R2</code> (see below). For further details see the vignettes in the package.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_r2">R2</code></td>
<td>
<p>(numeric, <code>0&lt;R2&lt;1</code>) The proportion of variance that one expects, a priori, to be explained by the regression. Only used if 
the hyper-parameters are not specified; if that is the case, internaly, hyper-paramters are set so that the prior modes are consistent with the 
variance partition specified by R2 and the prior distribution is relatively flat at the mode. For 
further details see the vignettes in the package.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_verbose">verbose</code></td>
<td>
<p>(logical) if TRUE the iteration history is printed, default TRUE.</p>
</td></tr>
<tr><td><code id="BLRXy_+3A_rmexistingfiles">rmExistingFiles</code></td>
<td>
<p>(logical) if TRUE removes existing output files from previous runs, default TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez.
</p>


<h3>References</h3>

<p>de los Campos G., H. Naya, D. Gianola, J. Crossa, A. Legarra, E. Manfredi, K. Weigel and J. Cotes. 2009.
Predicting Quantitative Traits with Regression Models for Dense Molecular Markers and Pedigree. <em>Genetics</em> <b>182</b>: 375-385.
</p>
<p>de los Campos, G., D. Gianola, G. J. M., Rosa, K. A., Weigel, and J. Crossa. 2010.  Semi-parametric genomic-enabled prediction of genetic values using 
reproducing kernel Hilbert spaces methods. <em>Genetics Research</em>, <b>92</b>:295-308.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(BGLR)

p=1000
n=1500

data(mice)
X=scale(mice.X[1:n,1:p],center=TRUE)

A=mice.A
A=A[1:n,1:n]

QTL=seq(from=50,to=p-50,by=80)

b=rep(0,p)
b[QTL]=1
signal=as.vector(X%*%b)
 
error=rnorm(sd=sd(signal),n=n)
y=error+signal
y=2+y

#Example 1

#BayesA
ETA=list(list(X=X,model="BayesA"))

fm1=BLRXy(y=y,ETA=ETA)
plot(fm1$yHat,y)

#Example 2, missing values
yNA&lt;-y
whichNA&lt;-sample(1:length(y),size=100,replace=FALSE)
yNA[whichNA]&lt;-NA

fm2&lt;-BLRXy(y=yNA,ETA=ETA)
plot(fm2$yHat,y)
points(fm2$yHat[whichNA],y[whichNA],col="red",pch=19)

#Example 3, RKHS with no-missing values
ETA&lt;-list(list(K=A,model="RKHS"))
fm3&lt;-BLRXy(y=y,ETA=ETA)
plot(fm3$yHat,y)

#Example 4, RKHS with missing values
fm4&lt;-BLRXy(y=yNA,ETA=ETA)
plot(fm4$yHat,y)
points(fm4$yHat[whichNA],y[whichNA],col="red",pch=19)



## End(Not run)

</code></pre>

<hr>
<h2 id='getGCovar'>getGCovar</h2><span id='topic+getGCovar'></span>

<h3>Description</h3>

<p>Genetic co-variance matrix using MCMC samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getGCovar(X,B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGCovar_+3A_x">X</code></td>
<td>
<p>(numeric) matrix of covariates.</p>
</td></tr>
<tr><td><code id="getGCovar_+3A_b">B</code></td>
<td>
<p>(numeric) matrix that contains samples for regression coefficients, 3D array, 
with dim=c(nRow,p,traits), where nRow number of MCMC samples saved, p 
is the number of predictors and traits is the number of traits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genetic co-variance matrix.
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos.
</p>


<h3>References</h3>

<p>Lehermeier, C., G. de los Campos, V. Wimmer and C.-C. Schon. Genomic Variance Estimates: With or without Disequilibrium Covariances?. <em>J Anim Breed Genet.</em>, <b>134</b> (3): 232-241.
</p>

<hr>
<h2 id='getVariances'>getVariances</h2><span id='topic+getVariances'></span>

<h3>Description</h3>

<p>Computes the sample-variance (var()) for sets of markers as well as the total variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	getVariances(X, B, sets, verbose=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVariances_+3A_x">X</code></td>
<td>
<p>(numeric, <code class="reqn">n \times p</code>) incidence matrix for <code class="reqn">\boldsymbol \beta</code>.</p>
</td></tr>
<tr><td><code id="getVariances_+3A_b">B</code></td>
<td>
<p>(numeric), object returned by the function  readBinMat().</p>
</td></tr>
<tr><td><code id="getVariances_+3A_sets">sets</code></td>
<td>
<p>(numeric).</p>
</td></tr>
<tr><td><code id="getVariances_+3A_verbose">verbose</code></td>
<td>
<p>(logical), if TRUE it shows progress information in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with variances for markers as well as the total.	
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Demos

library(BGLR)
data(wheat)
y=wheat.Y[,1] ; X=scale(wheat.X)
dir.create('test_saveEffects')
setwd('test_saveEffects')
fm=BGLR(y=y,ETA=list(list(X=X,model='BayesB',saveEffects=TRUE)),nIter=12000,thin=2,burnIn=2000)
B=readBinMat('ETA_1_b.bin')
plot(B[,1],type='o',col=4)
VAR=getVariances(B=B,X=X,sets=sample(1:20,size=1279,replace=T))
head(VAR)
plot(VAR[,"total"])


## End(Not run)

</code></pre>

<hr>
<h2 id='mice'>mice dataset</h2><span id='topic+mice'></span>

<h3>Description</h3>

<p>The mice data comes from an experiment carried out to detect and locate QTLs for complex traits in a 
mice population (Valdar et al. 2006a; 2006b). This data has already been analyzed for comparing genome-assisted 
genetic evaluation methods (Legarra et al. 2008). The data file consists of 1814 individuals,  
each genotyped for 10,346 polymorphic markers. The information is related to 
obesity and biochemistry and other covariates related to the traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(mice)
</code></pre>


<h3>Format</h3>

<p>Matrix mice.A contains the pedigree.
The matrix mice.X contains the markes information and the map data.frame
contains information for the genetic map.
The data.frame mice.pheno contains phenotypical information.
</p>


<h3>References</h3>

<p>Legarra A., Robert-Granie, E. Manfredi, and J. M. Elsen, 2008 Performance of genomic selection in mice. Genetics 180:611-618.
</p>
<p>Valdar, W., L. C. Solberg, D. Gauguier, S. Burnett, P. Klenerman et al., 2006a Genome-wide genetic association of complex traits in heterogeneous stock mice. Nat. Genet. 38:879-887.
</p>
<p>Valdar, W., L. C. Solberg, D. Gauguier, W. O. Cookson, J. N. P. Rawlis et al., 2006b Genetic and environmental effects on complex traits in mice. Genetics, 174:959-984.
</p>

<hr>
<h2 id='mice.A'>Pedigree info for the mice dataset</h2><span id='topic+mice.A'></span>

<h3>Description</h3>

<p>Is a numerator relationship matrix (1814 x 1814) computed
from a pedigree that traced back many generations.
</p>


<h3>References</h3>

<p>de los Campos G., H. Naya, D. Gianola, J. Crossa, A. Legarra, E. Manfredi, K. Weigel and J. Cotes. 2009.
Predicting Quantitative Traits with Regression Models for Dense Molecular Markers and Pedigree. <em>Genetics</em> <b>182</b>: 375-385.
</p>

<hr>
<h2 id='mice.map'>Genetic map info for the mice dataset</h2><span id='topic+mice.map'></span>

<h3>Description</h3>

<p>Is a data.frame with 10436 rows and 4 columns: chr, snp_id, mbp and alleles.
</p>
<p>The data can be downloaded from http://mtweb.cs.ucl.ac.uk/mus/www/GSCAN/HS_GENOTYPES/.
</p>

<hr>
<h2 id='mice.pheno'>Phenotypical data for the mice dataset</h2><span id='topic+mice.pheno'></span>

<h3>Description</h3>

<p>A data frame with pheotypical information related to obesity and 
biochemistry. 
The data frame has several columns: SUBJECT.NAME, Obesity.BMI, Obesity.BodyLength, 
Obesity.Date.Month, Obesity.Date.Year, Obesity.Date.Season,
Obesity.Date.StudyStartSeconds, Obesity.Date.Hour, Obesity.Date.StudyDay,          
GENDER, Obesity.EndNormalBW, CoatColour, CageDensity, Litter,                        
cage, Biochem.Albumin, Biochem.ALP, Biochem.ALT,                   
Biochem.AST, Biochem.Calcium, Biochem.Chloride, Biochem.Creatinine,
Biochem.Glucose, Biochem.HDL, Biochem.LDL, Biochem.Phosphorous,           
Biochem.Potassium, Biochem.Sodium, Biochem.Tot.Cholesterol,
Biochem.Tot.Protein, Biochem.Triglycerides, Biochem.Urea,                  
Biochem.EndNormalBW, Biochem.Date.StudyDay, Biochem.Date.Season,
Biochem.Date.Month, Biochem.Date.Year and Biochem.Age.  
</p>
<p>The data can be downloaded from http://mtweb.cs.ucl.ac.uk/mus/www/GSCAN/HS_PHENOTYPES/.
</p>

<hr>
<h2 id='mice.X'>Molecular markers</h2><span id='topic+mice.X'></span>

<h3>Description</h3>

<p>Is a matrix ( 1814 x 10346) with SNP markers.
</p>
<p>The data can be downloaded from http://mtweb.cs.ucl.ac.uk/mus/www/GSCAN/HS_GENOTYPES/.
</p>

<hr>
<h2 id='Multitrait'>Multi trait models</h2><span id='topic+Multitrait'></span>

<h3>Description</h3>

<p>The Multitrait  function fits Bayesian multitrait models with arbitrary number of random effects ussing a Gibbs 
sampler. The data equation is as follows:
</p>
y<sub>j</sub> = 1&mu;<sub>j</sub> + X<sub>Fj</sub> &beta;<sub>Fj</sub>+X<sub>1</sub>&beta;<sub>j1</sub> + ... +X<sub>k</sub>&beta;<sub>jk</sub> + u<sub>j1</sub>+ ... + u<sub>jq</sub> + e<sub>j</sub>,
<p>where:
</p>

<ul>
<li>y<sub>j</sub> is a n-dimensional response vector of phenotypes (NAs allowed) with y<sub>ij</sub> representing the phenotypic record of the i-th subject for the j-th trait.
</li>
<li>&mu;<sub>j</sub> is an intercept.
</li>
<li>X<sub>Fj</sub> is a matrix of fixed effects.
</li>
<li>&beta;<sub>Fj</sub> is a vector of fixed effects.
</li>
<li>X<sub>s</sub> is an incidence matrix for predictors that are common for all individuals (e.g. markers), s=1,...,k.
</li>
<li>&beta;<sub>js</sub>  is a vector of regression coefficients, s=1,..,k. Different priors can be assigned to these regression coefficients (spike-slab and Gaussian) and regression coefficients are correlated across traits.
</li>
<li>u<sub>jr</sub> is a n-dimensional vector of random effects.
</li>
<li>e<sub>j</sub> is a n-dimensional vector of residuals.
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'> Multitrait(y, ETA, intercept=TRUE,resCov = list(df0=5,S0=NULL,type="UN"), 
   R2=0.5, nIter=1000,burnIn=500,thin=10, saveAt="",verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multitrait_+3A_y">y</code></td>
<td>
<p>a matrix of dimension <code class="reqn">n \times t</code>, where <code class="reqn">n</code> is the number of individials in each trait, 
<code class="reqn">t</code> is the number of traits, NAs are allowed.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_eta">ETA</code></td>
<td>
<p> (list) This is a two-level list used to specify the regression function (or linear predictor). 
Regression on covariates and other types of random effects are specified in this two-level list. For instance:
</p>
<pre>ETA=list(list(X=W, model="FIXED"), 
      list(X=Z,model="BRR"), 
      list(K=G,model="RKHS"))</pre> 
<p>specifies that the linear predictor should include: a linear regression on W with regression 
coefficients treated as fixed effects (i.e., flat prior), plus regression on Z, with regression 
coefficients modeled as in the Ridge Regression plus and a random effect with co-variance structure G.
</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_intercept">intercept</code></td>
<td>
<p>logical, if TRUE (default) an intercept is included.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_niter">nIter</code>, <code id="Multitrait_+3A_burnin">burnIn</code>, <code id="Multitrait_+3A_thin">thin</code></td>
<td>
<p>(integer) the number of iterations, burn-in and thinning.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_rescov">resCov</code></td>
<td>
<p>A list used to define the co-variance matrix for model residuals (R). Four covariance strucures are 
supported: i) Unstructured (<code>"UN"</code>), ii)Diagonal (<code>"DIAG"</code>), iii)Factor Analytic (<code>"FA"</code>) 
and  iv)Recursive (<code>"REC"</code>), for example: 
</p>
<pre>resCov=list(type="UN", df0=4, S0=V)</pre> 
<p>specifies an UN-structured covariance matrix, 
with an Inverse Whishart prior with degree of freedom df0 (scalar) and scale matrix (t x t) V.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_saveat">saveAt</code></td>
<td>
<p>(string) this may include a path and a pre-fix that will be added to the name of the files that are saved as the program runs.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_r2">R2</code></td>
<td>
<p>(numeric, <code>0&lt;R2&lt;1</code>) The proportion of co-variance that one expects, a priori, to be explained by the regression. Only used if 
the hyper-parameters are not specified; if that is the case, internaly, hyper-paramters are set so that the prior modes are consistent with the 
co-variance partition specified by R2 and the prior distribution is relatively flat at the mode.</p>
</td></tr>
<tr><td><code id="Multitrait_+3A_verbose">verbose</code></td>
<td>
<p>(logical) if TRUE the iteration history is printed, default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Conditional distribution of the data</em>
</p>
<p>Model residuals are assumed to follow a multivariate normal distribution, with null mean and 
covariance matrix   Cov((e'<sub>1</sub>,...,e'<sub>n</sub>)')=R<sub>0</sub> &otimes; I
where R<sub>0</sub> is a t x t (within-subject) covariance matrix of model residuals
and n-dimensional identity matrix. Therefore:
</p>
p(y<sub>i1</sub>,...,y<sub>it</sub> | &theta; )=MN(&eta;<sub>i</sub>, R<sub>0</sub>)
<p>where MN(.,.), denotes the multivariate normal distribution with mean 
&eta;<sub>i</sub> and covariance matrix 
R<sub>0</sub>; here 
&eta;<sub>i</sub> is 
a t-dimensional vector whose entries
are the expected values of the response variable for the i-th individual. 
</p>
<p><em>Prior distribution</em>
</p>
<p>The prior distribution is structured hierarchically. The first level of the prior specifies the distribution 
of the fixed and random effects given the codispersion parameters 
(the covariance matrices of the random effects, see below). 
The priors for the codispersion parameters are specified in a deeper level of the hierarchy.
</p>
<p>The intercepts and vectors of fixed effects are assigned flat prior 
(each unknown is assigned a Gaussian prior with null mean and very large variance).
</p>
<p>The vectors of random effects u<sub>r</sub> 
are assigned independent multivariate normal priors with null mean and covariance matrices 
Cov(u<sub>r</sub>)=G<sub>r</sub>&otimes;K<sub>r</sub>,
u<sub>r</sub> represent the vector of effects for the 
r-th random effects (sorted by subject first and trait within subject),
G<sub>r</sub> is an t x t (within-subject) covariance matrix
of the r-th random effect and K<sub>r</sub> is 
a user defined (between subjects) covariance matrix for the r-th
random effect, for instance, may be a pedigree or marker-based 
relationship matrix. The covariance matrix of random effects are assigned Inverse Wishart
priors (for the case of unstructured options) or priors that are structured according to
some model (diagonal, factor analytic or recursive).
</p>
<p>The vector or regression coefficients &beta;<sub>s</sub>
are assigned Gaussian  and Spike Slab priors whose 
covariance matrixes depend on a &Omega;<sub>s</sub>
covariance matrix of dimmensions t x t (within subject).
The covariance matrix of random effects are assigned Inverse Wishart
priors (for the case of unstructured options) or priors that are structured according to
some model (diagonal, factor analytic or recursive).
</p>
<p><em>Algorithm</em>
</p>
<p>Internally, samples from all the model unknowns are drawn using a Gibbs sampler 
(i.e., based on fully conditional distributions).
</p>


<h3>Value</h3>

<p>List containing estimated posterior means and estimated posterior
standard deviations.
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez-Rodriguez
</p>


<h3>References</h3>

<p>Burgueno, J., G. de los Campos, K. Weigel and J. Crossa. 2012. Genomic Prediction of Breeding Values when Modelling
Genotype x Environment Interaction using Pedigree and Dense Molecular Markers. <em>Crop Sci.</em>, <b>52(2)</b>:707-719.
</p>
<p>de los Campos, G. and  D. Gianola. 2007. Factor analysis models for structuring covariance matrices of additive genetic 
effects: a Bayesian implementation. <em>Genet. Sel. Evol.</em>, <b>39</b>:481-494.
</p>
<p>Cheng, H.,  K. Kadir, J., Zeng, D. Garrick and R. Fernando. 2018. Genomic Prediction from Multiple-Trait 
Bayesian Regression Methods Using Mixture Priors. <em>Genetics</em>, <b>209(1)</b>: 89-103.
</p>
<p>Sorensen, D. and D. Gianola. 2002. Likelihood, Bayesian, and MCMC methods in quantitative genetics. 
<em>Springer-Verlag, New York</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
	
library(BGLR)
data(wheat)
X&lt;-wheat.X
K&lt;-wheat.A
y&lt;-wheat.Y

#Example 1, Spike Slab regression
ETA1&lt;-list(list(X=X,model="SpikeSlab"))

fm1&lt;-Multitrait(y=y,ETA=ETA1,nIter=1000,burnIn=500)

#Example 2, Ridge Regression
ETA2&lt;-list(list(X=X,model="BRR"))
fm2&lt;-Multitrait(y=y,ETA=ETA2,nIter=1000,burnIn=500)

#Example 3, Random effects with user defined covariance structure
#for individuals derived from pedigree
ETA3&lt;-list(list(K=K,model="RKHS"))
fm3&lt;-Multitrait(y=y,ETA=ETA3,nIter=1000,burnIn=500)

#Example 4, Markers and pedigree
ETA4&lt;-list(list(X=X,model="BRR"), list(K=K,model="RKHS"))

fm4&lt;-Multitrait(y=y,ETA=ETA4,nIter=1000,burnIn=500)

#Example 5, recursive structures for within subject covariance matrix
M1 &lt;- matrix(nrow = 4, ncol = 4, FALSE)
M1[3, 2] &lt;- M1[4, 2] &lt;- TRUE # Adding recursion from trait 2 onto traits 3 and 4
M1[4, 3] &lt;- TRUE # Adding recursion from trait 3 on trait 4

ETA5&lt;-list(list(K=K,model="RKHS",Cov=list(type="REC",M=M1)))
fm5&lt;-Multitrait(y=y,ETA=ETA5,nIter=1000,burnIn=500)

#Example 6, diagonal residual covariance matrix with the predictor 
#used in example 5
residual1&lt;-list(type="DIAG")
fm6&lt;-Multitrait(y=y,ETA=ETA5,resCov=residual1,nIter=1000,burnIn=500)


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.BGLR'>Plots for BGLR Analysis</h2><span id='topic+plot.BGLR'></span>

<h3>Description</h3>

<p>Plots observed vs predicted values for objects of class BGLR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BGLR_+3A_x">x</code></td>
<td>
<p>An object of class <code>BGLR</code>.</p>
</td></tr>
<tr><td><code id="plot.BGLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>See Also</h3>

<p><code>BGLR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

setwd(tempdir())
library(BGLR)
data(wheat)
out=BLR(y=wheat.Y[,1],XL=wheat.X)
plot(out)


## End(Not run)

</code></pre>

<hr>
<h2 id='predict.BGLR'>Model Predictions</h2><span id='topic+predict.BGLR'></span>

<h3>Description</h3>

<p>extracts predictions from the results
of BGLR function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLR'
predict(object, newdata, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BGLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>BGLR</code>.</p>
</td></tr>
<tr><td><code id="predict.BGLR_+3A_newdata">newdata</code></td>
<td>
<p>Currently not supported, for new data you should assing missing value indicator (NAs) to the corresponding entries in the 
response vector (y).</p>
</td></tr>
<tr><td><code id="predict.BGLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>See Also</h3>

<p><code>BGLR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

setwd(tempdir())
library(BGLR)
data(wheat)
out=BLR(y=wheat.Y[,1],XL=wheat.X)
predict(out)


## End(Not run)

</code></pre>

<hr>
<h2 id='read_bed'>read_bed</h2><span id='topic+read_bed'></span>

<h3>Description</h3>

<p>This function reads genotype information stored in  binary PED (BED) files used in plink.
These files save space and time. The pedigree/phenotype information is stored in a separate file (*.fam) 
and the map information is stored in an extededed MAP file (*.bim) that contains information about the allele names, 
which would otherwise be lost in the BED file. More details <a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read_bed(bed_file,bim_file,fam_file,na.strings,verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bed_+3A_bed_file">bed_file</code></td>
<td>
<p>binary file with genotype information.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_bim_file">bim_file</code></td>
<td>
<p>text file with pedigree/phenotype information.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_fam_file">fam_file</code></td>
<td>
<p>text file with extended map information.</p>
</td></tr>
<tr><td><code id="read_bed_+3A_na.strings">na.strings</code></td>
<td>
<p>missing value indicators, default=c(&quot;0&quot;,&quot;-9&quot;).</p>
</td></tr>
<tr><td><code id="read_bed_+3A_verbose">verbose</code></td>
<td>
<p>logical, if true print hex dump of bed file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The routine will return a vector of dimension n*p (n=number of individuals, p=number of snps), with the snps(individuals) stacked, 
depending whether the BED file is in SNP-major or individual-major mode.
</p>
<p>The vector contains integer codes:
</p>

<table>
<tr>
 <td style="text-align: left;">
   Integer code </td><td style="text-align: left;"> Genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> 00 Homozygote "1"/"1" </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 01 Heterozygote </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 10 Missing genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 11 Homozygote "2"/"2" </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(BGLR)
demo(read_bed)


## End(Not run)

</code></pre>

<hr>
<h2 id='read_ped'>read_ped</h2><span id='topic+read_ped'></span>

<h3>Description</h3>

<p>This function reads genotype information stored in  PED format used in plink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read_ped(ped_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ped_+3A_ped_file">ped_file</code></td>
<td>
<p>ASCII file with genotype information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PED file is a white-space (space or tab) delimited file: the first six columns are mandatory:
</p>
<p>Family ID
Individual ID
Paternal ID
Maternal ID
Sex (1=male; 2=female; other=unknown)
Phenotype
</p>
<p>The IDs are alphanumeric: the combination of family and individual ID should uniquely identify a person. 
A PED file must have 1 and only 1 phenotype in the sixth column. The phenotype can be either a quantitative 
trait or an affection status column.
</p>


<h3>Value</h3>

<p>The routine will return a vector of dimension n*p (n=number of individuals, p=number of snps), with the snps stacked.
</p>
<p>The vector contains integer codes:
</p>

<table>
<tr>
 <td style="text-align: left;">
   Integer code </td><td style="text-align: left;"> Genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> 00 Homozygote "1"/"1" </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 01 Heterozygote </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 10 Missing genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 11 Homozygote "2"/"2" </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(BGLR)
demo(read_ped)


## End(Not run)

</code></pre>

<hr>
<h2 id='readBinMat'>readBinMat</h2><span id='topic+readBinMat'></span>

<h3>Description</h3>

<p>Function to read effects saved by BGLR when ETA[[j]]$saveEffects=TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	readBinMat(filename,byrow=TRUE,storageMode="double")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readBinMat_+3A_filename">filename</code></td>
<td>
<p>(string), the name of the file to be read.</p>
</td></tr>
<tr><td><code id="readBinMat_+3A_byrow">byrow</code></td>
<td>
<p>(logical), if TRUE the matrix is created by filling its corresponding elements by rows.</p>
</td></tr>
<tr><td><code id="readBinMat_+3A_storagemode">storageMode</code></td>
<td>
<p>(character), the storage mode used to save effects via ETA[[j]]$storageMode: 'double' (default) or 'single'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with samples of regression coefficients.	
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#Demos

library(BGLR)
data(wheat)
y=wheat.Y[,1] ; X=scale(wheat.X)
dir.create('test_saveEffects')
setwd('test_saveEffects')
fm=BGLR(y=y,ETA=list(list(X=X,model='BayesB',saveEffects=TRUE)),nIter=12000,thin=2,burnIn=2000)
B=readBinMat('ETA_1_b.bin')


## End(Not run)

</code></pre>

<hr>
<h2 id='readBinMatMultitrait'>readBinMatMultitrait</h2><span id='topic+readBinMatMultitrait'></span>

<h3>Description</h3>

<p>Function to read effects saved by Multitrait when ETA[[j]]$saveEffects=TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	readBinMatMultitrait(filename,storageMode="double")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readBinMatMultitrait_+3A_filename">filename</code></td>
<td>
<p>(string), the name of the file to be read.</p>
</td></tr>
<tr><td><code id="readBinMatMultitrait_+3A_storagemode">storageMode</code></td>
<td>
<p>(character), the storage mode used to save effects via ETA[[j]]$storageMode: 'double' (default) or 'single'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D array, with dim=c(nRow,p,traits), where nRow number of MCMC samples saved,
p is the number of predictors and traits is the number of traits. 
</p>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez-Rodriguez.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(BGLR)

data(wheat)
y&lt;-wheat.Y 
X&lt;-wheat.X

fm&lt;-Multitrait(y=y,ETA=list(list(X=X,model='BRR',saveEffects=TRUE)),
                      nIter=1000,thin=10,burnIn=500)
                      
 B&lt;-readBinMatMultitrait('ETA_1_beta.bin')


## End(Not run)

</code></pre>

<hr>
<h2 id='residuals.BGLR'>Extracts models residuals</h2><span id='topic+residuals.BGLR'></span>

<h3>Description</h3>

<p>extracts model residuals from objects returned by BGLR function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLR'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.BGLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>BGLR</code>.</p>
</td></tr>
<tr><td><code id="residuals.BGLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>See Also</h3>

<p><code>BGLR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

setwd(tempdir())
library(BGLR)
data(wheat)
out=BLR(y=wheat.Y[,1],XL=wheat.X)
residuals(out)


## End(Not run)

</code></pre>

<hr>
<h2 id='simulated3t'>simulated data for 3 traits</h2><span id='topic+simulated3t'></span>

<h3>Description</h3>

<p>Simulated dataset for three traits. Markers, QTL and phenotypes are
simulated for three traits. Here we extend the simulation scheme 
described by Cheng et al. (2018) for the case of three traits.  So we
simulated 100 evenly spaced loci on each of 4 chromosomes of length
10 cM. We selected 10 loci on each chromosome as QTL. We sampled
states from Bernoulli distribution with p=0.5. After that
we simulated 500 generations to obtain linkage disequilibrium using 
500 males and 500 females that were mated at random. 
Random mating was continued for 5 more generations and 
population size was increased to 4000 males and 4000 females. 
The QTL on chromosome 1 has effect on trait 1, wherehas 
chomosomes 1 and 2 had effects on traits 2 and 3 respectively.
The QTL on chromosome 4 had effects on the 3 traits. The effects 
of QTL on chromosome 4 were simulated from a multivariate
normal distribution with null mean and variance covariance matrix:
</p>
<pre>
1.00	 0.75  0.50
0.75	 1.00  0.75  
0.50	 0.75  1.00
 </pre> 
<p>The genetic values were scaled to have variance 1.0.
The phenotypes  for these traits were obtained by 
adding residuals to genetic values, residuals were 
simulated from a multivariate normal distribution 
with null mean and covariance matrix: 
</p>
<pre>
6.0  6.0  1.0
6.0  8.0  2.0  
1.0  2.0  1.0
 </pre> 
<p>In total, 8000 individuals were simulated and the genetic covariance 
matrix is:
</p>
<pre>
1.00  0.34  0.07
0.34  1.00  0.21 
0.07  0.21  1.00 
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>  data(simulated3t)
</code></pre>


<h3>Format</h3>

<p>Matrix simulated3t.X contains the marker information.
Matrix simulated3t.pheno contains the phenotypical information.
</p>


<h3>References</h3>

<p>Cheng, H.,  K. Kadir, J., Zeng, D. Garrick and R. Fernando. 2018. Genomic Prediction from Multiple-Trait 
Bayesian Regression Methods Using Mixture Priors. <em>Genetics</em>, <b>209(1)</b>: 89-103.
</p>

<hr>
<h2 id='simulated3t.pheno'>Phenotypical data for simulated dataset with 3 traits</h2><span id='topic+simulated3t.pheno'></span>

<h3>Description</h3>

<p>A matrix with 8000 rows and 6 columns.
Columns 1 to 3 corresponds to simulated phenotypes for 3 traits,
columns 4-6 corresponds to true simulated genetic values for 3 traits.
</p>

<hr>
<h2 id='simulated3t.X'>Molecular markers</h2><span id='topic+simulated3t.X'></span>

<h3>Description</h3>

<p>Is a matrix ( 8000 x 327) with recoded SNP markers for additive effects as 0, 1, 2.
</p>

<hr>
<h2 id='summary.BGLR'>summary for BGLR fitted models</h2><span id='topic+summary.BGLR'></span>

<h3>Description</h3>

<p>Gives a summary for a fitted model using BGLR function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGLR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BGLR_+3A_object">object</code></td>
<td>
<p>An object of class <code>BGLR</code>.</p>
</td></tr>
<tr><td><code id="summary.BGLR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>See Also</h3>

<p><code>BGLR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

setwd(tempdir())
library(BGLR)
data(wheat)
out=BLR(y=wheat.Y[,1],XL=wheat.X)
summary(out)


## End(Not run)

</code></pre>

<hr>
<h2 id='vech'>Extract Lower Triangular Elements from a Symmetric Matrix</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>This function takes a symmetric matrix and extracts a list of all lower
triangular elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p>A symmetric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks to make sure the matrix is square, but it does not
check for symmetry (it just pulls the lower triangular elements).  The
elements are stored in column major order.  The original matrix can be
restored using the <code>xpnd</code> command.
</p>


<h3>Value</h3>

<p>A list of the lower triangular elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xpnd">xpnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   symmat &lt;- matrix(c(1,2,3,4,2,4,5,6,3,5,7,8,4,6,8,9),4,4)
   vech(symmat)

</code></pre>

<hr>
<h2 id='wheat'>wheat dataset</h2><span id='topic+wheat'></span>

<h3>Description</h3>

<p>Information from a collection of 599 historical CIMMYT wheat lines.  The wheat data set is from 
CIMMYT's Global Wheat Program. Historically, this program has conducted numerous international 
trials across a wide variety of wheat-producing environments. The environments represented in 
these trials were grouped into four basic target sets of environments comprising four 
main agroclimatic regions previously defined and widely used by CIMMYT's Global Wheat Breeding Program. 
The phenotypic trait considered here was the average grain yield (GY) of the 599 wheat lines evaluated 
in each of these four mega-environments. 
</p>
<p>A pedigree tracing back many generations was available, and the Browse application of 
the International Crop Information System (ICIS), as described in 
<a href="https://repository.cimmyt.org/xmlui/bitstream/handle/10883/3488/72673.pdf">https://repository.cimmyt.org/xmlui/bitstream/handle/10883/3488/72673.pdf</a> (McLaren <em>et al.</em> 2000, 2005) was used 
for deriving the relationship matrix A among the 599 lines; it accounts for selection and inbreeding.
</p>
<p>Wheat lines were recently genotyped using 1447 Diversity Array Technology (DArT) generated by 
Triticarte Pty. Ltd. (Canberra, Australia; <a href="https://www.diversityarrays.com">https://www.diversityarrays.com</a>). The DArT markers 
may take on two values, denoted by their presence or absence. Markers with a minor allele frequency 
lower than 0.05 were removed, and missing genotypes were imputed with samples from the marginal 
distribution of marker genotypes, that is, <code class="reqn">x_{ij}=Bernoulli(\hat p_j)</code>, where  <code class="reqn">\hat p_j</code>  
is the estimated allele frequency computed from the non-missing genotypes. The number of DArT 
MMs after edition was 1279.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(wheat)
</code></pre>


<h3>Format</h3>

<p>Matrix Y contains the average grain yield, column 1: Grain yield for environment 1 and so on. The matrix A contains additive relationship
computed from the pedigree and matrix X contains the markers information. 
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>McLaren, C. G., L. Ramos, C. Lopez, and W. Eusebio. 2000. &ldquo;Applications of the geneaology manegment system.&rdquo; 
In <em>International Crop Information System. Technical  Development Manual, version VI</em>, edited by McLaren, C. G., J.W. White 
and P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT and IRRI. 
</p>
<p>McLaren, C. G., R. Bruskiewich, A.M. Portugal, and A.B. Cosico. 2005. The International Rice Information System. 
A platform for meta-analysis of rice crop data. <em>Plant Physiology</em> <b>139</b>: 637-642.
</p>

<hr>
<h2 id='wheat.A'>Pedigree info for the wheat dataset</h2><span id='topic+wheat.A'></span>

<h3>Description</h3>

<p>Is a numerator relationship matrix (599 x 599) computed
from a pedigree that traced back many generations.
This relationship matrix was derived using the
Browse application of the International Crop Information
System (ICIS), as described in  
<a href="https://repository.cimmyt.org/xmlui/bitstream/handle/10883/3488/72673.pdf">https://repository.cimmyt.org/xmlui/bitstream/handle/10883/3488/72673.pdf</a> (McLaren <em>et al.</em> 2000, 2005).
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>McLaren, C. G., L. Ramos, C. Lopez, and W. Eusebio. 2000. &ldquo;Applications of the geneaology manegment system.&rdquo;
In <em>International Crop Information System. Technical  Development Manual, version VI</em>, edited by McLaren, C. G., J.W. White
and P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT and IRRI.
</p>
<p>McLaren, C. G., R. Bruskiewich, A.M. Portugal, and A.B. Cosico. 2005. The International Rice Information System. 
A platform for meta-analysis of rice crop data. <em>Plant Physiology</em> <b>139</b>: 637-642.
</p>

<hr>
<h2 id='wheat.sets'>Sets for cross validation (CV)</h2><span id='topic+wheat.sets'></span>

<h3>Description</h3>

<p>Is a vector (599 x 1) that assigns observations to 10
disjoint sets; the assignment was generated at random.
This is used later to conduct a 10-fold CV.
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>

<hr>
<h2 id='wheat.X'>Molecular markers</h2><span id='topic+wheat.X'></span>

<h3>Description</h3>

<p>Is a matrix (599 x 1279) with DArT genotypes; data are
from pure lines and genotypes were coded as 0/1 denoting
the absence/presence of the DArT. Markers with a
minor allele frequency lower than 0.05 were removed, and
missing genotypes were imputed with samples from the
marginal distribution of marker genotypes, that is, <code class="reqn">x_{ij}=Bernoulli(\hat p_j)</code>, where  <code class="reqn">\hat p_j</code>  
is the estimated allele frequency computed from the non-missing genotypes. The number of DArT 
MMs after edition was 1279.
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>

<hr>
<h2 id='wheat.Y'>Grain yield</h2><span id='topic+wheat.Y'></span>

<h3>Description</h3>

<p>A matrix (599 x 4) containing the 2-yr average grain
yield of each of these lines in each of the four environments
(phenotypes were standardized to a unit variance within each environment).
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>

<hr>
<h2 id='write_bed'>write_bed</h2><span id='topic+write_bed'></span>

<h3>Description</h3>

<p>This function writes genotype information into  a binary PED (BED) filed used in plink.
For more details about this format see  <a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write_bed(x,n,p,bed_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_bed_+3A_n">n</code></td>
<td>
<p>integer, number of individuals.</p>
</td></tr>
<tr><td><code id="write_bed_+3A_p">p</code></td>
<td>
<p>integer, number of SNPs.</p>
</td></tr>
<tr><td><code id="write_bed_+3A_x">x</code></td>
<td>
<p>integer vector that contains the genotypic information coded as 0,1,2 and 3 (see details below). 
The information must be in snp major order. The vector should be of dimension n*p with the snps stacked.</p>
</td></tr>
<tr><td><code id="write_bed_+3A_bed_file">bed_file</code></td>
<td>
<p>output binary file with genotype information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector contains integer codes:
</p>

<table>
<tr>
 <td style="text-align: left;">
   Integer code </td><td style="text-align: left;"> Genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> 00 Homozygote "1"/"1" </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> 01 Heterozygote </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> 10 Missing genotype </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 11 Homozygote "2"/"2" </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Gustavo de los Campos, Paulino Perez Rodriguez,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(BGLR)
demo(write_bed)


## End(Not run)

</code></pre>

<hr>
<h2 id='xpnd'>Expand a Vector into a Symmetric Matrix</h2><span id='topic+xpnd'></span>

<h3>Description</h3>

<p>This function takes a vector of appropriate length (typically created using
<code>vech</code>) and creates a symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpnd(x, nrow = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpnd_+3A_x">x</code></td>
<td>
<p>A list of elements to expand into symmetric matrix.</p>
</td></tr>
<tr><td><code id="xpnd_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows (and columns) in the returned matrix.  Look
into the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is particularly useful when dealing with variance covariance
matrices. Note that R stores matrices in column major order, and that the
items in <code>x</code> will be recycled to fill the matrix if need be.
</p>
<p>The number of rows can be specified or automatically computed from the
number of elements in a given object via <code class="reqn">(-1 + \sqrt{(1 + 8 *
length(x))}) / 2</code>.
</p>


<h3>Value</h3>

<p>An <code class="reqn">(nrows \times nrows)</code> symmetric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech">vech</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  xpnd(c(1,2,3,4,4,5,6,7,8,9),4)
  xpnd(c(1,2,3,4,4,5,6,7,8,9))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
