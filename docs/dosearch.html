<!DOCTYPE html><html><head><title>Help for package dosearch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dosearch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bivariate_missingness'><p>Systematic Analysis of Bivariate Missing Data Problems</p></a></li>
<li><a href='#dosearch'><p>Identify a causal effect from arbitrary experiments and observations</p></a></li>
<li><a href='#dosearch-package'><p>Causal Effect Identification from Multiple Incomplete Data Sources</p></a></li>
<li><a href='#get_benchmark'><p>Benchmark a specific run of the search</p></a></li>
<li><a href='#get_derivation'><p>Retrieve the derivation of a causal query</p></a></li>
<li><a href='#get_formula'><p>Retrieve the identifying formula of a causal query</p></a></li>
<li><a href='#is_identifiable'><p>Query whether the target distribution was identifiable or not</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Title:</td>
<td>Causal Effect Identification from Multiple Incomplete Data
Sources</td>
</tr>
<tr>
<td>Description:</td>
<td>Identification of causal effects from arbitrary observational and experimental probability distributions via do-calculus and standard probability manipulations using a search-based algorithm by Tikka et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v099.i05">doi:10.18637/jss.v099.i05</a>&gt;. Allows for the presence of mechanisms related to selection bias (Bareinboim, E. and Tian, J. (2015) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r445.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r445.pdf</a>), transportability (Bareinboim, E. and Pearl, J. (2014) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r443.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r443.pdf</a>), missing data (Mohan, K. and Pearl, J. and Tian., J. (2013) <a href="http://ftp.cs.ucla.edu/pub/stat_ser/r410.pdf">http://ftp.cs.ucla.edu/pub/stat_ser/r410.pdf</a>) and arbitrary combinations of these. Also supports identification in the presence of context-specific independence (CSI) relations through labeled directed acyclic graphs (LDAG). For details on CSIs see Corander et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.apal.2019.04.004">doi:10.1016/j.apal.2019.04.004</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.19)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dagitty, DOT, igraph</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Santtu Tikka <a href="https://orcid.org/0000-0003-4039-4342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Antti Hyttinen <a href="https://orcid.org/0000-0002-6649-3229"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Juha Karvanen <a href="https://orcid.org/0000-0001-5530-769X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santtu Tikka &lt;santtuth@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-19 12:45:12 UTC; Santtu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-19 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bivariate_missingness'>Systematic Analysis of Bivariate Missing Data Problems</h2><span id='topic+bivariate_missingness'></span>

<h3>Description</h3>

<p>This data set contains the results of a systematic analysis of all missing data problems of two variables. Each problem is associated with a graph containing two vertices, <code class="reqn">X</code> and <code class="reqn">Y</code>, and their response indicators, R<sub>X</sub> and R<sub>Y</sub>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bivariate_missingness)</code></pre>


<h3>Format</h3>

<p>A data frame with 6144 rows and 8 variables:
</p>

<dl>
<dt>graph</dt><dd><p>the graph of the instance, see <code><a href="#topic+get_derivation">get_derivation</a></code> for more details on the syntax </p>
</dd>
<dt>nedges</dt><dd><p>number of edges in the graph (directed and bidirected) </p>
</dd>
<dt>arrowXtoY</dt><dd><p>whether the graph contains an arrow from <code class="reqn">X</code> to <code class="reqn">Y</code> or not </p>
</dd>
<dt>jointXY</dt><dd><p>identifiability of the joint distribution of <code class="reqn">X</code> and <code class="reqn">Y</code> </p>
</dd>
<dt>marginX</dt><dd><p>identifiability of the marginal distribution of <code class="reqn">X</code> </p>
</dd>
<dt>marginY</dt><dd><p>identifiability of the marginal distribution of <code class="reqn">Y</code> </p>
</dd>
<dt>YcondX</dt><dd><p>identifiability of the conditional distribution of <code class="reqn">Y</code> given <code class="reqn">X</code> </p>
</dd>
<dt>YdoX</dt><dd><p>identifiability of the causal effect of <code class="reqn">X</code> on <code class="reqn">Y</code> </p>
</dd>
</dl>
 


<h3>Source</h3>

<p>Tikka et. al. (2019) &lt;arXiv:1902.01073&gt;</p>

<hr>
<h2 id='dosearch'>Identify a causal effect from arbitrary experiments and observations</h2><span id='topic+dosearch'></span>

<h3>Description</h3>

<p>Identify a causal <code>query</code> from available <code>data</code> in a causal model described by a <code>graph</code> that is a semi-Markovian DAG or a labeled directed acyclic graph (LDAG). For DAGs, special mechanisms related to transportability of causal effects, recoverability from selection bias and identifiability under missing data can also be included. </p>


<h3>Usage</h3>

<pre><code class='language-R'>dosearch(data, query, graph, 
         transportability, selection_bias, missing_data, 
         control)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dosearch_+3A_data">data</code></td>
<td>
<p>a character string describing the available distributions in the package syntax. Alternatively, a list of character vectors. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_query">query</code></td>
<td>
<p>a character string describing the target distribution in the package syntax. Alternatively, a character vector. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_graph">graph</code></td>
<td>
<p>a character string describing either a DAG or an LDAG in the package syntax. Alternatively, an &quot;igraph&quot; graph as used in the &quot;causaleffect&quot; package or a DAG constructed using the &quot;dagitty&quot; package. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_transportability">transportability</code></td>
<td>
<p>a character string describing the transportability nodes of the model in the package syntax (for DAGs only). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_selection_bias">selection_bias</code></td>
<td>
<p>a character string describing the selection bias nodes of the model in the package syntax (for DAGs only). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_missing_data">missing_data</code></td>
<td>
<p>a character string describing the missing data mechanisms of the model in the package syntax (for DAGs only). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="dosearch_+3A_control">control</code></td>
<td>
<p>a <a href="base.html#topic+list">list</a> of control parameters. See &lsquo;Details&rsquo;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> is used to list the available input distributions. When <code>graph</code> is a DAG the distributions should be of the form
</p>
<p> P(A<sub>i</sub>|do(B<sub>i</sub>),C<sub>i</sub>) </p>
<p>Individual variables within sets should be separated by a comma. For example, three input distributions
</p>
<p> P(Z|do(X)), P(W,Y|do(Z,X)), P(W,Y,X|Z) </p>
<p>should be given as follows: 
</p>
<pre>
&gt; data &lt;- "
+  P(Z|do(X))
+  P(W,Y|do(Z,X))
+  P(W,Y,X|Z)
+"
</pre>
<p>The use of multiple do-operators is not permitted. Furthermore, when both conditioning variables and a do-operator are present, every conditioning variable must either precede the do-operator or follow it. When <code>graph</code> is an LDAG, the do-operation is represented by an intervention node, i.e.,
</p>
<p>P(Y|do(X),Z) = P(Y|X,Z,I_X = 1)</p>
<p>For example, in the case of the previous example in an LDAG, the three input distributions become:
</p>
<pre>
&gt; data &lt;- "
+  P(Z|X,I_X = 1)
+  P(W,Y|Z,X,I_X=1,I_Z=1)
+  P(W,Y,X|Z)
+"
</pre>
<p>The intervention nodes <code class="reqn">I_X</code> and <code class="reqn">I_Z</code> must be explicitly defined in the <code>graph</code> along with the relevant labels for the edges.
</p>
<p><code>query</code> is the target distribution of the search. It has the same syntax as <code>data</code>, but only a single distribution should be given.
</p>
<p><code>graph</code> is a description of a directed acyclic graph where directed edges are denoted by <code>-&gt;</code> and bidirected arcs corresponding to unobserved confounders are denoted by <code>&lt;-&gt;</code> (or by <code>--</code>). As an example, a DAG with two directed edges and one bidirected edge is constructed as follows: 
</p>
<pre>
&gt; graph &lt;- "
+  X -&gt; Z
+  Z -&gt; Y
+  X &lt;-&gt; Y
+"
</pre>
<p>Some alternative formats for DAGs are supported as well. Graphs created using the <code>igraph</code> package in the <code>causal.effect</code> syntax can be used here. Similarly, DAGs created using <code>dagitty</code> are supported.
</p>
<p>LDAGs are constructed similarly with the addition of labels and with the omission bidirected edges (latent variables must be explicitly defined). As an example, an LDAG with two labeled edges can be constructed as follows:
</p>
<pre>
  &gt; graph &lt;- "
+  X -&gt; Z : A = 0
+  Z -&gt; Y : A = 1
+  A -&gt; Z
+  A -&gt; Y
+"
</pre>
<p>Here the labels indicate that the edge from <code class="reqn">X</code> to <code class="reqn">Z</code> vanishes when <code class="reqn">A</code> has the value 0 and the edge from <code class="reqn">Z</code> to <code class="reqn">Y</code> vanishes when A has the value 1. Multiple labels on the same edge should be separated by a semi-colon. 
</p>
<p><code>transportability</code> enumerates the nodes that should be understood as transportability nodes responsible for discrepancies between domains. Individual variables should be separated by a comma. See e.g., Bareinboim and Pearl (2014) for details on transportability.
</p>
<p><code>selection_bias</code> enumerates the nodes that should be understood as selection bias nodes responsible for bias in the input data sets. Individual variables should be separated by a comma. See e.g., Bareinboim and Pearl (2014) for details on selection bias recoverability.
</p>
<p><code>missing_data</code> enumerates the missingness mechanisms of the model. The syntax for a single mechanism is <code>M_X : X</code> where M<sub>X</sub> is the mechanism for <code class="reqn">X</code>. Individual mechanisms should be separated by a comma. Note that both M<sub>X</sub> and <code class="reqn">X</code> must be present in the graph if the corresponding mechanism is given as input. Proxy variables should not be included in the graph, since they are automatically generated based on <code>missing_data</code>. By default, a warning is issued if a proxy variable is present in an input distribution but its corresponding mechanism is not present in any input. See e.g., Mohan, Pearl and Tian (2013) for details on missing data as a causal inference problem.
</p>
<p>The <code>control</code> argument is a list that can supply any of the following components:
</p>

<dl>
<dt><code>benchmark</code></dt><dd><p>A logical value. If <code>TRUE</code>, the search time is recorded and returned (in milliseconds). Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>benchmark_rules</code></dt><dd><p>A logical value. If <code>TRUE</code>, the time taken by each individual inference rule is also recorded in the benchmark (in milliseconds). Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>draw_derivation</code></dt><dd><p>A logical value. If <code>TRUE</code>, a string representing the derivation steps as a DOT graph is returned. The graph can be exported as an image for example by using the <code>DOT</code> package. Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>draw_all</code></dt><dd><p>A logical value. If <code>TRUE</code> and if <code>draw_derivation = TRUE</code>, the derivation will contain every step taken by the search. If <code>FALSE</code>, only steps that resulted in an identifiable target are returned. Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>formula</code></dt><dd><p>A logical value. If <code>TRUE</code>, a string representing the identifiable query is returned when the target query is identifiable. If <code>FALSE</code>, only a logical value is returned that takes the value <code>TRUE</code> for an identifiable target and <code>FALSE</code> otherwise. Defaults to <code>TRUE</code>. </p>
</dd>
<dt><code>heuristic</code></dt><dd><p>A logical value. If <code>TRUE</code>, new distributions are expanded according to a search heuristic (see Tikka et al. (2019) for details). Otherwise, distributions are expanded in the order in which they were identified. Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>md_sym</code></dt><dd><p>A single character describing the symbol to use for active missing data mechanisms. Defaults to <code>"1"</code>. </p>
</dd>
<dt><code>time_limit</code></dt><dd><p>A numeric value giving a time limit for the search (in hours). Defaults to a negative value that disables the limit. </p>
</dd>
<dt><code>verbose</code></dt><dd><p>A logical value. If <code>TRUE</code>, diagnostic information is printed to the console during the search. Defaults to <code>FALSE</code>. </p>
</dd>
<dt><code>warn</code></dt><dd><p>A logical value. If <code>TRUE</code>, a warning is issued for possibly unintentionally misspecified but syntactically correct input distributions. </p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>dosearch</code> which is a list with the following components by default. See the options of <code>control</code> for how to obtain a graphical representation of the derivation or how to benchmark the search. 
</p>

<dl>
<dt><code>identifiable</code></dt><dd><p>A logical value that attains the value <code>TRUE</code> is the target quantity is identifiable and <code>FALSE</code> otherwise. </p>
</dd>
<dt><code>formula</code></dt><dd><p>A character string describing a formula for an identifiable query or an empty character vector for an unidentifiable effect. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>References</h3>

<p>S. Tikka, A. Hyttinen and J. Karvanen. Causal effect identification from multiple incomplete data sources: a general search-based approach. <em>Journal of Statistical Software</em>, 99(5):1&ndash;40, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple back-door formula
data1 &lt;- "P(x,y,z)"
query1 &lt;- "P(y|do(x))"
graph1 &lt;- "
  x -&gt; y
  z -&gt; x
  z -&gt; y
"
dosearch(data1, query1, graph1)

## Simple front-door formula
data2 &lt;- "P(x,y,z)"
query2 &lt;- "P(y|do(x))"
graph2 &lt;- "
  x -&gt; z
  z -&gt; y
  x &lt;-&gt; y
"
dosearch(data2, query2, graph2)

## Graph input using 'igraph' in the 'causaleffect' syntax
if (requireNamespace("igraph", quietly = TRUE)) {
  g_igraph &lt;- igraph::graph.formula(x -+ z, z -+ y, x -+ y, y -+ x)
  g_igraph &lt;- igraph::set.edge.attribute(g_igraph, "description", 3:4, "U")
  dosearch(data2, query2, g_igraph)
}

## Graph input with 'dagitty'
if (requireNamespace("dagitty", quietly = TRUE)) {
  g_dagitty &lt;- dagitty::dagitty("dag{x -&gt; z -&gt; y; x &lt;-&gt; y}")
  dosearch(data2, query2, g_dagitty)
}

## Alternative distribution input style using lists and vectors:
## Each element of the list describes a single distribution
## Each element is a character vector that describes the role
## of each variable in the distribution as follows:
## For a variable V and a distribution P(A|do(B),C) we have
##   V = 0, if V is in A
##   V = 1, if V is in B
##   V = 2, if V is in C
data_alt &lt;- list(
  c(x = 0, y = 0, z = 0) # = P(x,y,z)
)
query_alt &lt;- c(x = 1, y = 0) # = P(y|do(x))
dosearch(data_alt, query_alt, graph2)

## Additional examples
## Not run: 

## Multiple input distributions (both observational and interventional)
data3 &lt;- "
  p(z_2,x_2|do(x_1))
  p(z_1|x_2,do(x_1,y))
  p(x_1|w_1,do(x_2))
  p(y|z_1,z_2,x_1,do(x_2))
  p(w|y,x_1,do(x_2))
"
query3 &lt;- "p(y,x_1|w,do(x_2))"
graph3 &lt;- "
  x_1 -&gt; z_2
  x_1 -&gt; z_1
  x_2 -&gt; z_1
  x_2 -&gt; z_2
  z_1 -&gt; y
  z_2 -&gt; y
  x_1 -&gt; w
  x_2 -&gt; w
  z_1 -&gt; w
  z_2 -&gt; w
"
dosearch(data3, query3, graph3)

## Selection bias
data4 &lt;- "
  p(x,y,z_1,z_2|s)
  p(z_1,z_2)
"
query4 &lt;- "p(y|do(x))"
graph4 &lt;- "
  x   -&gt; z_1
  z_1 -&gt; z_2
  x   -&gt; y
  y   -- z_2
  z_2 -&gt; s
"
dosearch(data4, query4, graph4, selection_bias = "s")

## Transportability
data5 &lt;- "
  p(x,y,z_1,z_2)
  p(x,y,z_1|s_1,s_2,do(z_2))
  p(x,y,z_2|s_3,do(z_1))
"
query5 &lt;- "p(y|do(x))"
graph5 &lt;- "
  z_1 -&gt; x
  x   -&gt; z_2
  z_2 -&gt; y
  z_1 &lt;-&gt; x
  z_1 &lt;-&gt; z_2
  z_1 &lt;-&gt; y
  t_1 -&gt; z_1
  t_2 -&gt; z_2
  t_3 -&gt; y
"
dosearch(data5, query5, graph5, transportability = "t_1, t_2, t_3")

## Missing data
## Proxy variables are denoted by an asterisk (*)
data6 &lt;- "
  p(x*,y*,z*,m_x,m_y,m_z)
"
query6 &lt;- "p(x,y,z)"
graph6 &lt;- "
  z -&gt; x
  x -&gt; y
  x -&gt; m_z
  y -&gt; m_z
  y -&gt; m_x
  z &lt;-&gt; y
"
dosearch(data6, query6, graph6, missing_data = "m_x : x, m_y : y, m_z : z")

## An LDAG
data7 &lt;- "P(X,Y,Z)"
query7 &lt;- "P(Y|X,I_X=1)"
graph7 &lt;- "
  X -&gt; Y : Z = 1
  Z -&gt; Y 
  Z -&gt; X : I_X = 1
  I_X -&gt; X
  H -&gt; X : I_X = 1
  H -&gt; Z
  Q -&gt; Z
  Q -&gt; Y : Z = 0
"
dosearch(data7, query7, graph7)

## A more complicated LDAG
## with multiple assignments for the edge X -&gt; Z

data8 &lt;- "P(X,Y,Z,A,W)"
query8 &lt;- "P(Y|X,I_X=1)"
graph8 &lt;- "
  I_X -&gt; X
  I_Z -&gt; Z
  A -&gt; W
  Z -&gt; Y
  A -&gt; Z
  X -&gt; Z : I_Z = 1; A = 1
  X -&gt; Y : A = 0
  W -&gt; X : I_X = 1
  W -&gt; Y : A = 0
  A -&gt; Y
  U -&gt; X : I_X = 1
  U -&gt; Y : A = 1
"
dosearch(data8, query8, graph8)

## Export the DOT diagram of the derivation as an SVG file
## to the working directory via the DOT package.
## By default, only the identifying part is plotted.
## PostScript format is also supported.
if (requireNamespace("DOT", quietly = TRUE)) {
  d &lt;- get_derivation(data1, query1, graph1, 
                      control = list(draw_derivation = TRUE))
  DOT::dot(d$derivation, "derivation.svg")
}


## End(Not run) 

</code></pre>

<hr>
<h2 id='dosearch-package'>Causal Effect Identification from Multiple Incomplete Data Sources</h2><span id='topic+dosearch-package'></span>

<h3>Description</h3>

<p>Solves causal effect identifiability problems from arbitrary observational and experimental data using a heuristic search. Allows for the presence of advanced data-generating mechanims. See Tikka et al. (2021) &lt;doi:10.18637/jss.v099.i05&gt; for further details.
</p>


<h3>Author(s)</h3>

<p>Santtu Tikka, Antti Hyttinen, Juha Karvanen</p>


<h3>References</h3>

<p>G. Aleksandrowicz, H. Chockler, J. Y. Halpern, and A. Ivrii. The computational complexity of structure-based causality. <em>Journal of Artificial Intelligence Research</em>, 58:431&ndash;451, 2017. 
</p>
<p>J. D. Angrist, G. W. Imbens, and D. B. Rubin. Identification of causal effects using instrumental variables. <em>Journal of the American Statistical Association</em>, 91(434):444&ndash;455, 1996.
</p>
<p>Y. Barash and N. Friedman. Context-specific Bayesian clustering for gene expression data. <em>Journal of Computational Biology</em>, 9(2):169&ndash;191, 2002. 
</p>
<p>E. Bareinboim and J. Pearl. Controlling selection bias in causal inference. In <em>Proceedings of the 15th International Conference on Artificial Intelligence and Statistics</em>, 22:100&ndash;108, 2012a.
</p>
<p>E. Bareinboim and J. Pearl. Causal inference by surrogate experiments: z-identifiability. In <em>Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence</em>, 113&ndash;120, 2012b.
</p>
<p>E. Bareinboim and J. Pearl. A general algorithm for deciding transportability of experimental results. <em>Journal of Causal Inference</em>, 1:107&ndash;134, 2013.
</p>
<p>E. Bareinboim and J. Pearl. Transportability from multiple environments with limited experiments: Completeness results. In <em>Proceedings of the 27th Annual Conference on Neural Information Processing Systems</em>, 280&ndash;288, 2014.
</p>
<p>E. Bareinboim and J. Tian. Recovering causal effects from selection bias. In <em>Proceedings of the 29th AAAI Conference on Artificial Intelligence</em>, 3475&ndash;3481, 2015.
</p>
<p>E. Bareinboim, J. Tian, and J. Pearl. Recovering from selection bias in causal and statistical inference. In <em>Proceedings of the 28th AAAI Conference on Neural Information Processing Systems</em>, 2014.
</p>
<p>C. Boutilier, N. Friedman, M. Goldszmidt, and D. Koller. Context-specific independence in Bayesian networks. In <em>Proceedings of the 12th International Conference on Uncertainty in Artificial Intelligence</em>, 115&ndash;123, 1996.
</p>
<p>N. E. Breslow. Statistics in epidemiology: The case-control study. <em>Journal of the American Statistical Association</em>, 91(433):14&ndash;28, 1996.
</p>
<p>C. J. Butz, A. E. dos Santos, and J. S. Oliveira. Relevant path separation: A faster method for testing independencies in Bayesian networks. In <em>8th International Conference on Probabilistic Graphical Models</em>, 74&ndash;85, 2016.
</p>
<p>B. Chen, D. Kumor, and E. Bareinboim. Identification and model testing in linear structural equation models using auxiliary variables. In <em>Proceedings of the 34th International Conference on Machine Learning</em>, 70:757&ndash;766, 2017.
</p>
<p>G. F. Cooper. The computational complexity of probabilistic inference using Bayesian belief networks. Artificial Intelligence, 42(2):393&ndash;405, 1990.
</p>
<p>J. Corander, A. Hyttinen, J. Kontinen, J. Pensar, and J. Vaananen. A logical approach to context-specific independence. Annals of Pure and Applied Logic, 2019.
</p>
<p>J. Correa and E. Bareinboim. Causal effect identification by adjustment under confounding and selection biases. In <em>Proceedings of the 31st AAAI Conference on Artificial Intelligence</em>, 2017.
</p>
<p>J. Correa, J. Tian, and E. Bareinboim. Generalized adjustment under confounding and selection biases. In <em>Proceedings of the 32nd AAAI Conference on Artificial Intelligence</em>, 2018.
</p>
<p>D. Danks, C. Glymour, and R. E. Tillman. Integrating locally learned causal structures with overlapping variables. In <em>Advances in Neural Information Processing Systems</em>, 1665&ndash;1672, 2009.
</p>
<p>A. P. Dawid. Influence diagrams for causal modelling and inference. <em>International Statistical Review</em>, 70(2):161&ndash;189, 2002.
</p>
<p>D. Entner, P. Hoyer, and P. Spirtes. Data-driven covariate selection for nonparametric estimation of causal effects. In <em>Proceedings of the 16th International Conference on Artificial Intelligence and Statistics</em>, 31:256&ndash;264, 2013.
</p>
<p>D. Galles and J. Pearl. Testing identifiability of causal effects. In <em>Proceedings of the 11th Conference Annual Conference on Uncertainty in Artificial Intelligence</em>, 185&ndash;195, 1995.
</p>
<p>B. Georgi, J. Schultz, and A. Schliep. Context-specific independence mixture modelling for protein families. In <em>European Conference on Principles of Data Mining and Knowledge Discovery</em>, 79&ndash;90, 2007.
</p>
<p>S. Greenland, J. M. Robins, and J. Pearl. Confounding and collapsibility in causal inference. <em>Statistical Science</em>, 14(1):29&ndash;46, 1999.
</p>
<p>J. Y. Halpern. Axiomatizing causal reasoning. Journal of Artificial Intelligence Research, 12:317&ndash;337, 2000.
</p>
<p>Y. Huang and M. Valtorta. Pearl's calculus of intervention is complete. In <em>Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence</em>, 217&ndash;224, 2006.
</p>
<p>A. Hyttinen, F. Eberhardt, and P. O. Hoyer. Causal discovery of linear cyclic models from multiple experimental data sets with overlapping variables. In <em>Proceedings of the 28th Conference on Uncertainty in Artificial Intelligence</em>, 387&ndash;396, 2012.
</p>
<p>A. Hyttinen, F. Eberhardt, and M. Jarvisalo. Do-calculus when the true graph is unknown. In <em>Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence</em>, 395&ndash;404, 2015.
</p>
<p>A. Jaber, J. Zhang, and E. Bareinboim. Causal identification under Markov equivalence. In <em>Proceedings of the 34th Conference on Uncertainty in Artificial Intelligence</em>, 978&ndash;987, 2018.
</p>
<p>J. Karvanen. Study design in causal models. <em>Scandinavian Journal of Statistics</em>, 42(2):361&ndash;377, 2015.
</p>
<p>D. Koller and N. Friedman. <em>Probabilistic Graphical Models: Principles and Techniques</em>, 2009.
</p>
<p>S. L. Lauritzen. Causal inference from graphical models. In <em>Complex Stochastic Systems</em>, 67&ndash;107, 2000.
</p>
<p>R. J. A. Little and D. B. Rubin. <em>Statistical Analysis with Missing Data</em>, 1986.
</p>
<p>M. H. Maathuis, M. Kalisch, and P. Buhlmann. Estimating high-dimensional intervention effects from observational data. <em>The Annals of Statistics</em>, 37(6A):3133&ndash;3164, 2009.
</p>
<p>D. Malinsky and P. Spirtes. Estimating bounds on causal effects in high-dimensional and possibly confounded systems. <em>International Journal of Approximate Reasoning</em>, 88:371&ndash;384, 2017.
</p>
<p>K. Mohan and J. Pearl. Graphical models for processing missing data. 2018. Forthcoming, https://arxiv.org/abs/1801.03583.
</p>
<p>K. Mohan, J. Pearl, and J. Tian. Graphical models for inference with missing data. In <em>Advances in Neural Information Systems</em>, 26:1277&ndash;1285, 2013.
</p>
<p>H. Nyman, J. Pensar, T. Koski, and J. Corander. Stratified graphical models-context-specific independence in graphical models. Bayesian Analysis, 9(4):883&ndash;908, 2014.
</p>
<p>J. M. Pena and M. Bendtsen. Causal effect identification in acyclic directed mixed graphs and gated models. <em>International Journal of Approximate Reasoning</em>, 90:56&ndash;75, 2017.
</p>
<p>J. Pearl. Causal diagrams for empirical research. <em>Biometrika</em>, 82(4):669&ndash;688, 1995.
</p>
<p>J. Pearl. <em>Causality: Models, Reasoning, and Inference</em>, 2009.
</p>
<p>J. Pensar, H. J. Nyman, T. Koski, and J. Corander. Labeled directed acyclic graphs: a generalization of context-specific independence in directed graphical models. Data Mining and Knowledge Discovery, 29(2):503&ndash;533, 2015.
</p>
<p>E. Perkovic, J. Textor, M. Kalisch, and M. Maathuis. A complete generalized adjustment criterion. In <em>Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence</em>, 682&ndash;691, 2015.
</p>
<p>J. Peters, J. M. Mooij, D. Janzing, and B. Scholkopf. Causal discovery with continuous additive noise models. <em>Journal of Machine Learning Research</em>, 15:2009&ndash;2053, 2014.
</p>
<p>S. E. Shimony. Explanation, irrelevance, and statistical independence. In <em>Proceedings of the 9th National conference on Artificial intelligence - Volume 1</em>, 482&ndash;487, 1991.
</p>
<p>I. Shpitser and J. Pearl. Identification of joint interventional distributions in recursive semi-Markovian causal models. In <em>Proceedings of the 21st National Conference on Artificial Intelligence &ndash; Volume 2</em>, 1219&ndash;1226, 2006a.
</p>
<p>I. Shpitser and J. Pearl. Identification of conditional interventional distributions. In <em>Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence</em>, 437&ndash;444, 2006b.
</p>
<p>I. Shpitser and J. Pearl. Complete identification methods for the causal hierarchy. <em>Journal of Machine Learning Research</em>, 9:1941&ndash;1979, 2008.
</p>
<p>I. Shpitser, K. Mohan, and J. Pearl. Missing data as a causal and probabilistic problem. In <em>Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence</em>, 802&ndash;811, 2015.
</p>
<p>P. Spirtes, C. Glymour, and R. Scheines. <em>Causation, Prediction, and Search</em>, 1993.
</p>
<p>S. Tikka and J. Karvanen. Identifying causal effects with the R package causaleffect. <em>Journal of Statistical Software</em>, 76(12):1&ndash;30, 2017a.
</p>
<p>S. Tikka and J. Karvanen. Simplifying probabilistic expressions in causal inference. <em>Journal of Machine Learning Research</em>, 18(36):1&ndash;30, 2017b.
</p>
<p>S. Tikka and J. Karvanen. Enhancing identification of causal effects by pruning. <em>Journal of Machine Learning Research</em>, 18(194):1&ndash;23, 2018.
</p>
<p>S. Tikka and J. Karvanen. Surrogate outcomes and transportability. <em>International Journal of Approximate Reasoning</em>, 108:21&ndash;37, 2019.
</p>
<p>S. Tikka, A. Hyttinen and J. Karvanen. Causal effect identification from multiple incomplete data sources: a general search-based approach. <em>Journal of Statistical Software</em>, 99(5):1&ndash;40, 2021.
</p>
<p>R. Tillman and P. Spirtes. Learning equivalence classes of acyclic models with latent and selection variables from multiple datasets with overlapping variables. In <em>Proceedings of the 14th International Conference on Artificial Intelligence and Statistics</em>, 3&ndash;15, 2011.
</p>
<p>S. Triantafillou and I. Tsamardinos. Constraint-based causal discovery from multiple interventions over overlapping variable sets. <em>Journal of Machine Learning Research</em>, 16:2147&ndash;2205, 2015.
</p>
<p>S. Triantafillou, I. Tsamardinos, and I. Tollis. Learning causal structure from overlapping variable sets. In <em>Proceedings of the 13th International Conference on Artificial Intelligence and Statistics</em>, 860&ndash;867, 2010.
</p>
<p>B. van der Zander and M. Liskiewicz. On searching for generalized instrumental variables. In <em>Proceedings of the 19th International Conference on Artificial Intelligence and Statistics</em>, 2016.
</p>
<p>S. Visscher, P. Lucas, I. Flesch, and K. Schurink. Using temporal context-specific independence information in the exploratory analysis of disease processes. In <em>Conference on Artificial Intelligence in Medicine in Europe</em>, 87&ndash;96, 2007. 
</p>

<hr>
<h2 id='get_benchmark'>Benchmark a specific run of the search</h2><span id='topic+get_benchmark'></span>

<h3>Description</h3>

<p>Returns the benchmarking information of an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;. </p>


<h3>Usage</h3>

<pre><code class='language-R'>get_benchmark(x, run_again = FALSE, include_rules = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_benchmark_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;. </p>
</td></tr>
<tr><td><code id="get_benchmark_+3A_run_again">run_again</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, run the search again to obtain the benchmarking information if it was not requested in the function call that produced <code>x</code>. </p>
</td></tr>
<tr><td><code id="get_benchmark_+3A_include_rules">include_rules</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, also benchmark the time taken by each inference rule separately. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one or two elements. The first is always a numeric value of the total time taken by the search in milliseconds. The second is a numeric vector of the time taken by each inference rule (in the internal C++ implementation) of the search in milliseconds if <code>include_rules = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- "P(x,y,z)"
query &lt;- "P(y|do(x))"
graph &lt;- "
  x -&gt; y
  z -&gt; x
  z -&gt; y
"
x &lt;- dosearch(data, query, graph, control = list(benchmark = FALSE))
get_benchmark(x, run_again = TRUE)
</code></pre>

<hr>
<h2 id='get_derivation'>Retrieve the derivation of a causal query</h2><span id='topic+get_derivation'></span>

<h3>Description</h3>

<p>Returns the derivation of causal query of an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;. </p>


<h3>Usage</h3>

<pre><code class='language-R'>get_derivation(x, run_again = FALSE, draw_all = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_derivation_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;.</p>
</td></tr>
<tr><td><code id="get_derivation_+3A_run_again">run_again</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, run the search again to obtain a derivation for the query if one was not requested in the function call that produced <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_derivation_+3A_draw_all">draw_all</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the derivation will contain every step taken by the search. If <code>FALSE</code>, only steps that resulted in identification are returned. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- "P(x,y,z)"
query &lt;- "P(y|do(x))"
graph &lt;- "
  x -&gt; y
  z -&gt; x
  z -&gt; y
"
x &lt;- dosearch(data, query, graph, control = list(draw_derivation = FALSE))
get_derivation(x, run_again = TRUE)
</code></pre>

<hr>
<h2 id='get_formula'>Retrieve the identifying formula of a causal query</h2><span id='topic+get_formula'></span>

<h3>Description</h3>

<p>Returns the identifying formula describing a causal query of an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;. </p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula(x, run_again = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_formula_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;.</p>
</td></tr>
<tr><td><code id="get_formula_+3A_run_again">run_again</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, run the search again to obtain a formula for the query if one was not requested in the function call that produced <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the query in terms of the input data. </p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- "P(x,y,z)"
query &lt;- "P(y|do(x))"
graph &lt;- "
  x -&gt; y
  z -&gt; x
  z -&gt; y
"
x &lt;- dosearch(data, query, graph, control = list(formula = FALSE))
get_formula(x, run_again = TRUE)
</code></pre>

<hr>
<h2 id='is_identifiable'>Query whether the target distribution was identifiable or not</h2><span id='topic+is_identifiable'></span>

<h3>Description</h3>

<p>Returns the a logical value describing the identifiability of a causal query of an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;. </p>


<h3>Usage</h3>

<pre><code class='language-R'>is_identifiable(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_identifiable_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<a href="#topic+dosearch">dosearch</a>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value. If <code>TRUE</code>, the target distribution is identifiable from the available inputs. </p>


<h3>Author(s)</h3>

<p>Santtu Tikka</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- "P(x,y,z)"
query &lt;- "P(y|do(x))"
graph &lt;- "
  x -&gt; y
  z -&gt; x
  z -&gt; y
"
x &lt;- dosearch(data, query, graph)
is_identifiable(x)
# TRUE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
