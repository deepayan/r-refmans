<!DOCTYPE html><html><head><title>Help for package lspls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lspls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lspls-package'>
<p>LS-PLS Models</p></a></li>
<li><a href='#lspls'><p>Fit LS-PLS Models</p></a></li>
<li><a href='#lsplsCv'><p>Cross-Validate LS-PLS Models</p></a></li>
<li><a href='#MSEP.lsplsCv'><p>MSEP, RMSEP and R^2 for LS-PLS</p></a></li>
<li><a href='#orthlspls.fit'><p>Underlying LS-PLS Fit Function</p></a></li>
<li><a href='#orthlsplsCv'><p>Low Level Cross-Validation Function</p></a></li>
<li><a href='#plot.lspls'><p>Plots of LS-PLS Models</p></a></li>
<li><a href='#plot.lsplsCv'><p>Plot Method for Cross-Validations</p></a></li>
<li><a href='#predict.lspls'><p>Predict Method for LS-PLS Models</p></a></li>
<li><a href='#projections'><p>Projection and Orthogonalisation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>LS-PLS Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Bjørn-Helge Mevik [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bjørn-Helge Mevik &lt;b-h@mevik.net&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>pls (&ge; 2.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the LS-PLS (least squares - partial least squares)
  method described in for instance Jørgensen, K., Segtnan, V. H., Thyholt, K.,
  Næs, T. (2004)  "A Comparison of Methods for Analysing Regression Models with
  Both Spectral and Designed Variables"
  Journal of Chemometrics, 18(10), 451&ndash;464, &lt;<a href="https://doi.org/10.1002%2Fcem.890">doi:10.1002/cem.890</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mevik.net/work/software/lspls.html">http://mevik.net/work/software/lspls.html</a>,
<a href="https://github.com/bhmevik/lspls">https://github.com/bhmevik/lspls</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bhmevik/lspls/issues">https://github.com/bhmevik/lspls/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-26 17:41:47 UTC; bhm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-26 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lspls-package'>
LS-PLS Models
</h2><span id='topic+lspls-package'></span>

<h3>Description</h3>

<p>Implements the LS-PLS (least squares - partial least squares)
method described in for instance Jørgensen, K., Segtnan, V. H., Thyholt, K.,
Næs, T. (2004)  &quot;A Comparison of Methods for Analysing Regression Models with
Both Spectral and Designed Variables&quot;
Journal of Chemometrics, 18(10), 451&ndash;464, &lt;doi:10.1002/cem.890&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lspls</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> LS-PLS Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-26</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Bjørn-Helge", "Mevik", role = c("aut", "cre"),
                     email = "b-h@mevik.net"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Bjørn-Helge Mevik [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Bjørn-Helge Mevik &lt;b-h@mevik.net&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> pls (&gt;= 2.2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> grDevices, graphics, methods, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implements the LS-PLS (least squares - partial least squares)
  method described in for instance Jørgensen, K., Segtnan, V. H., Thyholt, K.,
  Næs, T. (2004)  "A Comparison of Methods for Analysing Regression Models with
  Both Spectral and Designed Variables"
  Journal of Chemometrics, 18(10), 451--464, &lt;doi:10.1002/cem.890&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> http://mevik.net/work/software/lspls.html, https://github.com/bhmevik/lspls</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/bhmevik/lspls/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
MSEP.lsplsCv            MSEP, RMSEP and R^2 for LS-PLS
lspls                   Fit LS-PLS Models
lspls-package           LS-PLS Models
lsplsCv                 Cross-Validate LS-PLS Models
orthlspls.fit           Underlying LS-PLS Fit Function
orthlsplsCv             Low Level Cross-Validation Function
plot.lspls              Plots of LS-PLS Models
plot.lsplsCv            Plot Method for Cross-Validations
predict.lspls           Predict Method for LS-PLS Models
project                 Projection and Orthogonalisation
</pre>
<p>LS-PLS (least squares&ndash;partial least squares) models are written on the form
</p>
<p style="text-align: center;"><code class="reqn">Y = X\beta + T_1\gamma_1 + \cdots + T_k\gamma_k + E,</code>
</p>

<p>where the terms <code class="reqn">T_i</code> are one or more matrices <code class="reqn">Z_{i,j}</code>
separated by a colon (:), i.e., <code class="reqn">Z_{i,1} \colon Z_{i,2}\colon \cdots
  \colon Z_{i,l_i}</code>.  Multi-response models are
possible, in wich case <code class="reqn">Y</code> should be a matrix.
</p>
<p>The model is fitted from left to right.  First <code class="reqn">Y</code> is fitted to
<code class="reqn">X</code> using least squares (LS) regression and the residuals
calculated.
For each <code class="reqn">i</code>, the matrices <code class="reqn">Z_{i,1}</code>, ..., <code class="reqn">Z_{i,l_i}</code>
are orthogonalised against the variables used in the regression sofar
(when <code class="reqn">i = 1</code>, this means <code class="reqn">X</code>).
The residuals from the LS regression are used as the response in PLS
regressions with the orthogonalised matrices as predictors (one PLS
regression for each matrix), and the desired number of PLS components
from each matrix are included among the LS prediction variables.
The LS regression is then refit with the new variables, and new
residuals calculated.
</p>
<p>The function to fit LS-PLS models is <code><a href="#topic+lspls">lspls</a></code>.  A typical
usage to fit the model
</p>
<p style="text-align: center;"><code class="reqn">y = X\beta + Z \gamma + V_1 \colon V_2 \eta
  + W \theta + E</code>
</p>

<p>would be
</p>
<pre>
  mod &lt;- lspls(y ~ X + Z + V1:V2 + W, ncomp = list(3, c(2,1), 2),
               data = mydata)
</pre>
<p>The first argument is the formula describing the model.
<code>X</code> is fit first, using LS.  Then PLS scores from <code>Z</code>
(orthogonalised) are added.  Then PLS scores from <code>V1</code> and
<code>V2</code> are added (simultaneously), and finally PLS scores from
<code>W</code>.  The next argument, <code>ncomp</code>, specifies the number of
components to use from each PLS: 3 <code>Z</code> score vectors, 2 <code>V1</code>
score vectors, 1 <code>V2</code> score vector and 2 <code>W</code> score vectors.
Finally, <code>mydata</code> should be a data frame with matrices <code>y</code>,
<code>X</code>, <code>Z</code>, <code>V1</code>, <code>V2</code> and <code>W</code> (for
single-response models, <code>y</code> can be a vector).
</p>
<p>Currently, score plots and loading plots of fitted models are
implemented.  <code>plot(mod, "scores")</code> gives score plots for each PLS
regression, and <code>plot(mod, "loadings")</code> gives loading plots.
</p>
<p>There is a <code>predict</code> method to predict response or score values
from new data
</p>
<pre>
  predict(mod, newdata = mynewdata)
</pre>
<p>(This predicts response values.  Use <code>type = "scores"</code> to get
scores.)  Also, the standard functions <code>resid</code> and <code>fitted</code>
can be used to extract the residuals and fitted values.
</p>
<p>In order to determine the number of components to use from each matrix,
one can use cross-validation:
</p>
<pre>
  cvmod &lt;- lsplsCv(y ~ X + Z + V1:V2 + W, ncomp = list(4, c(3,4), 3),
                   segments = 12, data = mydata)
</pre>
<p>In <code>lsplsCv</code>, <code>ncomp</code> gives the maximal number of components to
test.  The argument <code>segments</code> specifies the number of segments to
use.  One can specify the type of segments to use (random (default),
consequtive or interleaved) with the argument <code>segment.type</code>.
Alternatively, one can supply the segments explicitly with
<code>segments</code>.  See <code><a href="#topic+lsplsCv">lsplsCv</a></code> for details.
</p>
<p>One can plot cross-validated RMSEP values with <code>plot(cvmod)</code>.
(Similarly, <code>plot(cvmod, "MSEP")</code> plots MSEP values.)  This makes
it easier to determine the optimal number of components for each PLS.
See <code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code> for details.  To calculate the RMSEP or
MSEP values explicitly, one can use the function <code>RMSEP</code> or
<code>MSEP</code>.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik [aut, cre]
</p>
<p>Maintainer: Bjørn-Helge Mevik &lt;b-h@mevik.net&gt;
</p>


<h3>References</h3>

<p>Jørgensen, K., Segtnan, V. H., Thyholt, K., Næs, T. (2004)  A
Comparison of Methods for Analysing Regression Models with Both
Spectral and Designed Variables.
<em>Journal of Chemometrics</em>, <b>18</b>(10), 451&ndash;464.
</p>
<p>Jørgensen, K., Mevik, B.-H., Næs, T.  Combining Designed Experiments
with Several Blocks of Spectroscopic Data.
(Submitted)
</p>
<p>Mevik, B.-H., Jørgensen, K., Måge, I., Næs, T.  LS-PLS: Combining
Categorical Design Variables with Blocks of Spectroscopic
Measurements.
(Submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code>, <code><a href="#topic+lsplsCv">lsplsCv</a></code>, <code><a href="#topic+plot.lspls">plot.lspls</a></code>,
<code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## FIXME
</code></pre>

<hr>
<h2 id='lspls'>Fit LS-PLS Models</h2><span id='topic+lspls'></span>

<h3>Description</h3>

<p>A function to fit LS-PLS (least squares&ndash;partial least squares) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lspls(formula, ncomp, data, subset, na.action, model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lspls_+3A_formula">formula</code></td>
<td>
<p>model formula.  See Details.</p>
</td></tr>
<tr><td><code id="lspls_+3A_ncomp">ncomp</code></td>
<td>
<p>list or vector of positive integers, giving the
number of components to use for each &lsquo;pls-matrix&rsquo;.  See Details.</p>
</td></tr>
<tr><td><code id="lspls_+3A_data">data</code></td>
<td>
<p>an optional data frame with the data to fit the model from.</p>
</td></tr>
<tr><td><code id="lspls_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="lspls_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain missing values.</p>
</td></tr>
<tr><td><code id="lspls_+3A_model">model</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="lspls_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to the underlying PLSR fit
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lspls</code> fits LS-PLS models, in which matrices are added
successively to the model.  The first matrix is fit
with ordinary least squares (LS) regression.  The rest of the matrices
are fit with partial least squares regression (PLSR), using the
residuals from the preceeding model as response.  See
<a href="#topic+lspls-package">lspls-package</a> or the references for more details, and
<a href="#topic+lspls-package">lspls-package</a> for typical usage.
</p>
<p>The model formula is specified as
<code><var>resp</var> ~ <var>term1</var> + <var>term2</var> + ...</code>.
If <var>resp</var> is a matrix (with more than one
coloumn), a multi-response model is fitted.  <var>term1</var> specifies the
first matrix to be fitted, using LS.  Each of the remaining terms will
be added sequentially in the order specified in the formula (from left
to right).  Each term can either be a single matrix, which will be added
by itself, or several matrices separated with <code>:</code>, e.g.,
<code>Z:V:W</code>, which will be added simultaneously (these will be denoted
<dfn>parallell</dfn> matrices).
</p>
<p>The first matrix, <var>term1</var>, is called the <dfn>LS matrix</dfn>, and
the rest of the predictor matrices (whether parallell or not) are
called <dfn>PLS matrices</dfn>.
</p>
<p>Note that an intercept is <em>not</em> automatically added to the model.
It should be included as a constant coloumn in the LS matrix, if
desired.  (If no intercept is included, the PLS matrices should be
centered.  This happens automatically if the LS matrix includes the
intercept.)
</p>
<p>The number of components to use in each of the PLSR models is
specified with the <code>ncomp</code> argument, which should be a
list.  Each element of the list gives the number of components to
use for the corresponding term in the formula.  If the term specifies
parallell matrices (separated with <code>:</code>), the list element
should be a vector with one integer for each matrix.  Otherwise, it
should be a number.
</p>
<p>To simplify the specification of <code>ncomp</code>, the following
conversions are made:  if <code>ncomp</code> is a vector, it will be
converted to a list.  <code>ncomp</code> will also be recycled as neccessary to get
one element for each term.  Finally, for a parallell term, the list
element will be recycled as needed.  Thus, <code>ncomp = 4</code> will
result in 4 components being fit for every PLS matrix.
</p>
<p>Currently, the function <code>lspls</code> itself handles the formula and
the data, and calls the underlying fit function
<code><a href="#topic+orthlspls.fit">orthlspls.fit</a></code> to do the actual fitting.  This implements
the orthogonalized version of the LS-PLS algorithm, and without splitting
of parallell matrices into common and unique components (see
the references).  Extensions to non-orthogonalized algorithms, and
splitting of parallell matrices are planned.
</p>


<h3>Value</h3>

<p>An object of class <code>"lspls"</code>.  The object contains all components
returned by the underlying fit function (currently
<code><a href="#topic+orthlspls.fit">orthlspls.fit</a></code>).  In addition, it contains the following
components:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>matrix with fitted values, one coloumn per response</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>if observations with missing values were removed,
<code>na.action</code> contains a vector with their indices.</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p>the list of number of components used in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the model terms.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if <code>model = TRUE</code>, the model frame.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The user interface (e.g. the model handling) is experimental, and
might well change in later versions.
</p>
<p>The handling of <code>formula</code> (especially <code>:</code>) is non-standard.
Note that the order of the terms is significant; terms are added
from left to right.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>References</h3>

<p>Jørgensen, K., Segtnan, V. H., Thyholt, K., Næs, T. (2004)  A
Comparison of Methods for Analysing Regression Models with Both
Spectral and Designed Variables.
<em>Journal of Chemometrics</em>, <b>18</b>(10), 451&ndash;464.
</p>
<p>Jørgensen, K., Mevik, B.-H., Næs, T.  Combining Designed Experiments
with Several Blocks of Spectroscopic Data.
(Submitted)
</p>
<p>Mevik, B.-H., Jørgensen, K., Måge, I., Næs, T.  LS-PLS: Combining
Categorical Design Variables with Blocks of Spectroscopic
Measurements.
(Submitted)
</p>


<h3>See Also</h3>

<p><a href="#topic+lspls-package">lspls-package</a>, <code><a href="#topic+lsplsCv">lsplsCv</a></code>,
<code><a href="#topic+plot.lspls">plot.lspls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

<hr>
<h2 id='lsplsCv'>Cross-Validate LS-PLS Models</h2><span id='topic+lsplsCv'></span>

<h3>Description</h3>

<p>Calculate cross-validated predictions for LS-PLS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsplsCv(formula, ncomp, data, subset, na.action, segments = 10,
        segment.type = c("random", "consecutive", "interleaved"),
        length.seg, model = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsplsCv_+3A_formula">formula</code></td>
<td>
<p>model formula.  See Details.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_ncomp">ncomp</code></td>
<td>
<p>list or vector of positive integers, giving the
number of components to use for each PLS matrix.  See Details.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_data">data</code></td>
<td>
<p>an optional data frame with the data to fit the model from.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain missing values.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_segments">segments</code></td>
<td>
<p>the number of segments to use, or a list with segments (see
Details).</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_segment.type">segment.type</code></td>
<td>
<p>the type of segments to use.  Ignored if
<code>segments</code> is a list.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_length.seg">length.seg</code></td>
<td>
<p>Positive integer.  The length of the segments to
use.  If specified, it overrides <code>segments</code> unless
<code>segments</code> is a list.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_model">model</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="lsplsCv_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to the underlying
cross-validation function (currently <code><a href="#topic+orthlsplsCv">orthlsplsCv</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs a cross-validation, using the model and segments
specified in the call.  It returns an object of class
<code>"lsplsCv"</code>, which has a plot method (see
<code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code>).  See <a href="#topic+lspls-package">lspls-package</a> for typical
usage and more about LS-PLS models.
</p>
<p>See <code><a href="#topic+lspls">lspls</a></code> for details about specifying the model
with <code>formula</code> and <code>ncomp</code>.  Note that <code>lsplsCv</code>
cross-validates models with from 0 components to the numbers of
components specified with <code>ncomp</code>.
</p>
<p>If <code>segments</code> is a list, the arguments <code>segment.type</code> and
<code>length.seg</code> are ignored.  The elements of the list should be
integer vectors specifying the indices of the segments.  See
<code><a href="pls.html#topic+cvsegments">cvsegments</a></code> for details.
</p>
<p>Otherwise, segments of type <code>segment.type</code> are generated.  How
many segments to generate is selected by specifying the number of
segments in <code>segments</code>, or giving the segment length in
<code>length.seg</code>.  If both are specified, <code>segments</code> is
ignored.
</p>


<h3>Value</h3>

<p>An object of class <code>"lsplsCv"</code>, with components
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>the cross-validated predictions.  An array with one
dimension for the observations, one for the responses, and one for
each of the PLS matrices.</p>
</td></tr>
<tr><td><code>segments</code></td>
<td>
<p>the list of segments used in the cross-validation.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>if observations with missing values were removed,
<code>na.action</code> contains a vector with their indices.</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p>the list of number of components used in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the model terms.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if <code>model = TRUE</code>, the model frame.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, <code>lsplsCv</code> handles the formula and the data, and calls
<code><a href="#topic+orthlsplsCv">orthlsplsCv</a></code> for the actual cross-validation.  The
formula interface is experimental, and might change in future versions.  
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>References</h3>

<p>Jørgensen, K., Segtnan, V. H., Thyholt, K., Næs, T. (2004)  A
Comparison of Methods for Analysing Regression Models with Both
Spectral and Designed Variables.
<em>Journal of Chemometrics</em>, <b>18</b>(10), 451&ndash;464.
</p>
<p>Jørgensen, K., Mevik, B.-H., Næs, T.  Combining Designed Experiments
with Several Blocks of Spectroscopic Data.
(Submitted)
</p>
<p>Mevik, B.-H., Jørgensen, K., Måge, I., Næs, T.  LS-PLS: Combining
Categorical Design Variables with Blocks of Spectroscopic
Measurements.
(Submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code>, <code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code>,
<code><a href="pls.html#topic+cvsegments">cvsegments</a></code>, <code><a href="#topic+orthlsplsCv">orthlsplsCv</a></code>,
<a href="#topic+lspls-package">lspls-package</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

<hr>
<h2 id='MSEP.lsplsCv'>MSEP, RMSEP and R^2 for LS-PLS</h2><span id='topic+MSEP.lsplsCv'></span><span id='topic+RMSEP.lsplsCv'></span><span id='topic+R2.lsplsCv'></span>

<h3>Description</h3>

<p>(Root) Mean Squared Error of Prediction ((R)MSEP) and R^2 methods for LS-PLS
cross-validations (<code>"lsplsCv"</code> objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsplsCv'
MSEP(object, scale = FALSE, ...)
## S3 method for class 'lsplsCv'
RMSEP(object, scale = FALSE, ...)
## S3 method for class 'lsplsCv'
R2(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSEP.lsplsCv_+3A_object">object</code></td>
<td>
<p>an <code>"lsplsCv"</code> object, typically the output from
<code>lsplsCv</code>.</p>
</td></tr>
<tr><td><code id="MSEP.lsplsCv_+3A_scale">scale</code></td>
<td>
<p>logical.  Whether the responses and predicted values
should be divided by the standard deviation of the response prior to
calculating the measure.  This is most useful when comparing several
responses.  Default is not to scale.  Note that this argument is
ignored by the <code>R2</code> method, since <code class="reqn">R^2</code> is independent of
scale.</p>
</td></tr>
<tr><td><code id="MSEP.lsplsCv_+3A_...">...</code></td>
<td>
<p>Further arguments.  Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array.  The first dimension corresponds to the responses (for
single-response models, the length of this dimension is 1).  The rest
of the dimensions correspond to the number of components from the
PLS matrices.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsplsCv">lsplsCv</a></code>, <code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code></p>

<hr>
<h2 id='orthlspls.fit'>Underlying LS-PLS Fit Function</h2><span id='topic+orthlspls.fit'></span>

<h3>Description</h3>

<p>Fits orthogonalized LS-PLS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthlspls.fit(Y, X, Z, ncomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthlspls.fit_+3A_y">Y</code></td>
<td>
<p>matrix.  Response matrix.</p>
</td></tr>
<tr><td><code id="orthlspls.fit_+3A_x">X</code></td>
<td>
<p>matrix.  The first predictor matrix (typically a design matrix).</p>
</td></tr>
<tr><td><code id="orthlspls.fit_+3A_z">Z</code></td>
<td>
<p>list.  List of predictor matrices.</p>
</td></tr>
<tr><td><code id="orthlspls.fit_+3A_ncomp">ncomp</code></td>
<td>
<p>list.  The number of components to fit from each matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>orthlspls.fit</code> is not meant to be called by the user.  It is
called by <code><a href="#topic+lspls">lspls</a></code> to do the actual fitting.  See
<code><a href="#topic+lspls">lspls</a></code> for details about LS-PLS and <code>ncomp</code>.  Each
element of the list <code>Z</code> should either be a matrix or a list of
matrices.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>matrix with the final prediction coefficients</p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p>matrix with variables and scores used in the final
regression</p>
</td></tr>
<tr><td><code>orthCoefs</code></td>
<td>
<p>list of coefficient generating matrices, to be used
when predicting new predictors.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>list of fitted PLS models for the matrices</p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p>list with the number of components used</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>list of score matrices</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>list of loading matrices</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>matrix with fit residuals, one coloumn per response</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The interface (arguments and return values) is likely to change in
a future version.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>References</h3>

<p>Jørgensen, K., Segtnan, V. H., Thyholt, K., Næs, T. (2004)  A
Comparison of Methods for Analysing Regression Models with Both
Spectral and Designed Variables.
<em>Journal of Chemometrics</em>, <b>18</b>(10), 451&ndash;464.
</p>
<p>Jørgensen, K., Mevik, B.-H., Næs, T.  Combining Designed Experiments
with Several Blocks of Spectroscopic Data.
(Submitted)
</p>
<p>Mevik, B.-H., Jørgensen, K., Måge, I., Næs, T.  LS-PLS: Combining
Categorical Design Variables with Blocks of Spectroscopic
Measurements.
(Submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code></p>

<hr>
<h2 id='orthlsplsCv'>Low Level Cross-Validation Function</h2><span id='topic+orthlsplsCv'></span>

<h3>Description</h3>

<p>Low-level function to perform the cross-validation in <code>lsplsCv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthlsplsCv(Y, X, Z, ncomp, segments, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthlsplsCv_+3A_y">Y</code></td>
<td>
<p>matrix.  Response matrix.</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_x">X</code></td>
<td>
<p>matrix.  The first predictor matrix (typically a design matrix).</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_z">Z</code></td>
<td>
<p>list.  List of predictor matrices.</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_ncomp">ncomp</code></td>
<td>
<p>list.  The number of components to fit from each matrix.</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_segments">segments</code></td>
<td>
<p>list.  The segments to use.</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_trace">trace</code></td>
<td>
<p>logical; if <code>TRUE</code>, the segment number is printed
for each segment.</p>
</td></tr>
<tr><td><code id="orthlsplsCv_+3A_...">...</code></td>
<td>
<p>Further arguments.  Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not meant to be called directly by the user.  It
performs cross-validation of ortogonalized LS-PLS-models without
splitting of parallell matrices into common and unique components.
See the references for details.
</p>


<h3>Value</h3>

<p>An array of cross-validated predictions.  The first dimension
corresponds to the observations, the second to the responses, and the
rest to the number of components of the PLS models.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>References</h3>

<p>Jørgensen, K., Segtnan, V. H., Thyholt, K., Næs, T. (2004)  A
Comparison of Methods for Analysing Regression Models with Both
Spectral and Designed Variables.
<em>Journal of Chemometrics</em>, <b>18</b>(10), 451&ndash;464.
</p>
<p>Jørgensen, K., Mevik, B.-H., Næs, T.  Combining Designed Experiments
with Several Blocks of Spectroscopic Data.
(Submitted)
</p>
<p>Mevik, B.-H., Jørgensen, K., Måge, I., Næs, T.  LS-PLS: Combining
Categorical Design Variables with Blocks of Spectroscopic
Measurements.
(Submitted)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code>, <code><a href="#topic+lsplsCv">lsplsCv</a></code>,
<code><a href="#topic+orthlspls.fit">orthlspls.fit</a></code></p>

<hr>
<h2 id='plot.lspls'>Plots of LS-PLS Models</h2><span id='topic+plot.lspls'></span><span id='topic+scoreplot.lspls'></span><span id='topic+loadingplot.lspls'></span>

<h3>Description</h3>

<p>Plot method for <code>"lspls"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lspls'
plot(x, plottype = c("scores", "loadings"), ...)
## S3 method for class 'lspls'
scoreplot(object, ...)
## S3 method for class 'lspls'
loadingplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lspls_+3A_x">x</code>, <code id="plot.lspls_+3A_object">object</code></td>
<td>
<p>Object of class <code>"lspls"</code>.  The model to be plotted.</p>
</td></tr>
<tr><td><code id="plot.lspls_+3A_plottype">plottype</code></td>
<td>
<p>character string.  What type of plot to generate.</p>
</td></tr>
<tr><td><code id="plot.lspls_+3A_...">...</code></td>
<td>
<p>Further arguments, passed on to underlying plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method simply calls <code>scoreplot.lspls</code> or
<code>loadingplot.lspls</code> depending on the <code>plottype</code> argument.
</p>
<p><code>scoreplot.lspls</code> gives a series of score plots, one for each PLS
model.  The user is asked to press Return between each plot.
</p>
<p><code>loadingplot.lspls</code> shows a series of loading plots, one for each
PLS model.  All plots are shown in the same plot window.
</p>


<h3>Value</h3>

<p>The functions return whatever the (last) underlying plot function returns.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code>, <code><a href="pls.html#topic+scoreplot">scoreplot</a></code>,
<code><a href="pls.html#topic+scoreplot">loadingplot</a></code>, <code><a href="#topic+plot.lsplsCv">plot.lsplsCv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

<hr>
<h2 id='plot.lsplsCv'>Plot Method for Cross-Validations</h2><span id='topic+plot.lsplsCv'></span>

<h3>Description</h3>

<p>Plot method for <code>"lsplsCv"</code> objects.  It plots the
cross-validated (R)MSEP or R^2 against the total number of components
or the matrices included in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsplsCv'
plot(x, which = c("RMSEP", "MSEP", "R2"), ncomp,
        separate = TRUE, scale = !isTRUE(separate), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lsplsCv_+3A_x">x</code></td>
<td>
<p>object of class <code>"lsplsCv"</code>.  Object to be plotted.
Typically the output from <code><a href="#topic+lsplsCv">lsplsCv</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lsplsCv_+3A_which">which</code></td>
<td>
<p>character string.  Which measure to plot.</p>
</td></tr>
<tr><td><code id="plot.lsplsCv_+3A_ncomp">ncomp</code></td>
<td>
<p>list.  The number of components to use when plotting, for
each PLS matrix in the model.  See Details.</p>
</td></tr>
<tr><td><code id="plot.lsplsCv_+3A_separate">separate</code></td>
<td>
<p>logical.  Whether separate plots should be generated
for each response (default) or one plot with the sum of the measure
for all responses.</p>
</td></tr>
<tr><td><code id="plot.lsplsCv_+3A_scale">scale</code></td>
<td>
<p>logical.  Whether the responses and predicted values
should be divided by the standard deviation of the response prior to
calculating the measure.  Default is to scale when producing a
combined plot (<code>separate = FALSE</code>) and not to scale otherwise.</p>
</td></tr>
<tr><td><code id="plot.lsplsCv_+3A_...">...</code></td>
<td>
<p>Further arguments, sent to the underlying plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>ncomp</code> is not specified, 
the <code>plot</code> method generates a plot of the cross-validated (R)MSEP
or R^2 values for all combinations of number of components.  The
values are plotted against the total number of components.  Each point
is labelled with the combination of number of components.  E.g., for
a model with three PLS matrices, &lsquo;<span class="samp">&#8288;132&#8288;</span>&rsquo; means one
component from the first matrix, three from the second and two from
the third. 
Also, the lowest (R)MSEP or highest <code class="reqn">R^2</code> values for each total
number of components are joined by a line.
</p>
<p>If <code>ncomp</code> is specified, the <code>plot</code> method plots (R)MSEP
or R^2 for models with the first matrix, with the two first matrices,
etc.  <code>ncomp</code> should be specified as when running <code>lsplsCv</code>,
and is used for selecting the number of components for each PLS
matrix.  For instance
</p>
<pre>
    mod &lt;- lsplsCv(Y ~ X + Z + V:W, ...)
    plot(mod, ncomp = list(2, c(1,3)))
  </pre>
<p>would plot the RMSEPs for <code>Y ~ X</code>, <code>Y ~ X + Z</code> and <code>Y ~
  X + Z + V:W</code>, using 2, 1 and 3 components for <code>Z</code>, <code>V</code> and
<code>W</code>, respectively.
</p>
<p>If <code>separate</code> is <code>TRUE</code>, a separate plot panel is produced
for each response.  Otherwise the measure is added for all responses
and shown in one plot.  If <code>scale</code> is <code>TRUE</code> (the default
when producing a combined plot), the measures for each response are
standardised by dividing the responses and predicted values by the
standard deviation of the (corresponding) response prior to
calculating the measure.  Note that <code>scale</code> is ignored when
<code>which</code> is <code>"R2"</code> because <code class="reqn">R^2</code> is independent of scale.)
</p>


<h3>Value</h3>

<p>The function returns whatever the (last) underlying plot function
returns.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsplsCv">lsplsCv</a></code>, <code><a href="#topic+lspls">lspls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

<hr>
<h2 id='predict.lspls'>Predict Method for LS-PLS Models</h2><span id='topic+predict.lspls'></span>

<h3>Description</h3>

<p>Predict method for <code>"lspls"</code> objects.  It predicts response
values or scores from new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lspls'
predict(object, newdata, type = c("response", "scores"),
        na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lspls_+3A_object">object</code></td>
<td>
<p>object of class <code>"lspls"</code>.  The fitted model to
predict with.</p>
</td></tr>
<tr><td><code id="predict.lspls_+3A_newdata">newdata</code></td>
<td>
<p>data frame.  The new data.</p>
</td></tr>
<tr><td><code id="predict.lspls_+3A_type">type</code></td>
<td>
<p>character.  Wether to predict responses or scores.</p>
</td></tr>
<tr><td><code id="predict.lspls_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing
values in <code>newdata</code>.  The default is to predict <code>NA</code>.  See
<code><a href="stats.html#topic+na.omit">na.omit</a></code> for alternatives.</p>
</td></tr>
<tr><td><code id="predict.lspls_+3A_...">...</code></td>
<td>
<p>further arguments.  Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type = "response"</code>, a matrix with predicted response values
is returned.  If <code>type = "scores"</code>, a matrix with predicted
score values is returned.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

<hr>
<h2 id='projections'>Projection and Orthogonalisation</h2><span id='topic+project'></span><span id='topic+orth'></span><span id='topic+Corth'></span>

<h3>Description</h3>

<p>Functions to project one matrix onto another, or to ortghogonalise it
against the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(M, N)
orth(M, N)
Corth(M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projections_+3A_m">M</code></td>
<td>
<p>matrix to be projected or orthogonalised</p>
</td></tr>
<tr><td><code id="projections_+3A_n">N</code></td>
<td>
<p>matrix to be projected onto or orthogonalised against</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>project(M, N)</code> calculates the projection of <code>M</code> onto <code>N</code>,
i.e., <code class="reqn">N (N^t N)^{-1} N^t M</code>.
</p>
<p><code>orth(M, N)</code> orthogonalises <code>M</code> with respect to <code>N</code>,
i.e., it calculates the projection of <code>M</code> onto the orthogonal
space of <code>N</code>: <code class="reqn">M - N (N^t N)^{-1} N^t M</code>.
</p>
<p><code>Corth(M, N)</code> calculates the coefficient matrix needed to
orthogonalise future matrices, that is,
<code class="reqn">(N^t N)^{-1} N^t M</code>.  Future
matrices <code>m</code> and <code>n</code> can be orthogonalised with
<code>m - n %*% Corth(M, N)</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p>The functions need to be opitmised, both for speed and numerical
accurracy.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik</p>


<h3>See Also</h3>

<p><code><a href="#topic+lspls">lspls</a></code>, <code><a href="#topic+lsplsCv">lsplsCv</a></code>,
<code><a href="#topic+predict.lspls">predict.lspls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##FIXME
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
