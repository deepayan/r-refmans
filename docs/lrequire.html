<!DOCTYPE html><html><head><title>Help for package lrequire</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lrequire}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#append.module.paths'><p>Append/Insert a path into module.paths, similar to append()</p></a></li>
<li><a href='#find.first.R'><p>Returns the path of the first found instance of <code>module</code> in <code>module.path</code>.</p></a></li>
<li><a href='#get.module.cache'><p>Returns the current file cache</p></a></li>
<li><a href='#get.module.paths'><p>Get existing collection of search paths of where to look for modules.</p></a></li>
<li><a href='#hide.not.found.warnings'><p>Globally hide warnings when modules are not found</p></a></li>
<li><a href='#lrequire'><p>Sources an R module with optional caching for subsequent attempts, exporting specified values</p></a></li>
<li><a href='#remove.from.module.cache'><p>Removes module from cache, applying same logic as <code>find.first.R</code> to find and remove it</p></a></li>
<li><a href='#remove.module.paths'><p>Remove one or more paths from <code>module.paths</code></p></a></li>
<li><a href='#reset.module.cache'><p>Resets the module cache, ensuring files are loaded on next require</p></a></li>
<li><a href='#show.module.cache'><p>Prints the current file cache</p></a></li>
<li><a href='#show.not.found.warnings'><p>Globally show warnings when modules are not found</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sources an R "Module" with Caching &amp; Encapsulation, Returning
Exported Vars</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-02-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Rick Wargo &lt;lrequire@rickwargo.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rick Wargo &lt;lrequire@rickwargo.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>In the fashion of 'node.js' <a href="https://nodejs.org/">https://nodejs.org/</a>, requires a file,
  sourcing into the current environment only the variables explicitly specified
  in the module.exports or exports list variable. If the file was already sourced,
  the result of the earlier sourcing is returned to the caller.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rickwargo/lrequire">https://github.com/rickwargo/lrequire</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rickwargo/lrequire/issues">https://github.com/rickwargo/lrequire/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-02-22 05:34:11 UTC; rick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-02-22 08:04:15</td>
</tr>
</table>
<hr>
<h2 id='append.module.paths'>Append/Insert a path into module.paths, similar to append()</h2><span id='topic+append.module.paths'></span>

<h3>Description</h3>

<p>Beware, little error checking is done to see if the indexes are valid.
Note the item indexes are 1-based.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append.module.paths(value, after = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.module.paths_+3A_value">value</code></td>
<td>
<p>(relative) path to insert into <code>module.paths</code></p>
</td></tr>
<tr><td><code id="append.module.paths_+3A_after">after</code></td>
<td>
<p>location in <code>module.paths</code> to append, 0 for the beginning, defaults
to -1 which appends to the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inserts `../R/lib' as the second path to search for modules
append.module.paths('../R/lib', after = 1)
</code></pre>

<hr>
<h2 id='find.first.R'>Returns the path of the first found instance of <code>module</code> in <code>module.path</code>.</h2><span id='topic+find.first.R'></span>

<h3>Description</h3>

<p>A symbol maybe passed instead of a string for readability. If an expression is passed, it must return a string value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.first.R(module, character.only = FALSE, warn.not.found = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.first.R_+3A_module">module</code></td>
<td>
<p>a string (or symbol) specifying the <code>module</code> to search for existance and readability in the current directory,
and if it cannot be found, searches for it in the list of directories specified by <code>module.paths</code>
and then through the set of paths with the module using a .R extension, if it was not originally
specified.</p>
</td></tr>
<tr><td><code id="find.first.R_+3A_character.only">character.only</code></td>
<td>
<p>a logical value, defaulted to FALSE, that permits an unquoted name to be <code>lrequire</code>-d.
Set this to TRUE when passing a variable to <code>lrequire</code>, requiring a quoted string.</p>
</td></tr>
<tr><td><code id="find.first.R_+3A_warn.not.found">warn.not.found</code></td>
<td>
<p>a logical value, defaulted to TRUE, can be set to not display warning messages when
module is not found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string consisting of the path the module was first found searching through module.paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hide.not.found.warnings()  # don't warn on files not foudn by find.first.R()

# Returns the path to the first found module according to module.paths
hello_ex.path &lt;- find.first.R(hello_ex)
</code></pre>

<hr>
<h2 id='get.module.cache'>Returns the current file cache</h2><span id='topic+get.module.cache'></span>

<h3>Description</h3>

<p>Returns the current file cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.module.cache()
</code></pre>


<h3>Value</h3>

<p>environment containing the file cache.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cache &lt;- get.module.cache()
</code></pre>

<hr>
<h2 id='get.module.paths'>Get existing collection of search paths of where to look for modules.</h2><span id='topic+get.module.paths'></span>

<h3>Description</h3>

<p>Get existing collection of search paths of where to look for modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.module.paths()
</code></pre>


<h3>Value</h3>

<p>Vector of paths (strings) that specify folders where to search for module files, in order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Returns a copy of the current module.paths
paths &lt;- get.module.paths()
</code></pre>

<hr>
<h2 id='hide.not.found.warnings'>Globally hide warnings when modules are not found</h2><span id='topic+hide.not.found.warnings'></span>

<h3>Description</h3>

<p>This is only to be called when handling results manually. This will be overridden by a <code>warn.not.found</code>
parameter explicitly set by either <code><a href="#topic+lrequire">lrequire</a></code>, <code><a href="#topic+find.first.R">find.first.R</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hide.not.found.warnings()
</code></pre>


<h3>Value</h3>

<p>nothing is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ensure warnings are not displayed when lrequire cannot find the module
hide.not.found.warnings()
</code></pre>

<hr>
<h2 id='lrequire'>Sources an R module with optional caching for subsequent attempts, exporting specified values</h2><span id='topic+lrequire'></span>

<h3>Description</h3>

<p><code>lrequire</code> looks in the current path, and then through a list of predefined paths
to search for the given module to source into the current environment, but only making visible
specific variables that are &quot;exported&quot; as a list, in a fashion similar
to <a href="https://nodejs.org/">node.js</a>. The caching behaviour can be either suspended or it can
re-source files that have changed since the last time the module was cached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrequire(module, force.reload = FALSE, character.only = FALSE,
  warn.not.found = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lrequire_+3A_module">module</code></td>
<td>
<p>a string (or expression) that specifies a module to load, with or without an optional .R extension. If
the module does not exist in the current directory, it searches for the module in directories listed in
<code>module.paths</code>, first seaching all directories for the named module,
then the module with a .R extension.
</p>

<ul>
<li><p>./R_modules/
</p>
</li>
<li><p>./lib/
</p>
</li>
<li><p>../R_modules/
</p>
</li>
<li><p>../lib/
</p>
</li>
<li><p>~/.R_modules
</p>
</li></ul>

<p>All variables exposed in the module will be hidden in the calling environment, except for
what is exposed through module.exports or the exports list variable.</p>
</td></tr>
<tr><td><code id="lrequire_+3A_force.reload">force.reload</code></td>
<td>
<p>a logical value, defaulted to FALSE, that can be set to TRUE to disable caching behavior for
the module. If the module has already been loaded and cached, setting <code>force.reload</code> to
TRUE will re-source the module. Setting it again to FALSE will re-source the module if the
previous state was TRUE.</p>
</td></tr>
<tr><td><code id="lrequire_+3A_character.only">character.only</code></td>
<td>
<p>a logical value, defaulted to FALSE, that permits an unquoted name to be <code>lrequire</code>-d.
Set this to TRUE when passing a variable to <code>lrequire</code>, requiring a quoted string.</p>
</td></tr>
<tr><td><code id="lrequire_+3A_warn.not.found">warn.not.found</code></td>
<td>
<p>a logical value, defaulted to TRUE, can be set to not display warning messages when
module is not found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lrequire</code> operates in a similar principle to modules in <a href="https://nodejs.org/">node.js</a> - keeping
any variables created in the source module isolated from the calling environment, while exposing a select set
of values/parameters. The specific values are exposed by setting a named list element in the <code>exports</code> variable
to the desired value or by assigning <code>module.exports</code> a value.
</p>
<p>Note this list exposed in <code>module.exports</code> should have named items so they can easily be accessed in
the calling environment, however that is not necessary if only a single value is being returned.
</p>
<p>If values are assigned to both <code>module.exports</code> and <code>exports</code>, only the values in <code>module.exports</code>
will be exposed to the caller.
</p>
<p>Caching a long-running operation, such as static data retrieval from a database is a good use of the
caching capability of <code>lrequire</code> during development when the same module is sourced multiple times.
</p>
<p>During development, files can be reloaded, even if being cached, if they have been modified after the time they
were cached. To enable this behaviour, set the variable <code>module.change_code</code> to 1.
</p>
<p>To quickly clear lrequire's package environment, unload the package. In RStudio, this can be done by unchecking
<code>lrequire</code> on the Packages tab. You can also execute the following at the R prompt:
<code>
    detach("package:lrequire", unload=TRUE)
    </code>
The next call to <code>library(lrequire)</code> will ensure it starts off with a clean slate.
</p>


<h3>Value</h3>

<p>Any values that exist in <code>module.exports</code> or, if that does not exist, then the
<em>list</em> <code>exports</code>.
</p>
<p>If no module is found, <code>NA</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Rick Wargo, <a href="mailto:lrequire@rickwargo.com">lrequire@rickwargo.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hide.not.found.warnings()  # don't warn on files not found by lrequire()

# If the module name is in a character vector, use:
my.module &lt;- 'myplot'
mm &lt;- lrequire(my.module, character.only = TRUE)

say.hello.to &lt;- lrequire(hello_ex)
# say.hello.to('Rick')  # use the say.hello.to() function that was returned by lrequire()

</code></pre>

<hr>
<h2 id='remove.from.module.cache'>Removes module from cache, applying same logic as <code><a href="#topic+find.first.R">find.first.R</a></code> to find and remove it</h2><span id='topic+remove.from.module.cache'></span>

<h3>Description</h3>

<p>Removes module from cache, applying same logic as <code><a href="#topic+find.first.R">find.first.R</a></code> to find and remove it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.from.module.cache(module, character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.from.module.cache_+3A_module">module</code></td>
<td>
<p>name of a module, same as the one used in the <code><a href="#topic+lrequire">lrequire</a></code> method, that will be removed
from the cache, such that the next time the <code>module</code> is <code><a href="#topic+lrequire">lrequire</a></code>'d, it will be
read and executed.</p>
</td></tr>
<tr><td><code id="remove.from.module.cache_+3A_character.only">character.only</code></td>
<td>
<p>a logical value, defaulted to FALSE, that permits an unquoted name to be <code>lrequire</code>-d.
Set this to TRUE when passing a variable to <code>lrequire</code>, requiring a quoted string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean value yielding success of removal from the cache
</p>


<h3>Examples</h3>

<pre><code class='language-R'>remove.from.module.cache(variables)
</code></pre>

<hr>
<h2 id='remove.module.paths'>Remove one or more paths from <code>module.paths</code></h2><span id='topic+remove.module.paths'></span>

<h3>Description</h3>

<p>Beware, little error checking is done to see if the indexes are valid.
Note the item indexes are 1-based.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.module.paths(index, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.module.paths_+3A_index">index</code></td>
<td>
<p>index of item to be removed from path</p>
</td></tr>
<tr><td><code id="remove.module.paths_+3A_...">...</code></td>
<td>
<p>optional indexes of items to be removed from path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Removes the2nd and 4th items from module.paths
remove.module.paths(2, 4)
</code></pre>

<hr>
<h2 id='reset.module.cache'>Resets the module cache, ensuring files are loaded on next require</h2><span id='topic+reset.module.cache'></span>

<h3>Description</h3>

<p>Note the chace contains other hidden variables, kept in the cache (or environment). These are not removed,
and removing them will conflict with the ability of <code><a href="#topic+lrequire">lrequire</a></code> to perform properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset.module.cache()
</code></pre>


<h3>Value</h3>

<p>Nothing is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reset.module.cache()
</code></pre>

<hr>
<h2 id='show.module.cache'>Prints the current file cache</h2><span id='topic+show.module.cache'></span>

<h3>Description</h3>

<p>Prints the current file cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.module.cache(all.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.module.cache_+3A_all.names">all.names</code></td>
<td>
<p>a logical value. If TRUE, all object names are returned. If FALSE,
names which begin with a . are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned, however, the contents of the module cache are printed to the standard output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show.module.cache()
show.module.cache(all.names = TRUE)
</code></pre>

<hr>
<h2 id='show.not.found.warnings'>Globally show warnings when modules are not found</h2><span id='topic+show.not.found.warnings'></span>

<h3>Description</h3>

<p>This is the default behaviour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.not.found.warnings()
</code></pre>


<h3>Details</h3>

<p>This is only to be called when handling results manually. This will be overridden by a <code>warn.not.found</code>
parameter explicitly set by either <code><a href="#topic+lrequire">lrequire</a></code> or <code><a href="#topic+find.first.R">find.first.R</a></code>.
</p>


<h3>Value</h3>

<p>nothing is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ensure warnings are displayed when lrequire cannot find the module
show.not.found.warnings()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
