<!DOCTYPE html><html lang="en"><head><title>Help for package duckplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {duckplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#duckplyr-package'><p>duckplyr: A 'DuckDB'-Backed Version of 'dplyr'</p></a></li>
<li><a href='#anti_join.duckplyr_df'><p>Anti join</p></a></li>
<li><a href='#arrange.duckplyr_df'><p>Order rows using column values</p></a></li>
<li><a href='#as_duckplyr_df'><p>Convert to a duckplyr data frame</p></a></li>
<li><a href='#collect.duckplyr_df'><p>Force conversion to a data frame</p></a></li>
<li><a href='#compute_csv'><p>Compute results to a CSV file</p></a></li>
<li><a href='#compute_parquet'><p>Compute results to a Parquet file</p></a></li>
<li><a href='#compute.duckplyr_df'><p>Compute results</p></a></li>
<li><a href='#config'><p>Configuration options</p></a></li>
<li><a href='#count.duckplyr_df'><p>Count the observations in each group</p></a></li>
<li><a href='#db_exec'><p>Execute a statement for the default connection</p></a></li>
<li><a href='#df_from_file'><p>Read Parquet, CSV, and other files using DuckDB</p></a></li>
<li><a href='#distinct.duckplyr_df'><p>Keep distinct/unique rows</p></a></li>
<li><a href='#duckdb_tibble'><p>duckplyr data frames</p></a></li>
<li><a href='#duckplyr_execute'><p>Execute a statement for the default connection</p></a></li>
<li><a href='#explain.duckplyr_df'><p>Explain details of a tbl</p></a></li>
<li><a href='#fallback'><p>Fallback to dplyr</p></a></li>
<li><a href='#filter.duckplyr_df'><p>Keep rows that match a condition</p></a></li>
<li><a href='#flights_df'><p>Flight data</p></a></li>
<li><a href='#full_join.duckplyr_df'><p>Full join</p></a></li>
<li><a href='#head.duckplyr_df'><p>Return the First Parts of an Object</p></a></li>
<li><a href='#inner_join.duckplyr_df'><p>Inner join</p></a></li>
<li><a href='#intersect.duckplyr_df'><p>Intersect</p></a></li>
<li><a href='#is_duckplyr_df'><p>Class predicate for duckplyr data frames</p></a></li>
<li><a href='#last_rel'><p>Retrieve details about the most recent computation</p></a></li>
<li><a href='#left_join.duckplyr_df'><p>Left join</p></a></li>
<li><a href='#methods_overwrite'><p>Forward all dplyr methods to duckplyr</p></a></li>
<li><a href='#mutate.duckplyr_df'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#new_relational'><p>Relational implementer's interface</p></a></li>
<li><a href='#new_relexpr'><p>Relational expressions</p></a></li>
<li><a href='#pull.duckplyr_df'><p>Extract a single column</p></a></li>
<li><a href='#read_csv_duckdb'><p>Read CSV files using DuckDB</p></a></li>
<li><a href='#read_file_duckdb'><p>Read files using DuckDB</p></a></li>
<li><a href='#read_json_duckdb'><p>Read JSON files using DuckDB</p></a></li>
<li><a href='#read_parquet_duckdb'><p>Read Parquet files using DuckDB</p></a></li>
<li><a href='#read_sql_duckdb'><p>Return SQL query as duckdb_tibble</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relocate.duckplyr_df'><p>Change column order</p></a></li>
<li><a href='#rename.duckplyr_df'><p>Rename columns</p></a></li>
<li><a href='#right_join.duckplyr_df'><p>Right join</p></a></li>
<li><a href='#select.duckplyr_df'><p>Keep or drop columns using their names and types</p></a></li>
<li><a href='#semi_join.duckplyr_df'><p>Semi join</p></a></li>
<li><a href='#setdiff.duckplyr_df'><p>Set difference</p></a></li>
<li><a href='#stats_show'><p>Show stats</p></a></li>
<li><a href='#summarise.duckplyr_df'><p>Summarise each group down to one row</p></a></li>
<li><a href='#symdiff.duckplyr_df'><p>Symmetric difference</p></a></li>
<li><a href='#transmute.duckplyr_df'><p>Create, modify, and delete columns</p></a></li>
<li><a href='#union_all.duckplyr_df'><p>Union of all</p></a></li>
<li><a href='#union.duckplyr_df'><p>Union</p></a></li>
<li><a href='#unsupported'><p>Verbs not implemented in duckplyr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A 'DuckDB'-Backed Version of 'dplyr'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A drop-in replacement for 'dplyr', powered by 'DuckDB' for
    performance.  Offers convenient utilities for working with in-memory and
    larger-than-memory data while retaining full 'dplyr' compatibility.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://duckplyr.tidyverse.org">https://duckplyr.tidyverse.org</a>,
<a href="https://github.com/tidyverse/duckplyr">https://github.com/tidyverse/duckplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/duckplyr/issues">https://github.com/tidyverse/duckplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), dplyr (&ge; 1.1.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, collections, DBI, duckdb (&ge; 1.2.0), glue, jsonlite,
lifecycle, magrittr, memoise, pillar (&ge; 1.10.1), rlang (&ge;
1.0.6), tibble, tidyselect, utils, vctrs (&ge; 0.6.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arrow, brio, callr, conflicted, constructive (&ge; 1.0.0),
curl, dbplyr, hms, knitr, lobstr, lubridate, nycflights13,
palmerpenguins, prettycode, purrr, readr, rmarkdown, testthat
(&ge; 3.1.5), usethis, withr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>qs, reprex, rstudioapi</td>
</tr>
<tr>
<td>Config/Needs/check:</td>
<td>anthonynorth/roxyglobals</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate, dbplyr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>rel_api, tpch, as_duckplyr_df,
dplyr-mutate, dplyr-filter, dplyr-count-tally</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2.9000</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 14:02:47 UTC; kirill</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannes Mühleisen <a href="https://orcid.org/0000-0001-8552-0029"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kirill Müller &lt;kirill@cynkra.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 14:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='duckplyr-package'>duckplyr: A 'DuckDB'-Backed Version of 'dplyr'</h2><span id='topic+duckplyr'></span><span id='topic+duckplyr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A drop-in replacement for 'dplyr', powered by 'DuckDB' for performance. Offers convenient utilities for working with in-memory and larger-than-memory data while retaining full 'dplyr' compatibility.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Hannes Mühleisen (<a href="https://orcid.org/0000-0001-8552-0029">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://duckplyr.tidyverse.org">https://duckplyr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/duckplyr">https://github.com/tidyverse/duckplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/duckplyr/issues">https://github.com/tidyverse/duckplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='anti_join.duckplyr_df'>Anti join</h2><span id='topic+anti_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> generic.
<code>anti_join()</code> returns all rows from <code>x</code> with<strong>out</strong> a match in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
anti_join(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anti_join.duckplyr_df_+3A_x">x</code>, <code id="anti_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="anti_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="anti_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="anti_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="anti_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
band_members %&gt;% anti_join(band_instruments)
</code></pre>

<hr>
<h2 id='arrange.duckplyr_df'>Order rows using column values</h2><span id='topic+arrange.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>arrange()</code> orders the rows of a data frame by the values of selected
columns.
</p>
<p>Unlike other dplyr verbs, <code>arrange()</code> largely ignores grouping; you
need to explicitly mention grouping variables (or use  <code>.by_group = TRUE</code>)
in order to group by them, and functions of variables are evaluated
once per data frame, not once per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
arrange(.data, ..., .by_group = FALSE, .locale = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="arrange.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables, or
functions of variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending
order.</p>
</td></tr>
<tr><td><code id="arrange.duckplyr_df_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
<tr><td><code id="arrange.duckplyr_df_+3A_.locale">.locale</code></td>
<td>
<p>The locale to sort character vectors in.
</p>

<ul>
<li><p> If <code>NULL</code>, the default, uses the <code>"C"</code> locale unless the
<code>dplyr.legacy_locale</code> global option escape hatch is active. See the
<a href="dplyr.html#topic+dplyr-locale">dplyr-locale</a> help page for more details.
</p>
</li>
<li><p> If a single string from <code><a href="stringi.html#topic+stri_locale_list">stringi::stri_locale_list()</a></code> is supplied, then
this will be used as the locale to sort with. For example, <code>"en"</code> will
sort with the American English locale. This requires the stringi package.
</p>
</li>
<li><p> If <code>"C"</code> is supplied, then character vectors will always be sorted in the
C locale. This does not require stringi and is often much faster than
supplying a locale identifier.
</p>
</li></ul>

<p>The C locale is not the same as English locales, such as <code>"en"</code>,
particularly when it comes to data containing a mix of upper and lower case
letters. This is explained in more detail on the <a href="dplyr.html#topic+dplyr-locale">locale</a>
help page under the <code style="white-space: pre;">&#8288;Default locale&#8288;</code> section.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>arrange.duckplyr_df()</code>
</p>

<ul>
<li><p> with <code>.by_group = TRUE</code>,
</p>
</li>
<li><p> providing a value for the <code>.locale</code> argument,
</p>
</li>
<li><p> providing a value for the <code>dplyr.legacy_locale</code> option.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
arrange(mtcars, cyl, disp)
arrange(mtcars, desc(disp))
</code></pre>

<hr>
<h2 id='as_duckplyr_df'>Convert to a duckplyr data frame</h2><span id='topic+as_duckplyr_df'></span><span id='topic+as_duckplyr_tibble'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions convert a data-frame-like input to an object of class <code>"duckpylr_df"</code>.
For such objects,
dplyr verbs such as <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> or <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>  will attempt to use DuckDB.
If this is not possible, the original dplyr implementation is used.
</p>
<p><code>as_duckplyr_df()</code> requires the input to be a plain data frame or a tibble,
and will fail for any other classes, including subclasses of <code>"data.frame"</code> or <code>"tbl_df"</code>.
This behavior is likely to change, do not rely on it.
</p>
<p><code>as_duckplyr_tibble()</code> converts the input to a tibble and then to a duckplyr data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_duckplyr_df(.data)

as_duckplyr_tibble(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>data frame or tibble to transform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set the <code>DUCKPLYR_FALLBACK_INFO</code> and <code>DUCKPLYR_FORCE</code> environment variables
for more control over the behavior, see <a href="#topic+config">config</a> for more details.
</p>


<h3>Value</h3>

<p>For <code>as_duckplyr_df()</code>, an object of class <code>"duckplyr_df"</code>,
inheriting from the classes of the <code>.data</code> argument.
</p>
<p>For <code>as_duckplyr_tibble()</code>, an object of class
<code>c("duckplyr_df", class(tibble()))</code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble(a = 1:3) %&gt;%
  mutate(b = a + 1)
</code></pre>

<hr>
<h2 id='collect.duckplyr_df'>Force conversion to a data frame</h2><span id='topic+collect.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code> generic.
<code>collect()</code> converts the input to a tibble, materializing any lazy operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
collect(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect.duckplyr_df_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for more
details.</p>
</td></tr>
<tr><td><code id="collect.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- duckdb_tibble(x = c(1, 2), .lazy = TRUE)
df
try(print(df$x))
df &lt;- collect(df)
df
</code></pre>

<hr>
<h2 id='compute_csv'>Compute results to a CSV file</h2><span id='topic+compute_csv'></span>

<h3>Description</h3>

<p>For a duckplyr frame, this function executes the query
and stores the results in a CSV file,
without converting it to an R data frame.
The result is a duckplyr frame that can be used with subsequent dplyr verbs.
This function can also be used as a CSV writer for regular data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_csv(x, path, ..., prudence = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_csv_+3A_x">x</code></td>
<td>
<p>A duckplyr frame.</p>
</td></tr>
<tr><td><code id="compute_csv_+3A_path">path</code></td>
<td>
<p>The path of the Parquet file to create.</p>
</td></tr>
<tr><td><code id="compute_csv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="compute_csv_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never,
</p>
</li>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells.
</p>
</li></ul>

<p>The default is to inherit from the input.
This argument is provided here only for convenience.
The same effect can be achieved by forwarding the output to <code><a href="#topic+as_duckdb_tibble">as_duckdb_tibble()</a></code>
with the desired prudence.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="compute_csv_+3A_options">options</code></td>
<td>
<p>A list of additional options to pass to create the storage format,
see <a href="https://duckdb.org/docs/sql/statements/copy.html#csv-options">https://duckdb.org/docs/sql/statements/copy.html#csv-options</a>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A duckplyr frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_parquet">compute_parquet()</a></code>, <code><a href="#topic+compute.duckplyr_df">compute.duckplyr_df()</a></code>, <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- data.frame(x = c(1, 2))
df &lt;- mutate(df, y = 2)
path &lt;- tempfile(fileext = ".csv")
df &lt;- compute_csv(df, path)
readLines(path)
</code></pre>

<hr>
<h2 id='compute_parquet'>Compute results to a Parquet file</h2><span id='topic+compute_parquet'></span>

<h3>Description</h3>

<p>For a duckplyr frame, this function executes the query
and stores the results in a Parquet file,
without converting it to an R data frame.
The result is a duckplyr frame that can be used with subsequent dplyr verbs.
This function can also be used as a Parquet writer for regular data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_parquet(x, path, ..., prudence = NULL, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_parquet_+3A_x">x</code></td>
<td>
<p>A duckplyr frame.</p>
</td></tr>
<tr><td><code id="compute_parquet_+3A_path">path</code></td>
<td>
<p>The path of the Parquet file to create.</p>
</td></tr>
<tr><td><code id="compute_parquet_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="compute_parquet_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never,
</p>
</li>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells.
</p>
</li></ul>

<p>The default is to inherit from the input.
This argument is provided here only for convenience.
The same effect can be achieved by forwarding the output to <code><a href="#topic+as_duckdb_tibble">as_duckdb_tibble()</a></code>
with the desired prudence.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="compute_parquet_+3A_options">options</code></td>
<td>
<p>A list of additional options to pass to create the Parquet file,
see <a href="https://duckdb.org/docs/sql/statements/copy.html#parquet-options">https://duckdb.org/docs/sql/statements/copy.html#parquet-options</a>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A duckplyr frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_csv">compute_csv()</a></code>, <code><a href="#topic+compute.duckplyr_df">compute.duckplyr_df()</a></code>, <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- data.frame(x = c(1, 2))
df &lt;- mutate(df, y = 2)
path &lt;- tempfile(fileext = ".parquet")
df &lt;- compute_parquet(df, path)
explain(df)
</code></pre>

<hr>
<h2 id='compute.duckplyr_df'>Compute results</h2><span id='topic+compute.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+compute">dplyr::compute()</a></code> generic.
For a duckplyr frame,
<code>compute()</code> executes a query but stores it in a (temporary) table,
or in a Parquet or CSV file.
The result is a duckplyr frame that can be used with subsequent dplyr verbs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
compute(
  x,
  ...,
  prudence = NULL,
  name = NULL,
  schema_name = NULL,
  temporary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.duckplyr_df_+3A_x">x</code></td>
<td>
<p>A duckplyr frame.</p>
</td></tr>
<tr><td><code id="compute.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
<tr><td><code id="compute.duckplyr_df_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never,
</p>
</li>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells.
</p>
</li></ul>

<p>The default is to inherit from the input.
This argument is provided here only for convenience.
The same effect can be achieved by forwarding the output to <code><a href="#topic+as_duckdb_tibble">as_duckdb_tibble()</a></code>
with the desired prudence.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="compute.duckplyr_df_+3A_name">name</code></td>
<td>
<p>The name of the table to store the result in.</p>
</td></tr>
<tr><td><code id="compute.duckplyr_df_+3A_schema_name">schema_name</code></td>
<td>
<p>The schema to store the result in, defaults to the current schema.</p>
</td></tr>
<tr><td><code id="compute.duckplyr_df_+3A_temporary">temporary</code></td>
<td>
<p>Set to <code>FALSE</code> to store the result in a permanent table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A duckplyr frame.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- duckdb_tibble(x = c(1, 2))
df &lt;- mutate(df, y = 2)
explain(df)
df &lt;- compute(df)
explain(df)
</code></pre>

<hr>
<h2 id='config'>Configuration options</h2><span id='topic+config'></span>

<h3>Description</h3>

<p>The behavior of duckplyr can be fine-tuned with several environment variables,
and one option.
</p>


<h3>Environment variables</h3>

<p><code>DUCKPLYR_TEMP_DIR</code>: Set to a path where temporary files can be created.
By default, <code><a href="base.html#topic+tempdir">tempdir()</a></code> is used.
</p>
<p><code>DUCKPLYR_OUTPUT_ORDER</code>: If <code>TRUE</code>, row output order is preserved.
The default may change the row order where dplyr would keep it stable.
Preserving the order leads to more complicated execution plans
with less potential for optimization, and thus may be slower.
</p>
<p><code>DUCKPLYR_FORCE</code>: If <code>TRUE</code>, fail if duckdb cannot handle a request.
</p>
<p><code>DUCKPLYR_CHECK_ROUNDTRIP</code>: If <code>TRUE</code>, check if all columns are roundtripped perfectly
when creating a relational object from a data frame,
This is slow, and mostly useful for debugging.
The default is to check roundtrip of attributes.
</p>
<p><code>DUCKPLYR_EXPERIMENTAL</code>: If <code>TRUE</code>, pass <code>experimental = TRUE</code>
to certain duckdb functions.
Currently unused.
</p>
<p><code>DUCKPLYR_METHODS_OVERWRITE</code>: If <code>TRUE</code>, call <code>methods_overwrite()</code>
when the package is loaded.
</p>
<p>See <a href="#topic+fallback">fallback</a> for more options related to printing, logging, and uploading
of fallback events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE)
data.frame(a = 3:1) %&gt;%
  as_duckdb_tibble() %&gt;%
  inner_join(data.frame(a = 1:4), by = "a")

withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = "TRUE"), {
  data.frame(a = 3:1) %&gt;%
    as_duckdb_tibble() %&gt;%
    inner_join(data.frame(a = 1:4), by = "a")
})

# Sys.setenv(DUCKPLYR_FORCE = TRUE)
add_one &lt;- function(x) {
  x + 1
}

data.frame(a = 3:1) %&gt;%
  as_duckdb_tibble() %&gt;%
  mutate(b = add_one(a))

try(withr::with_envvar(c(DUCKPLYR_FORCE = "TRUE"), {
  data.frame(a = 3:1) %&gt;%
    as_duckdb_tibble() %&gt;%
    mutate(b = add_one(a))
}))

# Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE)
withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = "TRUE"), {
  data.frame(a = 3:1) %&gt;%
    as_duckdb_tibble() %&gt;%
    mutate(b = add_one(a))
})
</code></pre>

<hr>
<h2 id='count.duckplyr_df'>Count the observations in each group</h2><span id='topic+count.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+count">dplyr::count()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>count()</code> lets you quickly count the unique values of one or more variables:
<code>df %&gt;% count(a, b)</code> is roughly equivalent to
<code>df %&gt;% group_by(a, b) %&gt;% summarise(n = n())</code>.
<code>count()</code> is paired with <code>tally()</code>, a lower-level helper that is equivalent
to <code>df %&gt;% summarise(n = n())</code>. Supply <code>wt</code> to perform weighted counts,
switching the summary from <code>n = n()</code> to <code>n = sum(wt)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = NULL,
  .drop = group_by_drop_default(x)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count.duckplyr_df_+3A_x">x</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="count.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Variables to group
by.</p>
</td></tr>
<tr><td><code id="count.duckplyr_df_+3A_wt">wt</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="count.duckplyr_df_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="count.duckplyr_df_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
</p>
<p>If omitted, it will default to <code>n</code>. If there's already a column called <code>n</code>,
it will use <code>nn</code>. If there's a column called <code>n</code> and <code>nn</code>, it'll use
<code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="count.duckplyr_df_+3A_.drop">.drop</code></td>
<td>
<p>Handling of factor levels that don't appear in the data, passed
on to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>.
</p>
<p>For <code>count()</code>: if <code>FALSE</code> will include counts for empty groups (i.e. for
levels of factors that don't exist in the data).
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> For <code>add_count()</code>: deprecated since it
can't actually affect the output.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>count.duckplyr_df()</code>
</p>

<ul>
<li><p> with complex expressions in <code>...</code>,
</p>
</li>
<li><p> with <code>.drop = FALSE</code>,
</p>
</li>
<li><p> with <code>sort = TRUE</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+count">dplyr::count()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">dplyr::count()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
count(mtcars, am)
</code></pre>

<hr>
<h2 id='db_exec'>Execute a statement for the default connection</h2><span id='topic+db_exec'></span>

<h3>Description</h3>

<p>The <span class="pkg">duckplyr</span> package relies on a DBI connection
to an in-memory database.
The <code>db_exec()</code> function allows running SQL statements
with side effects on this connection.
It can be used to execute statements that start with
<code>PRAGMA</code>, <code>SET</code>, or <code>ATTACH</code>
to, e.g., set up credentials, change configuration options,
or attach other databases.
See <a href="https://duckdb.org/docs/configuration/overview.html">https://duckdb.org/docs/configuration/overview.html</a>
for more information on the configuration options,
and <a href="https://duckdb.org/docs/sql/statements/attach.html">https://duckdb.org/docs/sql/statements/attach.html</a>
for attaching databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_exec(sql, ..., con = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="db_exec_+3A_sql">sql</code></td>
<td>
<p>The statement to run.</p>
</td></tr>
<tr><td><code id="db_exec_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="db_exec_+3A_con">con</code></td>
<td>
<p>The connection, defaults to the default connection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of the <code><a href="DBI.html#topic+dbExecute">DBI::dbExecute()</a></code> call, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_sql_duckdb">read_sql_duckdb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db_exec("SET threads TO 2")
</code></pre>

<hr>
<h2 id='df_from_file'>Read Parquet, CSV, and other files using DuckDB</h2><span id='topic+df_from_file'></span><span id='topic+duckplyr_df_from_file'></span><span id='topic+df_from_csv'></span><span id='topic+duckplyr_df_from_csv'></span><span id='topic+df_from_parquet'></span><span id='topic+duckplyr_df_from_parquet'></span><span id='topic+df_to_parquet'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>df_from_file()</code> uses arbitrary table functions to read data.
See <a href="https://duckdb.org/docs/data/overview">https://duckdb.org/docs/data/overview</a> for a documentation
of the available functions and their options.
To read multiple files with the same schema,
pass a wildcard or a character vector to the <code>path</code> argument,
</p>
<p><code>duckplyr_df_from_file()</code> is a thin wrapper around <code>df_from_file()</code>
that calls <code>as_duckplyr_df()</code> on the output.
</p>
<p>These functions ingest data from a file using a table function.
The results are transparently converted to a data frame, but the data is only read when
the resulting data frame is actually accessed.
</p>
<p><code>df_from_csv()</code> reads a CSV file using the <code>read_csv_auto()</code> table function.
</p>
<p><code>duckplyr_df_from_csv()</code> is a thin wrapper around <code>df_from_csv()</code>
that calls <code>as_duckplyr_df()</code> on the output.
</p>
<p><code>df_from_parquet()</code> reads a Parquet file using the <code>read_parquet()</code> table function.
</p>
<p><code>duckplyr_df_from_parquet()</code> is a thin wrapper around <code>df_from_parquet()</code>
that calls <code>as_duckplyr_df()</code> on the output.
</p>
<p><code>df_to_parquet()</code> writes a data frame to a Parquet file via DuckDB.
If the data frame is a <code>duckplyr_df</code>, the materialization occurs outside of R.
An existing file will be overwritten.
This function requires duckdb &gt;= 0.10.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_from_file(path, table_function, ..., options = list(), class = NULL)

duckplyr_df_from_file(
  path,
  table_function,
  ...,
  options = list(),
  class = NULL
)

df_from_csv(path, ..., options = list(), class = NULL)

duckplyr_df_from_csv(path, ..., options = list(), class = NULL)

df_from_parquet(path, ..., options = list(), class = NULL)

duckplyr_df_from_parquet(path, ..., options = list(), class = NULL)

df_to_parquet(data, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_from_file_+3A_path">path</code></td>
<td>
<p>Path to files, glob patterns <code>*</code> and <code style="white-space: pre;">&#8288;?&#8288;</code> are supported.</p>
</td></tr>
<tr><td><code id="df_from_file_+3A_table_function">table_function</code></td>
<td>
<p>The name of a table-valued
DuckDB function such as <code>"read_parquet"</code>,
<code>"read_csv"</code>, <code>"read_csv_auto"</code> or <code>"read_json"</code>.</p>
</td></tr>
<tr><td><code id="df_from_file_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="df_from_file_+3A_options">options</code></td>
<td>
<p>Arguments to the DuckDB function
indicated by <code>table_function</code>.</p>
</td></tr>
<tr><td><code id="df_from_file_+3A_class">class</code></td>
<td>
<p>The class of the output.
By default, a tibble is created.
The returned object will always be a data frame.
Use <code>class = "data.frame"</code> or <code>class = character()</code>
to create a plain data frame.</p>
</td></tr>
<tr><td><code id="df_from_file_+3A_data">data</code></td>
<td>
<p>A data frame to be written to disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame for <code>df_from_file()</code>, or a <code>duckplyr_df</code> for
<code>duckplyr_df_from_file()</code>, extended by the provided <code>class</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create simple CSV file
path &lt;- tempfile("duckplyr_test_", fileext = ".csv")
write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)

# Reading is immediate
df &lt;- df_from_csv(path)

# Materialization only upon access
names(df)
df$a

# Return as tibble, specify column types:
df_from_file(
  path,
  "read_csv",
  options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR"))),
  class = class(tibble())
)

# Read multiple file at once
path2 &lt;- tempfile("duckplyr_test_", fileext = ".csv")
write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)

duckplyr_df_from_csv(file.path(tempdir(), "duckplyr_test_*.csv"))

unlink(c(path, path2))

# Write a Parquet file:
path_parquet &lt;- tempfile(fileext = ".parquet")
df_to_parquet(df, path_parquet)

# With a duckplyr_df, the materialization occurs outside of R:
df %&gt;%
  as_duckplyr_df() %&gt;%
  mutate(b = a + 1) %&gt;%
  df_to_parquet(path_parquet)

duckplyr_df_from_parquet(path_parquet)

unlink(path_parquet)
</code></pre>

<hr>
<h2 id='distinct.duckplyr_df'>Keep distinct/unique rows</h2><span id='topic+distinct.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code> generic.
Keep only unique/distinct rows from a data frame.
This is similar to <code>unique.data.frame()</code> but considerably faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distinct.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="distinct.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Optional variables to
use when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables in the data frame.</p>
</td></tr>
<tr><td><code id="distinct.duckplyr_df_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- duckdb_tibble(
  x = sample(10, 100, rep = TRUE),
  y = sample(10, 100, rep = TRUE)
)
nrow(df)
nrow(distinct(df))
</code></pre>

<hr>
<h2 id='duckdb_tibble'>duckplyr data frames</h2><span id='topic+duckdb_tibble'></span><span id='topic+as_duckdb_tibble'></span><span id='topic+is_duckdb_tibble'></span>

<h3>Description</h3>

<p>Data frames backed by duckplyr have a special class, <code>"duckplyr_df"</code>,
in addition to the default classes.
This ensures that dplyr methods are dispatched correctly.
For such objects,
dplyr verbs such as <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> or <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>  will use DuckDB.
</p>
<p><code>duckdb_tibble()</code> works like <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
</p>
<p><code>as_duckdb_tibble()</code> converts a data frame or a dplyr lazy table to a duckplyr data frame.
This is a generic function that can be overridden for custom classes.
</p>
<p><code>is_duckdb_tibble()</code> returns <code>TRUE</code> if <code>x</code> is a duckplyr data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duckdb_tibble(..., .prudence = c("lavish", "thrifty", "stingy"))

as_duckdb_tibble(x, ..., prudence = c("lavish", "thrifty", "stingy"))

is_duckdb_tibble(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duckdb_tibble_+3A_...">...</code></td>
<td>
<p>For <code>duckdb_tibble()</code>, passed on to <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>.
For <code>as_duckdb_tibble()</code>, passed on to methods.</p>
</td></tr>
<tr><td><code id="duckdb_tibble_+3A_x">x</code></td>
<td>
<p>The object to convert or to test.</p>
</td></tr>
<tr><td><code id="duckdb_tibble_+3A_prudence">prudence</code>, <code id="duckdb_tibble_+3A_.prudence">.prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never,
</p>
</li>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells.
</p>
</li></ul>

<p>The default is <code>"lavish"</code> for <code>duckdb_tibble()</code> and <code>as_duckdb_tibble()</code>,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>duckdb_tibble()</code> and <code>as_duckdb_tibble()</code>, an object with the following classes:
</p>

<ul>
<li> <p><code>"prudent_duckplyr_df"</code> if <code>prudence</code> is not <code>"lavish"</code>
</p>
</li>
<li> <p><code>"duckplyr_df"</code>
</p>
</li>
<li><p> Classes of a <a href="tibble.html#topic+tibble">tibble::tibble</a>
</p>
</li></ul>

<p>For <code>is_duckdb_tibble()</code>, a scalar logical.
</p>


<h3>Fine-tuning prudence</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The <code>prudence</code> argument can also be a named numeric vector
with at least one of <code>cells</code> or <code>rows</code>
to limit the cells (values) and rows in the resulting data frame
after automatic materialization.
If both limits are specified, both are enforced.
The equivalent of <code>"thrifty"</code> is <code>c(cells = 1e6)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- duckdb_tibble(a = 1)
x

library(dplyr)
x %&gt;%
  mutate(b = 2)

x$a

y &lt;- duckdb_tibble(a = 1, .prudence = "stingy")
y
try(length(y$a))
length(collect(y)$a)
</code></pre>

<hr>
<h2 id='duckplyr_execute'>Execute a statement for the default connection</h2><span id='topic+duckplyr_execute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>The <span class="pkg">duckplyr</span> package relies on a DBI connection
to an in-memory database.
The <code>duckplyr_execute()</code> function allows running SQL statements
with this connection to, e.g., set up credentials
or attach other databases.
See <a href="https://duckdb.org/docs/configuration/overview.html">https://duckdb.org/docs/configuration/overview.html</a>
for more information on the configuration options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duckplyr_execute(sql)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duckplyr_execute_+3A_sql">sql</code></td>
<td>
<p>The statement to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of the <code><a href="DBI.html#topic+dbExecute">DBI::dbExecute()</a></code> call, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>duckplyr_execute("SET threads TO 2")
</code></pre>

<hr>
<h2 id='explain.duckplyr_df'>Explain details of a tbl</h2><span id='topic+explain.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+explain">dplyr::explain()</a></code> generic.
This is a generic function which gives more details about an object
than <code>print()</code>, and is more focused on human readable output than <code>str()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
explain(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explain.duckplyr_df_+3A_x">x</code></td>
<td>
<p>An object to explain</p>
</td></tr>
<tr><td><code id="explain.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters possibly used by generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+explain">dplyr::explain()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- duckdb_tibble(x = c(1, 2))
df &lt;- mutate(df, y = 2)
explain(df)
</code></pre>

<hr>
<h2 id='fallback'>Fallback to dplyr</h2><span id='topic+fallback'></span><span id='topic+fallback_sitrep'></span><span id='topic+fallback_config'></span><span id='topic+fallback_review'></span><span id='topic+fallback_upload'></span><span id='topic+fallback_purge'></span>

<h3>Description</h3>

<p>The <span class="pkg">duckplyr</span> package aims at providing
a fully compatible drop-in replacement for <span class="pkg">dplyr</span>.
To achieve this, only a carefully selected subset of <span class="pkg">dplyr</span>'s operations,
R functions, and R data types are implemented.
Whenever a request cannot be handled by DuckDB,
<span class="pkg">duckplyr</span> falls back to <span class="pkg">dplyr</span>.
See <code style="white-space: pre;">&#8288;vignette("fallback"&#8288;</code>)' for details.
</p>
<p>To assist future development, the fallback situations can be logged
to the console or to a local file and uploaded for analysis.
By default, <span class="pkg">duckplyr</span> will not log or upload anything.
The functions and environment variables on this page control the process.
</p>
<p><code>fallback_sitrep()</code> prints the current settings for fallback printing, logging,
and uploading, the number of reports ready for upload, and the location of the logs.
</p>
<p><code>fallback_config()</code> configures the current settings for fallback printing,
logging, and uploading.
Only settings that do not affect computation results can be configured,
this is by design.
The configuration is stored in a file under <code>tools::R_user_dir("duckplyr", "config")</code> .
When the <span class="pkg">duckplyr</span> package is loaded, the configuration is read from this file,
and the corresponding environment variables are set.
</p>
<p><code>fallback_review()</code> prints the available reports for review to the console.
</p>
<p><code>fallback_upload()</code> uploads the available reports to a central server for analysis.
The server is hosted on AWS and the reports are stored in a private S3 bucket.
Only authorized personnel have access to the reports.
</p>
<p><code>fallback_purge()</code> deletes some or all available reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fallback_sitrep()

fallback_config(
  ...,
  reset_all = FALSE,
  info = NULL,
  logging = NULL,
  autoupload = NULL,
  log_dir = NULL,
  verbose = NULL
)

fallback_review(oldest = NULL, newest = NULL, detail = TRUE)

fallback_upload(oldest = NULL, newest = NULL, strict = TRUE)

fallback_purge(oldest = NULL, newest = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fallback_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="fallback_+3A_reset_all">reset_all</code></td>
<td>
<p>Set to <code>TRUE</code> to reset all settings to their defaults.
The R session must be restarted for the changes to take effect.</p>
</td></tr>
<tr><td><code id="fallback_+3A_info">info</code></td>
<td>
<p>Set to <code>TRUE</code> to enable fallback printing.</p>
</td></tr>
<tr><td><code id="fallback_+3A_logging">logging</code></td>
<td>
<p>Set to <code>FALSE</code> to disable fallback logging,
set to <code>TRUE</code> to explicitly enable it.</p>
</td></tr>
<tr><td><code id="fallback_+3A_autoupload">autoupload</code></td>
<td>
<p>Set to <code>TRUE</code> to enable automatic fallback uploading,
set to <code>FALSE</code> to disable it.</p>
</td></tr>
<tr><td><code id="fallback_+3A_log_dir">log_dir</code></td>
<td>
<p>Set the location of the logs in the file system.
The directory will be created if it does not exist.</p>
</td></tr>
<tr><td><code id="fallback_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to enable verbose logging.</p>
</td></tr>
<tr><td><code id="fallback_+3A_oldest">oldest</code>, <code id="fallback_+3A_newest">newest</code></td>
<td>
<p>The number of oldest or newest reports to review.
If not specified, all reports are dispayed.</p>
</td></tr>
<tr><td><code id="fallback_+3A_detail">detail</code></td>
<td>
<p>Print the full content of the reports.
Set to <code>FALSE</code> to only print the file names.</p>
</td></tr>
<tr><td><code id="fallback_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, the function aborts if any of the reports fail to upload.
With <code>FALSE</code>, only a message is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Logging is on by default, but can be turned off.
Uploading is opt-in.
</p>
<p>The following environment variables control the logging and uploading:
</p>

<ul>
<li> <p><code>DUCKPLYR_FALLBACK_INFO</code> controls human-friendly alerts
for fallback events.
If <code>TRUE</code>, a message is printed when a fallback to dplyr occurs
because DuckDB cannot handle a request.
These messages are never logged.
</p>
</li>
<li> <p><code>DUCKPLYR_FALLBACK_COLLECT</code> controls logging, set it
to 1 or greater to enable logging.
If the value is 0, logging is disabled.
Future versions of <span class="pkg">duckplyr</span> may start logging additional data
and thus require a higher value to enable logging.
Set to 99 to enable logging for all future versions.
Use <code><a href="usethis.html#topic+edit">usethis::edit_r_environ()</a></code> to edit the environment file.
</p>
</li>
<li> <p><code>DUCKPLYR_FALLBACK_AUTOUPLOAD</code> controls uploading, set it
to 1 or greater to enable uploading.
If the value is 0, uploading is disabled.
Currently, uploading is active if the value is 1 or greater.
Future versions of <span class="pkg">duckplyr</span> may start logging additional data
and thus require a higher value to enable uploading.
Set to 99 to enable uploading for all future versions.
Use <code><a href="usethis.html#topic+edit">usethis::edit_r_environ()</a></code> to edit the environment file.
</p>
</li>
<li> <p><code>DUCKPLYR_FALLBACK_LOG_DIR</code> controls the location of the logs.
It must point to a directory (existing or not) where the logs will be written.
By default, logs are written to a directory in the user's cache directory
as returned by <code>tools::R_user_dir("duckplyr", "cache")</code>.
</p>
</li>
<li> <p><code>DUCKPLYR_FALLBACK_VERBOSE</code> controls printing of log data, set it
to <code>TRUE</code> or <code>FALSE</code> to enable or disable printing.
If the value is <code>TRUE</code>, a message is printed to the console
for each fallback situation.
This setting is only relevant if logging is enabled,
and mostly useful for <span class="pkg">duckplyr</span>'s internal tests.
</p>
</li></ul>

<p>All code related to fallback logging and uploading is in the
<a href="https://github.com/tidyverse/duckplyr/blob/main/R/fallback.R"><code>fallback.R</code></a> and
<a href="https://github.com/tidyverse/duckplyr/blob/main/R/telemetry.R"><code>telemetry.R</code></a> files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fallback_sitrep()
</code></pre>

<hr>
<h2 id='filter.duckplyr_df'>Keep rows that match a condition</h2><span id='topic+filter.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
The <code>filter()</code> function is used to subset a data frame,
retaining all rows that satisfy your conditions.
To be retained, the row must produce a value of <code>TRUE</code> for all conditions.
Note that when a condition evaluates to <code>NA</code> the row will be dropped,
unlike base subsetting with <code>[</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
filter(.data, ..., .by = NULL, .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="filter.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
<tr><td><code id="filter.duckplyr_df_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="filter.duckplyr_df_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>filter.duckplyr_df()</code>
</p>

<ul>
<li><p> with no filter conditions,
</p>
</li>
<li><p> nor for a grouped operation (if <code>.by</code> is set).
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- duckdb_tibble(x = 1:3, y = 3:1)
filter(df, x &gt;= 2)
</code></pre>

<hr>
<h2 id='flights_df'>Flight data</h2><span id='topic+flights_df'></span>

<h3>Description</h3>

<p>Provides a variant of <code>nycflights13::flights</code> that is compatible with duckplyr,
as a tibble:
the timezone has been set to UTC to work around a current limitation of duckplyr, see <code>vignette("limits")</code>.
Call <code><a href="#topic+as_duckdb_tibble">as_duckdb_tibble()</a></code> to enable duckplyr operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flights_df()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
flights_df()

</code></pre>

<hr>
<h2 id='full_join.duckplyr_df'>Full join</h2><span id='topic+full_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
A <code>full_join()</code> keeps all observations in <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  relationship = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full_join.duckplyr_df_+3A_x">x</code>, <code id="full_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="full_join.duckplyr_df_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>full_join.duckplyr_df()</code>
</p>

<ul>
<li><p> for an implicit cross join,
</p>
</li>
<li><p> for a value of the <code>multiple</code> argument that isn't the default <code>"all"</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
full_join(band_members, band_instruments)
</code></pre>

<hr>
<h2 id='head.duckplyr_df'>Return the First Parts of an Object</h2><span id='topic+head.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="utils.html#topic+head">head()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
Return the first rows of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
head(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="head.duckplyr_df_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="head.duckplyr_df_+3A_n">n</code></td>
<td>
<p>A positive integer, how many rows to return.</p>
</td></tr>
<tr><td><code id="head.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Not used yet.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>head.duckplyr_df()</code>
</p>

<ul>
<li><p> with a negative <code>n</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="utils.html#topic+head">head()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(mtcars, 2)
</code></pre>

<hr>
<h2 id='inner_join.duckplyr_df'>Inner join</h2><span id='topic+inner_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
An <code>inner_join()</code> only keeps observations from <code>x</code>
that have a matching key in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_join.duckplyr_df_+3A_x">x</code>, <code id="inner_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="inner_join.duckplyr_df_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>inner_join.duckplyr_df()</code>
</p>

<ul>
<li><p> for an implicit crossjoin,
</p>
</li>
<li><p> for a value of the <code>multiple</code> argument that isn't the default <code>"all"</code>.
</p>
</li>
<li><p> for a value of the <code>unmatched</code> argument that isn't the default <code>"drop"</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
inner_join(band_members, band_instruments)
</code></pre>

<hr>
<h2 id='intersect.duckplyr_df'>Intersect</h2><span id='topic+intersect.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>intersect(x, y)</code> finds all rows in both <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
intersect(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersect.duckplyr_df_+3A_x">x</code>, <code id="intersect.duckplyr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="intersect.duckplyr_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>intersect.duckplyr_df()</code>
</p>

<ul>
<li><p> if column names are duplicated in one of the tables,
</p>
</li>
<li><p> if column names are different in both tables.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+setops">dplyr::intersect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- duckdb_tibble(x = 1:3)
df2 &lt;- duckdb_tibble(x = 3:5)
intersect(df1, df2)
</code></pre>

<hr>
<h2 id='is_duckplyr_df'>Class predicate for duckplyr data frames</h2><span id='topic+is_duckplyr_df'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Tests if the input object is of class <code>"duckplyr_df"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_duckplyr_df(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>The object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the input object is of class <code>"duckplyr_df"</code>,
otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble(a = 1:3) %&gt;%
  is_duckplyr_df()

tibble(a = 1:3) %&gt;%
  as_duckplyr_df() %&gt;%
  is_duckplyr_df()
</code></pre>

<hr>
<h2 id='last_rel'>Retrieve details about the most recent computation</h2><span id='topic+last_rel'></span>

<h3>Description</h3>

<p>Before a result is computed, it is specified as a &quot;relation&quot; object.
This function retrieves this object for the last computation that led to the
materialization of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last_rel()
</code></pre>


<h3>Value</h3>

<p>A duckdb &quot;relation&quot; object, or <code>NULL</code> if no computation has been
performed yet.
</p>

<hr>
<h2 id='left_join.duckplyr_df'>Left join</h2><span id='topic+left_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
A <code>left_join()</code> keeps all observations in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="left_join.duckplyr_df_+3A_x">x</code>, <code id="left_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="left_join.duckplyr_df_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>left_join.duckplyr_df()</code>
</p>

<ul>
<li><p> for an implicit cross join,
</p>
</li>
<li><p> for a value of the <code>multiple</code> argument that isn't the default <code>"all"</code>.
</p>
</li>
<li><p> for a value of the <code>unmatched</code> argument that isn't the default <code>"drop"</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
left_join(band_members, band_instruments)
</code></pre>

<hr>
<h2 id='methods_overwrite'>Forward all dplyr methods to duckplyr</h2><span id='topic+methods_overwrite'></span><span id='topic+methods_restore'></span>

<h3>Description</h3>

<p>After calling <code>methods_overwrite()</code>, all dplyr methods are redirected to duckplyr
for the duraton of the session, or until a call to <code>methods_restore()</code>.
The <code>methods_overwrite()</code> function is called automatically when the package is loaded
if the environment variable <code>DUCKPLYR_METHODS_OVERWRITE</code> is set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methods_overwrite()

methods_restore()
</code></pre>


<h3>Value</h3>

<p>Called for their side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tibble(a = 1:3) %&gt;%
  mutate(b = a + 1)

methods_overwrite()

tibble(a = 1:3) %&gt;%
  mutate(b = a + 1)

methods_restore()

tibble(a = 1:3) %&gt;%
  mutate(b = a + 1)
</code></pre>

<hr>
<h2 id='mutate.duckplyr_df'>Create, modify, and delete columns</h2><span id='topic+mutate.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> generic.
<code>mutate()</code> creates new columns that are functions of existing variables.
It can also modify (if the name is the same as an existing column)
and delete columns (by setting their value to <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="mutate.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.duckplyr_df_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate.duckplyr_df_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate.duckplyr_df_+3A_.before">.before</code>, <code id="mutate.duckplyr_df_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
df &lt;- data.frame(x = c(1, 2))
df &lt;- mutate(df, y = 2)
df
</code></pre>

<hr>
<h2 id='new_relational'>Relational implementer's interface</h2><span id='topic+new_relational'></span><span id='topic+rel_to_df'></span><span id='topic+rel_filter'></span><span id='topic+rel_project'></span><span id='topic+rel_aggregate'></span><span id='topic+rel_order'></span><span id='topic+rel_join'></span><span id='topic+rel_limit'></span><span id='topic+rel_distinct'></span><span id='topic+rel_set_intersect'></span><span id='topic+rel_set_diff'></span><span id='topic+rel_set_symdiff'></span><span id='topic+rel_union_all'></span><span id='topic+rel_explain'></span><span id='topic+rel_alias'></span><span id='topic+rel_set_alias'></span><span id='topic+rel_names'></span>

<h3>Description</h3>

<p>The constructor and generics described here define a class
that helps separating dplyr's user interface from the actual underlying operations.
In the longer term, this will help packages that implement the dplyr interface
(such as <span class="pkg">dbplyr</span>, <span class="pkg">dtplyr</span>, <span class="pkg">arrow</span> and similar)
to focus on the core details of their functionality,
rather than on the intricacies of dplyr's user interface.
</p>
<p><code>new_relational()</code> constructs an object of class <code>"relational"</code>.
Users are encouraged to provide the <code>class</code> argument.
The typical use case will be to create a wrapper function.
</p>
<p><code>rel_to_df()</code> extracts a data frame representation from a relational object,
to be used by <code><a href="dplyr.html#topic+compute">dplyr::collect()</a></code>.
</p>
<p><code>rel_filter()</code> keeps rows that match a predicate,
to be used by <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>
<p><code>rel_project()</code> selects columns or creates new columns,
to be used by <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>,
<code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>, and others.
</p>
<p><code>rel_aggregate()</code> combines several rows into one,
to be used by <code><a href="dplyr.html#topic+summarise">dplyr::summarize()</a></code>.
</p>
<p><code>rel_order()</code> reorders rows by columns or expressions,
to be used by <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>.
</p>
<p><code>rel_join()</code> joins or merges two tables,
to be used by <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code>, <code><a href="dplyr.html#topic+cross_join">dplyr::cross_join()</a></code>,
<code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code>, and <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>.
</p>
<p><code>rel_limit()</code> limits the number of rows in a table,
to be used by <code><a href="utils.html#topic+head">utils::head()</a></code>.
</p>
<p><code>rel_distinct()</code> only keeps the distinct rows in a table,
to be used by <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>.
</p>
<p><code>rel_set_intersect()</code> returns rows present in both tables,
to be used by <code><a href="generics.html#topic+setops">generics::intersect()</a></code>.
</p>
<p><code>rel_set_diff()</code> returns rows present in any of both tables,
to be used by <code><a href="generics.html#topic+setops">generics::setdiff()</a></code>.
</p>
<p><code>rel_set_symdiff()</code> returns rows present in any of both tables,
to be used by <code><a href="dplyr.html#topic+setops">dplyr::symdiff()</a></code>.
</p>
<p><code>rel_union_all()</code> returns rows present in any of both tables,
to be used by <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code>.
</p>
<p><code>rel_explain()</code> prints an explanation of the plan
executed by the relational object.
</p>
<p><code>rel_alias()</code> returns the alias name for a relational object.
</p>
<p><code>rel_set_alias()</code> sets the alias name for a relational object.
</p>
<p><code>rel_names()</code> returns the column names as character vector,
to be used by <code><a href="base.html#topic+colnames">colnames()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_relational(..., class = NULL)

rel_to_df(rel, ...)

rel_filter(rel, exprs, ...)

rel_project(rel, exprs, ...)

rel_aggregate(rel, groups, aggregates, ...)

rel_order(rel, orders, ascending, ...)

rel_join(
  left,
  right,
  conds,
  join = c("inner", "left", "right", "outer", "cross", "semi", "anti"),
  join_ref_type = c("regular", "natural", "cross", "positional", "asof"),
  ...
)

rel_limit(rel, n, ...)

rel_distinct(rel, ...)

rel_set_intersect(rel_a, rel_b, ...)

rel_set_diff(rel_a, rel_b, ...)

rel_set_symdiff(rel_a, rel_b, ...)

rel_union_all(rel_a, rel_b, ...)

rel_explain(rel, ...)

rel_alias(rel, ...)

rel_set_alias(rel, alias, ...)

rel_names(rel, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_relational_+3A_...">...</code></td>
<td>
<p>Reserved for future extensions, must be empty.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_class">class</code></td>
<td>
<p>Classes added in front of the <code>"relational"</code> base class.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_rel">rel</code>, <code id="new_relational_+3A_rel_a">rel_a</code>, <code id="new_relational_+3A_rel_b">rel_b</code>, <code id="new_relational_+3A_left">left</code>, <code id="new_relational_+3A_right">right</code></td>
<td>
<p>A relational object.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_exprs">exprs</code></td>
<td>
<p>A list of <code>"relational_relexpr"</code> objects to filter by,
created by <code><a href="#topic+new_relexpr">new_relexpr()</a></code>.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_groups">groups</code></td>
<td>
<p>A list of expressions to group by.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_aggregates">aggregates</code></td>
<td>
<p>A list of expressions with aggregates to compute.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_orders">orders</code></td>
<td>
<p>A list of expressions to order by.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_ascending">ascending</code></td>
<td>
<p>A logical vector describing the sort order.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_conds">conds</code></td>
<td>
<p>A list of expressions to use for the join.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_join">join</code></td>
<td>
<p>The type of join.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_join_ref_type">join_ref_type</code></td>
<td>
<p>The ref type of join.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_n">n</code></td>
<td>
<p>The number of rows.</p>
</td></tr>
<tr><td><code id="new_relational_+3A_alias">alias</code></td>
<td>
<p>the new alias</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>new_relational()</code> returns a new relational object.
</p>
</li>
<li> <p><code>rel_to_df()</code> returns a data frame.
</p>
</li>
<li> <p><code>rel_names()</code> returns a character vector.
</p>
</li>
<li><p> All other generics return a modified relational object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>new_dfrel &lt;- function(x) {
  stopifnot(is.data.frame(x))
  new_relational(list(x), class = "dfrel")
}
mtcars_rel &lt;- new_dfrel(mtcars[1:5, 1:4])

rel_to_df.dfrel &lt;- function(rel, ...) {
  unclass(rel)[[1]]
}
rel_to_df(mtcars_rel)

rel_filter.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the predicates defined
  # by the exprs argument
  new_dfrel(df[seq_len(min(3, nrow(df))), ])
}

rel_filter(
  mtcars_rel,
  list(
    relexpr_function(
      "gt",
      list(relexpr_reference("cyl"), relexpr_constant("6"))
    )
  )
)

rel_project.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the expressions defined
  # by the exprs argument
  new_dfrel(df[seq_len(min(3, ncol(df)))])
}

rel_project(
  mtcars_rel,
  list(relexpr_reference("cyl"), relexpr_reference("disp"))
)

rel_order.dfrel &lt;- function(rel, exprs, ...) {
  df &lt;- unclass(rel)[[1]]

  # A real implementation would evaluate the expressions defined
  # by the exprs argument
  new_dfrel(df[order(df[[1]]), ])
}

rel_order(
  mtcars_rel,
  list(relexpr_reference("mpg"))
)

rel_join.dfrel &lt;- function(left, right, conds, join, ...) {
  left_df &lt;- unclass(left)[[1]]
  right_df &lt;- unclass(right)[[1]]

  # A real implementation would evaluate the expressions
  # defined by the conds argument,
  # use different join types based on the join argument,
  # and implement the join itself instead of relaying to left_join().
  new_dfrel(dplyr::left_join(left_df, right_df))
}

rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)


rel_limit.dfrel &lt;- function(rel, n, ...) {
  df &lt;- unclass(rel)[[1]]

  new_dfrel(df[seq_len(n), ])
}

rel_limit(mtcars_rel, 3)

rel_distinct.dfrel &lt;- function(rel, ...) {
  df &lt;- unclass(rel)[[1]]

  new_dfrel(df[!duplicated(df), ])
}

rel_distinct(new_dfrel(mtcars[1:3, 1:4]))

rel_names.dfrel &lt;- function(rel, ...) {
  df &lt;- unclass(rel)[[1]]

  names(df)
}

rel_names(mtcars_rel)
</code></pre>

<hr>
<h2 id='new_relexpr'>Relational expressions</h2><span id='topic+new_relexpr'></span><span id='topic+relexpr_reference'></span><span id='topic+relexpr_constant'></span><span id='topic+relexpr_function'></span><span id='topic+relexpr_comparison'></span><span id='topic+relexpr_window'></span><span id='topic+relexpr_set_alias'></span>

<h3>Description</h3>

<p>These functions provide a backend-agnostic way to construct expression trees
built of column references, constants, and functions.
All subexpressions in an expression tree can have an alias.
</p>
<p><code>new_relexpr()</code> constructs an object of class <code>"relational_relexpr"</code>.
It is used by the higher-level constructors,
users should rarely need to call it directly.
</p>
<p><code>relexpr_reference()</code> constructs a reference to a column.
</p>
<p><code>relexpr_constant()</code> wraps a constant value.
</p>
<p><code>relexpr_function()</code> applies a function.
The arguments to this function are a list of other expression objects.
</p>
<p><code>relexpr_comparison()</code> wraps a comparison expression.
</p>
<p><code>relexpr_window()</code> applies a function over a window,
similarly to the SQL <code>OVER</code> clause.
</p>
<p><code>relexpr_set_alias()</code> assigns an alias to an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_relexpr(x, class = NULL)

relexpr_reference(name, rel = NULL, alias = NULL)

relexpr_constant(val, alias = NULL)

relexpr_function(name, args, alias = NULL)

relexpr_comparison(cmp_op, exprs)

relexpr_window(
  expr,
  partitions,
  order_bys = list(),
  offset_expr = NULL,
  default_expr = NULL,
  alias = NULL
)

relexpr_set_alias(expr, alias = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_relexpr_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_class">class</code></td>
<td>
<p>Classes added in front of the <code>"relational_relexpr"</code> base class.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_name">name</code></td>
<td>
<p>The name of the column or function to reference.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_rel">rel</code></td>
<td>
<p>The name of the relation to reference.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_alias">alias</code></td>
<td>
<p>An alias for the new expression.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_val">val</code></td>
<td>
<p>The value to use in the constant expression.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_args">args</code></td>
<td>
<p>Function arguments, a list of <code>expr</code> objects.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_cmp_op">cmp_op</code></td>
<td>
<p>Comparison operator, e.g., <code>"&lt;"</code> or <code>"=="</code>.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_exprs">exprs</code></td>
<td>
<p>Expressions to compare, a list of <code>expr</code> objects.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_expr">expr</code></td>
<td>
<p>An <code>expr</code> object.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_partitions">partitions</code></td>
<td>
<p>Partitions, a list of <code>expr</code> objects.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_order_bys">order_bys</code></td>
<td>
<p>which variables to order results by (list).</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_offset_expr">offset_expr</code></td>
<td>
<p>offset relational expression.</p>
</td></tr>
<tr><td><code id="new_relexpr_+3A_default_expr">default_expr</code></td>
<td>
<p>default relational expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"relational_relexpr"</code>
</p>
<p>an object of class <code>"relational_relexpr"</code>
</p>
<p>an object of class <code>"relational_relexpr"</code>
</p>
<p>an object of class <code>"relational_relexpr"</code>
</p>
<p>an object of class <code>"relational_relexpr"</code>
</p>
<p>an object of class <code>"relational_relexpr"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>relexpr_set_alias(
  alias = "my_predicate",
  relexpr_function(
    "&lt;",
    list(
      relexpr_reference("my_number"),
      relexpr_constant(42)
    )
  )
)
</code></pre>

<hr>
<h2 id='pull.duckplyr_df'>Extract a single column</h2><span id='topic+pull.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>pull()</code> is similar to <code>$</code>.
It's mostly useful because it looks a little nicer in pipes,
it also works with remote data frames, and it can optionally name the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pull.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="pull.duckplyr_df_+3A_var">var</code></td>
<td>
<p>A variable specified as:
</p>

<ul>
<li><p> a literal variable name
</p>
</li>
<li><p> a positive integer, giving the position counting from the left
</p>
</li>
<li><p> a negative integer, giving the position counting from the right.
</p>
</li></ul>

<p>The default returns the last column (on the assumption that's the
column you've created most recently).
</p>
<p>This argument is taken by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names and column locations).</p>
</td></tr>
<tr><td><code id="pull.duckplyr_df_+3A_name">name</code></td>
<td>
<p>An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as <code>var</code>.</p>
</td></tr>
<tr><td><code id="pull.duckplyr_df_+3A_...">...</code></td>
<td>
<p>For use by methods.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>pull.duckplyr_df()</code>
</p>

<ul>
<li><p> with a selection that returns no columns.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">dplyr::pull()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
pull(mtcars, cyl)
pull(mtcars, 1)
</code></pre>

<hr>
<h2 id='read_csv_duckdb'>Read CSV files using DuckDB</h2><span id='topic+read_csv_duckdb'></span>

<h3>Description</h3>

<p><code>read_csv_duckdb()</code> reads a CSV file using DuckDB's <code>read_csv_auto()</code> table function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csv_duckdb(
  path,
  ...,
  prudence = c("thrifty", "lavish", "stingy"),
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_csv_duckdb_+3A_path">path</code></td>
<td>
<p>Path to files, glob patterns <code>*</code> and <code style="white-space: pre;">&#8288;?&#8288;</code> are supported.</p>
</td></tr>
<tr><td><code id="read_csv_duckdb_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="read_csv_duckdb_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells,
</p>
</li>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never.
</p>
</li></ul>

<p>The default is <code>"thrifty"</code> for the ingestion functions,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="read_csv_duckdb_+3A_options">options</code></td>
<td>
<p>Arguments to the DuckDB <code>read_csv_auto</code> table function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_parquet_duckdb">read_parquet_duckdb()</a></code>, <code><a href="#topic+read_json_duckdb">read_json_duckdb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create simple CSV file
path &lt;- tempfile("duckplyr_test_", fileext = ".csv")
write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)

# Reading is immediate
df &lt;- read_csv_duckdb(path)

# Names are always available
names(df)

# Materialization upon access is turned off by default
try(print(df$a))

# Materialize explicitly
collect(df)$a

# Automatic materialization with prudence = "lavish"
df &lt;- read_csv_duckdb(path, prudence = "lavish")
df$a

# Specify column types
read_csv_duckdb(
  path,
  options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR")))
)
</code></pre>

<hr>
<h2 id='read_file_duckdb'>Read files using DuckDB</h2><span id='topic+read_file_duckdb'></span>

<h3>Description</h3>

<p><code>read_file_duckdb()</code> uses arbitrary readers to read data.
See <a href="https://duckdb.org/docs/data/overview">https://duckdb.org/docs/data/overview</a> for a documentation
of the available functions and their options.
To read multiple files with the same schema,
pass a wildcard or a character vector to the <code>path</code> argument,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_file_duckdb(
  path,
  table_function,
  ...,
  prudence = c("thrifty", "lavish", "stingy"),
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_file_duckdb_+3A_path">path</code></td>
<td>
<p>Path to files, glob patterns <code>*</code> and <code style="white-space: pre;">&#8288;?&#8288;</code> are supported.</p>
</td></tr>
<tr><td><code id="read_file_duckdb_+3A_table_function">table_function</code></td>
<td>
<p>The name of a table-valued
DuckDB function such as <code>"read_parquet"</code>,
<code>"read_csv"</code>, <code>"read_csv_auto"</code> or <code>"read_json"</code>.</p>
</td></tr>
<tr><td><code id="read_file_duckdb_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="read_file_duckdb_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells,
</p>
</li>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never.
</p>
</li></ul>

<p>The default is <code>"thrifty"</code> for the ingestion functions,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="read_file_duckdb_+3A_options">options</code></td>
<td>
<p>Arguments to the DuckDB function
indicated by <code>table_function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A duckplyr frame, see <code><a href="#topic+as_duckdb_tibble">as_duckdb_tibble()</a></code> for details.
</p>


<h3>Fine-tuning prudence</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The <code>prudence</code> argument can also be a named numeric vector
with at least one of <code>cells</code> or <code>rows</code>
to limit the cells (values) and rows in the resulting data frame
after automatic materialization.
If both limits are specified, both are enforced.
The equivalent of <code>"thrifty"</code> is <code>c(cells = 1e6)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_csv_duckdb">read_csv_duckdb()</a></code>, <code><a href="#topic+read_parquet_duckdb">read_parquet_duckdb()</a></code>, <code><a href="#topic+read_json_duckdb">read_json_duckdb()</a></code>
</p>

<hr>
<h2 id='read_json_duckdb'>Read JSON files using DuckDB</h2><span id='topic+read_json_duckdb'></span>

<h3>Description</h3>

<p><code>read_json_duckdb()</code> reads a JSON file using DuckDB's <code>read_json()</code> table function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json_duckdb(
  path,
  ...,
  prudence = c("thrifty", "lavish", "stingy"),
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_json_duckdb_+3A_path">path</code></td>
<td>
<p>Path to files, glob patterns <code>*</code> and <code style="white-space: pre;">&#8288;?&#8288;</code> are supported.</p>
</td></tr>
<tr><td><code id="read_json_duckdb_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="read_json_duckdb_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells,
</p>
</li>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never.
</p>
</li></ul>

<p>The default is <code>"thrifty"</code> for the ingestion functions,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="read_json_duckdb_+3A_options">options</code></td>
<td>
<p>Arguments to the DuckDB <code>read_json</code> table function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_csv_duckdb">read_csv_duckdb()</a></code>, <code><a href="#topic+read_parquet_duckdb">read_parquet_duckdb()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Create and read a simple JSON file
path &lt;- tempfile("duckplyr_test_", fileext = ".json")
writeLines('[{"a": 1, "b": "x"}, {"a": 2, "b": "y"}]', path)

# Reading needs the json extension
db_exec("INSTALL json")
db_exec("LOAD json")
read_json_duckdb(path)

</code></pre>

<hr>
<h2 id='read_parquet_duckdb'>Read Parquet files using DuckDB</h2><span id='topic+read_parquet_duckdb'></span>

<h3>Description</h3>

<p><code>read_parquet_duckdb()</code> reads a Parquet file using DuckDB's <code>read_parquet()</code> table function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_parquet_duckdb(
  path,
  ...,
  prudence = c("thrifty", "lavish", "stingy"),
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_parquet_duckdb_+3A_path">path</code></td>
<td>
<p>Path to files, glob patterns <code>*</code> and <code style="white-space: pre;">&#8288;?&#8288;</code> are supported.</p>
</td></tr>
<tr><td><code id="read_parquet_duckdb_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="read_parquet_duckdb_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells,
</p>
</li>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never.
</p>
</li></ul>

<p>The default is <code>"thrifty"</code> for the ingestion functions,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="read_parquet_duckdb_+3A_options">options</code></td>
<td>
<p>Arguments to the DuckDB <code>read_parquet</code> table function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+read_csv_duckdb">read_csv_duckdb()</a></code>, <code><a href="#topic+read_json_duckdb">read_json_duckdb()</a></code>
</p>

<hr>
<h2 id='read_sql_duckdb'>Return SQL query as duckdb_tibble</h2><span id='topic+read_sql_duckdb'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Runs a query and returns it as a duckplyr frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sql_duckdb(
  sql,
  ...,
  prudence = c("thrifty", "lavish", "stingy"),
  con = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_sql_duckdb_+3A_sql">sql</code></td>
<td>
<p>The SQL to run.</p>
</td></tr>
<tr><td><code id="read_sql_duckdb_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="read_sql_duckdb_+3A_prudence">prudence</code></td>
<td>
<p>Memory protection, controls if DuckDB may convert
intermediate results in DuckDB-managed memory to data frames in R memory.
</p>

<ul>
<li> <p><code>"thrifty"</code>: up to a maximum size of 1 million cells,
</p>
</li>
<li> <p><code>"lavish"</code>: regardless of size,
</p>
</li>
<li> <p><code>"stingy"</code>: never.
</p>
</li></ul>

<p>The default is <code>"thrifty"</code> for the ingestion functions,
and may be different for other functions.
See <code>vignette("prudence")</code> for more information.</p>
</td></tr>
<tr><td><code id="read_sql_duckdb_+3A_con">con</code></td>
<td>
<p>The connection, defaults to the default connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using data frames from the calling environment is not supported yet,
see <a href="https://github.com/duckdb/duckdb-r/issues/645">https://github.com/duckdb/duckdb-r/issues/645</a> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+db_exec">db_exec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_sql_duckdb("FROM duckdb_settings()")
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relocate.duckplyr_df'>Change column order</h2><span id='topic+relocate.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
Use <code>relocate()</code> to change column positions,
using the same syntax as <code>select()</code> to make it easy to move blocks of columns at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
relocate(.data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relocate.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="relocate.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to move.</p>
</td></tr>
<tr><td><code id="relocate.duckplyr_df_+3A_.before">.before</code>, <code id="relocate.duckplyr_df_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Destination of
columns selected by <code>...</code>. Supplying neither will move columns to the
left-hand side; specifying both is an error.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>relocate.duckplyr_df()</code>
</p>

<ul>
<li><p> with a selection that returns no columns.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- duckdb_tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
relocate(df, f)
</code></pre>

<hr>
<h2 id='rename.duckplyr_df'>Rename columns</h2><span id='topic+rename.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>rename()</code> changes the names of individual variables
using <code>new_name = old_name</code> syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
rename(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rename.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="rename.duckplyr_df_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Use
<code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>rename.duckplyr_df()</code>
</p>

<ul>
<li><p> with a selection that returns no columns.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
rename(mtcars, thing = mpg)
</code></pre>

<hr>
<h2 id='right_join.duckplyr_df'>Right join</h2><span id='topic+right_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
A <code>right_join()</code> keeps all observations in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
right_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = c("na", "never"),
  multiple = "all",
  unmatched = "drop",
  relationship = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="right_join.duckplyr_df_+3A_x">x</code>, <code id="right_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?
</p>

<ul>
<li><p> If <code>NULL</code>, the default, joins on equality retain only the keys from <code>x</code>,
while joins on inequality retain the keys from both inputs.
</p>
</li>
<li><p> If <code>TRUE</code>, all keys from both inputs are retained.
</p>
</li>
<li><p> If <code>FALSE</code>, only keys from <code>x</code> are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in <code>y</code> are
merged into the key columns from <code>x</code>. Can't be used when joining on
inequality conditions.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_multiple">multiple</code></td>
<td>
<p>Handling of rows in <code>x</code> with multiple matches in <code>y</code>.
For each row of <code>x</code>:
</p>

<ul>
<li> <p><code>"all"</code>, the default, returns every match detected in <code>y</code>. This is the
same behavior as SQL.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code>
if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_unmatched">unmatched</code></td>
<td>
<p>How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

<p><code>unmatched</code> is intended to protect you from accidentally dropping rows
during a join. It only checks for unmatched keys in the input that could
potentially drop rows.
</p>

<ul>
<li><p> For left joins, it checks <code>y</code>.
</p>
</li>
<li><p> For right joins, it checks <code>x</code>.
</p>
</li>
<li><p> For inner joins, it checks both <code>x</code> and <code>y</code>. In this case, <code>unmatched</code> is
also allowed to be a character vector of length 2 to specify the behavior
for <code>x</code> and <code>y</code> independently.
</p>
</li></ul>
</td></tr>
<tr><td><code id="right_join.duckplyr_df_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between the keys of
<code>x</code> and <code>y</code>. If the expectations chosen from the list below are
invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>NULL</code>, the default, doesn't expect there to be any relationship between
<code>x</code> and <code>y</code>. However, for equality joins it will check for a many-to-many
relationship (which is typically unexpected) and will warn if one occurs,
encouraging you to either take a closer look at your inputs or make this
relationship explicit by specifying <code>"many-to-many"</code>.
</p>
<p>See the <em>Many-to-many relationships</em> section for more details.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each row in <code>y</code> matches at most 1 row in <code>x</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each row in <code>x</code> matches at most 1 row in <code>y</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> doesn't perform any relationship checks, but is provided
to allow you to be explicit about this relationship if you know it
exists.
</p>
</li></ul>

<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>unmatched</code>.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>right_join.duckplyr_df()</code>
</p>

<ul>
<li><p> for an implicit cross join,
</p>
</li>
<li><p> for a value of the <code>multiple</code> argument that isn't the default <code>"all"</code>.
</p>
</li>
<li><p> for a value of the <code>unmatched</code> argument that isn't the default <code>"drop"</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
right_join(band_members, band_instruments)
</code></pre>

<hr>
<h2 id='select.duckplyr_df'>Keep or drop columns using their names and types</h2><span id='topic+select.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
Select (and optionally rename) variables in a data frame,
using a concise mini-language that makes it easy to refer to variables
based on their name (e.g. <code>a:f</code> selects all columns from a on the left
to f on the right) or type
(e.g. <code>where(is.numeric)</code> selects all numeric columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="select.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like <code>x:y</code> can
be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>select.duckplyr_df()</code>
</p>

<ul>
<li><p> with no expression,
</p>
</li>
<li><p> nor with a selection that returns no columns.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+select">dplyr::select()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
select(mtcars, mpg)
</code></pre>

<hr>
<h2 id='semi_join.duckplyr_df'>Semi join</h2><span id='topic+semi_join.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> generic.
<code>semi_join()</code> returns all rows from x with a match in y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
semi_join(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semi_join.duckplyr_df_+3A_x">x</code>, <code id="semi_join.duckplyr_df_+3A_y">y</code></td>
<td>
<p>A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="semi_join.duckplyr_df_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="semi_join.duckplyr_df_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="semi_join.duckplyr_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="semi_join.duckplyr_df_+3A_na_matches">na_matches</code></td>
<td>
<p>Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, and <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values. This is similar to joins
for database sources and to <code>base::merge(incomparables = NA)</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
band_members %&gt;% semi_join(band_instruments)
</code></pre>

<hr>
<h2 id='setdiff.duckplyr_df'>Set difference</h2><span id='topic+setdiff.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>setdiff(x, y)</code> finds all rows in <code>x</code> that aren't in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
setdiff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setdiff.duckplyr_df_+3A_x">x</code>, <code id="setdiff.duckplyr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="setdiff.duckplyr_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>setdiff.duckplyr_df()</code>
</p>

<ul>
<li><p> if column names are duplicated in one of the tables,
</p>
</li>
<li><p> if column names are different in both tables.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- duckdb_tibble(x = 1:3)
df2 &lt;- duckdb_tibble(x = 3:5)
setdiff(df1, df2)
setdiff(df2, df1)
</code></pre>

<hr>
<h2 id='stats_show'>Show stats</h2><span id='topic+stats_show'></span>

<h3>Description</h3>

<p>Prints statistics on how many calls were handled by DuckDB.
The output shows the total number of requests in the current session,
split by fallbacks to dplyr and requests handled by duckdb.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats_show()
</code></pre>


<h3>Value</h3>

<p>Called for its side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stats_show()

tibble(a = 1:3) %&gt;%
  as_duckplyr_tibble() %&gt;%
  mutate(b = a + 1)

stats_show()
</code></pre>

<hr>
<h2 id='summarise.duckplyr_df'>Summarise each group down to one row</h2><span id='topic+summarise.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>summarise()</code> creates a new data frame.
It returns one row for each combination of grouping variables;
if there are no grouping variables,
the output will have a single row summarising all observations in the input.
It will contain one column for each grouping variable
and one column for each of the summary statistics that you have specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
summarise(.data, ..., .by = NULL, .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="summarise.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs of
summary functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Returning values with size 0 or &gt;1 was
deprecated as of 1.1.0. Please use <code><a href="dplyr.html#topic+reframe">reframe()</a></code> for this instead.</p>
</td></tr>
<tr><td><code id="summarise.duckplyr_df_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="summarise.duckplyr_df_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>summarise.duckplyr_df()</code>
</p>

<ul>
<li><p> with <code>.groups = "rowwise"</code>.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
summarise(mtcars, mean = mean(disp), n = n())
</code></pre>

<hr>
<h2 id='symdiff.duckplyr_df'>Symmetric difference</h2><span id='topic+symdiff.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+setops">dplyr::symdiff()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>symdiff(x, y)</code>  computes the symmetric difference,
i.e. all rows in <code>x</code> that aren't in <code>y</code> and all rows in <code>y</code> that aren't in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
symdiff(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symdiff.duckplyr_df_+3A_x">x</code>, <code id="symdiff.duckplyr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="symdiff.duckplyr_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>symdiff.duckplyr_df()</code>
</p>

<ul>
<li><p> if column names are duplicated in one of the tables,
</p>
</li>
<li><p> if column names are different in both tables.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+setops">dplyr::symdiff()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+setops">dplyr::symdiff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- duckdb_tibble(x = 1:3)
df2 &lt;- duckdb_tibble(x = 3:5)
symdiff(df1, df2)
</code></pre>

<hr>
<h2 id='transmute.duckplyr_df'>Create, modify, and delete columns</h2><span id='topic+transmute.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>transmute()</code> creates a new data frame containing only the specified computations.
It's superseded because you can perform the same job with <code>mutate(.keep = "none")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transmute.duckplyr_df_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="transmute.duckplyr_df_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>transmute.duckplyr_df()</code>
</p>

<ul>
<li><p> with a selection that returns no columns:
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(duckplyr)
transmute(mtcars, mpg2 = mpg*2)
</code></pre>

<hr>
<h2 id='union_all.duckplyr_df'>Union of all</h2><span id='topic+union_all.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code> generic.
See &quot;Fallbacks&quot; section for differences in implementation.
<code>union_all(x, y)</code> finds all rows in either x or y, including duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
union_all(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union_all.duckplyr_df_+3A_x">x</code>, <code id="union_all.duckplyr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="union_all.duckplyr_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Fallbacks</h3>

<p>There is no DuckDB translation in <code>union_all.duckplyr_df()</code>
</p>

<ul>
<li><p> if column names are duplicated in one of the tables,
</p>
</li>
<li><p> if column names are different in both tables.
</p>
</li></ul>

<p>These features fall back to <code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code>, see <code>vignette("fallback")</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+setops">dplyr::union_all()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- duckdb_tibble(x = 1:3)
df2 &lt;- duckdb_tibble(x = 3:5)
union_all(df1, df2)
</code></pre>

<hr>
<h2 id='union.duckplyr_df'>Union</h2><span id='topic+union.duckplyr_df'></span>

<h3>Description</h3>

<p>This is a method for the <code><a href="dplyr.html#topic+setops">dplyr::union()</a></code> generic.
<code>union(x, y)</code> finds all rows in either x or y, excluding duplicates.
The implementation forwards to <code>distinct(union_all(x, y))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duckplyr_df'
union(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union.duckplyr_df_+3A_x">x</code>, <code id="union.duckplyr_df_+3A_y">y</code></td>
<td>
<p>Pair of compatible data frames. A pair of data frames is
compatible if they have the same column names (possibly in different
orders) and compatible types.</p>
</td></tr>
<tr><td><code id="union.duckplyr_df_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+setops">dplyr::union()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- duckdb_tibble(x = 1:3)
df2 &lt;- duckdb_tibble(x = 3:5)
union(df1, df2)
</code></pre>

<hr>
<h2 id='unsupported'>Verbs not implemented in duckplyr</h2><span id='topic+unsupported'></span>

<h3>Description</h3>

<p>The following dplyr generics have no counterpart method in duckplyr.
If you want to help add a new verb,
please refer to our contributing guide <a href="https://duckplyr.tidyverse.org/CONTRIBUTING.html#support-new-verbs">https://duckplyr.tidyverse.org/CONTRIBUTING.html#support-new-verbs</a>
</p>


<h3>Unsupported verbs</h3>

<p>For these verbs, duckplyr will fall back to dplyr.
</p>

<ul>
<li> <p><code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+cross_join">dplyr::cross_join()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+do">dplyr::do()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_data">dplyr::group_indices()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_data">dplyr::group_keys()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_map">dplyr::group_map()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_map">dplyr::group_modify()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_nest">dplyr::group_nest()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_data">dplyr::group_size()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_split">dplyr::group_split()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_trim">dplyr::group_trim()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_data">dplyr::groups()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_data">dplyr::n_groups()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+nest_by">dplyr::nest_by()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+reframe">dplyr::reframe()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_append()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_delete()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_insert()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_patch()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_update()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rows">dplyr::rows_upsert()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>
</p>
</li>
<li> <p><code><a href="generics.html#topic+setops">generics::setequal()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice">dplyr::slice_head()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice">dplyr::slice_sample()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice">dplyr::slice_tail()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
