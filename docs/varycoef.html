<!DOCTYPE html><html><head><title>Help for package varycoef</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {varycoef}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_cov_lower'><p>Check Lower Bound of Covariance Parameters</p></a></li>
<li><a href='#coef.SVC_mle'><p>Extact Mean Effects</p></a></li>
<li><a href='#cov_par'><p>Extact Covariance Parameters</p></a></li>
<li><a href='#fitted.SVC_mle'><p>Extact Model Fitted Values</p></a></li>
<li><a href='#GLS_chol'><p>GLS Estimate using Cholesky Factor</p></a></li>
<li><a href='#house'><p>Lucas County House Price Data</p></a></li>
<li><a href='#IC.SVC_mle'><p>Conditional Akaike's and Bayesian Information Criteria</p></a></li>
<li><a href='#init_bounds_optim'><p>Setting of Optimization Bounds and Initial Values</p></a></li>
<li><a href='#logLik.SVC_mle'><p>Extact the Likelihood</p></a></li>
<li><a href='#nlocs'><p>Extract Number of Unique Locations</p></a></li>
<li><a href='#nobs.SVC_mle'><p>Extract Number of Observations</p></a></li>
<li><a href='#plot.SVC_mle'><p>Plotting Residuals of <code>SVC_mle</code> model</p></a></li>
<li><a href='#predict.SVC_mle'><p>Prediction of SVCs (and response variable)</p></a></li>
<li><a href='#print.summary.SVC_mle'><p>Printing Method for <code>summary.SVC_mle</code></p></a></li>
<li><a href='#print.SVC_mle'><p>Print Method for <code>SVC_mle</code></p></a></li>
<li><a href='#residuals.SVC_mle'><p>Extact Model Residuals</p></a></li>
<li><a href='#sample_SVCdata'><p>Sample Function for GP-based SVC Model for Given Locations</p></a></li>
<li><a href='#summary.SVC_mle'><p>Summary Method for <code>SVC_mle</code></p></a></li>
<li><a href='#SVC_mle'><p>MLE of SVC model</p></a></li>
<li><a href='#SVC_mle_control'><p>Set Parameters for <code>SVC_mle</code></p></a></li>
<li><a href='#SVC_selection'><p>SVC Model Selection</p></a></li>
<li><a href='#SVC_selection_control'><p>SVC Selection Parameters</p></a></li>
<li><a href='#SVCdata'><p>Sampled SVC Data</p></a></li>
<li><a href='#varycoef'><p>varycoef: Modeling Spatially Varying Coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Spatially Varying Coefficients</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a maximum likelihood estimation (MLE) method for
    estimation and prediction of Gaussian process-based spatially varying
    coefficient (SVC) models (Dambon et al. (2021a)
    &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2020.100470">doi:10.1016/j.spasta.2020.100470</a>&gt;).  Covariance tapering (Furrer et
    al. (2006) &lt;<a href="https://doi.org/10.1198%2F106186006X132178">doi:10.1198/106186006X132178</a>&gt;) can be applied such that
    the method scales to large data. Further, it implements a joint
    variable selection of the fixed and random effects (Dambon et al.
    (2021b) &lt;<a href="https://doi.org/10.1080%2F13658816.2022.2097684">doi:10.1080/13658816.2022.2097684</a>&gt;). The package and its 
    capabilities are described in (Dambon et al. (2021c) &lt;<a href="https://doi.org/10.48550/arXiv.2106.02364">doi:10.48550/arXiv.2106.02364</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jakobdambon/varycoef">https://github.com/jakobdambon/varycoef</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jakobdambon/varycoef/issues">https://github.com/jakobdambon/varycoef/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, lhs, methods, mlr, mlrMBO, optimParallel (&ge; 0.8-1),
ParamHelpers, pbapply, smoof, spam</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiceKriging, knitr, lattice, latticeExtra, parallel,
rmarkdown, sp, spData, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-17 14:11:21 UTC; jakob</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakob A. Dambon <a href="https://orcid.org/0000-0001-5855-2017"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Fabio Sigrist <a href="https://orcid.org/0000-0002-3994-2244"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Reinhard Furrer <a href="https://orcid.org/0000-0002-6319-2332"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakob A. Dambon &lt;jakob.dambon@math.uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-17 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_cov_lower'>Check Lower Bound of Covariance Parameters</h2><span id='topic+check_cov_lower'></span>

<h3>Description</h3>

<p>Ensures that the covariance parameters define a positive definite covariance
matrix. It takes the vector
<code class="reqn">(\rho_1, \sigma^2_1, ..., \rho_q, \sigma^2_q, \tau^2)</code> and checks if
all <code class="reqn">\rho_k&gt;0</code>, all <code class="reqn">\sigma_k^2&gt;=0</code>, and <code class="reqn">\tau^2&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cov_lower(cv, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cov_lower_+3A_cv">cv</code></td>
<td>
<p>(<code>numeric(2*q+1)</code>) <br /> Covariance vector of SVC model.</p>
</td></tr>
<tr><td><code id="check_cov_lower_+3A_q">q</code></td>
<td>
<p>(<code>numeric(1)</code>) <br /> Integer indicating the number of SVCs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code> with <code>TRUE</code> if all conditions above are
fulfilled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first one is true, all other are false
check_cov_lower(c(0.1, 0, 0.2,  1, 0.2), q = 2)
check_cov_lower(c(0  , 0, 0.2,  1, 0.2), q = 2)
check_cov_lower(c(0.1, 0, 0.2,  1, 0  ), q = 2)
check_cov_lower(c(0.1, 0, 0.2, -1, 0  ), q = 2)
</code></pre>

<hr>
<h2 id='coef.SVC_mle'>Extact Mean Effects</h2><span id='topic+coef.SVC_mle'></span><span id='topic+coef.SVC_selection'></span>

<h3>Description</h3>

<p>Method to extract the mean effects from an <code><a href="#topic+SVC_mle">SVC_mle</a></code>
or <code><a href="#topic+SVC_selection">SVC_selection</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
coef(object, ...)

## S3 method for class 'SVC_selection'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> or <code><a href="#topic+SVC_selection">SVC_selection</a></code> object</p>
</td></tr>
<tr><td><code id="coef.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector with mean effects, i.e. <code class="reqn">\mu</code> from
<code><a href="#topic+SVC_mle">SVC_mle</a></code>
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='cov_par'>Extact Covariance Parameters</h2><span id='topic+cov_par'></span><span id='topic+cov_par.SVC_mle'></span><span id='topic+cov_par.SVC_selection'></span>

<h3>Description</h3>

<p>Function to extract the covariance parameters from an 
<code><a href="#topic+SVC_mle">SVC_mle</a></code> or <code><a href="#topic+SVC_selection">SVC_selection</a></code>object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_par(...)

## S3 method for class 'SVC_mle'
cov_par(object, ...)

## S3 method for class 'SVC_selection'
cov_par(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_par_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="cov_par_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> or <code><a href="#topic+SVC_selection">SVC_selection</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with covariance parameters with the following attributes:
</p>

<ul>
<li> <p><code>"GRF"</code>, charachter, describing the covariance function used for
the GP, see <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code>.
</p>
</li>
<li> <p><code>"tapering"</code>, either <code>NULL</code> if no tapering is applied of
the taper range.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='fitted.SVC_mle'>Extact Model Fitted Values</h2><span id='topic+fitted.SVC_mle'></span>

<h3>Description</h3>

<p>Method to extract the fitted values from an <code><a href="#topic+SVC_mle">SVC_mle</a></code> object. This is only possible if <code>save.fitted</code> was set to <code>TRUE</code> in the control of the function call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="fitted.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame, fitted values to given data, i.e., the SVC as well as the response and their locations
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='GLS_chol'>GLS Estimate using Cholesky Factor</h2><span id='topic+GLS_chol'></span><span id='topic+GLS_chol.spam.chol.NgPeyton'></span><span id='topic+GLS_chol.matrix'></span>

<h3>Description</h3>

<p>Computes the GLS estimate using the formula:
</p>
<p style="text-align: center;"><code class="reqn">\mu_{GLS} = (X^\top \Sigma^{-1} X)^{-1}X^\top \Sigma^{-1} y.</code>
</p>

<p>The computation is done depending on the input class of the Cholesky factor
<code>R</code>. It relies on the classical <code><a href="base.html#topic+solve">solve</a></code> or on
using <code>forwardsolve</code> and <code>backsolve</code> functions of package
<code>spam</code>, see <code><a href="spam.html#topic+solve">solve</a></code>. This is much faster than
computing the inverse of <code class="reqn">\Sigma</code>, especially since we have to compute
the Cholesky decomposition of <code class="reqn">\Sigma</code> either way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLS_chol(R, X, y)

## S3 method for class 'spam.chol.NgPeyton'
GLS_chol(R, X, y)

## S3 method for class 'matrix'
GLS_chol(R, X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLS_chol_+3A_r">R</code></td>
<td>
<p>(<code>spam.chol.NgPeyton</code> or <code>matrix(n, n)</code>) <br /> Cholesky factor of
the covariance matrix <code class="reqn">\Sigma</code>. If covariance tapering and sparse
matrices are used, then the input is of class <code>spam.chol.NgPeyton</code>.
Otherwise, <code>R</code> is the output of a standard <code><a href="base.html#topic+chol">chol</a></code>,
i.e., a simple <code>matrix</code></p>
</td></tr>
<tr><td><code id="GLS_chol_+3A_x">X</code></td>
<td>
<p>(<code>matrix(n, p)</code>) <br /> Data / design matrix.</p>
</td></tr>
<tr><td><code id="GLS_chol_+3A_y">y</code></td>
<td>
<p>(<code>numeric(n)</code>) <br /> Response vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric(p)</code> vector, i.e., the mean effects.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data
n &lt;- 10
X &lt;- cbind(1, 20+1:n)
y &lt;- rnorm(n)
A &lt;- matrix(runif(n^2)*2-1, ncol=n)
Sigma &lt;- t(A) %*% A
# two possibilities
## using standard Cholesky decomposition
R_mat &lt;- chol(Sigma); str(R_mat)
mu_mat &lt;- GLS_chol(R_mat, X, y)
## using spam
R_spam &lt;- chol(spam::as.spam(Sigma)); str(R_spam)
mu_spam &lt;- GLS_chol(R_spam, X, y)
# should be identical to the following
mu &lt;- solve(crossprod(X, solve(Sigma, X))) %*%
      crossprod(X, solve(Sigma, y))
## check
abs(mu - mu_mat)
abs(mu - mu_spam)
</code></pre>

<hr>
<h2 id='house'>Lucas County House Price Data</h2><span id='topic+house'></span>

<h3>Description</h3>

<p>A dataset containing the prices and other attributes of 25,357 houses in
Lucas County, Ohio. The selling dates span years 1993 to 1998. Data taken
from <code><a href="spData.html#topic+house">house</a></code> (<code>spData</code> package) and slightly modified to a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>house
</code></pre>


<h3>Format</h3>

<p>A data frame with 25357 rows and 25 variables:
</p>

<dl>
<dt>price</dt><dd><p>(<code>integer</code>) selling price, in US dollars</p>
</dd>
<dt>yrbuilt</dt><dd><p>(<code>integer</code>) year the house was built</p>
</dd>
<dt>stories</dt><dd><p>(<code>factor</code>) levels are <code>"one", "bilevel",
  "multilvl",  "one+half", "two", "two+half", "three"</code></p>
</dd>
<dt>TLA</dt><dd><p>(<code>integer</code>) total living area, in square feet.</p>
</dd>
<dt>wall</dt><dd><p>(<code>factor</code>) levels are <code>"stucdrvt", "ccbtile",
  "metlvnyl", "brick", "stone", "wood", "partbrk"</code></p>
</dd>
<dt>beds, baths, halfbaths</dt><dd><p>(<code>integer</code>) number of corresponding
rooms / facilities.</p>
</dd>
<dt>frontage, depth</dt><dd><p>dimensions of the lot. Unit is feet.</p>
</dd>
<dt>garage</dt><dd><p>(<code>factor</code>) levels are <code>"no garage", "basement",
  "attached", "detached", "carport"</code></p>
</dd>
<dt>garagesqft</dt><dd><p>(<code>integer</code>) garage area, in square feet. If
<code>garage == "no garage"</code>, then <code>garagesqft == 0</code>.</p>
</dd>
<dt>rooms</dt><dd><p>(<code>integer</code>) number of rooms</p>
</dd>
<dt>lotsize</dt><dd><p>(<code>integer</code>) area of lot, in square feet</p>
</dd>
<dt>sdate</dt><dd><p>(<code>Date</code>) selling date, in format <code>yyyy-mm-dd</code></p>
</dd>
<dt>avalue</dt><dd><p>(<code>int</code>) appraised value</p>
</dd>
<dt>s1993, s1994, s1995, s1996, s1997, s1998</dt><dd><p>(<code>int</code>) dummies for
selling year.</p>
</dd>
<dt>syear</dt><dd><p>(<code>factor</code>) levels are selling years <code>"1993", "1994",
  "1995", "1996", "1997", "1998"</code></p>
</dd>
<dt>long, lat</dt><dd><p>(<code>numeric</code>) location of houses. Longitude and
Latitude are given in <code>CRS(+init=epsg:2834)</code>, the Ohio North State
Plane. Units are meters.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.spatial-econometrics.com/html/jplv6.zip">http://www.spatial-econometrics.com/html/jplv6.zip</a>
</p>

<hr>
<h2 id='IC.SVC_mle'>Conditional Akaike's and Bayesian Information Criteria</h2><span id='topic+IC.SVC_mle'></span><span id='topic+BIC.SVC_mle'></span><span id='topic+AIC.SVC_mle'></span>

<h3>Description</h3>

<p>Methods to calculate information criteria for
<code><a href="#topic+SVC_mle">SVC_mle</a></code> objects. Currently, two are supported: the conditional
Akaike's Information Criteria <code class="reqn">cAIC = -2*log-likelihood + 2*(edof + df)</code>
and the Bayesian Information Criteria <code class="reqn">BIC = -2*log-likelihood + log(n) * npar</code>.
Note that the Akaike's Information Criteria is of the corrected form, that
is: <code class="reqn">edof</code> is the effective degrees of freedom which is derived as the
trace of the hat matrices and df is the degree of freedoms with respect to
mean parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
BIC(object, ...)

## S3 method for class 'SVC_mle'
AIC(object, conditional = "BW", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="IC.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="IC.SVC_mle_+3A_conditional">conditional</code></td>
<td>
<p>string. If <code>conditional = "BW"</code>, the
conditional AIC is calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, value of information criteria
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='init_bounds_optim'>Setting of Optimization Bounds and Initial Values</h2><span id='topic+init_bounds_optim'></span>

<h3>Description</h3>

<p>Sets bounds and initial values for <code><a href="stats.html#topic+optim">optim</a></code> by
extracting potentially given values from <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code> and
checking them, or calculating them from given data. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_bounds_optim(control, p, q, id_obj, med_dist, y_var, OLS_mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_bounds_optim_+3A_control">control</code></td>
<td>
<p>(<code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code> output, i.e. <code>list</code>)</p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_p">p</code></td>
<td>
<p>(<code>numeric(1)</code>) <br /> Number of fixed effects</p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_q">q</code></td>
<td>
<p>(<code>numeric(1)</code>) <br /> Number of SVCs</p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_id_obj">id_obj</code></td>
<td>
<p>(<code>numeric(2*q+1+q)</code>) <br /> Index vector to identify the
arguments of objective function.</p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_med_dist">med_dist</code></td>
<td>
<p>(<code>numeric(1)</code>) <br /> Median distance between observations</p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_y_var">y_var</code></td>
<td>
<p>(<code>numeric(1)</code>) <br /> Variance of response <code>y</code></p>
</td></tr>
<tr><td><code id="init_bounds_optim_+3A_ols_mu">OLS_mu</code></td>
<td>
<p>(<code>numeric(p)</code>) <br /> Coefficient estimates of ordinary
least squares (OLS).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If values are not provided, then they are set in the following way.
Let <code class="reqn">d</code> be the median distance <code>med_dist</code>, let <code class="reqn">s^2_y</code> be
the variance of the response <code>y_var</code>, and let <code class="reqn">b_j</code> be the OLS
coefficients of the linear model. The computed values are given in the
table below.</p>

<table>
<tr>
 <td style="text-align: left;">
   Parameter </td><td style="text-align: right;"> Lower bound </td><td style="text-align: right;"> Initial Value </td><td style="text-align: right;"> Upper Bound </td>
</tr>
<tr>
 <td style="text-align: left;">
   Range </td><td style="text-align: right;"> <code class="reqn">d/1000</code> </td><td style="text-align: right;"> <code class="reqn">d/4</code> </td><td style="text-align: right;"> <code class="reqn">10 d</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Variance </td><td style="text-align: right;"> <code class="reqn">0</code> </td><td style="text-align: right;"> <code class="reqn">s^2_y/(q+1)</code> </td><td style="text-align: right;"> <code class="reqn">10s^2_y</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Nugget </td><td style="text-align: right;"> <code class="reqn">10^{-6}</code> </td><td style="text-align: right;"> <code class="reqn">s^2_y/(q+1)</code> </td><td style="text-align: right;"> <code class="reqn">10s^2_y</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   Mean <code class="reqn">j</code> </td><td style="text-align: right;"> <code>-Inf</code> </td><td style="text-align: right;"> <code class="reqn">b_j</code> </td><td style="text-align: right;"> <code>Inf</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A <code>list</code> with three entries: <code>lower</code>, <code>init</code>,
and <code>upper</code>.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='logLik.SVC_mle'>Extact the Likelihood</h2><span id='topic+logLik.SVC_mle'></span>

<h3>Description</h3>

<p>Method to extract the computed (penalized) log (profile) Likelihood from an <code><a href="#topic+SVC_mle">SVC_mle</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="logLik.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>logLik</code> with attributes
</p>

<ul>
<li> <p><code>"penalized"</code>, logical, if the likelihood (<code>FALSE</code>) or some penalized likelihood (<code>TRUE</code>) was optimized.
</p>
</li>
<li> <p><code>"profileLik"</code>, logical, if the optimization was done using the profile likelihood  (<code>TRUE</code>) or not.
</p>
</li>
<li> <p><code>"nobs"</code>, integer of number of observations
</p>
</li>
<li> <p><code>"df"</code>, integer of how many parameters were estimated. <strong>Note</strong>: This includes only the covariance parameters if the profile likelihood was used.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='nlocs'>Extract Number of Unique Locations</h2><span id='topic+nlocs'></span>

<h3>Description</h3>

<p>Function to extract the number of unique locations in the data 
set used in an MLE of the <code><a href="#topic+SVC_mle">SVC_mle</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlocs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlocs_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer with the number of unique locations
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='nobs.SVC_mle'>Extract Number of Observations</h2><span id='topic+nobs.SVC_mle'></span>

<h3>Description</h3>

<p>Method to extract the number of observations used in MLE for an <code><a href="#topic+SVC_mle">SVC_mle</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="nobs.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer of number of observations
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='plot.SVC_mle'>Plotting Residuals of <code>SVC_mle</code> model</h2><span id='topic+plot.SVC_mle'></span>

<h3>Description</h3>

<p>Method to plot the residuals from an <code><a href="#topic+SVC_mle">SVC_mle</a></code>
object. For this, <code>save.fitted</code> has to be <code>TRUE</code> in
<code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
plot(x, which = 1:2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SVC_mle_+3A_x">x</code></td>
<td>
<p>(<code><a href="#topic+SVC_mle">SVC_mle</a></code>)</p>
</td></tr>
<tr><td><code id="plot.SVC_mle_+3A_which">which</code></td>
<td>
<p>(<code>numeric</code>) <br /> A numeric vector and subset of
<code>1:2</code> indicating which of the 2 plots should be plotted.</p>
</td></tr>
<tr><td><code id="plot.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a maximum 2 plots
</p>

<ul>
<li><p> Tukey-Anscombe plot, i.e. residuals vs. fitted
</p>
</li>
<li><p> QQ-plot
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+legend">legend</a></code>  <a href="#topic+SVC_mle">SVC_mle</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## ---- toy example ----
## sample data
# setting seed for reproducibility
set.seed(123)
m &lt;- 7
# number of observations
n &lt;- m*m
# number of SVC
p &lt;- 3
# sample data
y &lt;- rnorm(n)
X &lt;- matrix(rnorm(n*p), ncol = p)
# locations on a regular m-by-m-grid
locs &lt;- expand.grid(seq(0, 1, length.out = m),
                    seq(0, 1, length.out = m))

## preparing for maximum likelihood estimation (MLE)
# controls specific to MLE
control &lt;- SVC_mle_control(
  # initial values of optimization
  init = rep(0.1, 2*p+1),
  # using profile likelihood
  profileLik = TRUE
)

# controls specific to optimization procedure, see help(optim)
opt.control &lt;- list(
  # number of iterations (set to one for demonstration sake)
  maxit = 1,
  # tracing information
  trace = 6
)

## starting MLE
fit &lt;- SVC_mle(y = y, X = X, locs = locs,
               control = control,
               optim.control = opt.control)

## output: convergence code equal to 1, since maxit was only 1
summary(fit)

## plot residuals
# only QQ-plot
plot(fit, which = 2)

# two plots next to each other
oldpar &lt;- par(mfrow = c(1, 2))
plot(fit)
par(oldpar)

</code></pre>

<hr>
<h2 id='predict.SVC_mle'>Prediction of SVCs (and response variable)</h2><span id='topic+predict.SVC_mle'></span>

<h3>Description</h3>

<p>Prediction of SVCs (and response variable)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
predict(
  object,
  newlocs = NULL,
  newX = NULL,
  newW = NULL,
  newdata = NULL,
  compute.y.var = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SVC_mle_+3A_object">object</code></td>
<td>
<p>(<code>SVC_mle</code>) <br />
Model obtained from <code><a href="#topic+SVC_mle">SVC_mle</a></code> function call.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_newlocs">newlocs</code></td>
<td>
<p>(<code>NULL</code> or <code>matrix(n.new, 2)</code>) <br />
If <code>NULL</code>, then function uses observed locations of model to estimate
SVCs. Otherwise, these are the new locations the SVCs are predicted for.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_newx">newX</code></td>
<td>
<p>(<code>NULL</code> or <code>matrix(n.new, q)</code>) <br />
If provided (together with <code>newW</code>), the function also returns the
predicted response variable.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_neww">newW</code></td>
<td>
<p>(<code>NULL</code> or <code>matrix(n.new, p)</code>) <br />
If provided (together with <code>newX</code>), the function also returns the
predicted response variable.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_newdata">newdata</code></td>
<td>
<p>(<code>NULL</code> or <code>data.frame(n.new, p)</code>) <br />
This argument can be used, when the <code>SVC_mle</code> function has been called
with an formula, see examples.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_compute.y.var">compute.y.var</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code> and the response is being estimated, the predictive
variance of each estimate will be computed.</p>
</td></tr>
<tr><td><code id="predict.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data frame of <code>n.new</code> rows and with
columns
</p>

<ul>
<li> <p><code>SVC_1, ..., SVC_p</code>: the predicted SVC at locations <code>newlocs</code>.
</p>
</li>
<li> <p><code>y.pred</code>, if <code>newX</code> and <code>newW</code> are provided
</p>
</li>
<li> <p><code>y.var</code>, if <code>newX</code> and <code>newW</code> are provided and
<code>compute.y.var</code> is set to <code>TRUE</code>.
</p>
</li>
<li> <p><code>loc_x, loc_y</code>, the locations of the predictions
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>References</h3>

<p>Dambon, J. A., Sigrist, F., Furrer, R. (2021)
<em>Maximum likelihood estimation of spatially varying coefficient
models for large data with an application to real estate price prediction</em>,
Spatial Statistics doi: <a href="https://doi.org/10.1016/j.spasta.2020.100470">10.1016/j.spasta.2020.100470</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVC_mle">SVC_mle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---- toy example ----
## We use the sampled, i.e., one dimensional SVCs
str(SVCdata)
# sub-sample data to have feasible run time for example
set.seed(123)
id &lt;- sample(length(SVCdata$locs), 50)

## SVC_mle call with matrix arguments
fit_mat &lt;- with(SVCdata, SVC_mle(
  y[id], X[id, ], locs[id], 
  control = SVC_mle_control(profileLik = TRUE, cov.name = "mat32")))

## SVC_mle call with formula
df &lt;- with(SVCdata, data.frame(y = y[id], X = X[id, -1]))
fit_form &lt;- SVC_mle(
  y ~ X, data = df, locs = SVCdata$locs[id], 
  control = SVC_mle_control(profileLik = TRUE, cov.name = "mat32")
)

## prediction

# predicting SVCs
predict(fit_mat, newlocs = 1:2)
predict(fit_form, newlocs = 1:2)

# predicting SVCs and response providing new covariates
predict(
  fit_mat, 
  newX = matrix(c(1, 1, 3, 4), ncol = 2), 
  newW = matrix(c(1, 1, 3, 4), ncol = 2), 
  newlocs = 1:2
)
predict(fit_form, newdata = data.frame(X = 3:4), newlocs = 1:2)

</code></pre>

<hr>
<h2 id='print.summary.SVC_mle'>Printing Method for <code>summary.SVC_mle</code></h2><span id='topic+print.summary.SVC_mle'></span>

<h3>Description</h3>

<p>Printing Method for <code>summary.SVC_mle</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.SVC_mle'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.SVC_mle_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+summary.SVC_mle">summary.SVC_mle</a></code></p>
</td></tr>
<tr><td><code id="print.summary.SVC_mle_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.summary.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The printed output of the summary in the console.
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.SVC_mle">summary.SVC_mle</a> <a href="#topic+SVC_mle">SVC_mle</a>
</p>

<hr>
<h2 id='print.SVC_mle'>Print Method for <code>SVC_mle</code></h2><span id='topic+print.SVC_mle'></span>

<h3>Description</h3>

<p>Method to print an <code><a href="#topic+SVC_mle">SVC_mle</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SVC_mle_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="print.SVC_mle_+3A_digits">digits</code></td>
<td>
<p>(<code>numeric</code>)
Number of digits to be plotted.</p>
</td></tr>
<tr><td><code id="print.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='residuals.SVC_mle'>Extact Model Residuals</h2><span id='topic+residuals.SVC_mle'></span>

<h3>Description</h3>

<p>Method to extract the residuals from an <code><a href="#topic+SVC_mle">SVC_mle</a></code>
object. This is only possible if <code>save.fitted</code> was set to <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="residuals.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>numeric(n)</code>)
Residuals of model
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>

<hr>
<h2 id='sample_SVCdata'>Sample Function for GP-based SVC Model for Given Locations</h2><span id='topic+sample_SVCdata'></span>

<h3>Description</h3>

<p>Samples SVC data at given locations. The SVCs parameters and the
covariance function have to be provided. The sampled model matrix can be 
provided or it is sampled. The SVCs are sampled according to their given parametrization and at
respective observation locations. The error vector is sampled from a nugget
effect. Finally, the response vector is computed. Please note that the
function is not optimized for sampling large data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_SVCdata(
  df.pars,
  nugget.sd,
  locs,
  cov.name = c("exp", "sph", "mat32", "mat52", "wend1", "wend2"),
  X = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_SVCdata_+3A_df.pars">df.pars</code></td>
<td>
<p>(<code>data.frame(p, 3)</code>) <br />
Contains the mean and covariance parameters of SVCs. The three columns
must have the names <code>"mean"</code>, <code>"var"</code>, and <code>"scale"</code>.</p>
</td></tr>
<tr><td><code id="sample_SVCdata_+3A_nugget.sd">nugget.sd</code></td>
<td>
<p>(<code>numeric(1)</code>) <br />
Standard deviation of the nugget / error term.</p>
</td></tr>
<tr><td><code id="sample_SVCdata_+3A_locs">locs</code></td>
<td>
<p>(<code>numeric(n)</code> or <code>matrix(n, d)</code>) <br />
The numeric vector or matrix contains the observation locations and
therefore defines the number of observations to be <code>n</code>. For a vector,
we assume locations on the real line, i.e., <code class="reqn">d=1</code>.</p>
</td></tr>
<tr><td><code id="sample_SVCdata_+3A_cov.name">cov.name</code></td>
<td>
<p>(<code>character</code>(1)) <br />
Character defining the covariance function, c.f. <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code>.</p>
</td></tr>
<tr><td><code id="sample_SVCdata_+3A_x">X</code></td>
<td>
<p>(<code>NULL</code> or <code>matrix(n, p)</code>) <br />
If <code>NULL</code>, the covariates are sampled, where the first column contains 
only ones to model an intercept and further columns are sampled from a 
standard normal. If it is provided as a <code>matrix</code>, then the dimensions
must match the number of locations in <code>locs</code> (<code>n</code>) and the number of SVCs
defined by the number of rows in <code>df.pars</code> (<code>p</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters of the model can be chosen such that we obtain data
from a not full model, i.e., not all covariates are associated with a 
fixed and a random effect. Using <code>var = 0</code> for instance yields a 
constant beta coefficient for respective covariate. Note that in that 
case the <code>scale</code> value is neglected.
</p>


<h3>Value</h3>

<p><code>list</code> <br />
Returns a list with the response <code>y</code>, model matrix
<code>X</code>, a matrix <code>beta</code> containing the sampled SVC at given
locations, a vector <code>eps</code> containing the error, and a matrix
<code>locs</code> containing the original locations. The <code>true_pars</code>
contains the data frame of covariance parameters that were used to
sample the GP-based SVCs. The nugget variance has been added to the 
original argument of the function with its respective variance, but 
<code>NA</code> for <code>"mean"</code> and <code>"scale"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# SVC parameters
(df.pars &lt;- data.frame(
   var = c(2, 1),
   scale = c(3, 1),
   mean = c(1, 2)))
# nugget standard deviation
tau &lt;- 0.5

# sample locations
s &lt;- sort(runif(500, min = 0, max = 10))
SVCdata &lt;- sample_SVCdata(
  df.pars = df.pars, nugget.sd = tau, locs = s, cov.name = "mat32"
)
</code></pre>

<hr>
<h2 id='summary.SVC_mle'>Summary Method for <code>SVC_mle</code></h2><span id='topic+summary.SVC_mle'></span>

<h3>Description</h3>

<p>Method to construct a <code>summary.SVC_mle</code> object out of a
<code><a href="#topic+SVC_mle">SVC_mle</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SVC_mle'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SVC_mle_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SVC_mle">SVC_mle</a></code> object</p>
</td></tr>
<tr><td><code id="summary.SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>summary.SVC_mle</code> with summarized values of the MLE.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVC_mle">SVC_mle</a></code>
</p>

<hr>
<h2 id='SVC_mle'>MLE of SVC model</h2><span id='topic+SVC_mle'></span><span id='topic+SVC_mle.default'></span><span id='topic+SVC_mle.formula'></span>

<h3>Description</h3>

<p>Conducts a maximum likelihood estimation (MLE) for a Gaussian
process-based spatially varying coefficient model as described in 
Dambon et al. (2021) doi: <a href="https://doi.org/10.1016/j.spasta.2020.100470">10.1016/j.spasta.2020.100470</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVC_mle(...)

## Default S3 method:
SVC_mle(y, X, locs, W = NULL, control = NULL, optim.control = list(), ...)

## S3 method for class 'formula'
SVC_mle(
  formula,
  data,
  RE_formula = NULL,
  locs,
  control = NULL,
  optim.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVC_mle_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_y">y</code></td>
<td>
<p>(<code>numeric(n)</code>) <br />
Response vector.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_x">X</code></td>
<td>
<p>(<code>matrix(n, p)</code>) <br />
Design matrix. Intercept has to be added manually.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_locs">locs</code></td>
<td>
<p>(<code>matrix(n, d)</code>) <br />
Locations in a <code class="reqn">d</code>-dimensional space. May contain multiple
observations at single location.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_w">W</code></td>
<td>
<p>(<code>NULL</code> or <code>matrix(n, q)</code>) <br />
If <code>NULL</code>, the same matrix as provided in <code>X</code> is used. This
fits a full SVC model, i.e., each covariate effect is modeled with a mean
and an SVC. In this case we have <code class="reqn">p = q</code>. If optional matrix <code>W</code>
is provided, SVCs are only modeled for covariates within matrix <code>W</code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_control">control</code></td>
<td>
<p>(<code>list</code>) <br />
Control paramaters given by <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_optim.control">optim.control</code></td>
<td>
<p>(<code>list</code>) <br />
Control arguments for optimization function, see Details in
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_formula">formula</code></td>
<td>
<p>Formula describing the fixed effects in SVC model. The response, 
i.e. LHS of the formula, is not allowed to have functions such as <code>sqrt()</code> or <code>log()</code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_data">data</code></td>
<td>
<p>data frame containing the observations</p>
</td></tr>
<tr><td><code id="SVC_mle_+3A_re_formula">RE_formula</code></td>
<td>
<p>Formula describing the random effects in SVC model. 
Only RHS is considered. If <code>NULL</code>, the same RHS of argument <code>formula</code> for fixed effects is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GP-based SVC model is defined with some abuse of notation as:
</p>
<p style="text-align: center;"><code class="reqn">y(s) = X \mu + W \eta (s) + \epsilon(s)</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">y</code> is the response (vector of length <code class="reqn">n</code>)
</p>
</li>
<li> <p><code class="reqn">X</code> is the data matrix for the fixed effects covariates. The
dimensions are <code class="reqn">n</code> times <code class="reqn">p</code>. This leads to <code class="reqn">p</code> fixed effects.
</p>
</li>
<li> <p><code class="reqn">\mu</code> is the vector containing the fixed effects
</p>
</li>
<li><p> W is the data matrix for the SVCs modeled by GPs. The dimensions are
<code class="reqn">n</code> times <code class="reqn">q</code>. This lead to <code class="reqn">q</code> SVCs in the model.
</p>
</li>
<li> <p><code class="reqn">\eta</code> are the SVCs represented by a GP.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code> is the nugget effect
</p>
</li></ul>

<p>The MLE is an numeric optimization that runs <code><a href="stats.html#topic+optim">optim</a></code> or
(if parallelized) <code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code>.
</p>
<p>You can call the function in two ways. Either, you define the model matrices
yourself and provide them using the arguments <code>X</code> and <code>W</code>. As usual, 
the individual columns correspond to the fixed and random effects, i.e., the 
Gaussian processes, respectively. The second way is to call the function with
formulas, like you would in <code><a href="stats.html#topic+lm">lm</a></code>. From the <code>data.frame</code>
provided in argument <code>data</code>, the respective model matrices as described
above are implicitly built. Using simple arguments <code>formula</code> and 
<code>RE_formula</code> with <code>data</code> column names, we can decide which 
covariate is modeled with a fixed or random effect (SVC). 
</p>
<p>Note that similar to model matrix call from above, if the <code>RE_formula</code> 
is not provided, we use the one as in argument <code>formula</code>. Further, note 
that the intercept is implicitly constructed in the model matrix if not 
prohibited.
</p>


<h3>Value</h3>

<p>Object of class <code>SVC_mle</code> if <code>control$extract_fun = FALSE</code>,
meaning that a MLE has been conducted. Otherwise, if <code>control$extract_fun = TRUE</code>,
the function returns a list with two entries:
</p>

<ul>
<li> <p><code>obj_fun</code>: the objective function used in the optimization
</p>
</li>
<li> <p><code>args</code>: the arguments to evaluate the objective function.
</p>
</li></ul>

<p>For further details, see description of <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>References</h3>

<p>Dambon, J. A., Sigrist, F., Furrer, R. (2021)
<em>Maximum likelihood estimation of spatially varying coefficient
models for large data with an application to real estate price prediction</em>,
Spatial Statistics doi: <a href="https://doi.org/10.1016/j.spasta.2020.100470">10.1016/j.spasta.2020.100470</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.SVC_mle">predict.SVC_mle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---- toy example ----
## We use the sampled, i.e., one dimensional SVCs
str(SVCdata)
# sub-sample data to have feasible run time for example
set.seed(123)
id &lt;- sample(length(SVCdata$locs), 50)

## SVC_mle call with matrix arguments
fit &lt;- with(SVCdata, SVC_mle(
  y[id], X[id, ], locs[id], 
  control = SVC_mle_control(profileLik = TRUE, cov.name = "mat32")))

## SVC_mle call with formula
df &lt;- with(SVCdata, data.frame(y = y[id], X = X[id, -1]))
fit &lt;- SVC_mle(
  y ~ X, data = df, locs = SVCdata$locs[id], 
  control = SVC_mle_control(profileLik = TRUE, cov.name = "mat32")
)
class(fit)

summary(fit)


## ---- real data example ----
require(sp)
## get data set
data("meuse", package = "sp")

# construct data matrix and response, scale locations
y &lt;- log(meuse$cadmium)
X &lt;- model.matrix(~1+dist+lime+elev, data = meuse)
locs &lt;- as.matrix(meuse[, 1:2])/1000


## starting MLE
# the next call takes a couple of seconds
fit &lt;- SVC_mle(
  y = y, X = X, locs = locs,
  # has 4 fixed effects, but only 3 random effects (SVC)
  # elev is missing in SVC
  W = X[, 1:3],
  control = SVC_mle_control(
    # inital values for 3 SVC
    # 7 = (3 * 2 covariance parameters + nugget)
    init = c(rep(c(0.4, 0.2), 3), 0.2),
    profileLik = TRUE
  )
)

## summary and residual output
summary(fit)
plot(fit)

## predict
# new locations
newlocs &lt;- expand.grid(
  x = seq(min(locs[, 1]), max(locs[, 1]), length.out = 30),
  y = seq(min(locs[, 2]), max(locs[, 2]), length.out = 30))
# predict SVC for new locations
SVC &lt;- predict(fit, newlocs = as.matrix(newlocs))
# visualization
sp.SVC &lt;- SVC
coordinates(sp.SVC) &lt;- ~loc_1+loc_2
spplot(sp.SVC, colorkey = TRUE)

</code></pre>

<hr>
<h2 id='SVC_mle_control'>Set Parameters for <code>SVC_mle</code></h2><span id='topic+SVC_mle_control'></span><span id='topic+SVC_mle_control.default'></span><span id='topic+SVC_mle_control.SVC_mle'></span>

<h3>Description</h3>

<p>Function to set up control parameters for <code><a href="#topic+SVC_mle">SVC_mle</a></code>.
In the following, we assume the GP-based SVC model to have <code class="reqn">q</code> GPs which
model the SVCs and <code class="reqn">p</code> fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVC_mle_control(...)

## Default S3 method:
SVC_mle_control(
  cov.name = c("exp", "sph", "mat32", "mat52", "wend1", "wend2"),
  tapering = NULL,
  parallel = NULL,
  init = NULL,
  lower = NULL,
  upper = NULL,
  save.fitted = TRUE,
  profileLik = FALSE,
  mean.est = c("GLS", "OLS"),
  pc.prior = NULL,
  extract_fun = FALSE,
  hessian = TRUE,
  dist = list(method = "euclidean"),
  parscale = TRUE,
  ...
)

## S3 method for class 'SVC_mle'
SVC_mle_control(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVC_mle_control_+3A_...">...</code></td>
<td>
<p>Further Arguments yet to be implemented</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_cov.name">cov.name</code></td>
<td>
<p>(<code>character(1)</code>) <br />
Name of the covariance function of the GPs. Currently, the following are
implemented: <code>"exp"</code> for the exponential, <code>"sph"</code> for
spherical, <code>"mat32"</code> and <code>"mat52"</code> for Matern class covariance
functions with smoothness 3/2 or 5/2, as well as <code>"wend1"</code> and
<code>"wend2"</code> for Wendland class covariance functions with kappa 1 or 2.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_tapering">tapering</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric(1)</code>) <br />
If <code>NULL</code>, no tapering is applied. If a scalar is given, covariance
tapering with this taper range is applied, for all Gaussian processes
modeling the SVC. Only defined for Matern class covariance functions,
i.e., set <code>cov.name</code> either to <code>"exp"</code>, <code>"mat32"</code>, or
<code>"mat52"</code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_parallel">parallel</code></td>
<td>
<p>(<code>NULL</code> or <code>list</code>) <br />
If <code>NULL</code>, no parallelization is applied. If cluster has been
established, define arguments for parallelization with a list, see
documentation of <code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code>. See Examples.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_init">init</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric(2q+1+p*as.numeric(profileLik))</code>) <br />
Initial values for optimization procedure. If <code>NULL</code> is given, an
initial vector is calculated (see Details). Otherwise, the vector is
assumed to consist of q-times (alternating) range and variance,
the nugget variance and if <code>profileLik = TRUE</code> p mean effects.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_lower">lower</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric(2q+1+p*as.numeric(profileLik))</code>) <br />
Lower bound for <code>init</code> in <code>optim</code>. Default <code>NULL</code> calculates
the lower bounds (see Details).</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_upper">upper</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric(2q+1+p*as.numeric(profileLik))</code>) <br />
Upper bound for <code>init</code> in <code>optim</code>. Default <code>NULL</code> calculates
the upper bounds (see Details).</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_save.fitted">save.fitted</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, calculates the fitted values and residuals after MLE and
stores them. This is necessary to call <code><a href="stats.html#topic+residuals">residuals</a></code> and
<code><a href="stats.html#topic+fitted">fitted</a></code> methods afterwards.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_profilelik">profileLik</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, MLE is done over profile Likelihood of covariance
parameters.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_mean.est">mean.est</code></td>
<td>
<p>(<code>character(1)</code>) <br />
If <code>profileLik = TRUE</code>, the means have to be estimated seperately for
each step. <code>"GLS"</code> uses the generalized least square estimate while
<code>"OLS"</code> uses the ordinary least squares estimate.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_pc.prior">pc.prior</code></td>
<td>
<p>(<code>NULL</code> or <code>numeric(4)</code>) <br />
If numeric vector is given, penalized complexity priors are applied. The
order is <code class="reqn">\rho_0, \alpha_\rho, \sigma_0, \alpha_\sigma</code> to give some
prior believes for the range and the standard deviation of GPs, such that
<code class="reqn">P(\rho &lt; \rho_0) = \alpha_\rho, P(\sigma &gt; \sigma_0) = \alpha_\sigma</code>.
This regulates the optimization process. Currently, only supported for
GPs with of Matrn class covariance functions. Based on the idea by
Fulgstad et al. (2018) doi: <a href="https://doi.org/10.1080/01621459.2017.1415907">10.1080/01621459.2017.1415907</a>.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_extract_fun">extract_fun</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, the function call of <code><a href="#topic+SVC_mle">SVC_mle</a></code> stops before
the MLE and gives back the objective function of the MLE as well as all
used arguments. If <code>FALSE</code>, regular MLE is conducted.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_hessian">hessian</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, Hessian matrix is computed, see <a href="stats.html#topic+optim">optim</a>. This
required to give the standard errors for covariance parameters and to do
a Wald test on the variances, see <code><a href="#topic+summary.SVC_mle">summary.SVC_mle</a></code>.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_dist">dist</code></td>
<td>
<p>(<code>list</code>) <br />
List containing the arguments of <a href="stats.html#topic+dist">dist</a> or
<a href="spam.html#topic+nearest.dist">nearest.dist</a>. This controls
the method of how the distances and therefore dependency structures are
calculated. The default gives Euclidean distances in a <code class="reqn">d</code>-dimensional
space. Further editable arguments are <code>p, miles, R</code>, see respective
help files of <a href="stats.html#topic+dist">dist</a> or <a href="spam.html#topic+nearest.dist">nearest.dist</a>.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_parscale">parscale</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
Triggers parameter scaling within the optimization in <a href="stats.html#topic+optim">optim</a>.
If <code>TRUE</code>, the optional parameter scaling in <code>optim.control</code> in
function <code><a href="#topic+SVC_mle">SVC_mle</a></code> is overwritten by the initial value used in
the numeric optimization. The initial value is either computed from the
data or provided by the user, see <code>init</code> argument above or Details
below. Note that we check whether the initial values are unequal to zero.
If they are zero, the corresponding scaling factor is 0.001. If
<code>FALSE</code>, the <code>parscale</code> argument in <code>optim.control</code> is let
unchanged.</p>
</td></tr>
<tr><td><code id="SVC_mle_control_+3A_object">object</code></td>
<td>
<p>(<code>SVC_mle</code>) <br />
The function then extracts the control settings from the function call
used to compute in the given <code>SVC_mle</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not provided, the initial values as well as the lower and upper
bounds are calculated given the provided data. In particular, we require
the median distance between observations, the variance of the response and,
the ordinary least square (OLS) estimates, see <code><a href="#topic+init_bounds_optim">init_bounds_optim</a></code>.
</p>
<p>The argument <code>extract_fun</code> is useful, when one wants to modify
the objective function. Further, when trying to parallelize the
optimization, it is useful to check whether a single evaluation of the
objective function takes longer than 0.05 seconds to evaluate,
cf. Gerber and Furrer (2019) doi: <a href="https://doi.org/10.32614/RJ-2019-030">10.32614/RJ-2019-030</a>. Platform specific
issues can be sorted out by the user by setting up their own optimization.
</p>


<h3>Value</h3>

<p>A list with which <code><a href="#topic+SVC_mle">SVC_mle</a></code> can be controlled.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVC_mle">SVC_mle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control &lt;- SVC_mle_control(init = rep(0.3, 10))
# or
control &lt;- SVC_mle_control()
control$init &lt;- rep(0.3, 10)


# Code for setting up parallel computing
require(parallel)
# exchange number of nodes (1) for detectCores()-1 or appropriate number
cl &lt;- makeCluster(1, setup_strategy = "sequential")
clusterEvalQ(
  cl = cl,
  {
    library(spam)
    library(varycoef)
  })
# use this list for parallel argument in SVC_mle_control
parallel.control &lt;- list(cl = cl, forward = TRUE, loginfo = TRUE)
# SVC_mle goes here ...
# DO NOT FORGET TO STOP THE CLUSTER!
stopCluster(cl); rm(cl)

</code></pre>

<hr>
<h2 id='SVC_selection'>SVC Model Selection</h2><span id='topic+SVC_selection'></span>

<h3>Description</h3>

<p>This function implements the variable selection for
Gaussian process-based SVC models using a penalized maximum likelihood
estimation (PMLE, Dambon et al., 2021, &lt;arXiv:2101.01932&gt;).
It jointly selects the fixed and random effects of GP-based SVC models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVC_selection(obj.fun, mle.par, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVC_selection_+3A_obj.fun">obj.fun</code></td>
<td>
<p>(<code>SVC_obj_fun</code>) <br />
Function of class <code>SVC_obj_fun</code>. This is the output of
<code><a href="#topic+SVC_mle">SVC_mle</a></code> with the <code><a href="#topic+SVC_mle_control">SVC_mle_control</a></code> parameter
<code>extract_fun</code> set to <code>TRUE</code>. This objective function comprises
of the whole SVC model on which the selection should be applied.</p>
</td></tr>
<tr><td><code id="SVC_selection_+3A_mle.par">mle.par</code></td>
<td>
<p>(<code>numeric(2*q+1)</code>) <br />
Numeric vector with estimated covariance parameters of unpenalized MLE.</p>
</td></tr>
<tr><td><code id="SVC_selection_+3A_control">control</code></td>
<td>
<p>(<code>list</code> or <code>NULL</code>) <br />
List of control parameters for variable selection. Output of
<code><a href="#topic+SVC_selection_control">SVC_selection_control</a></code>. If <code>NULL</code> is given, the 
default values of <code><a href="#topic+SVC_selection_control">SVC_selection_control</a></code> are used.</p>
</td></tr>
<tr><td><code id="SVC_selection_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>SVC_selection</code>. It contains parameter estimates under PMLE and the optimization as well as choice of the shrinkage parameters.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>References</h3>

<p>Dambon, J. A., Sigrist, F., Furrer, R. (2021).
<em>Joint Variable Selection of both Fixed and Random Effects for
Gaussian Process-based Spatially Varying Coefficient Models</em>,
ArXiv Preprint <a href="https://arxiv.org/abs/2101.01932">https://arxiv.org/abs/2101.01932</a>
</p>

<hr>
<h2 id='SVC_selection_control'>SVC Selection Parameters</h2><span id='topic+SVC_selection_control'></span>

<h3>Description</h3>

<p>Function to set up control parameters for
<code><a href="#topic+SVC_selection">SVC_selection</a></code>. The underlying Gaussian Process-based
SVC model is defined in <code><a href="#topic+SVC_mle">SVC_mle</a></code>. <code><a href="#topic+SVC_selection">SVC_selection</a></code>
then jointly selects fixed and random effects of the GP-based
SVC model using a penalized maximum likelihood estimation (PMLE).
In this function, one can set the parameters for the PMLE and
its optimization procedures (Dambon et al., 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVC_selection_control(
  IC.type = c("BIC", "cAIC_BW", "cAIC_VB"),
  method = c("grid", "MBO"),
  r.lambda = c(1e-10, 10),
  n.lambda = 10L,
  n.init = 10L,
  n.iter = 10L,
  CD.conv = list(N = 20L, delta = 1e-06, logLik = TRUE),
  hessian = FALSE,
  adaptive = FALSE,
  parallel = NULL,
  optim.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVC_selection_control_+3A_ic.type">IC.type</code></td>
<td>
<p>(<code>character(1)</code>) <br />
Select Information Criterion.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_method">method</code></td>
<td>
<p>(<code>character(1)</code>) <br />
Select optimization method for lambdas, i.e., shrinkage parameters.
Either model-based optimization (MBO, Bischl et al., 2017 &lt;arXiv:1703.03373&gt;) or over grid.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_r.lambda">r.lambda</code></td>
<td>
<p>(<code>numeric(2)</code>) <br />
Range of lambdas, i.e., shrinkage parameters.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_n.lambda">n.lambda</code></td>
<td>
<p>(<code>numeric(1)</code>) <br />
If grid method is selected, number of lambdas per side of grid.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_n.init">n.init</code></td>
<td>
<p>(<code>numeric(1)</code>) <br />
If MBO method is selected, number of initial values for surrogate model.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_n.iter">n.iter</code></td>
<td>
<p>(<code>numeric(1)</code>) <br />
If MBO method is selected, number of iteration steps of surrogate models.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_cd.conv">CD.conv</code></td>
<td>
<p>(<code>list(3)</code>) <br />
List containing the convergence conditions, i.e.,
first entry is the maximum number of iterations,
second value is the relative change necessary to stop iteration,
third is logical to toggle if relative change in log likelihood
(<code>TRUE</code>) or rather the parameters themselves (<code>FALSE</code>)
is the criteria for convergence.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_hessian">hessian</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, Hessian will be computed for final model.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_adaptive">adaptive</code></td>
<td>
<p>(<code>logical(1)</code>) <br />
If <code>TRUE</code>, adaptive LASSO is executed, i.e.,
the shrinkage parameter is defined as <code class="reqn">\lambda_j := \lambda / |\theta_j|</code>.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_parallel">parallel</code></td>
<td>
<p>(<code>list</code>) <br />
List with arguments for parallelization,
see documentation of <code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code>.</p>
</td></tr>
<tr><td><code id="SVC_selection_control_+3A_optim.args">optim.args</code></td>
<td>
<p>(<code>list</code>) <br />
List of further arguments of <code><a href="optimParallel.html#topic+optimParallel">optimParallel</a></code>,
such as the lower bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of control parameters for SVC selection.
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>References</h3>

<p>Bischl, B., Richter, J., Bossek, J., Horn, D., Thomas, J.,
Lang, M. (2017).
<em>mlrMBO: A Modular Framework for Model-Based Optimization of
Expensive Black-Box Functions</em>,
ArXiv preprint <a href="https://arxiv.org/abs/1703.03373">https://arxiv.org/abs/1703.03373</a>
</p>
<p>Dambon, J. A., Sigrist, F., Furrer, R. (2022).
<em>Joint Variable Selection of both Fixed and Random Effects for
Gaussian Process-based Spatially Varying Coefficient Models</em>,
International Journal of Geographical Information Science
doi: <a href="https://doi.org/10.1080/13658816.2022.2097684">10.1080/13658816.2022.2097684</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Initializing parameters and switching logLik to FALSE
selection_control &lt;- SVC_selection_control(
  CD.conv = list(N = 20L, delta = 1e-06, logLik = FALSE)
)
# or
selection_control &lt;- SVC_selection_control()
selection_control$CD.conv$logLik &lt;- FALSE

</code></pre>

<hr>
<h2 id='SVCdata'>Sampled SVC Data</h2><span id='topic+SVCdata'></span>

<h3>Description</h3>

<p>A list object that contains sampled data of 500 observations. The data has 
been sampled using the <code>RandomFields</code> package (Schlather et al., 2015). 
It is given in the list object <code>SVCdata</code> which contains the following.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVCdata
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with the following entries:
</p>

<dl>
<dt>y</dt><dd><p>(<code>numeric</code>) Response</p>
</dd>
<dt>X</dt><dd><p>(<code>numeric</code>) Covariates; first columns contains ones to model
an intercept, the second column contains standard-normal sampled data.</p>
</dd>
<dt>beta</dt><dd><p>(<code>numeric</code>) The sampled Gaussian processes, which are
usually unobserved. It uses a Matern covariance function and the true 
parameters are given in the entry 'true_pars'.</p>
</dd>
<dt>eps</dt><dd><p>(<code>numeric</code>) Error (or Nugget effect), i.e., drawn from a 
zero-mean normal distribution with 0.5 standard deviation.</p>
</dd>
<dt>locs</dt><dd><p>(<code>numeric</code>) Locations sampled from a uniform distribution
on the interval 0 to 10.</p>
</dd>
<dt>true_pars</dt><dd><p>(<code>data.frame</code>) True parameters of the GP-based SVC 
model with Gaussian process mean, variance, and range. Additionally, the 
smoothness (nu) is given.</p>
</dd>
</dl>



<h3>References</h3>

<p>Schlather, M., Malinowski, A., Menck, P. J., Oesting, M., Strokorb, K. (2015) 
<em>Analysis, simulation and prediction of multivariate random fields with package RandomFields</em>,
Journal of Statistical Software, doi: <a href="https://doi.org/10.18637/jss.v063.i08">10.18637/jss.v063.i08</a>
</p>

<hr>
<h2 id='varycoef'>varycoef: Modeling Spatially Varying Coefficients</h2><span id='topic+varycoef'></span>

<h3>Description</h3>

<p>This package offers functions to estimate and predict Gaussian process-based
spatially varying coefficient (SVC) models. Briefly described, one
generalizes a linear regression equation such that the coefficients are no
longer constant, but have the possibility to vary spatially. This is enabled
by modeling the coefficients using Gaussian processes with (currently) either
an exponential or spherical covariance function. The advantages of such SVC
models are that they are usually quite easy to interpret, yet they offer a
very high level of flexibility.
</p>


<h3>Estimation and Prediction</h3>

<p>The ensemble of the function <code><a href="#topic+SVC_mle">SVC_mle</a></code> and the method
<code>predict</code> estimates the defined SVC model and gives predictions of the
SVC as well as the response for some pre-defined locations. This concept
should be rather familiar as it is the same for the classical regression
(<code><a href="stats.html#topic+lm">lm</a></code>) or local polynomial regression (<code><a href="stats.html#topic+loess">loess</a></code>),
to name a couple. As the name suggests, we are using a <em>maximum
likelihood estimation</em> (MLE) approach in order to estimate the model. The
predictor is obtained by the empirical best linear unbiased predictor.
to give location-specific predictions. A detailed tutorial with examples is
given in a vignette; call <code>vignette("example", package = "varycoef")</code>.
We also refer to the original article Dambon et al. (2021) which lays the
methodological foundation of this package.
</p>
<p>With the before mentioned <code><a href="#topic+SVC_mle">SVC_mle</a></code> function one gets an object
of class <code><a href="#topic+SVC_mle">SVC_mle</a></code>. And like the method <code>predict</code> for
predictions, there are several more methods in order to diagnose the model,
see <code>methods(class = "SVC_mle")</code>.
</p>


<h3>Variable Selection</h3>

<p>As of version 0.3.0 of <code>varycoef</code>, a joint variable selection of both
fixed and random effect of the Gaussian process-based SVC model is
implemented. It uses a <em>penalized maximum likelihood estimation</em> (PMLE)
which is implemented via a gradient descent. The estimation of the shrinkage
parameter is available using a <em>model-based optimization</em> (MBO). Here,
we use the framework by Bischl et al. (2017). The methodological foundation
of the PMLE is described in Dambon et al. (2022).
</p>


<h3>Author(s)</h3>

<p>Jakob Dambon
</p>


<h3>References</h3>

<p>Bischl, B., Richter, J., Bossek, J., Horn, D., Thomas, J.,
Lang, M. (2017). <em>mlrMBO: A Modular Framework for Model-Based
Optimization of Expensive Black-Box Functions</em>,
ArXiv preprint <a href="https://arxiv.org/abs/1703.03373">https://arxiv.org/abs/1703.03373</a>
</p>
<p>Dambon, J. A., Sigrist, F., Furrer, R. (2021).
<em>Maximum likelihood estimation of spatially varying coefficient
models for large data with an application to real estate price prediction</em>,
Spatial Statistics 41 100470 doi: <a href="https://doi.org/10.1016/j.spasta.2020.100470">10.1016/j.spasta.2020.100470</a>
</p>
<p>Dambon, J. A., Sigrist, F., Furrer, R. (2022).
<em>Joint Variable Selection of both Fixed and Random Effects for
Gaussian Process-based Spatially Varying Coefficient Models</em>,
International Journal of Geographical Information Science
doi: <a href="https://doi.org/10.1080/13658816.2022.2097684">10.1080/13658816.2022.2097684</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vignette("manual", package = "varycoef")
methods(class = "SVC_mle")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
