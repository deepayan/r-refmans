<!DOCTYPE html><html lang="en"><head><title>Help for package BMconcor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BMconcor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#concor'><p>Relative links of several subsets of variables</p></a></li>
<li><a href='#concorcano'><p>Canonical analysis of several sets with another set</p></a></li>
<li><a href='#concoreg'><p>Redundancy of sets yj by one set x</p></a></li>
<li><a href='#concorgm'><p>Analyzing a set of partial links between Xi and Yj</p></a></li>
<li><a href='#concorgmcano'><p>Canonical analysis of subsets Yj with subsets Xi</p></a></li>
<li><a href='#concorgmreg'><p>Regression of subsets Yj by subsets Xi</p></a></li>
<li><a href='#concors'><p>simultaneous  concorgm</p></a></li>
<li><a href='#concorscano'><p>simultaneous concorgmcano</p></a></li>
<li><a href='#concorsreg'><p>Redundancy of sets yj by one set x</p></a></li>
<li><a href='#svdbip'><p>SVD for one bipartitioned matrix x</p></a></li>
<li><a href='#svdbip2'><p>SVD for bipartitioned matrix x</p></a></li>
<li><a href='#svdbips'><p>SVD for bipartitioned matrix x</p></a></li>
<li><a href='#svdcp'><p>SVD for a Column Partitioned matrix x</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>CONCOR for Structural- And Regular-Equivalence Blockmodeling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The four functions svdcp() ('cp' for column partitioned), svdbip() or svdbip2() ('bip' for bipartitioned), and svdbips() ('s' for a simultaneous optimization of a set of 'r' solutions), correspond to a singular value decomposition (SVD) by blocks notion, by supposing each block depending on relative subspaces, rather than on two whole spaces as usual SVD does. The other functions, based on this notion, are relative to two column partitioned data matrices x and y defining two sets of subsets x_i and y_j of variables and amount to estimate a link between x_i and y_j for the pair (x_i, y_j) relatively to the links associated to all the other pairs. These methods were first presented in: Lafosse R. &amp; Hanafi M.,(1997) <a href="https://eudml.org/doc/106424">https://eudml.org/doc/106424</a> and Hanafi M. &amp; Lafosse, R. (2001) <a href="https://eudml.org/doc/106494">https://eudml.org/doc/106494</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fatelarico.github.io/BMconcor/">https://fatelarico.github.io/BMconcor/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-01 09:32:49 UTC; fabio</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Lafosse [aut],
  Fabio Ashtar Telarico
    <a href="https://orcid.org/0000-0002-8740-7078"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabio Ashtar Telarico &lt;Fabio-Ashtar.Telarico@fdv.uni-lj.si&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-02 13:22:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='concor'>Relative links of several subsets of variables</h2><span id='topic+concor'></span>

<h3>Description</h3>

<p>Relative links of several subsets of variables Yj with another set X. SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concor(x, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concor_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concor_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concor_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concor_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates 1+kx normed vectors: the vector <code>u[:,1]</code> of Rp associated to the ky vectors <code>vi[:,1]</code>'s of Rqi,
by maximizing <code class="reqn">\sum_i \mbox{cov}(x*u[,k],y_i*v_i[,k])^2</code>, with 1+ky norm constraints on the axes.
A component <code>(x)(u[,k])</code> is associated to ky partial components <code>(yi)(vi)[,k]</code> and to a global component <code>y*V[,k]</code>.
<code class="reqn">\mbox{cov}((x)(u[,k]),(y)(V[,k]))^2 = \sum \mbox{cov}((x)(u[,k]),(y_i)(v_i[,k]))^2</code>.
<code>(y)(V[,k])</code> is a global component of the components <code>(yi)(vi[,k])</code>.
The second solution is obtained from the same criterion, but after replacing each yi by <code class="reqn">y_i-(y_i)(v_i[,1])(v_i[,1]')</code>.
And so on for the successive solutions 1,2,...,r.  The biggest number of solutions may be r = inf(n, p, qi), when the (x')(yi')(s)
are supposed with full rank; then rmax = min(c(min(py),n,p)).  For a set of r solutions, the matrix u'X'YV is diagonal and the
matrices u'X'Yjvj are triangular (good partition of the link by the solutions).
concor.m is the svdcp.m function applied to the matrix x'y.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>A <code>p</code> times <code>r</code> matrix of axes in <code>Rp</code> relative to <code>x; (u^prime)(u) = Identity</code></p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>A <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>A <code>q</code> times <code>r</code> matrix of axes in <code>Rq</code> relative to <code>y; Vprime*V = Identity</code></p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>A <code>ky</code> times <code>r</code> matrix; each column <code>k</code> contains <code>ky</code> squared covariances <code class="reqn">\mbox{cov}(x*u[,k],y_i*v_i[,k])^2</code>, the partial measures of link</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Lafosse R. &amp; Hanafi M.(1997) Concordance d'un tableau avec K tableaux: Definition de K+1 uples synthetiques. Revue de Statistique Appliquee vol.45,n.4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# To make some "GPA" : so, by posing the compromise X = Y,
# "procrustes" rotations to the "compromise X" then are :
# Yj*(vj*u').
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
co &lt;- concor(x,y,c(3,2,4),2)

</code></pre>

<hr>
<h2 id='concorcano'>Canonical analysis of several sets with another set</h2><span id='topic+concorcano'></span>

<h3>Description</h3>

<p>Relative proximities of several subsets of variables Yj with another set X. SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorcano(x, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorcano_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorcano_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorcano_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorcano_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates a standardized canonical component <code>cx[,1]</code> of x associated to ky
standardized components <code>cyi[,1]</code> of yi by maximizing <code class="reqn">\sum_i \rho(cx[,1],cy_i[,1])^2</code>.
The second solution is obtained from the same criterion, with ky
orthogonality constraints for having <code>rho(cyi[,1],cyi[,2])=0</code> (that
implies <code>rho(cx[,1],cx[,2])=0)</code>.  For each of the 1+ky sets, the r
canonical components are 2 by 2 zero correlated.
The ky matrices (cx)'*cyi are triangular.
This function uses concor function.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code> matrix of the r canonical components of x</p>
</td></tr>
<tr><td><code>cy</code></td>
<td>
<p>a <code>n.ky</code> times <code>r</code> matrix. The ky blocks cyi of the rows n*(i-1)+1 : n*i contain the r canonical components relative to Yi</p>
</td></tr>
<tr><td><code>rho2</code></td>
<td>
<p>a <code>ky</code> times <code>r</code> matrix; each column k contains ky squared canonical correlations <code class="reqn">\rho(cx[,k],cy_i[,k])^2</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Hanafi &amp; Lafosse (2001) Generalisation de la regression lineaire simple pour analyser la dependance de K ensembles de variables avec un K+1 eme.  Revue de Statistique Appliquee vol.49, n.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
ca &lt;- concorcano(x,y,c(3,2,4),2)

</code></pre>

<hr>
<h2 id='concoreg'>Redundancy of sets yj by one set x</h2><span id='topic+concoreg'></span>

<h3>Description</h3>

<p>Regression of several subsets of variables Yj by another set X. SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concoreg(x, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concoreg_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concoreg_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concoreg_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concoreg_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code>matrix of the r explanatory components</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>is a <code class="reqn">q \times r</code> matrix of ky row blocks <code class="reqn">v_i</code> (<code class="reqn">q_i \times r</code>) of axes in Rqi relative to yi; <code class="reqn">v_i'*v_i = \mbox{Id}</code></p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>is a <code class="reqn">q \times r</code> matrix of axes in Rq relative to y; <code class="reqn">V'*V = \mbox{Id}</code></p>
</td></tr>
<tr><td><code>varexp</code></td>
<td>
<p>is a <code class="reqn">ky \times r</code> matrix; each column k contains ky explained variances <code class="reqn">\rho(cx[,k],y_i*v_i[,k])^2 \mbox{var}(y_i*v_i[,k])</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Lafosse R. &amp; Hanafi M.(1997) Concordance d'un tableau avec K tableaux: Definition de K+1 uples synthetiques. Revue de Statistique Appliquee vol.45,n.4.
</p>
<p>Chessel D. &amp; Hanafi M. (1996) Analyses de la Co-inertie de K nuages de points.  Revue de Statistique Appliquee vol.44, n.2. (this ACOM analysis of one multiset is obtained by the command : concoreg(Y,Y,py,r))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
co &lt;- concoreg(x,y,c(3,2,4),2)

</code></pre>

<hr>
<h2 id='concorgm'>Analyzing a set of partial links between Xi and Yj</h2><span id='topic+concorgm'></span>

<h3>Description</h3>

<p>Analyzing a set of partial links between Xi and Yj, SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorgm(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorgm_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorgm_+3A_px">px</code></td>
<td>
<p>A row vector which contains the numbers pi, i=1,...,kx, of the kx subsets xi of x : sum(pi)=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concorgm_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorgm_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorgm_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions rmax &lt;= min(min(px),min(py),n)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates 1+kx normed vectors: the vector <code>u[:,1]</code> of Rp associated to the ky vectors <code>vi[:,1]</code>'s of Rqi,
by maximizing <code>sum(cov((x)(u[,k]),(y_i)(v_i[,k]))^2)</code>, with 1+ky norm constraints on the axes.
A component <code>(x)(u[,k])</code> is associated to ky partial components <code>(yi)(vi)[,k]</code> and to a global component <code>y*V[,k]</code>.
<code>cov((x)(u[,k]),(y)(V[,k]))^2 = sum(cov((x)(u[,k]),(y_i)(v_i[,k]))^2)(y)(V[,k])</code> is a global component of the components <code>(yi)(vi[,k])</code>.
The second solution is obtained from the same criterion, but after replacing each yi by <code class="reqn">y_i-(y_i)(v_i[,1])(v_i[,1]')</code>.
And so on for the successive solutions 1,2,...,r.  The biggest number of solutions may be r=inf(n, p, qi), when the (x')(yi')(s)
are supposed with full rank; then rmax=min(c(min(py),n,p)).  For a set of r solutions, the matrix u'X'YV is diagonal and the
matrices u'X'Yjvj are triangular (good partition of the link by the solutions).
concor.m is the svdcp.m function applied to the matrix x'y.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of axes in <code>Rp</code> relative to <code>x; u^prime*u = Identity</code></p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>a <code>ky</code> times <code>r</code> matrix; each column <code>k</code> contains <code>ky</code> squared covariances <code class="reqn">\mbox{cov}((x)(u[,k]),(y_i)(v_i[,k]))^2</code>, the partial measures of link</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Kissita, Cazes, Hanafi &amp; Lafosse (2004) Deux methodes d'analyse factorielle du lien entre deux tableaux de variables partitionn?es. Revue de Statistique Appliqu?e, Vol 52, n. 3, 73-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cg &lt;- concorgm(x,c(2,3),y,c(3,2,4),2)
cg$cov2[1,1,]

</code></pre>

<hr>
<h2 id='concorgmcano'>Canonical analysis of subsets Yj with subsets Xi</h2><span id='topic+concorgmcano'></span>

<h3>Description</h3>

<p>Canonical analysis of subsets Yj with subsets Xi. Relative valuations by squared correlations of the proximities of subsets Xi with subsets Yj. SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorgmcano(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorgmcano_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorgmcano_+3A_px">px</code></td>
<td>
<p>The row vector which contains the numbers pi, i=1,...,kx, of the kx subsets xi of x : <code class="reqn">\sum_i p_i</code>=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concorgmcano_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorgmcano_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorgmcano_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions rmax &lt;= min(min(px),min(py),n)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the first solution, <code class="reqn">sum_i sum_j \mbox{rho2}(cx_i[,1],cy_j[,1])</code> is the optimized
criterion. The other solutions are calculated from the same criterion, but with
orthogonalities for having two by two zero correlated the canonical components defined for
each xi, and also for those defined for each yj.  Each solution associates kx canonical
components to ky canonical components.  When kx =1 (px=p), take <code>concorcano</code> function
This function uses the concorgm function
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>is a <code>n.kx</code> times  <code>r</code> matrix of kx row blocks cxi (n x r). Each row block contains r partial canonical components</p>
</td></tr>
<tr><td><code>cy</code></td>
<td>
<p>is a  <code>n.ky</code> times  <code>r</code> matrix of ky row blocks cyj (n x r). Each row block contains r partial canonical components</p>
</td></tr>
<tr><td><code>rho2</code></td>
<td>
<p>is a  <code>kx</code> time  <code>ky</code> tims  <code>r</code> array; for a fixed solution k, <code>rho2[,,k]</code> contains kxky squared correlations <code class="reqn">rho2(cx[n*(i-1)+1:n*i,k],cy[n*(j-1)+1:n*j,k])</code>, simultaneously calculated between all the yj with all the xi</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Kissita G., Analyse canonique generalisee avec tableau de reference generalisee. Thesis, Ceremade Paris 9 Dauphine (2003).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cc &lt;- concorgmcano(x,c(2,3),y,c(3,2,4),2)
cc$rho2[1,1,]

</code></pre>

<hr>
<h2 id='concorgmreg'>Regression of subsets Yj by subsets Xi</h2><span id='topic+concorgmreg'></span>

<h3>Description</h3>

<p>Regression of subsets Yj by subsets Xi for comparing all the explanatory-explained pairs (Xi,Yj). SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorgmreg(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorgmreg_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorgmreg_+3A_px">px</code></td>
<td>
<p>A row vector which contains the numbers pi, i = 1,...,kx, of the kx subsets xi of x : sum(pi)=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concorgmreg_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorgmreg_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorgmreg_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the first solution, <code class="reqn">\sum_i \sum_j \mbox{rho2}(cx_i[,1],y_j*v_j[,1])
\mbox{var}(y_j*v_j[,1])</code> is the optimized criterion. The second solution is
calculated from the same criterion, but with <code class="reqn">y_j-y_j*v_j[,1]*v_j[,1]'</code>
instead of the matrices yj and with orthogonalities for having two by
two zero correlated the explanatory components defined for each matrix
xi. And so on for the other solutions. One solution k associates kx
explanatory components (in <code>cx[,k]</code>) to ky explained components. When
kx =1 (px = p), take concoreg function
This function uses the concorgm function
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code>matrix of the r explanatory components</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>is a <code class="reqn">q \times r</code> matrix of ky row blocks <code class="reqn">v_i</code> (<code class="reqn">q_i \times r</code>) of axes in Rqi relative to yi; <code class="reqn">v_i'*v_i = \mbox{Id}</code></p>
</td></tr>
<tr><td><code>varexp</code></td>
<td>
<p>is a kx x ky x r array; for a fixed solution k, the matrix <code>varexp[,,k]</code> contains kxky explained variances obtained by a simultaneous regression of all the yj by all the xi, so the values <code class="reqn">\mbox{rho2}(cx[n*(i-1)+1:n*i,k],y_j*v_j[,k]) var(y_j*v_j[,k])</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Hanafi &amp; Lafosse (2004) Regression of a multi-set by another based on an extension of the SVD. COMPSTAT'2004 Symposium
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cr &lt;- concorgmreg(x,c(2,3),y,c(3,2,4),2)
cr$varexp[1,1,]

</code></pre>

<hr>
<h2 id='concors'>simultaneous  concorgm</h2><span id='topic+concors'></span>

<h3>Description</h3>

<p>concorgm with the set of r solutions simultaneously optimized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concors(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concors_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concors_+3A_px">px</code></td>
<td>
<p>A row vector which contains the numbers pi, i=1,...,kx, of the kx subsets xi of x : sum(pi)=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concors_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concors_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concors_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions rmax &lt;= min(min(px),min(py),n)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the svdbips function
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of axes in <code>Rp</code> relative to <code>x; u^prime*u = Identity</code></p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>a <code>ky</code> times <code>r</code> matrix; each column <code>k</code> contains <code>ky</code> squared covariances <code class="reqn">\mbox{cov}(x*u[,k],y_i*v_i[,k])^2</code>, the partial measures of link</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Lafosse R. &amp; Hanafi M.(1997) Concordance d'un tableau avec K tableaux: Definition de K+1 uples synthetiques. Revue de Statistique Appliquee vol.45,n.4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cs &lt;- concors(x,c(2,3),y,c(3,2,4),2)
cs$cov2[1,1,]

</code></pre>

<hr>
<h2 id='concorscano'>simultaneous concorgmcano</h2><span id='topic+concorscano'></span>

<h3>Description</h3>

<p>concorgmcano with the set of r solutions simultaneously optimized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorscano(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorscano_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorscano_+3A_px">px</code></td>
<td>
<p>A row vector which contains the numbers pi, i=1,...,kx, of the kx subsets xi of x : sum(pi)=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concorscano_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorscano_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorscano_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions rmax &lt;= min(min(px),min(py),n)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the concors function
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code> matrix of the r canonical components of x</p>
</td></tr>
<tr><td><code>cy</code></td>
<td>
<p>a <code>n.ky</code> times <code>r</code> matrix. The ky blocks cyi of the rows n*(i-1)+1 : n*i contain the r canonical components relative to Yi</p>
</td></tr>
<tr><td><code>cov2</code></td>
<td>
<p>a <code>ky</code> times <code>r</code> matrix; each column <code>k</code> contains <code>ky</code> squared covariances <code class="reqn">\mbox{cov}(x*u[,k],y_i*v_i[,k])^2</code>, the partial measures of link</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Hanafi &amp; Lafosse (2001) Generalisation de la regression lineaire simple pour analyser la dependance de K ensembles de variables avec un K+1 eme.  Revue de Statistique Appliquee vol.49, n.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
cca &lt;- concorscano(x,c(2,3),y,c(3,2,4),2)
cca$rho2[1,1,]

</code></pre>

<hr>
<h2 id='concorsreg'>Redundancy of sets yj by one set x</h2><span id='topic+concorsreg'></span>

<h3>Description</h3>

<p>Regression of several subsets of variables Yj by another set X. SUCCESSIVE SOLUTIONS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorsreg(x, px, y, py, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concorsreg_+3A_x">x</code></td>
<td>
<p>are the <code>n</code> times <code>p</code> and <code>n</code> times <code>q</code> matrices of <code>p</code> and <code>q</code> centered column</p>
</td></tr>
<tr><td><code id="concorsreg_+3A_px">px</code></td>
<td>
<p>The row vector which contains the numbers pi, i = 1,...,kx, of the kx subsets xi of x : <code class="reqn">\sum_i p_i</code>=sum(px)=p. px is the partition vector of x</p>
</td></tr>
<tr><td><code id="concorsreg_+3A_y">y</code></td>
<td>
<p>See <code>x</code></p>
</td></tr>
<tr><td><code id="concorsreg_+3A_py">py</code></td>
<td>
<p>The partition vector of y. A row vector containing the numbers <code>qi</code> for <code>i = 1,...,ky</code> of the <code>ky</code> subsets <code>yi</code> of <code>y : sum(qi)=sum(py)=q</code>.</p>
</td></tr>
<tr><td><code id="concorsreg_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>cx</code></td>
<td>
<p>a <code>n</code> times <code>r</code>matrix of the r explanatory components</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>is a <code class="reqn">q \times r</code> matrix of ky row blocks <code class="reqn">v_i</code> (<code class="reqn">q_i \times r</code>) of axes in Rqi relative to yi; <code class="reqn">v_i'*v_i = \mbox{Id}</code></p>
</td></tr>
<tr><td><code>varexp</code></td>
<td>
<p>is a <code class="reqn">ky \times r</code> matrix; each column k contains ky explained variances <code class="reqn">\rho(cx[,k],y_i*v_i[,k])^2 \mbox{var}(y_i*v_i[,k])</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(50),10,5);y &lt;- matrix(runif(90),10,9)
x &lt;- scale(x);y &lt;- scale(y)
crs &lt;- concorsreg(x,c(2,3),y,c(3,2,4),2)
crs$varexp[1,1,]

</code></pre>

<hr>
<h2 id='svdbip'>SVD for one bipartitioned matrix x</h2><span id='topic+svdbip'></span>

<h3>Description</h3>

<p>SVD for bipartitioned matrix x. r successive Solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdbip(x, K, H, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdbip_+3A_x">x</code></td>
<td>
<p>a <code>p</code> times <code>q</code> matrix</p>
</td></tr>
<tr><td><code id="svdbip_+3A_k">K</code></td>
<td>
<p>is a row vector which contains the numbers pk, k=1,...,kx, of the partition of x with kx row blocks : <code>sum(pk)=p</code></p>
</td></tr>
<tr><td><code id="svdbip_+3A_h">H</code></td>
<td>
<p>is a row vector which contains the numbers qh, h=1,...,ky, of the partition of x with ky column blocks : sum(qh)=q</p>
</td></tr>
<tr><td><code id="svdbip_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates kx+ky normed vectors: kx vectors <code>uk[:,1]</code>
of <code class="reqn">R^{p_k}</code> associated to ky vectors <code>vh[:,1]</code>'s of <code class="reqn">R^{q_h}</code>, by
maximizing <code class="reqn">\sum_k \sum_h (u_k[:,1]^prime*x_{kh}*v_h[:,1])^2</code>, with kx+ky
norm constraints. A value <code class="reqn">(u_k[,1]^prime*x_{kh}*v_h[,1])^2</code> measures the
relative link between <code class="reqn">R^{p_k}</code> and <code class="reqn">R^{q_h}</code> associated to the block xkh.
The second solution is obtained from the same criterion, but after
replacing each xhk by xkh-xkh<em>vh</em>vh'-uk<em>uk'xkh+uk</em>uk'xkh<em>vh</em>vh'.  And
so on for the successive solutions 1,2,...,r .  The biggest number of
solutions may be r=inf(pk,qh), when the xkh's are supposed with full
rank; then <code>rmax=min([min(K),min(H)])</code>.
When K=p (or H=q, with t(x)), svdcp function is better.  When H=q and
K=p, it is the usual svd (with squared singular values).
Convergence of algorithm may be not global. So the below proposed
initialisation of the algorithm may be not very suitable for some data
sets.  Several different random initialisations with normed vectors
might be considered and the best result then choosen.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of kx row blocks uk (pk x r); uk'*uk = Identity.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a <code>kx</code> times <code>ky</code> times <code>r</code> array; with r fixed, each matrix contains kxky values <code class="reqn">(u_h'*x_{kh}*v_k)^2</code>, the partial (squared) singular values relative to xkh.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Kissita G., Cazes P., Hanafi M. &amp; Lafosse (2004) Deux methodes d'analyse factorielle du lien entre deux tableaux de variables partitiones. Revue de Statistique Appliquee.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(200),10,20)
s &lt;- svdbip(x,c(3,4,3),c(5,15),3)

</code></pre>

<hr>
<h2 id='svdbip2'>SVD for bipartitioned matrix x</h2><span id='topic+svdbip2'></span>

<h3>Description</h3>

<p>SVD for bipartitioned matrix x. r successive Solutions. As SVDBIP, but with another algorithm and another initialisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdbip2(x, K, H, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdbip2_+3A_x">x</code></td>
<td>
<p>a <code>p</code> times <code>q</code> matrix</p>
</td></tr>
<tr><td><code id="svdbip2_+3A_k">K</code></td>
<td>
<p>is a row vector which contains the numbers pk, k=1,...,kx, of the partition of x with kx row blocks : <code>sum(pk)=p</code></p>
</td></tr>
<tr><td><code id="svdbip2_+3A_h">H</code></td>
<td>
<p>is a row vector which contains the numbers qh, h=1,...,ky, of the partition of x with ky column blocks : sum(qh)=q</p>
</td></tr>
<tr><td><code id="svdbip2_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates kx+ky normed vectors: kx vectors
<code>uk[:,1]</code> of Rpk associated to ky vectors <code>vh[,1]</code>'s of Rqh, by maximizing
<code class="reqn">\sum_k \sum_h (u_k[,1]'*x_{kh}*v_h[,1])^2</code>, with kx+ky norm
constraints.  A value <code class="reqn">(u_k[,1]'*x_{kh}*v_h[,1])^2</code> measures the
relative link between <code class="reqn">R^{p_k}</code> and <code class="reqn">R^{q_h}</code> associated to the
block xkh.
The second solution is obtained from the same criterion, but after
replacing each xhk by xkh-xkh<em>vh</em>vh'-uk<em>uk'xkh+uk</em>uk'xkh<em>vh</em>vh'.  And
so on for the successive solutions 1,2,...,r .  The biggest number of
solutions may be r=inf(pk,qh), when the xkh's are supposed with full
rank; then <code>rmax=min([min(K),min(H)])</code>.
When K=p (or H=q, with t(x)), svdcp function is better.  When H=q and
K=p, it is the usual svd (with squared singular values).
Convergence of algorithm may be not global. So the below proposed
initialisation of the algorithm may be not very suitable for some data
sets.  Several different random initialisations with normed vectors
might be considered and the best result then choosen
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of kx row blocks uk (pk x r); uk'*uk = Identity.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a <code>kx</code> times <code>ky</code> times <code>r</code> array; with r fixed, each matrix contains kxky values <code class="reqn">(u_h'*x_{kh}*v_k)^2</code>, the partial (squared) singular values relative to xkh.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Kissita G., Analyse canonique generalisee avec tableau de reference generalisee. Thesis, Ceremade Paris 9 Dauphine (2003)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(200),10,20)
s2 &lt;- svdbip2(x,c(3,4,3),c(5,5,10),3);s2$s2
s1 &lt;- svdbip(x,c(3,4,3),c(5,5,10),3);s1$s2

</code></pre>

<hr>
<h2 id='svdbips'>SVD for bipartitioned matrix x</h2><span id='topic+svdbips'></span>

<h3>Description</h3>

<p>SVD for bipartitioned matrix x. SIMULTANEOUS SOLUTIONS. (&quot;simultaneous svdbip&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdbips(x, K, H, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdbips_+3A_x">x</code></td>
<td>
<p>a <code>p</code> times <code>q</code> matrix</p>
</td></tr>
<tr><td><code id="svdbips_+3A_k">K</code></td>
<td>
<p>is a row vector which contains the numbers pk, k=1,...,kx, of the partition of x with kx row blocks : <code>sum(pk)=p</code></p>
</td></tr>
<tr><td><code id="svdbips_+3A_h">H</code></td>
<td>
<p>is a row vector which contains the numbers qh, h=1,...,ky, of the partition of x with ky column blocks : sum(qh)=q</p>
</td></tr>
<tr><td><code id="svdbips_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One set of r solutions is calculated by maximizing <code class="reqn">\sum_i \sum_k \sum_h
(u_k[,i]'*x_{kh}*v_h[,i])^2</code>, with kx+ky orthonormality constraints (for
each uk and each vh).  For each fixed r value, the solution is totally
new (does'nt consist to complete a previous calculus of one set of r-1
solutions).  <code>rmax=min([min(K),min(H)])</code>.  When r=1, it is svdbip (thus
it is svdcp when r=1 and kx=1).
Convergence of algorithm may be not global. So the below proposed
initialisation of the algorithm may be not very suitable for some data
sets.  Several different random initialisations with normed vectors
might be considered and the best result then choosen....
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of kx row blocks uk (pk x r); uk'*uk = Identity.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a <code>kx</code> times <code>ky</code> times <code>r</code> array; with r fixed, each matrix contains kxky values <code class="reqn">(u_h'*x_{kh}*v_k)^2</code>, the partial (squared) singular values relative to xkh.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Lafosse R. &amp; Ten Berge J. A simultaneous CONCOR method for the analysis of two partitioned matrices. submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(200),10,20)
s1 &lt;- svdbip(x,c(3,4,3),c(5,5,10),2);sum(sum(sum(s1$s2)))
ss &lt;- svdbips(x,c(3,4,3),c(5,5,10),2);sum(sum(sum(ss$s2)))

</code></pre>

<hr>
<h2 id='svdcp'>SVD for a Column Partitioned matrix x</h2><span id='topic+svdcp'></span>

<h3>Description</h3>

<p>SVD for a Column Partitioned matrix x. r global successive solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdcp(x, H, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdcp_+3A_x">x</code></td>
<td>
<p>a <code>p</code> times <code>q</code> matrix</p>
</td></tr>
<tr><td><code id="svdcp_+3A_h">H</code></td>
<td>
<p>is a row vector which contains the numbers qh, h=1,...,ky, of the partition of x with ky column blocks : sum(qh)=q</p>
</td></tr>
<tr><td><code id="svdcp_+3A_r">r</code></td>
<td>
<p>The number of wanted successive solutions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first solution calculates 1+kx normed vectors: the vector <code>u[,1]</code> of
<code class="reqn">R^p</code> associated to the kx vectors <code>vi[,1]</code>'s of <code class="reqn">R^{q_i}</code>. by maximizing
<code class="reqn">\sum_i (u[,1]'*x_i*v_i[,1])^2</code>, with 1+kx norm constraints.  A
value <code class="reqn">(u[,1]'*x_i*v_i[,1])^2</code> measures the relative link between
<code class="reqn">R^p</code> and <code class="reqn">R^{q_i}</code> associated to xi. It corresponds to a partial squared
singular value notion, since <code class="reqn">\sum_i (u[,1]'*x_i*v_i[,1])^2=s^2</code>,
where s is the usual first singular value of x.
The second solution is obtained from the same criterion, but after
replacing each xi by <code>xi-xi*vi[,1]*vi[,1]^prime</code>.  And so on for the
successive solutions 1,2,...,r .  The biggest number of solutions may
be r=inf(p,qi), when the xi's are supposed with full rank; then
<code>rmax=min([min(H),p])</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> with following components:
</p>
<table role = "presentation">
<tr><td><code>u</code></td>
<td>
<p>a <code>p</code> times <code>r</code> matrix of kx row blocks uk (pk x r); uk'*uk = Identity.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a <code>q</code> times <code>r</code> matrix of <code>ky</code> row blocks <code>vi (qi x r)</code> of axes in <code>Rqi</code> relative to <code>yi; vi^prime*vi = Identity</code></p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a <code>kx</code> times <code>ky</code> times <code>r</code> array; with r fixed, each matrix contains kxky values <code class="reqn">(u_h'*x_{kh}*v_k)^2</code>, the partial (squared) singular values relative to xkh.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Lafosse, R.
</p>


<h3>References</h3>

<p>Lafosse R. &amp; Hanafi M.(1997) Concordance d'un tableau avec K tableaux: Definition de K+1 uples synthetiques. Revue de Statistique Appliquee vol.45,n.4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(200),10,20)
s &lt;- svdcp(x,c(5,5,10),1)
ss &lt;- svd(x);ss$d[1]^2
sum(s$s2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
