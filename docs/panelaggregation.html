<!DOCTYPE html><html><head><title>Help for package panelaggregation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {panelaggregation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#btsdemo'><p>Randomly Generated Panel Dataset</p></a></li>
<li><a href='#computeBalance'><p>Compute Balances from a Item Shares</p></a></li>
<li><a href='#computeShares'><p>Compute Weighted Shares By Group</p></a></li>
<li><a href='#computeWeightedMeans'><p>Compute Weighted Mean by Group</p></a></li>
<li><a href='#doUniqueCJ'><p>Performs a Cross Join of Unique combinations</p></a></li>
<li><a href='#extractTimeSeries'><p>Extract a Time Series from a Data.table</p></a></li>
<li><a href='#joinDataTables'><p>Joins two data.tables based on keys</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Aggregate Longitudinal Survey Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Aggregate Business Tendency Survey Data (and other qualitative
    surveys) to time series at various aggregation levels. Run aggregation of
    survey data in a speedy, re-traceable and a easily deployable way.
    Aggregation is substantially accelerated by use of data.table.
    This package intends to provide an interface that is less general and abstract than data.table but rather geared towards
    survey researchers.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Bannert &lt;bannert@kof.ethz.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), data.table (&ge; 1.9.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-06 15:52:59 UTC; mbannert</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Bannert [aut, cre],
  Gabriel Bucur [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-07 02:40:46</td>
</tr>
</table>
<hr>
<h2 id='btsdemo'>Randomly Generated Panel Dataset</h2><span id='topic+btsdemo'></span>

<h3>Description</h3>

<p>This data was created by simulation to mimmick a firm level dataset stemming from business tendency surveys.
The data was simulated because of privacy concerns with micro level firm data. For convenience the dataset 
contains two different date notations. Also 5 qualitative 3-item questions are included. Business tendency survey data
is often weighted with company size represented by the number of employees. Thus the weight column is quantitative and
its distribution is somewhat (!) reasonable with respect to the distribution of employees in a typical firm sample.
</p>


<h3>Format</h3>

<p>A data frame with 27000 rows and 13 variables</p>


<h3>Details</h3>


<ul>
<li><p> uid unique company identifier
</p>
</li>
<li><p> year numeric year column
</p>
</li>
<li><p> weight quantitative weight
</p>
</li>
<li><p> question\_1
</p>
</li>
<li><p> question\_2
</p>
</li>
<li><p> question\_3
</p>
</li>
<li><p> question\_4
</p>
</li>
<li><p> question\_5
</p>
</li>
<li><p> group group to mimmick different sectors / branches of trade
</p>
</li>
<li><p> altGroup another alternative grouping columns
</p>
</li>
<li><p> sClass a column denoting discrete size classes small (S), medium (M) and large (L)
</p>
</li>
<li><p> date\_qtrly quarterly dates stored in a single column. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthias Bannert
</p>


<h3>Source</h3>

<p>Randomly generated in R using the sample generator from https://github.com/mbannert/gateveys/blob/master/R/gateveys.R
</p>

<hr>
<h2 id='computeBalance'>Compute Balances from a Item Shares</h2><span id='topic+computeBalance'></span>

<h3>Description</h3>

<p>This function computes balances (i.e. positive - negative items), from item shares
stored in a wide format data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeBalance(data_table, multipliers = list(item_pos = 1, item_eq = 0,
  item_neg = -1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeBalance_+3A_data_table">data_table</code></td>
<td>
<p>a data.table in wide format containing item</p>
</td></tr>
<tr><td><code id="computeBalance_+3A_multipliers">multipliers</code></td>
<td>
<p>list containing multipliers of items, assigned by item and column names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucu
</p>

<hr>
<h2 id='computeShares'>Compute Weighted Shares By Group</h2><span id='topic+computeShares'></span>

<h3>Description</h3>

<p>This function computes weighted shares from a data.table. 
computeShares is performance optimized and designed to
work well in bulk operations. The function returns a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeShares(data_table, variable, weight, by, wide = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeShares_+3A_data_table">data_table</code></td>
<td>
<p>a data.table</p>
</td></tr>
<tr><td><code id="computeShares_+3A_variable">variable</code></td>
<td>
<p>character name of the variable to focus on. The variable must be in the data.table</p>
</td></tr>
<tr><td><code id="computeShares_+3A_weight">weight</code></td>
<td>
<p>character name of the data.table column that contains a weight.</p>
</td></tr>
<tr><td><code id="computeShares_+3A_by">by</code></td>
<td>
<p>character vector of the columns to group by</p>
</td></tr>
<tr><td><code id="computeShares_+3A_wide">wide</code></td>
<td>
<p>logical if true the result is returned in wide format dcast.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucur, Oliver Mueller
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO: add new weight columns to BTS demo
# load library and dataset
library(panelaggregation)
data(btsdemo)
head(btsdemo)
# adapt the levels to positive, equal and negative
# in order to suit the naming defaults. other levels work too, 
# but you'd need to specify multipliers in computeBalance then
levels(btsdemo$question_1) &lt;- c("pos","eq","neg")

# compute the weighted shares and display store in wide format 
# to get a basis for further steps
level1 &lt;- computeShares(btsdemo,"question_1","weight", 
                        by = c("date_qtrly","group", "altGroup", "sClass"))

# compute balance, don't have to do much here, because
# (pos, eq, neg) is the default for the possible answers
level1_wbalance &lt;- computeBalance(level1)

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 1 aggregation.
ts1 &lt;- extractTimeSeries(level1_wbalance,
                         "date_qtrly",
                         list(group = "C", altGroup = "a", sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts1
# Plot a standard R ts using the plot method for ts
plot(ts1, main = attributes(ts1)$ts_key)

# Add weight column to the aggregated results
# In order to join the tables, we need to know what weight to assign to each row.
# This is done by having via a common key, for example c('group', 'altGroup').
# In this example we would assign a different weight for each 
#   c('group', 'altGroup') combination (e.g. c('A', 'a')).
btsweight1 &lt;- btsdemo[, list(weight = sum(weight)), by = 'group']
btsagg1 &lt;- joinDataTables(level1_wbalance, btsweight1, 'group')

# Compute second level aggregation, this time on fewer columns and using a different set of weights.
level2_balance &lt;- computeWeightedMeans(btsagg1, c('item_pos', 'item_eq', 'item_neg', 'balance'), 
                                       'weight', c("date_qtrly","group", "sClass"))

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 2 aggregation.
ts2 &lt;- extractTimeSeries(level2_balance,
                         "date_qtrly",
                         list(group = "C", sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts2
# Plot a standard R ts using the plot method for ts
plot(ts2, main = attributes(ts2)$ts_key)

# Add weight column to the aggregated results
# In order to join the tables, we need to know what weight to assign to each row.
# This is done by having via a common key, for example c('group', 'altGroup').
# In this example we would assign a different weight for each 
#   c('group', 'altGroup') combination (e.g. c('A', 'a')).
btsweight2 &lt;- btsdemo[, list(weight = sum(weight)), by = 'sClass']
btsagg2 &lt;- joinDataTables(level2_balance, btsweight2, 'sClass')

# Compute third level of aggregation, on the whole sector, using yet another set of weights.
level3_balance &lt;- computeWeightedMeans(btsagg2, 'balance', 'weight', c("date_qtrly", "sClass"))

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 2 aggregation.
ts3 &lt;- extractTimeSeries(level3_balance,
                         "date_qtrly",
                         list(sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts3
# Plot a standard R ts using the plot method for ts
plot(ts3, main = attributes(ts3)$ts_key)
</code></pre>

<hr>
<h2 id='computeWeightedMeans'>Compute Weighted Mean by Group</h2><span id='topic+computeWeightedMeans'></span>

<h3>Description</h3>

<p>This function computes the weighted mean of variable groups from a data.table. 
computeWeightedMean is performance optimized and designed to
work well in bulk operations. The function returns a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeWeightedMeans(data_table, variables, weight, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeWeightedMeans_+3A_data_table">data_table</code></td>
<td>
<p>a data.table</p>
</td></tr>
<tr><td><code id="computeWeightedMeans_+3A_variables">variables</code></td>
<td>
<p>character name of the variable(s) to focus on. The variables must be in the data.table</p>
</td></tr>
<tr><td><code id="computeWeightedMeans_+3A_weight">weight</code></td>
<td>
<p>character name of the data.table column that contains a weight.</p>
</td></tr>
<tr><td><code id="computeWeightedMeans_+3A_by">by</code></td>
<td>
<p>character vector of the columns to group by</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucur
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO: add new weight columns to BTS demo
# load library and dataset
library(panelaggregation)
data(btsdemo)
head(btsdemo)
# adapt the levels to positive, equal and negative
# in order to suit the naming defaults. other levels work too, 
# but you'd need to specify multipliers in computeBalance then
levels(btsdemo$question_1) &lt;- c("pos","eq","neg")

# compute the weighted shares and display store in wide format 
# to get a basis for further steps
level1 &lt;- computeShares(btsdemo,"question_1","weight", 
                        by = c("date_qtrly","group", "altGroup", "sClass"))

# compute balance, don't have to do much here, because
# (pos, eq, neg) is the default for the possible answers
level1_wbalance &lt;- computeBalance(level1)

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 1 aggregation.
ts1 &lt;- extractTimeSeries(level1_wbalance,
                         "date_qtrly",
                         list(group = "C", altGroup = "a", sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts1
# Plot a standard R ts using the plot method for ts
plot(ts1, main = attributes(ts1)$ts_key)

# Add weight column to the aggregated results
# In order to join the tables, we need to know what weight to assign to each row.
# This is done by having via a common key, for example c('group', 'altGroup').
# In this example we would assign a different weight for each 
#   c('group', 'altGroup') combination (e.g. c('A', 'a')).
btsweight1 &lt;- btsdemo[, list(weight = sum(weight)), by = 'group']
btsagg1 &lt;- joinDataTables(level1_wbalance, btsweight1, 'group')

# Compute second level aggregation, this time on fewer columns and using a different set of weights.
level2_balance &lt;- computeWeightedMeans(btsagg1, c('item_pos', 'item_eq', 'item_neg', 'balance'), 
                                       'weight', c("date_qtrly","group", "sClass"))

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 2 aggregation.
ts2 &lt;- extractTimeSeries(level2_balance,
                         "date_qtrly",
                         list(group = "C", sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts2
# Plot a standard R ts using the plot method for ts
plot(ts2, main = attributes(ts2)$ts_key)

# Add weight column to the aggregated results
# In order to join the tables, we need to know what weight to assign to each row.
# This is done by having via a common key, for example c('group', 'altGroup').
# In this example we would assign a different weight for each 
#   c('group', 'altGroup') combination (e.g. c('A', 'a')).
btsweight2 &lt;- btsdemo[, list(weight = sum(weight)), by = 'sClass']
btsagg2 &lt;- joinDataTables(level2_balance, btsweight2, 'sClass')

# Compute third level of aggregation, on the whole sector, using yet another set of weights.
level3_balance &lt;- computeWeightedMeans(btsagg2, 'balance', 'weight', c("date_qtrly", "sClass"))

# Select a particular grouping combination and a timeseries that 
# should be extracted from the level 2 aggregation.
ts3 &lt;- extractTimeSeries(level3_balance,
                         "date_qtrly",
                         list(sClass = "S"),
                         freq = 4,
                         item = "balance",
                         variable = "question_1")
ts3
# Plot a standard R ts using the plot method for ts
plot(ts3, main = attributes(ts3)$ts_key)
</code></pre>

<hr>
<h2 id='doUniqueCJ'>Performs a Cross Join of Unique combinations</h2><span id='topic+doUniqueCJ'></span>

<h3>Description</h3>

<p>This function makes use of <code><a href="data.table.html#topic+CJ">CJ</a></code> function of the data.table package to perform a
cross join. The function makes sure that the combinations are unique and removes NAs before
joining. doUniqueCJ is rather not used as a standalone function but inside <code><a href="#topic+computeShares">computeShares</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doUniqueCJ(dt, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doUniqueCJ_+3A_dt">dt</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="doUniqueCJ_+3A_cols">cols</code></td>
<td>
<p>character vector that denotes names of relevant columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucur
</p>

<hr>
<h2 id='extractTimeSeries'>Extract a Time Series from a Data.table</h2><span id='topic+extractTimeSeries'></span>

<h3>Description</h3>

<p>This function extracts time series from data.table columns and returns object of class ts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTimeSeries(data_table, time_column, group_list, freq, item, variable,
  prefix = "CH.KOF.IND")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTimeSeries_+3A_data_table">data_table</code></td>
<td>
<p>a data.table</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_time_column">time_column</code></td>
<td>
<p>character name of the column which contains the time index</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_group_list">group_list</code></td>
<td>
<p>list or NULL</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_freq">freq</code></td>
<td>
<p>integer value either 4 denoting quarterly frequency or 12 denoting quarterly frequency</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_item">item</code></td>
<td>
<p>character name of the column which contains the item
that is extracted from the data.table</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_variable">variable</code></td>
<td>
<p>character name of the variable selected</p>
</td></tr>
<tr><td><code id="extractTimeSeries_+3A_prefix">prefix</code></td>
<td>
<p>character prefix attached to the dynamically generated key string to identify the time series. Recommend key format:
ISOcountry.provider.source.aggregationLevel.selectedGroup.variable.item</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucur
</p>

<hr>
<h2 id='joinDataTables'>Joins two data.tables based on keys</h2><span id='topic+joinDataTables'></span>

<h3>Description</h3>

<p>This function joins two data.table objects, given a common key, which can have different names in the two tables.
In the latter case, the sequence of the names is crucial. Make sure that the key columns match exactly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinDataTables(dt_1, dt_2, key_1, key_2 = key_1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinDataTables_+3A_dt_1">dt_1</code></td>
<td>
<p>first data.table</p>
</td></tr>
<tr><td><code id="joinDataTables_+3A_dt_2">dt_2</code></td>
<td>
<p>second data.table</p>
</td></tr>
<tr><td><code id="joinDataTables_+3A_key_1">key_1</code></td>
<td>
<p>character vector of key columns for first data.table</p>
</td></tr>
<tr><td><code id="joinDataTables_+3A_key_2">key_2</code></td>
<td>
<p>character vector of key columns for second data.table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>joined data.table
</p>


<h3>Author(s)</h3>

<p>Matthias Bannert, Gabriel Bucur
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
