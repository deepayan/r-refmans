<!DOCTYPE html><html><head><title>Help for package r2glmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {r2glmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_sgv'><p>Compute the standardized generalized variance (SGV) of a blocked diagonal matrix.</p></a></li>
<li><a href='#cmp_R2'><p>Compute R2 with a specified C matrix</p></a></li>
<li><a href='#glmPQL'><p>Compute PQL estimates for fixed effects from a generalized linear model.</p></a></li>
<li><a href='#is.CompSym'><p>Checks if a matrix is Compound Symmetric.</p></a></li>
<li><a href='#make.partial.C'><p>Generate partial contrast matrices</p></a></li>
<li><a href='#plot.R2'><p>Visualize standardized effect sizes and model R squared</p></a></li>
<li><a href='#pqlmer'><p>pqlmer</p></a></li>
<li><a href='#print.R2'><p>Print the contents of an R2 object</p></a></li>
<li><a href='#r2beta'><p>r2beta Compute R Squared for Mixed Models</p></a></li>
<li><a href='#r2dt'><p>R Squared Difference Test (R2DT). Test for a statistically significant difference in generalized explained variance between two candidate models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computes R Squared for Mixed (Multilevel) Models</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-08-04</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The model R squared and semi-partial R squared for the linear and
    generalized linear mixed model (LMM and GLMM) are computed with confidence
    limits. The R squared measure from Edwards et.al (2008) &lt;<a href="https://doi.org/10.1002%2Fsim.3429">doi:10.1002/sim.3429</a>&gt;
    is extended to the GLMM using penalized quasi-likelihood (PQL) estimation
    (see Jaeger et al. 2016 &lt;<a href="https://doi.org/10.1080%2F02664763.2016.1193725">doi:10.1080/02664763.2016.1193725</a>&gt;). Three methods
    of computation are provided and described as follows. First, The
    Kenward-Roger approach. Due to some inconsistency between the 'pbkrtest'
    package and the 'glmmPQL' function, the Kenward-Roger approach in the
    'r2glmm' package is limited to the LMM. Second, The method introduced
    by Nakagawa and Schielzeth (2013) &lt;<a href="https://doi.org/10.1111%2Fj.2041-210x.2012.00261.x">doi:10.1111/j.2041-210x.2012.00261.x</a>&gt;
    and later extended by Johnson (2014) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12225">doi:10.1111/2041-210X.12225</a>&gt;.
    The 'r2glmm' package only computes marginal R squared for the LMM and does
    not generalize the statistic to the GLMM; however, confidence limits and
    semi-partial R squared for fixed effects are useful additions. Lastly, an
    approach using standardized generalized variance (SGV) can be used for
    covariance model selection. Package installation instructions can be found
    in the readme file.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, lmerTest, Matrix, pbkrtest, ggplot2, afex, stats, MASS,
gridExtra, grid, data.table, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4, nlme, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bcjaeger/r2glmm">https://github.com/bcjaeger/r2glmm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bcjaeger/r2glmm/issues">https://github.com/bcjaeger/r2glmm/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-08-05 00:26:41 UTC; Byron</td>
</tr>
<tr>
<td>Author:</td>
<td>Byron Jaeger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Byron Jaeger &lt;byron.jaeger@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-08-05 10:26:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_sgv'>Compute the standardized generalized variance (SGV) of a blocked diagonal matrix.</h2><span id='topic+calc_sgv'></span>

<h3>Description</h3>

<p>Compute the standardized generalized variance (SGV) of a blocked diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sgv(nblocks = NULL, blksizes = NULL, vmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sgv_+3A_nblocks">nblocks</code></td>
<td>
<p>Number of blocks in the matrix.</p>
</td></tr>
<tr><td><code id="calc_sgv_+3A_blksizes">blksizes</code></td>
<td>
<p>vector of block sizes</p>
</td></tr>
<tr><td><code id="calc_sgv_+3A_vmat">vmat</code></td>
<td>
<p>The blocked covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SGV of the covariance matrix <code>vmat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
v1 = matrix(c(1,0.5,0.5,1), nrow = 2)
v2 = matrix(c(1,0.2,0.1,0.2,1,0.3,0.1,0.3,1), nrow = 3)
v3 = matrix(c(1,0.1,0.1,0.1,1,0.2,0.1,0.2,1), nrow = 3)
calc_sgv(nblocks = 3, blksizes = c(2,3,3), vmat = Matrix::bdiag(v1,v2,v3))
</code></pre>

<hr>
<h2 id='cmp_R2'>Compute R2 with a specified C matrix</h2><span id='topic+cmp_R2'></span>

<h3>Description</h3>

<p>Compute R2 with a specified C matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmp_R2(c, x, SigHat, beta, method, obsperclust = NULL, nclusts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmp_R2_+3A_c">c</code></td>
<td>
<p>Contrast matrix for fixed effects</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_x">x</code></td>
<td>
<p>Fixed effects design matrix</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_sighat">SigHat</code></td>
<td>
<p>estimated model covariance (matrix or scalar)</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_beta">beta</code></td>
<td>
<p>fixed effects estimates</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_method">method</code></td>
<td>
<p>the method for computing r2beta</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_obsperclust">obsperclust</code></td>
<td>
<p>number of observations per cluster (i.e. subject)</p>
</td></tr>
<tr><td><code id="cmp_R2_+3A_nclusts">nclusts</code></td>
<td>
<p>number of clusters (i.e. subjects)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the Wald statistic (ncp), approximate Wald F
statistic (F), numerator degrees of freedom (v1), denominator degrees
of freedom (v2), and the specified r squared value (Rsq)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
library(lme4)
library(mgcv)
lmemod = lme(distance ~ age*Sex, random = ~1|Subject, data = Orthodont)
X = model.matrix(lmemod, data = Orthodont)
SigHat = extract.lme.cov(lmemod, data = Orthodont)
beta = fixef(lmemod)
p = length(beta)
obsperclust = as.numeric(table(lmemod$data[,'Subject']))
nclusts = length(obsperclust)
C = cbind(rep(0, p-1),diag(p-1))
partial.c = make.partial.C(p-1,p,2)

cmp_R2(c=C, x=X, SigHat=SigHat, beta=beta, obsperclust = obsperclust,
nclusts = nclusts, method = 'sgv')
cmp_R2(c=partial.c, x=X, SigHat=SigHat, beta=beta, obsperclust = obsperclust,
nclusts = nclusts, method = 'sgv')
</code></pre>

<hr>
<h2 id='glmPQL'>Compute PQL estimates for fixed effects from a generalized linear model.</h2><span id='topic+glmPQL'></span>

<h3>Description</h3>

<p>Compute PQL estimates for fixed effects from a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmPQL(glm.mod, niter = 20, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmPQL_+3A_glm.mod">glm.mod</code></td>
<td>
<p>a generalized linear model fitted with the glm function.</p>
</td></tr>
<tr><td><code id="glmPQL_+3A_niter">niter</code></td>
<td>
<p>maximum number of iterations allowed in the PQL algorithm.</p>
</td></tr>
<tr><td><code id="glmPQL_+3A_data">data</code></td>
<td>
<p>The data used by the fitted model. This argument is required
for models with special expressions in their formula, such as
offset, log, cbind(sucesses, trials), etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A glmPQL object (i.e. a linear model using pseudo outcomes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the datasets package for example code
library(datasets)
library(dplyr)

# We'll model the number of world changing discoveries per year for the
# last 100 years as a poisson outcome. First, we set up the data

dat = data.frame(discoveries) %&gt;% mutate(year = 1:length(discoveries))

# Fit the GLM with a poisson link function
mod &lt;- glm(discoveries~year+I(year^2), family = 'poisson', data = dat)

# Find PQL estimates using the original GLM
mod.pql = glmPQL(mod)

# Note that the PQL model yields a higher R Squared statistic
# than the fit of a strictly linear model. This is attributed
# to correctly modelling the distribution of outcomes and then
# linearizing the model to measure goodness of fit, rather than
# simply fitting a linear model

summary(mod.pql)
summary(linfit &lt;- lm(discoveries~year+I(year^2), data = dat))

r2beta(mod.pql)
r2beta(linfit)

</code></pre>

<hr>
<h2 id='is.CompSym'>Checks if a matrix is Compound Symmetric.</h2><span id='topic+is.CompSym'></span>

<h3>Description</h3>

<p>Checks if a matrix is Compound Symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.CompSym(mat, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.CompSym_+3A_mat">mat</code></td>
<td>
<p>The matrix to be tested.</p>
</td></tr>
<tr><td><code id="is.CompSym_+3A_tol">tol</code></td>
<td>
<p>a number indicating the smallest acceptable difference between off diagonal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if the matrix is compound symmetric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gcmat &lt;- matrix(c(1,0.2,0.1,0.2,1,0.3,0.1,0.3,1), nrow = 3)
csmat &lt;- matrix(c(1,0.2,0.2,0.2,1,0.2,0.2,0.2,1), nrow = 3)
is.CompSym(csmat)
</code></pre>

<hr>
<h2 id='make.partial.C'>Generate partial contrast matrices</h2><span id='topic+make.partial.C'></span>

<h3>Description</h3>

<p>Generate partial contrast matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.partial.C(rows, cols, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.partial.C_+3A_rows">rows</code></td>
<td>
<p>Number of rows in the contrast matrix</p>
</td></tr>
<tr><td><code id="make.partial.C_+3A_cols">cols</code></td>
<td>
<p>Number of columns in the contrast matrix</p>
</td></tr>
<tr><td><code id="make.partial.C_+3A_index">index</code></td>
<td>
<p>A number corresponding to the position of the fixed effect
in the vector of fixed effect parameter estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast matrix designed to test the fixed effect
corresponding to <code>index</code> in the vector of fixed effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make.partial.C(4, 5, 2)
make.partial.C(4, 5, 3)
make.partial.C(4, 5, 2:4)
</code></pre>

<hr>
<h2 id='plot.R2'>Visualize standardized effect sizes and model R squared</h2><span id='topic+plot.R2'></span>

<h3>Description</h3>

<p>Visualize standardized effect sizes and model R squared
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'R2'
plot(x, y = NULL, txtsize = 10, maxcov = 3, r2labs = NULL,
  r2mthd = "sgv", cor = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.R2_+3A_x">x</code></td>
<td>
<p>An R2 object from the r2beta function.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_y">y</code></td>
<td>
<p>An R2 object from the r2beta function.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_txtsize">txtsize</code></td>
<td>
<p>The text size of the axis labels.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_maxcov">maxcov</code></td>
<td>
<p>Maximum number of covariates to include in the semi-partial plots.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_r2labs">r2labs</code></td>
<td>
<p>a character vector containing labels for the models. The labels are printed as subscripts on a covariance model matrix.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_r2mthd">r2mthd</code></td>
<td>
<p>The method used to compute R2</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_cor">cor</code></td>
<td>
<p>An argument to be passed to the r2dt function. Only relevant if comparing two R2 objects.</p>
</td></tr>
<tr><td><code id="plot.R2_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A visual representation of the model and semi-partial R squared
from the r2 object provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
library(r2glmm)

data(Orthodont)

# Linear mixed model
lmemod = lme(distance ~ age*Sex, random = ~1|Subject, data = Orthodont)

r2 = r2beta(model=lmemod,partial=TRUE,method='sgv')

plot(x=r2)
</code></pre>

<hr>
<h2 id='pqlmer'>pqlmer</h2><span id='topic+pqlmer'></span>

<h3>Description</h3>

<p>Fit a GLMM model with multivariate normal random effects using Penalized Quasi-Likelihood for mermod objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pqlmer(formula, family, data, niter = 40, verbose = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pqlmer_+3A_formula">formula</code></td>
<td>
<p>The lme4 model formula.</p>
</td></tr>
<tr><td><code id="pqlmer_+3A_family">family</code></td>
<td>
<p>a family function of the error distribution and link function to be used in the model.</p>
</td></tr>
<tr><td><code id="pqlmer_+3A_data">data</code></td>
<td>
<p>the dataframe containing the variables in the model.</p>
</td></tr>
<tr><td><code id="pqlmer_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations to perform.</p>
</td></tr>
<tr><td><code id="pqlmer_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, iterations are printed to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pseudo linear mixed model of class &quot;lme&quot; .
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+glmmPQL">glmmPQL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare lmer PQL with lme PQL

library(MASS)

lmePQL = glmmPQL(y ~ trt + week + I(week &gt; 2), random = ~ 1 | ID,
                  family = binomial, data = bacteria,
                  verbose = FALSE)

merPQL= pqlmer(y ~ trt + week + I(week &gt; 2) + (1 | ID),
               family = binomial, data = bacteria,
               verbose = FALSE)

summary(lmePQL)
summary(merPQL)
</code></pre>

<hr>
<h2 id='print.R2'>Print the contents of an R2 object</h2><span id='topic+print.R2'></span>

<h3>Description</h3>

<p>Print the contents of an R2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'R2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.R2_+3A_x">x</code></td>
<td>
<p>an object of class R2</p>
</td></tr>
<tr><td><code id="print.R2_+3A_...">...</code></td>
<td>
<p>other arguments passed to the print function.</p>
</td></tr>
</table>

<hr>
<h2 id='r2beta'>r2beta Compute R Squared for Mixed Models</h2><span id='topic+r2beta'></span>

<h3>Description</h3>

<p>Computes coefficient of determination (R squared) from
edwards et al., 2008 and the generalized R squared from Jaeger et al., 2016.
Currently implemented for linear mixed models with
<code><a href="lmerTest.html#topic+lmer">lmer</a></code> and <code><a href="nlme.html#topic+lme">lme</a></code> objects. For
generalized linear mixed models, only <code><a href="MASS.html#topic+glmmPQL">glmmPQL</a></code> are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2beta(model, partial = TRUE, method = "sgv", data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2beta_+3A_model">model</code></td>
<td>
<p>a fitted mermod, lme, or glmmPQL model.</p>
</td></tr>
<tr><td><code id="r2beta_+3A_partial">partial</code></td>
<td>
<p>if TRUE, semi-partial R squared are calculated for each
fixed effect in the mixed model.</p>
</td></tr>
<tr><td><code id="r2beta_+3A_method">method</code></td>
<td>
<p>Specifies the method of computation for R squared beta:
if <code>method</code> = 'sgv' then the standardized generalized variance
approach is applied. This method is recommended for covariance model
selection.
if <code>method</code> = 'kr', then the Kenward Roger approach is applied.
This option is only available for <code><a href="nlme.html#topic+lme">lme</a></code> models.
if <code>method</code> = 'nsj',then the Nakagawa and Schielzeth approach
is applied. This option is available for
<code><a href="lmerTest.html#topic+lmer">lmer</a></code> and <code><a href="nlme.html#topic+lme">lme</a></code> objects.
if <code>method</code> = 'lm', the classical R squared from the
linear model is computed. This method should only be used
on glm and lm object.</p>
</td></tr>
<tr><td><code id="r2beta_+3A_data">data</code></td>
<td>
<p>The data used by the fitted model. This argument is required
for models with special expressions in their formula, such as
offset, log, cbind(sucesses, trials), etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the model F statistic, numerator
and denominator degrees of freedom, non-centrality parameter,
and R squared statistic with 95
If partial = TRUE, then the dataframe also contains partial R
squared statistics for all fixed effects in the model.
</p>


<h3>References</h3>

<p>Edwards, Lloyd J., et al. &quot;An R2 statistic for fixed effects in
the linear mixed model.&quot; Statistics in medicine 27.29 (2008): 6137-6157.
</p>
<p>Nakagawa, Shinichi, and Holger Schielzeth. &quot;A general and simple method for
obtaining R2 from generalized linear mixed effects models.&quot; Methods in
Ecology and Evolution 4.2 (2013): 133-142.
</p>
<p>Jaeger, Byron C., et al., &quot;An R Squared Statistic for Fixed Effects in the
Generalized Linear Mixed Model.&quot; Journal of Applied Statistics (2016).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
library(lme4)
data(Orthodont)

# Linear mixed models
mermod = lmer(distance ~ age*Sex + (1|Subject), data = Orthodont)
lmemod = lme(distance ~ age*Sex, random = ~1|Subject, data = Orthodont)

# The Kenward-Roger approach
r2beta(mermod, method = 'kr')

# Standardized Generalized Variance
r2beta(mermod, method = 'sgv')
r2beta(lmemod, method = 'sgv')

# The marginal R squared by Nakagawa and Schielzeth (extended by Johnson)
r2beta(mermod, method = 'nsj')

# linear and generalized linear models

library(datasets)
dis = data.frame(discoveries)
dis$year = 1:nrow(dis)

lmod = lm(discoveries ~ year + I(year^2), data = dis)
glmod = glm(discoveries ~ year + I(year^2), family = 'poisson', data = dis)

# Using an inappropriate link function (normal) leads to
# a poor fit relative to the poisson link function.

r2beta(lmod)
r2beta(glmod)

# PQL models
# Currently only SGV method is supported
library(MASS)
PQL_bac = glmmPQL(y ~ trt + I(week &gt; 2), random = ~ 1 | ID,
                  family = binomial, data = bacteria,
                  verbose = FALSE)

r2beta(PQL_bac, method='sgv')

</code></pre>

<hr>
<h2 id='r2dt'>R Squared Difference Test (R2DT). Test for a statistically significant difference in generalized explained variance between two candidate models.</h2><span id='topic+r2dt'></span>

<h3>Description</h3>

<p>R Squared Difference Test (R2DT). Test for a statistically significant difference in generalized explained variance between two candidate models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2dt(x, y = NULL, cor = TRUE, fancy = FALSE, onesided = TRUE,
  clim = 95, nsims = 2000, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r2dt_+3A_x">x</code></td>
<td>
<p>An R2 object from the r2beta function.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_y">y</code></td>
<td>
<p>An R2 object from the r2beta function. If y is not specified, Ho: E[x] = mu is tested (mu is specified by the user).</p>
</td></tr>
<tr><td><code id="r2dt_+3A_cor">cor</code></td>
<td>
<p>if TRUE, the R squared statistics are assumed to be positively correlated and a simulation based approach is used. If FALSE, the R squared are assumed independent and the difference of independent beta distributions is used. This only needs to be specified when two R squared measures are being considered.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_fancy">fancy</code></td>
<td>
<p>if TRUE, the output values are rounded and changed to characters.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_onesided">onesided</code></td>
<td>
<p>if TRUE, the alternative hypothesis is that one model explains a larger proportion of generalized variance. If false, the alternative is that the amount of generalized variance explained by the two candidate models is not equal.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_clim">clim</code></td>
<td>
<p>Desired confidence level for interval estimates regarding the difference in generalized explained variance.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_nsims">nsims</code></td>
<td>
<p>number of samples to draw when simulating correlated non-central beta random variables. This parameter is only relevant if cor=TRUE.</p>
</td></tr>
<tr><td><code id="r2dt_+3A_mu">mu</code></td>
<td>
<p>Used to test Ho: E[x] = mu.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A confidence interval for the difference in R Squared statistics and a p-value corresponding to the null hypothesis of no difference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nlme)
library(lme4)
library(r2glmm)

data(Orthodont)

# Comparing two linear mixed models
m1 = lmer(distance ~ age*Sex+(1|Subject), Orthodont)
m2 = lmer(distance ~ age*Sex+(1+age|Subject), Orthodont)

m1r2 = r2beta(model=m1,partial=FALSE)
m2r2 = r2beta(model=m2,partial=FALSE)

# Accounting for correlation can make a substantial difference.

r2dt(x=m1r2, y = m2r2, cor = TRUE)
r2dt(x=m1r2, y = m2r2, cor = FALSE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
