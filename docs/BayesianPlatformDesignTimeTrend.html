<!DOCTYPE html><html><head><title>Help for package BayesianPlatformDesignTimeTrend</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesianPlatformDesignTimeTrend}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdaptiveRandomisation'><p>AdaptiveRandomisation</p></a></li>
<li><a href='#alphaspending'><p>alphaspending</p></a></li>
<li><a href='#ARmethod'><p>ARmethod</p></a></li>
<li><a href='#BayesianPlatformDesignTimeTrend-package'><p>The 'BayesianPlatformDesignTimeTrend' package.</p></a></li>
<li><a href='#Boundaryconstruction'><p>Boundaryconstruction</p></a></li>
<li><a href='#conjuncativepower_or_FWER'><p>conjuncativepower_or_FWER</p></a></li>
<li><a href='#dataloginformd'><p>Cutoff screening example: the details of grid</p></a></li>
<li><a href='#demo_Cutoffscreening'><p>demo_Cutoffscreening</p></a></li>
<li><a href='#demo_Cutoffscreening.GP'><p>A demo for cutoff screening using Bayesian optimisation</p></a></li>
<li><a href='#demo_multscenario'><p>demo_multscenario</p></a></li>
<li><a href='#disconjunctivepowerfunc'><p>disconjunctivepowerfunc</p></a></li>
<li><a href='#GP.optim'><p>GP.optim: optimiser to give the next cutoff for evaluation</p></a></li>
<li><a href='#ibetabinomial.post'><p>ibetabinomial.post</p></a></li>
<li><a href='#Initializetrialparameter'><p>Initializetrialparameter</p></a></li>
<li><a href='#intbias'><p>intbias</p></a></li>
<li><a href='#Meanfunc'><p>Meanfunc</p></a></li>
<li><a href='#modelinf.fun'><p>modelinf.fun</p></a></li>
<li><a href='#Nfunc'><p>Nfunc</p></a></li>
<li><a href='#OPC_alt'><p>Operation characteristic table for alternative scenario</p></a></li>
<li><a href='#OPC_null'><p>Operation characteristic table for null scenario</p></a></li>
<li><a href='#OPC_Trial.simulation'><p>Operation characteristic table for Trial.simulation() null scenario</p></a></li>
<li><a href='#optimdata_asy'><p>A list of data from Gaussian process and trial simulation for asymmetric cutoff screening.</p></a></li>
<li><a href='#optimdata_sym'><p>A list of data from Gaussian process for symmetric cutoff screening.</p></a></li>
<li><a href='#OutputStats.initialising'><p>OutputStats.initialising</p></a></li>
<li><a href='#perHtypeIerror_marginalpowerfunc'><p>perHtypeIerror_powerfunc</p></a></li>
<li><a href='#predictedtpIEinformd'><p>Cutoff screening example: the predicted value from quadratic model</p></a></li>
<li><a href='#Randomisation.inf'><p>Randomisation.inf</p></a></li>
<li><a href='#recommandloginformd'><p>Cutoff screening example: the recommended grid value at each time point</p></a></li>
<li><a href='#resultrtostats'><p>resultrtostats</p></a></li>
<li><a href='#resultrtostats.rand'><p>resultrtostats.rand</p></a></li>
<li><a href='#resultstantoRfunc'><p>resultstantoRfunc</p></a></li>
<li><a href='#resultstantoRfunc.rand'><p>resultstantoRfunc.rand</p></a></li>
<li><a href='#Save.resulttoRDatafile'><p>Save.resulttoRDatafile</p></a></li>
<li><a href='#simulatetrial'><p>simulatetrial</p></a></li>
<li><a href='#Sperarmfunc'><p>Sperarmfunc</p></a></li>
<li><a href='#stan.logisticmodeltrans'><p>stan.logisticmodeltrans</p></a></li>
<li><a href='#Stopboundinf'><p>Stopboundinf</p></a></li>
<li><a href='#testing_and_armdropping'><p>testing_and_armdropping</p></a></li>
<li><a href='#Timetrend.fun'><p>Timetrend.fun</p></a></li>
<li><a href='#Trial.simulation'><p>Trial simulation</p></a></li>
<li><a href='#trtbias'><p>trtbias</p></a></li>
<li><a href='#trteffect'><p>trteffect</p></a></li>
<li><a href='#varfunc'><p>varfunc</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulate and Analyse Bayesian Platform Trial with Time Trend</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Ziyan Wang [aut, cre],
  David Woods [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ziyan Wang &lt;zw7g20@soton.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulating the sequential multi-arm multi-stage or platform trial with Bayesian approach using the 'rstan' package, which provides the R interface for the Stan. 
    This package supports fixed ratio and Bayesian adaptive randomization approaches for randomization. 
    Additionally, it allows for the study of time trend problems in platform trials. 
    There are demos available for a multi-arm multi-stage trial with two different null scenarios, as well as for Bayesian trial cutoff screening.
    The Bayesian adaptive randomisation approaches are described in:
    Trippa et al. (2012) &lt;<a href="https://doi.org/10.1200%2FJCO.2011.39.8420">doi:10.1200/JCO.2011.39.8420</a>&gt; and
    Wathen et al. (2017) &lt;<a href="https://doi.org/10.1177%2F1740774517692302">doi:10.1177/1740774517692302</a>&gt;.
    The randomisation algorithm is described in: 
    Zhao W &lt;<a href="https://doi.org/10.1016%2Fj.cct.2015.06.008">doi:10.1016/j.cct.2015.06.008</a>&gt;.
    The analysis methods of time trend effect in platform trial are described in:
    Saville et al. (2022) &lt;<a href="https://doi.org/10.1177%2F17407745221112013">doi:10.1177/17407745221112013</a>&gt; and
    Bofill Roig et al. (2022) &lt;<a href="https://doi.org/10.1186%2Fs12874-022-01683-w">doi:10.1186/s12874-022-01683-w</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ZXW834/BayesianPlatformDesignTimeTrend">https://github.com/ZXW834/BayesianPlatformDesignTimeTrend</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ZXW834/BayesianPlatformDesignTimeTrend/issues">https://github.com/ZXW834/BayesianPlatformDesignTimeTrend/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), rstan (&ge; 2.32.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>BiocManager (&ge; 1.30.19), boot (&ge; 1.3-28), doParallel (&ge;
1.0.17), foreach (&ge; 1.5.1), ggplot2 (&ge; 3.4.0), ggpubr (&ge;
0.4.0), iterators (&ge; 1.0.13), laGP (&ge; 1.5-9), lhs (&ge; 1.1.6),
matrixStats (&ge; 0.61.0), methods, RColorBrewer (&ge; 1.1-3), Rcpp
(&ge; 0.12.0), RcppParallel (&ge; 5.0.1), reshape (&ge; 0.8.8),
rstantools (&ge; 2.3.1.1), stringr (&ge; 1.4.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), StanHeaders (&ge; 2.26.0), rstan (&ge;
2.26.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 10:11:18 UTC; ziyanwang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdaptiveRandomisation'>AdaptiveRandomisation</h2><span id='topic+AdaptiveRandomisation'></span>

<h3>Description</h3>

<p>This is a function doing the randomisation process. This Function generates the Sequence for patient allocation to each arm, patient outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptiveRandomisation(
  Fixratio,
  rand.algo,
  K,
  n.new,
  randomprob,
  treatmentindex,
  groupwise.response.probs,
  group,
  armleft,
  max.deviation,
  trend_add_or_multip,
  trend.function,
  trend.effect,
  ns,
  Fixratiocontrol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptiveRandomisation_+3A_fixratio">Fixratio</code></td>
<td>
<p>A indicator TRUE/FALSE</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_rand.algo">rand.algo</code></td>
<td>
<p>Randomisation algorithm: &quot;Coin&quot;: Biased coin; &quot;Urn&quot;: Urn method</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_n.new">n.new</code></td>
<td>
<p>The cohort size</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_randomprob">randomprob</code></td>
<td>
<p>A named vector of randomisation probability to each arm</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>The vector of treatment arm index excluding the control arm whose index is 0</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_groupwise.response.probs">groupwise.response.probs</code></td>
<td>
<p>A matrix of response probability of each arm</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_max.deviation">max.deviation</code></td>
<td>
<p>Tuning parameter of using urn randomisation method.</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_trend_add_or_multip">trend_add_or_multip</code></td>
<td>
<p>How time trend affects the true response probability: &quot;add&quot; or &quot;mult&quot;</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_trend.function">trend.function</code></td>
<td>
<p>The function returns time trend effect regarding to different time trend pattern</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_trend.effect">trend.effect</code></td>
<td>
<p>The strength of time trend effect as a parameter in trend.function()</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
<tr><td><code id="AdaptiveRandomisation_+3A_fixratiocontrol">Fixratiocontrol</code></td>
<td>
<p>A numeric value indicating the weight of control in randomisation.
Eg. 1 means equal randomisation, 2 means thw number of patients allocated to control is twice as large as other treatment arm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of patient allocation and patient outcome
nstage: A vector of the number of patients allocated to each arm
ystage: A vector of the patients outcome after treating with each arm
znew: A vector of treatment index assigned to each patient in the current cohort
ynew: A vector of outcome index record for each patient after treatment in the current cohort
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>References</h3>

<p>Mass weighted urn designâ€”a new randomization algorithm for unequal allocations. Zhao, Wenle. Contemporary clinical trials 43 (2015): 209-216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AdaptiveRandomisation(
Fixratio = FALSE,
rand.algo = "Urn",
K = 2,
n.new = 30,
randomprob = matrix(c(0.5, 0.5), ncol = 2, dimnames = list(c(),c("1","2"))),
treatmentindex = 1,
groupwise.response.probs = matrix(rep(c(0.4, 0.4), 5), byrow = TRUE, ncol = 2, nrow = 5),
group = 1,
armleft = 2,
max.deviation = 3,
trend_add_or_multip = "mult",
trend.function = function(ns, group, i, trend.effect) {delta = 0; return(delta)},
trend.effect = c(0, 0),
ns = c(30, 60, 90, 120, 150),
Fixratiocontrol = NA)

AdaptiveRandomisation(
Fixratio = TRUE,
rand.algo = "Urn",
K = 4,
n.new = 30,
randomprob = NA,
treatmentindex = c(1,3),
groupwise.response.probs = matrix(rep(c(0.4, 0.4,0.4, 0.4), 5), byrow = TRUE, ncol = 4, nrow = 5),
group = 1,
armleft = 3,
max.deviation = 3,
trend_add_or_multip = "mult",
trend.function = function(ns, group, i, trend.effect) {delta = 0; return(delta)},
trend.effect = c(0, 0),
ns = c(30, 60, 90, 120, 150),
Fixratiocontrol = 1)

</code></pre>

<hr>
<h2 id='alphaspending'>alphaspending</h2><span id='topic+alphaspending'></span>

<h3>Description</h3>

<p>This function estimates the mean error rate spent at each interim analysis for a trial
Example usage:
</p>

<ol>
<li><p> sapply(res = result, fun = alphaspending) will generate list of the proportion of trial replicates are stopped at each stage for all scenarios in result where result is a list containing output data for different scenario
</p>
</li>
<li><p> sapply(sapply(result,FUN = alphaspending),sum) will generate the type I error rate or power for all scenario on the result list
</p>
</li>
<li><p> alpha(result) generate the proportion of trial replicates are stopped at each stage where result is the output data for one specific scenario
</p>
</li>
<li><p> sum(alpha(result)) will generate the type I error rate or power for a specific scenario
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>alphaspending(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaspending_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The error rate at each interim analysis
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: alphaspending(res)
</code></pre>

<hr>
<h2 id='ARmethod'>ARmethod</h2><span id='topic+ARmethod'></span>

<h3>Description</h3>

<p>This function adjusts the posterior randomisation probability for each arm using many approaches.
Currently Thall's approach and Trippa's approach are used.
Double biased coin and other method will be added in the next version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARmethod(
  BARmethod,
  group,
  stats,
  post.prob.btcontrol,
  K,
  n,
  tuningparameter = NA,
  c = NA,
  a = NA,
  b = NA,
  post.prob.best,
  max.ar = NA,
  armleft,
  treatmentindex
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARmethod_+3A_barmethod">BARmethod</code></td>
<td>
<p>The indicator of which adaptive randomisation method is used</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_stats">stats</code></td>
<td>
<p>The output matrix</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_post.prob.btcontrol">post.prob.btcontrol</code></td>
<td>
<p>The vector of posterior probability of each active treatment arm better than control</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_n">n</code></td>
<td>
<p>The vector of sample size for each arm</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_tuningparameter">tuningparameter</code></td>
<td>
<p>The tuning parameter indicator for Thall's approach</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_c">c</code></td>
<td>
<p>The tuning parameter for Thall's approach</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_a">a</code></td>
<td>
<p>The hyperparamter parameter for Trippa's approach</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_b">b</code></td>
<td>
<p>The hyperparamter parameter for Trippa's approach</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_post.prob.best">post.prob.best</code></td>
<td>
<p>Posterior probability of each arm to be the best</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_max.ar">max.ar</code></td>
<td>
<p>The upper boundary for randomisation ratio for each arm, which is used in Thall's approach since Trippa's approach has protection on control arm.</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="ARmethod_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>The vector of treatment arm index excluding the control arm whose index is 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>randomprob: The vector of adjusted randomisation probability to each arm
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>References</h3>

<p>Bayesian adaptive randomized trial design for patients with recurrent glioblastoma. Trippa, Lorenzo, Eudocia Q. Lee, Patrick Y. Wen, Tracy T. Batchelor, Timothy Cloughesy, Giovanni Parmigiani, and Brian M. Alexander. Journal of Clinical Oncology 30, no. 26 (2012): 3258.
A simulation study of outcome adaptive randomization in multi-arm clinical trials. Wathen, J. Kyle, and Peter F. Thall. Clinical Trials 14, no. 5 (2017): 432-440.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARmethod(
BARmethod = "Thall",
group = 1,
stats = matrix(rep(NA, 40), ncol = 8, nrow = 5),
post.prob.btcontrol = 0.5,
K = 2,
n = c(30, 30),
tuningparameter = "fixed",
c = 1,
post.prob.best = c(0.5, 0.5),
max.ar = 0.75,
armleft = 2,
treatmentindex = 1)

ARmethod(
BARmethod = "Trippa",
group = 1,
stats = matrix(rep(NA, 40), ncol = 8, nrow = 5),
post.prob.btcontrol = c(0.5, 0.6),
K = 3,
n = c(30, 30, 40),
tuningparameter = NA,
c = NA,
a = 3,
b = 0.75,
post.prob.best = c(0.3, 0.3, 0.4),
max.ar = NA,
armleft = 3,
treatmentindex = c(1, 2))

</code></pre>

<hr>
<h2 id='BayesianPlatformDesignTimeTrend-package'>The 'BayesianPlatformDesignTimeTrend' package.</h2><span id='topic+BayesianPlatformDesignTimeTrend-package'></span><span id='topic+BayesianPlatformDesignTimeTrend'></span>

<h3>Description</h3>

<p>This package simulates the multi-arm multi-stage or platform trial with bayesian approach using the 'rstan' package, which provides the R interface for to the stan.
The package uses Thall's and Trippa's randomisation approach for Bayesian adaptive randomisation.
In addition, the time trend problem of platform trial can be studied in this package.
There is a demo for multi-arm multi-stage trial for two different null scenario in this package.
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.2. https://mc-stan.org
</p>

<hr>
<h2 id='Boundaryconstruction'>Boundaryconstruction</h2><span id='topic+Boundaryconstruction'></span>

<h3>Description</h3>

<p>This function constructs the stopping boundary based on input information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boundaryconstruction(Stopbound.inf = Stopbound.inf, ns = ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Boundaryconstruction_+3A_stopbound.inf">Stopbound.inf</code></td>
<td>
<p>The list of stop boundary information for more see <code><a href="#topic+Stopboundinf">Stopboundinf</a></code></p>
</td></tr>
<tr><td><code id="Boundaryconstruction_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the futility boundary and the efficacy boundary
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'> Stopbound.inf=list(Stop.type="Early-Pocock",Boundary.type="Symmetric",cutoff=c(0.9928,0.0072))
 ns=c(60,120,180,240,300)
 Boundaryconstruction(Stopbound.inf, ns)
</code></pre>

<hr>
<h2 id='conjuncativepower_or_FWER'>conjuncativepower_or_FWER</h2><span id='topic+conjuncativepower_or_FWER'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate the Family wise error rate or Conjunctive power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjuncativepower_or_FWER(res, scenario, test.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conjuncativepower_or_FWER_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
<tr><td><code id="conjuncativepower_or_FWER_+3A_scenario">scenario</code></td>
<td>
<p>The true scenario used to generate the res list</p>
</td></tr>
<tr><td><code id="conjuncativepower_or_FWER_+3A_test.type">test.type</code></td>
<td>
<p>The indicator of whether using one side or two side testing.
Please make sure that the input test.type does not conflicts to the data. Otherwise the conjunctive power calculation is wrong</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Family wise error rate or Conjunctive power
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: conjuncativepower_or_FWER(res)
</code></pre>

<hr>
<h2 id='dataloginformd'>Cutoff screening example: the details of grid</h2><span id='topic+dataloginformd'></span>

<h3>Description</h3>

<p>Details of grid including famliy wise error rate of a cutoff value, the cutoff value and the square of cutoff value for modelling and prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataloginformd
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 3 variables:
</p>

<dl>
<dt><code>tpIE</code></dt><dd><p>FWER</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>Cutoff value</p>
</dd>
<dt><code>cutoff2</code></dt><dd><p>Square of cutoff value</p>
</dd>
</dl>


<hr>
<h2 id='demo_Cutoffscreening'>demo_Cutoffscreening</h2><span id='topic+demo_Cutoffscreening'></span>

<h3>Description</h3>

<p>This function does a cutoff screening for trial simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_Cutoffscreening(
  ntrials = 1000,
  trial.fun = simulatetrial,
  grid.inf = list(start = c(0.9, 0.95, 1), extendlength = 15),
  input.info = list(response.probs = c(0.4, 0.4), ns = c(30, 60, 90, 120, 150), max.ar =
    0.75, rand.algo = "Urn", max.deviation = 3, test.type = "Twoside", model.inf =
    list(model = "tlr", ibb.inf = list(pi.star = 0.5, pess = 2, betabinomialmodel =
    ibetabinomial.post), tlr.inf = list(beta0_prior_mu = 0, beta1_prior_mu = 0,
    beta0_prior_sigma = 2.5, beta1_prior_sigma = 2.5, beta0_df = 7, beta1_df = 7, reg.inf
    = "main", variable.inf = "Fixeffect")), Stop.type = "Early-Pocock", Boundary.type =
    "Symmetric", Random.inf = list(Fixratio = FALSE, 
     Fixratiocontrol = NA,
    BARmethod = "Thall", Thall.tuning.inf = list(tuningparameter = "Fixed", fixvalue =
    1)), trend.inf = list(trend.type = "step", trend.effect = c(0, 0),
    trend_add_or_multip = "mult")),
  cl = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demo_Cutoffscreening_+3A_ntrials">ntrials</code></td>
<td>
<p>A numeric variable indicating how many trial replicates you want to run</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening_+3A_trial.fun">trial.fun</code></td>
<td>
<p>The function of trial simulation, related to MainFunction.R</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening_+3A_grid.inf">grid.inf</code></td>
<td>
<p>A list of grid information to create start grid and extend grid for cutoff screening.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening_+3A_input.info">input.info</code></td>
<td>
<p>A list of input information including all information required for trial simulation.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening_+3A_cl">cl</code></td>
<td>
<p>A numeric variable indicating how many cores you want to use in parallel programming.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of recommended cutoff. The final value is the latest recommended value. A plot for all tested cutoff and error rate
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo_Cutoffscreening(ntrials = 2, cl = 2,
    grid.inf = list(start = c(0.9, 0.95, 1), extendlength = 2))
</code></pre>

<hr>
<h2 id='demo_Cutoffscreening.GP'>A demo for cutoff screening using Bayesian optimisation</h2><span id='topic+demo_Cutoffscreening.GP'></span>

<h3>Description</h3>

<p>This function does a cutoff screening for trial simulation using Bayesian optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_Cutoffscreening.GP(
  ntrials = 1000,
  trial.fun = simulatetrial,
  grid.inf = list(start.length = 10, grid.min = NULL, grid.max = NULL, confidence.level =
    0.95, grid.length = 5000, change.scale = FALSE, noise = TRUE, errorrate = 0.1,
    simulationerror = 0.01, iter.max = 15, plotornot = FALSE),
  power.type = NA,
  response.probs.alt = NA,
  input.info = list(response.probs.null = c(0.4, 0.4, 0.4, 0.4), ns = c(120, 240, 360,
    480, 600), max.ar = 0.85, rand.algo = "Urn", max.deviation = 3, test.type =
    "Twoside", model.inf = list(model = "tlr", ibb.inf = list(pi.star = 0.5, pess = 2,
    betabinomialmodel = ibetabinomial.post), tlr.inf = list(beta0_prior_mu = 0,
    beta1_prior_mu = 0, beta0_prior_sigma = 2.5, beta1_prior_sigma = 2.5, beta0_df = 7,
    beta1_df = 7, reg.inf = "main", variable.inf = "Fixeffect")), Stop.type =
    "Early-OBF", Boundary.type = "Symmetric", 
     Random.inf = list(Fixratio = FALSE,
    Fixratiocontrol = NA, BARmethod = "Thall", Thall.tuning.inf = list(tuningparameter =
    "Unfixed", fixvalue = 1)), trend.inf = list(trend.type = "step", trend.effect = c(0,
    0, 0, 0), trend_add_or_multip = "mult")),
  cl = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_ntrials">ntrials</code></td>
<td>
<p>A numeric variable indicating how many trial replicates you want to run</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_trial.fun">trial.fun</code></td>
<td>
<p>The function of trial simulation, related to MainFunction.R</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_grid.inf">grid.inf</code></td>
<td>
<p>A list of grid information to create start grid and extend grid for cutoff screening.
'start.length' is the size of start grid. Default is 10.
'grid.min' A numeric value or vector (for asymmetric boundary) indicating the lower bound of the grid for screening. For asymmetric boundary, the first value is efficacy minimum value and the second value is futility minimum value.
'grid.max' A numeric value or vector (for asymmetric boundary) indicating the upper bound of the grid for screening. For asymmetric boundary, the first value is efficacy maximum value and the second value is futility maximum value.
'errorrate' refers to the target of type I error rate or family-wise error rate. Default is 0.05. User can change it to 0.1 for FWER if they think 0.05 is too conservative. The per-hypothesis type I error equals errorrate / (K-1) where (K-1) is the number of treatment arms.
'confidence.level' is a numeric value indicating the confidence level of estimate. Default is 0.95.
'grid.length' A numeric value indicating the grid resolution. Default is 5000 for symmetric boundary. For asymmetric boundary, the length of grid is 101 for both efficacy grid and futility grid. A numeric value indicating the grid resolution. Default is 5000 for symmetric boundary. For asymmetric boundary, the length of grid is 101 for both efficacy grid and futility grid.
'change.scale' is a logic value indicating whether we want to change scale when doing Gaussian process. Default is FALSE.
'noise' is a logic value indicating whether the input x is noisy. Default is TRUE.
'simulationerror' is a numeric value indicating the tolerable error for simulated type I error rate. Default is 0.01,
'iter.max' is a numeric value indicating the maximum number of evaluations. Default is 15.
'plotornot' is a logic value indicating whether the errorrate vs grid plot needed to be generated at each iteration. Default is FALSE.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_power.type">power.type</code></td>
<td>
<p>A indicator of which type of power we need to optimise when tuning the cutoff value for asymmetric boundary. Default is NA (Symmetric boundary).
The choice of power type is Conjunctive power (&quot;Conjunctive&quot;) and Disconjunctive power (&quot;Disconjunctive&quot;). In a two arm trial design, these power type are the same.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_response.probs.alt">response.probs.alt</code></td>
<td>
<p>A vector of response probability of each arm under the alternative scenario. This is used for power optimisation when tuning the cutoff values for asymmetric boundary. Default is NA.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_input.info">input.info</code></td>
<td>
<p>A list of input information including all information required for trial simulation.</p>
</td></tr>
<tr><td><code id="demo_Cutoffscreening.GP_+3A_cl">cl</code></td>
<td>
<p>A numeric variable indicating how many cores you want to use in parallel programming.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of recommended cutoff. The final value is the latest recommended value. A plot for all tested cutoff and error rate
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Two arm asymmetric boundary screening. Default is OBF boundary.
demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
 power.type = NA,
 response.probs.alt = NA,
 grid.inf = list(
 start.length = 10,
 confidence.level = 0.95,
 grid.length = 5000,
 change.scale = FALSE,
 noise = TRUE,
 errorrate = 0.1,
 simulationerror = 0.01,
 iter.max = 15,
 plotornot = FALSE))

 #Four arm asymmetric OBF boundary screening where conjunctive power is optimised.
 demo_Cutoffscreening.GP(ntrials = 2, cl = 2,
 power.type = "Conjunctive",
 response.probs.alt = c(0.4,0.6,0.6,0.4),
 grid.inf = list(
 start.length = 10,
 confidence.level = 0.95,
 grid.length = 101,
 change.scale = FALSE,
 noise = TRUE,
 errorrate = 0.1,
 simulationerror = 0.01,
 iter.max = 15,
 plotornot = FALSE))
 input.info = list(
 response.probs.null = c(0.4,0.4,0.4,0.4),
 ns = c(120, 240, 360, 480, 600),
 max.ar = 0.85,
 rand.algo = "Urn",
 max.deviation = 3,
 test.type = "Twoside",
 model.inf = list(
 model = "tlr",
 ibb.inf = list(
 pi.star = 0.5,
 pess = 2,
 betabinomialmodel = ibetabinomial.post
 ),
 tlr.inf = list(
 beta0_prior_mu = 0,
 beta1_prior_mu = 0,
 beta0_prior_sigma = 2.5,
 beta1_prior_sigma = 2.5,
 beta0_df = 7,
 beta1_df = 7,
 reg.inf =  "main",
 variable.inf = "Fixeffect"
 )
 ),
 Stop.type = "Early-OBF",
 Boundary.type = "Asymmetric",
 Random.inf = list(
 Fixratio = FALSE,
 Fixratiocontrol = NA,
 BARmethod = "Thall",
 Thall.tuning.inf = list(tuningparameter = "Unfixed",  fixvalue = 1)
 ),
 trend.inf = list(
 trend.type = "step",
 trend.effect = c(0, 0, 0, 0),
 trend_add_or_multip = "mult"
 )
 )
 

</code></pre>

<hr>
<h2 id='demo_multscenario'>demo_multscenario</h2><span id='topic+demo_multscenario'></span>

<h3>Description</h3>

<p>This is a demo function simulating multi-arm multi-stage design with two different null scenarios where the response probability of control is 0.15 and 0.4, respectively.
The clinically meaningful increment on probability scale is 0.2. The stopping boundary is the OBF. The cutoff vector in the demo is tuned to keep Type I error rate to be 0.05. The output data can be saved as .RData file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_multscenario(ntrials = 1000, cl = 2, save_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demo_multscenario_+3A_ntrials">ntrials</code></td>
<td>
<p>A numeric value. The number of total trail replicates for each scenario.</p>
</td></tr>
<tr><td><code id="demo_multscenario_+3A_cl">cl</code></td>
<td>
<p>A numeric variable indicating how many cores you want to use in parallel programming.</p>
</td></tr>
<tr><td><code id="demo_multscenario_+3A_save_data">save_data</code></td>
<td>
<p>An indicator of whether the output data need to be saved. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data for plotting. One is results of trial replicates for all scenarios. The other one is a data frame containing all summarised evaluation metrics for all scenarios
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo_multscenario(ntrials = 2, cl = 2, save_data = FALSE)
</code></pre>

<hr>
<h2 id='disconjunctivepowerfunc'>disconjunctivepowerfunc</h2><span id='topic+disconjunctivepowerfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate the Family wise error rate or disconjunctive power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disconjunctivepowerfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disconjunctivepowerfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Disconjunctive power
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: disconjunctivepowerfunc(res)
</code></pre>

<hr>
<h2 id='GP.optim'>GP.optim: optimiser to give the next cutoff for evaluation</h2><span id='topic+GP.optim'></span>

<h3>Description</h3>

<p>A function to predict the next cutoff value for evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP.optim(
  x,
  y.t1E,
  y.pow = NA,
  ESS = NA,
  errorrate = 0.05,
  confidence.level = 0.95,
  grid.length = 1000,
  change.scale = FALSE,
  noise = T,
  grid.min,
  grid.max,
  Boundary.type = "Symmetric"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GP.optim_+3A_x">x</code></td>
<td>
<p>A numeric vector of cutoff data</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_y.t1e">y.t1E</code></td>
<td>
<p>A numeric vector of type I error rate data</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_y.pow">y.pow</code></td>
<td>
<p>A numeric vector of power data. You can input conjucntive, disconjunctive and marginal power data. Default is NA. Only used when Boundary.type == &quot;Asymmetric&quot;</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_ess">ESS</code></td>
<td>
<p>A matrix of effective sample size. This is only called for asymmetric boundary cutoff screening. Default is NA for symmetric boundary.
The first column is the ESS for different cutoff pair under the null scenario, the second column is the ESS for different cutoff pair under the alternative scenario.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_errorrate">errorrate</code></td>
<td>
<p>'errorrate' refers to the target of type I error rate or family-wise error rate. Default is 0.05. User can change it to 0.1 for FWER if they think 0.05 is too conservative. The per-hypothesis type I error equals errorrate / (K-1) where (K-1) is the number of treatment arms.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_confidence.level">confidence.level</code></td>
<td>
<p>A numeric value indicating the confidence level of estimate. Default is 0.95</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_grid.length">grid.length</code></td>
<td>
<p>A numeric value indicating the grid resolution. Default is 1000.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_change.scale">change.scale</code></td>
<td>
<p>A logic value indicating whether we want to change scale when doing Gaussian process. Default is FALSE.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_noise">noise</code></td>
<td>
<p>A logic value indicating whether the input x is noisy. Default is TRUE.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_grid.min">grid.min</code></td>
<td>
<p>A numeric value or vector (for asymmetric boundary) indicating the lower bound of the grid for screening. For asymmetric boundary, the first value is efficacy minimum value and the second value is futility minimum value.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_grid.max">grid.max</code></td>
<td>
<p>A numeric value or vector (for asymmetric boundary) indicating the upper bound of the grid for screening. For asymmetric boundary, the first value is efficacy maximum value and the second value is futility maximum value.</p>
</td></tr>
<tr><td><code id="GP.optim_+3A_boundary.type">Boundary.type</code></td>
<td>
<p>A text indicating what type of boundary used. Default is &quot;Symmetric&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the next cutoff value for evaluation <code>next.cutoff</code> and a list of predictions for screening grid.
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>References</h3>

<p>Surrogates: Gaussian process modeling, design, and optimization for the applied sciences. CRC press. Gramacy, R.B., 2020.
Bayesian optimization for adaptive experimental design: A review. IEEE access, 8, 13937-13948. Greenhill, S., Rana, S., Gupta, S., Vellanki, P., &amp; Venkatesh, S. (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(7.123968, 6.449631, 1.984406,
3.507463, 4.972510, 2.925768,
5.816682, 4.367796,
7.349160, 1.113648)
y.t1E = c(0.0396, 0.0450,
0.5116, 0.2172,
0.1040, 0.3058,
0.0592, 0.1384,
0.0296, 0.7936)
grid.min=1
grid.max=8
GP.res=GP.optim(x=x, y.t1E=y.t1E, errorrate = 0.1, grid.min = grid.min, grid.max = grid.max)
GP.res$next.cutoff

x =  data.frame(matrix(c(
0.9563408, 0.006295626,
0.9669739, 0.014395030,
0.9959410, 0.034858339,
0.9635357, 0.048435579,
0.9794314, 0.021659226,
0.9552201, 0.018442535,
0.9655374, 0.035281833,
0.9837123, 0.010656442,
0.9974910, 0.047741842,
0.9989172, 0.012982826), byrow=TRUE, ncol = 2))
y.t1E = c(0.3044, 0.2938, 0.2573, 0.4780, 0.2923, 0.3733, 0.4263, 0.1962, 0.2941, 0.1131)
y.pow = c(0.8300, 0.8239, 0.7102, 0.7291, 0.8205, 0.7984, 0.7709, 0.8418, 0.6359, 0.5609)
ESS = data.frame(matrix(c(
594.672, 560.580,
596.148, 566.328,
597.840, 590.124,
590.052, 544.800,
597.024, 574.716,
593.952, 554.580,
593.676, 554.400,
598.500, 583.896,
595.740, 590.520,
599.580, 598.644),byrow=TRUE,ncol=2))
grid.min=c(0.95,0)
grid.max=c(1,0.05)
GP.res_asy=GP.optim(x=x, y.t1E=y.t1E, y.pow=y.pow, ESS=ESS,errorrate = 0.1,
grid.min = grid.min, grid.max = grid.max, Boundary.type="Asymmetric")
GP.res_asy$next.cutoff
</code></pre>

<hr>
<h2 id='ibetabinomial.post'>ibetabinomial.post</h2><span id='topic+ibetabinomial.post'></span>

<h3>Description</h3>

<p>This function calculates the posterior probability of each active treatment arm better than control using betabinomial model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibetabinomial.post(n, y, pi.star = 0.5, pess = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibetabinomial.post_+3A_n">n</code></td>
<td>
<p>A vector of treated patients for each arm (The first element is for control)</p>
</td></tr>
<tr><td><code id="ibetabinomial.post_+3A_y">y</code></td>
<td>
<p>A vector of treated patient outcomes for each arm (The first element is for control)</p>
</td></tr>
<tr><td><code id="ibetabinomial.post_+3A_pi.star">pi.star</code></td>
<td>
<p>The prior response probability. The default is 0.5</p>
</td></tr>
<tr><td><code id="ibetabinomial.post_+3A_pess">pess</code></td>
<td>
<p>The effective sample size of beta prior. The default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector posterior probability of each active treatment arm better than control
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(20,20,20,20)
y &lt;- c(12,12,12,6)
ibetabinomial.post(n, y, pi.star = 0.5, pess = 2)
#[1] 0.5000000 0.5000000 0.0308018
</code></pre>

<hr>
<h2 id='Initializetrialparameter'>Initializetrialparameter</h2><span id='topic+Initializetrialparameter'></span>

<h3>Description</h3>

<p>This function initialises the inner parameter used in simulate.trial function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Initializetrialparameter(response.probs, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initializetrialparameter_+3A_response.probs">response.probs</code></td>
<td>
<p>A vector of response probability of each arm</p>
</td></tr>
<tr><td><code id="Initializetrialparameter_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of initialised parameters including the number of arms for this trial 'K',
the number of arm active 'armleft', the index of treatment arm 'treatmentindex', the vector of total number of patients allocated to each arm 'n'
the number of total number of patients survived for each arm 'y1',
the matrix for true response probability of each arm at each stage 'groupwise.response.probs' which is required for the time trend study,
the vector of randomisation probability for each arm 'randomprob',
the array of arm assignment for each patient 'z',
the array of outcome for each patient 'y',
the array of the stage index for each patient 'group_indicator',
the matrix of the probability of each arm to be the best at each stage 'post.prob.best.mat'.
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Initializetrialparameter(response.probs = c(0.4,0.6), ns = c(15,30,45,60,75,90))

#$K
#[1] 2

#$armleft
#[1] 2

#$treatmentindex
#[1] 1

#$n
#[1] 0 0

#$y1
#[1] 0 0

#$groupwise.response.probs
#     [,1] [,2]
#[1,]  0.4  0.6
#[2,]  0.4  0.6
#[3,]  0.4  0.6
#[4,]  0.4  0.6
#[5,]  0.4  0.6
#[6,]  0.4  0.6

#$randomprob
#     1   2
#[1,] 0.5 0.5

#$z
#numeric(0)

#$y
#numeric(0)

#$group_indicator
#numeric(0)

#$post.prob.best.mat
#     0 1
#[1,] 0 0
#[2,] 0 0
#[3,] 0 0
#[4,] 0 0
#[5,] 0 0
#[6,] 0 0

</code></pre>

<hr>
<h2 id='intbias'>intbias</h2><span id='topic+intbias'></span>

<h3>Description</h3>

<p>This function estimates the mean bias of treatment - stage interaction effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intbias(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intbias_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of mean treatment - stage interaction effect bias
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: intbias(res)
</code></pre>

<hr>
<h2 id='Meanfunc'>Meanfunc</h2><span id='topic+Meanfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate mean treatment effect estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Meanfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Meanfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean treatment effect estimates of each treatment arm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: Meanfunc(res)
</code></pre>

<hr>
<h2 id='modelinf.fun'>modelinf.fun</h2><span id='topic+modelinf.fun'></span>

<h3>Description</h3>

<p>This function summarize the input parameters describing the model for analysis and transfer them into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelinf.fun(
  model = "tlr",
  ibb.inf = list(pi.star = 0.5, pess = 2, betabinomialmodel = ibetabinomial.post),
  tlr.inf = list(beta0_prior_mu = 0, beta1_prior_mu = 0, beta0_prior_sigma = 2.5,
    beta1_prior_sigma = 2.5, beta0_df = 7, beta1_df = 7, reg.inf = "main", variable.inf =
    "Fixeffect")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelinf.fun_+3A_model">model</code></td>
<td>
<p>The statistical model. ibb: betabinomial model / tlr: logistic model</p>
</td></tr>
<tr><td><code id="modelinf.fun_+3A_ibb.inf">ibb.inf</code></td>
<td>
<p>The list of information for betabinomial model including:
betabinomialmodel: The betabinomial model, pi.star: prior response rate,
pess: prior effective sample size</p>
</td></tr>
<tr><td><code id="modelinf.fun_+3A_tlr.inf">tlr.inf</code></td>
<td>
<p>The list of information for logistic model including:
The mean (mu), variance (sigma), degree of freedom (df) of the intercept
and the main effect of the linear terms in logistic model.
reg.inf: The type of linear function in logistic model.
variable.inf: Fixeffect/Mixeffect. Indicating whether a mix effect model
is used (for time trend effect modelling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model information including model, ibb.inf and tlr.inf
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modelinf.fun(model = "tlr",
  ibb.inf = list(pi.star = 0.5,
                 pess = 2,
                 betabinomialmodel = ibetabinomial.post),
  tlr.inf = list(beta0_prior_mu = 0,
                 beta1_prior_mu = 0,
                 beta0_prior_sigma = 2.5,
                 beta1_prior_sigma = 2.5,
                 beta0_df = 7,
                 beta1_df = 7,
                 reg.inf =  "main",
                 variable.inf = "Fixeffect"
                 ))
</code></pre>

<hr>
<h2 id='Nfunc'>Nfunc</h2><span id='topic+Nfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate mean estimate of total number of patients allocated to each arm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean estimate of total number of patients allocated to each arm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: Nfunc(res)

</code></pre>

<hr>
<h2 id='OPC_alt'>Operation characteristic table for alternative scenario</h2><span id='topic+OPC_alt'></span>

<h3>Description</h3>

<p>Operation characteristic table for alternative scenario using main + continuousstage model. The time trend pattern is step.
The strength of time trend is 0.1 equally for all arm. The effect of time trend on true response probability is multiplicative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPC_alt
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 16 variables:
</p>

<dl>
<dt><code>Type.I.Error.or.Power</code></dt><dd><p>Power</p>
</dd>
<dt><code>Bias.1</code></dt><dd><p>Treatment effect bias for treatment 1</p>
</dd>
<dt><code>Bias.2</code></dt><dd><p>Treatment effect bias for treatment 2</p>
</dd>
<dt><code>Bias.3</code></dt><dd><p>Treatment effect bias for treatment 3</p>
</dd>
<dt><code>rMSE.1</code></dt><dd><p>Rooted mean squared error for treatment 1</p>
</dd>
<dt><code>rMSE.2</code></dt><dd><p>Rooted mean squared error for treatment 2</p>
</dd>
<dt><code>rMSE.3</code></dt><dd><p>Rooted mean squared error for treatment 3</p>
</dd>
<dt><code>N.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>N.per.arm.2</code></dt><dd><p>Mean total number of patient allocated to treatment 1</p>
</dd>
<dt><code>N.per.arm.3</code></dt><dd><p>Mean total number of patient allocated to treatment 2</p>
</dd>
<dt><code>N.per.arm.4</code></dt><dd><p>Mean total number of patient allocated to treatment 3</p>
</dd>
<dt><code>Survive.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>Survive.per.arm.2</code></dt><dd><p>Mean total number of patient survived when using treatment 1</p>
</dd>
<dt><code>Survive.per.arm.3</code></dt><dd><p>Mean total number of patient survived when usin treatment 2</p>
</dd>
<dt><code>Survive.per.arm.4</code></dt><dd><p>Mean total number of patient survived when usin treatment 3</p>
</dd>
<dt><code>N</code></dt><dd><p>Mean total number of patient in a trial</p>
</dd>
</dl>


<hr>
<h2 id='OPC_null'>Operation characteristic table for null scenario</h2><span id='topic+OPC_null'></span>

<h3>Description</h3>

<p>Operation characteristic table for null scenario using main and main + continuousstage model. The main effect model was run for a null scenario with and without time trend.
The time trend pattern is step. The strength of time trend is 0.1 equally for all arm. The effect of time trend on true response probability is multiplicative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPC_null
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 16 variables:
</p>

<dl>
<dt><code>Type.I.Error.or.Power</code></dt><dd><p>Family wise error rate</p>
</dd>
<dt><code>Bias.1</code></dt><dd><p>Treatment effect bias for treatment 1</p>
</dd>
<dt><code>Bias.2</code></dt><dd><p>Treatment effect bias for treatment 2</p>
</dd>
<dt><code>Bias.3</code></dt><dd><p>Treatment effect bias for treatment 3</p>
</dd>
<dt><code>rMSE.1</code></dt><dd><p>Rooted mean squared error for treatment 1</p>
</dd>
<dt><code>rMSE.2</code></dt><dd><p>Rooted mean squared error for treatment 2</p>
</dd>
<dt><code>rMSE.3</code></dt><dd><p>Rooted mean squared error for treatment 3</p>
</dd>
<dt><code>N.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>N.per.arm.2</code></dt><dd><p>Mean total number of patient allocated to treatment 1</p>
</dd>
<dt><code>N.per.arm.3</code></dt><dd><p>Mean total number of patient allocated to treatment 2</p>
</dd>
<dt><code>N.per.arm.4</code></dt><dd><p>Mean total number of patient allocated to treatment 3</p>
</dd>
<dt><code>Survive.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>Survive.per.arm.2</code></dt><dd><p>Mean total number of patient survived when using treatment 1</p>
</dd>
<dt><code>Survive.per.arm.3</code></dt><dd><p>Mean total number of patient survived when usin treatment 2</p>
</dd>
<dt><code>Survive.per.arm.4</code></dt><dd><p>Mean total number of patient survived when usin treatment 3</p>
</dd>
<dt><code>N</code></dt><dd><p>Mean total number of patient in a trial</p>
</dd>
</dl>


<hr>
<h2 id='OPC_Trial.simulation'>Operation characteristic table for Trial.simulation() null scenario</h2><span id='topic+OPC_Trial.simulation'></span>

<h3>Description</h3>

<p>Operation characteristic table for null scenario using main model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OPC_Trial.simulation
</code></pre>


<h3>Format</h3>

<p>A data frame with 1 rows and 8 variables:
</p>

<dl>
<dt><code>Type.I.Error.or.Power</code></dt><dd><p>Power</p>
</dd>
<dt><code>Bias</code></dt><dd><p>Treatment effect bias for treatment 1</p>
</dd>
<dt><code>rMSE</code></dt><dd><p>Rooted mean squared error for treatment effect 1</p>
</dd>
<dt><code>N.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>N.per.arm.2</code></dt><dd><p>Mean total number of patient allocated to treatment 1</p>
</dd>
<dt><code>Survive.per.arm.1</code></dt><dd><p>Mean total number of patient allocated to control</p>
</dd>
<dt><code>Survive.per.arm.2</code></dt><dd><p>Mean total number of patient survived when using treatment 1</p>
</dd>
<dt><code>N</code></dt><dd><p>Mean total number of patient in a trial</p>
</dd>
</dl>


<hr>
<h2 id='optimdata_asy'>A list of data from Gaussian process and trial simulation for asymmetric cutoff screening.</h2><span id='topic+optimdata_asy'></span>

<h3>Description</h3>

<p>A list of data from Gaussian process and trial simulation for asymmetric cutoff screening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimdata_asy
</code></pre>


<h3>Format</h3>

<p>A list with four element:
</p>

<dl>
<dt><code>next.cutoff</code></dt><dd><p>The cutoff value for the next evaluation</p>
</dd>
<dt><code>prediction</code></dt><dd><p>A list of values from Gaussian process model</p>
</dd>
<dt><code>ESS</code></dt><dd><p>A two column twenty five rows matrix with the effective sample size for each cutoff pair under both null (first column) and alternative (second column) scenario</p>
</dd>
<dt><code>testeddata</code></dt><dd><p>A data frame containing each tested cutoff pair (column two and three for efficacy and futility, respectively), their FWER under null (column one) and conjunctive power under alternative (column four)</p>
</dd>
</dl>


<hr>
<h2 id='optimdata_sym'>A list of data from Gaussian process for symmetric cutoff screening.</h2><span id='topic+optimdata_sym'></span>

<h3>Description</h3>

<p>A list of data from Gaussian process for symmetric cutoff screening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimdata_sym
</code></pre>


<h3>Format</h3>

<p>A list with two element:
</p>

<dl>
<dt><code>next.cutoff</code></dt><dd><p>The cutoff value for the next evaluation</p>
</dd>
<dt><code>prediction</code></dt><dd><p>A list of values from Gaussian process model</p>
</dd>
<dt><code>tpIE</code></dt><dd><p>A vector of type I error rate data</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>A vector of cutoff data</p>
</dd>
</dl>


<hr>
<h2 id='OutputStats.initialising'>OutputStats.initialising</h2><span id='topic+OutputStats.initialising'></span>

<h3>Description</h3>

<p>This function initializes the output matrix including all evaluation metrics based on input information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutputStats.initialising(variable.inf, reg.inf, ns, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutputStats.initialising_+3A_variable.inf">variable.inf</code></td>
<td>
<p>The parameter information in the model</p>
</td></tr>
<tr><td><code id="OutputStats.initialising_+3A_reg.inf">reg.inf</code></td>
<td>
<p>The model information. For the fixed effect model, the input of reg.inf can be main, main + stage_continuous, main * stage_continuous, main + stage_discrete,
main * stage_discrete.
For the mixed effect model, the reg.inf is invalid.</p>
</td></tr>
<tr><td><code id="OutputStats.initialising_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
<tr><td><code id="OutputStats.initialising_+3A_k">K</code></td>
<td>
<p>Total number of arm including control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The empty output matrix including different evaluation metrics.
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>OutputStats.initialising(
    variable.inf = "Fixeffect",
    reg.inf = "main",
    ns = c(15, 30, 45, 60, 75),
    K = 2)
</code></pre>

<hr>
<h2 id='perHtypeIerror_marginalpowerfunc'>perHtypeIerror_powerfunc</h2><span id='topic+perHtypeIerror_marginalpowerfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate the error rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perHtypeIerror_marginalpowerfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perHtypeIerror_marginalpowerfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;per-hypothesis&quot; Type I error rate or power (marginal power) for each treatment - control comparison
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: perHtypeIerror_powerfunc(res)
</code></pre>

<hr>
<h2 id='predictedtpIEinformd'>Cutoff screening example: the predicted value from quadratic model</h2><span id='topic+predictedtpIEinformd'></span>

<h3>Description</h3>

<p>The predicted value from quadratic model for famliy wise error rate vs cutoff value plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictedtpIEinformd
</code></pre>


<h3>Format</h3>

<p>A data frame with 1001 rows and 1 variables:
</p>

<dl>
<dt><code>predictedtpIEinformd</code></dt><dd><p>The predicted FWER value of a large grid</p>
</dd>
</dl>


<hr>
<h2 id='Randomisation.inf'>Randomisation.inf</h2><span id='topic+Randomisation.inf'></span>

<h3>Description</h3>

<p>This function checks the validity of the randomisation information input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Randomisation.inf(
  Random.inf = list(Fixratio = FALSE, Fixratiocontrol = NA, BARmethod = "Thall",
    Thall.tuning.inf = list(tuningparameter = "Fixed", fixvalue = 1), Trippa.tuning.inf =
    list(a = 10, b = 0.75))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Randomisation.inf_+3A_random.inf">Random.inf</code></td>
<td>
<p>A list of adaptive randomisation information.
'Fixratio' a indicator of whether the randomisation process uses fix ratio. Default is FALSE.
'Fixratiocontrol' the numerical value indicating the randomisation weight of the control arm compared to the treatment arms. Default is NA for Fixratio = FALSE.
'BARmethod' the Bayesian adaptive randomisation type. Default is &quot;Thall&quot; indicating the use of Thall's approach in the randomisation process. The other value is 'Trippa'.
'Thall.tuning.inf' the list of tuning parameter for Thall's approach including 'tuningparameter' (Default is &quot;Fixed&quot; indicating that the tuning paramter is fixed for all stages) and 'fixvalue' (Default is 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of input randomisation information
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Randomisation.inf(Random.inf = list(
Fixratio = FALSE,
Fixratiocontrol = NA,
BARmethod = "Thall",
Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1),
Trippa.tuning.inf = list(a = NA, b = NA)
))
</code></pre>

<hr>
<h2 id='recommandloginformd'>Cutoff screening example: the recommended grid value at each time point</h2><span id='topic+recommandloginformd'></span>

<h3>Description</h3>

<p>he recommended grid value at each time point. There are 20 cutoff value explored
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recommandloginformd
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 1 variables:
</p>

<dl>
<dt><code>recommandloginformd</code></dt><dd><p>The cutoff value at each time point</p>
</dd>
</dl>


<hr>
<h2 id='resultrtostats'>resultrtostats</h2><span id='topic+resultrtostats'></span>

<h3>Description</h3>

<p>This is an inner function of the function <code><a href="#topic+resultstantoRfunc">resultstantoRfunc</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultrtostats(
  trteff = NA,
  treatmentindex = NA,
  armleft,
  K,
  group,
  reg.inf,
  fit,
  ns
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resultrtostats_+3A_trteff">trteff</code></td>
<td>
<p>Stan posterior samples of treatment effect sample distribution</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>A vector of treatment index at the beginning of a trial</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_reg.inf">reg.inf</code></td>
<td>
<p>The information of how much accumulated information will be used</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_fit">fit</code></td>
<td>
<p>The stan output</p>
</td></tr>
<tr><td><code id="resultrtostats_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stan result inference
stats1: A vector of posterior probability for all treatment arms
including dropped and active treatment arm
stats4: The mean treatment effect estimate of each treatment compared to control
stats5: The variance of treatment effect estimate of each treatment compared to control
post.prob.btcontrol: a vector including Posterior probability
of each active treatment arm better than control
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: resultrtostats(trteff = NA, treatmentindex = NA, armleft, K, group, reg.inf, fit, ns)
</code></pre>

<hr>
<h2 id='resultrtostats.rand'>resultrtostats.rand</h2><span id='topic+resultrtostats.rand'></span>

<h3>Description</h3>

<p>The inner function of function <code><a href="#topic+resultstantoRfunc.rand">resultstantoRfunc.rand</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultrtostats.rand(
  trteff = NA,
  treatmentindex = NA,
  armleft,
  K,
  group,
  fit,
  ns
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resultrtostats.rand_+3A_trteff">trteff</code></td>
<td>
<p>Stan posterior samples of treatment effect sample distribution</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>A vector of treatment index at the beginning of a trial</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_fit">fit</code></td>
<td>
<p>The stan output</p>
</td></tr>
<tr><td><code id="resultrtostats.rand_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stan result inference
stats1: A vector of posterior probability for all treatment arms
including dropped and active treatment arm
stats4: The mean treatment effect estimate of each treatment compared to control
stats5: The variance of treatment effect estimate of each treatment compared to control
post.prob.btcontrol: a vector including Posterior probability
of each active treatment arm better than control
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: resultrtostats.rand(trteff = NA, treatmentindex = NA, armleft, K, group, fit, ns)
</code></pre>

<hr>
<h2 id='resultstantoRfunc'>resultstantoRfunc</h2><span id='topic+resultstantoRfunc'></span>

<h3>Description</h3>

<p>This function summarise the fix effect stan output data to and transform them to be readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultstantoRfunc(
  group,
  reg.inf,
  variable.inf,
  fit,
  armleft,
  treatmentindex,
  K,
  ns
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resultstantoRfunc_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_reg.inf">reg.inf</code></td>
<td>
<p>The information of how much accumulated information will be used</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_variable.inf">variable.inf</code></td>
<td>
<p>The information of whether to use random effect model or fix effect model.</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_fit">fit</code></td>
<td>
<p>The stan output</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>A vector of treatment index at the beginning of a trial</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="resultstantoRfunc_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stan result inference
stats1: A vector of posterior probability for all treatment arms
including dropped and active treatment arm
stats4: The mean treatment effect estimate of each treatment compared to control
stats5: The variance of treatment effect estimate of each treatment compared to control
post.prob.btcontrol: a vector including Posterior probability
of each active treatment arm better than control
stats6: A vector of mean stage (time trend) effect estimate
stats7: A vector of mean treatment - stage (time trend) interaction effect estimate
sampefftotal: The posterior samples of response probability
of each active arm on logit scale.
This can be transformed to probit scale by using inv.logit() function.
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: resultstantoRfunc(group, reg.inf, fit, armleft, treatmentindex, K, ns)
</code></pre>

<hr>
<h2 id='resultstantoRfunc.rand'>resultstantoRfunc.rand</h2><span id='topic+resultstantoRfunc.rand'></span>

<h3>Description</h3>

<p>This function summarise the mix effect stan output data to and transform them to be readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultstantoRfunc.rand(group, fit, armleft, treatmentindex, K, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resultstantoRfunc.rand_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="resultstantoRfunc.rand_+3A_fit">fit</code></td>
<td>
<p>The stan output</p>
</td></tr>
<tr><td><code id="resultstantoRfunc.rand_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="resultstantoRfunc.rand_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>A vector of treatment index at the beginning of a trial</p>
</td></tr>
<tr><td><code id="resultstantoRfunc.rand_+3A_k">K</code></td>
<td>
<p>Total number of arms at the beginning</p>
</td></tr>
<tr><td><code id="resultstantoRfunc.rand_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stan result inference
stats1: A vector of posterior probability for all treatment arms
including dropped and active treatment arm
stats4: The mean treatment effect estimate of each treatment compared to control
stats5: The variance of treatment effect estimate of each treatment compared to control
post.prob.btcontrol: a vector including Posterior probability
of each active treatment arm better than control
stats6: A vector of mean stage (time trend) effect estimate
stats7: A vector of mean treatment - stage (time trend) interaction effect estimate
sampefftotal: The posterior samples of response probability
of each active arm on logit scale.
This can be transformed to probit scale by using inv.logit() function.
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: resultstantoRfunc.rand(group, fit, armleft, treatmentindex, K, ns)
</code></pre>

<hr>
<h2 id='Save.resulttoRDatafile'>Save.resulttoRDatafile</h2><span id='topic+Save.resulttoRDatafile'></span>

<h3>Description</h3>

<p>This function generates the name of file for output table and dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Save.resulttoRDatafile(
  input.info = list(response.probs = c(0.4, 0.4), ns = c(30, 60, 90, 120, 150), max.ar =
    0.75, rand.type = "Urn", max.deviation = 3, model.inf = list(model = "tlr", ibb.inf =
    list(pi.star = 0.5, pess = 2, betabinomialmodel = ibetabinomial.post), tlr.inf =
    list(beta0_prior_mu = 0, beta1_prior_mu = 0, beta0_prior_sigma = 2.5,
    beta1_prior_sigma = 2.5, beta0_df = 7, beta1_df = 7, reg.inf = "main", variable.inf =
    "Fixeffect")), Stopbound.inf = Stopboundinf(Stop.type = "Early-Pocock", Boundary.type
    = "Symmetric", cutoff = c(0.99, 
     0.01)), Random.inf = list(Fixratio = FALSE,
    Fixratiocontrol = NA, BARmethod = "Thall", Thall.tuning.inf = list(tuningparameter =
    "Fixed", fixvalue = 1)), trend.inf = list(trend.type = "step", trend.effect = c(0,
    0), trend_add_or_multip = "mult"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Save.resulttoRDatafile_+3A_input.info">input.info</code></td>
<td>
<p>A list of input information require for trial simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of name for table and dataset
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Save.resulttoRDatafile(
input.info = list(
  response.probs = c(0.4, 0.4),
  ns = c(30, 60, 90, 120, 150),
  max.ar = 0.75,
  rand.type = "Urn",
  max.deviation = 3,
  model.inf = list(
    model = "tlr",
    ibb.inf = list(
      pi.star = 0.5,
      pess = 2,
      betabinomialmodel = ibetabinomial.post
    ),
    tlr.inf = list(
      beta0_prior_mu = 0,
      beta1_prior_mu = 0,
      beta0_prior_sigma = 2.5,
      beta1_prior_sigma = 2.5,
      beta0_df = 7,
      beta1_df = 7,
      reg.inf =  "main",
      variable.inf = "Fixeffect"
    )
  ),
  Stop.type = "Early-Pocock",
  Boundary.type = "Symmetric",
  Random.inf = list(
    Fixratio = FALSE,
    Fixratiocontrol = NA,
    BARmethod = "Thall",
    Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1)
  ),
  trend.inf = list(
    trend.type = "step",
    trend.effect = c(0, 0),
    trend_add_or_multip = "mult"
  )
))
</code></pre>

<hr>
<h2 id='simulatetrial'>simulatetrial</h2><span id='topic+simulatetrial'></span>

<h3>Description</h3>

<p>This function simulates a MAMS trial applying adaptive methods where the time trend effect can be studied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatetrial(
  ii,
  response.probs = c(0.4, 0.4),
  ns = c(30, 60, 90, 120, 150),
  test.type = "Twoside",
  max.ar = 0.75,
  rand.algo = "Urn",
  max.deviation = 3,
  model.inf = list(model = "tlr", ibb.inf = list(pi.star = 0.5, pess = 2,
    betabinomialmodel = ibetabinomial.post), tlr.inf = list(beta0_prior_mu = 0,
    beta1_prior_mu = 0, beta0_prior_sigma = 2.5, beta1_prior_sigma = 2.5, beta0_df = 7,
    beta1_df = 7, reg.inf = "main", variable.inf = "Fixeffect")),
  Stopbound.inf = Stopbound.inf,
  Random.inf = Random.inf,
  trend.inf = trend.inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatetrial_+3A_ii">ii</code></td>
<td>
<p>Meaning less parameter but required for foreach function in doParallel package</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_response.probs">response.probs</code></td>
<td>
<p>A vector of true response probability for each arm. Default response.probs = c(0.4, 0.4).</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_ns">ns</code></td>
<td>
<p>A vector of accumulated number of patient at each stage. Default is ns = c(30, 60, 90, 120, 150).</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_test.type">test.type</code></td>
<td>
<p>A indicator of whether to use one side test or two side test for each treatment-control comparison.</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_max.ar">max.ar</code></td>
<td>
<p>The upper boundary for randomisation ratio for each arm. Default is 0.75 for a two arm trial. The minimum value depends on K where 1 - max.ar &lt;= 1/K</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_rand.algo">rand.algo</code></td>
<td>
<p>The method of applying patient allocation with a given randomisation probability vector. Default is &quot;Urn&quot;.</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_max.deviation">max.deviation</code></td>
<td>
<p>The tuning parameter for Urn randomisation method. Default is 3.</p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_model.inf">model.inf</code></td>
<td>
<p>The list of interim data analysis model information for more see <code><a href="#topic+modelinf.fun">modelinf.fun</a></code></p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_stopbound.inf">Stopbound.inf</code></td>
<td>
<p>The list of stop boundary information for more see <code><a href="#topic+Stopboundinf">Stopboundinf</a></code></p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_random.inf">Random.inf</code></td>
<td>
<p>The list of Adaptive randomisation information for more see <code><a href="#topic+Randomisation.inf">Randomisation.inf</a></code></p>
</td></tr>
<tr><td><code id="simulatetrial_+3A_trend.inf">trend.inf</code></td>
<td>
<p>The list of time trend information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix including all evaluation metrics
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
simulatetrial(response.probs = c(0.4, 0.4),
               ns = c(30, 60, 90, 120, 150),
               max.ar = 0.75,
               test.type = "Twoside",
               rand.algo = "Urn",
               max.deviation = 3,
               model.inf = list(
               model = "tlr",
               ibb.inf = list(
               pi.star = 0.5,
               pess = 2,
               betabinomialmodel = ibetabinomial.post
               ),
               tlr.inf = list(
               beta0_prior_mu = 0,
               beta1_prior_mu = 0,
               beta0_prior_sigma = 2.5,
               beta1_prior_sigma = 2.5,
               beta0_df = 7,
               beta1_df = 7,
               reg.inf =  "main",
               variable.inf = "Fixeffect"
               )
               ),
               Stopbound.inf = Stopboundinf(
               Stop.type = "Early-Pocock",
               Boundary.type = "Symmetric",
               cutoff = c(0.99,0.01)
               ),
               Random.inf = list(
               Fixratio = FALSE,
               Fixratiocontrol = NA,
               BARmethod = "Thall",
               Thall.tuning.inf = list(tuningparameter = "Fixed",  fixvalue = 1),
               Trippa.tuning.inf = list(a = 10, b = 0.75)
               ),
               trend.inf = list(
               trend.type = "step",
               trend.effect = c(0, 0),
               trend_add_or_multip = "mult"
               ))
</code></pre>

<hr>
<h2 id='Sperarmfunc'>Sperarmfunc</h2><span id='topic+Sperarmfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate mean total number of survived patients of each arm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sperarmfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sperarmfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean total number of survived patients of each arm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: Sperarmfunc(res)
</code></pre>

<hr>
<h2 id='stan.logisticmodeltrans'>stan.logisticmodeltrans</h2><span id='topic+stan.logisticmodeltrans'></span>

<h3>Description</h3>

<p>This function transform the data in trial simulation to the data required for stan modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan.logisticmodeltrans(
  z,
  y,
  randomprob,
  group_indicator,
  armleft,
  group,
  variable.inf,
  reg.inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan.logisticmodeltrans_+3A_z">z</code></td>
<td>
<p>A vector of all treatment index data from the beginning of a trial</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_y">y</code></td>
<td>
<p>A vector of all outcome data from the beginning of a trial</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_randomprob">randomprob</code></td>
<td>
<p>A named vector of randomisation probability to each arm</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_group_indicator">group_indicator</code></td>
<td>
<p>A vector for the stage at which each patient was treated</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_armleft">armleft</code></td>
<td>
<p>The number of treatment left in the platform (&gt;2)</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_group">group</code></td>
<td>
<p>The current stage</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_variable.inf">variable.inf</code></td>
<td>
<p>Fixeffect/Mixeffect for logistic model parameter</p>
</td></tr>
<tr><td><code id="stan.logisticmodeltrans_+3A_reg.inf">reg.inf</code></td>
<td>
<p>The information of how much accumulated information will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information require for the stan model including:
zdropped: The vector of treatment index for each patient
whose treatment arm is active at current stage.
ydropped: The vector of outcome index for each patient
whose treatment arm is active at current stage.
Ndropped: The total number of patients
that are treated with active treatment arms at current stage.
group_indicator_dropped: The vector of stage index for each patient
whose treatment arm is active at current stage.
zlevel: The active treatment arm index at current stage
xdummy: A design matrix transformed from zdropped and group_indicator_dropped for modelling
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stan.logisticmodeltrans(
z = c(1,2,1,2,2,1,2,1),
y = c(0,0,0,0,1,1,1,1),
randomprob = matrix(c( 0.5, 0.5), ncol = 2, dimnames = list(c("Stage1"), c("1", "2"))),
group_indicator = c(1,1,1,1,1,1,1,1),
armleft = 2,
group = 1,
variable.inf = "Fixeffect",
reg.inf = "main")
</code></pre>

<hr>
<h2 id='Stopboundinf'>Stopboundinf</h2><span id='topic+Stopboundinf'></span>

<h3>Description</h3>

<p>This function summaries and checks stopping boundary information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stopboundinf(
  Stop.type = "Early-Pocock",
  Boundary.type = "Symmetric",
  cutoff = c(0.9928, 0.0072)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stopboundinf_+3A_stop.type">Stop.type</code></td>
<td>
<p>The type of stopping boundary should be &quot;Early-Pocock&quot;, &quot;Early-OBF&quot; and &quot;Noearly&quot;. Default is &quot;Early-Pocock&quot; which is the Pocock boundary with early stopping.</p>
</td></tr>
<tr><td><code id="Stopboundinf_+3A_boundary.type">Boundary.type</code></td>
<td>
<p>Whether the futility boundary and the efficacy boundary are the same conservative.
Default is &quot;Symmetric&quot; which means they are as conservative as each other.
Boundary.type = &quot;Asymmetric&quot; means that the efficacy boundary and the futility boundary are not as conservative as each other</p>
</td></tr>
<tr><td><code id="Stopboundinf_+3A_cutoff">cutoff</code></td>
<td>
<p>= c(cutoff1, cutoff2). A numerical vector of cutoff value for each boundary.
The first element is the efficacy boundary cutoff. The second element is the futility boundary cutoff
Pr(theta_1 &gt; theta_0|D_n) &gt; cutoff1. Should input the cutoff1 for efficacy boundary as the first element
Pr(theta_1 &lt; theta_0|D_n) &lt; cutoff2. Should input the cutoff2 for futility boundary as the first element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of information required for boundary construction function 'Stopbound.inf'
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Stop.type = "Early-Pocock" #(Pocock boundarty is a flat boundary across time)
Boundary.type = "Symmetric"
cutoff = c(0.9928, 0.0072)

Stopbound.inf = Stopboundinf(Stop.type, Boundary.type, cutoff)
#Stopbound.inf
#$Stop.type
# [1] "Early-Pocock"
#$Boundary.type
#[1] "Symmetric"
#$cutoff
# [1] 0.9928 0.0072
</code></pre>

<hr>
<h2 id='testing_and_armdropping'>testing_and_armdropping</h2><span id='topic+testing_and_armdropping'></span>

<h3>Description</h3>

<p>This function makes a decision on whether any active arm should be dropped based on posterior probability and
return the vector of decision on each arm, the vector of active arms index and the number of arms left for further study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing_and_armdropping(
  K,
  armleft,
  post.prob.btcontrol,
  group,
  cutoffeff,
  cutoffful,
  treatmentindex,
  test.type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testing_and_armdropping_+3A_k">K</code></td>
<td>
<p>A numeric value indicating the total number of arm at the beginning of trial including both control and treatment.</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_armleft">armleft</code></td>
<td>
<p>A numeric vector indicating the number of active arms before this interim analysis;</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_post.prob.btcontrol">post.prob.btcontrol</code></td>
<td>
<p>A numeric vector of posterior probability of each treatment arm better than control</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_group">group</code></td>
<td>
<p>A numeric value. The current stage index.</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_cutoffeff">cutoffeff</code></td>
<td>
<p>A numeric vector of the cutoff value at each stage for efficacy boundary.</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_cutoffful">cutoffful</code></td>
<td>
<p>A numeric vector of the cutoff value at each stage for futility boundary.</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_treatmentindex">treatmentindex</code></td>
<td>
<p>A numeric vector of the current active treatment arm index</p>
</td></tr>
<tr><td><code id="testing_and_armdropping_+3A_test.type">test.type</code></td>
<td>
<p>A character indicating which hypothesis testing we are use.
&quot;Oneside&quot;: H_0: \pi_k \leq \pi_0; H_0: \pi_k \&gt; \pi_0
&quot;Twoside&quot;: H_0: \pi_k \eq \pi_0; H_0: \pi_k \neq \pi_0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of information including armleft: the number of active arms after this interim analysis;
treatmentindex: the index vector of active arm after this interim analysis;
stats3: the vector of conclusion on whether null hypothesis is rejected
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testing_and_armdropping(
K = 4,
armleft = 4,
post.prob.btcontrol = c(0.5,0.99,0.02),
group = 3,
cutoffeff = c(1, 0.99, 0.975, 0.96, 0.95),
cutoffful = c(0, 0.01, 0.025, 0.04, 0.05),
treatmentindex = c(1,2,3),
test.type = "Oneside")

testing_and_armdropping(
K = 4,
armleft = 4,
post.prob.btcontrol = c(0.5,0.99,0.02),
group = 3,
cutoffeff = c(1, 0.99, 0.975, 0.96, 0.95),
cutoffful = c(0, 0.01, 0.025, 0.04, 0.05),
treatmentindex = c(1,2,3),
test.type = "Twoside")
</code></pre>

<hr>
<h2 id='Timetrend.fun'>Timetrend.fun</h2><span id='topic+Timetrend.fun'></span>

<h3>Description</h3>

<p>This function generate the time trend function based on trend information. This function also check the validity of the input time trend information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Timetrend.fun(trend.inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Timetrend.fun_+3A_trend.inf">trend.inf</code></td>
<td>
<p>The list of information for time trend effect including 'trend.type', 'trend.effect', 'trend_add_or_multip'.
'trend.type' is the shape of time trend. Default is &quot;step&quot;. Other types are &quot;linear&quot;, &quot;inverse.U.linear&quot;, &quot;plateau&quot;.
&quot;trend.effect&quot; the vector of the strength of time trend for each arm. The first element is for the control arm.
The value of time trend is the gap between the start of the trial and the end of the trial. The change between each interim or each patient is calculated in the function.
For example, for linear time trend with trend.effect = c(0.2, 0.2). The trend effect increment in control group for patient $i$ is 0.2(i-1)/(N_max-1), for stage $j$ is 0.2(j-1)/(length(ns)-1).
&quot;trend_add_or_multip&quot; the pattern of time trend affecting the true response probability. Default is &quot;mult&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the time trend function according to input trend.type variable,
and a indicator of whether there is a time trend in data generation
based on input trend information
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Timetrend.fun(trend.inf = list(
               trend.type = "step",
               trend.effect = c(0, 0),
               trend_add_or_multip = "mult"
               ))
</code></pre>

<hr>
<h2 id='Trial.simulation'>Trial simulation</h2><span id='topic+Trial.simulation'></span>

<h3>Description</h3>

<p>This function simulates and does final analysis of a trial with one scenario.
The time cost of this function depend on the cpu cores of the user's cpmputer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trial.simulation(
  ntrials = 5000,
  trial.fun = simulatetrial,
  input.info = list(response.probs = c(0.4, 0.4), ns = c(30, 60, 90, 120, 150), max.ar =
    0.75, test.type = "Twoside", rand.algo = "Urn", max.deviation = 3, model.inf =
    list(model = "tlr", ibb.inf = list(pi.star = 0.5, pess = 2, betabinomialmodel =
    ibetabinomial.post), tlr.inf = list(beta0_prior_mu = 0, beta1_prior_mu = 0,
    beta0_prior_sigma = 2.5, beta1_prior_sigma = 2.5, beta0_df = 7, beta1_df = 7, reg.inf
    = "main", variable.inf = "Fixeffect")), Stopbound.inf = Stopboundinf(Stop.type =
    "Early-Pocock", Boundary.type = "Symmetric", 
     cutoff = c(0.99, 0.01)),
    Random.inf = list(Fixratio = TRUE, Fixratiocontrol = 1, BARmethod = NA,
    Thall.tuning.inf = NA, Trippa.tuning.inf = NA), trend.inf = list(trend.type = "step",
    trend.effect = c(0, 0), trend_add_or_multip = "mult")),
  cl = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trial.simulation_+3A_ntrials">ntrials</code></td>
<td>
<p>A numeric variable indicating how many trial replicates you want to run. Default is 5000.</p>
</td></tr>
<tr><td><code id="Trial.simulation_+3A_trial.fun">trial.fun</code></td>
<td>
<p>The function of trial simulation for more see <code><a href="#topic+simulatetrial">simulatetrial</a></code></p>
</td></tr>
<tr><td><code id="Trial.simulation_+3A_input.info">input.info</code></td>
<td>
<p>A list of input information including all information required for trial simulation.</p>
</td></tr>
<tr><td><code id="Trial.simulation_+3A_cl">cl</code></td>
<td>
<p>A numeric variable indicating how many cores you want to use in parallel programming.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of output including the final output of each trial replicates called 'result'
The analysis result table of the specific trial called 'OPC' and the file name for saving these output on the computer
</p>


<h3>Author(s)</h3>

<p>Ziyan Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Trial.simulation(ntrials = 2, cl = 2)
</code></pre>

<hr>
<h2 id='trtbias'>trtbias</h2><span id='topic+trtbias'></span>

<h3>Description</h3>

<p>This function estimates the mean bias of treatment effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trtbias(res, trueeffect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trtbias_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
<tr><td><code id="trtbias_+3A_trueeffect">trueeffect</code></td>
<td>
<p>A vector of true treatment effect in each scenario</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of mean treatment effect bias
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: trtbias(res, trueeffect)
</code></pre>

<hr>
<h2 id='trteffect'>trteffect</h2><span id='topic+trteffect'></span>

<h3>Description</h3>

<p>This function estimates the mean treatment effect bias and its rooted mean squared error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trteffect(res, trueeff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trteffect_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
<tr><td><code id="trteffect_+3A_trueeff">trueeff</code></td>
<td>
<p>A vector of true treatment effect in each scenario</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mean treatment effect bias and its rooted mean squared error
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: trteffect(res, trueeff)
</code></pre>

<hr>
<h2 id='varfunc'>varfunc</h2><span id='topic+varfunc'></span>

<h3>Description</h3>

<p>This function reads in the output matrix of a number of trial replicates to calculate the variance of treatment effect estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varfunc(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfunc_+3A_res">res</code></td>
<td>
<p>A list of output matrix of a number of trial replicates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of Treatment effect estimates of each treatment arm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: varfunc(res)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
