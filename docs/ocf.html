<!DOCTYPE html><html><head><title>Help for package ocf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ocf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_alpha'><p>Check Argument alpha</p></a></li>
<li><a href='#check_honesty_inference'><p>Check Arguments honesty, honesty.fraction and inference</p></a></li>
<li><a href='#check_maxdepth'><p>Check Argument max.depth</p></a></li>
<li><a href='#check_minnodesize'><p>Check Argument min.node.size</p></a></li>
<li><a href='#check_mtry'><p>Check Argument mtry</p></a></li>
<li><a href='#check_ntrees'><p>Check Argument n.trees</p></a></li>
<li><a href='#check_samplefraction'><p>Check Argument sample.fraction</p></a></li>
<li><a href='#check_x_y'><p>Check Arguments x and y</p></a></li>
<li><a href='#class_honest_split'><p>Honest Sample Split</p></a></li>
<li><a href='#forest_weights_fitted'><p>Forest In-Sample Honest Weights</p></a></li>
<li><a href='#forest_weights_fitted_cpp'><p>Forest In-Sample Honest Weights</p></a></li>
<li><a href='#forest_weights_predicted_cpp'><p>Forest Out-of-Sample Honest Weights</p></a></li>
<li><a href='#honest_fitted'><p>Honest In-Sample Predictions</p></a></li>
<li><a href='#honest_fitted_cpp'><p>Honest In-Sample Predictions</p></a></li>
<li><a href='#honest_predictions'><p>Honest Out-of-Sample Predictions</p></a></li>
<li><a href='#honest_predictions_cpp'><p>Honest Out-of-Sample Predictions</p></a></li>
<li><a href='#marginal_effects'><p>Marginal Effects for Ordered Correlation Forest</p></a></li>
<li><a href='#mean_squared_error'><p>Accuracy Measures for Ordered Probability Predictions</p></a></li>
<li><a href='#multinomial_ml'><p>Multinomial Machine Learning</p></a></li>
<li><a href='#ocf'><p>Ordered Correlation Forest</p></a></li>
<li><a href='#ordered_ml'><p>Ordered Machine Learning</p></a></li>
<li><a href='#predict_forest_weights'><p>Forest Out-of-Sample Weights</p></a></li>
<li><a href='#predict.mml'><p>Prediction Method for mml Objects</p></a></li>
<li><a href='#predict.ocf'><p>Prediction Method for ocf Objects</p></a></li>
<li><a href='#predict.ocf.forest'><p>Prediction Method for ocf.forest Objects</p></a></li>
<li><a href='#predict.oml'><p>Prediction Method for oml Objects</p></a></li>
<li><a href='#print.ocf'><p>Print Method for ocf Objects</p></a></li>
<li><a href='#print.ocf.marginal'><p>Print Method for ocf.marginal Objects</p></a></li>
<li><a href='#rename_latex'><p>Renaming Variables for LATEX Usage</p></a></li>
<li><a href='#summary.ocf'><p>Summary Method for ocf Objects</p></a></li>
<li><a href='#summary.ocf.marginal'><p>Summary Method for ocf.marginal Objects</p></a></li>
<li><a href='#tree_info'><p>Tree Information in Readable Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ordered Correlation Forest</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric estimator for ordered non-numeric outcomes. The estimator modifies a
    standard random forest splitting criterion to build a collection of forests, each estimating the conditional 
    probability of a single class. The package also implements a nonparametric estimator of the covariatesâ€™ marginal effects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix, stats, utils, stringr, orf, glmnet, ranger</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://riccardo-df.github.io/ocf/">https://riccardo-df.github.io/ocf/</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 18:42:58 UTC; difra</td>
</tr>
<tr>
<td>Author:</td>
<td>Riccardo Di Francesco [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Riccardo Di Francesco &lt;difrancesco.riccardo96@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-14 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_alpha'>Check Argument alpha</h2><span id='topic+check_alpha'></span>

<h3>Description</h3>

<p>Check Argument alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_alpha(alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_alpha_+3A_alpha">alpha</code></td>
<td>
<p>Fraction of observations that must lie on each side of each split.</p>
</td></tr>
</table>

<hr>
<h2 id='check_honesty_inference'>Check Arguments honesty, honesty.fraction and inference</h2><span id='topic+check_honesty_inference'></span>

<h3>Description</h3>

<p>Check Arguments honesty, honesty.fraction and inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_honesty_inference(honesty, honesty.fraction, inference)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_honesty_inference_+3A_honesty">honesty</code></td>
<td>
<p>Whether to grow honest forests.</p>
</td></tr>
<tr><td><code id="check_honesty_inference_+3A_honesty.fraction">honesty.fraction</code></td>
<td>
<p>Fraction of honest sample.</p>
</td></tr>
<tr><td><code id="check_honesty_inference_+3A_inference">inference</code></td>
<td>
<p>Whether to conduct weight-based inference.</p>
</td></tr>
</table>

<hr>
<h2 id='check_maxdepth'>Check Argument max.depth</h2><span id='topic+check_maxdepth'></span>

<h3>Description</h3>

<p>Check Argument max.depth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_maxdepth(max.depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_maxdepth_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximal tree depth. A value of 0 corresponds to unlimited depth, 1 to &quot;stumps&quot; (one split per tree).</p>
</td></tr>
</table>

<hr>
<h2 id='check_minnodesize'>Check Argument min.node.size</h2><span id='topic+check_minnodesize'></span>

<h3>Description</h3>

<p>Check Argument min.node.size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_minnodesize(min.node.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_minnodesize_+3A_min.node.size">min.node.size</code></td>
<td>
<p>Minimal node size.</p>
</td></tr>
</table>

<hr>
<h2 id='check_mtry'>Check Argument mtry</h2><span id='topic+check_mtry'></span>

<h3>Description</h3>

<p>Check Argument mtry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_mtry(mtry, nv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_mtry_+3A_mtry">mtry</code></td>
<td>
<p>Number of covariates to possibly split at in each node. Default is the (rounded down) square root of the number of covariates. Alternatively, one can pass a single-argument function returning an integer, where the argument is the number of covariates.</p>
</td></tr>
<tr><td><code id="check_mtry_+3A_nv">nv</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Appropriate value of <code>mtry</code>.
</p>

<hr>
<h2 id='check_ntrees'>Check Argument n.trees</h2><span id='topic+check_ntrees'></span>

<h3>Description</h3>

<p>Check Argument n.trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ntrees(n.trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ntrees_+3A_n.trees">n.trees</code></td>
<td>
<p>Number of trees.</p>
</td></tr>
</table>

<hr>
<h2 id='check_samplefraction'>Check Argument sample.fraction</h2><span id='topic+check_samplefraction'></span>

<h3>Description</h3>

<p>Check Argument sample.fraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_samplefraction(sample.fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_samplefraction_+3A_sample.fraction">sample.fraction</code></td>
<td>
<p>Fraction of observations to sample.</p>
</td></tr>
</table>

<hr>
<h2 id='check_x_y'>Check Arguments x and y</h2><span id='topic+check_x_y'></span>

<h3>Description</h3>

<p>Check Arguments x and y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_x_y(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_x_y_+3A_x">x</code></td>
<td>
<p>Covariate matrix (no intercept).</p>
</td></tr>
<tr><td><code id="check_x_y_+3A_y">y</code></td>
<td>
<p>Outcome vector.</p>
</td></tr>
</table>

<hr>
<h2 id='class_honest_split'>Honest Sample Split</h2><span id='topic+class_honest_split'></span>

<h3>Description</h3>

<p>Randomly spits the sample into a training sample and an honest sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_honest_split(data, honesty.fraction = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="class_honest_split_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> to be split. The outcome must be located in the first column.</p>
</td></tr>
<tr><td><code id="class_honest_split_+3A_honesty.fraction">honesty.fraction</code></td>
<td>
<p>Fraction of honest sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>class_honest_split</code> looks for balanced splits, i.e., splits such as all the outcome's classes are represented
in both the training and the honest sample. After 100 trials, the program throws an error.
</p>


<h3>Value</h3>

<p>List with elements:
</p>
<table>
<tr><td><code>train_sample</code></td>
<td>
<p>Training sample.</p>
</td></tr>
<tr><td><code>honest_sample</code></td>
<td>
<p>Honest sample.</p>
</td></tr>
</table>

<hr>
<h2 id='forest_weights_fitted'>Forest In-Sample Honest Weights</h2><span id='topic+forest_weights_fitted'></span>

<h3>Description</h3>

<p>Computes forest in-sample honest weights for an <code>ocf.forest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest_weights_fitted(forest, honest_sample, train_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest_weights_fitted_+3A_forest">forest</code></td>
<td>
<p>An <code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="forest_weights_fitted_+3A_honest_sample">honest_sample</code></td>
<td>
<p>Honest sample.</p>
</td></tr>
<tr><td><code id="forest_weights_fitted_+3A_train_sample">train_sample</code></td>
<td>
<p>Training sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forest</code> must have been grown using only the training sample.
</p>


<h3>Value</h3>

<p>Matrix of in-sample honest weights.
</p>

<hr>
<h2 id='forest_weights_fitted_cpp'>Forest In-Sample Honest Weights</h2><span id='topic+forest_weights_fitted_cpp'></span>

<h3>Description</h3>

<p>Computes forest in-sample honest weights for a <code>ocf.forest</code> object relative to the m-th class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest_weights_fitted_cpp(
  leaf_IDs_train_list,
  leaf_IDs_honest_list,
  leaf_size_honest_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest_weights_fitted_cpp_+3A_leaf_ids_train_list">leaf_IDs_train_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the leaf of each tree where training units fall into.</p>
</td></tr>
<tr><td><code id="forest_weights_fitted_cpp_+3A_leaf_ids_honest_list">leaf_IDs_honest_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the leaf of each tree where honest units fall into.</p>
</td></tr>
<tr><td><code id="forest_weights_fitted_cpp_+3A_leaf_size_honest_list">leaf_size_honest_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the size of the leaves of each tree computed with honest units.</p>
</td></tr>
</table>

<hr>
<h2 id='forest_weights_predicted_cpp'>Forest Out-of-Sample Honest Weights</h2><span id='topic+forest_weights_predicted_cpp'></span>

<h3>Description</h3>

<p>Computes forest out-of-sample honest weights for a <code>ocf.forest</code> object relative to the m-th class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest_weights_predicted_cpp(
  leaf_IDs_test_list,
  leaf_IDs_honest_list,
  leaf_size_honest_list,
  w
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest_weights_predicted_cpp_+3A_leaf_ids_test_list">leaf_IDs_test_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the leaf of each tree where training units fall into.</p>
</td></tr>
<tr><td><code id="forest_weights_predicted_cpp_+3A_leaf_ids_honest_list">leaf_IDs_honest_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the leaf of each tree where honest units fall into.</p>
</td></tr>
<tr><td><code id="forest_weights_predicted_cpp_+3A_leaf_size_honest_list">leaf_size_honest_list</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the size of the leaves of each tree computed with honest units.</p>
</td></tr>
<tr><td><code id="forest_weights_predicted_cpp_+3A_w">w</code></td>
<td>
<p>1 if marginal effects are being computed, 0 otherwise for normal prediction.</p>
</td></tr>
</table>

<hr>
<h2 id='honest_fitted'>Honest In-Sample Predictions</h2><span id='topic+honest_fitted'></span>

<h3>Description</h3>

<p>Computes honest in-sample predictions for an <code>ocf.forest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>honest_fitted(forest, train_sample, honest_sample, y_m_honest, y_m_1_honest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="honest_fitted_+3A_forest">forest</code></td>
<td>
<p>An <code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="honest_fitted_+3A_train_sample">train_sample</code></td>
<td>
<p>Training sample.</p>
</td></tr>
<tr><td><code id="honest_fitted_+3A_honest_sample">honest_sample</code></td>
<td>
<p>Honest sample.</p>
</td></tr>
<tr><td><code id="honest_fitted_+3A_y_m_honest">y_m_honest</code></td>
<td>
<p>Indicator variable, whether the outcome is smaller than or equal to the m-th class.</p>
</td></tr>
<tr><td><code id="honest_fitted_+3A_y_m_1_honest">y_m_1_honest</code></td>
<td>
<p>Indicator variable, whether the outcome is smaller than or equal to the (m-1)-th class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forest</code> must have been grown using only the training sample. <code>honest_fitted</code> replaces the leaf estimates 
using the outcome from the honest sample (using the prediction method of <code><a href="#topic+ocf">ocf</a></code>).
</p>


<h3>Value</h3>

<p>In-sample honest predictions.
</p>

<hr>
<h2 id='honest_fitted_cpp'>Honest In-Sample Predictions</h2><span id='topic+honest_fitted_cpp'></span>

<h3>Description</h3>

<p>Computes honest in-sample predictions for a ocf.forest object relative to the desired class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>honest_fitted_cpp(
  unique_leaves_honest,
  y_m,
  y_m_1,
  honest_leaves,
  train_leaves
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="honest_fitted_cpp_+3A_unique_leaves_honest">unique_leaves_honest</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the unique leaf ids of each tree relative to the honest sample.</p>
</td></tr>
<tr><td><code id="honest_fitted_cpp_+3A_y_m">y_m</code></td>
<td>
<p>Indicator variable, equal to 1 if the <code>y</code> is lower or equal than the m-th class and zero otherwise.</p>
</td></tr>
<tr><td><code id="honest_fitted_cpp_+3A_y_m_1">y_m_1</code></td>
<td>
<p>Indicator variable, equal to 1 if the <code>y</code> is lower or equal than the (m-1)-th class and zero otherwise.</p>
</td></tr>
<tr><td><code id="honest_fitted_cpp_+3A_honest_leaves">honest_leaves</code></td>
<td>
<p>Matrix of size (<code>n.samples</code> x <code>n.trees</code>). The i-th row stores the id of the leaf where the i-th honest observation falls in each tree.</p>
</td></tr>
<tr><td><code id="honest_fitted_cpp_+3A_train_leaves">train_leaves</code></td>
<td>
<p>Matrix of size (<code>n.samples</code> x <code>n.trees</code>). The i-th row stores the id of the leaf where the i-th training observation falls in each tree.</p>
</td></tr>
</table>

<hr>
<h2 id='honest_predictions'>Honest Out-of-Sample Predictions</h2><span id='topic+honest_predictions'></span>

<h3>Description</h3>

<p>Computes honest out-of-sample predictions for an <code>ocf.forest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>honest_predictions(
  forest,
  honest_sample,
  test_sample,
  y_m_honest,
  y_m_1_honest
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="honest_predictions_+3A_forest">forest</code></td>
<td>
<p><code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="honest_predictions_+3A_honest_sample">honest_sample</code></td>
<td>
<p>Honest sample.</p>
</td></tr>
<tr><td><code id="honest_predictions_+3A_test_sample">test_sample</code></td>
<td>
<p>Test sample.</p>
</td></tr>
<tr><td><code id="honest_predictions_+3A_y_m_honest">y_m_honest</code></td>
<td>
<p>Indicator variable, whether the outcome is smaller than or equal to the m-th class.</p>
</td></tr>
<tr><td><code id="honest_predictions_+3A_y_m_1_honest">y_m_1_honest</code></td>
<td>
<p>Indicator variable, whether the outcome is smaller than or equal to the (m-1)-th class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>honest_predictions</code> replaces the leaf estimates of <code>forest</code> using the outcome from the associated 
honest sample (using the prediction method of <code><a href="#topic+ocf">ocf</a></code>). The honest sample must not have been used
to build the trees.
</p>


<h3>Value</h3>

<p>Out-of-sample honest predictions.
</p>

<hr>
<h2 id='honest_predictions_cpp'>Honest Out-of-Sample Predictions</h2><span id='topic+honest_predictions_cpp'></span>

<h3>Description</h3>

<p>Computes honest out-of-sample predictions for a ocf.forest object relative to the desired class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>honest_predictions_cpp(
  unique_leaves_honest,
  y_m,
  y_m_1,
  honest_leaves,
  test_leaves
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="honest_predictions_cpp_+3A_unique_leaves_honest">unique_leaves_honest</code></td>
<td>
<p>List of size <code>n.trees</code>, storing the unique leaf ids of each tree relative to the honest sample.</p>
</td></tr>
<tr><td><code id="honest_predictions_cpp_+3A_y_m">y_m</code></td>
<td>
<p>Indicator variable, equal to 1 if the <code>y</code> is lower or equal than the m-th class and zero otherwise.</p>
</td></tr>
<tr><td><code id="honest_predictions_cpp_+3A_y_m_1">y_m_1</code></td>
<td>
<p>Indicator variable, equal to 1 if the <code>y</code> is lower or equal than the (m-1)-th class and zero otherwise.</p>
</td></tr>
<tr><td><code id="honest_predictions_cpp_+3A_honest_leaves">honest_leaves</code></td>
<td>
<p>Matrix of size (<code>n.samples</code> x <code>n.trees</code>). The i-th row stores the id of the leaf where the i-th honest observation falls in each tree.</p>
</td></tr>
<tr><td><code id="honest_predictions_cpp_+3A_test_leaves">test_leaves</code></td>
<td>
<p>Matrix of size (<code>n.samples</code> x <code>n.trees</code>). The i-th row stores the id of the leaf where the i-th test observation falls in each tree.</p>
</td></tr>
</table>

<hr>
<h2 id='marginal_effects'>Marginal Effects for Ordered Correlation Forest</h2><span id='topic+marginal_effects'></span>

<h3>Description</h3>

<p>Nonparametric estimation of marginal effects using an <code><a href="#topic+ocf">ocf</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_effects(
  object,
  data = NULL,
  which_covariates = c(),
  eval = "atmean",
  bandwitdh = 0.1,
  inference = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_effects_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ocf">ocf</a></code> object.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_data">data</code></td>
<td>
<p>Data set of class <code>data.frame</code> to estimate marginal effects. It must contain at least the same covariates used to train the forests. If <code>NULL</code>, marginal effects are estimated on <code>object$full_data</code>.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_which_covariates">which_covariates</code></td>
<td>
<p>Character vector storing the names of the covariates for which marginal effect estimation is desired. If empty (the default), marginal effects are estimated for all covariates.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_eval">eval</code></td>
<td>
<p>Evaluation point for marginal effects. Either <code>"mean"</code>, <code>"atmean"</code> or <code>"atmedian"</code>.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_bandwitdh">bandwitdh</code></td>
<td>
<p>How many standard deviations <code>x_up</code> and <code>x_down</code> differ from <code>x</code>.</p>
</td></tr>
<tr><td><code id="marginal_effects_+3A_inference">inference</code></td>
<td>
<p>Whether to extract weights and compute standard errors. The weights extraction considerably slows down the program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+marginal_effects">marginal_effects</a></code> can estimate mean marginal effects, marginal effects at the mean, or marginal effects at the
median, according to the <code>eval</code> argument.<br /> 
</p>
<p>The routine assumes that covariates with more than ten unique values are continuous. Otherwise, covariates are assumed to 
be discrete.<br />
</p>


<h3>Value</h3>

<p>Object of class <code>ocf.marginal</code>.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf. Use large number of trees.
forests &lt;- ocf(y, X, n.trees = 4000)

## Marginal effects at the mean.
me &lt;- marginal_effects(forests, eval = "atmean")
print(me)
summary(me)

## LATEX.
print(me, latex = TRUE)

## Compute standard errors. This requires honest forests.
honest_forests &lt;- ocf(y, X, n.trees = 4000, honesty = TRUE)
honest_me &lt;- marginal_effects(honest_forests, eval = "atmean", inference = TRUE)
honest_me$standard.errors
honest_me$p.values # These are not corrected for multiple hypotheses testing!

print(honest_me, latex = TRUE)

</code></pre>

<hr>
<h2 id='mean_squared_error'>Accuracy Measures for Ordered Probability Predictions</h2><span id='topic+mean_squared_error'></span><span id='topic+mean_absolute_error'></span><span id='topic+mean_ranked_score'></span><span id='topic+classification_error'></span>

<h3>Description</h3>

<p>Accuracy measures for evaluating ordered probability predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_squared_error(y, predictions, use.true = FALSE)

mean_absolute_error(y, predictions, use.true = FALSE)

mean_ranked_score(y, predictions, use.true = FALSE)

classification_error(y, predictions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_squared_error_+3A_y">y</code></td>
<td>
<p>Either the observed outcome vector or a matrix of true probabilities.</p>
</td></tr>
<tr><td><code id="mean_squared_error_+3A_predictions">predictions</code></td>
<td>
<p>Predictions.</p>
</td></tr>
<tr><td><code id="mean_squared_error_+3A_use.true">use.true</code></td>
<td>
<p>If <code>TRUE</code>, then the program treats <code>y</code> as a matrix of true probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>MSE, MAE, and RPS</h4>

<p>When calling one of <code><a href="#topic+mean_squared_error">mean_squared_error</a></code>, <code><a href="#topic+mean_absolute_error">mean_absolute_error</a></code>, or <code><a href="#topic+mean_ranked_score">mean_ranked_score</a></code>,
<code>predictions</code> must be a matrix of predicted  class probabilities, with as many rows as observations in <code>y</code> and as
many columns as classes of <code>y</code>.<br />
</p>
<p>If <code>use.true == FALSE</code>, the mean squared error (MSE), the mean absolute error (MAE), and the mean ranked probability score
(RPS) are computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">MSE = \frac{1}{n} \sum_{i = 1}^n \sum_{m = 1}^M (1 (Y_i = m) - \hat{p}_m (x))^2</code>
</p>

<p style="text-align: center;"><code class="reqn">MAE = \frac{1}{n} \sum_{i = 1}^n \sum_{m = 1}^M |1 (Y_i = m) - \hat{p}_m (x)|</code>
</p>

<p style="text-align: center;"><code class="reqn">RPS = \frac{1}{n} \sum_{i = 1}^n \frac{1}{M - 1} \sum_{m = 1}^M (1 (Y_i \leq m) - \hat{p}_m^* (x))^2</code>
</p>

<p>If <code>use.true == TRUE</code>, the MSE, the MAE, and the RPS are computed as follows (useful for simulation studies):
</p>
<p style="text-align: center;"><code class="reqn">MSE = \frac{1}{n} \sum_{i = 1}^n \sum_{m = 1}^M (p_m (x) - \hat{p}_m (x))^2</code>
</p>

<p style="text-align: center;"><code class="reqn">MSE = \frac{1}{n} \sum_{i = 1}^n \sum_{m = 1}^M |p_m (x) - \hat{p}_m (x)|</code>
</p>

<p style="text-align: center;"><code class="reqn">RPS = \frac{1}{n} \sum_{i = 1}^n \frac{1}{M - 1} \sum_{m = 1}^M (p_m^* (x) - \hat{p}_m^* (x))^2</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">p_m (x) = P(Y_i = m | X_i = x)</code>
</p>

<p style="text-align: center;"><code class="reqn">p_m^* (x) = P(Y_i \leq m | X_i = x)</code>
</p>




<h4>Classification error</h4>

<p>When calling <code><a href="#topic+classification_error">classification_error</a></code>, <code>predictions</code> must be a vector of predicted class labels.<br />
</p>
<p>Classification error (CE) is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">CE = \frac{1}{n} \sum_{i = 1}^n 1 (Y_i \neq \hat{Y}_i)</code>
</p>

<p>where Y_i are the observed class labels.
</p>



<h3>Value</h3>

<p>The MSE, the MAE, the RPS, or the CE of the method.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_ranked_score">mean_ranked_score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit ocf on training sample.
forests &lt;- ocf(y_tr, X_tr)

## Accuracy measures on test sample.
predictions &lt;- predict(forests, X_test)

mean_squared_error(y_test, predictions$probabilities)
mean_ranked_score(y_test, predictions$probabilities)
classification_error(y_test, predictions$classification)

</code></pre>

<hr>
<h2 id='multinomial_ml'>Multinomial Machine Learning</h2><span id='topic+multinomial_ml'></span>

<h3>Description</h3>

<p>Estimation strategy to estimate conditional choice probabilities for ordered non-numeric outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial_ml(y = NULL, X = NULL, learner = "forest", scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomial_ml_+3A_y">y</code></td>
<td>
<p>Outcome vector.</p>
</td></tr>
<tr><td><code id="multinomial_ml_+3A_x">X</code></td>
<td>
<p>Covariate matrix (no intercept).</p>
</td></tr>
<tr><td><code id="multinomial_ml_+3A_learner">learner</code></td>
<td>
<p>String, either <code>"forest"</code> or <code>"l1"</code>. Selects the base learner to estimate each expectation.</p>
</td></tr>
<tr><td><code id="multinomial_ml_+3A_scale">scale</code></td>
<td>
<p>Logical, whether to scale the covariates. Ignored if <code>learner</code> is not <code>"l1"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multinomial machine learning expresses conditional choice probabilities as expectations of binary variables:
</p>
<p style="text-align: center;"><code class="reqn">p_m \left( X_i \right) = \mathbb{E} \left[ 1 \left( Y_i = m \right) | X_i \right]</code>
</p>

<p>This allows us to estimate each expectation separately using any regression algorithm to get an estimate of conditional probabilities.<br />
</p>
<p><code><a href="#topic+multinomial_ml">multinomial_ml</a></code> combines this strategy with either regression forests or penalized logistic regression with an L1 penalty,
according to the user-specified parameter <code>learner</code>.<br />
</p>
<p>If <code>learner == "l1"</code>, the penalty parameters are chosen via 10-fold cross-validation 
and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> is used to handle non-numeric covariates. Additionally, if <code>scale == TRUE</code>, the covariates are scaled to 
have zero mean and unit variance.
</p>


<h3>Value</h3>

<p>Object of class <code>mml</code>.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordered_ml">ordered_ml</a></code>, <code><a href="#topic+ocf">ocf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit multinomial machine learning on training sample using two different learners.
multinomial_forest &lt;- multinomial_ml(y_tr, X_tr, learner = "forest")
multinomial_l1 &lt;- multinomial_ml(y_tr, X_tr, learner = "l1")

## Predict out of sample.
predictions_forest &lt;- predict(multinomial_forest, X_test)
predictions_l1 &lt;- predict(multinomial_l1, X_test)

## Compare predictions.
cbind(head(predictions_forest), head(predictions_l1))

</code></pre>

<hr>
<h2 id='ocf'>Ordered Correlation Forest</h2><span id='topic+ocf'></span>

<h3>Description</h3>

<p>Nonparametric estimator for ordered non-numeric outcomes. The estimator modifies a standard random forest
splitting criterion to build a collection of forests, each estimating the conditional probability of a single class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocf(
  y = NULL,
  X = NULL,
  honesty = FALSE,
  honesty.fraction = 0.5,
  inference = FALSE,
  alpha = 0,
  n.trees = 2000,
  mtry = ceiling(sqrt(ncol(X))),
  min.node.size = 5,
  max.depth = 0,
  replace = FALSE,
  sample.fraction = ifelse(replace, 1, 0.5),
  n.threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocf_+3A_y">y</code></td>
<td>
<p>Outcome vector.</p>
</td></tr>
<tr><td><code id="ocf_+3A_x">X</code></td>
<td>
<p>Covariate matrix (no intercept).</p>
</td></tr>
<tr><td><code id="ocf_+3A_honesty">honesty</code></td>
<td>
<p>Whether to grow honest forests.</p>
</td></tr>
<tr><td><code id="ocf_+3A_honesty.fraction">honesty.fraction</code></td>
<td>
<p>Fraction of honest sample. Ignored if <code>honesty = FALSE</code>.</p>
</td></tr>
<tr><td><code id="ocf_+3A_inference">inference</code></td>
<td>
<p>Whether to extract weights and compute standard errors. The weights extraction considerably slows down the routine. <code>honesty = TRUE</code> is required for valid inference.</p>
</td></tr>
<tr><td><code id="ocf_+3A_alpha">alpha</code></td>
<td>
<p>Controls the balance of each split. Each split leaves at least a fraction <code>alpha</code> of observations in the parent node on each side of the split.</p>
</td></tr>
<tr><td><code id="ocf_+3A_n.trees">n.trees</code></td>
<td>
<p>Number of trees.</p>
</td></tr>
<tr><td><code id="ocf_+3A_mtry">mtry</code></td>
<td>
<p>Number of covariates to possibly split at in each node. Default is the square root of the number of covariates.</p>
</td></tr>
<tr><td><code id="ocf_+3A_min.node.size">min.node.size</code></td>
<td>
<p>Minimal node size.</p>
</td></tr>
<tr><td><code id="ocf_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximal tree depth. A value of 0 corresponds to unlimited depth, 1 to &quot;stumps&quot; (one split per tree).</p>
</td></tr>
<tr><td><code id="ocf_+3A_replace">replace</code></td>
<td>
<p>If <code>TRUE</code>, grow trees on bootstrap subsamples. Otherwise, trees are grown on random subsamples drawn without replacement.</p>
</td></tr>
<tr><td><code id="ocf_+3A_sample.fraction">sample.fraction</code></td>
<td>
<p>Fraction of observations to sample.</p>
</td></tr>
<tr><td><code id="ocf_+3A_n.threads">n.threads</code></td>
<td>
<p>Number of threads. Zero corresponds to the number of CPUs available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>ocf</code>.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginal_effects">marginal_effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit ocf on training sample.
forests &lt;- ocf(y_tr, X_tr)

## We have compatibility with generic S3-methods.
print(forests)
summary(forests)
predictions &lt;- predict(forests, X_test)
head(predictions$probabilities)
table(y_test, predictions$classification)

## Compute standard errors. This requires honest forests.
honest_forests &lt;- ocf(y_tr, X_tr, honesty = TRUE, inference = TRUE)
head(honest_forests$predictions$standard.errors)

</code></pre>

<hr>
<h2 id='ordered_ml'>Ordered Machine Learning</h2><span id='topic+ordered_ml'></span>

<h3>Description</h3>

<p>Estimation strategy to estimate conditional choice probabilities for ordered non-numeric outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordered_ml(y = NULL, X = NULL, learner = "forest", scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordered_ml_+3A_y">y</code></td>
<td>
<p>Outcome vector.</p>
</td></tr>
<tr><td><code id="ordered_ml_+3A_x">X</code></td>
<td>
<p>Covariate matrix (no intercept).</p>
</td></tr>
<tr><td><code id="ordered_ml_+3A_learner">learner</code></td>
<td>
<p>String, either <code>"forest"</code> or <code>"l1"</code>. Selects the base learner to estimate each expectation.</p>
</td></tr>
<tr><td><code id="ordered_ml_+3A_scale">scale</code></td>
<td>
<p>Logical, whether to scale the covariates. Ignored if <code>learner</code> is not <code>"l1"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordered machine learning expresses conditional choice probabilities as the difference between the cumulative probabilities 
of two adjacent classes, which in turn can be expressed as conditional expectations of binary variables:
</p>
<p style="text-align: center;"><code class="reqn">p_m \left( X_i \right) = \mathbb{E} \left[ 1 \left( Y_i \leq m \right) | X_i \right] - \mathbb{E} \left[ 1 \left( Y_i \leq m - 1 \right) | X_i \right]</code>
</p>

<p>Then we can separately estimate each expectation using any regression algorithm and pick the difference between the m-th and the
(m-1)-th estimated surfaces to estimate conditional probabilities.<br />
</p>
<p><code><a href="#topic+ordered_ml">ordered_ml</a></code> combines this strategy with either regression forests or penalized logistic regression with an L1 penalty,
according to the user-specified parameter <code>learner</code>.<br />
</p>
<p>If <code>learner == "forest"</code>, then the <code><a href="orf.html#topic+orf">orf</a></code>
function is called from an external package, as this estimator has already been proposed by Lechner and Okasa (2019).<br />
</p>
<p>If <code>learner == "l1"</code>, 
the penalty parameters are chosen via 10-fold cross-validation and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> is used to handle non-numeric covariates. 
Additionally, if <code>scale == TRUE</code>, the covariates are scaled to have zero mean and unit variance.
</p>


<h3>Value</h3>

<p>Object of class <code>oml</code>.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinomial_ml">multinomial_ml</a></code>, <code><a href="#topic+ocf">ocf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit ordered machine learning on training sample using two different learners.
ordered_forest &lt;- ordered_ml(y_tr, X_tr, learner = "forest")
ordered_l1 &lt;- ordered_ml(y_tr, X_tr, learner = "l1")

## Predict out of sample.
predictions_forest &lt;- predict(ordered_forest, X_test)
predictions_l1 &lt;- predict(ordered_l1, X_test)

## Compare predictions.
cbind(head(predictions_forest), head(predictions_l1))

</code></pre>

<hr>
<h2 id='predict_forest_weights'>Forest Out-of-Sample Weights</h2><span id='topic+predict_forest_weights'></span>

<h3>Description</h3>

<p>Computes forest out-of-sample honest weights for an <code>ocf.forest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_forest_weights(forest, honest_sample, test_sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_forest_weights_+3A_forest">forest</code></td>
<td>
<p>An <code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="predict_forest_weights_+3A_honest_sample">honest_sample</code></td>
<td>
<p>Honest sample.</p>
</td></tr>
<tr><td><code id="predict_forest_weights_+3A_test_sample">test_sample</code></td>
<td>
<p>Test sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>forest</code> must have been grown using only the training sample.
</p>


<h3>Value</h3>

<p>Matrix of out-of-sample honest weights.
</p>

<hr>
<h2 id='predict.mml'>Prediction Method for mml Objects</h2><span id='topic+predict.mml'></span>

<h3>Description</h3>

<p>Prediction method for class <code>mml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mml'
predict(object, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mml_+3A_object">object</code></td>
<td>
<p>An <code>mml</code> object.</p>
</td></tr>
<tr><td><code id="predict.mml_+3A_data">data</code></td>
<td>
<p>Data set of class <code>data.frame</code>. It must contain the same covariates used to train the base learners. If <code>data</code> is <code>NULL</code>, then <code>object$X</code> is used.</p>
</td></tr>
<tr><td><code id="predict.mml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object$learner == "l1"</code>, then <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> is used to handle non-numeric covariates. If we also
have <code>object$scaling == TRUE</code>, then <code>data</code> is scaled to have zero mean and unit variance.
</p>


<h3>Value</h3>

<p>Matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinomial_ml">multinomial_ml</a></code>, <code><a href="#topic+ordered_ml">ordered_ml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit multinomial machine learning on training sample using two different learners.
multinomial_forest &lt;- multinomial_ml(y_tr, X_tr, learner = "forest")
multinomial_l1 &lt;- multinomial_ml(y_tr, X_tr, learner = "l1")

## Predict out of sample.
predictions_forest &lt;- predict(multinomial_forest, X_test)
predictions_l1 &lt;- predict(multinomial_l1, X_test)

## Compare predictions.
cbind(head(predictions_forest), head(predictions_l1))

</code></pre>

<hr>
<h2 id='predict.ocf'>Prediction Method for ocf Objects</h2><span id='topic+predict.ocf'></span>

<h3>Description</h3>

<p>Prediction method for class <code><a href="#topic+ocf">ocf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf'
predict(object, data = NULL, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ocf_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ocf">ocf</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.ocf_+3A_data">data</code></td>
<td>
<p>Data set of class <code>data.frame</code>. It must contain at least the same covariates used to train the forests. If <code>data</code> is <code>NULL</code>, then <code>object$full_data</code> is used.</p>
</td></tr>
<tr><td><code id="predict.ocf_+3A_type">type</code></td>
<td>
<p>Type of prediction. Either <code>"response"</code> or <code>"terminalNodes"</code>.</p>
</td></tr>
<tr><td><code id="predict.ocf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type == "response"</code>, the routine returns the predicted conditional class probabilities and the predicted class 
labels. If forests are honest, the predicted probabilities are honest.<br />
</p>
<p>If <code>type == "terminalNodes"</code>, the IDs of the terminal node in each tree for each observation in <code>data</code> are returned.<br />
</p>


<h3>Value</h3>

<p>Desired predictions.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>, <code><a href="#topic+marginal_effects">marginal_effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit ocf on training sample.
forests &lt;- ocf(y_tr, X_tr)

## Predict on test sample.
predictions &lt;- predict(forests, X_test)
head(predictions$probabilities)
predictions$classification

## Get terminal nodes.
predictions &lt;- predict(forests, X_test, type = "terminalNodes")
predictions$forest.1[1:10, 1:20] # Rows are observations, columns are forests.

</code></pre>

<hr>
<h2 id='predict.ocf.forest'>Prediction Method for ocf.forest Objects</h2><span id='topic+predict.ocf.forest'></span>

<h3>Description</h3>

<p>Prediction method for class <code>ocf.forest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf.forest'
predict(object, data, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ocf.forest_+3A_object">object</code></td>
<td>
<p>An <code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="predict.ocf.forest_+3A_data">data</code></td>
<td>
<p>Data set of class <code>data.frame</code>. It must contain at least the same covariates used to train the forests.</p>
</td></tr>
<tr><td><code id="predict.ocf.forest_+3A_type">type</code></td>
<td>
<p>Type of prediction. Either <code>"response"</code> or <code>"terminalNodes"</code>.</p>
</td></tr>
<tr><td><code id="predict.ocf.forest_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type === "response"</code> (the default), the predicted conditional class probabilities are returned. If forests are 
honest, these predictions are honest.<br />
</p>
<p>If <code>type == "terminalNodes"</code>, the IDs of the terminal node in each tree for each observation in <code>data</code> are returned.
</p>


<h3>Value</h3>

<p>Prediction results.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>, <code><a href="#topic+marginal_effects">marginal_effects</a></code>
</p>

<hr>
<h2 id='predict.oml'>Prediction Method for oml Objects</h2><span id='topic+predict.oml'></span>

<h3>Description</h3>

<p>Prediction method for class <code>oml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oml'
predict(object, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.oml_+3A_object">object</code></td>
<td>
<p>An <code>oml</code> object.</p>
</td></tr>
<tr><td><code id="predict.oml_+3A_data">data</code></td>
<td>
<p>Data set of class <code>data.frame</code>. It must contain the same covariates used to train the base learners. If <code>data</code> is <code>NULL</code>, then <code>object$X</code> is used.</p>
</td></tr>
<tr><td><code id="predict.oml_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object$learner == "l1"</code>, then <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> is used to handle non-numeric covariates. If we also
have <code>object$scaling == TRUE</code>, then <code>data</code> is scaled to have zero mean and unit variance.
</p>


<h3>Value</h3>

<p>Matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multinomial_ml">multinomial_ml</a></code>, <code><a href="#topic+ordered_ml">ordered_ml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Training-test split.
train_idx &lt;- sample(seq_len(length(y)), floor(length(y) * 0.5))

y_tr &lt;- y[train_idx]
X_tr &lt;- X[train_idx, ]

y_test &lt;- y[-train_idx]
X_test &lt;- X[-train_idx, ]

## Fit ordered machine learning on training sample using two different learners.
ordered_forest &lt;- ordered_ml(y_tr, X_tr, learner = "forest")
ordered_l1 &lt;- ordered_ml(y_tr, X_tr, learner = "l1")

## Predict out of sample.
predictions_forest &lt;- predict(ordered_forest, X_test)
predictions_l1 &lt;- predict(ordered_l1, X_test)

## Compare predictions.
cbind(head(predictions_forest), head(predictions_l1))

</code></pre>

<hr>
<h2 id='print.ocf'>Print Method for ocf Objects</h2><span id='topic+print.ocf'></span>

<h3>Description</h3>

<p>Prints an <code><a href="#topic+ocf">ocf</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ocf_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+ocf">ocf</a></code> object.</p>
</td></tr>
<tr><td><code id="print.ocf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints an <code><a href="#topic+ocf">ocf</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:200, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf.
forests &lt;- ocf(y, X)

## Print.
print(forests)

</code></pre>

<hr>
<h2 id='print.ocf.marginal'>Print Method for ocf.marginal Objects</h2><span id='topic+print.ocf.marginal'></span>

<h3>Description</h3>

<p>Prints an <code>ocf.marginal</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf.marginal'
print(x, latex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ocf.marginal_+3A_x">x</code></td>
<td>
<p>An <code>ocf.marginal</code> object.</p>
</td></tr>
<tr><td><code id="print.ocf.marginal_+3A_latex">latex</code></td>
<td>
<p>If <code>TRUE</code>, prints LATEX code.</p>
</td></tr>
<tr><td><code id="print.ocf.marginal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compilation of the LATEX code requires the following packages: <code>booktabs</code>, <code>float</code>, <code>adjustbox</code>. If
standard errors have been estimated, they are printed in parenthesis below each point estimate.
</p>


<h3>Value</h3>

<p>Prints an <code>ocf.marginal</code> object.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>, <code><a href="#topic+marginal_effects">marginal_effects</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf. Use large number of trees.
forests &lt;- ocf(y, X, n.trees = 4000)

## Marginal effects at the mean.
me &lt;- marginal_effects(forests, eval = "atmean")
print(me)
print(me, latex = TRUE)


## Add standard errors.
honest_forests &lt;- ocf(y, X, n.trees = 4000, honesty = TRUE)
honest_me &lt;- marginal_effects(honest_forests, eval = "atmean", inference = TRUE)
print(honest_me, latex = TRUE)

</code></pre>

<hr>
<h2 id='rename_latex'>Renaming Variables for LATEX Usage</h2><span id='topic+rename_latex'></span>

<h3>Description</h3>

<p>Renames variables where the character &quot;_&quot; is used, which causes clashes in LATEX. Useful for the <code>phased</code> print method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_latex(names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_latex_+3A_names">names</code></td>
<td>
<p>string vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The renamed string vector. Strings where &quot;_&quot; is not found are not modified by <code>rename_latex</code>.
</p>

<hr>
<h2 id='summary.ocf'>Summary Method for ocf Objects</h2><span id='topic+summary.ocf'></span>

<h3>Description</h3>

<p>Summarizes an <code><a href="#topic+ocf">ocf</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ocf_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ocf">ocf</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.ocf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summarizes an <code><a href="#topic+ocf">ocf</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>, <code><a href="#topic+marginal_effects">marginal_effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf.
forests &lt;- ocf(y, X)

## Summary.
summary(forests)

</code></pre>

<hr>
<h2 id='summary.ocf.marginal'>Summary Method for ocf.marginal Objects</h2><span id='topic+summary.ocf.marginal'></span>

<h3>Description</h3>

<p>Summarizes an <code>ocf.marginal</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ocf.marginal'
summary(object, latex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ocf.marginal_+3A_object">object</code></td>
<td>
<p>An <code>ocf.marginal</code> object.</p>
</td></tr>
<tr><td><code id="summary.ocf.marginal_+3A_latex">latex</code></td>
<td>
<p>If <code>TRUE</code>, prints LATEX code.</p>
</td></tr>
<tr><td><code id="summary.ocf.marginal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compilation of the LATEX code requires the following packages: <code>booktabs</code>, <code>float</code>, <code>adjustbox</code>. If
standard errors have been estimated, they are printed in parenthesis below each point estimate.
</p>


<h3>Value</h3>

<p>Summarizes an <code>ocf.marginal</code> object.
</p>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>, <code><a href="#topic+marginal_effects">marginal_effects</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:100, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf. Use large number of trees.
forests &lt;- ocf(y, X, n.trees = 4000)

## Marginal effects at the mean.
me &lt;- marginal_effects(forests, eval = "atmean")
summary(me)
summary(me, latex = TRUE)


## Add standard errors.
honest_forests &lt;- ocf(y, X, n.trees = 4000, honesty = TRUE)
honest_me &lt;- marginal_effects(honest_forests, eval = "atmean", inference = TRUE)
summary(honest_me, latex = TRUE)

</code></pre>

<hr>
<h2 id='tree_info'>Tree Information in Readable Format</h2><span id='topic+tree_info'></span>

<h3>Description</h3>

<p>Extracts tree information from a <code>ocf.forest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_info(object, tree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_info_+3A_object">object</code></td>
<td>
<p><code>ocf.forest</code> object.</p>
</td></tr>
<tr><td><code id="tree_info_+3A_tree">tree</code></td>
<td>
<p>Number of the tree of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nodes and variables IDs are 0-indexed, i.e., node 0 is the root node. <br />
</p>
<p>All values smaller than or equal to <code>splitval</code> go to the left and all values larger go to the right.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns:
</p>
<table>
<tr><td><code>nodeID</code></td>
<td>
<p>Node IDs.</p>
</td></tr> 
<tr><td><code>leftChild</code></td>
<td>
<p>IDs of the left child node.</p>
</td></tr> 
<tr><td><code>rightChild</code></td>
<td>
<p>IDs of the right child node.</p>
</td></tr> 
<tr><td><code>splitvarID</code></td>
<td>
<p>IDs of the splitting variable.</p>
</td></tr>
<tr><td><code>splitvarName</code></td>
<td>
<p>Name of the splitting variable.</p>
</td></tr>
<tr><td><code>splitval</code></td>
<td>
<p>Splitting value.</p>
</td></tr> 
<tr><td><code>terminal</code></td>
<td>
<p>Logical, TRUE for terminal nodes.</p>
</td></tr> 
<tr><td><code>prediction</code></td>
<td>
<p>One column with the predicted conditional class probabilities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Riccardo Di Francesco
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ocf">ocf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load data from orf package.
set.seed(1986)

library(orf)
data(odata)
odata &lt;- odata[1:200, ] # Subset to reduce elapsed time.

y &lt;- as.numeric(odata[, 1])
X &lt;- as.matrix(odata[, -1])

## Fit ocf.
forests &lt;- ocf(y, X)

## Extract information from tenth tree of first forest.
info &lt;- tree_info(forests$forests.info$forest.1, tree = 10)
head(info)
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
