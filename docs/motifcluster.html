<!DOCTYPE html><html><head><title>Help for package motifcluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {motifcluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a_b_one'><p>Compute a right-multiplication with the ones matrix</p></a></li>
<li><a href='#a_one_b'><p>Compute a left-multiplication with the ones matrix</p></a></li>
<li><a href='#build_G'><p>Build sparse adjacency matrix</p></a></li>
<li><a href='#build_Gd'><p>Build double-edge adjacency matrix</p></a></li>
<li><a href='#build_Gp'><p>Build product adjacency matrix</p></a></li>
<li><a href='#build_Gs'><p>Build single-edge adjacency matrix</p></a></li>
<li><a href='#build_Id'><p>Build identity matrix</p></a></li>
<li><a href='#build_J'><p>Build directed indicator matrix</p></a></li>
<li><a href='#build_J0'><p>Build missing-edge indicator matrix</p></a></li>
<li><a href='#build_Jd'><p>Build double-edge indicator matrix</p></a></li>
<li><a href='#build_Je'><p>Build edge-and-diagonal indicator matrix</p></a></li>
<li><a href='#build_Jn'><p>Build vertex-distinct indicator matrix</p></a></li>
<li><a href='#build_Js'><p>Build single-edge indicator matrix</p></a></li>
<li><a href='#build_laplacian'><p>Build a Laplacian matrix</p></a></li>
<li><a href='#build_motif_adjacency_matrix'><p>Build a motif adjacency matrix</p></a></li>
<li><a href='#cluster_spectrum'><p>Get cluster assignments from spectrum using k-means++</p></a></li>
<li><a href='#demonstration_graph'><p>Generate a small graph for demonstrations</p></a></li>
<li><a href='#drop0_killdiag'><p>Set diagonal entries to zero and sparsify</p></a></li>
<li><a href='#get_first_eigs'><p>Compute first few eigenvalues and eigenvectors of a matrix</p></a></li>
<li><a href='#get_largest_component'><p>Get largest connected component</p></a></li>
<li><a href='#get_motif_names'><p>Get common motif names</p></a></li>
<li><a href='#kmeanspp'><p>kmeans++ clustering</p></a></li>
<li><a href='#mam_M1'><p>Perform the motif adjacency matrix calculations for motif M1</p></a></li>
<li><a href='#mam_M10'><p>Perform the motif adjacency matrix calculations for motif M10</p></a></li>
<li><a href='#mam_M11'><p>Perform the motif adjacency matrix calculations for motif M11</p></a></li>
<li><a href='#mam_M12'><p>Perform the motif adjacency matrix calculations for motif M12</p></a></li>
<li><a href='#mam_M13'><p>Perform the motif adjacency matrix calculations for motif M13</p></a></li>
<li><a href='#mam_M2'><p>Perform the motif adjacency matrix calculations for motif M2</p></a></li>
<li><a href='#mam_M3'><p>Perform the motif adjacency matrix calculations for motif M3</p></a></li>
<li><a href='#mam_M4'><p>Perform the motif adjacency matrix calculations for motif M4</p></a></li>
<li><a href='#mam_M5'><p>Perform the motif adjacency matrix calculations for motif M5</p></a></li>
<li><a href='#mam_M6'><p>Perform the motif adjacency matrix calculations for motif M6</p></a></li>
<li><a href='#mam_M7'><p>Perform the motif adjacency matrix calculations for motif M7</p></a></li>
<li><a href='#mam_M8'><p>Perform the motif adjacency matrix calculations for motif M8</p></a></li>
<li><a href='#mam_M9'><p>Perform the motif adjacency matrix calculations for motif M9</p></a></li>
<li><a href='#mam_Mcoll'><p>Perform the motif adjacency matrix calculations for motif Mcoll</p></a></li>
<li><a href='#mam_Md'><p>Perform the motif adjacency matrix calculations for motif Md</p></a></li>
<li><a href='#mam_Mexpa'><p>Perform the motif adjacency matrix calculations for motif Mexpa</p></a></li>
<li><a href='#mam_Ms'><p>Perform the motif adjacency matrix calculations for motif Ms</p></a></li>
<li><a href='#random_sparse_matrix'><p>Build a random sparse matrix</p></a></li>
<li><a href='#run_laplace_embedding'><p>Run Laplace embedding</p></a></li>
<li><a href='#run_motif_clustering'><p>Run motif-based clustering</p></a></li>
<li><a href='#run_motif_embedding'><p>Run motif embedding</p></a></li>
<li><a href='#sample_bsbm'><p>Sample a bipartite stochastic block model (BSBM)</p></a></li>
<li><a href='#sample_dsbm'><p>Sample a directed stochastic block model (DSBM)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Motif-Based Spectral Clustering of Weighted Directed Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Tools for spectral clustering of weighted directed networks using motif
    adjacency matrices. Methods perform well on large and sparse networks, and
    random sampling methods for generating weighted directed networks are also
    provided. Based on methodology detailed in Underwood, Elliott and Cucuringu
    (2020) &lt;<a href="https://arxiv.org/abs/2004.01293">arXiv:2004.01293</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wgunderwood/motifcluster">https://github.com/wgunderwood/motifcluster</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wgunderwood/motifcluster/issues">https://github.com/wgunderwood/motifcluster/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 1.2.5), Matrix (&ge; 1.2), RSpectra (&ge; 0.16.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.5.0), knitr (&ge; 1.28), mclust (&ge; 5.4.6),
rmarkdown (&ge; 2.1), testthat (&ge; 2.3.2)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-18 04:29:33 UTC; will</td>
</tr>
<tr>
<td>Author:</td>
<td>William George Underwood [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William George Underwood &lt;wgu2@princeton.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-18 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a_b_one'>Compute a right-multiplication with the ones matrix</h2><span id='topic+a_b_one'></span>

<h3>Description</h3>

<p>Compute <code>a * (b %*% one_mat)</code> where <code>a</code>, <code>b</code>,
<code>ones_mat</code> are square matrices of the same size,
and <code>ones_mat</code> contains all entries equal to one.
The product <code>*</code> is an entry-wise (Hadamard) product,
while <code>%*%</code> represents matrix multiplication.
This method is more efficient than the naive approach
when <code>a</code> or <code>b</code> are sparse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_b_one(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_b_one_+3A_a">a</code>, <code id="a_b_one_+3A_b">b</code></td>
<td>
<p>Square matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square matrix <code>a * (b %*% one_mat)</code>.
</p>

<hr>
<h2 id='a_one_b'>Compute a left-multiplication with the ones matrix</h2><span id='topic+a_one_b'></span>

<h3>Description</h3>

<p>Compute <code>a * (one_mat %*% b)</code> where <code>a</code>, <code>b</code>,
<code>ones_mat</code> are square matrices of the same size,
and <code>ones_mat</code> contains all entries equal to one.
The product <code>*</code> is an entry-wise (Hadamard) product,
while <code>%*%</code> represents matrix multiplication.
This method is more efficient than the naive approach
when <code>a</code> or <code>b</code> are sparse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_one_b(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_one_b_+3A_a">a</code>, <code id="a_one_b_+3A_b">b</code></td>
<td>
<p>Square matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The square matrix <code>a * (one_mat %*% b)</code>.
</p>

<hr>
<h2 id='build_G'>Build sparse adjacency matrix</h2><span id='topic+build_G'></span>

<h3>Description</h3>

<p>Build the sparse adjacency matrix <code>G</code> from a graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_G(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_G_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency matrix <code>G</code> in sparse form.
</p>

<hr>
<h2 id='build_Gd'>Build double-edge adjacency matrix</h2><span id='topic+build_Gd'></span>

<h3>Description</h3>

<p>Build the sparse double-edge adjacency matrix <code>Gd</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Gd(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Gd_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double-edge adjacency matrix <code>Gd</code> in sparse form.
</p>

<hr>
<h2 id='build_Gp'>Build product adjacency matrix</h2><span id='topic+build_Gp'></span>

<h3>Description</h3>

<p>Build the sparse product adjacency matrix <code>Jp</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Gp(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Gp_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A product adjacency matrix <code>Jp</code> in sparse form.
</p>

<hr>
<h2 id='build_Gs'>Build single-edge adjacency matrix</h2><span id='topic+build_Gs'></span>

<h3>Description</h3>

<p>Build the sparse single-edge adjacency matrix <code>Gs</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Gs(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Gs_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-edge adjacency matrix <code>Gs</code> in sparse form.
</p>

<hr>
<h2 id='build_Id'>Build identity matrix</h2><span id='topic+build_Id'></span>

<h3>Description</h3>

<p>Build the sparse identity matrix <code>Id</code> from a graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Id(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Id_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An identity matrix <code>Id</code> in sparse form.
</p>

<hr>
<h2 id='build_J'>Build directed indicator matrix</h2><span id='topic+build_J'></span>

<h3>Description</h3>

<p>Build the sparse directed indicator matrix <code>J</code>
from a graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_J(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_J_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A directed indicator matrix <code>J</code> in sparse form.
</p>

<hr>
<h2 id='build_J0'>Build missing-edge indicator matrix</h2><span id='topic+build_J0'></span>

<h3>Description</h3>

<p>Build the missing-edge indicator matrix <code>J0</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_J0(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_J0_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A missing-edge indicator matrix <code>J0</code>.
</p>

<hr>
<h2 id='build_Jd'>Build double-edge indicator matrix</h2><span id='topic+build_Jd'></span>

<h3>Description</h3>

<p>Build the sparse double-edge indicator matrix <code>Jd</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Jd(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Jd_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double-edge indicator matrix <code>Jd</code> in sparse form.
</p>

<hr>
<h2 id='build_Je'>Build edge-and-diagonal indicator matrix</h2><span id='topic+build_Je'></span>

<h3>Description</h3>

<p>Build the sparse edge-and-diagonal indicator matrix <code>Je</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Je(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Je_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge-and-diagonal indicator matrix <code>Je</code> in sparse form.
</p>

<hr>
<h2 id='build_Jn'>Build vertex-distinct indicator matrix</h2><span id='topic+build_Jn'></span>

<h3>Description</h3>

<p>Build the vertex-distinct indicator matrix <code>Jn</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Jn(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Jn_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex-distinct indicator matrix <code>Jn</code>.
</p>

<hr>
<h2 id='build_Js'>Build single-edge indicator matrix</h2><span id='topic+build_Js'></span>

<h3>Description</h3>

<p>Build the sparse single-edge indicator matrix <code>Js</code> from a
graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_Js(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_Js_+3A_adj_mat">adj_mat</code></td>
<td>
<p>The original adjacency matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-edge indicator matrix <code>Js</code> in sparse form.
</p>

<hr>
<h2 id='build_laplacian'>Build a Laplacian matrix</h2><span id='topic+build_laplacian'></span>

<h3>Description</h3>

<p>Build a Laplacian matrix (combinatorial Laplacian or random-walk Laplacian)
from a symmetric (weighted) graph adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_laplacian(adj_mat, type_lap = c("comb", "rw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_laplacian_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Symmetric adjacency matrix from which to build the Laplacian.</p>
</td></tr>
<tr><td><code id="build_laplacian_+3A_type_lap">type_lap</code></td>
<td>
<p>Type of Laplacian to build.
One of <code>"comb"</code> (combinatorial) or <code>"rw"</code> (random-walk).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The specified Laplacian matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(1:9), nrow = 3)
build_laplacian(adj_mat, "rw")
</code></pre>

<hr>
<h2 id='build_motif_adjacency_matrix'>Build a motif adjacency matrix</h2><span id='topic+build_motif_adjacency_matrix'></span>

<h3>Description</h3>

<p>Build a motif adjacency matrix from an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_motif_adjacency_matrix(
  adj_mat,
  motif_name,
  motif_type = c("struc", "func"),
  mam_weight_type = c("unweighted", "mean", "poisson"),
  mam_method = c("sparse", "dense")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_motif_adjacency_matrix_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="build_motif_adjacency_matrix_+3A_motif_name">motif_name</code></td>
<td>
<p>Motif used for the motif adjacency matrix.</p>
</td></tr>
<tr><td><code id="build_motif_adjacency_matrix_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.
One of <code>"func"</code> or <code>"struc"</code>.</p>
</td></tr>
<tr><td><code id="build_motif_adjacency_matrix_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="build_motif_adjacency_matrix_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.
The sparse formulation avoids generating large dense matrices
so tends to be faster for large sparse graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entry (<em>i</em>, <em>j</em>) of a motif adjacency matrix is the
sum of the weights of all motifs containing both
nodes <em>i</em> and <em>j</em>.
The motif is specified by name and the type of motif instance can be one of:
</p>

<ul>
<li><p> Functional: motifs should appear as subgraphs.
</p>
</li>
<li><p> Structural: motifs should appear as induced subgraphs.
</p>
</li></ul>

<p>The weighting scheme can be one of:
</p>

<ul>
<li><p> Unweighted: the weight of any motif instance is one.
</p>
</li>
<li><p> Mean: the weight of any motif instance
is the mean of its edge weights.
</p>
</li>
<li><p> Product: the weight of any motif instance
is the product of its edge weights.
</p>
</li></ul>



<h3>Value</h3>

<p>A motif adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(1:9), nrow = 3)
build_motif_adjacency_matrix(adj_mat, "M1", "func", "mean")
</code></pre>

<hr>
<h2 id='cluster_spectrum'>Get cluster assignments from spectrum using k-means++</h2><span id='topic+cluster_spectrum'></span>

<h3>Description</h3>

<p>Get a vector of cluster assignments from a spectrum,
using k-means++ and <code>num_clusts</code> clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_spectrum(spectrum, num_clusts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_spectrum_+3A_spectrum">spectrum</code></td>
<td>
<p>A list containing <code>$vects</code>;
the matrix of eigenvectors to pass to k-means++.</p>
</td></tr>
<tr><td><code id="cluster_spectrum_+3A_num_clusts">num_clusts</code></td>
<td>
<p>The number of clusters to find.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-nrow(spectrum$vects) vector of integers
from 1 to num_clusts, representing cluster assignments.
</p>

<hr>
<h2 id='demonstration_graph'>Generate a small graph for demonstrations</h2><span id='topic+demonstration_graph'></span>

<h3>Description</h3>

<p>Generate the sparse and dense adjacency matrices of a small weighted
directed graph, for demonstrating methods and running tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demonstration_graph()
</code></pre>


<h3>Value</h3>

<p>A list with two entries:
<code>adj_mat_dense</code> is the adjacency matrix in dense form, and
<code>adj_mat_sparse</code> is the adjacency matrix in sparse form.
</p>

<hr>
<h2 id='drop0_killdiag'>Set diagonal entries to zero and sparsify</h2><span id='topic+drop0_killdiag'></span>

<h3>Description</h3>

<p>Set the diagonal entries of a matrix to zero
and convert it to sparse form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop0_killdiag(some_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop0_killdiag_+3A_some_mat">some_mat</code></td>
<td>
<p>A square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse-form copy of <code>some_mat</code> with its
diagonal entries set to zero.
</p>

<hr>
<h2 id='get_first_eigs'>Compute first few eigenvalues and eigenvectors of a matrix</h2><span id='topic+get_first_eigs'></span>

<h3>Description</h3>

<p>Compute the first few eigenvalues (by magnitude) and
associated eigenvectors of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_first_eigs(some_mat, num_eigs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_first_eigs_+3A_some_mat">some_mat</code></td>
<td>
<p>Matrix for which eigenvalues and eigenvectors
are to be calculated.</p>
</td></tr>
<tr><td><code id="get_first_eigs_+3A_num_eigs">num_eigs</code></td>
<td>
<p>Number of eigenvalues and eigenvectors to calculate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries:
<code>vals</code> contains a length-<code>num_eigs</code> vector of the first few
eigenvalues,
and vects contains an <code>nrow(some_mat)</code> by <code>num_eigs</code> matrix
of the associated eigenvectors.
</p>

<hr>
<h2 id='get_largest_component'>Get largest connected component</h2><span id='topic+get_largest_component'></span>

<h3>Description</h3>

<p>Get the indices of the vertices in the largest connected
component of a graph from its adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_largest_component(adj_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_largest_component_+3A_adj_mat">adj_mat</code></td>
<td>
<p>An adjacency matrix of a graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices corresponding to the vertices in the largest
connected component.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(0, 1, 0, 0, 0, 0, 0, 0, 0), nrow = 3)
get_largest_component(adj_mat)
</code></pre>

<hr>
<h2 id='get_motif_names'>Get common motif names</h2><span id='topic+get_motif_names'></span>

<h3>Description</h3>

<p>Get the names of some common motifs as strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_motif_names()
</code></pre>


<h3>Value</h3>

<p>A vector of names (strings) of common motifs.
</p>

<hr>
<h2 id='kmeanspp'>kmeans++ clustering</h2><span id='topic+kmeanspp'></span>

<h3>Description</h3>

<p>Use the kmeans++ algorithm to cluster points
into <code>k</code> clusters, as implemented in the
deprecated LICORS package, using the
built-in function <a href="stats.html#topic+kmeans">kmeans</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeanspp(data, k = 2, iter.max = 100, nstart = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeanspp_+3A_data">data</code></td>
<td>
<p>An <code class="reqn">N \times d</code> matrix, where there are <code class="reqn">N</code> samples
in dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_k">k</code></td>
<td>
<p>The number of clusters.</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_iter.max">iter.max</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_nstart">nstart</code></td>
<td>
<p>The number of restarts.</p>
</td></tr>
<tr><td><code id="kmeanspp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 9 entries:
</p>

<ul>
<li> <p><code>cluster</code>: A vector of integers from 1:k indicating the
cluster to which each point is allocated.
</p>
</li>
<li> <p><code>centers</code>: A matrix of cluster centers.
</p>
</li>
<li> <p><code>totss</code>: The total sum of squares.
</p>
</li>
<li> <p><code>withinss</code>: Vector of within-cluster sum of squares,
one component per cluster.
</p>
</li>
<li> <p><code>tot.withinss</code>: Total within-cluster sum of squares,
i.e.sum(withinss).
</p>
</li>
<li> <p><code>betweenss</code>: The between-cluster sum of squares,
i.e.totss-tot.withinss.
</p>
</li>
<li> <p><code>size</code>: The number of points in each cluster.
</p>
</li>
<li> <p><code>iter</code>: The number of (outer) iterations.
</p>
</li>
<li> <p><code>ifault</code>: An integer indicator of a possible algorithm problem.
</p>
</li>
<li> <p><code>initial.centers</code>: The initial centers used.
</p>
</li></ul>



<h3>References</h3>

<p>Arthur, D. and S. Vassilvitskii (2007).
&ldquo;k-means++: The advantages of careful seeding.&rdquo;
In H. Gabow (Ed.), Proceedings of the 18th Annual ACM-SIAM
Symposium on Discrete Algorithms
[SODA07], Philadelphia, pp. 1027-1035.
Society for Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1984)
n &lt;- 100
X = matrix(rnorm(n), ncol = 2)
Y = matrix(runif(length(X)*2, -1, 1), ncol = ncol(X))
Z = rbind(X, Y)
cluster_Z = kmeanspp(Z, k = 5)
</code></pre>

<hr>
<h2 id='mam_M1'>Perform the motif adjacency matrix calculations for motif M1</h2><span id='topic+mam_M1'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M1(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M1_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M1_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M1_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M10'>Perform the motif adjacency matrix calculations for motif M10</h2><span id='topic+mam_M10'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M10
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M10(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M10_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M10_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M10_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M10_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M11'>Perform the motif adjacency matrix calculations for motif M11</h2><span id='topic+mam_M11'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M11
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M11(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M11_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M11_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M11_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M11_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M12'>Perform the motif adjacency matrix calculations for motif M12</h2><span id='topic+mam_M12'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M12
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M12(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M12_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M12_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M12_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M12_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M13'>Perform the motif adjacency matrix calculations for motif M13</h2><span id='topic+mam_M13'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M13
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M13(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M13_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M13_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M13_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M13_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M2'>Perform the motif adjacency matrix calculations for motif M2</h2><span id='topic+mam_M2'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M2(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M2_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M2_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M2_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M3'>Perform the motif adjacency matrix calculations for motif M3</h2><span id='topic+mam_M3'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M3(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M3_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M3_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M3_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M4'>Perform the motif adjacency matrix calculations for motif M4</h2><span id='topic+mam_M4'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M4(adj_mat, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M4_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M4_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M5'>Perform the motif adjacency matrix calculations for motif M5</h2><span id='topic+mam_M5'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M5(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M5_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M5_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M5_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M6'>Perform the motif adjacency matrix calculations for motif M6</h2><span id='topic+mam_M6'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M6
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M6(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M6_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M6_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M6_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M7'>Perform the motif adjacency matrix calculations for motif M7</h2><span id='topic+mam_M7'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M7
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M7(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M7_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M7_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M7_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M8'>Perform the motif adjacency matrix calculations for motif M8</h2><span id='topic+mam_M8'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M8
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M8(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M8_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M8_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M8_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M8_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_M9'>Perform the motif adjacency matrix calculations for motif M9</h2><span id='topic+mam_M9'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif M9
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_M9(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_M9_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_M9_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_M9_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_M9_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_Mcoll'>Perform the motif adjacency matrix calculations for motif Mcoll</h2><span id='topic+mam_Mcoll'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif Mcoll
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_Mcoll(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_Mcoll_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_Mcoll_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_Mcoll_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_Mcoll_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_Md'>Perform the motif adjacency matrix calculations for motif Md</h2><span id='topic+mam_Md'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif Md
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_Md(adj_mat, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_Md_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_Md_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_Mexpa'>Perform the motif adjacency matrix calculations for motif Mexpa</h2><span id='topic+mam_Mexpa'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif Mexpa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_Mexpa(adj_mat, motif_type, mam_weight_type, mam_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_Mexpa_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_Mexpa_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_Mexpa_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="mam_Mexpa_+3A_mam_method">mam_method</code></td>
<td>
<p>Which formulation to use.
One of <code>"dense"</code> or <code>"sparse"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='mam_Ms'>Perform the motif adjacency matrix calculations for motif Ms</h2><span id='topic+mam_Ms'></span>

<h3>Description</h3>

<p>Perform the motif adjacency matrix calculations for motif Ms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mam_Ms(adj_mat, motif_type, mam_weight_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mam_Ms_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix from which to build the motif
adjacency matrix.</p>
</td></tr>
<tr><td><code id="mam_Ms_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to build.</p>
</td></tr>
<tr><td><code id="mam_Ms_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>The weighting scheme to use.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A motif adjacency matrix.
</p>

<hr>
<h2 id='random_sparse_matrix'>Build a random sparse matrix</h2><span id='topic+random_sparse_matrix'></span>

<h3>Description</h3>

<p>Build a sparse matrix of size <code>m * n</code> with
non-zero probability <code>p</code>.
Edge weights can be unweighted, constant-weighted or
Poisson-weighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_sparse_matrix(m, n, p, sample_weight_type = "constant", w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_sparse_matrix_+3A_m">m</code>, <code id="random_sparse_matrix_+3A_n">n</code></td>
<td>
<p>Dimension of matrix to build is <code>(m, n)</code>.</p>
</td></tr>
<tr><td><code id="random_sparse_matrix_+3A_p">p</code></td>
<td>
<p>Probability that each entry is non-zero (before weighting).</p>
</td></tr>
<tr><td><code id="random_sparse_matrix_+3A_sample_weight_type">sample_weight_type</code></td>
<td>
<p>Type of weighting scheme.</p>
</td></tr>
<tr><td><code id="random_sparse_matrix_+3A_w">w</code></td>
<td>
<p>Weight parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random sparse matrix.
</p>

<hr>
<h2 id='run_laplace_embedding'>Run Laplace embedding</h2><span id='topic+run_laplace_embedding'></span>

<h3>Description</h3>

<p>Run Laplace embedding on a symmetric (weighted) adjacency matrix
with a specified number of eigenvalues and eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_laplace_embedding(adj_mat, num_eigs, type_lap = c("comb", "rw"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_laplace_embedding_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Symmetric adjacency matrix to be embedded.</p>
</td></tr>
<tr><td><code id="run_laplace_embedding_+3A_num_eigs">num_eigs</code></td>
<td>
<p>Number of eigenvalues and eigenvectors for the embedding.</p>
</td></tr>
<tr><td><code id="run_laplace_embedding_+3A_type_lap">type_lap</code></td>
<td>
<p>Type of Laplacian for the embedding.
One of <code>"comb"</code> (combinatorial) or <code>"rw"</code> (random-walk).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two entries:
<code>vals</code> contains the length-<code>num_eigs</code> vector
of the first few eigenvalues of the Laplacian,
and <code>vects</code> contains an <code>nrow(adj_mat)</code> by <code>num_eigs</code> matrix
of the associated eigenvectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(1:9), nrow = 3)
run_laplace_embedding(adj_mat, 2, "rw")
</code></pre>

<hr>
<h2 id='run_motif_clustering'>Run motif-based clustering</h2><span id='topic+run_motif_clustering'></span>

<h3>Description</h3>

<p>Run motif-based clustering on the adjacency matrix of a
(weighted directed) network,
using a specified motif, motif type, weighting scheme,
embedding dimension, number of clusters and Laplacian type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_motif_clustering(
  adj_mat,
  motif_name,
  motif_type = c("struc", "func"),
  mam_weight_type = c("unweighted", "mean", "product"),
  mam_method = c("sparse", "dense"),
  num_eigs = 2,
  type_lap = c("comb", "rw"),
  restrict = TRUE,
  num_clusts = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_motif_clustering_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix to be embedded.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_motif_name">motif_name</code></td>
<td>
<p>Motif used for the motif adjacency matrix.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to use.
One of <code>"func"</code> or <code>"struc"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>Weighting scheme for the motif adjacency matrix.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_mam_method">mam_method</code></td>
<td>
<p>The method to use for building the motif adjacency matrix.
One of <code>"sparse"</code> or <code>"dense"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_num_eigs">num_eigs</code></td>
<td>
<p>Number of eigenvalues and eigenvectors for the embedding.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_type_lap">type_lap</code></td>
<td>
<p>Type of Laplacian for the embedding.
One of <code>"comb"</code> or <code>"rw"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_restrict">restrict</code></td>
<td>
<p>Whether or not to restrict the motif adjacency matrix
to its largest connected component before embedding.</p>
</td></tr>
<tr><td><code id="run_motif_clustering_+3A_num_clusts">num_clusts</code></td>
<td>
<p>The number of clusters to find.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 8 entries:
</p>

<ul>
<li> <p><code>adj_mat</code>: the original adjacency matrix.
</p>
</li>
<li> <p><code>motif_adj_mat</code>: the motif adjacency matrix.
</p>
</li>
<li> <p><code>comps</code>: the indices of the largest connected component
of the motif adjacency matrix
(if restrict = TRUE).
</p>
</li>
<li> <p><code>adj_mat_comps</code>: the original adjacency matrix restricted
to the largest connected component of the motif adjacency matrix
(if restrict = TRUE).
</p>
</li>
<li> <p><code>motif_adj_mat_comps</code>: the motif adjacency matrix restricted
to its largest connected component
(if restrict = TRUE).
</p>
</li>
<li> <p><code>vals</code>: a length-<code>num_eigs</code> vector containing the
eigenvalues associated with the Laplace embedding
of the (restricted) motif adjacency matrix.
</p>
</li>
<li> <p><code>vects</code>: a matrix
containing the eigenvectors associated with the Laplace embedding
of the (restricted) motif adjacency matrix.
</p>
</li>
<li> <p><code>clusts</code>: a vector containing integers representing the
cluster assignment of each vertex in the (restricted) graph.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(1:16), nrow = 4)
run_motif_clustering(adj_mat, "M1", "func")
</code></pre>

<hr>
<h2 id='run_motif_embedding'>Run motif embedding</h2><span id='topic+run_motif_embedding'></span>

<h3>Description</h3>

<p>Calculate a motif adjacency matrix for a given motif and motif type,
restrict it to its largest connected component,
and then run Laplace embedding with specified Laplacian type and
number of eigenvalues and eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_motif_embedding(
  adj_mat,
  motif_name,
  motif_type = c("struc", "func"),
  mam_weight_type = c("unweighted", "mean", "product"),
  mam_method = c("sparse", "dense"),
  num_eigs = 2,
  type_lap = c("comb", "rw"),
  restrict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_motif_embedding_+3A_adj_mat">adj_mat</code></td>
<td>
<p>Adjacency matrix to be embedded.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_motif_name">motif_name</code></td>
<td>
<p>Motif used for the motif adjacency matrix.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_motif_type">motif_type</code></td>
<td>
<p>Type of motif adjacency matrix to use.
One of <code>"func"</code> or <code>"struc"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_mam_weight_type">mam_weight_type</code></td>
<td>
<p>Weighting scheme for the motif adjacency matrix.
One of <code>"unweighted"</code>, <code>"mean"</code> or <code>"product"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_mam_method">mam_method</code></td>
<td>
<p>The method to use for building the motif adjacency matrix.
One of <code>"sparse"</code> or <code>"dense"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_num_eigs">num_eigs</code></td>
<td>
<p>Number of eigenvalues and eigenvectors for the embedding.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_type_lap">type_lap</code></td>
<td>
<p>Type of Laplacian for the embedding.
One of <code>"comb"</code> or <code>"rw"</code>.</p>
</td></tr>
<tr><td><code id="run_motif_embedding_+3A_restrict">restrict</code></td>
<td>
<p>Whether or not to restrict the motif adjacency matrix
to its largest connected component before embedding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 7 entries:
</p>

<ul>
<li> <p><code>adj_mat</code>: the original adjacency matrix.
</p>
</li>
<li> <p><code>motif_adj_mat</code>: the motif adjacency matrix.
</p>
</li>
<li> <p><code>comps</code>: the indices of the largest connected component
of the motif adjacency matrix
(if restrict = TRUE).
</p>
</li>
<li> <p><code>adj_mat_comps</code>: the original adjacency matrix restricted
to the largest connected component of the motif adjacency matrix
(if restrict = TRUE).
</p>
</li>
<li> <p><code>motif_adj_mat_comps</code>: the motif adjacency matrix restricted
to its largest connected component
(if restrict = TRUE).
</p>
</li>
<li> <p><code>vals</code>: a length-<code>num_eigs</code> vector containing the
eigenvalues associated with the Laplace embedding
of the (restricted) motif adjacency matrix.
</p>
</li>
<li> <p><code>vects</code>: a matrix
containing the eigenvectors associated with the Laplace embedding
of the (restricted) motif adjacency matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>adj_mat &lt;- matrix(c(1:9), nrow = 3)
run_motif_embedding(adj_mat, "M1", "func")
</code></pre>

<hr>
<h2 id='sample_bsbm'>Sample a bipartite stochastic block model (BSBM)</h2><span id='topic+sample_bsbm'></span>

<h3>Description</h3>

<p>Sample the (weighted) adjacency matrix of a (weighted) bipartite stochastic
block model (BSBM) with specified parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_bsbm(
  source_block_sizes,
  dest_block_sizes,
  bipartite_connection_matrix,
  bipartite_weight_matrix = NULL,
  sample_weight_type = c("unweighted", "constant", "poisson")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_bsbm_+3A_source_block_sizes">source_block_sizes</code></td>
<td>
<p>A vector containing the size of each block
of source vertices.</p>
</td></tr>
<tr><td><code id="sample_bsbm_+3A_dest_block_sizes">dest_block_sizes</code></td>
<td>
<p>A vector containing the size of each block
of destination vertices.</p>
</td></tr>
<tr><td><code id="sample_bsbm_+3A_bipartite_connection_matrix">bipartite_connection_matrix</code></td>
<td>
<p>A matrix containing the
source block to destination block
connection probabilities.</p>
</td></tr>
<tr><td><code id="sample_bsbm_+3A_bipartite_weight_matrix">bipartite_weight_matrix</code></td>
<td>
<p>A matrix containing the
source block to destination block weight parameters.
Unused for <code>sample_weight_type = "constant"</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_bsbm_+3A_sample_weight_type">sample_weight_type</code></td>
<td>
<p>The type of weighting scheme.
One of <code>"unweighted"</code>, <code>"constant"</code> or <code>"poisson"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A randomly sampled (weighted) adjacency matrix of a BSBM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>source_block_sizes &lt;- c(10, 10)
dest_block_sizes &lt;- c(10, 10, 10)
bipartite_connection_matrix &lt;- matrix(c(0.8, 0.5, 0.1, 0.1, 0.5, 0.8),
      nrow = 2, byrow = TRUE)
bipartite_weight_matrix = matrix(c(20, 10, 2, 2, 10, 20),
      nrow = 2, byrow = TRUE)
sample_bsbm(source_block_sizes, dest_block_sizes,
      bipartite_connection_matrix, bipartite_weight_matrix, "poisson")
</code></pre>

<hr>
<h2 id='sample_dsbm'>Sample a directed stochastic block model (DSBM)</h2><span id='topic+sample_dsbm'></span>

<h3>Description</h3>

<p>Sample the (weighted) adjacency matrix of a (weighted) directed stochastic
block model (DSBM) with specified parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dsbm(
  block_sizes,
  connection_matrix,
  weight_matrix = NULL,
  sample_weight_type = c("unweighted", "constant", "poisson")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dsbm_+3A_block_sizes">block_sizes</code></td>
<td>
<p>A vector containing the size of each block of vertices.</p>
</td></tr>
<tr><td><code id="sample_dsbm_+3A_connection_matrix">connection_matrix</code></td>
<td>
<p>A matrix containing the block-to-block connection
probabilities.</p>
</td></tr>
<tr><td><code id="sample_dsbm_+3A_weight_matrix">weight_matrix</code></td>
<td>
<p>A matrix containing the block-to-block weight
parameters.
Unused for <code>sample_weight_type = "constant"</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_dsbm_+3A_sample_weight_type">sample_weight_type</code></td>
<td>
<p>The type of weighting scheme.
One of <code>"unweighted"</code>, <code>"constant"</code> or <code>"poisson"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A randomly sampled (weighted) adjacency matrix of a DSBM.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block_sizes &lt;- c(10, 10)
connection_matrix &lt;- matrix(c(0.8, 0.1, 0.1, 0.8), nrow = 2, byrow = TRUE)
weight_matrix &lt;- matrix(c(10, 3, 3, 10), nrow = 2, byrow = TRUE)
sample_dsbm(block_sizes, connection_matrix, weight_matrix, "poisson")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
