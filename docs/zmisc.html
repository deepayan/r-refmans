<!DOCTYPE html><html><head><title>Help for package zmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ddply_helper'><p>Apply a function to each column of a data.frame</p></a></li>
<li><a href='#ll_assert_labelled'><p>Verify that x is a valid labelled variable</p></a></li>
<li><a href='#ll_labelled'><p>Create a labelled variable</p></a></li>
<li><a href='#ll_to_character'><p>Get the character representation of a labelled variable</p></a></li>
<li><a href='#ll_val_labels'><p>Get or set value labels of a labelled variable</p></a></li>
<li><a href='#ll_var_label'><p>Get or set variable label of a labelled variable</p></a></li>
<li><a href='#lookup'><p>Lookup values from a lookup table</p></a></li>
<li><a href='#notate'><p>Embed factor levels and value labels in values.</p></a></li>
<li><a href='#standardize_lookup_table'><p>Helper function to standardize the <code>lookup_table</code>.</p></a></li>
<li><a href='#threadbare'><p>Return a threadbare version of a vector</p></a></li>
<li><a href='#wrap_error'><p>Utility function to output an error</p></a></li>
<li><a href='#zample'><p>Sample from a vector in a safe way</p></a></li>
<li><a href='#zeq'><p>Generate sequence in a safe way</p></a></li>
<li><a href='#zingle'><p>Return the single (unique) value found in a vector</p></a></li>
<li><a href='#zmisc'><p>zmisc: Vector Look-Ups and Safer Sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector Look-Ups and Safer Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Thor Torfason</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Thor Torfason &lt;m@zulutime.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of utility functions that facilitate looking up
    vector values from a lookup table, annotate values in at table for 
    clearer viewing, and support a safer approach to vector sampling, 
    sequence generation, and aggregation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/torfason/zmisc/">https://github.com/torfason/zmisc/</a>,
<a href="https://torfason.github.io/zmisc/">https://torfason.github.io/zmisc/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>desc, dplyr, haven, knitr, labelled, purrr, rmarkdown,
roxygen2, rprojroot, stringr, testthat, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 08:08:10 UTC; magnus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ddply_helper'>Apply a function to each column of a data.frame</h2><span id='topic+ddply_helper'></span>

<h3>Description</h3>

<p>Thin wrapper around <code>lapply()</code> that checks that the input is a table before
applying the function to each column, and converts the result back to a table
afterwards. If the <code>tibble</code> package is available and the input is a <code>tibble</code>,
the result will be a <code>tibble</code>; otherwise, it will be a plain <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddply_helper(d, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddply_helper_+3A_d">d</code></td>
<td>
<p>A <code>data.frame</code> or <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="ddply_helper_+3A_fun">fun</code></td>
<td>
<p>A function to apply to each column of <code>d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>tibble</code> with the function applied to each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  col1 = c(1, 2, 3),
  col2 = c(4, 5, 6)
)
sum_fun &lt;- function(x) sum(x)
result &lt;- ddply_helper(df, sum_fun)
print(result)

</code></pre>

<hr>
<h2 id='ll_assert_labelled'>Verify that x is a valid labelled variable</h2><span id='topic+ll_assert_labelled'></span>

<h3>Description</h3>

<p>Verify that x is a valid labelled variable satisfying the (minimal)
specification inherent in the parameter documentation of the
<code><a href="haven.html#topic+labelled">haven::labelled()</a></code> function for <code>haven_labelled</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_assert_labelled(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_assert_labelled_+3A_x">x</code></td>
<td>
<p>A labelled variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns x if the check is successful.
</p>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_labelled">ll_labelled</a>()</code>,
<code><a href="#topic+ll_to_character">ll_to_character</a>()</code>,
<code><a href="#topic+ll_val_labels">ll_val_labels</a>()</code>,
<code><a href="#topic+ll_var_label">ll_var_label</a>()</code>,
<code><a href="#topic+threadbare">threadbare</a>()</code>
</p>

<hr>
<h2 id='ll_labelled'>Create a labelled variable</h2><span id='topic+ll_labelled'></span>

<h3>Description</h3>

<p>The labelled_light (ll) collection is a minimal implementation of core
functions for creating and managing <code>haven_labelled</code> variables, and with
minimal dependencies. These functions, prefixed with <code>ll_</code> rely only on base
R, and operate only on objects of type <code>haven_labelled</code>. All functions check
internally that the variables have the correct class and the correct
structure for labelled variables, satisfying the (minimal) specification
inherent in the parameter documentation of the <code><a href="haven.html#topic+labelled">haven::labelled()</a></code> function.
</p>
<p>The constructor, <code>ll_labelled()</code>, creates a labelled variable satisfying that
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_labelled(x = double(), labels = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_labelled_+3A_x">x</code></td>
<td>
<p>A vector to label. Must be either numeric (integer or double) or
character.</p>
</td></tr>
<tr><td><code id="ll_labelled_+3A_labels">labels</code></td>
<td>
<p>A named vector or <code>NULL</code>. The vector should be the same type
as <code>x</code>. Unlike factors, labels don't need to be exhaustive: only a fraction
of the values might be labelled.</p>
</td></tr>
<tr><td><code id="ll_labelled_+3A_label">label</code></td>
<td>
<p>A short, human-readable description of the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid labelled variable.
</p>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_assert_labelled">ll_assert_labelled</a>()</code>,
<code><a href="#topic+ll_to_character">ll_to_character</a>()</code>,
<code><a href="#topic+ll_val_labels">ll_val_labels</a>()</code>,
<code><a href="#topic+ll_var_label">ll_var_label</a>()</code>,
<code><a href="#topic+threadbare">threadbare</a>()</code>
</p>

<hr>
<h2 id='ll_to_character'>Get the character representation of a labelled variable</h2><span id='topic+ll_to_character'></span>

<h3>Description</h3>

<p>Returns a character representation of a labelled variable, using the value
labels to look up the label for a given value.
</p>
<p>The default behavior of this function is similar to
<code><a href="labelled.html#topic+to_character">labelled::to_character()</a></code>. The options, however, are slightly different.
Most importantly, instead of specifying <code>NA</code> handling using parameters, the
function relies on the <code>default</code> parameter to determine what happens for
unlabelled variables, allowing users to specify including the original values
of <code>x</code> instead of the labels, returning <code>NA</code>, or returning a specific string
value. Also, the default behavior is to drop any variable label attribute, in
line with the default <code><a href="base.html#topic+as.character">as.character()</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_to_character(x, default = x, preserve_var_label = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_to_character_+3A_x">x</code></td>
<td>
<p>A labelled variable</p>
</td></tr>
<tr><td><code id="ll_to_character_+3A_default">default</code></td>
<td>
<p>Vector providing a default label for any values not found in
the <code>val_labels</code> (unlabelled values). Must be of length 1 or of the same
length as x. Useful possibilities are <code>x</code> (use values where labels are not
found), <code>NA</code> (return NA for such values), and <code>""</code> (an empty string).
Missing (<code>NA</code>) values in <code>x</code>, however, are never replaced with the default,
they remain <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ll_to_character_+3A_preserve_var_label">preserve_var_label</code></td>
<td>
<p>Should any <code>var_label</code> in x be preserved, or
should they be dropped from the result (ensuring that the result is bare
and without any attributes).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_assert_labelled">ll_assert_labelled</a>()</code>,
<code><a href="#topic+ll_labelled">ll_labelled</a>()</code>,
<code><a href="#topic+ll_val_labels">ll_val_labels</a>()</code>,
<code><a href="#topic+ll_var_label">ll_var_label</a>()</code>,
<code><a href="#topic+threadbare">threadbare</a>()</code>
</p>

<hr>
<h2 id='ll_val_labels'>Get or set value labels of a labelled variable</h2><span id='topic+ll_val_labels'></span><span id='topic+ll_val_labels+3C-'></span>

<h3>Description</h3>

<p>Gets or sets the value labels (<code>labels</code> attribute) of a labelled vector. The
getters/setters should be used rather than manipulating attributes directly,
since these functions perform checks to ensure that the result, and the
resulting labelled variable, are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_val_labels(x, always = FALSE)

ll_val_labels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_val_labels_+3A_x">x</code></td>
<td>
<p>A labelled variable</p>
</td></tr>
<tr><td><code id="ll_val_labels_+3A_always">always</code></td>
<td>
<p>Always return at least an empty vector of the correct
type, even if the attribute is not set.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_assert_labelled">ll_assert_labelled</a>()</code>,
<code><a href="#topic+ll_labelled">ll_labelled</a>()</code>,
<code><a href="#topic+ll_to_character">ll_to_character</a>()</code>,
<code><a href="#topic+ll_var_label">ll_var_label</a>()</code>,
<code><a href="#topic+threadbare">threadbare</a>()</code>
</p>

<hr>
<h2 id='ll_var_label'>Get or set variable label of a labelled variable</h2><span id='topic+ll_var_label'></span><span id='topic+ll_var_label+3C-'></span>

<h3>Description</h3>

<p>Gets or sets the variable label (<code>label</code> attribute) of a labelled vector. The
getters/setters should be used rather than manipulating attributes directly,
since these functions perform checks to ensure that the result, and the
resulting labelled variable, are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_var_label(x)

ll_var_label(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_var_label_+3A_x">x</code></td>
<td>
<p>A labelled variable</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_assert_labelled">ll_assert_labelled</a>()</code>,
<code><a href="#topic+ll_labelled">ll_labelled</a>()</code>,
<code><a href="#topic+ll_to_character">ll_to_character</a>()</code>,
<code><a href="#topic+ll_val_labels">ll_val_labels</a>()</code>,
<code><a href="#topic+threadbare">threadbare</a>()</code>
</p>

<hr>
<h2 id='lookup'>Lookup values from a lookup table</h2><span id='topic+lookup'></span><span id='topic+lookuper'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+lookup">lookup()</a></code> function implements lookup of certain strings (such as
variable names) from a lookup table which maps keys onto values (such as
variable labels or descriptions).
</p>
<p>The lookup table can be in the form of a two-column <code>data.frame</code>, in the form
of a named <code>vector</code>, or in the form of a <code>list</code>. If the table is in the form
of a <code>data.frame</code>, the lookup columns should be named <code>name</code> (for the key)
and <code>value</code> (for the value). If the lookup table is in the form of a named
<code>vector</code> or <code>list</code>, the name is used for the key, and the returned value is
taken from the values in the vector or list.
</p>
<p>Original values are returned if they are not found in the lookup table.
Alternatively, a <code>default</code> can be specified for values that are not found.
Note that an <code>NA</code> in x will never be found and will be replaced with the
default value. To specify different defaults for values that are not found
and for <code>NA</code> values in <code>x</code>, the <code>default</code> must be crafted manually to achieve
this.
</p>
<p>Any names in x are not included in the result.
</p>
<p>The <code><a href="#topic+lookuper">lookuper()</a></code> function returns <em>a function</em> equivalent to the <code><a href="#topic+lookup">lookup()</a></code>
function, except that instead of taking a lookup table as an argument, the
lookup table is embedded in the function itself.
</p>
<p>This can be very useful, in particular when using the lookup function as an
argument to other functions that expect a function which maps
<code>character</code>-&gt;<code>character</code> but do not offer a good way to pass additional
arguments to that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(x, lookup_table, default = x)

lookuper(lookup_table, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_x">x</code></td>
<td>
<p>A string vector whose elements are to be looked up.</p>
</td></tr>
<tr><td><code id="lookup_+3A_lookup_table">lookup_table</code></td>
<td>
<p>The lookup table to use.</p>
</td></tr>
<tr><td><code id="lookup_+3A_default">default</code></td>
<td>
<p>If a value is not found in the lookup table, the value will be
taken from <code>default</code>. This must be a character vector of length 1 or the
same length as x. Useful values include <code>x</code> (the default setting), <code>NA</code>, or
<code>""</code> (an empty string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+lookup">lookup()</a></code> function returns string vector based on <code>x</code>, with
values replaced with the lookup values from <code>lookup_table</code>. Any values not
found in the lookup table are taken from <code>default</code>.
</p>
<p>The <code><a href="#topic+lookuper">lookuper()</a></code> function returns <em>a function</em> that takes <code>character</code>
vectors as its argument <code>x</code>, and returns either the corresponding values
from the underlying lookup table, or the original values from x for those
elements that are not found in the lookup table (or looks them up from the
<code>default</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruit_lookup_vector &lt;- c(a="Apple", b="Banana", c="Cherry")
lookup(letters[1:5], fruit_lookup_vector)
lookup(letters[1:5], fruit_lookup_vector, default = NA)

mtcars_lookup_data_frame &lt;- data.frame(
  name = c("mpg", "hp", "wt"),
  value = c("Miles/(US) gallon", "Gross horsepower", "Weight (1000 lbs)"))
lookup(names(mtcars), mtcars_lookup_data_frame)

lookup_fruits &lt;- lookuper(list(a="Apple", b="Banana", c="Cherry"))
lookup_fruits(letters[1:5])

</code></pre>

<hr>
<h2 id='notate'>Embed factor levels and value labels in values.</h2><span id='topic+notate'></span>

<h3>Description</h3>

<p>This function adds level/label information as an annotation to either factors
or <code>labelled</code> variables. This function is called <code>notate()</code> rather than
<code>annotate()</code> to avoid conflict with <code>ggplot2::annotate()</code>. It is a generic that
can operate either on individual vectors or on a <code>data.frame</code>.
</p>
<p>When printing <code>labelled</code> variables from a <code>tibble</code> in a console, both the
numeric value and the text label are shown, but no variable labels. When
using the <code>View()</code> function, only variable labels are shown but no value
labels. For factors, there is no way to view the integer levels and values at
the same time.
</p>
<p>In order to allow the viewing of both variable and value labels at the same
time, this function converts both <code>factor</code> and <code>labelled</code> variables to
<code>character</code>, including both numeric levels (<code>labelled</code> values) and character
values (<code>labelled</code> labels) in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notate_+3A_x">x</code></td>
<td>
<p>The object (either vector or <code>date.frame</code> of vectors), that one
desires to annotate and/or view.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The processed <code>data.frame</code>, suitable for viewing, in particular
through the <code>View()</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  chr = letters[1:4],
  fct = factor(c("alpha", "bravo", "chrly", "delta")),
  lbl = ll_labelled(c(1, 2, 3, NA),
                    labels = c(one=1, two=2),
                    label = "A labelled vector")
)
dn &lt;- notate(d)
dn
# View(dn)

</code></pre>

<hr>
<h2 id='standardize_lookup_table'>Helper function to standardize the <code>lookup_table</code>.</h2><span id='topic+standardize_lookup_table'></span>

<h3>Description</h3>

<p>Preprocessing the lookup table to convert it to a list can take some time, so
when possible, we want to do it only once. Therefore we offload it to a
helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_lookup_table(lookup_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_lookup_table_+3A_lookup_table">lookup_table</code></td>
<td>
<p>The unstandardized lookup table (must still be one of the
formats specified for the <code>lookup()</code> function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lookup table as a list.
</p>

<hr>
<h2 id='threadbare'>Return a threadbare version of a vector</h2><span id='topic+threadbare'></span>

<h3>Description</h3>

<p>A bare object is an R object that has no class attributes (see
<code><a href="rlang.html#topic+bare-type-predicates">rlang::is_bare_character()</a></code>). A threadbare object is an atomic object (i.e.
not a <code><a href="base.html#topic+list">list()</a></code>, see <code><a href="base.html#topic+is.atomic">is.atomic()</a></code>), with no attributes at all. The function
returns an error if a list is passed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threadbare(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threadbare_+3A_x">x</code></td>
<td>
<p>A vector, possibly classed, but not a list object, to strip of all
attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the same core values as <code>x</code>, but with no <code><a href="base.html#topic+attributes">attributes()</a></code>
at all, not even <code><a href="base.html#topic+names">names()</a></code>.
</p>


<h3>See Also</h3>

<p>Other labelled light: 
<code><a href="#topic+ll_assert_labelled">ll_assert_labelled</a>()</code>,
<code><a href="#topic+ll_labelled">ll_labelled</a>()</code>,
<code><a href="#topic+ll_to_character">ll_to_character</a>()</code>,
<code><a href="#topic+ll_val_labels">ll_val_labels</a>()</code>,
<code><a href="#topic+ll_var_label">ll_var_label</a>()</code>
</p>

<hr>
<h2 id='wrap_error'>Utility function to output an error</h2><span id='topic+wrap_error'></span>

<h3>Description</h3>

<p>This function is used to capture errors, typically inside a <code>tryCatch()</code>
statement and output them in a clean and readable way. The function provides
line-wrapping, with a configurable width. When printing the error message, it
prefixes the text with &quot;<code style="white-space: pre;">&#8288;#E&gt; &#8288;</code>&quot; to make it easier to look for the error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_error(e, wrap = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_error_+3A_e">e</code></td>
<td>
<p>The error to wrap.</p>
</td></tr>
<tr><td><code id="wrap_error_+3A_wrap">wrap</code></td>
<td>
<p>How many characters per line before wrapping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original error is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatch(stop("This is an error"), error=wrap_error)

</code></pre>

<hr>
<h2 id='zample'>Sample from a vector in a safe way</h2><span id='topic+zample'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+zample">zample()</a></code> function duplicates the functionality of <code><a href="base.html#topic+sample">sample()</a></code>, with the
exception that it does not attempt the (sometimes dangerous)
user-friendliness of switching the interpretation of the first element to a
number if the length of the vector is 1. <code>zample()</code> <em>always</em> treats its first
argument as a vector containing elements that should be sampled, so your code
won't break in unexpected ways when the input vector happens to be of length
1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zample(x, size = length(x), replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zample_+3A_x">x</code></td>
<td>
<p>The vector to sample from</p>
</td></tr>
<tr><td><code id="zample_+3A_size">size</code></td>
<td>
<p>The number of elements to sample from <code>x</code> (defaults to <code>length(x)</code>)</p>
</td></tr>
<tr><td><code id="zample_+3A_replace">replace</code></td>
<td>
<p>Should elements be replaced after sampling (defaults to <code>false</code>)</p>
</td></tr>
<tr><td><code id="zample_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights (defaults to equal probabilities)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If what you really want is to sample from an interval between 1 and n, you can
use <code>sample(n)</code> or <code>sample.int(n)</code> (but make sure to only pass vectors of
length one to those functions).
</p>


<h3>Value</h3>

<p>The resulting sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For vectors of length 2 or more, zample() and sample() are identical
set.seed(42); zample(7:11)
set.seed(42); sample(7:11)

# For vectors of length 1, zample() will still sample from the vector,
# whereas sample() will "magically" switch to interpreting the input
# as a number n, and sampling from the vector 1:n.
set.seed(42); zample(7)
set.seed(42); sample(7)

# The other arguments work in the same way as for sample()
set.seed(42); zample(7:11, size=13, replace=TRUE, prob=(5:1)^3)
set.seed(42); sample(7:11, size=13, replace=TRUE, prob=(5:1)^3)

# Of course, sampling more than the available elements without
# setting replace=TRUE will result in an error
set.seed(42); tryCatch(zample(7, size=2), error=wrap_error)

</code></pre>

<hr>
<h2 id='zeq'>Generate sequence in a safe way</h2><span id='topic+zeq'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+zeq">zeq()</a></code> function creates an increasing integer sequence, but differs from
the standard one in that it will not silently generate a decreasing sequence
when the second argument is smaller than the first. If the second argument is
one smaller than the first it will generate an empty sequence, if the
difference is greater, the function will throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeq(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeq_+3A_from">from</code></td>
<td>
<p>The lower bound of the sequence</p>
</td></tr>
<tr><td><code id="zeq_+3A_to">to</code></td>
<td>
<p>The higher bound of the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence ranging from <code>from</code> to <code>to</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For increasing sequences, zeq() and seq() are identical
zeq(11,15)
zeq(11,11)

# If second argument equals first-1, an empty sequence is returned
zeq(11,10)

# If second argument is less than first-1, the function throws an error
tryCatch(zeq(11,9), error=wrap_error)

</code></pre>

<hr>
<h2 id='zingle'>Return the single (unique) value found in a vector</h2><span id='topic+zingle'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+zingle">zingle()</a></code> function returns the first element in a vector, but only if
all the other elements are identical to the first one (the vector only has a
<code>zingle</code> value). If the elements are not all identical, it throws an error.
The vector must contain at least one non-<code>NA</code> value, or the function errors
out as well. This is especially useful in aggregations, when all values in a
given group should be identical, but you want to make sure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zingle(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zingle_+3A_x">x</code></td>
<td>
<p>Vector of elements that should all be identical</p>
</td></tr>
<tr><td><code id="zingle_+3A_na.rm">na.rm</code></td>
<td>
<p>Should <code>NA</code> elements be removed prior to comparison</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optionally takes a <code>na.rm</code> parameter, similarly to sum, mean and other
aggregate functions. If <code>TRUE</code>, <code>NA</code> values will be removed prior to
comparing the elements, so the function will accept input values that contain
a combination of the single value and any <code>NA</code> values (but at least one
non-<code>NA</code> value is required).
</p>
<p>Only values are tested for equality. Any names are simply ignored, and the
result is an unnamed value. This is in line with how other aggregation
functions handle names.
</p>


<h3>Value</h3>

<p>The <code>zingle</code> element in the vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If all elements are identical, all is good.
# The value of the element is returned.
zingle(c("Alpha", "Alpha", "Alpha"))

# If any elements differ, an error is thrown
tryCatch(zingle(c("Alpha", "Beta", "Alpha")), error=wrap_error)

if (require("dplyr", quietly=TRUE, warn.conflicts=FALSE)) {
  d &lt;- tibble::tribble(
    ~id, ~name, ~fouls,
    1, "James", 3,
    2, "Jack",  2,
    1, "James", 4
  )

  # If the data is of the correct format, all is good
  d %&gt;%
    dplyr::group_by(id) %&gt;%
    dplyr::summarise(name=zingle(name), total_fouls=sum(fouls))
 }

if (require("dplyr", quietly=TRUE, warn.conflicts=FALSE)) {
  # If a name does not match its ID, we should get an error
  d[1,"name"] &lt;- "Jammes"
  tryCatch({
    d %&gt;%
      dplyr::group_by(id) %&gt;%
      dplyr::summarise(name=zingle(name), total_fouls=sum(fouls))
  }, error=wrap_error)
}
</code></pre>

<hr>
<h2 id='zmisc'>zmisc: Vector Look-Ups and Safer Sampling</h2><span id='topic+zmisc'></span><span id='topic+zmisc-package'></span>

<h3>Description</h3>

<p>A collection of utility functions that facilitate looking up
vector values from a lookup table, annotate values in at table for
clearer viewing, and support a safer approach to vector sampling,
sequence generation, and aggregation.
</p>
<p>For more information, see vignette(&quot;zmisc&quot;).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/torfason/zmisc/">https://github.com/torfason/zmisc/</a>
</p>
</li>
<li> <p><a href="https://torfason.github.io/zmisc/">https://torfason.github.io/zmisc/</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
