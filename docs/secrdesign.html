<!DOCTYPE html><html lang="en"><head><title>Help for package secrdesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {secrdesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#secrdesign-package'><p>Spatially Explicit Capture&ndash;Recapture Study Design</p></a></li>
<li><a href='#costing'><p>Cost of SECR design</p></a></li>
<li><a href='#count'><p>Extract Summaries</p></a></li>
<li><a href='#estimateSummary'><p>Direct summary of estimate tables</p></a></li>
<li><a href='#expand.arg'><p>Expand Argument List</p></a></li>
<li><a href='#GAoptim'>
<p>SECR detector placement by maximisation of a simple criterion</p>
</p></a></li>
<li><a href='#getdetectpar'><p>Ballpark Detection Parameters</p></a></li>
<li><a href='#Internal'><p>Internal Functions</p></a></li>
<li><a href='#Lambda'><p>Expected Detections</p></a></li>
<li><a href='#make.array'><p> Re-cast Simulated Statistical Output as Array</p></a></li>
<li><a href='#make.scenarios'><p>Construct Scenario Data Frame</p></a></li>
<li><a href='#minsimRSE'><p> Optimal Spacing by Simulation</p></a></li>
<li><a href='#optimalSpacing'><p>Optimal Detector Spacing</p></a></li>
<li><a href='#plot.optimalSpacing'><p>Plot and print methods for optimalSpacing object</p></a></li>
<li><a href='#predict.fittedmodels'><p> Extract Estimates From Fitted Models</p></a></li>
<li><a href='#rbind.estimatetables'>
<p>Combine Simulation Output</p>
</p></a></li>
<li><a href='#run.scenarios'><p>Simulate Sampling Designs</p></a></li>
<li><a href='#saturation'><p>Detector saturation</p></a></li>
<li><a href='#scenariosFromStatistics'><p>Make Scenarios to Match Capture Statistics</p></a></li>
<li><a href='#scenarioSummary'><p>Summary of Scenarios</p></a></li>
<li><a href='#select.stats'><p> Select Statistics to Summarize</p></a></li>
<li><a href='#summary.secrdesign'><p>Generic Methods for secrdesign Objects</p></a></li>
<li><a href='#transformOutput'>
<p>Transform Simulation Output</p>
</p></a></li>
<li><a href='#validate'><p>Reject Implausible Statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sampling Design for Spatially Explicit Capture-Recapture</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for designing spatially explicit capture-recapture studies of animal populations. This is primarily a simulation manager for package 'secr'. Extensions in version 2.5.0 include costing and evaluation of detector spacing.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), secr (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, kofnGA, parallel, sf, Rcpp (&ge; 0.12.14)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>secrlinear, ipsecr (&ge; 1.4.0), testthat (&ge; 0.11.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>,
<a href="https://github.com/MurrayEfford/secrdesign/">https://github.com/MurrayEfford/secrdesign/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 23:11:19 UTC; murra</td>
</tr>
<tr>
<td>Author:</td>
<td>Murray Efford <a href="https://orcid.org/0000-0001-5231-5184"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ian Durbach <a href="https://orcid.org/0000-0003-0769-2153"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Murray Efford &lt;murray.efford@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-27 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='secrdesign-package'>Spatially Explicit Capture&ndash;Recapture Study Design </h2><span id='topic+secrdesign-package'></span><span id='topic+secrdesign'></span>

<h3>Description</h3>

<p>Tools to assist the design of spatially explicit capture&ndash;recapture studies of animal populations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> secr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.9.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-09-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GNU General Public License Version 2 or later</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The primary use of <span class="pkg">secrdesign</span> is to predict by Monte Carlo
simulation the precision or bias of density estimates from different
detector layouts, given pilot values for density and the detection
parameters lambda0/g0 and sigma.
</p>
<p>Tools are also provided for predicting the performance of detector layouts 
without simulation, and for optimising layouts to meet various criteria, 
particularly expected counts.
</p>
<p>The simulation functions in <span class="pkg">secrdesign</span> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+make.scenarios">make.scenarios</a></code> </td><td style="text-align: left;"> generate dataframe of parameter values etc. </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+run.scenarios">run.scenarios</a></code> </td><td style="text-align: left;"> perform simulations, with or without model fitting </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fit.models">fit.models</a></code> </td><td style="text-align: left;"> fit SECR model(s) to rawdata output from <code>run.scenarios</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+predict.fittedmodels">predict.fittedmodels</a></code> </td><td style="text-align: left;"> infer `real' parameter
  estimates from fitted models </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+select.stats">select.stats</a></code> </td><td style="text-align: left;"> collect output for a particular
  parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+summary.selectedstatistics">summary.selectedstatistics</a></code> </td><td style="text-align: left;"> numerical summary of results </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code><a href="#topic+plot.selectedstatistics">plot.selectedstatistics</a></code> </td><td style="text-align: left;"> histogram or CI plot for
  each scenario </td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td>
</tr>

</table>

<p><img src="../help/figures/secrdesign-fig1.png" width=700 alt="secrdesign-fig1.png" />

</p>
<p><b>Fig.</b> Core simulation functions in <span class="pkg">secrdesign</span> (yellow) and their main inputs and outputs. Output from the simulation function run.scenarios() may be saved as whole fitted models, predicted values (parameter estimates), or selected statistics. Each form of output requires different subsequent handling. The default path is shown by solid blue arrows. <br />
</p>
<p>Other functions not used exclusively for simulation are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+Enrm">Enrm</a></code> </td><td style="text-align: left;"> expected numbers of individuals <code class="reqn">n</code>, re-detections <code class="reqn">r</code> and movements <code class="reqn">m</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+En2">En2</a></code> </td><td style="text-align: left;"> expected number of individuals detected at two or more detectors </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+minnrRSE">minnrRSE</a></code> </td><td style="text-align: left;"> approximate RSE(D-hat) given sample size (<code class="reqn">n</code>, <code class="reqn">r</code>) (Efford and Boulanger 2019)</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+GAoptim">GAoptim</a></code> </td><td style="text-align: left;"> optimization of detector placement using genetic algorithm (Durbach et al. 2021) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+costing">costing</a></code> </td><td style="text-align: left;"> various cost components </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+saturation">saturation</a></code> </td><td style="text-align: left;"> expected detector saturation (trap success) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+scenarioSummary">scenarioSummary</a></code> </td><td style="text-align: left;"> applies <code>Enrm</code>, <code>minnrRSE</code>, and other summaries to each scenario in a dataframe </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+optimalSpacing">optimalSpacing</a></code> </td><td style="text-align: left;"> optimal detector spacing by rule-of-thumb and simulation RSE(D-hat)</td>
</tr>
<tr>
 <td style="text-align: left;">
  
</td>
</tr>

</table>

<p>A vignette documenting the simulation functions is available at <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-vignette.pdf">secrdesign-vignette.pdf</a>. An Appendix in that vignette has code for various examples that should help get you started. 
</p>
<p>Documentation for expected counts is in <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-Enrm.pdf">secrdesign-Enrm.pdf</a>. Another vignette <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-tools.pdf">secrdesign-tools.pdf</a> demonstrates other tools. These include the <code>optimalSpacing</code> function, for finding the detector spacing that yields the greatest precision for a given detector geometry, number of sampling occasions, density and detection parameters.
</p>
<p>Help pages are also available as <a href="../doc/secrdesign-manual.pdf">../doc/secrdesign-manual.pdf</a>.
</p>


<h3>Author(s)</h3>

<p> Murray Efford <a href="mailto:murray.efford@otago.ac.nz">murray.efford@otago.ac.nz</a> </p>


<h3>References</h3>

<p>Durbach, I., Borchers, D., Sutherland, C. and Sharma, K. (2021) Fast, flexible 
alternatives to regular grid designs for spatial capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em> <b>12</b>, 298&ndash;310. DOI 10.1111/2041-210X.13517
</p>
<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529&ndash;1535. DOI: 10.1111/2041-210X.13239
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+make.grid">make.grid</a></code>, 
<code><a href="secr.html#topic+sim.popn">sim.popn</a></code>, 
<code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>,  
<code><a href="secr.html#topic+secr.fit">secr.fit</a></code>
</p>

<hr>
<h2 id='costing'>Cost of SECR design</h2><span id='topic+costing'></span>

<h3>Description</h3>

<p>The cost of implementing a spatially explicit capture&ndash;recapture design depends on the detector layout, the number of detections and the various unit costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costing(traps, nr, noccasions, unitcost = list(), nrepeats = 1, routelength = NULL, 
    setupoccasion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="costing_+3A_traps">traps</code></td>
<td>
<p>traps object for detector array</p>
</td></tr>
<tr><td><code id="costing_+3A_nr">nr</code></td>
<td>
<p>numeric vector with E(<code class="reqn">n</code>) and E(<code class="reqn">r</code>) as first two elements</p>
</td></tr>
<tr><td><code id="costing_+3A_noccasions">noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td></tr>
<tr><td><code id="costing_+3A_unitcost">unitcost</code></td>
<td>
<p>list with unit costs (see Details)</p>
</td></tr>
<tr><td><code id="costing_+3A_nrepeats">nrepeats</code></td>
<td>
<p>integer number of repeated arrays</p>
</td></tr>
<tr><td><code id="costing_+3A_routelength">routelength</code></td>
<td>
<p>numeric route length (km)</p>
</td></tr>
<tr><td><code id="costing_+3A_setupoccasion">setupoccasion</code></td>
<td>
<p>logical; if TRUE then the cost of a setup visit is included (noccasions+1) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nr</code> is a vector with the expected sample sizes (numbers of individuals and recaptures), usually the output from <code><a href="#topic+Enrm">Enrm</a></code>.
</p>
<p><code>unitcost</code> should be a list with at least one of the components &lsquo;perkm&rsquo;, &lsquo;perarray&rsquo;, &lsquo;perdetector&rsquo;, &lsquo;pervisit&rsquo; and &lsquo;perdetection&rsquo;. 
</p>
<p>The number of occasions (noccasions) is incremented by 1 if <code>setupoccasion</code> is TRUE.
</p>

<table>
<tr>
 <td style="text-align: left;">
Component </td><td style="text-align: left;"> Unit cost </td><td style="text-align: left;"> Costing </td>
</tr>
<tr>
 <td style="text-align: left;">
Arrays </td><td style="text-align: left;"> perarray </td><td style="text-align: left;"> perarray x nrepeats </td>
</tr>
<tr>
 <td style="text-align: left;">
Detectors </td><td style="text-align: left;"> perdetector </td><td style="text-align: left;"> perdetector x nrow(traps) x nrepeats </td>
</tr>
<tr>
 <td style="text-align: left;">
Travel </td><td style="text-align: left;">  perkm </td><td style="text-align: left;"> perkm x routelength x noccasions x nrepeats </td>
</tr>
<tr>
 <td style="text-align: left;">
Visits </td><td style="text-align: left;"> pervisit </td><td style="text-align: left;"> sum(pervisit x trapcost) x noccasions x nrepeats </td>
</tr>
<tr>
 <td style="text-align: left;">
Detections </td><td style="text-align: left;"> perdetection </td><td style="text-align: left;"> perdetection x total detections (E(<code class="reqn">n</code>) + E(<code class="reqn">r</code>)) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>&lsquo;Travel&rsquo; and &lsquo;Visits&rsquo; are alternative ways to cost field time. The variable &lsquo;routelength&rsquo; represents the length of a path followed to visit all detectors; if not specified it is approximated by the sum of the nearest-trap distances. The variable &lsquo;trapcost&rsquo; is a vector of length equal to the number of detectors. By default it is a vector of 1's, but detector- specific values may be provided as trap covariate &lsquo;costpervisit&rsquo;. In the latter case the value of &lsquo;pervisit&rsquo; should probably be 1.0.
</p>
<p>&lsquo;Arrays&rsquo; and 'Detectors' represent one-off costs.
</p>
<p>&lsquo;Detections&rsquo; includes costs such as handling time and laboratory DNA analysis.
</p>
<p>See  <a href="../doc/secrdesign-tools.pdf">../doc/secrdesign-tools.pdf</a> for more.
</p>


<h3>Value</h3>

<p>A named numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Enrm">Enrm</a></code>, <code><a href="#topic+scenarioSummary">scenarioSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr &lt;- make.grid(8, 8, spacing = 25)
msk &lt;- make.mask(tr, buffer = 100, type = 'trapbuffer')
nrm &lt;- Enrm(D = 5, tr, msk, list(lambda0 = 0.2, sigma = 20), 5)
costing (tr, nrm, 5, unitcost = list(pervisit = 5, perdetection = 15))

</code></pre>

<hr>
<h2 id='count'>Extract Summaries</h2><span id='topic+count'></span><span id='topic+coef.summary'></span><span id='topic+predict.summary'></span><span id='topic+count.summary'></span>

<h3>Description</h3>

<p>Reshape results from <code>run.scenarios(..., extractfn = summary)</code> so that they may be passed to the usual summary functions of <span class="pkg">secrdesign</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
count(object, ...)

## S3 method for class 'summary'
predict(object, ...)
## S3 method for class 'summary'
coef(object, ...)
## S3 method for class 'summary'
count(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_+3A_object">object</code></td>
<td>
<p>summary simulation output from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim is to extract numerical results from simulations performed using <code>run.scenarios(..., extractfn = summary)</code>. The results may then be passed to the summary method for &lsquo;secrdesign&rsquo; objects, possibly via <code><a href="#topic+select.stats">select.stats</a></code> (see Examples).
</p>


<h3>Value</h3>

<p>An object of class <code>c("estimatetables", "secrdesign", "list")</code> in which the output component for each scenario is a list of dataframes, one per replicate. The structure of each dataframe is indicated in the following table (parameters may vary with model); &lsquo;parameters&rsquo; and &lsquo;statistics&rsquo; correspond to arguments of <code><a href="#topic+select.stats">select.stats</a></code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> </td><td style="text-align: left;"> Row(s) </td><td style="text-align: left;"> </td><td style="text-align: left;"> Columns </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> </td><td style="text-align: left;"> (parameters) </td><td style="text-align: left;"> </td><td style="text-align: left;"> (statistics) </td>
</tr>
<tr>
 <td style="text-align: left;">

count </td><td style="text-align: left;"> </td><td style="text-align: left;">  Number </td><td style="text-align: left;"> </td><td style="text-align: left;"> Animals, Detections, Moves </td>
</tr>
<tr>
 <td style="text-align: left;">
coef </td><td style="text-align: left;"> </td><td style="text-align: left;">  D, g0, sigma </td><td style="text-align: left;"> </td><td style="text-align: left;">  estimate, SE.estimate, lcl, ucl </td>
</tr>
<tr>
 <td style="text-align: left;">
predict </td><td style="text-align: left;"> </td><td style="text-align: left;">  D, g0, sigma </td><td style="text-align: left;"> </td><td style="text-align: left;">  estimate, SE.estimate, lcl, ucl </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="secr.html#topic+predict.secr">predict.secr</a></code>,
<code><a href="secr.html#topic+coef.secr">coef.secr</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate some simulations
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid(6, 6, spacing = 25)
sims1 &lt;- run.scenarios(nrepl = 2, trapset = traps1, scenarios =
     scen1, seed = 345, fit = TRUE, extractfn = summary)

## view the results
count(sims1)$output
predict(sims1)$output

summary(sims1)  ## header only

summary(count(sims1))   # equivalent to following
summary(select.stats(count(sims1), parameter = 'Number'))  

summary(predict(sims1)) # default select.stats parameter = 'D'
summary(select.stats(predict(sims1), parameter = 'sigma')  )

</code></pre>

<hr>
<h2 id='estimateSummary'>Direct summary of estimate tables</h2><span id='topic+estimateArray'></span><span id='topic+estimateSummary'></span>

<h3>Description</h3>

<p>An alternative approach to summarising output from <code>run.scenarios</code>
(cf <code><a href="#topic+summary.estimatetables">summary.estimatetables</a></code>). <code>estimateSummary</code> is 
especially useful when <code>extractfn = predict</code> or <code>extractfn = coef</code>,
and all scenarios have group structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
estimateArray(object)

estimateSummary(object, parameter = "D", statistics = c("true", "nvalid", 
    "EST", "seEST", "RB", "seRB", "RSE", "RMSE", "rRMSE", "COV"), true,
    validrange = c(0, Inf), checkfields = c('estimate','SE.estimate'),
    format = c('data.frame', 'list'), cols = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateSummary_+3A_object">object</code></td>
<td>
<p>secrdesign object of class &quot;estimatetables&quot;</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_parameter">parameter</code></td>
<td>
<p>character name of parameter (row in estimate table)</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_statistics">statistics</code></td>
<td>
<p>character choice of outputs</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_true">true</code></td>
<td>
<p>numeric vector of true values, one per scenario and group</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_validrange">validrange</code></td>
<td>
<p>numeric allowed for estimates or other checkfields</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_checkfields">checkfields</code></td>
<td>
<p>character choice of columns in each estimate table that 
will be checked against validrange</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_format">format</code></td>
<td>
<p>character choice of output</p>
</td></tr>
<tr><td><code id="estimateSummary_+3A_cols">cols</code></td>
<td>
<p>indices of scenario columns to include when format = &quot;data.frame&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'predict(fittedmodel)' in <code><a href="#topic+run.scenarios">run.scenarios</a></code> generates more than 
one estimate table (i.e. when the model uses groups, mixture classes or 
multiple sessions), the default extract function retains only the first. 
This is often OK, but it can be frustrating if you care about 
group- or session-specific estimates.
</p>
<p>The alternative is to use 'predict' as the run.scenarios extractfn, which 
retains all estimate tables. This requires a different function for 
summarisation; <code>estimateSummary</code> will suffice for many purposes.
</p>
<p><code>estimateSummary</code> internally calls <code>estimateArray</code> to pre-process 
the output from run.scenarios.
</p>
<p>The code should be examined for the precise definition of each statistic.
</p>
<p>True parameter values are required for RB, RMSE and COV, and these are computed 
even if later dropped from the output. If provided, the argument <code>true</code> 
should have length equal to the number of parameter tables in each replicate, 
i.e. (number of scenarios) * (number of groups), ordered by scenario. 
Otherwise, true values will be taken from rows of the data frame object$scenarios.
</p>
<p>Replicates are rejected (set to NA) if any <code>checkfields</code> 
falls outside <code>validrange</code>.
</p>
<p>Output statistics &lsquo;EST&rsquo;, &lsquo;RB&rsquo;, and &lsquo;RSE&rsquo; are means 
across replicates, and &lsquo;seEST&rsquo;, &lsquo;seRB&rsquo; the corresponding standard errors.
</p>
<p>The output list may optionally be formatted as a data.frame with pre-pended 
columns from object$scenarios. Set <code>cols</code> to 0 or NULL for no scenario 
columns.
</p>
<p><code>cols</code> defaults to <code>c("scenario", "group")</code> if groups are present and <code>"scenario"</code> otherwise. 
</p>


<h3>Value</h3>

<p><code>estimateArray</code> &ndash;
array with dimensions (Parameter, statistic, Group, Scenario, Replicate)
</p>
<p><code>estimateSummary</code> &ndash;
</p>
<p>If groups present and format = &quot;list&quot; - a list of matrices (group x scenario), one for each statistic:
</p>
<table role = "presentation">
<tr><td><code>true.X</code></td>
<td>
<p>true value of parameter (X)</p>
</td></tr>
<tr><td><code>nvalid</code></td>
<td>
<p>number of valid replicates used in later summaries</p>
</td></tr>
<tr><td><code>EST</code></td>
<td>
<p>mean of parameter estimates</p>
</td></tr>
<tr><td><code>seEST</code></td>
<td>
<p>standard error of estimates (across replicates)</p>
</td></tr>
<tr><td><code>RB</code></td>
<td>
<p>relative bias</p>
</td></tr>
<tr><td><code>seRB</code></td>
<td>
<p>standard error of replicate-specific RB (across replicates)</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>relative standard error (SE.estimate/estimate)</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>root mean squared error</p>
</td></tr>
<tr><td><code>rRMSE</code></td>
<td>
<p>RMSE/true.X</p>
</td></tr>
<tr><td><code>COV</code></td>
<td>
<p>coverage of confidence intervals (usually 95% intervals).</p>
</td></tr>
</table>
<p>If groups absent and format = &quot;list&quot; - a list of vectors (one element per scenario) with statistics as above.
</p>
<p>If format = &quot;data.frame&quot; - a data frame with rows corresponding to group x scenario (or session x scenario) combinations and columns corresponding to statistics as above.
</p>


<h3>Note</h3>

<p>These functions were introduced in version 2.8.1. They may change in later versions. 
The default format was changed to &lsquo;data.frame&rsquo; in 2.8.3.
</p>
<p>Results may be confusing when scenarios have group structure and groups 
are not used in the fitted model.
</p>
<p>It is assumed that all scenarios (and all models in a multi-model fit) report the same parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>,
<code><a href="#topic+header">header</a></code>,
<code><a href="#topic+summary.estimatetables">summary.estimatetables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# 2-scenario, 2-group simulation
scen8 &lt;- make.scenarios (D = 8, g0 = 0.3, sigma = 30, 
    noccasions = c(4,8), groups = c('F','M'))
    
# replace density and sigma values of males to make it interesting 
male &lt;- scen8$group == 'M'
scen8$D[male] &lt;- 4
scen8$sigma[male] &lt;- 40

grid &lt;- make.grid(8, 8, spacing = 30)
mask &lt;- make.mask(grid, buffer = 160, type = 'trapbuffer')

old &lt;- options(digits = 3)
setNumThreads(2)

#--------------------------------------------------------------------------
# run a few simulations

# model groups
sims &lt;- run.scenarios(10, scen8, trapset = grid, fit = TRUE, 
    fit.args = list(model = list(D~g, g0~1, sigma~g), groups = 'group'),
    extractfn = predict, maskset = mask)

# format as list, selecting statistics
# default summary uses true = c(8,4,8,4)  
estimateSummary(sims, 'D', c("true", "nvalid", "EST", "RB", "seRB"))

# format as data.frame by scenario and group, all statistics
estimateSummary(sims, 'D',  format = 'data.frame')

#--------------------------------------------------------------------------
# try with default extractfn (single table per replicate, despite groups)
sims2 &lt;- run.scenarios(10, scen8, trapset = grid, fit = TRUE, 
     maskset = mask)

# Fails with "Error in estimateSummary(sims2, "D") : incongruent 'true'""
# estimateSummary(sims2, 'D')

# OK if manually provide scenario-specific true density
estimateSummary(sims2, 'D', true = c(12,12))

# reformat by scenario
estimateSummary(sims2, 'D', true = c(12,12), format = 'data.frame')

# compare standard summary
summary(sims2)$OUTPUT

#--------------------------------------------------------------------------

# multiple estimate tables also arise from multi-session simulations
# argument 'true' must be specified manually
# interpret with care: sessions are (probably) not independent
# this example uses the previous grid and mask

scen9 &lt;- make.scenarios (D = 8, g0 = 0.3, sigma = 30, noccasions = 5)
poparg &lt;- list(nsessions = 3, details = list(lambda = 1.2))  # for sim.popn
detarg &lt;- list(renumber = FALSE)                             # for sim.capthist
fitarg &lt;- list(model = D~Session)                            # for secr.fit

sims3 &lt;- run.scenarios(5, scen9, trapset = grid, fit = TRUE, 
    maskset = mask, pop.args = poparg, det.args = detarg,
    fit.args = fitarg, extractfn = predict)
    
estimateSummary(sims3, parameter = 'D', format = 'data.frame', 
    true = 8 * 1.2^(0:2))
#--------------------------------------------------------------------------

# extractfn = coef results in a single estimate table per replicate,
# so the usual summary method is sufficent. For completeness we show 
# that estimateSummary can also be used. Coefficients are often negative,
# so relative values (e.g., RB, RSE) may be meaningless.

sims4 &lt;- run.scenarios(5, scen9, trapset = grid, fit = TRUE, 
    maskset = mask, pop.args = poparg, det.args = detarg,
    fit.args = fitarg, extractfn = coef)
    
estimateSummary(sims4, parameter = 'D', c("nvalid", "EST", "seEST", "RMSE", "COV"), 
    format = 'data.frame', true = log(8), checkfields = 'beta', 
    validrange = log(c(2,20)))

estimateSummary(sims4, parameter = 'D.Session', c("nvalid", "EST", "seEST", 
    "RMSE", "COV"), format = "data.frame", true = log(1.2), checkfields = "beta", 
    validrange = log(c(0.5,2)))
#--------------------------------------------------------------------------

options(old)



</code></pre>

<hr>
<h2 id='expand.arg'>Expand Argument List</h2><span id='topic+expand.arg'></span>

<h3>Description</h3>

<p>Generate a list of lists from vectors of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
expand.arg(..., sublist = list())

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.arg_+3A_...">...</code></td>
<td>
<p>named vectors of argument values</p>
</td></tr>
<tr><td><code id="expand.arg_+3A_sublist">sublist</code></td>
<td>
<p>named list of character vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The full 'pop.args', 'det.args' and 'fit.args' arguments of <code><a href="#topic+run.scenarios">run.scenarios</a></code> are lists of lists corresponding to the popindex, detindex and fitindex columns in scenarios.
</p>
<p><code>expand.arg</code> constructs such lists from all possible combinations of specified arguments, with invariant arguments appended. 
</p>
<p><code>sublist</code> may be specified to shift one or more named subsets of ... arguments to a sub-list such as 'detectpar' (see Examples).
</p>


<h3>Value</h3>

<p>A list of lists. A flat dataframe of combinations is returned as the attribute 'comb'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate some arguments for sim.capthist
## noccasions is constant

expand.arg(detectfn = c('HN','EX'), noccasions = 5)

## detectpar sub-list

expand.arg(lambda0 = c(0.1, 0.2), sigma = 20, detectfn = c('HHN','HEX'),
    sublist = list(detectpar = c('lambda0','sigma')))

</code></pre>

<hr>
<h2 id='GAoptim'>
SECR detector placement by maximisation of a simple criterion
</h2><span id='topic+GAoptim'></span>

<h3>Description</h3>

<p>Implements the approach of Durbach et al. (2021) for optimization of detector 
placement using a genetic algorithm to maximize the lesser 
of E(<code class="reqn">n</code>) and E(<code class="reqn">r</code>), where <code class="reqn">n</code> is the number of distinct individuals 
and <code class="reqn">r</code> is the total number of recaptures. This criterion predicts the 
relative standard error of the density estimate (Efford and Boulanger 2019).
</p>
<p>Users may choose the criterion to be maximised. The number of individuals 
detected at two or more detectors is an alternative of particular interest 
(Dupont et al. 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
GAoptim(mask, alltraps, ntraps, detectpar, noccasions, 
    detectfn = c("HHN", "HHR", "HEX", "HAN", "HCG"), D = NULL, 
    criterion = 4, penalty = NULL, seed = NULL, ...)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GAoptim_+3A_mask">mask</code></td>
<td>
<p>mask object</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_alltraps">alltraps</code></td>
<td>
<p>traps object with all possible trap locations</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_ntraps">ntraps</code></td>
<td>
<p>number of required trap locations </p>
</td></tr>
<tr><td><code id="GAoptim_+3A_detectpar">detectpar</code></td>
<td>
<p>list values of detection parameters lambd0, sigma etc.</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function - see <a href="secr.html#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="GAoptim_+3A_noccasions">noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_d">D</code></td>
<td>
<p>numeric density animals per hectare (0.01 km^2)</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_criterion">criterion</code></td>
<td>
<p>integer code for criterion to maximise, or function (see Details)</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_penalty">penalty</code></td>
<td>
<p>list defining penalty for layout in relation to reference grid (optional)</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_seed">seed</code></td>
<td>
<p>set a random seed for reproducibility of GA</p>
</td></tr>
<tr><td><code id="GAoptim_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="kofnGA.html#topic+kofnGA">kofnGA</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>detectpar</code> is a named list with values of the detection parameters for the chosen detectfn. Usually this will be just lambda0 (baseline hazard of detection) and sigma (spatial scale of detection).
</p>
<p>The genetic algorithm is provided by function <code>kofnGA</code> from package <span class="pkg">kofnGA</span> (Wolters 2015). The first three arguments of <code>kofnGA</code> (i.e., n, k, OF) are set by <code>GAoptim</code>. Others may be adjusted by the user via the ... argument. Specifically,
</p>

<table>
<tr>
 <td style="text-align: left;">

Argument </td><td style="text-align: left;"> Default </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
ngen </td><td style="text-align: left;"> 500 </td><td style="text-align: left;"> number of generations to run </td>
</tr>
<tr>
 <td style="text-align: left;">

popsize </td><td style="text-align: left;"> 200 </td><td style="text-align: left;"> size of the population; equivalently, the number of offspring produced each generation </td>
</tr>
<tr>
 <td style="text-align: left;">

mutprob </td><td style="text-align: left;"> 0.01 </td><td style="text-align: left;"> mutation rate </td>
</tr>
<tr>
 <td style="text-align: left;">

verbose </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> integer controlling the display of progress during search. If a positive value, then the iteration number and best objective function value are displayed at the console every 'verbose' generations. Otherwise nothing is displayed. The default gives no display. </td>
</tr>
<tr>
 <td style="text-align: left;">

cluster </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> number of parallel cores or a prebuilt parallel cluster </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>

<p>The default for ngen may (or may not) be larger than is needed for routine use. Durbach et al. (2021) used ngen = 50, popsize = 1000 and mutprob = 0.01. 
</p>
<p>Density D may be a scalar or a vector of length equal to the number of mask cells. No value need be specified if the sole aim is to optimize trap placement, but D is required for predictions of E(<code class="reqn">n</code>) and E(<code class="reqn">r</code>).
</p>
<p>Pathological detector layouts (sensu Efford and Boulanger 2019) may be avoided by adding a penalty to the objective.
No penalty is applied by default. To apply a penalty, <code>penalty</code> should be a list with named components pen_wt&gt;0 and pen_gridsigma). If a penalty is applied, the default compares the number of trap pairs with close spacing (2.5-3.5 sigma, 3.5-4.5 sigma) to the number in a compact sample from a regular grid with spacing sigma * pen_gridsigma (see internal functions <code><a href="#topic+GApenfn">GApenfn</a></code> and <code><a href="#topic+compactSample">compactSample</a></code> and the vignette).  An alternative penalty function may be supplied as component &lsquo;pen_fn&rsquo; of <code>penalty</code>.
</p>
<p>The default criterion is the minimum of E(n) and E(r) as used by Durbach et al. (2021).
The full list of builtin possibilities is:
</p>

<table>
<tr>
 <td style="text-align: left;">

Code </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Note </td>
</tr>
<tr>
 <td style="text-align: left;">
1 </td><td style="text-align: left;"> E(n) </td><td style="text-align: left;"> number of distinct individuals </td>
</tr>
<tr>
 <td style="text-align: left;">
2 </td><td style="text-align: left;"> E(r) </td><td style="text-align: left;"> number of recaptures </td>
</tr>
<tr>
 <td style="text-align: left;">
3 </td><td style="text-align: left;"> E(m) </td><td style="text-align: left;"> number of movement recaptures </td>
</tr>
<tr>
 <td style="text-align: left;">
4 </td><td style="text-align: left;"> min(E(n), E(r)) </td><td style="text-align: left;"> minimum E(n), E(r) </td>
</tr>
<tr>
 <td style="text-align: left;">
5 </td><td style="text-align: left;"> E(n2) </td><td style="text-align: left;"> expected number of animals detected at 2 or more sites (cf Qpm Dupont et al. 2021) </td>
</tr>
<tr>
 <td style="text-align: left;">
6 </td><td style="text-align: left;"> E(n) + E(n2) </td><td style="text-align: left;"> (1) + (5) (cf Qpb Dupont et al. 2021)  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Criteria 1&ndash;4 are computed with function <code><a href="#topic+Enrm">Enrm</a></code> (see also Efford and Boulanger 2019). Criteria 5&ndash;6 are computed with function <code><a href="#topic+En2">En2</a></code>. Any penalty is applied only when criterion = 4.
</p>
<p>The criterion may also be a function that returns a single numeric value to be maximised. Arguments of the function should match those of <code><a href="#topic+En2">En2</a></code>, although ... may suffice for some or all (see Examples).
</p>


<h3>Value</h3>

<p>An object of class &quot;GAoptim&quot; that is a list with components
</p>
<table role = "presentation">
<tr><td><code>mask</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>alltraps</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>detectpar</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>noccasions</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>detectfn</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>des</code></td>
<td>
<p>kofnGA() output object</p>
</td></tr>
<tr><td><code>optimaltraps</code></td>
<td>
<p>traps object with optimized layout</p>
</td></tr>
<tr><td><code>optimalenrms</code></td>
<td>
<p>E(n), E(r), E(m) evaluated with optimized layout</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>Spatial representativeness is not considered, so designs &lsquo;optimised&rsquo; with <code>GAoptim</code> are not robust to unmodelled variation in density or detection parameters.
</p>


<h3>Author(s)</h3>

<p>Ian Durbach and Murray Efford.
</p>


<h3>References</h3>

<p>Dupont, G., Royle, J. A., Nawaz, M. A. and Sutherland, C. (2021) Optimal sampling
design for spatial capture&ndash;recapture. <em>Ecology</em> <b>102</b> e03262.
</p>
<p>Durbach, I., Borchers, D., Sutherland, C. and Sharma, K. (2021) Fast, flexible 
alternatives to regular grid designs for spatial capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em> <b>12</b>, 298&ndash;310. DOI 10.1111/2041-210X.13517
</p>
<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529&ndash;1535. DOI: 10.1111/2041-210X.13239
</p>
<p>Wolters, M. A. (2015) A genetic algorithm for selection of fixed-size
subsets with application to design problems. <em>Journal of Statistical
Software, Code Snippets</em>, <b>68</b>, 1&ndash;18. DOI 10.18637/jss.v068.c01
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Enrm">Enrm</a></code>, 
<code><a href="#topic+En2">En2</a></code>, 
<code><a href="#topic+minnrRSE">minnrRSE</a></code>, 
<code><a href="#topic+GApenfn">GApenfn</a></code>, 
<code><a href="#topic+compactSample">compactSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# an artificial example
msk &lt;- make.mask(type = 'rectangular', spacing = 10, nx = 30, ny = 20, buffer = 0)
alltrps &lt;- make.grid(nx = 29, ny = 19, origin = c(10,10), spacing = 10)
set.seed(123)

# 50 generations for demonstration, use more in practice
opt &lt;- GAoptim(msk, alltrps, ntraps = 20, detectpar = list(lambda0 = 0.5, sigma = 20), 
    detectfn = 'HHN', D = 10, noccasions = 5, ngen = 50, verbose = 1)

plot(msk)
plot(opt$optimaltraps, add = TRUE)
minnrRSE(opt, distribution = 'binomial')

# Using a criterion function
# En2 is unsuitable as a criterion function as it returns 2 values
# This function selects the second as the (unique) criterion
fn &lt;- function(...) En2(...)[2]
opt2 &lt;- GAoptim(msk, alltrps, ntraps = 20, detectpar = list(lambda0 = 0.5, sigma = 20), 
    detectfn = 'HHN', D = 10, noccasions = 5, ngen = 50, verbose = 1, criterion = fn)
    


</code></pre>

<hr>
<h2 id='getdetectpar'>Ballpark Detection Parameters</h2><span id='topic+getdetectpar'></span>

<h3>Description</h3>

<p>Detection parameters for an animal population may be guessed from some basic inputs (population density, a coefficent of home-range overlap, and the expected number of detections on a given detector array). These values are useful as a starting point for study design. They are not 'estimates'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getdetectpar(D, C, sigma = NULL, k = 0.5, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getdetectpar_+3A_d">D</code></td>
<td>
<p>population density animals / hectare; may be scalar or vector of length <code>nrow(mask)</code></p>
</td></tr>
<tr><td><code id="getdetectpar_+3A_c">C</code></td>
<td>
<p>integer expected total number of detections</p>
</td></tr>
<tr><td><code id="getdetectpar_+3A_sigma">sigma</code></td>
<td>
<p>numeric spatial scale parameter of chosen detection function, in metres (optional)</p>
</td></tr>
<tr><td><code id="getdetectpar_+3A_k">k</code></td>
<td>
<p>coefficient of overlap - typically in range 0.3 to 1.1</p>
</td></tr>
<tr><td><code id="getdetectpar_+3A_...">...</code></td>
<td>
<p>named arguments passed to <code><a href="#topic+Enrm">Enrm</a></code> and <code><a href="#topic+Lambda">Lambda</a></code> (traps, mask, noccasions, detectfn)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If sigma is missing and detectfn = &lsquo;HHN&rsquo; then sigma is first inferred from the relationship <code class="reqn">\sigma = 100 k \sqrt D</code> (<code class="reqn">D</code> in animals per hectare and <code class="reqn">\sigma</code> in metres). Other detectfn give an error.
</p>
<p>A numerical search is then conducted for the value of lambda0 that results in <code>C</code> expected detections for the given density and design. The calculation takes account of the detector array, the habitat mask and the number of sampling occasions (all specified in the ... argument - see example).
</p>
<p>Only hazard detection functions are supported (&lsquo;HHN&rsquo;, &lsquo;HHR&rsquo;, &lsquo;HEX&rsquo;, &lsquo;HAN&rsquo;, &lsquo;HCG&rsquo;). The default is &lsquo;HHN&rsquo;.
</p>


<h3>Value</h3>

<p>A list with one component for each detection parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Enrm">Enrm</a></code>, <code><a href="#topic+Lambda">Lambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr &lt;- traps(captdata)
detector(tr) &lt;- "multi"
msk &lt;- make.mask(tr, buffer = 100, type = 'trapbuffer')
getdetectpar(D = 5.48, C = 235, traps = tr, mask = msk, noccasions = 5)

</code></pre>

<hr>
<h2 id='Internal'>Internal Functions</h2><span id='topic+compactSample'></span><span id='topic+GApenfn'></span><span id='topic+outputtype'></span><span id='topic+outputtype+3C-'></span>

<h3>Description</h3>

 
<p>Functions that are called internally by <span class="pkg">secrdesign</span>. 
These are exported and may be called separately for testing etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
compactSample (traps, n)

GApenfn(traps, sigma)

'outputtype&lt;-'(object, value)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Internal_+3A_traps">traps</code></td>
<td>
<p>secr trapsobject</p>
</td></tr>
<tr><td><code id="Internal_+3A_n">n</code></td>
<td>
<p>integer number in sample (<code class="reqn">0 &lt; n \le ntraps)</code></p>
</td></tr>
<tr><td><code id="Internal_+3A_sigma">sigma</code></td>
<td>
<p>numeric sparial scale parameter</p>
</td></tr>
<tr><td><code id="Internal_+3A_object">object</code></td>
<td>
<p>object output from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="Internal_+3A_value">value</code></td>
<td>
<p>replacement value for outputtype of object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compactSample</code> selects a detector at random and returns the a compact subset of surrounding detectors.
</p>
<p><code>GApenfn</code> is the default pen_fn used by <code><a href="#topic+GAoptim">GAoptim</a></code> When called with a non-null penalty argument.
</p>
<p>Values of outputtype map to class of the run.scenarios output as follows
</p>

<table>
<tr>
 <td style="text-align: left;">
  Output type </td><td style="text-align: left;"> Class </td>
</tr>
<tr>
 <td style="text-align: left;">
  secrfit </td><td style="text-align: left;"> c("fittedmodels", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  ipsecrfit </td><td style="text-align: left;"> c("fittedmodels", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  predicted </td><td style="text-align: left;"> c("estimatetables", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  derived </td><td style="text-align: left;"> c("estimatetables", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  regionN </td><td style="text-align: left;"> c("estimatetables", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  coef </td><td style="text-align: left;"> c("estimatetables", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  user </td><td style="text-align: left;"> c("estimatetables", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  secrsummary </td><td style="text-align: left;"> c("summary", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  capthist </td><td style="text-align: left;"> c("rawdata", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  selectedstatistics </td><td style="text-align: left;"> c("selectedstatistics", "secrdesign", "list") </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Calling the replacement function automatically changes the class of the output object as appropriate. This determines how the output is handled by downstream functions such as <code>summary</code>. Using a custom extractfn or post-processing the output sometimes requires the outputtype to be set manually (see example in the Multi-model section of secrdesign-vignette.pdf).
</p>


<h3>Value</h3>

<p>GApenfn &ndash; a numeric vector with the number of trap pairs separated by 2.5-3.5 sigma and 3.5-4.5 sigma.
</p>
<p>compactSample &ndash; an object like traps, but with only n rows.
</p>


<h3>References</h3>

<p>Durbach, I., Borchers, D., Sutherland, C. and Sharma, K. (2021) Fast, flexible alternatives to regular grid designs for spatial capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>12</b>, 298&ndash;310. DOI 10.1111/2041-210X.13517
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GAoptim">GAoptim</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CStraps &lt;- compactSample(traps(captdata), n = 20)

plot(traps(captdata))
plot(CStraps, add = TRUE, detpar = list(fg = 'blue',pch = 16))

GApenfn(CStraps, sigma = 25)

</code></pre>

<hr>
<h2 id='Lambda'>Expected Detections</h2><span id='topic+Lambda'></span><span id='topic+Enrm'></span><span id='topic+minnrRSE'></span><span id='topic+Qpm'></span><span id='topic+En2'></span>

<h3>Description</h3>

<p>Compute the expected number of detections as a function of location (<code>Lambda</code>), and the expected total numbers of individuals <code class="reqn">n</code>, recaptures <code class="reqn">r</code> and movements <code class="reqn">m</code> for a population sampled with an array of detectors (<code>Enrm</code>) or the number of individuals detected at two or more detectors (<code>En2</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
Lambda(traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", 'HN', 'HR', 'EX'))
Enrm(D, ...)

minnrRSE(D, ..., CF = 1.0, distribution = c("poisson","binomial"))

En2(D, traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", "HN", "HR", "EX"))

Qpm(D, traps, mask, detectpar, noccasions, detectfn = c("HHN", "HHR", "HEX", 
    "HAN", "HCG", "HN", "HR", "EX"))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lambda_+3A_traps">traps</code></td>
<td>
 <p><code><a href="secr.html#topic+traps">traps</a></code> object </p>
</td></tr>
<tr><td><code id="Lambda_+3A_mask">mask</code></td>
<td>
 <p><code><a href="secr.html#topic+mask">mask</a></code> object </p>
</td></tr>
<tr><td><code id="Lambda_+3A_detectpar">detectpar</code></td>
<td>
<p> a named list giving a value for each parameter of detection function </p>
</td></tr>
<tr><td><code id="Lambda_+3A_noccasions">noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td></tr>
<tr><td><code id="Lambda_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function 
&ndash; see <a href="secr.html#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="Lambda_+3A_d">D</code></td>
<td>
<p>population density animals / hectare; may be scalar or vector of length <code>nrow(mask)</code></p>
</td></tr>
<tr><td><code id="Lambda_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>Lambda</code></p>
</td></tr>
<tr><td><code id="Lambda_+3A_cf">CF</code></td>
<td>
<p>numeric correction factor</p>
</td></tr>
<tr><td><code id="Lambda_+3A_distribution">distribution</code></td>
<td>
<p>character distribution of <code class="reqn">n</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The detector attribute of <code>traps</code> may be &lsquo;multi&rsquo;, &lsquo;proximity&rsquo; or &lsquo;count&rsquo;. It is assumed that detectpar and detector type do not differ among occasions.
</p>
<p>The calculation is based on an additive hazard model. If <code>detectfn</code> is not a hazard function (&lsquo;HHN&rsquo;, &lsquo;HEX&rsquo;, &lsquo;HHR&rsquo;, &lsquo;HAN&rsquo; and &lsquo;HCG&rsquo;) then an attempt is made to approximate one of the hazard functions (HN -&gt; HHN, HR -&gt; HHR, EX -&gt; HEX). The default is &lsquo;HHN&rsquo;.
</p>
<p>For hazard function <code class="reqn">\lambda(d)</code> and <code class="reqn">S</code> occasions, we define <code class="reqn">\Lambda(x) = \sum_s \sum_k \lambda(d_k(x))</code>.
</p>
<p>Formulae for expected counts are given in <a href="https://www.otago.ac.nz/density/pdfs/secrdesign-Enrm.pdf">secrdesign-Enrm.pdf</a>.
</p>
<p><code>minnrRSE</code> has mostly the same inputs as <code>Enrm</code> but returns sqrt(CF/min(n,r)). The correction factor CF may be used to adjust for systematic bias (e.g., for a line of detectors CF = 1.4 may be appropriate). The default <code>distribution = 'poisson'</code> is for Poisson-distributed <code class="reqn">N</code> and <code class="reqn">n</code>. To adjust the prediction for fixed <code class="reqn">N</code> (binomial <code class="reqn">n</code>) use <code>distribution = 'binomial'</code> (see <a href="../doc/secrdesign-tools.pdf">../doc/secrdesign-tools.pdf</a> Appendix 2).
</p>
<p>From 2.7.0, the first argument of <code>minnrRSE</code> may also be the output from <code><a href="#topic+GAoptim">GAoptim</a></code>.
</p>
<p><code>En2</code> is defined for detectors &lsquo;multi&rsquo;, &lsquo;proximity&rsquo; and &lsquo;count&rsquo;.
</p>
<p><code>Qpm</code> returns the optimisation criteria <code class="reqn">Q_p</code> and <code class="reqn">Q_{p_m}</code> of Dupont et al. (2021), defined only for &lsquo;proximity&rsquo; and &lsquo;count&rsquo; detectors. The criteria are mask-dependent, and <code>En2</code> is generally preferred. For &lsquo;proximity&rsquo; and &lsquo;count&rsquo; detectors the following expressions give the same result:
</p>
<p><code>En2(D, trp, msk, dp)</code>
</p>
<p><code>Qpm(D, trp, msk, dp) * maskarea(msk) * D</code>
</p>
<p>given constant density &lsquo;D&rsquo;, detectors &lsquo;trp&rsquo;, mask &lsquo;msk&rsquo; and detection parameters &lsquo;dp&rsquo;.
</p>


<h3>Value</h3>

<p><code>Lambda</code> &ndash;
<a href="secr.html#topic+mask">mask</a> object with covariates &lsquo;Lambda&rsquo; (<code class="reqn">\Lambda(x)</code>), &lsquo;sumpk&rsquo; and &lsquo;sumq2&rsquo; (intermediate values for computation of expected counts - see <a href="../doc/expectedcounts.pdf">../doc/expectedcounts.pdf</a>)
</p>
<p><code>Enrm</code> &ndash;
numeric vector of length 3, the values of E(<code class="reqn">n</code>), E(<code class="reqn">r</code>) and E(<code class="reqn">m</code>)
</p>
<p><code>minnrRSE</code> &ndash; rule-of-thumb RSE(D-hat) Efford and Boulanger (2019)
</p>
<p><code>En2</code> &ndash; numeric vector comprising the values E(<code class="reqn">n</code>) and E(number of animals detected at 2 or more sites)
</p>
<p><code>Qpm</code> &ndash; numeric vector comprising the criteria <code class="reqn">Q_p</code> and <code class="reqn">Q_{p_m}</code> of Dupont et al. (2021)
</p>


<h3>References</h3>

<p>Dupont, G., Royle, J. A., Nawaz, M. A. and Sutherland, C. (2021) Optimal sampling
design for spatial capture&ndash;recapture. <em>Ecology</em> <b>102</b> e03262.
</p>
<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529&ndash;1535. DOI: 10.1111/2041-210X.13239
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getdetectpar">getdetectpar</a></code>, 
<code><a href="#topic+optimalSpacing">optimalSpacing</a></code>, 
<code><a href="#topic+scenarioSummary">scenarioSummary</a></code>, 
<code><a href="#topic+GAoptim">GAoptim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr &lt;- traps(captdata)
detector(tr) &lt;- "multi"
msk &lt;- make.mask(tr, buffer = 100, type = 'trapbuffer')

L &lt;- Lambda(tr, msk, list(lambda0 = 0.2, sigma = 20), 5)
nrm &lt;- Enrm(D = 5, tr, msk, list(lambda0 = 0.2, sigma = 20), 5)
nrm

En2(D = 5, tr, msk, list(lambda0 = 0.2, sigma = 20), 5)

plot(L, cov = "Lambda", dots = FALSE)
plot(tr, add = TRUE)
mtext(side = 3,  paste(paste(names(nrm), round(nrm,1)), collapse = ", "))

</code></pre>

<hr>
<h2 id='make.array'> Re-cast Simulated Statistical Output as Array </h2><span id='topic+make.array'></span>

<h3>Description</h3>

<p>This function is used internally by <code><a href="#topic+summary.secrdesign">summary.secrdesign</a></code>, and may
occasionally be of general use.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.array(object)

</code></pre>


<h3>Arguments</h3>

 <table role = "presentation">
<tr><td><code id="make.array_+3A_object">object</code></td>
<td>
<p>secrdesign object containing numerical values
for a particular parameter (i.e. output from
<code><a href="#topic+select.stats">select.stats</a></code> 
inheriting from &lsquo;selectedstatistics&rsquo;) </p>
</td></tr> </table>


<h3>Details</h3>

<p><code>make.array</code> converts a particular simulated numerical output into an array
with one dimension for each varying input.
</p>


<h3>Value</h3>

<p>A numeric array with dimensions corresponding to the varying inputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## collect raw counts
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()
tmp1 &lt;- run.scenarios(nrepl = 50, trapset = traps1, scenarios = scen1,
    fit = FALSE)
make.array(tmp1)
</code></pre>

<hr>
<h2 id='make.scenarios'>Construct Scenario Data Frame</h2><span id='topic+make.scenarios'></span>

<h3>Description</h3>

<p>This function prepares a dataframe in which each row specifies a
simulation scenario. The dataframe is used as input to <code><a href="#topic+run.scenarios">run.scenarios</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.scenarios(trapsindex = 1, noccasions = 3,  nrepeats = 1, D, g0, sigma, lambda0,
detectfn = 0, recapfactor = 1, popindex = 1, detindex = 1, fitindex = 1, groups,
crosstraps = TRUE)

</code></pre>


<h3>Arguments</h3>

 
<table role = "presentation">
<tr><td><code id="make.scenarios_+3A_trapsindex">trapsindex</code></td>
<td>
<p>integer vector determining the traps object to use</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_noccasions">noccasions</code></td>
<td>
<p>integer vector for the number of sampling occasions</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_nrepeats">nrepeats</code></td>
<td>
<p>integer vector of multipliers for D (see Details)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_d">D</code></td>
<td>
<p>numeric vector of values for the density parameter (animals /
hectare)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_g0">g0</code></td>
<td>
<p>numeric vector of values for the g0 parameter</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector of values for the sigma parameter (m)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_lambda0">lambda0</code></td>
<td>
<p>numeric vector of values for the lambda0 parameter</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_detectfn">detectfn</code></td>
<td>
<p>vector of valid detection function codes (numeric or
character)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_recapfactor">recapfactor</code></td>
<td>
<p>numeric vector of values for recapfactor
(<code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_popindex">popindex</code></td>
<td>
<p>integer vector determining which population model is used</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_detindex">detindex</code></td>
<td>
<p>integer vector determining which detection options are used</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_fitindex">fitindex</code></td>
<td>
<p>integer vector determining which model is fitted</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_groups">groups</code></td>
<td>
<p>character vector of group labels (optional)</p>
</td></tr>
<tr><td><code id="make.scenarios_+3A_crosstraps">crosstraps</code></td>
<td>
<p>logical; if TRUE the output includes all
combinations of   
<code>trapsindex</code>, <code>noccasions</code> and <code>nrepeats</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The index in <code>trapsindex</code> is used in <code><a href="#topic+run.scenarios">run.scenarios</a></code> to
select particular detector arrays from the list of arrays provided as
an argument to that function.
</p>
<p>The function generates all combinations of the given parameter values
using <code><a href="base.html#topic+expand.grid">expand.grid</a></code>. By default, it also generates
all combinations of the parameters with <code>trapsindex</code> and the
number of sampling occasions. If <code>crosstraps</code> is FALSE then
<code>trapsindex</code>, <code>noccasions</code>, and <code>nrepeats</code> are merely
used to fill in these columns in the output dataframe.
</p>
<p>The argument <code>lambda0</code> replaces <code>g0</code> for the hazard detection
functions 14&ndash;18 (<code><a href="secr.html#topic+detectfn">detectfn</a></code>). 
</p>
<p>Designs may use multiple detector arrays with the same internal
geometry (e.g., number and spacing of traps). The number of such
arrays is varied with the <code>nrepeats</code> argument. For example, you
may compare designs with many small arrays or a few large ones. In
practice, <code>run.scenarios</code> simulates a single layout with density 
D * nrepeats. This shortcut is not appropriate when
animals compete for traps (detector = &lsquo;single&rsquo;).
</p>
<p><code>fitindex</code> allows a choice of different models when the argument
<code>fit.args</code> of <code><a href="#topic+run.scenarios">run.scenarios</a></code> is a compound list.
</p>
<p>If <code>groups</code> is provided each scenario is replicated to the length of <code>groups</code> and a column &lsquo;group&rsquo; is added.
</p>


<h3>Value</h3>

<p>Dataframe with one row per scenario (or sub-scenario) and the columns
</p>
<table role = "presentation">
<tr><td><code>scenario</code></td>
<td>
<p>a number identifying the scenario</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>(optional)</p>
</td></tr>
<tr><td><code>trapsindex</code></td>
<td>
</td></tr>
<tr><td><code>noccasions</code></td>
<td>
</td></tr>
<tr><td><code>nrepeats</code></td>
<td>
</td></tr>
<tr><td><code>D</code></td>
<td>
</td></tr>
<tr><td><code>g0</code></td>
<td>
<p>or lambda0</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
</td></tr>
<tr><td><code>detectfn</code></td>
<td>
<p>see <code><a href="secr.html#topic+detectfn">detectfn</a></code>; always numeric</p>
</td></tr>
<tr><td><code>recapfactor</code></td>
<td>
</td></tr>
<tr><td><code>popindex</code></td>
<td>
</td></tr>
<tr><td><code>detindex</code></td>
<td>
</td></tr>
<tr><td><code>fitindex</code></td>
<td>
</td></tr>
</table>
<p>An attribute &lsquo;inputs&rsquo; is saved for possible use in <code><a href="#topic+make.array">make.array</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>, <code><a href="#topic+scenarioSummary">scenarioSummary</a></code>, <code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make.scenarios(trapsindex = 1, nrepeats = 1, D = c(5,10), sigma = 25,
g0 = 0.2)

</code></pre>

<hr>
<h2 id='minsimRSE'> Optimal Spacing by Simulation </h2><span id='topic+minsimRSE'></span><span id='topic+minsimRSE.optimalSpacing'></span>

<h3>Description</h3>

<p>A method to obtain a unique &lsquo;optimal&rsquo; spacing from previously simulated scenaios for detector spacing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'optimalSpacing'
minsimRSE(object, cut = 0.2, plt = FALSE, verbose = FALSE, incr = 0.1, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minsimRSE_+3A_object">object</code></td>
<td>
<p>optimalSpacing object</p>
</td></tr>
<tr><td><code id="minsimRSE_+3A_cut">cut</code></td>
<td>
<p>numeric maximum <code class="reqn">\Delta</code> RSE to include</p>
</td></tr>
<tr><td><code id="minsimRSE_+3A_plt">plt</code></td>
<td>
<p>logical; if TRUE a plot is generated</p>
</td></tr>
<tr><td><code id="minsimRSE_+3A_verbose">verbose</code></td>
<td>
<p>logical; if TRUE then output includes fitted model</p>
</td></tr>
<tr><td><code id="minsimRSE_+3A_incr">incr</code></td>
<td>
<p>numeric spacing of computed points (R)</p>
</td></tr>
<tr><td><code id="minsimRSE_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>plot.optimalSpacing</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quadratic is fitted to the simulated RSE (y) vs simulationR (x), including only values of x and y for which <code class="reqn">y \le \mbox{min}(y) \times (1+\mbox{cut})</code>. The restriction allows the user to exclude extreme x-values for which the quadratic is a poor fit.
</p>
<p>The optimum is the minimum of the quadratic <code class="reqn">ax^2 + bx + c</code>, given by <code class="reqn">-b/2a</code>.
</p>
<p>The quadratic is fitted with <code><a href="stats.html#topic+lm">lm</a></code> (<code>lm(RSE.mean ~ R + I(R^2)</code>).
</p>


<h3>Value</h3>

<p>When <code>verbose = FALSE</code>, a numeric vector with optimum R (multiple of sigma) and corresponding RSE.
</p>
<p>When <code>verbose = TRUE</code>, a list with components &ndash;
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>fitted model from <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>dataframe of points on fitted curve</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>optimum R</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>minimum RSE</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimalSpacing">optimalSpacing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


grid &lt;- make.grid(8, 8, spacing = 20, detector = 'proximity')

# method = "none" uses the shortcut variance
tmp &lt;- optimalSpacing(D = 5, traps = grid, detectfn = "HHN", detectpar = 
    list(lambda0 = 1, sigma = 20), noccasions = 1, nx = 32, 
    fit.function = "secr.fit", method = "none", simulationR = seq(1.2,2.2,0.2))
minsimRSE(tmp, plt = TRUE)



</code></pre>

<hr>
<h2 id='optimalSpacing'>Optimal Detector Spacing</h2><span id='topic+optimalSpacing'></span>

<h3>Description</h3>

<p>Estimate the detector spacing that yields the greatest precision (lowest RSE D-hat) for a given detector geometry, number of sampling occasions, density and detection parameters. By default this uses only the approximate RSE of Efford and Boulanger (2019), but simulations may also be performed and the optimum found later with <code>minsimRSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
optimalSpacing (D, traps, detectpar, noccasions, nrepeats = 1, 
    detectfn = c('HHN', 'HHR', 'HEX','HAN','HCG', 'HN', 'HR', 'EX'),
    fittedmodel = NULL, xsigma = 4, R = seq(0.2, 4, 0.2), CF = 1.0,
    distribution = c("poisson", "binomial"),
    fit.function = c("none", "secr.fit"), 
    simulationR = seq(0.4, 4, 0.4), nrepl = 10, 
    plt = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimalSpacing_+3A_d">D</code></td>
<td>
<p>population density animals / hectare (constant)</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_traps">traps</code></td>
<td>
 <p><code><a href="secr.html#topic+traps">traps</a></code> object </p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_detectpar">detectpar</code></td>
<td>
<p>named list giving a value for each parameter of detection function (sigma not needed)</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_noccasions">noccasions</code></td>
<td>
<p>integer number of sampling occasions</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_nrepeats">nrepeats</code></td>
<td>
<p>integer number of replicate arrays (not yet used)</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function &ndash; see <a href="secr.html#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_fittedmodel">fittedmodel</code></td>
<td>
<p>secr fitted model (instead of preceding arguments)</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_xsigma">xsigma</code></td>
<td>
<p>numeric buffer width as multiple of sigma</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_r">R</code></td>
<td>
<p>numeric vector of relative spacings at which to plot rule-of-thumb RSE(D-hat)</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_cf">CF</code></td>
<td>
<p>numeric correction factor for rule-of-thumb RSE</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_distribution">distribution</code></td>
<td>
<p>character distribution of number of individuals detected</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_fit.function">fit.function</code></td>
<td>
<p>character function to use for model fitting</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_simulationr">simulationR</code></td>
<td>
<p>numeric vector of relative spacings at which to simulate</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_nrepl">nrepl</code></td>
<td>
<p>integer number of replicate simulations </p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_plt">plt</code></td>
<td>
<p>logical; if TRUE then results are plotted</p>
</td></tr>
<tr><td><code id="optimalSpacing_+3A_...">...</code></td>
<td>
<p>other arguments passed to various functions (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A numerical search over possible spacings uses the rule-of-thumb RSE(D-hat) given by <code><a href="#topic+minnrRSE">minnrRSE</a></code> as the objective function. 
</p>
<p><code>traps</code> provides the geometry of the detector layout and the initial spacing <code class="reqn">s</code>. Function <code><a href="stats.html#topic+optimize">optimize</a></code> is used to search for a solution (minimum RSE) in the range of <code>R</code> x <code class="reqn">s</code>.
</p>
<p>The computation emulates variation in detector spacing by inverse variation in sigma (sigma' = sigma / R) with compensating variation in density. Mask buffer width and spacing are also scaled by R.
</p>
<p>If <code>fit.function</code> is &quot;secr.fit&quot; then simulations are also performed for the relative spacings in <code>simulationR</code>. Density, sigma and mask attributes are scaled as for the rule-of-thumb calculations. Using 'method = &quot;none&quot;' gives fast prediction of RSE (from the Hessian evaluated at the known parameter values), but does not estimate bias.
</p>
<p>Simulation results are not summarised as a unique &lsquo;optimal&rsquo; spacing. For this apply the method <code><a href="#topic+minsimRSE">minsimRSE</a></code> to the resulting object.
</p>
<p>The ... argument may be used to set the values of these arguments:
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> Arguments </td>
</tr>
<tr>
 <td style="text-align: left;">
make.mask </td><td style="text-align: left;"> `nx', `type', `poly',`poly.habitat' </td>
</tr>
<tr>
 <td style="text-align: left;">
run.scenarios </td><td style="text-align: left;"> `seed', `ncores', `method' </td>
</tr>
<tr>
 <td style="text-align: left;">
plot.optimalSpacing </td><td style="text-align: left;"> `add', ... </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The argument <code>CF</code> may be set to NA to suppress rule-of-thumb RSE, including optimisation. <code>range(R)</code> specifies the search interval for optimisation.
</p>
<p>A <code>plot</code> method is provided, with options for plotting different components.
</p>


<h3>Value</h3>

<p>List of two components, one for the rule-of-thumb optimisation (rotRSE) and the other for simulation results, if requested (simRSE).
</p>
<p>The optimisation results are
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>dataframe with E(n), E(r) and the rule-of-thumb RSE for each requested R</p>
</td></tr>
<tr><td><code>optimum.spacing</code></td>
<td>
<p>the absolute spacing that yields maximum precision (minimum rule-of-thumb RSE(D-hat))</p>
</td></tr>
<tr><td><code>optimum.R</code></td>
<td>
<p>spacing relative to sigma</p>
</td></tr>
<tr><td><code>minimum.RSE</code></td>
<td>
<p>final value of the objective function (minimum rule-of-thumb RSE(D-hat))</p>
</td></tr>
</table>
<p>The simulation results in the dataframe simRSE are the mean and SE of the simulated RSE(D-hat) for each level of <code>simulationR</code>, with added columns for the relative bias (RB) and relative root-mean-square-error (rRMSE) of D-hat.
</p>
<p>Results are returned invisibly if <code>plt = TRUE</code>.
</p>


<h3>Warnings</h3>

<p>For single-catch traps, use of a maximum likelihood estimate of lambda0 from a fitted multi-catch model results in negative bias.
</p>
<p>Only hazard-based detection functions are supported. The meaning of the &lsquo;sigma&rsquo; parameter depends on the function, and so will the optimal spacing in sigma units.
</p>


<h3>Note</h3>

<p>fit.function = 'openCR.fit' was deprecated from 2.5.8 and has been removed as an option</p>


<h3>References</h3>

<p>Efford, M. G., and Boulanger, J. (2019) Fast evaluation of study designs for 
spatially explicit capture&ndash;recapture. 
<em>Methods in Ecology and Evolution</em>, <b>10</b>, 1529&ndash;1535. DOI: 10.1111/2041-210X.13239
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minnrRSE">minnrRSE</a></code>,
<code><a href="#topic+minsimRSE">minsimRSE</a></code>
<code><a href="#topic+plot.optimalSpacing">plot.optimalSpacing</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid &lt;- make.grid(7, 7)  # default multi-catch detector
optimalSpacing(D = 5, traps = grid, detectpar = list(lambda0 = 0.2, sigma = 20), 
   noccasions = 5, plt = TRUE)

## Not run: 

optimalSpacing(D = 5, traps = grid, detectpar = list(lambda0 = 0.4, sigma = 20), 
    detectfn = 'HEX', R = seq(1,6,0.4), noccasions = 10, plt = TRUE, col = "blue")

## with simulations
grid &lt;- make.grid(8, 8, spacing = 20, detector = 'proximity')
optimalSpacing(D = 5, traps = grid, detectfn = "HHN", detectpar = 
    list(lambda0 = 0.2, sigma = 20), noccasions = 5, nrepl = 20, nx = 32, 
    fit.function = "secr.fit", ncores = 4, plt = TRUE, col = "blue")

## manual check
grid &lt;- make.grid(8, 8, spacing = 60, detector = 'proximity')
scen &lt;- make.scenarios(D = 5, detectfn = 14, lambda0 = 0.2, sigma = 20,
    noccasions = 5)
sim1 &lt;- run.scenarios(nrepl = 20, scen, trapset = list(grid), fit = TRUE, 
    fit.args = list(detectfn = 14), ncores = 4, byscenario = FALSE)
summary(sim1)


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.optimalSpacing'>Plot and print methods for optimalSpacing object</h2><span id='topic+plot.optimalSpacing'></span><span id='topic+print.optimalSpacing'></span>

<h3>Description</h3>

<p>Plotsor print results from optimalSpacing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'optimalSpacing'
plot(x, add = FALSE, plottype = c("both", "RSE", "nrm"), ...)
## S3 method for class 'optimalSpacing'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.optimalSpacing_+3A_x">x</code></td>
<td>
<p>object from <code><a href="#topic+optimalSpacing">optimalSpacing</a></code></p>
</td></tr>
<tr><td><code id="plot.optimalSpacing_+3A_add">add</code></td>
<td>
<p>logical; if TRUE will add to existing plot</p>
</td></tr>
<tr><td><code id="plot.optimalSpacing_+3A_plottype">plottype</code></td>
<td>
<p>character code</p>
</td></tr>
<tr><td><code id="plot.optimalSpacing_+3A_...">...</code></td>
<td>
<p>other arguments for plot, lines or points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>plottype = "RSE"</code> then RSE(D-hat) is plotted against R (relative detector spacing). If <code>plottype = "nrm"</code> then the expected numbers of individuals, recaptures and movements are plotted against R. 
</p>
<p>The ... argument may be used to pass other plotting arguments to override defaults:
</p>

<table>
<tr>
 <td style="text-align: left;">
Function </td><td style="text-align: left;"> Arguments </td><td style="text-align: left;"> Note </td>
</tr>
<tr>
 <td style="text-align: left;">
plot </td><td style="text-align: left;"> `xlab', `ylab', `xlim', `ylim', `las', `xaxs', `yaxs' </td><td style="text-align: left;"> add = FALSE </td>
</tr>
<tr>
 <td style="text-align: left;">
points </td><td style="text-align: left;"> `col', `cex', `pch' </td><td style="text-align: left;"> optimum and simulated RSE </td>
</tr>
<tr>
 <td style="text-align: left;">
lines </td><td style="text-align: left;"> `col', `lwd', `lty' </td><td style="text-align: left;"> rule-of-thumb RSE </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The print method removes attributes before printing.
</p>


<h3>Value</h3>

<p>None</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimalSpacing">optimalSpacing</a></code></p>

<hr>
<h2 id='predict.fittedmodels'> Extract Estimates From Fitted Models </h2><span id='topic+predict'></span><span id='topic+coef'></span><span id='topic+derived'></span><span id='topic+region.N'></span><span id='topic+predict.fittedmodels'></span><span id='topic+coef.fittedmodels'></span><span id='topic+derived.fittedmodels'></span><span id='topic+region.N.fittedmodels'></span>

<h3>Description</h3>

<p>If simulations have been saved from <code>run.scenarios</code> as fitted
secr models it is necessary to use one of these functions to extract
estimates for later summarization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'fittedmodels'
predict(object, ...)

## S3 method for class 'fittedmodels'
coef(object, ...)

## S3 method for class 'fittedmodels'
derived(object, ...)

## S3 method for class 'fittedmodels'
region.N(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.fittedmodels_+3A_object">object</code></td>
<td>
<p>fitted model simulation output from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="predict.fittedmodels_+3A_...">...</code></td>
<td>
<p>other arguments passed to predict, coef, derived or region.N </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used when output from <code><a href="#topic+run.scenarios">run.scenarios</a></code>
has been saved as fitted models. <code>derived</code> and <code>region.N</code>
require a full fit (including the mask and design0 objects) whereas a trimmed model
is sufficient for <code>predict</code> and <code>coef</code>.
</p>
<p><code>derived</code> is used to compute the Horvitz-Thompson-like estimate
of density when <code><a href="secr.html#topic+secr.fit">secr.fit</a></code> has been used with <code>CL
= TRUE</code>; it is roughly equivalent to <code>predict</code>.
</p>
<p><code>region.N</code> predicts the realised number (R.N) or expected number
(E.N) in a masked area. When detector layouts and/or <code>sigma</code> vary,
the masked area will also vary (arbitrarily, depending on the buffer
argument &lsquo;xsigma&rsquo;) unless a mask is provided by the user; this may be
done either in <code>run.scenarios</code> or in <code>region.N</code>.
</p>


<h3>Value</h3>

<p>An object with class (&lsquo;estimatetables&rsquo;, &lsquo;secrdesign&rsquo;, &lsquo;list&rsquo;) with
appropriate outputtype (&lsquo;predicted&rsquo;, &lsquo;coef&rsquo;, &lsquo;derived&rsquo;, &lsquo;regionN&rsquo;;
see also <code><a href="#topic+run.scenarios">run.scenarios</a></code>).
</p>


<h3>Note</h3>

<p>From <span class="pkg">secrdesign</span> 2.5.3 the methods described here replace the functions <code>derived.SL</code> and <code>regionN.SL</code>. This is for compatibility with <span class="pkg">secr</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>
<code><a href="secr.html#topic+coef.secr">coef.secr</a></code>
<code><a href="secr.html#topic+predict.secr">predict.secr</a></code>
<code><a href="secr.html#topic+derived.secr">derived.secr</a></code>
<code><a href="secr.html#topic+region.N.secr">region.N.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
scen1 &lt;- make.scenarios(D = c(3,6), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()  ## default 6 x 6 grid of multi-catch traps
tmp1 &lt;- run.scenarios(nrepl = 10, trapset = traps1, scenarios = scen1,
    fit = TRUE, extractfn = trim)
tmp2 &lt;- predict(tmp1)
tmp3 &lt;- select.stats(tmp2, 'D', c('estimate','RB','RSE'))
summary(tmp3)

## for derived and region.N need more than just 'trimmed' secr object
## use argument 'keep' to save mask and design0 usually discarded by trim
tmp4 &lt;- run.scenarios(nrepl = 10, trapset = traps1, scenarios = scen1,
    fit = TRUE, extractfn = trim, keep = c('mask','design0'))

summary(derived(tmp4))

## for region.N we must specify the parameter for which we want statistics
## (default 'D' not relevant)
tmp5 &lt;- select.stats(region.N(tmp4), parameter = 'E.N')
summary(tmp5)

## End(Not run)

</code></pre>

<hr>
<h2 id='rbind.estimatetables'>
Combine Simulation Output
</h2><span id='topic+rbind.estimatetables'></span><span id='topic+rbind.selectedstatistics'></span><span id='topic+c.estimatetables'></span><span id='topic+c.selectedstatistics'></span>

<h3>Description</h3>

<p>Methods to combine output from separate executions of <code><a href="#topic+run.scenarios">run.scenarios</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'estimatetables'
rbind(..., deparse.level = 1)

## S3 method for class 'selectedstatistics'
rbind(..., deparse.level = 1)

## S3 method for class 'estimatetables'
c(...)

## S3 method for class 'selectedstatistics'
c(...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind.estimatetables_+3A_...">...</code></td>
<td>
<p>estimatetables or selectedstatistics output from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="rbind.estimatetables_+3A_deparse.level">deparse.level</code></td>
<td>
<p>not used (required by generic method <code><a href="base.html#topic+rbind">rbind</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rbind</code> assumes all inputs used exactly the same scenarios. Replicate estimate tables are combined across executions for each scenario in turn. This is useful to increase the number of replicates by combining two batches of simulations with different random seeds. The &lsquo;scenarios&rsquo; component remains unchanged.
</p>
<p><code>c</code> combines outputs from <code>run.scenarios</code> that may differ in their scenarios. The &lsquo;output&rsquo; component of the result is a concatenation of the output lists in the input. The &lsquo;scenarios&rsquo; component of the result comprises the input scenarios stacked with <code><a href="base.html#topic+rbind.data.frame">rbind.data.frame</a></code>.
</p>
<p>The compatibility of the inputs is checked, but the checks are not exhaustive. Users should be wary.
</p>


<h3>Value</h3>

<p>&lsquo;estimatetables&rsquo; or &lsquo;selectedstatistics&rsquo; object combining the inputs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.scenarios">make.scenarios</a></code>
<code><a href="#topic+run.scenarios">run.scenarios</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple example: generate and summarise trapping data at two densities
## result inherits from 'selectedstatistics'

scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2, noccasions = 5)
traps1 &lt;- make.grid()   ## default 6 x 6 trap grid
tmp1 &lt;- run.scenarios(nrepl = 5, trapset = traps1, scenarios = scen1,
    fit = FALSE, seed = 123)
tmp2 &lt;- run.scenarios(nrepl = 15, trapset = traps1, scenarios = scen1,
    fit = FALSE, seed = 127)
    
summary(rbind(tmp1,tmp2))    
summary(c(tmp1,tmp2))    

</code></pre>

<hr>
<h2 id='run.scenarios'>Simulate Sampling Designs</h2><span id='topic+run.scenarios'></span><span id='topic+fit.models'></span>

<h3>Description</h3>

<p>This function performs simulations to predict the precision of density and other
estimates from simple 1-session SECR designs. Scenarios are specified
via an input dataframe that will usually be constructed with
<code><a href="#topic+make.scenarios">make.scenarios</a></code>. Each scenario comprises an index to a detector layout,
the number of sampling occasions, and specified density (D) and detection
parameters (usually <code class="reqn">g_0</code> and <code class="reqn">\sigma</code>).
</p>
<p>Detector layouts are provided in a separate list <code>trapset</code>. This
may comprise an actual field design input with <code><a href="secr.html#topic+read.traps">read.traps</a></code> or
&lsquo;traps&rsquo; objects constructed with <code><a href="secr.html#topic+make.grid">make.grid</a></code> etc., as in the
Examples. Even a single layout must be presented as a component of a
list (e.g., <code>list(make.grid())</code>).
</p>
<p>Alternative approaches are offered for predicting precision. Both start
by generating a pseudorandom dataset under the design using the
parameter values for a particular scenario. The first estimates the
parameter values and their standard errors from each dataset by
maximizing the full likelihood, as usual in <code>secr.fit</code>. The second
takes the short cut of computing variances and SE from the Hessian
estimated numerically at the known expected values of the parameters,
without maximizing the likelihood. Set <code>method = "none"</code> in fit.args 
for this shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
run.scenarios(nrepl, scenarios, trapset, maskset, xsigma = 4, nx = 32,
    pop.args, CH.function = c("sim.capthist", "simCH"), det.args, 
    fit = FALSE, fit.function = c("secr.fit", "ipsecr.fit"), 
    fit.args, chatnsim, extractfn = NULL, multisession = FALSE,
    joinsessions = FALSE, ncores = NULL, byscenario = FALSE, seed = 123, 
    trap.args, prefix = NULL, ...)

fit.models(rawdata, fit = FALSE, fit.function = c("secr.fit", "ipsecr.fit"), 
    fit.args, chatnsim, extractfn = NULL, ncores = NULL, byscenario = FALSE,
    scen, repl, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.scenarios_+3A_nrepl">nrepl</code></td>
<td>
<p>integer number of replicate simulations</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_scenarios">scenarios</code></td>
<td>
<p>dataframe of simulation scenarios</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_trapset">trapset</code></td>
<td>
<p>secr traps object or a list of traps objects or functions</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_maskset">maskset</code></td>
<td>
<p>secr mask object or a list of mask objects (optional)</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_xsigma">xsigma</code></td>
<td>
<p>numeric buffer width as multiple of sigma (alternative
to maskset)</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_nx">nx</code></td>
<td>
<p>integer number of cells in mask in x direction  (alternative
to maskset)</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_pop.args">pop.args</code></td>
<td>
<p>list of named arguments to
<code><a href="secr.html#topic+sim.popn">sim.popn</a></code> (optional)</p>
</td></tr> 
<tr><td><code id="run.scenarios_+3A_ch.function">CH.function</code></td>
<td>
<p>character name of function to simulate capthist</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_det.args">det.args</code></td>
<td>
<p>list of named arguments to
<code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code> (optional)</p>
</td></tr> 
<tr><td><code id="run.scenarios_+3A_fit">fit</code></td>
<td>
<p>logical or character; if TRUE a model is fitted with <code>fit.function</code>, otherwise
data are generated but no model is fitted <br /> 
(see also Multi-model fit and Design-only statistics in Details)</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_fit.function">fit.function</code></td>
<td>
<p>character name of function to use for model fitting</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_fit.args">fit.args</code></td>
<td>
<p>list of named arguments to <code><a href="secr.html#topic+secr.fit">secr.fit</a></code> or <code><a href="ipsecr.html#topic+ipsecr.fit">ipsecr.fit</a></code> (optional)</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_chatnsim">chatnsim</code></td>
<td>
<p>integer number of simulations for overdispersion of mark-resight models</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_extractfn">extractfn</code></td>
<td>
<p>function to extract a vector of statistics from secr model</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_multisession">multisession</code></td>
<td>
<p>logical; if TRUE groups are treated as additional sessions</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_joinsessions">joinsessions</code></td>
<td>
<p>logical; if TRUE function <code><a href="secr.html#topic+join">join</a></code> is applied to multisession capthist</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_ncores">ncores</code></td>
<td>
<p>integer number of cores for parallel processing or NULL</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_byscenario">byscenario</code></td>
<td>
<p>logical; if TRUE then each scenario is sent to a different core</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_seed">seed</code></td>
<td>
<p>integer pseudorandom number seed</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_trap.args">trap.args</code></td>
<td>
<p>list of arguments for trapset components if using function option </p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_prefix">prefix</code></td>
<td>
<p>character to name files saving output of each scenario </p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_...">...</code></td>
<td>
<p>other arguments passed to extractfn</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_rawdata">rawdata</code></td>
<td>
<p>&lsquo;rawdata&rsquo; object from previous call to <code>run.scenarios</code></p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_scen">scen</code></td>
<td>
<p>integer vector of scenario subscripts</p>
</td></tr>
<tr><td><code id="run.scenarios_+3A_repl">repl</code></td>
<td>
<p>integer vector of subscripts in range 1:nrepl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designs are constructed from the trap layouts in <code>trapset</code>, the
numbers of grids in <code>ngrid</code>, and the numbers of sampling
occasions (secondary sessions) in <code>noccasions</code>. These are
<em>not</em> crossed: the number of designs is the maximum length of any
of these arguments. Any of these arguments whose length is less than
the maximum will be replicated to match.
</p>
<p><code>pop.args</code> is used to customize the simulated population
distribution. It will usually comprise a single list, but may be a
list of lists (one per popindex value in scenarios).
</p>
<p><code>det.args</code> may be used to customize some aspects of the detection
modelling in <code>sim.capthist</code>, but not <code>traps, popn, detectpar,
  detectfn</code>, and <code>noccasions</code>, which are controlled directly by the
scenarios. It will usually comprise a single list, but may be a list
of lists (one per detindex value in scenarios).
</p>
<p><code>fit.args</code> is used to customize the fitted model; it will usually
comprise a single list. If you are interested in precision alone, use
<code>fit.args=list(method = 'none')</code> to obtain variance estimates
from the hessian evaluated at the parameter estimates. This is much
faster than a complete model fit, and usually accurate enough.
</p>
<p>If no <code>extractfn</code> is supplied then a default is used - see
Examples. Replacement functions should follow this pattern i.e. test
for whether the single argument is an secr object, and if not supply a
named vector of NA values of the correct length.
</p>
<p>Using <code>extractfn = summary</code> has the advantage of allowing both model fits and raw statistics to be extracted from one set of simulations. However, this approach requires an additional step to retrieve the desired numeric results from each replicate (see <code><a href="#topic+count.summary">count.summary</a></code> and <code><a href="#topic+predict.summary">predict.summary</a></code>).
</p>


<h4>Parallel processing</h4>

  
<p>If <code>byscenario = TRUE</code> then by default each scenario will be run in a separate worker
process using <code>parLapply</code> from <span class="pkg">parallel</span> (see also <a href="secr.html#topic+Parallel">Parallel</a>). The number of scenarios should not exceed the available number of cores (set by the 'ncores' argument or a prior call to 'setNumThreads').
</p>
<p>If <code>byscenario = FALSE</code> then from <span class="pkg">secrdesign</span> 2.6.0 onwards the usual multithreading of <span class="pkg">secr</span> 4.5 is applied. The number of cores should usually be preset with 'setNumThreads'. If <code>ncores</code> is provided then the environment variable RCPP_PARALLEL_NUM_THREADS is reset. The default behaviour of the fitting functions (secr.fit, ipsecr.fit) is to use this value (unless specified in fit.args).
</p>
<p>When &lsquo;byscenario = TRUE' the L&rsquo;Ecuyer pseudorandom generator is used with a separate random
number stream for each core (see <code><a href="parallel.html#topic+clusterSetRNGStream">clusterSetRNGStream</a></code>).
</p>
<p>For <code>ncores &gt; 1</code> it pays to keep an eye on the processes from the
Performance page of Windows Task Manager (&lt;ctrl&gt;&lt;alt&gt;&lt;del&gt;), or &lsquo;top&rsquo; in
linux OS. If you interrupt <code>run.scenarios</code> (&lt;Esc&gt; from Windows)
you may occasionally find some processes do not terminate and have to
be manually terminated from the Task Manager - they appear as
Rscript.exe on the Processes page.
</p>



<h4>Alternate functions for simulation and fitting</h4>

<p>The default is to use functions <code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code> and <code><a href="secr.html#topic+secr.fit">secr.fit</a></code> from <span class="pkg">secr</span>. Either may be substituted by the corresponding function (<code><a href="ipsecr.html#topic+simCH">simCH</a></code> or <code><a href="ipsecr.html#topic+ipsecr.fit">ipsecr.fit</a></code>) from package <span class="pkg">ipsecr</span> if that has been installed.
</p>



<h4>Multi-model fit</h4>

<p>Multiple models may be fitted to the same simulated data for multi-model inference. This requires both (i) &lsquo;fit = &quot;multifit&quot;&rsquo;, and (ii) 'fit.args' should be a nested list (fit arguments within models within fit.index) with a separate specification for each model fit. See the vignette for examples.
</p>



<h4>Design-only statistics</h4>

<p>Designs for distance sampling were evaluated by Fewster and Buckland (2004) by computing statistics from simulated detections without fitting a model to estimate the detection parameters. An analogous procedure for SECR is implemented by setting <code>fit = 'design'</code>. A new default extractfn (designextractfn) computes the effective sampling area with the <span class="pkg">secr</span> function <code><a href="secr.html#topic+pdot">pdot</a></code> and returns a vector of values -
</p>

<table>
<tr>
 <td style="text-align: left;">
  n   </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of individuals detected </td>
</tr>
<tr>
 <td style="text-align: left;">
  r   </td><td style="text-align: left;"> </td><td style="text-align: left;"> number of recaptures </td>
</tr>
<tr>
 <td style="text-align: left;">
  esa </td><td style="text-align: left;"> </td><td style="text-align: left;"> effective sampling area, given the known detection parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
  D   </td><td style="text-align: left;"> </td><td style="text-align: left;"> D = n/esa </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The resulting simulation object is of type 'selectedstatistics' for which the summary method works as usual.
</p>
<p>A similar effect may be achieved by providing a custom extractfn and passing arguments to it via the dots argument of <code>run.scenarios</code>.
</p>



<h4>Miscellaneous</h4>

<p>From 2.2.0, two or more rows in <code>scenarios</code> may share the same scenario number. This is used to generate multiple population subclasses (e.g. sexes) differing in density and/or detection parameters. If <code>multisession = TRUE</code> the subclasses become separate sessions in a multi-session capthist object (this may require a custom <code>extractfn</code>). <code>multisession</code> is ignored with a warning if each scenario row has a unique number.
</p>
<p>From 2.7.0, each component of &lsquo;trapset&rsquo; may be a function that constructs a detector layout. This allows layouts to be constructed dynamically at the time each capthist is generated; arguments of each function are provided in the &lsquo;trap.args&rsquo; list which should be of the same length as &lsquo;trapset&rsquo; The primary purpose is to allow systematic grids, laceworks etc. to be constructed with a unique random origin for each replicate. The &lsquo;maskset&rsquo; argument must be provided - it should cover all potential layouts, regardless of origins.
</p>
<p>In <code>fit.models</code> the arguments <code>scen</code> and <code>repl</code> may be used to select a subset of datasets for model fitting.
</p>



<h4>Mark-resight</h4>

  <p><code>chatnsim</code> controls an additional quasi-likelihood model step to adjust for overdispersion of sighting counts. No adjustment happens when <code>chatnsim = 0</code>; otherwise <code>abs(chatnsim)</code> gives the number of simulations to perform to estimate overdispersion. If <code>chatnsim &lt; 0</code> then the quasilikelihood is used only to re-estimate the variance at the previous MLE (method = &quot;none&quot;).
</p>



<h4>Intermediate output</h4>

<p> If 'prefix' is provided than results will be saved for each scenario separately. The filename of scenario 1 is of the form 'prefix1.RDS'. The prefix may include a file path.
</p>



<h4>Further processing</h4>

<p>A summary method is provided (see
<code><a href="#topic+summary.secrdesign">summary.secrdesign</a></code>). It is usually necessary to process
the simulation results further with <code><a href="#topic+predict.fittedmodels">predict.fittedmodels</a></code>
and/or <code><a href="#topic+select.stats">select.stats</a></code> before summarization.
</p>



<h3>Value</h3>

<p>An object of class (x, &lsquo;secrdesign&rsquo;, &lsquo;list&rsquo;), where x is one of
&lsquo;fittedmodels&rsquo;, &lsquo;estimatetables&rsquo;, &lsquo;selectedstatistics&rsquo; or &lsquo;rawdata&rsquo;,
with components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>character string including the software version number</p>
</td></tr>
<tr><td><code>starttime</code></td>
<td>
<p>character string for date and time of run</p>
</td></tr>
<tr><td><code>proctime</code></td>
<td>
<p>processor time for simulations, in seconds</p>
</td></tr>
<tr><td><code>scenarios</code></td>
<td>
<p>dataframe as input</p>
</td></tr>
<tr><td><code>trapset</code></td>
<td>
<p>list of trap layouts as input</p>
</td></tr>
<tr><td><code>maskset</code></td>
<td>
<p>list of habitat masks (input or generated)</p>
</td></tr>
<tr><td><code>xsigma</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>nx</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>pop.args</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>CH.function</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>det.args</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>fit.function</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>fit.args</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>extractfn</code></td>
<td>
<p>function used to extract statistics from each
simulation</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>nrepl</code></td>
<td>
<p>from input</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>list with one component per scenario </p>
</td></tr>
<tr><td><code>outputtype</code></td>
<td>
<p>character code - see vignette</p>
</td></tr>
</table>
<p>If <code>fit = FALSE</code> and <code>extractfn = identity</code> the result is of
class (&lsquo;rawdata&rsquo;, &lsquo;secrdesign&rsquo;, &lsquo;list&rsquo;). This may be used as input to
<code>fit.models</code>, which interprets each model specification in
<code>fit.args</code> as a new &lsquo;sub-scenario&rsquo; of each input scenario
(i.e. all models are fitted to every dataset). The output
possibilities are the same as for <code>run.scenarios</code>.
</p>
<p>If subclasses have been defined (i.e. scenarios has multiple rows with the same scenario ID), each simulated capthist object has covariates with a character-valued column named &quot;group&quot; (&quot;1&quot;, &quot;2&quot; etc.) (there is also a column &quot;sex&quot; generated automatically by <code>sim.popn</code>).
</p>


<h3>Note</h3>

<p>100 ha = 1 km^2.
</p>
<p>fit.function = 'openCR.fit' was deprecated from 2.5.8 and has been removed.
</p>


<h3>Author(s)</h3>

<p>Murray Efford
</p>


<h3>References</h3>

<p>Fewster, R. M. and Buckland, S. T. 2004. Assessment of distance
sampling estimators. In: S. T. Buckland, D. R. Anderson,
K. P. Burnham, J. L. Laake, D. L. Borchers and L. Thomas (eds)
<em>Advanced distance sampling</em>. Oxford University Press, Oxford,
U. K. Pp. 281&ndash;306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expand.arg">expand.arg</a></code>,
</p>
<p><code><a href="#topic+select.stats">select.stats</a></code>,
</p>
<p><code><a href="#topic+summary.secrdesign">summary.secrdesign</a></code>,
</p>
<p><code><a href="#topic+summary.estimatetables">summary.estimatetables</a></code>,
</p>
<p><code><a href="#topic+summary.selectedstatistics">summary.selectedstatistics</a></code>,
</p>
<p><code><a href="#topic+estimateSummary">estimateSummary</a></code>
</p>
<p>Miscellaneous &ndash;
</p>
<p><code><a href="#topic+predict.fittedmodels">predict.fittedmodels</a></code>,
</p>
<p><code><a href="#topic+scenarioSummary">scenarioSummary</a></code>, 
</p>
<p><code><a href="#topic+count.summary">count.summary</a></code>,
</p>
<p><code><a href="#topic+predict.summary">predict.summary</a></code>
</p>
<p><span class="pkg">secr</span> functions used internally &ndash;
</p>
<p><code><a href="secr.html#topic+sim.popn">sim.popn</a></code>,
</p>
<p><code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>,
</p>
<p><code><a href="secr.html#topic+secr.fit">secr.fit</a></code>
</p>
<p>To combine output &ndash;
</p>
<p><code><a href="#topic+rbind.estimatetables">rbind.estimatetables</a></code>,
</p>
<p><code><a href="#topic+rbind.selectedstatistics">rbind.selectedstatistics</a></code>,
</p>
<p><code><a href="#topic+c.estimatetables">c.estimatetables</a></code>,
</p>
<p><code><a href="#topic+c.selectedstatistics">c.selectedstatistics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple example: generate and summarise trapping data
## at two densities and for two levels of sampling frequency
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2, noccasions =
    c(5,10))
traps1 &lt;- make.grid()   ## default 6 x 6 trap grid
tmp1 &lt;- run.scenarios(nrepl = 20, trapset = traps1, scenarios = scen1,
    fit = FALSE)
summary(tmp1)

## Not run: 

setNumThreads(7)

##########################################
# new summary method (secrdesign &gt;= 2.8.1)
# assumes fit = TRUE, extractfn = predict

tmp2 &lt;- run.scenarios(nrepl = 10, trapset = traps1, scenarios = scen1,
    fit = TRUE, extractfn = predict)
estimateSummary(tmp2, format = "data.frame", 
    cols = c('scenario', 'noccasions'))

###########################
## 2-phase example
## first make and save rawdata
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()   ## default 6 x 6 trap grid
tmp1 &lt;- run.scenarios(nrepl = 20, trapset = traps1, scenarios = scen1,
    fit = FALSE, extractfn = identity)

## review rawdata
summary(tmp1)

## then fit and summarise models
tmp2 &lt;- fit.models(tmp1, fit.args = list(list(model = g0~1),
    list(model = g0~T)), fit = TRUE)
summary(tmp2)
###########################

## Construct a list of detector arrays
## Each is a set of 5 parallel lines with variable between-line spacing;
## the argument that we want to vary (spacey) follows nx, ny and spacex
## in the argument list of make.grid().

spacey &lt;- seq(2000,5000,500)
names(spacey) &lt;- paste('line', spacey, sep = '.')
trapset &lt;- lapply(spacey, make.grid, nx = 101, ny = 5, spacex = 1000,
    detector = 'proximity')

## Make corresponding set of masks with constant spacing (1 km)
maskset &lt;- lapply(trapset, make.mask, buffer = 8000, spacing = 1000,
    type = 'trapbuffer')

## Generate scenarios
scen &lt;- make.scenarios (trapsindex = 1:length(spacey), nrepeats = 8,
    noccasions = 2, D = 0.0002, g0 = c(0.05, 0.1), sigma = 1600, cross = TRUE)

## RSE without fitting model
sim &lt;- run.scenarios (50, scenarios = scen, trapset = trapset, maskset = maskset,
    fit = TRUE, fit.args = list(method = 'none'), seed = 123)

## Extract statistics for predicted density
sim &lt;- select.stats(sim, parameter = 'D')

## Plot to compare line spacing
summ &lt;- summary (sim, type='array',  fields = c('mean','lcl','ucl'))$OUTPUT
plot(0,0,type='n', xlim=c(1.500,5.500), ylim = c(0,0.36), yaxs = 'i',
    xaxs = 'i', xlab = 'Line spacing  km', ylab = 'RSE (D)')
xv &lt;- seq(2,5,0.5)
points(xv, summ$mean[,1,'RSE'], type='b', pch=1)
points(xv, summ$mean[,2,'RSE'], type='b', pch=16)
segments(xv, summ$lcl[,1,'RSE'], xv, summ$ucl[,1,'RSE'])
segments(xv, summ$lcl[,2,'RSE'], xv, summ$ucl[,2,'RSE'])
legend(4,0.345, pch=c(1,16), title = 'Baseline detection',
    legend = c('g0 = 0.05', 'g0 = 0.1'))

## End(Not run)

</code></pre>

<hr>
<h2 id='saturation'>Detector saturation</h2><span id='topic+saturation'></span>

<h3>Description</h3>

<p>Computes the expected proportion of successful detectors (i.e., &lsquo;trap success&rsquo;). The calculation does not allow for local variation in realised density (number of animals centred near each detector) and the predictions are therefore slightly higher than simulations with Poisson local density. The discrepancy is typically less than 1%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
saturation(traps, mask, detectpar, detectfn = 
    c("HHN", "HHR", "HEX", "HAN", "HCG", 'HN', 'HR', 'EX'), 
    D, plt = FALSE, add = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saturation_+3A_traps">traps</code></td>
<td>
<p>secr traps object</p>
</td></tr>
<tr><td><code id="saturation_+3A_mask">mask</code></td>
<td>
<p>secr mask object</p>
</td></tr>
<tr><td><code id="saturation_+3A_detectpar">detectpar</code></td>
<td>
<p> a named list giving a value for each parameter of detection function </p>
</td></tr>
<tr><td><code id="saturation_+3A_detectfn">detectfn</code></td>
<td>
<p>integer code or character string for shape of detection function 
&ndash; see <a href="secr.html#topic+detectfn">detectfn</a></p>
</td></tr>
<tr><td><code id="saturation_+3A_d">D</code></td>
<td>
<p>population density animals / hectare; may be scalar or vector of length <code>nrow(mask)</code></p>
</td></tr>
<tr><td><code id="saturation_+3A_plt">plt</code></td>
<td>
<p>logical; if TRUE then a colour plot is produced</p>
</td></tr>
<tr><td><code id="saturation_+3A_add">add</code></td>
<td>
<p>logical; if TRUE any plot is added to the existing plot</p>
</td></tr>
<tr><td><code id="saturation_+3A_...">...</code></td>
<td>
<p>other arguments passed to plot.mask when plt = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is based on an additive hazard model. If <code>detectfn</code> is not a hazard function (&lsquo;HHN&rsquo;, &lsquo;HEX&rsquo;, &lsquo;HHR&rsquo;, &lsquo;HAN&rsquo; and &lsquo;HCG&rsquo;) then an attempt is made to approximate one of the hazard functions (HN -&gt; HHN, HR -&gt; HHR, EX -&gt; HEX). The default is &lsquo;HHN&rsquo;.
</p>
<p>Computation is not possible for single-catch traps.
</p>
<p>An empirical estimate of saturation is the total number of detectors visited divided by the total number of detectors used. These are outputs from the summary method for capthist objects. See Examples.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>bydetector</code></td>
<td>
<p>expected saturation for each detector</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>average over detectors</p>
</td></tr>
</table>
<p>The list is returned invisibly if <code>plt = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Enrm">Enrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr &lt;- traps(captdata)
detector(tr) &lt;- 'multi'
mask &lt;- make.mask(tr, buffer = 100)
saturation(tr, mask, detectpar = list(lambda0 = 0.27, sigma = 29), 
    detectfn = 'HHN', D = 5.5, plt = TRUE)
plotMaskEdge(as.mask(tr), add = TRUE)  ## boundary line

# empirical - useful for extractfn argument of secrdesign::run.scenarios
satfn &lt;- function(CH) { 
    sumCH &lt;- summary(CH)$counts
    sumCH['detectors visited', 'Total'] /  sumCH['detectors used', 'Total']
}
satfn(captdata)

</code></pre>

<hr>
<h2 id='scenariosFromStatistics'>Make Scenarios to Match Capture Statistics</h2><span id='topic+scenariosFromStatistics'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+make.scenarios">make.scenarios</a></code> function requires prior knowledge of
population density and the intercept of the detection function
(g0). This function provides an alternative mechanism for generating
scenarios from a value of sigma and target values for the numbers of
individuals n and recaptures r. Only a halfnormal detection function
is supported (probability, not hazard), and many options in
<code><a href="#topic+make.scenarios">make.scenarios</a></code> have yet to be implemented. Only a single
detector layout and single mask may be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
scenariosFromStatistics(sigma, noccasions, traps, mask, nval, rval,
 g0.int = c(0.001, 0.999))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scenariosFromStatistics_+3A_sigma">sigma</code></td>
<td>
<p>numeric vector of one or more values for sigma</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_noccasions">noccasions</code></td>
<td>
<p>integer vector of number of sampling occasions</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_traps">traps</code></td>
<td>
<p>traps object</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_mask">mask</code></td>
<td>
<p>mask object</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_nval">nval</code></td>
<td>
<p>integer vector of values of n</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_rval">rval</code></td>
<td>
<p>integer vector of values of r</p>
</td></tr>
<tr><td><code id="scenariosFromStatistics_+3A_g0.int">g0.int</code></td>
<td>
<p>numeric vector defining the interval to be searched for g0 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is based on R code in Appendix B of Efford, Dawson and
Borchers (2009).
</p>


<h3>Value</h3>

<p>A scenario dataframe with one row for each combination of <code>sigma</code>,
<code>noccasions</code>, <code>nval</code> and <code>rval</code>.
</p>


<h3>References</h3>

<p>Efford, M. G., Dawson, D. K. and Borchers, D. L. (2009) Population
density estimated from locations of individuals on a passive detector
array. <em>Ecology</em> <b>90</b>, 2676&ndash;2682.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.scenarios">make.scenarios</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid36 &lt;- make.grid(nx = 6, ny = 6, spacing = 200)
mask &lt;- make.mask(grid36, buffer = 2000)
scen &lt;- scenariosFromStatistics (sigma = c(200,400), noccasions = 44,
    traps = grid36, mask = mask, nval = 14, rval = 34)
sim &lt;- run.scenarios(scen, nrepl = 5, traps = grid36, mask = mask)
summary(sim)

</code></pre>

<hr>
<h2 id='scenarioSummary'>Summary of Scenarios</h2><span id='topic+scenarioSummary'></span>

<h3>Description</h3>

<p>Compute various deterministic summaries for scenarios generated by <code>make.scenarios</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>
scenarioSummary(scenarios, trapset, maskset, xsigma = 4, nx = 64, CF = 1.0, 
    costing = FALSE, ..., ncores = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scenarioSummary_+3A_scenarios">scenarios</code></td>
<td>
<p>dataframe of simulation scenarios</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_trapset">trapset</code></td>
<td>
<p>secr traps object or a list of traps objects</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_maskset">maskset</code></td>
<td>
<p>secr mask object or a list of mask objects (optional)</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_xsigma">xsigma</code></td>
<td>
<p>numeric buffer width as multiple of sigma (alternative
to maskset)</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_nx">nx</code></td>
<td>
<p>integer number of cells in mask in x direction  (alternative
to maskset)</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_cf">CF</code></td>
<td>
<p>numeric correction factor for rule-of-thumb RSE (see <code><a href="#topic+minnrRSE">minnrRSE</a></code>)</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_costing">costing</code></td>
<td>
<p>logical; if TRUE then costings will be appended</p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+costing">costing</a></code></p>
</td></tr>
<tr><td><code id="scenarioSummary_+3A_ncores">ncores</code></td>
<td>
<p>integer number of cores for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all scenarios from <code>make.scenarios()</code> are suitable. Grouped (multi-line) scenarios are excluded. Hazard detection functions are preferred (&lsquo;HHN&rsquo;, &lsquo;HHR&rsquo;, &lsquo;HEX&rsquo;, &lsquo;HAN&rsquo;, &lsquo;HCG&rsquo;). &lsquo;HN&rsquo;, &lsquo;HR&rsquo; and &lsquo;EX&rsquo; are converted approximately to &lsquo;HHN&rsquo;, &lsquo;HHR&rsquo; and &lsquo;HEX&rsquo; respectively, with a warning; other functions are rejected.
</p>
<p><code>CF</code> may be a vector of values that is recycled across the components of <code>trapset</code>. The correction factor is a multiplier applied after all other calculations.
</p>
<p>The approximate RSE(D-hat) is rotRSE = CF/ sqrt(min(E(n), E(r))). This assumes n is Poisson-distributed. For binomial n an ad hoc adjustment is rotRSEB = sqrt(rotRSE^2 - 1 / (D x A)) where A is the mask area.
</p>
<p>The default <code>ncores = 1</code> (new in 2.7.0) is usually faster than setting ncores&gt;1 because of the overheads in setting up a parallel cluster.
</p>
<p>The ... argument is for inputs to <code><a href="#topic+costing">costing</a></code>, including <code>unitcost</code> (required) and routelength (optional). 
</p>


<h3>Value</h3>

<p>A dataframe including the first 8 columns from scenarios and the computed columns &ndash;
</p>
<table role = "presentation">
<tr><td><code>En</code></td>
<td>
<p>expected number of individuals</p>
</td></tr>
<tr><td><code>Er</code></td>
<td>
<p>expected number of recaptures</p>
</td></tr>
<tr><td><code>Em</code></td>
<td>
<p>expected number of movement recaptures</p>
</td></tr>
<tr><td><code>En2</code></td>
<td>
<p>expected number of individuals detected at two or more sites</p>
</td></tr>
<tr><td><code>esa</code></td>
<td>
<p>effective sampling area (ha)</p>
</td></tr>
<tr><td><code>CF</code></td>
<td>
<p>rule-of-thumb correction factor</p>
</td></tr>
<tr><td><code>rotRSE</code></td>
<td>
<p>rule-of-thumb relative standard error of density estimate</p>
</td></tr>
<tr><td><code>rotRSEB</code></td>
<td>
<p>rotRSE with adjustment for fixed N in region defined by mask (i.e. Binomial <code class="reqn">n</code> rather than Poisson <code class="reqn">n</code>)</p>
</td></tr>
<tr><td><code>arrayN</code></td>
<td>
<p>number of detectors in each array</p>
</td></tr>
<tr><td><code>arrayspace</code></td>
<td>
<p>array spacing in sigma units</p>
</td></tr>
<tr><td><code>arrayspan</code></td>
<td>
<p>largest dimension of array in sigma units</p>
</td></tr>
<tr><td><code>saturation</code></td>
<td>
<p>expected proportion of detectors at which detection occurs (trap success)</p>
</td></tr>
<tr><td><code>travel</code></td>
<td>
<p>travel cost</p>
</td></tr>
<tr><td><code>arrays</code></td>
<td>
<p>cost of each repeated array</p>
</td></tr>
<tr><td><code>detectors</code></td>
<td>
<p>fixed cost per detector</p>
</td></tr>
<tr><td><code>visits</code></td>
<td>
<p>cost per detector per visit</p>
</td></tr>
<tr><td><code>detections</code></td>
<td>
<p>cost per detection </p>
</td></tr>
<tr><td><code>totalcost</code></td>
<td>
<p>summed costs</p>
</td></tr>
<tr><td><code>detperHR</code></td>
<td>
<p>median number of detectors per 95% home range</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>overlap index <code class="reqn">k = \sigma \sqrt D / 100</code> from secr <code><a href="secr.html#topic+kfn">kfn</a></code></p>
</td></tr>
</table>
<p>Costings (the last 6 columns) are omitted if <code>costing = FALSE</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.scenarios">make.scenarios</a></code>, 
<code><a href="#topic+Enrm">Enrm</a></code>, 
<code><a href="#topic+costing">costing</a></code>, 
<code><a href="#topic+minnrRSE">minnrRSE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scen &lt;- make.scenarios(D = c(5,10), sigma = 25, lambda0 = 0.2, detectfn = 'HHN')
grid &lt;- make.grid(6,6, detector = 'multi')
scenarioSummary(scen, list(grid), costing = TRUE, unitcost = list(perkm = 10))

</code></pre>

<hr>
<h2 id='select.stats'> Select Statistics to Summarize </h2><span id='topic+select.stats'></span><span id='topic+find.param'></span><span id='topic+find.stats'></span>

<h3>Description</h3>

<p>When the results of each simulation with <code>run.scenarios</code> are
saved as a dataframe (e.g. from predict()) it is necessary to select
estimates of just one parameter for numerical summarization. This does
the job. <code>find.param</code> is a helper function to quickly display the
parameters available for summarisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
select.stats(object, parameter = "D", statistics, true)
find.param(object)
find.stats(object)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.stats_+3A_object">object</code></td>
<td>
<p>&lsquo;estimatetables&rsquo; object from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="select.stats_+3A_parameter">parameter</code></td>
<td>
<p>character name of parameter to extract</p>
</td></tr>
<tr><td><code id="select.stats_+3A_statistics">statistics</code></td>
<td>
<p>character vector of statistic names</p>
</td></tr>
<tr><td><code id="select.stats_+3A_true">true</code></td>
<td>
<p>numeric vector of ''true' values of parameter, one per scenario</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>select.stats</code> is used to select a particular vector of numeric
values for summarization. The &lsquo;parameter&rsquo; argument indexes a row in the
data.frame for one replicate (i.e., one &lsquo;real&rsquo; parameter). Each
&lsquo;statistic&rsquo; is either a column in that data.frame or a statistic derived
from a column.
</p>
<p>If <code>statistics</code> is not specified, the default is to use all numeric
columns in the input (i.e., c(&lsquo;estimate&rsquo;, &lsquo;SE.estimate&rsquo;, &lsquo;lcl&rsquo;, &lsquo;ucl&rsquo;)
for predict and c(&lsquo;beta&rsquo;, &lsquo;SE.beta&rsquo;, &lsquo;lcl&rsquo;, &lsquo;ucl&rsquo;) for coef).
</p>
<p><code>statistics</code> may include any of &lsquo;estimate&rsquo;, &lsquo;SE.estimate&rsquo;, &lsquo;lcl&rsquo;,
&lsquo;ucl&rsquo;, 'true', &lsquo;RB&rsquo;, &lsquo;RSE&rsquo;, &lsquo;COV&rsquo; and &lsquo;ERR&rsquo; (for outputtype &lsquo;coef&rsquo; use &lsquo;beta&rsquo; and
&lsquo;SE.beta&rsquo; instead of &lsquo;estimate and 'SE.estimate&rsquo;). &lsquo;true&rsquo; refers to the
known parameter value used to generate the data.
</p>
<p>The computed statistics are:
</p>

<table>
<tr>
 <td style="text-align: left;">
  Statistic </td><td style="text-align: left;"> Name </td><td style="text-align: left;"> Value </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  RB </td><td style="text-align: left;"> Relative bias </td><td style="text-align: left;"> (estimate - true) / true </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  RSE </td><td style="text-align: left;"> Relative SE </td><td style="text-align: left;"> SE.estimate / estimate </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  ERR </td><td style="text-align: left;"> Absolute deviation </td><td style="text-align: left;"> abs(estimate - true) </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  COV </td><td style="text-align: left;"> Coverage </td><td style="text-align: left;"> (estimate &gt; lcl) &amp; (estimate &lt; ucl) </td><td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>&lsquo;RB&rsquo;, &lsquo;COV&rsquo; and &lsquo;ERR&rsquo; relate an estimate to the known (true) value of
the parameter in <code>object$scenarios</code>. They are computed only when a
model has been fitted without method = &lsquo;none&rsquo;.
</p>
<p>&lsquo;COV&rsquo; remains binary (0/1) in the output from <code>select.stats</code>; the
result of interest is the mean of this statistic across replicates (see
<code><a href="#topic+summary.secrdesign">summary.secrdesign</a></code>). Similarly, &lsquo;ERR&rsquo; is used with field &lsquo;rms&rsquo;
in <code><a href="#topic+summary.secrdesign">summary.secrdesign</a></code> to compute the
root-mean-squared-error RMSE.
</p>
<p><code>find.param</code> and <code>find.stats</code> may be used to &lsquo;peek&rsquo; at objects
of class &lsquo;estimatetables&rsquo; and &lsquo;selectedstatistics&rsquo; respectively to
recall the available parameter estimates or &lsquo;statistics&rsquo;.
</p>
<p>An attempt is made to extract <code>true</code> automatically if it is not provided. This does not always work (e.g. with extractfn <code>region.N</code>, region differing from the mask, and a heterogeneous density model). Check this by including &ldquo;true&rdquo; as a statistic to summarise (see Examples).
</p>


<h3>Value</h3>

<p>For <code>select.stats</code>, an object with class
c(&lsquo;selectedstatistics&rsquo;,&lsquo;secrdesign&rsquo;, &lsquo;list&rsquo;) suitable for numerical
summarization with <code><a href="#topic+summary.selectedstatistics">summary.selectedstatistics</a></code>. The value
of &lsquo;parameter&rsquo; is stored as an attribute.
</p>
<p>For <code>find.param</code>, a character vector of the names of parameters
with estimates in <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>, <code><a href="#topic+validate">validate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## using nrepl = 2 just for checking
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()
tmp1 &lt;- run.scenarios(nrepl = 2, trapset = traps1, scenarios = scen1,
    fit = TRUE, extractfn = secr::trim)
tmp2 &lt;- predict(tmp1)
tmp3 &lt;- select.stats(tmp2, 'D', c('estimate','true','RB','RSE','COV'))
summary(tmp3)
</code></pre>

<hr>
<h2 id='summary.secrdesign'>Generic Methods for secrdesign Objects</h2><span id='topic+summary.secrdesign'></span><span id='topic+summary.rawdata'></span><span id='topic+summary.estimatetables'></span><span id='topic+summary.selectedstatistics'></span><span id='topic+plot.selectedstatistics'></span><span id='topic+header'></span>

<h3>Description</h3>

<p>Methods to summarize simulated datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'secrdesign'
summary(object, ...)

## S3 method for class 'rawdata'
summary(object, ...)

## S3 method for class 'estimatetables'
summary(object, ...)

## S3 method for class 'selectedstatistics'
summary(object, fields = c('n', 'mean',
'se'), dec = 5, alpha = 0.05, type = c('list','dataframe','array'), ...)

## S3 method for class 'selectedstatistics'
plot(x, scenarios, statistic, type =
c('hist', 'CI'), refline, xlab = NULL, ...)

header(object)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.secrdesign_+3A_object">object</code></td>
<td>
<p>object of class simulations from <code>run.scenarios</code></p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_dec">dec</code></td>
<td>
<p>number of decimal places in output</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_fields">fields</code></td>
<td>
<p>character vector; names of required summary
statistics (see Details)</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals and quantiles</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_type">type</code></td>
<td>
<p>character code for type of output (see Details)</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_...">...</code></td>
<td>
<p>other arguments &ndash; not currently used by summary but
passed to <code><a href="graphics.html#topic+hist">hist</a></code> by the plot method</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_x">x</code></td>
<td>
<p>object of class &lsquo;selectedstatistics&rsquo; from
<code>run.scenarios</code></p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_scenarios">scenarios</code></td>
<td>
<p>integer indices of scenarios to plot (all plotted if not specified)</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_statistic">statistic</code></td>
<td>
<p>integer or character indices of the statistics in x for which
histograms are requested</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_refline">refline</code></td>
<td>
<p>logical; if TRUE a reference line is plotted at the
true value of a parameter</p>
</td></tr>
<tr><td><code id="summary.secrdesign_+3A_xlab">xlab</code></td>
<td>
<p>character; optional label for x-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>object</code> inherits from &lsquo;selectedstatistics&rsquo; then the numeric
results from replicate simulations are summarized using the chosen
&lsquo;fields&rsquo; (by default, the number of non-missing values, mean and standard
error), along with header information describing the
simulations. Otherwise the header alone is returned.
</p>
<p><code>fields</code> is a vector of any selection from c(&lsquo;n&rsquo;, &lsquo;mean&rsquo;, &lsquo;sd&rsquo;,
&lsquo;se&rsquo;, &lsquo;min&rsquo;, &lsquo;max&rsquo;, &lsquo;lcl&rsquo;, &lsquo;ucl&rsquo;, &lsquo;median&rsquo;, &lsquo;q&rsquo;, &lsquo;rms&rsquo;, &lsquo;var&rsquo;), or the
character value &lsquo;all&rsquo;.
</p>
<p>Field &lsquo;q&rsquo; provides 1000 <code>alpha/2</code> and 1000[1 - <code>alpha/2</code>]
quantiles qxxx and qyyy.
</p>
<p>&lsquo;lcl&rsquo; and &lsquo;ucl&rsquo; refer to the upper and lower limits of a 100(1 -
alpha)% confidence interval for the statistic, across replicates.
</p>
<p>&lsquo;rms&rsquo; gives the root-mean-square of the statistic - most useful for
the statistic &lsquo;ERR&rsquo; (see <code><a href="#topic+select.stats">select.stats</a></code>) when it
represents the overall accuracy or RMSE.
</p>
<p>The <code>plot</code> method plots either (i) histograms of the selected
statistics (type = &lsquo;hist&rsquo;) or (ii) the estimate and confidence interval for
each replicate (type = &lsquo;CI&rsquo;). The default for type = &lsquo;hist&rsquo; is to plot
the first statistic - this is usually &lsquo;n&rsquo; (number of detected animals)
when <code>fit = FALSE</code>, and &lsquo;estimate&rsquo; (parameter estimate) when
<code>fit = TRUE</code>. If length(statistic) &gt; 1 then more than one plot
will be produced, so a multi-column or multi-row layout should be
prepared with <code>par</code> arguments &lsquo;mfcol&rsquo; or &lsquo;mfrow&rsquo;.
</p>
<p>For type = &lsquo;CI&rsquo; the statistics must include &lsquo;estimate&rsquo;, &lsquo;lcl&rsquo; and
&lsquo;ucl&rsquo; (or &lsquo;beta&rsquo;, &lsquo;lcl&rsquo; and &lsquo;ucl&rsquo; if outputtype = &lsquo;coef&rsquo;).
</p>
<p><code><a href="#topic+estimateSummary">estimateSummary</a></code> is a simpler approach that provides full output 
for models with groups or multiple sessions simulated in 
<code><a href="#topic+run.scenarios">run.scenarios</a></code> with extractfn predict or coef).
</p>


<h3>Value</h3>

<p>List with components &lsquo;header&rsquo;
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>original function call</p>
</td></tr>
<tr><td><code>starttime</code></td>
<td>
<p>from object</p>
</td></tr>
<tr><td><code>proctime</code></td>
<td>
<p>from object</p>
</td></tr>
<tr><td><code>constants</code></td>
<td>
<p>small dataframe with values of non-varying inputs</p>
</td></tr>
<tr><td><code>varying</code></td>
<td>
<p>small dataframe with values of varying inputs</p>
</td></tr>
<tr><td><code>fit.args</code></td>
<td>
<p>small dataframe with values arguments for
secr.fit, if specified</p>
</td></tr>
</table>
<p>and &lsquo;OUTPUT&rsquo;, a list with one component for each field. Each component
may be a list or an array.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>,
<code><a href="#topic+make.array">make.array</a></code>,
<code><a href="#topic+select.stats">select.stats</a></code>
<code><a href="#topic+validate">validate</a></code>
<code><a href="#topic+estimateSummary">estimateSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## collect raw counts
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()
tmp1 &lt;- run.scenarios(nrepl = 50, trapset = traps1, scenarios = scen1,
    fit = FALSE)

opar &lt;- par(mfrow=c(2,3))
plot(tmp1, statistic = 1:3)
par(opar)

summary(tmp1)

summary(tmp1, field=c('q025', 'median', 'q975'))

</code></pre>

<hr>
<h2 id='transformOutput'>
Transform Simulation Output
</h2><span id='topic+transformOutput'></span>

<h3>Description</h3>

<p>Transform output component of simulation output from <code><a href="#topic+run.scenarios">run.scenarios</a></code>. 
Typically this replaces an entire saved model fit with a table of estimates from that fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
transformOutput(object, extractfn, outputtype = "predicted", ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformOutput_+3A_object">object</code></td>
<td>
<p>output from <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="transformOutput_+3A_extractfn">extractfn</code></td>
<td>
<p>function such as the &lsquo;extractfn&rsquo; argument of <code><a href="#topic+run.scenarios">run.scenarios</a></code></p>
</td></tr>
<tr><td><code id="transformOutput_+3A_outputtype">outputtype</code></td>
<td>
<p>character (see Details)</p>
</td></tr>
<tr><td><code id="transformOutput_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>extractfn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each replicate of each scenario is transformed using &lsquo;extractfn&rsquo;, which should accept as input the object returned by the extractfn of the original call to <code>run.scenarios</code>. As a typical example, <code>sims &lt;- run.scenarios(..., fit = TRUE, extractfn = identity)</code> returns outputs of class &lsquo;secr&rsquo; and could be followed by <code>sims2 &lt;- transformOutput(sims, predict)</code>; <code>sims2</code> may be used as input to <code><a href="#topic+estimateSummary">estimateSummary</a></code> and other summary functions.
</p>


<h3>Value</h3>

<p>An object resembling the output from <code><a href="#topic+run.scenarios">run.scenarios</a></code> but with transformed output.
The outputtype and class of the object are changed to match &lsquo;outputtype&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.scenarios">run.scenarios</a></code>,
<code><a href="#topic+estimateSummary">estimateSummary</a></code>,
<code><a href="#topic+outputtype+3C-">outputtype&lt;-</a></code>
</p>

<hr>
<h2 id='validate'>Reject Implausible Statistics</h2><span id='topic+validate'></span>

<h3>Description</h3>

<p>Simulation output may contain rogue values due to idiosyncracies of
model fitting. For example, nonidentifiability due to inadequate data
can result in spurious extreme &lsquo;estimates&rsquo; of the sampling
variance. Undue influence of rogue replicates can be reduced by using
the median as a summary field rather than the mean. This function is
another way to deal with the problem, by setting to NA selected
statistics from replicates for which some &lsquo;test&rsquo; statistic is
out-of-range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(x, test, validrange = c(0, Inf), targets = test, quietly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_+3A_x">x</code></td>
<td>
<p>object that inherits from &lsquo;selectedstatistics&rsquo;</p>
</td></tr>
<tr><td><code id="validate_+3A_test">test</code></td>
<td>
<p>character; name of statistic to check</p>
</td></tr>
<tr><td><code id="validate_+3A_validrange">validrange</code></td>
<td>
<p>numeric vector comprising the minimum and maximum
permitted values of &lsquo;test&rsquo;, or a matrix (see details)</p>
</td></tr>
<tr><td><code id="validate_+3A_targets">targets</code></td>
<td>
<p>character vector with names of one or more statistics
to set to missing (NA) when test is out-of-range</p>
</td></tr>
<tr><td><code id="validate_+3A_quietly">quietly</code></td>
<td>
<p>logical; if TRUE messages are suppressed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of &lsquo;test&rsquo; and &lsquo;targets&rsquo; should be columns in each component
&lsquo;replicate x statistic&rsquo; matrix (i.e., scenario) of
<code>x$output</code>. You can check for these with
<code><a href="#topic+find.stats">find.stats</a></code>.
</p>
<p>If <code>validrange</code> is a matrix its first and second columns are
interpreted as scenario-specific bounds (minima and maxima), and the
number of rows must match the number of scenarios.
</p>
<p>If all non-missing values of &lsquo;test&rsquo; are in the valid range, the effect
is to force the target statistics to NA wherever &lsquo;test&rsquo; is NA.
</p>
<p>The default is to change only the test field itself. If the value of
&lsquo;test&rsquo; does not appear in &lsquo;targets&rsquo; then the test field is unchanged.
</p>
<p>If <code>targets = "all"</code> then all columns are set to NA when the test
fails.
</p>


<h3>Value</h3>

<p>An object of class c(&lsquo;selectedstatistics&rsquo;, secrdesign', &lsquo;list&rsquo;) with
the same structure and header information as the input, but possibly
with some values in the &lsquo;output&rsquo; component converted to NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select.stats">select.stats</a></code>, <code><a href="#topic+find.stats">find.stats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## generate some data
scen1 &lt;- make.scenarios(D = c(5,10), sigma = 25, g0 = 0.2)
traps1 &lt;- make.grid()
tmp1 &lt;- run.scenarios(nrepl = 5, trapset = traps1, scenarios = scen1,
    fit = TRUE, extractfn = trim)
tmp2 &lt;- predict(tmp1)
tmp3 &lt;- select.stats(tmp2, 'D', c('estimate','RB','RSE','COV'))

## just for demonstration --
## apply scenario-specific +/- 20% bounds for estimated density
## set RB, RSE and COV to NA when estimate is outside this range
permitted &lt;- outer(tmp3$scenarios$D, c(0.8,1.2)) 
permitted   ## a 2 x 2 matrix
tmp4 &lt;- validate(tmp3, 'estimate', permitted, c('RB', 'RSE','COV'))

## what have we done?!
tmp4$output
summary(tmp4)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
