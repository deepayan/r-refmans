<!DOCTYPE html><html><head><title>Help for package ADPclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ADPclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adpclust'><p>Fast Clustering Using Adaptive Density Peak Detection</p></a></li>
<li><a href='#AMISE'><p>AMISE bandwidth</p></a></li>
<li><a href='#clust10'><p>1000 5-dimensional data points that form ten clusters</p></a></li>
<li><a href='#clust3'><p>90 2-dimensional data points that form three clusters</p></a></li>
<li><a href='#clust5'><p>500 5-dimensional data points that form five clusters</p></a></li>
<li><a href='#clust5.1'><p>500 5-dimensional data points that form five clusters</p></a></li>
<li><a href='#dat_gene'><p>243-dimensional gene expression data of 38 patients (243 genes)</p></a></li>
<li><a href='#defCol'><p>Default colors</p></a></li>
<li><a href='#FindCentersAutoD'><p>Automatically finds centers with diagonal f(x) vs delta(x) thresholds</p></a></li>
<li><a href='#FindCentersAutoV'><p>Automatically find centers with vertical threshold</p></a></li>
<li><a href='#FindClustersAuto'><p>Automatically find cluster assignment given f and delta.</p></a></li>
<li><a href='#FindClustersGivenCenters'><p>Find cluster assignments given centers and distance matrix</p></a></li>
<li><a href='#FindClustersManual'><p>User-interactive routine to find clusters</p></a></li>
<li><a href='#FindDistm'><p>Find the distance matrix from data.</p></a></li>
<li><a href='#FindFD'><p>Find f and delta from distance matrix.</p></a></li>
<li><a href='#FindH'><p>Find bandwidth h.</p></a></li>
<li><a href='#plot.adpclust'><p>Visualize the result of adpclust()</p></a></li>
<li><a href='#ROT'><p>Calculate ROT bandwidth</p></a></li>
<li><a href='#summary.adpclust'><p>Summary of adpclust</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Clustering Using Adaptive Density Peak Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of ADPclust clustering procedures (Fast
    Clustering Using Adaptive Density Peak Detection). The work is built and
    improved upon the idea of Rodriguez and Laio (2014)&lt;<a href="https://doi.org/10.1126%2Fscience.1242072">doi:10.1126/science.1242072</a>&gt;. 
    ADPclust clusters data by finding density peaks in a density-distance plot 
    generated from local multivariate Gaussian density estimation. It includes 
    an automatic centroids selection and parameter optimization algorithm, which 
    finds the number of clusters and cluster centroids by comparing average 
    silhouettes on a grid of testing clustering results; It also includes a user 
    interactive algorithm that allows the user to manually selects cluster 
    centroids from a two dimensional "density-distance plot". Here is the 
    research article associated with this package: "Wang, Xiao-Feng, and 
    Yifan Xu (2015)&lt;<a href="https://doi.org/10.1177%2F0962280215609948">doi:10.1177/0962280215609948</a>&gt; Fast clustering using adaptive 
    density peak detection." Statistical methods in medical research". url:
    http://smm.sagepub.com/content/early/2015/10/15/0962280215609948.abstract. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, cluster, fields, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ethanyxu/ADPclust">https://github.com/ethanyxu/ADPclust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ethanyxu/ADPclust/issues">https://github.com/ethanyxu/ADPclust/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-10-14 14:59:52 UTC; ethan.xu</td>
</tr>
<tr>
<td>Author:</td>
<td>Yifan (Ethan) Xu [aut, cre],
  Xiao-Feng Wang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yifan (Ethan) Xu &lt;ethan.yifanxu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-10-15 11:37:01</td>
</tr>
</table>
<hr>
<h2 id='adpclust'>Fast Clustering Using Adaptive Density Peak Detection</h2><span id='topic+adpclust'></span>

<h3>Description</h3>

<p>Clustering of data by finding cluster centers from estimated density peaks. ADPclust is a non-iterative procedure that incorporates multivariate Gaussian density estimation. The number of clusters as well as bandwidths can either be selected by the user or selected automatically through an internal clustering criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adpclust(x = NULL, distm = NULL, p = NULL, centroids = "auto",
  h = NULL, htype = "amise", nclust = 2:10, ac = 1, f.cut = c(0.1,
  0.2, 0.3), fdelta = "mnorm", dmethod = "euclidean", draw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adpclust_+3A_x">x</code></td>
<td>
<p>numeric data frame where rows are observations and columns are variables. One of x and distm must be provided.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_distm">distm</code></td>
<td>
<p>distance matrix of class 'dist'. distm is ignored if x is given.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_p">p</code></td>
<td>
<p>number of variables (ncol(x)). This is only needed if neither x nor h is given.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_centroids">centroids</code></td>
<td>
<p>character string specifying how cluster centroids are selected. Valid options are &quot;user&quot; and &quot;auto&quot;.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_h">h</code></td>
<td>
<p>nonnegative number specifying the bandwidth in density estimation. If h is NULL, the algorithm attempts to find h in a neighborhood centered at either the AMISE bandwidth or ROT bandwidth (see htype).</p>
</td></tr>
<tr><td><code id="adpclust_+3A_htype">htype</code></td>
<td>
<p>character string specifying the method used to calculate a reference bandwidth for the density estimation. htype is ignored if h is given. Valid options of are &quot;ROT&quot; and &quot;AMISE&quot; (see details).</p>
</td></tr>
<tr><td><code id="adpclust_+3A_nclust">nclust</code></td>
<td>
<p>integer, or a vector of integers specifying the pool of the number of clusters in automatic variation. The default is 2:10.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_ac">ac</code></td>
<td>
<p>integer indicating which automatic cut method is used. This is ignored if centroids = 'user'. The valid options are:
</p>

<ul>
<li><p>ac = 1: centroids are chosen to be the data points x's with the largest delta values such that f(x) &gt;= a'th percentile of all f(x). The number of centroids is given by the parameter nclust. The cutting percentile(s) is given by the parameter f.cut. 
</p>
</li>
<li><p>ac = 2: let l denote the straight line connecting (min(f), max(delta)) and (max(f), min(delta)). The centroids are selected to be data points above l and farthest away from it. The number of centroids is given by the parameter nclust.
</p>
</li></ul>
</td></tr>
<tr><td><code id="adpclust_+3A_f.cut">f.cut</code></td>
<td>
<p>number between (0, 1) or numeric vector of numbers between (0, 1). f.cut is used when centroids = &quot;auto&quot; and ac = 1 to automatically select cluster centroids from the decision plot (see ac). The default is c(0.1, 0.2, 0.3).</p>
</td></tr>
<tr><td><code id="adpclust_+3A_fdelta">fdelta</code></td>
<td>
<p>character string that specifies the method used to estimate local density f(x) at each data point x. The default (recommended) is &quot;mnorm&quot; that uses a multivariate Gaussian density estimation to calculate f. Other options are listed below. Here 'distm' denotes the distance matrix. 
</p>

<ul>
<li><p>unorm(f &lt;- 1/(h * sqrt(2 * pi)) * rowSums(exp(-(distm/h)^2/2))); Univariate Gaussian smoother
</p>
</li>
<li><p>weighted(f &lt;- rowSums(exp(-(distm/h)^2))); Univariate weighted smoother
</p>
</li>
<li><p>count(f &lt;- rowSums(distm &lt; h) - 1); Histogram estimator (used in Rodriguez [2014])
</p>
</li></ul>
</td></tr>
<tr><td><code id="adpclust_+3A_dmethod">dmethod</code></td>
<td>
<p>character string that is passed to the 'method' argument in function dist(), which is used to calculate the distance matrix if 'distm' is not given. The default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="adpclust_+3A_draw">draw</code></td>
<td>
<p>boolean. If draw = TRUE the clustering result is plotted after the algorithm finishes. The plot is produced by by plot.adpclust(ans), where 'ans' is the outcome of 'adpclust()'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given n data points x's in p dimensions, adpclust() calculates f(x) and delta(x) for each data point x, where f(x) is the local density at x, and delta(x) is the shortest distance between x and y for all y such that f(x) &lt;= f(y). Data points with large f and large delta values are labeled class centroids. In other words, they appear as isolated points in the upper right corner of the f vs. delta plot (the decision plot). After cluster centroids are determined, other data points are clustered according to their distances to the closes centroids.
</p>
<p>A bandwidth (smoothing parameter) h is used to calculate local density f(x) in various ways. See parameter 'fdelta' for details. If centroids = 'user', then h must be explicitly provided. If centroids = 'auto' and h is not specified, then it is automatically selected from a range of testing values: First a reference bandwidth h0 is calculated by one of the two methods: Scott's Rule-of-Thumb value (htype = &quot;ROT&quot;) or Wand's Asymptotic-Mean-Integrated-Squared-Error value (htype = &quot;AMISE&quot;), then 10 values equally spread in the range [1/3h0, 3h0] are tested. The value that yields the highest silhouette score is chosen as the final h.
</p>


<h3>Value</h3>

<p>An 'adpclust' object that contains the list of the following items.
</p>

<ul>
<li><p>clusters Cluster assignments. A vector of the same length as the number of observations.
</p>
</li>
<li><p>centers: Indices of the clustering centers.
</p>
</li>
<li><p>silhouette: Silhouette score from the final clustering result.
</p>
</li>
<li><p>nclust: Number of clusters.
</p>
</li>
<li><p>h: Final bandwidth.
</p>
</li>
<li><p>f: Final density vector f(x).
</p>
</li>
<li><p>delta: Final delta vector delta(x).
</p>
</li>
<li><p>selection.type: 'user' or 'auto'.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>GitHub: <a href="https://github.com/ethanyxu/ADPclust">https://github.com/ethanyxu/ADPclust</a>
</p>
</li>
<li><p>Xiao-Feng Wang, and Yifan Xu, (2015) &quot;Fast Clustering Using Adaptive Density Peak Detection.&quot; Statistical Methods in Medical Research, doi:10.1177/0962280215609948. 
</p>
</li>
<li><p>PubMed: <a href="http://www.ncbi.nlm.nih.gov/pubmed/26475830">http://www.ncbi.nlm.nih.gov/pubmed/26475830</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load a data set with 3 clusters
data(clust3)

# Automatically select cluster centroids
ans &lt;- adpclust(clust3, centroids = "auto", draw = FALSE)
summary(ans)
plot(ans)

# Specify distm instead of data
distm &lt;- FindDistm(clust3, normalize = TRUE)
ans.distm &lt;- adpclust(distm = distm, p = 2, centroids = "auto", draw = FALSE)
identical(ans, ans.distm)

# Specify the grid of h and nclust
ans &lt;- adpclust(clust3, centroids = "auto", h = c(0.1, 0.2, 0.3), nclust = 2:6)

# Specify that bandwidths should be searched around
# Wand's Asymptotic-Mean-Integrated-Squared-Error bandwidth
# Also test 3 to 6 clusters.
ans &lt;- adpclust(clust3, centroids = "auto", htype = "AMISE", nclust = 3:6)

# Set a specific bandwidth value.
ans &lt;- adpclust(clust3, centroids = "auto", h = 5)

# Change method of automatic selection of centers
ans &lt;- adpclust(clust3, centroids = "auto", nclust = 2:6, ac = 2)

# Specify that the single "ROT" bandwidth value by
# using the 'ROT()' function
ans &lt;- adpclust(clust3, centroids = "auto", h = ROT(clust3))

# Centroids selected by user
## Not run: 
ans &lt;- adpclust(clust3, centroids = "user", h = ROT(clust3))

## End(Not run)

# A larger data set
data(clust5)
ans &lt;- adpclust(clust5, centroids = "auto", htype = "ROT", nclust = 3:5)
summary(ans)
plot(ans)
</code></pre>

<hr>
<h2 id='AMISE'>AMISE bandwidth</h2><span id='topic+AMISE'></span>

<h3>Description</h3>

<p>Calculate the AMISE bandwidth from either a data frame, or from the number of observations and the dimension of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMISE(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AMISE_+3A_x">x</code></td>
<td>
<p>the number of variables (if y is given), or a data frame or a matrix (if y is missing).</p>
</td></tr>
<tr><td><code id="AMISE_+3A_y">y</code></td>
<td>
<p>the number of observations. If y is missing then x is interpreted as the data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IMPORTANT NOTE: The standard deviation of each variable is omitted in this formula.
</p>


<h3>Value</h3>

<p>AMISE bandwidth.
</p>

<hr>
<h2 id='clust10'>1000 5-dimensional data points that form ten clusters</h2><span id='topic+clust10'></span>

<h3>Description</h3>

<p>Generated from the genRandomClust() function of the &quot;clusterGeneration&quot; package with separation value 0.2.
</p>


<h3>Format</h3>

<p>data frame</p>

<hr>
<h2 id='clust3'>90 2-dimensional data points that form three clusters</h2><span id='topic+clust3'></span>

<h3>Description</h3>

<p>Randomly generated from three normal distributions.
</p>


<h3>Format</h3>

<p>data frame</p>

<hr>
<h2 id='clust5'>500 5-dimensional data points that form five clusters</h2><span id='topic+clust5'></span>

<h3>Description</h3>

<p>500 5-dim points in 5 clusters. Generated from the genRandomClust() function of the &quot;clusterGeneration&quot; package with separation value 0.1.
</p>


<h3>Format</h3>

<p>data frame</p>

<hr>
<h2 id='clust5.1'>500 5-dimensional data points that form five clusters</h2><span id='topic+clust5.1'></span>

<h3>Description</h3>

<p>Generated from the genRandomClust() function of the &quot;clusterGeneration&quot; package with separation value 0.01 (tightly clustered).
</p>


<h3>Format</h3>

<p>data frame</p>

<hr>
<h2 id='dat_gene'>243-dimensional gene expression data of 38 patients (243 genes)</h2><span id='topic+dat_gene'></span>

<h3>Description</h3>

<p>38 by 243 matrix. Each row represents a patient. Each column represents a gene.
</p>


<h3>Format</h3>

<p>matrix</p>

<hr>
<h2 id='defCol'>Default colors</h2><span id='topic+defCol'></span>

<h3>Description</h3>

<p>Returns 10 default colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defCol()
</code></pre>


<h3>Value</h3>

<p>vector of colors
</p>

<hr>
<h2 id='FindCentersAutoD'>Automatically finds centers with diagonal f(x) vs delta(x) thresholds</h2><span id='topic+FindCentersAutoD'></span>

<h3>Description</h3>

<p>Automatically finds centers with diagonal f(x) vs delta(x) thresholds. This is used in adpclust() with ac = 2. It finds points that are above and farthest from the diagonal line in the f vs. delta plots, and label them to be centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindCentersAutoD(f, delta, nclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindCentersAutoD_+3A_f">f</code></td>
<td>
<p>vector of local distance.</p>
</td></tr>
<tr><td><code id="FindCentersAutoD_+3A_delta">delta</code></td>
<td>
<p>vector of minimal distances to higher ground.</p>
</td></tr>
<tr><td><code id="FindCentersAutoD_+3A_nclust">nclust</code></td>
<td>
<p>number of clusters. Can be a single integer or a vector of integers. Duplicates are silently removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vectors. Each vector gives the locations of centers.
</p>


<h3>Author(s)</h3>

<p>Ethan Xu
</p>

<hr>
<h2 id='FindCentersAutoV'>Automatically find centers with vertical threshold</h2><span id='topic+FindCentersAutoV'></span>

<h3>Description</h3>

<p>Automatically find centers with vertical threshold vertical f(x) thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindCentersAutoV(f, delta, f.cut = c(0.1, 0.2, 0.3), nclust, rm.dup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindCentersAutoV_+3A_f">f</code></td>
<td>
<p>vector of local distance f(x). See the detail section of the help(adpclust).</p>
</td></tr>
<tr><td><code id="FindCentersAutoV_+3A_delta">delta</code></td>
<td>
<p>vector of minimal distances to higher ground delta(x). See the detail section of the help(adpclust).</p>
</td></tr>
<tr><td><code id="FindCentersAutoV_+3A_f.cut">f.cut</code></td>
<td>
<p>number between (0, 1) or numeric vector of numbers between (0, 1). Data points whose f values are larger than f.cut with large delta values are selected as centers. The default is c(0.1, 0.2, 0.3).</p>
</td></tr>
<tr><td><code id="FindCentersAutoV_+3A_nclust">nclust</code></td>
<td>
<p>number of clusters. It can be either a single integer or a vector of integers.</p>
</td></tr>
<tr><td><code id="FindCentersAutoV_+3A_rm.dup">rm.dup</code></td>
<td>
<p>boolean. If TRUE (default) duplicated centers vectors are removed from returned list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given f's and delta's, cluster centers are chosen to be the data points whose delta values are high and f values are larger than a fixed threshold. To be more specific, let F denote the set of all f(x). centers are selected as points with the largest m delta values in the set x | f(x) &gt; a'th percentile of F. The number of centers m is given by the parameter nclust. The cutting percentile a is given by the parameter f.cut. When at least one of these two parameters are vectors, centers are selected based all combinations of them, and returned in a list.
</p>


<h3>Value</h3>

<p>a list of vectors. Each vector contains the indices of selected centers.
</p>


<h3>Author(s)</h3>

<p>Ethan Xu
</p>

<hr>
<h2 id='FindClustersAuto'>Automatically find cluster assignment given f and delta.</h2><span id='topic+FindClustersAuto'></span>

<h3>Description</h3>

<p>This is the subroutine that automatically finds cluster assignments from given f and delta by testing various parameter settings and find the one that maximizes the silhouette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindClustersAuto(distm, f, delta, ac = 1, nclust = 2:10, f.cut = c(0.1,
  0.2, 0.3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindClustersAuto_+3A_distm">distm</code></td>
<td>
<p>the distance matrix</p>
</td></tr>
<tr><td><code id="FindClustersAuto_+3A_f">f</code></td>
<td>
<p>vector of local distance f(x). See the help of adpclust() for details.</p>
</td></tr>
<tr><td><code id="FindClustersAuto_+3A_delta">delta</code></td>
<td>
<p>vector of minimal distances to higher ground delta(x). See the help of adpclust() for details.</p>
</td></tr>
<tr><td><code id="FindClustersAuto_+3A_ac">ac</code></td>
<td>
<p>type of auto selection. The valid options are 1 and 2. See the help of adpclust() for details.</p>
</td></tr>
<tr><td><code id="FindClustersAuto_+3A_nclust">nclust</code></td>
<td>
<p>number of clusters to test. Either a single integer or a vector of integers.</p>
</td></tr>
<tr><td><code id="FindClustersAuto_+3A_f.cut">f.cut</code></td>
<td>
<p>number between (0, 1) or numeric vector of numbers between (0, 1). Data points whose f values are larger than f.cut with large delta values are selected as centers. The default is c(0.1, 0.2, 0.3). See the help of FindCentersAutoV() for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of four elements: 
</p>

<ul>
<li><p>clusters Cluster assignments. A vector of the same length as the number of observations.
</p>
</li>
<li><p>centers: Indices of the clustering centers.
</p>
</li>
<li><p>silhouette: Silhouette score from the final clustering result.
</p>
</li>
<li><p>nclust: Number of clusters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ethan Xu
</p>

<hr>
<h2 id='FindClustersGivenCenters'>Find cluster assignments given centers and distance matrix</h2><span id='topic+FindClustersGivenCenters'></span>

<h3>Description</h3>

<p>Find cluster assignments from given centers and distance matrix. Each point is assigned to the center that has the shortest Euclidean distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindClustersGivenCenters(distm, centers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindClustersGivenCenters_+3A_distm">distm</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="FindClustersGivenCenters_+3A_centers">centers</code></td>
<td>
<p>vector of integers that gives the indices of centers. Duplications will be silently dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cluster assignments. A vector of the same length as the number of observations.
</p>

<hr>
<h2 id='FindClustersManual'>User-interactive routine to find clusters</h2><span id='topic+FindClustersManual'></span>

<h3>Description</h3>

<p>Plot the f vs. delta plot, then wait for the user to select centers of clusters by left clicking the points. In general points with both large f and large delta are good candidates of cluster centroids. Selected centers are highlighted. Press ESC to end the selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindClustersManual(distm, f, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindClustersManual_+3A_distm">distm</code></td>
<td>
<p>distance matrix.</p>
</td></tr>
<tr><td><code id="FindClustersManual_+3A_f">f</code></td>
<td>
<p>vector of local densities f(x). Same length of the number of observations.</p>
</td></tr>
<tr><td><code id="FindClustersManual_+3A_delta">delta</code></td>
<td>
<p>vector of distances to the closest high ground delta(x). Same length of the number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the following items:
</p>

<ul>
<li><p>clusters Cluster assignments. A vector of the same length as the number of observations.
</p>
</li>
<li><p>centers: Indices of the clustering centers.
</p>
</li>
<li><p>silhouette: Silhouette score from the final clustering result.
</p>
</li>
<li><p>nclust: Number of clusters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(clust3)
distm &lt;- FindDistm(clust3, normalize = TRUE)
## Not run: 
fd &lt;- FindFD(distm, 2, "mnorm")
ans &lt;- FindClustersManual(distm, fd$f, fd$delta)
names(ans)
ans$centers

## End(Not run)
</code></pre>

<hr>
<h2 id='FindDistm'>Find the distance matrix from data.</h2><span id='topic+FindDistm'></span>

<h3>Description</h3>

<p>A wrapper of the dist() method, with the option to rescale the data with standard deviation of each dimension before calculating the distance matrix. NOTE: If fdelta='mnorm' is passed to adpclust(), then the distm is calculated from rescaled data internally, i.e. distm &lt;- FindDistm(x, normalize = TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDistm(x, normalize = FALSE, method = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindDistm_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="FindDistm_+3A_normalize">normalize</code></td>
<td>
<p>boolean. Normalize data before calculating distance?</p>
</td></tr>
<tr><td><code id="FindDistm_+3A_method">method</code></td>
<td>
<p>passed to 'dist()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance matrix of class dist.
</p>


<h3>Author(s)</h3>

<p>Ethan Xu
</p>

<hr>
<h2 id='FindFD'>Find f and delta from distance matrix.</h2><span id='topic+FindFD'></span>

<h3>Description</h3>

<p>Calculate f(x) and delta(x) from distm and h.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindFD(distm, h, fdelta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindFD_+3A_distm">distm</code></td>
<td>
<p>distance matrix of class 'dist'.</p>
</td></tr>
<tr><td><code id="FindFD_+3A_h">h</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
<tr><td><code id="FindFD_+3A_fdelta">fdelta</code></td>
<td>
<p>character string that specifies the method used to estimate local density f(x) at each data point x. The default is &quot;mnorm&quot; that uses a multivariate Gaussian density estimation to calculate f. Other options are listed below. Here 'distm' denotes the distance matrix. 
</p>

<ul>
<li><p>unorm(f &lt;- 1/(h * sqrt(2 * pi)) * rowSums(exp(-(distm/h)^2/2))); Univariate Gaussian smoother
</p>
</li>
<li><p>weighted(f &lt;- rowSums(exp(-(distm/h)^2))); Univariate weighted smoother
</p>
</li>
<li><p>count(f &lt;- rowSums(distm &lt; h) - 1); Histogram estimator (used in Rodriguez [2014])
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two items: f and delta.
</p>

<hr>
<h2 id='FindH'>Find bandwidth h.</h2><span id='topic+FindH'></span>

<h3>Description</h3>

<p>Find bandwidth h from the number of observations n and the dimension p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindH(p, n, htype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindH_+3A_p">p</code></td>
<td>
<p>dimension of data. The number of variables.</p>
</td></tr>
<tr><td><code id="FindH_+3A_n">n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="FindH_+3A_htype">htype</code></td>
<td>
<p>methods to calculate h. The valid options are (case insensitive) &quot;amise&quot; or &quot;rot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bandwidth h.
</p>

<hr>
<h2 id='plot.adpclust'>Visualize the result of adpclust()</h2><span id='topic+plot.adpclust'></span>

<h3>Description</h3>

<p>Plot the f vs. delta plot with selected centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpclust'
plot(x, cols = "default", to.plot = c("cluster.sil",
  "fd"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.adpclust_+3A_x">x</code></td>
<td>
<p>an object of class &quot;adpclust&quot;. Result of adpclust().</p>
</td></tr>
<tr><td><code id="plot.adpclust_+3A_cols">cols</code></td>
<td>
<p>vector of colors used to distinguish different clusters. Recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot.adpclust_+3A_to.plot">to.plot</code></td>
<td>
<p>string vector that indicate which plot(s) to show. The two options are 'cluster.sil' (nclust vs. silhouette) and 'fd' (f vs. delta).</p>
</td></tr>
<tr><td><code id="plot.adpclust_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Load a data set with 3 clusters
data(clust3)
## Automatically select cluster centroids
ans &lt;- adpclust(clust3, centroids = "auto")
plot(ans)
plot(ans, to.plot = "fd")
plot(ans, to.plot = "cluster.sil")
plot(ans, to.plot = c("cluster.sil", "fd")) #Default
</code></pre>

<hr>
<h2 id='ROT'>Calculate ROT bandwidth</h2><span id='topic+ROT'></span>

<h3>Description</h3>

<p>Calculate the ROT bandwidth either from a data frame, or from p and n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROT(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROT_+3A_x">x</code></td>
<td>
<p>the number of variables (if y is missing), or a data frame or a matrix (if y is not missing).</p>
</td></tr>
<tr><td><code id="ROT_+3A_y">y</code></td>
<td>
<p>the number of observations. If y is missing, x should be the data matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IMPORTANT NOTE: The standard deviation of each variable is omitted in this formula.
</p>


<h3>Value</h3>

<p>ROT bandwidth.
</p>

<hr>
<h2 id='summary.adpclust'>Summary of adpclust</h2><span id='topic+summary.adpclust'></span>

<h3>Description</h3>

<p>Summarizes the result from the adpclust() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adpclust'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.adpclust_+3A_object">object</code></td>
<td>
<p>object of class &quot;adpclust&quot; that is returned from adpclust().</p>
</td></tr>
<tr><td><code id="summary.adpclust_+3A_...">...</code></td>
<td>
<p>other arguments. NOT used.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
