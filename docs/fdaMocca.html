<!DOCTYPE html><html><head><title>Help for package fdaMocca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdaMocca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fdaMocca-package'><p>Model-based clustering for functional data with covariates</p></a></li>
<li><a href='#criteria.mocca'><p> AIC, BIC, entropy for a functional clustering model</p></a></li>
<li><a href='#estimate.mocca'><p> Model parameter estimation</p></a></li>
<li><a href='#logLik.mocca'><p> Log-likelihood for a functional clustering model</p></a></li>
<li><a href='#mocca'><p>Model-based clustering for functional data with covariates</p></a></li>
<li><a href='#plot.mocca'><p>mocca plotting</p></a></li>
<li><a href='#print.mocca'><p>Print a mocca object</p></a></li>
<li><a href='#simdata'><p>Simulated data</p></a></li>
<li><a href='#summary.mocca'><p>Summary for a mocca fit</p></a></li>
<li><a href='#varve'><p>Varved sediment data from lake Kassjön</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalya Pya Arnqvist[aut, cre], 
        Per Arnqvist [aut, cre],
        Sara Sjöstedt de Luna [aut]    </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Natalya Pya Arnqvist &lt;nat.pya@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Model-Based Clustering for Functional Data with Covariates</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for model-based functional cluster analysis for functional data with optional covariates. The idea is to cluster functional subjects (often called functional objects) into homogenous groups by using spline smoothers (for functional data) together with scalar covariates. The spline coefficients and the covariates are modelled as a multivariate Gaussian mixture model, where the number of mixtures corresponds to the number of clusters. The parameters of the model are estimated by maximizing the observed mixture likelihood via an EM algorithm (Arnqvist and Sjöstedt de Luna, 2019) &lt;<a href="https://doi.org/10.48550/arXiv.1904.10265">doi:10.48550/arXiv.1904.10265</a>&gt;. The clustering method is used to analyze annual lake sediment from lake Kassjön (Northern Sweden) which cover more than 6400 years and can be seen as historical records of weather and climate.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, Matrix, parallel, foreach, doParallel,
mvtnorm, fda, grDevices</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-21 11:28:53 UTC; natalya</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-21 12:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='fdaMocca-package'>Model-based clustering for functional data with covariates
</h2><span id='topic+fdaMocca-package'></span>

<h3>Description</h3>

<p><code>fdaMocca</code> provides functions for model-based functional cluster analysis for functional data with optional covariates. The aim is to cluster a set of independent functional subjects (often called functional objects) into homogenous groups by using basis function representation of the functional data and allowing scalar covariates. A functional subject is defined as a curve and covariates. The spline coefficients and the (potential) covariates are modelled as a multivariate Gaussian mixture model, where the number of mixtures corresponds to the number of (predefined) clusters. The model allows for different cluster covariance structures for the basis coefficients and for the covariates. The parameters of the model are estimated by maximizing the observed mixture likelihood using an EM-type algorithm (Arnqvist and Sjöstedt de Luna, 2019).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> fdaMocca</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>

<p>Per Arnqvist, Sara Sjöstedt de Luna, Natalya Pya Arnqvist
</p>
<p>Maintainer: Natalya Pya Arnqvist&lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Arnqvist, P., Bigler, C., Renberg, I., Sjöstedt de Luna, S. (2016). Functional clustering of varved lake sediment to reconstruct past seasonal climate. <em>Environmental and Ecological Statistics</em>, <b>23</b>(4), 513&ndash;529.
</p>
<p>Abramowicz, K., Arnqvist, P., Secchi, P., Sjöstedt de Luna, S., Vantini, S., Vitelli, V. (2017). Clustering misaligned dependent curves applied to varved lake sediment for climate reconstruction. <em>Stochastic Environmental Research and Risk Assessment</em>. Volume <b>31.1</b>, 71&ndash;85.
</p>
<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>

<hr>
<h2 id='criteria.mocca'> AIC, BIC, entropy for a functional clustering model
</h2><span id='topic+criteria.mocca'></span>

<h3>Description</h3>

<p>Function to extract the information criteria AIC and BIC, as well as the average Shannon entropy over all functional objects, for a fitted functional clustering <code>mocca</code>. The Shannon entropy is computed over the posterior probability distribution of belonging to a specific cluster given the functional object (see Arnqvist and Sjöstedt de Luna, 2019, for further details).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  criteria.mocca(x)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="criteria.mocca_+3A_x">x</code></td>
<td>
<p>fitted model objects of class <code>mocca</code> as produced by <code>mocca()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with the AIC, BIC and Shannon entropy values of the fitted model. 
</p>


<h3>Author(s)</h3>

<p>Per Arnqvist
</p>


<h3>References</h3>

<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+logLik.mocca">logLik.mocca</a></code>, <code><a href="#topic+mocca">mocca</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples in mocca() 
</code></pre>

<hr>
<h2 id='estimate.mocca'> Model parameter estimation</h2><span id='topic+estimate.mocca'></span>

<h3>Description</h3>

<p>Function to estimate model parameters by maximizing the observed log likelihood via an EM algorithm. 
The estimation procedure is based on an algorithm proposed by James and Sugar (2003).
</p>
<p>The function is not normally called directly, but rather service routines for <code><a href="#topic+mocca">mocca</a></code>. See the description of the <code><a href="#topic+mocca">mocca</a></code> function for more detailed information of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.mocca(data,K=5,q=6,h=2,random=TRUE,B=NULL,svd=TRUE,
       use.covariates=FALSE,stand.cov=TRUE,index.cov=NULL,
       lambda=1.4e-4,EM.maxit=50, EMstep.tol=1e-8,Mstep.maxit=10,
       Mstep.tol=1e-4, EMplot=TRUE,trace=TRUE,n.cores=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.mocca_+3A_data">data</code></td>
<td>
<p>a list containing at least five objects (vectors) named as <code>x</code>, <code>time</code>, <code>timeindex</code>, <code>curve</code>, <code>grid</code>, <code>covariates</code> (optional). See <code><a href="#topic+mocca">mocca</a></code> for the detailed explanation of each object.</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_k">K</code></td>
<td>
<p>number of clusters (default: <code>K=3</code>).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_q">q</code></td>
<td>
<p>number of B-splines used to describe the individual curves. Evenly spaced knots are used (default: <code>q=6</code>). (currently only B-splines are implemented, however, it is possible  to use other basis functions such as, e.g. Fourier basis functions)</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_h">h</code></td>
<td>
<p>a positive integer, parameter vector dimension in low-dimensionality representation of the curves (spline coefficients).
<code class="reqn">h</code> should be less or equal to the number of clusters <code class="reqn">K</code> (default: <code>h=2</code>).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_random">random</code></td>
<td>
<p><code>TRUE/FALSE</code>,  if <code>TRUE</code> each subject is randomly assigned to one of the <code>K</code> clusters initially, otherwise <code>k-</code>means is used to initialize cluster belongings (default: TRUE).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_b">B</code></td>
<td>
<p> an <code class="reqn">N x q</code> matrix of spline coefficients,  the spline approximation of the yearly curves based on <code class="reqn">p</code> number of splines. If <code>B=NULL</code> (default), the coefficients are estimated using <code>fda:: create.bspline.basis</code>.</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_svd">svd</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether SVD decomposition should be used for the matrix of spline coefficients (default: TRUE).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_use.covariates">use.covariates</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether covariates should be included when modelling (default: FALSE).</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_stand.cov">stand.cov</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether covariates should be standardized when modelling (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_index.cov">index.cov</code></td>
<td>
<p>a vector of indices indicating which covariates should be used when modelling. If <code>NULL</code> (default) all present covariates are included.</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_lambda">lambda</code></td>
<td>
<p>a positive real number, smoothing parameter value to be used when estimating B-spline coefficients.</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_em.maxit">EM.maxit</code></td>
<td>
<p>a positive integer which gives the maximum number of iterations for a EM algorithm (default: EM.maxit=50).</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_emstep.tol">EMstep.tol</code></td>
<td>
<p>the tolerance to use within iterative procedure of the EM algorithm (default: EMstep.tol=1e-8).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_mstep.maxit">Mstep.maxit</code></td>
<td>
<p>a positive scalar which gives the maximum number of iterations for an inner loop of the parameter estimation in M step (default: Mstep.maxit=20).</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_mstep.tol">Mstep.tol</code></td>
<td>
<p>the tolerance to use within iterative procedure to estimate model parameters (default: Mstep.tol=1e-4).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_emplot">EMplot</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether plots of cluster means with some summary information should be produced at each iteration of the EM algorithm (default: FALSE).</p>
</td></tr> 
<tr><td><code id="estimate.mocca_+3A_trace">trace</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether to print the current values of <code class="reqn">\sigma^2</code> and <code class="reqn">\sigma^2_x</code> of the covariates at each iteration of <code>M step</code>  (default: TRUE).</p>
</td></tr>
<tr><td><code id="estimate.mocca_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to be used with parallel computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the following items:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>the maximized log likelihood value.</p>
</td></tr> 
<tr><td><code>sig2</code></td>
<td>
<p>estimated residual variance for the spline coefficients (for the model without covariates), or a vector of the estimated residual variances for the spline coefficients and for the covariates (for the model with covariates).</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>indicates why the EM algorithm terminated:
</p>
<p>0: indicates successful completion.
</p>
<p>1: indicates that the iteration limit <code>EM.maxit</code> has been reached.
</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>number of iterations of the EM algorithm taken to get convergence.</p>
</td></tr>
<tr><td><code>score.hist</code></td>
<td>
<p>a matrix of the succesive values of the scores: residual variances and log likelihood, up until convergence.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list containing all the estimated parameters: <code class="reqn">\bm\lambda_0</code>, <code class="reqn">\bm\Lambda</code>, <code class="reqn">\bm\alpha_k</code>, <code class="reqn">\bm\Gamma_k</code> (or <code class="reqn">\bm\Delta_k</code> in presence of covariates), <code class="reqn">\pi_k</code> (probabilities of cluster belongnings), <code class="reqn">\sigma^2_x</code> (residual variance for the covariates if present), <code class="reqn">\mathbf{v}_k</code> (mean values of the covariates for each cluster, in presence of covariates), <code class="reqn">k=1,..., K</code>, where <code class="reqn">K</code> is the number of clusters.</p>
</td></tr> 
<tr><td><code>vars</code></td>
<td>
<p>a list containing results from the E step of the algorithm: the posterior probabilities for each subject <code class="reqn">\pi_{k|i}</code>'s, the expected values of the <code class="reqn">\bm\gamma_i</code>'s, <code class="reqn">\bm\gamma_i\bm\gamma_i^T</code>, and the covariance matrix of <code class="reqn">\bm\gamma_i</code> given cluster membership and the observed values of the curve. See Arnqvist and Sjöstedt de Luna (2019) that explains these values.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing all the original data plus re-arranged functional data and covariates (if supplied) needed for EM-steps.</p>
</td></tr> 
<tr><td><code>design</code></td>
<td>
<p>a list of spline basis matrices with and without covariates: 
<code>FullS.bmat</code> is the spline basis matrix <code class="reqn">\mathbf{S}</code> computed on the grid of uniquily specified time points; 
<code>FullS</code> is the spline basis matrix <code>FullS.bmat</code> or <code class="reqn">\mathbf U</code> matrix from the svd of <code>FullS</code> (if applied);
<code class="reqn">\mathbf{S}</code> is the spline basis matrix computed on <code>timeindex</code>, a vector of time indices from <code class="reqn">T</code> possible from <code>grid</code>;
the inverse <code class="reqn">(\mathbf{S}^T\mathbf{S})^{-1}</code>;
<code>tag.S</code> is the matrix <code class="reqn">\mathbf{S}</code> with covariates; 
<code>tag.FullS</code> is the matrix <code>FullS</code> with covariates. 
</p>
</td></tr>
<tr><td><code>initials</code></td>
<td>
<p>a list of initial settings: <code class="reqn">q</code> is the spline basis dimension, <code class="reqn">N</code> is the number of objects/curves, <code class="reqn">Q</code> is the number of basis dimension plus the number of covariates (if present), <code class="reqn">random</code> is whether k-means was used to initialize cluster belonings, <code class="reqn">h</code> is the vector dimension in low-dimensionality representation of the curves, <code class="reqn">K</code> is the number of clusters,  <code class="reqn">r</code> is the number of scalar covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Per Arnqvist, Natalya Pya Arnqvist, Sara Sjöstedt de Luna
</p>


<h3>References</h3>

<p>James, G.M., Sugar, C.A. (2003). Clustering for sparsely sampled functional data.  <em>Journal of the American Statistical Association</em>, 98.462, 397&ndash;408.
</p>
<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdaMocca-package">fdaMocca-package</a></code>, <code><a href="#topic+mocca">mocca</a></code>
</p>

<hr>
<h2 id='logLik.mocca'> Log-likelihood for a functional clustering model
</h2><span id='topic+logLik.mocca'></span>

<h3>Description</h3>

<p>Function to extract the log-likelihood for a fitted functional clustering <code>mocca</code>
model (fitted by mixture likelihood maximization). 
</p>
<p>Note: <code>estimate.mocca</code> uses <code>loglik.EMmocca()</code> for calculating the log likelihood at each iterative step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mocca'
logLik(object,...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="logLik.mocca_+3A_object">object</code></td>
<td>
<p>fitted model objects of class <code>mocca</code> as produced by <code>mocca()</code>.</p>
</td></tr>
<tr><td><code id="logLik.mocca_+3A_...">...</code></td>
<td>
<p>unused in this case</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The log-likehood value as <code>logLik</code> object. 
</p>


<h3>Author(s)</h3>

<p>Per Arnqvist
</p>


<h3>References</h3>

<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+estimate.mocca">estimate.mocca</a></code>, <code><a href="#topic+mocca">mocca</a></code> 
</p>

<hr>
<h2 id='mocca'>Model-based clustering for functional data with covariates</h2><span id='topic+mocca'></span>

<h3>Description</h3>

<p>This function fits a functional clustering model to observed independent functional subjects, where a functional subject consists of a function and possibly a set of covariates. Here, each curve is projected onto a finite dimensional basis and clustering is done on the resulting basis coefficients. However, rather than treating basis coefficients as parameters, mixed effect modelling is used for the coefficients. In the model-based functional clustering approach the functional subjects (i.e. the spline/basis coefficients and the potential covariates) are assumed to follow a multivariate Gaussian mixture model, where the number of distributions in the mixture model corresponds to the number of (predefined) clusters, <code class="reqn">K</code>. Given that a functional subject belongs to a cluster <code class="reqn">k</code>, the basis coefficients and covariate values are normally distributed with a cluster-specific mean and covariance structure. 
</p>
<p>An EM-style algorithm based on James and Sugar (2003) is implemented to fit the Gaussian mixture model for a prespecified number of clusters <code>K</code>. The model allows for different cluster covariance structure for the spline coefficients and model coefficients for the covariates. See Arnqvist and Sjöstedt de Luna (2019) for details about differences to the clustering model and its implementation. 
</p>
<p>The routine calls <code>estimate.mocca</code> for the model fitting. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mocca(data=stop("No data supplied"), K = 5, q = 6, h = 2,
     use.covariates=FALSE,stand.cov=TRUE,index.cov=NULL,
     random=TRUE, B=NULL,svd=TRUE,lambda=1.4e-4, EM.maxit=50, 
     EMstep.tol=1e-6,Mstep.maxit=20,Mstep.tol=1e-4,EMplot=TRUE,
     trace=FALSE,n.cores=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mocca_+3A_data">data</code></td>
<td>
<p>a list containing at least three objects (vectors) named as <code>x</code>, <code>time</code>, <code>curve</code>, and optional <code>timeindex</code>, <code>grid</code> and <code>covariates</code>:
</p>
<p>i) suppose we observe <code class="reqn">N</code> independent subjects, each consisting of a curve and potentially a set of scalar covariates, where the <code class="reqn">i^{th}</code> curve has been observed at <code class="reqn">n_i</code> different time points, <code class="reqn">i=1,...,N</code>. <code>x</code> is a vector of length <code class="reqn">\sum_{i=1}^N n_i</code> with the first <code class="reqn">n_1</code> elements representing the observations of the first curve, followed by <code class="reqn">n_2</code> observations of the second curve, etc;
</p>
<p>ii)  <code>time</code> is a <code class="reqn">\sum_i n_i</code> vector of the concatenated time points for each curve <code class="reqn">(t_{ij}, j=1,...,n_i, i=1,...,N)</code>, with the first <code class="reqn">n_1</code> elements being the time points at which the first curve is observed, etc. Often, the time points within each curve are scaled to <code class="reqn">[0,1]</code>. 
</p>
<p>iii) <code>timeindex</code> is a <code class="reqn">\sum_i n_i</code> vector of time indices from <code class="reqn">T</code> possible from <code>grid</code>. So each observation has a corresponding location (time index) within <code class="reqn">[0,1]</code> uniquely specified time points. If not supplied, obtained from <code>time</code> and <code>grid</code>;
</p>
<p>iv)  <code>curve</code> is a <code class="reqn">\sum_i n_i</code> vector of integers from <code class="reqn">1,..., N</code>, specifying the subject number for each observation in <code>x</code>;
</p>
<p>v)  <code>grid</code> is a <code class="reqn">T</code> vector of all unique time points (values within <code class="reqn">[0,1]</code> interval) for all <code class="reqn">N</code> subjects, needed for estimation of the B-spline coefficients in <code>fda::eval.basis()</code>. <code>timeindex</code> and <code>grid</code> together give the timepoint for each subject (curve). If not supplied, obtained from <code>time</code>.
</p>
<p>vi) if supplied, <code>covariates</code> is an <code class="reqn">N \times r</code> matrix (or data frame) of scalar covariates (finite-dimensional covariates).
</p>
</td></tr> 
<tr><td><code id="mocca_+3A_k">K</code></td>
<td>
<p>number of clusters (default: <code>K=3</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_q">q</code></td>
<td>
<p>number of B-splines for the individual curves. Evenly spaced knots are used (default: <code>q=6</code>).</p>
</td></tr> 
<tr><td><code id="mocca_+3A_h">h</code></td>
<td>
<p>a positive integer, parameter vector dimension in the low-dimensionality representation of the curves (spline coefficients).
<code class="reqn">h</code> should be smaller than the number of clusters <code class="reqn">K</code> (default: <code>h=2</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_use.covariates">use.covariates</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether covariates should be used when modelling (default: <code>FALSE</code>).</p>
</td></tr> 
<tr><td><code id="mocca_+3A_stand.cov">stand.cov</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether covariates should be standardized when modelling (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_index.cov">index.cov</code></td>
<td>
<p>a vector of indices indicating which covariates should be used when modelling. If <code>NULL</code> (default) all present covariates are included.</p>
</td></tr>
<tr><td><code id="mocca_+3A_random">random</code></td>
<td>
<p><code>TRUE/FALSE</code>,  if <code>TRUE</code> the initial cluster belongings is given by uniform distribution, otherwise <code>k-</code>means is used to initialize cluster belongings (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_b">B</code></td>
<td>
<p> an <code class="reqn">N \times q</code> matrix of spline coefficients,  the spline approximation of the yearly curves based on <code class="reqn">p</code> number of splines. If <code>B=NULL</code> (default), the coefficients are estimated using <code>fda:: create.bspline.basis</code>.</p>
</td></tr> 
<tr><td><code id="mocca_+3A_svd">svd</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether SVD decomposition should be used for the matrix of spline coefficients (default: <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_lambda">lambda</code></td>
<td>
<p>a positive real number, smoothing parameter value to be used when estimating B-spline coefficients.</p>
</td></tr>
<tr><td><code id="mocca_+3A_em.maxit">EM.maxit</code></td>
<td>
<p>a positive integer which gives the maximum number of iterations for a EM algorithm (default:
<code>EM.maxit=50</code>).</p>
</td></tr> 
<tr><td><code id="mocca_+3A_emstep.tol">EMstep.tol</code></td>
<td>
<p>the tolerance to use within iterative procedure of the EM algorithm (default: <code>EMstep.tol=1e-8</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_mstep.maxit">Mstep.maxit</code></td>
<td>
<p>a positive scalar which gives the maximum number of iterations for an inner loop of the parameter estimation in M step (default: <code>Mstep.maxit=20</code>).</p>
</td></tr> 
<tr><td><code id="mocca_+3A_mstep.tol">Mstep.tol</code></td>
<td>
<p>the tolerance to use within iterative procedure to estimate model parameters (default: Mstep.tol=1e-4).</p>
</td></tr>
<tr><td><code id="mocca_+3A_emplot">EMplot</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether plots of cluster means with some summary information should be produced at each iteration of the EM algorithm (default: <code>TRUE</code>).</p>
</td></tr> 
<tr><td><code id="mocca_+3A_trace">trace</code></td>
<td>
<p><code>TRUE/FALSE</code>, whether to print the current values of <code class="reqn">\sigma^2</code> and <code class="reqn">\sigma^2_x</code> for the covariates at each iteration of <code>M step</code>  (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mocca_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to be used with parallel computing. If <code>NULL</code> (default) <code>n.cores</code> is set to the  numbers of available cores - 1 (<code>n.cores= detectCores()-1</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A model-based clustering with covariates (mocca) for the functional subjects (curves and potentially covariates) is a gaussian mixture model with <code class="reqn">K</code> components. 
Let <code class="reqn">g_i(t)</code> be the true function (curve) of the <code class="reqn">i^{th}</code> subject, for a set of <code class="reqn">N</code> independent subjects. Assume that for each subject we have a vector of observed values of the function <code class="reqn">g_i(t)</code> at times <code class="reqn">t_{i1},...,t_{in_i},</code> obtained with some measurement errors. We are interested in clustering the subjects into <code class="reqn">K</code> (homogenous) groups. Let <code class="reqn">y_{ij}</code> be the observed value of the <code class="reqn">i</code>th curve at time point <code class="reqn">t_{ij}</code>. Then  
</p>
<p style="text-align: center;"><code class="reqn">
y_{ij} = g_i(t_{ij})+ \epsilon_{ij},  i=1,...,N, j=1,...,n_i,</code>
</p>

<p>where <code class="reqn">\epsilon_{ij}</code> are assumed to be independent and normally distributed measurement errors
with mean <code class="reqn">0</code> and variance <code class="reqn">\sigma^2</code>. Let <code class="reqn">\mathbf{y}_i</code>, <code class="reqn">\mathbf{g}_i,</code> and <code class="reqn">\boldsymbol{\epsilon}_i</code> be the <code class="reqn">n_i</code>-dimensional vectors for subject <code class="reqn">i</code>, corresponding to the observed values, true values and measurement errors, respectively. Then, in matrix notation, the above could be written as 
</p>
<p style="text-align: center;"><code class="reqn">
 \mathbf{y}_i=\mathbf{g}_i+\boldsymbol{\epsilon}_i, ~~~~i=1,\ldots, N,
</code>
</p>

<p>where <code class="reqn">\boldsymbol{\epsilon}_i ~\sim ~ N_{n_i}(\mathbf{0},\sigma^2 \mathbf{I}_{n_i}).</code> 
We further assume that the smooth function <code class="reqn">g_i(t)</code> can be expressed as
</p>
<p style="text-align: center;"><code class="reqn"> 
g_i(t) = \boldsymbol{\phi}^T(t) \boldsymbol{\eta}_i,
</code>
</p>

<p>where <code class="reqn">\boldsymbol{\phi}(t)=\left(\phi_{1}(t),\ldots,\phi_{p}(t)\right)^T</code> 
is a <code class="reqn">p</code>-dimensional vector of known basis functions evaluated at time t, e.g. B-splines, and <code class="reqn">\boldsymbol{\eta}_i</code> a <code class="reqn">p</code>-dimensional vector of unknown (random) coefficients. The <code class="reqn">\boldsymbol{\eta}_i</code>'s are modelled as
</p>
<p style="text-align: center;"><code class="reqn">
\boldsymbol{\eta}_i = \boldsymbol{\mu}_{z_i} + \boldsymbol{\gamma}_i, ~~~ \boldsymbol{\eta}_i ~ \sim ~ N_p(\boldsymbol{\mu}_{z_i},\bm{\Gamma}_{z_i}),
</code>
</p>

<p>where <code class="reqn">\boldsymbol{\mu}_{z_i}</code> is a vector of expected spline coefficients for a cluster <code class="reqn">k</code> and <code class="reqn">z_i</code> denotes the unknown cluster membership, with <code class="reqn">P(z_i=k)=\pi_k</code>,  <code class="reqn">k=1,\ldots,K</code>. The random vector <code class="reqn">\boldsymbol{\gamma}_i</code> corresponds to subject-specific within-cluster variability.
Note that this variability is allowed to be different in different clusters, due to <code class="reqn">\bm\Gamma_{z_i}</code>. If desirable, given that subject <code class="reqn">i</code> belongs to cluster <code class="reqn">z_i=k</code>, a further parametrization of <code class="reqn">\boldsymbol{\mu}_{k},~~ k=1,\ldots,K,</code> may prove useful, for producing low-dimensional representations of the curves as suggested by James and Sugar (2003):
</p>
<p style="text-align: center;"><code class="reqn">
\bm\mu_k = \bm\lambda_0+ \bm\Lambda \bm\alpha_k,
</code>
</p>

<p>where <code class="reqn">\bm\lambda_0</code> and <code class="reqn">\bm\alpha_k</code> are <code class="reqn">p</code>- and <code class="reqn">h</code>-dimensional vectors respectively, and <code class="reqn">\bm\Lambda</code> is a <code class="reqn">p \times h</code> matrix with <code class="reqn">h \leq K-1</code>. Choosing <code class="reqn">h&lt;K-1</code> may be valuable, especially for sparse data. In order to ensure identifiability, some restrictions need to be put on the parameters. Imposing the restriction that <code class="reqn">\sum_{k=1}^K \bm\alpha_k=\mathbf{0}</code> implies that <code class="reqn">\bm\phi^T(t)\bm\lambda_0</code> can be viewed as the overall mean curve. Depending on the choice of <code class="reqn">h,p</code> and <code class="reqn">K</code>, further restrictions may need to be imposed in order to have identifiability of the parameters (<code class="reqn">\bm\lambda_0, \bm\Gamma</code> and <code class="reqn">\bm\alpha_k</code> are confounded if no restrictions are imposed).
In vector-notation we thus have
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{y}_i = \mathbf{B}_i(\bm\lambda_0 +  \bm\Lambda\bm\alpha_{z_i}+\bm\gamma_i)+\bm\epsilon_i,~~ i=1,...,N,
</code>
</p>

<p>where <code class="reqn">\mathbf{B}_i</code> is an <code class="reqn">n_i \times p</code> matrix with <code class="reqn">\bm\phi^T(t_{ij})</code> on the <code class="reqn">j^\textrm{th}</code> row, <code class="reqn">j=1,\ldots,n_i.</code>
We will also assume that the <code class="reqn">\bm\gamma_i</code>'s, <code class="reqn">\bm\epsilon_i</code>'s and the <code class="reqn">z_i</code>'s are independent. Hence, given that subject <code class="reqn">i</code> belongs to cluster <code class="reqn">z_i=k</code> we have
</p>
<p style="text-align: center;"><code class="reqn">
\mathbf{y}_i | z_i=k ~~\sim ~~ N_{n_i}\left(\mathbf{B}_i(\bm\lambda_0 +  \bm\Lambda \bm\alpha_k), ~~\mathbf{B}_i \bm\Gamma_k \mathbf{B}_i^T+ \sigma^2\mathbf{I}_{n_i}\right).
</code>
</p>

<p>Based on the observed data <code class="reqn">\mathbf{y}_1,\ldots,\mathbf{y}_N</code>, the parameters <code class="reqn">\bm\theta</code>
of the model can be estimated by maximizing the observed likelihood
</p>
<p style="text-align: center;"><code class="reqn">
L_o(\bm\theta|\mathbf{y}_1,\ldots,\mathbf{y}_N)=\prod_{i=1}^N \sum_{k=1}^G \pi_k f_k(\mathbf{y}_i,\bm\theta),
</code>
</p>

<p>where
<code class="reqn">\bm\theta = \left\{\bm\lambda_0,\bm\Lambda,\bm\alpha_1,\ldots,\bm\alpha_K,\pi_1,\ldots,\pi_K,\sigma^2,\bm\Gamma_1,\ldots,\bm\Gamma_K\right\},</code>
and <code class="reqn">f_k(\mathbf{y}_i,\bm\theta)</code> is the normal density given above. Note that here <code class="reqn">\bm\theta</code> will denote all scalar, vectors and matrices of parameters to be estimated. An EM-type algorithm is used to maximize the likelihood above.
</p>
<p>If additional covariates  have been observed for each subject besides the curves, they can also be included in the model when clustering the subjects. Given that the subject <code class="reqn">i</code> belongs to cluster <code class="reqn">k, (z_{i}=k)</code> the <code class="reqn">r</code> covariates <code class="reqn">\boldsymbol{x}_i \in \mathbf{R}^r</code> are assumed to have mean value <code class="reqn">\boldsymbol{\upsilon}_k</code> and moreover <code class="reqn">\boldsymbol{x}_{i} = \boldsymbol{\upsilon}_{k} + \boldsymbol{\delta}_{i} + \boldsymbol{e}_i,</code>
where we assume that <code class="reqn">\boldsymbol{\delta}_{i}|z_{i}=k \sim N_r(\boldsymbol{0}, \mathbf{D}_k)</code> is the random deviation within cluster and <code class="reqn">\boldsymbol{e}_i \sim N_r(\boldsymbol{0},\sigma_x^2 \mathbf{I}_r)</code> independent remaining unexplained variability. 
Note that this model also incorporates the dependence between covariates and the random curves via the random basis coefficients. See Arnqvist and Sjöstedt de Luna (2019) for further details.
EM-algorithm is implemented to maximize the mixture likelihood.
</p>
<p>The method is applied to annually varved lake sediment data from the lake Kassjön in Northern Sweden. See an example and also <code><a href="#topic+varve">varve</a></code> for the data description.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>"mocca"</code> with the following elements:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>the maximized log likelihood value.</p>
</td></tr> 
<tr><td><code>sig2</code></td>
<td>
<p>estimated residual variance for the functional data (for the model without covariates), or a vector of the estimated residual variances for the functional data and for the covariates (for the model with covariates).</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>indicates why the EM algorithm terminated:
</p>
<p>0: indicates successful completion.
</p>
<p>1: indicates that the iteration limit <code>EM.maxit</code> has been reached.
</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>number of iterations of the EM algorithm taken to get convergence.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of subjects/curves.</p>
</td></tr>
<tr><td><code>score.hist</code></td>
<td>
<p>a matrix of the succesive values of the scores, residual variances and log likelihood, up until convergence.</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>a list containing all the estimated parameters: <code class="reqn">\bm\lambda_0</code>, <code class="reqn">\bm\Lambda</code>, <code class="reqn">\bm\alpha_k</code>, <code class="reqn">\bm\Gamma_k</code> (or <code class="reqn">\bm\Delta_k</code> in presence of the covariates), <code class="reqn">\pi_k</code> (probabilities of cluster belongnings), <code class="reqn">\sigma^2</code>, <code class="reqn">\sigma^2_x</code> (residual variance for the covariates if present), <code class="reqn">\mathbf{v}_k</code> (mean values of the covariates for each cluster).</p>
</td></tr> 
<tr><td><code>vars</code></td>
<td>
<p>a list containing results from the E step of the algorithm: the posterior probabilities for each subject <code class="reqn">\pi_{k|i}</code>'s, the expected values of the <code class="reqn">\bm\gamma_i</code>'s, <code class="reqn">\bm\gamma_i\bm\gamma_i^T</code>, and the covariance matrix of <code class="reqn">\bm\gamma_i</code> given cluster membership and the observed values of the curve. See Arnqvist and Sjöstedt de Luna (2019) that explains these values.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing all the original data plus re-arranged functional data and covariates (if supplied).</p>
</td></tr> 
<tr><td><code>design</code></td>
<td>
<p>a list of spline basis matrices with and without covariates: 
<code>FullS.bmat</code> is the spline basis matrix <code class="reqn">\mathbf{S}</code> computed on the grid of uniquily specified time points; 
<code>FullS</code> is the spline basis matrix <code>FullS.bmat</code> or <code class="reqn">\mathbf U</code> matrix from the svd of <code>FullS</code> (if applied);
<code class="reqn">\mathbf{S}</code> is the spline basis matrix computed on <code>timeindex</code>, a vector of time indices from <code class="reqn">T</code> possible from <code>grid</code>;
the inverse <code class="reqn">(\mathbf{S}^T\mathbf{S})^{-1}</code>;
<code>tag.S</code> is the matrix <code class="reqn">\mathbf{S}</code> with covariates; 
<code>tag.FullS</code> is the matrix <code>FullS</code> with covariates. See Arnqvist and Sjöstedt de Luna (2019) for further details.
</p>
</td></tr>
<tr><td><code>initials</code></td>
<td>
<p>a list of initial settings: <code class="reqn">q</code> is the spline basis dimension, <code class="reqn">N</code> is the number of subjects/curves, <code class="reqn">Q</code> is the number of basis dimension plus the number of covariates (if present), <code class="reqn">random</code> is whether k-means was used to initialize cluster belonings, <code class="reqn">h</code> is the vector dimension in low-dimensionality representation of the curves, <code class="reqn">K</code> is the number of clusters,  <code class="reqn">r</code> is the number of scalar covariates, <code class="reqn">moc</code> TRUE/FALSE signaling if the model includes covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Per Arnqvist, Natalya Pya Arnqvist, Sara Sjöstedt de Luna
</p>


<h3>References</h3>

<p>Arnqvist, P., Bigler, C., Renberg, I., Sjöstedt de Luna, S. (2016). Functional clustering of varved lake sediment to reconstruct past seasonal climate. <em>Environmental and Ecological Statistics</em>, <b>23</b>(4), 513&ndash;529.
</p>
<p>Abramowicz, K., Arnqvist, P., Secchi, P., Sjöstedt de Luna, S., Vantini, S., Vitelli, V. (2017). Clustering misaligned dependent curves applied to varved lake sediment for climate reconstruction. <em>Stochastic Environmental Research and Risk Assessment</em>. Volume <b>31.1</b>, 71&ndash;85.
</p>
<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>
<p>James, G.M., Sugar, C.A. (2003). Clustering for sparsely sampled functional data.  <em>Journal of the American Statistical Association</em>, 98.462, 397&ndash;408.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdaMocca-package">fdaMocca-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## example with lake sediment data from lake Kassjön...
library(fdaMocca)
data(varve) ## reduced data set

## run without covariates...
m &lt;- mocca(data=varve,K=3,n.cores=2)
m
## some summary information...
summary(m)
criteria.mocca(m)
AIC(m)
BIC(m)
## various plots...
plot(m)
plot(m,select=2)
plot(m,type=2,years=c(-750:750)) 
plot(m,type=2,probs=TRUE,pts=TRUE,years=c(-750:750)) 
plot(m,type=2,pts=TRUE,select=c(3,1),years=c(-750:750))
plot(m,type=3)
plot(m,type=3,covariance=FALSE)


## model with two covariates...
## note, it takes some time to analyze the data...
m1 &lt;- mocca(data=varve, use.covariates=TRUE,index.cov=c(2,3), K=3,n.cores=2)
m1
## summary information...
summary(m1)
criteria.mocca(m1)
## various plots...
plot(m1)
plot(m1,type=2,pts=TRUE,years=c(-750:750)) 
plot(m1,type=3)
plot(m1,type=3,covariance=FALSE)
plot(m1,type=3,covariates=TRUE)

## simple simulated data...
data(simdata)
set.seed(2)
m2 &lt;- mocca(data=simdata,K=2,q=8,h=1,lambda=1e-10,n.cores=2,EMstep.tol=1e-3)
summary(m2)
criteria.mocca(m2)
plot(m2)
plot(m2,select=2)


## even simpler simulated data
##(reduced from 'simdata', EMstep.tol set high, q lower to allow automatic testing)...
library(fdaMocca)
data(simdata0)
set.seed(2)
m3 &lt;- mocca(data=simdata0,K=2,q=5,h=1,lambda=1e-10,n.cores=2,EMstep.tol=.5,
      EMplot=FALSE,B=simdata0$B)
summary(m3)
#plot(m3)
#plot(m3,select=2))
 
</code></pre>

<hr>
<h2 id='plot.mocca'>mocca plotting
</h2><span id='topic+plot.mocca'></span>

<h3>Description</h3>

<p>The function
takes a <code>mocca</code> object produced by <code>mocca()</code> and creates cluster means plots or covariance structure within each cluster.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mocca'
plot(x,type=1, select =NULL,transform=FALSE,covariance=TRUE,
    covariates =FALSE,lwd=2,ylab="",xlab="",main="",ylim=NULL,
    ncolors=NULL,probs=FALSE,pts=FALSE,size=50,
    years=NULL, years.names=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mocca_+3A_x">x</code></td>
<td>
<p> a <code>mocca</code> object as produced by <code>mocca()</code>.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_type">type</code></td>
<td>
<p>determines what type of plots to print. For <code>type=1</code> (default) cluster mean curves are shown in one plot on one page together with the overall mean curve; <code>type=2</code> produces the trend of the frequencies of the different clusters, together with mean probabilites (if <code>probs=TRUE</code>), the mean value of the included covariates (if present) within each cluster (not the model estimated covariate values) are also shown, if <code>pts=TRUE</code> points of the frequency trend are plotted, cluster means are shown on separate plots; <code>type=3</code> illustrates the covariance (or correlation) structure within each cluster. <code>type=2</code> is used with annual data.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_select">select</code></td>
<td>
<p>allows the plot for a single cluster mean to be selected for printing with <code>type=1</code> or <code>type=2</code>. it can also be the order of the cluster means to be printed. If <code>NULL</code> (default), the cluster mean curves are in <code>{1,2,...,K}</code> order, where <code>K</code> is the number of clusters.  If you just want the plot for the cluster mean of the second cluster set <code>select=2</code>.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_transform">transform</code></td>
<td>
<p>logical, informs whether svd back-transformation of the spline model matrix should be applied (see Arnqvist and Sjöstedt de Luna, 2019).</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_covariance">covariance</code></td>
<td>
<p>logical, informs whether covariance (<code>TRUE</code>) or correlation (<code>FALSE</code>) matrices should be plotted</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_covariates">covariates</code></td>
<td>
<p>logical, informs whether covariates should be added when printing the covariance structure of the spline coefficients</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_lwd">lwd</code></td>
<td>
<p>defines the line width.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_ylab">ylab</code></td>
<td>
<p>If supplied then this will be used as the <code>y</code> label for all plots.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_xlab">xlab</code></td>
<td>
<p>If supplied then this will be used as the <code>x</code> label for all plots.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_main">main</code></td>
<td>
<p>Used as title for plots if supplied.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_ylim">ylim</code></td>
<td>
<p>If supplied then this pair of numbers are used as the <code>y</code> limits for each plot. Default <code>ylim=c(-45, 55)</code>.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_ncolors">ncolors</code></td>
<td>
<p>defines the number of colors (<code class="reqn">\geq 1</code>) to be in the palette, used with the <code>rainbow()</code> function. 
If <code>NULL</code> (default), <code>ncolors</code> equals the number of clusters <code>K</code>.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_probs">probs</code></td>
<td>
<p>logical, used with <code>type=2</code>, informs whether the mean probabilites should be printed.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_pts">pts</code></td>
<td>
<p>logical, used with <code>type=2</code>, if <code>TRUE</code> (default) points of the frequency trend are shown.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_size">size</code></td>
<td>
<p>the bin size used with <code>type=2</code> (default: 50 years), the bin size of how many of those years belong to a specific cluster.</p>
</td></tr>


<tr><td><code id="plot.mocca_+3A_years">years</code></td>
<td>
<p>a vector of years used with annual data and needed for <code>type=2</code> plot to calculate frequencies in the bins of size provided by the <code>size</code> argument.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_years.names">years.names</code></td>
<td>
<p>a character vector that gives names of the years needed for <code>type=2</code> plot. This can be also supplied with <code>data</code>. With <code>varve</code> data <code>years.names</code> are supplied as rownames of the matrix of covariates. if <code>years.names=NULL</code> (default) then <code>years</code> are converted to the character vector and used as <code>years.names</code>.</p>
</td></tr>
<tr><td><code id="plot.mocca_+3A_...">...</code></td>
<td>
<p> other graphics parameters to pass on to plotting commands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function generates plots.
</p>


<h3>Author(s)</h3>

<p>Per Arnqvist, Sara Sjöstedt de Luna,  Natalya Pya Arnqvist
</p>


<h3>References</h3>

<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+mocca">mocca</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?mocca help files
</code></pre>

<hr>
<h2 id='print.mocca'>Print a mocca object</h2><span id='topic+print.mocca'></span>

<h3>Description</h3>

<p> The default print method for a <code>mocca</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mocca'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="print.mocca_+3A_x">x</code>, <code id="print.mocca_+3A_...">...</code></td>
<td>
<p> fitted model objects of class <code>mocca</code> as produced by <code>mocca()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Prints out whether the model is fitted with or without covariates, the number of clusters, the estimated residual variance for the functional data and for the scalar covariates (if present), the number of covariates (if present), the maximized value of the log likelihood, and the number of subjects/curves.
</p>


<h3>Value</h3>

<p> No return value, the function prints out several fitted results.
</p>


<h3>Author(s)</h3>

<p>Per Arnqvist, Natalya Pya Arnqvist, Sara Sjöstedt de Luna
</p>

<hr>
<h2 id='simdata'>Simulated data</h2><span id='topic+simdata'></span><span id='topic+simdata0'></span>

<h3>Description</h3>

<p><code>simdata</code> is a simple test data set simulated from two clusters and consisting of 100 curves, with 50 curves belonging to one cluster and 50 to another. The test data set is a copy of the <code>simdata</code> of James and Sugar (2003).
</p>


<h3>Format</h3>

 <p><code>simdata</code> is a list of three vectors called as <code>x</code>, <code>curve</code> and <code>time</code>. 
<code>simdata0</code> is a reduced dataset with only six curves in each cluster.
</p>


<h3>Source</h3>

<p>The data are from James and Sugar (2003).
</p>


<h3>References</h3>

<p>James, G.M., Sugar, C.A. (2003). Clustering for sparsely sampled functional data.  <em>Journal of the American Statistical Association</em>, 98.462, 397&ndash;408.
</p>

<hr>
<h2 id='summary.mocca'>Summary for a mocca fit
</h2><span id='topic+summary.mocca'></span><span id='topic+print.summary.mocca'></span>

<h3>Description</h3>

<p>Takes a <code>mocca</code> object produced by <code>mocca()</code> and produces various useful
summaries from it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mocca'
summary(object,...)

## S3 method for class 'summary.mocca'
print(x,digits = max(3, getOption("digits") - 3),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mocca_+3A_object">object</code></td>
<td>
<p>a fitted <code>mocca</code> object as produced by <code>mocca()</code>.</p>
</td></tr>
<tr><td><code id="summary.mocca_+3A_x">x</code></td>
<td>
<p>a <code>summary.mocca</code> object produced by <code>summary.mocca()</code>.</p>
</td></tr> 
<tr><td><code id="summary.mocca_+3A_digits">digits</code></td>
<td>
<p>controls the number of digits printed in the output.</p>
</td></tr>
<tr><td><code id="summary.mocca_+3A_...">...</code></td>
<td>
<p> other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.mocca</code> produces the following list of summary information for a <code>mocca</code> object. 
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>number of scalar covariates if model with covariates</p>
</td></tr>
<tr><td><code>sig2</code></td>
<td>
<p>residual variance estimate for the functional data and for the scalar covariates (if the model is with covariates)</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>total number of the estimated parameters in the model</p>
</td></tr>
<tr><td><code>tab_numOfCurves_cluster</code></td>
<td>
<p>number of objects/curves in each cluster as a table. Here 'hard' clustering is applied, where each object/curve belongs to a cluster with the highest posterior probability.</p>
</td></tr>
<tr><td><code>covariates_est</code></td>
<td>
<p>mean value estimates for scalar covariates given cluster belongings (if the model is with covariates)</p>
</td></tr>
<tr><td><code>t.probs</code></td>
<td>
<p>estimated probabilities of belonging to each cluster</p>
</td></tr>
<tr><td><code>crita</code></td>
<td>
<p>a table with the maximized log likelihood, AIC, BIC and Shannon entropy values of the fitted model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Per Arnqvist, Sara Sjöstedt de Luna,  Natalya Pya Arnqvist
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mocca">mocca</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?mocca help files
</code></pre>

<hr>
<h2 id='varve'>Varved sediment data from lake Kassjön</h2><span id='topic+varve'></span><span id='topic+varve_full'></span>

<h3>Description</h3>

<p>Annually varved lake sediment data from the lake Kassjön in Northern Sweden. The Kassjön data are used to illustrate the ideas of the model-based functional clustering with covariates. The varved sediment of lake Kassjön covers approximately 6400 years and is believed to be historical records of weather and climate.  The varves (years) are clustered into similar groups based on their seasonal patterns (functional data) and additional covariates, all potentially carrying information on past climate/weather. 
</p>
<p>The Kassjön data has been analyzed in several papers. In Petterson et al. (2010, 1999, 1993) the sediment data was captured with image analysis and after preprocessing, the data was recorded as gray scale values with yearly deliminators, thus giving 6388 years (-4386 &ndash; 1901), or varves with 4&ndash;36 gray scale values per year. In Arnqvist et al. (2016) the shape/form of the
yearly grey scale observations was modeled as curve functions and analyzed in a non-parametric functional data analysis approach. In Abramowicz et al. (2016) a Bagging Voronoi K-Medoid Alignment (BVKMA) method was proposed to group the varves into different &quot;climates&quot;. The suggested procedure simultaneously clusters and aligns spatially dependent curves and is a nonparametric statistical method that does not
rely on distributional or dependency structure assumptions.
</p>


<h3>Format</h3>

 <p><code>varve</code> data is a list containing six objects named as <code>x</code>, <code>time</code>, <code>timeindex</code>, <code>curve</code>, <code>grid</code>, <code>covariates</code>. See <code><a href="#topic+mocca">mocca</a></code> for explanation of these objects. 
</p>
<p><code>varve_full</code> has <code class="reqn">N=6326</code> observed subjects (years/varve), where for each varve we observed one function (seasonal pattern) and four covariates. <code>varve</code> is simply a reduced data set with only <code class="reqn">N=1493</code> subjects.
</p>


<h3>Details</h3>

<p>The varve patterns have the following origin. During
spring, in connection to snow melt and spring runoff, minerogenic material is
transported from the catchment area into the lake through four small streams, which
gives rise to a bright colored layer, giving high gray-scale values (Petterson et al., 2010). During summer, autochthonous organic matter, sinks to the bottom and creates a darker layer (lower gray-scale values). During the winter, when the lake is
ice-covered, fine organic material is deposited, resulting in a thin blackish winter layer
(lowest gray-scale values). There is substantial within- and between year
variation, reflecting the balance between minerogenic and organic material. The
properties of each varve reflect, to a large extent, weather conditions and internal
biological processes in the lake the year that the varve was deposited. The minerogenic
input reflects the intensity of the spring run-off, which is dependent on the amount of
snow accumulated during the winter, and hence the variability in past winter climate.
</p>
<p>The data consists of <code class="reqn">N = 6326</code> (subjects) years and the <code class="reqn">n_i</code> observations per year
ranges from 4 to 37. A few years were missing, see Arnqvist et al. (2016) for details. For
each year <code class="reqn">i</code> we observe the centered seasonal pattern in terms of grey scale values (<code class="reqn">y_i</code>)'s
at <code class="reqn">n_i</code> time points (pixels). We also register (the four covariates) the mean grey scale
within each year, the varve width <code class="reqn">n_i</code> and the minerogenic accumulation rate (<code class="reqn">mg/cm^2</code>)
corresponding to the total amount of minerogenic material per <code class="reqn">cm^2</code> in the varve (year) <code class="reqn">i</code>,
see Petterson et al. (2010) for details. In order to make the seasonal patterns comparable
we first put them on the same time scale <code class="reqn">[0,1]</code>, such that pixel position <code class="reqn">j</code> at year <code class="reqn">i</code>
corresponds to position <code class="reqn">\tilde{t}_{ij} = (j-1)/(n_i-1),~ j = 1, ..., n _i, ~i = 1, ..., N.</code> To make
the patterns more comparable (with respect to climate) they were further aligned by
landmark registration, synchronizing the first spring peaks, that are directly related to
the spring flood that occurs approximately the same time each year.
</p>
<p>As in previous analysis (Arnqvist et al., 2016) the first peak of each year is aligned
towards a common spring peak with an affine warping, that is, if we denote the common
spring peak as <code class="reqn">M_L</code> and the yearly spring peak as <code class="reqn">L_i,~ i = 1, ..., N</code> and let <code class="reqn">b = M_L/L_i</code>,
<code class="reqn">d=(1-M_L)/(1-L_i)</code> then we will have the warped time points according to <code class="reqn">w(t_{ij}) = t_{ij}b</code>
for <code class="reqn">t_{ij} &lt; L_i</code> and <code class="reqn">w(t_{ij}) = 1 + d(t_{ij}-1)</code> for <code class="reqn">t_{ij}\geq L_i</code>. The common spring peak and the
yearly spring peaks are given in Arnqvist et al. (2016).
</p>
<p>Focusing on the functional forms of the seasonal patterns we finally centered them
within years and worked with (the centered values) <code class="reqn">y_i(t_{ij}) -\bar{y}_i,~ j = 1, ..., n_i,~ i = 1,...,N</code>
where <code class="reqn">\bar{y}_i=\sum_{j=1}^{n_i}y_i(t_{ij})/n_i</code> is the mean grey scale value of varve (year) <code class="reqn">i</code>. In addition
to the seasonal patterns we also include four covariates: i) <code class="reqn">x_{1i}=\bar{y}_i</code>, the mean grey scale; ii) <code class="reqn">x_{2i} = n_i</code>, the varve width (proportional to <code class="reqn">n_i</code>); iii) <code class="reqn">x_{3i}</code>, the minerogenic accumulation rate
corresponding to the accumulated amount of minerogenic material per <code class="reqn">cm^2</code> in varve <code class="reqn">i</code>; and iv) <code class="reqn">x_{4i}</code>, the landmark which is the distance from the start of the year to the first peak, interpreted as the start of the spring, for details see (Petterson et al., 2010, and and Arnqvist et al. 2016).
</p>
<p><code>varve_full</code> is a full data set with <code class="reqn">N=6326</code> years/curves spanning the time period 4486 B.C. until 1901 A.D..
</p>
<p><code>varve</code> is a reduced data set with <code class="reqn">N=1493</code> years/curves covering the time period 750 BC to 750 AD.
</p>


<h3>References</h3>

<p>Arnqvist, P., Bigler, C., Renberg, I., Sjöstedt de Luna, S. (2016). Functional clustering of varved lake sediment to reconstruct past seasonal climate. <em>Environmental and Ecological Statistics</em>, <b>23</b>(4), 513&ndash;529.
</p>
<p>Abramowicz, K., Arnqvist, P., Secchi, P., Sjöstedt de Luna, S., Vantini, S., Vitelli, V. (2017). Clustering misaligned dependent curves applied to varved lake sediment for climate reconstruction. <em>Stochastic Environmental Research and Risk Assessment</em>. Volume <b>31.1</b>, 71&ndash;85.
</p>
<p>Arnqvist, P., and Sjöstedt de Luna, S. (2019). Model based functional clustering of varved lake sediments. <em>arXiv preprint arXiv:1904.10265</em>.
</p>
<p>Petterson, G., Renberg, I., Sjöstedt de Luna, S., Arnqvist, P., and Anderson, N. J. (2010). Climatic influence on the inter-annual variability of late-Holocene minerogenic sediment supply in a boreal forest catchment. <em>Earth surface processes and landforms</em>. <b>35</b>(4), 390&ndash;398.
</p>
<p>Petterson, G., B. Odgaard, and I. Renberg (1999). Image analysis as a method to quantify sediment components. <em>Journal of Paleolimnology 22</em>. (4), 443&ndash;455.
</p>
<p>Petterson, G., I. Renberg, P. Geladi, A. Lindberg, and F. Lindgren (1993). Spatial uniformity of sediment accumulation in varved lake sediments in Northern Sweden. <em>Journal of Paleolimnology</em>. <b>9</b>(3), 195&ndash;208.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
