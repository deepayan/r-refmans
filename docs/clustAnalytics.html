<!DOCTYPE html><html><head><title>Help for package clustAnalytics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustAnalytics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_subgraphs'><p>Applies function to each subgraph of a graph</p></a></li>
<li><a href='#auxiliary_functions'><p>Auxiliary Functions of a Graph Partition</p></a></li>
<li><a href='#average_degree'><p>Average Degree</p></a></li>
<li><a href='#average_odf'><p>Average Out Degree Fraction</p></a></li>
<li><a href='#barabasi_albert_blocks'><p>Generates a Barabási-Albert graph with community structure</p></a></li>
<li><a href='#boot_alg_list'><p>Performs nonparametric bootstrap to a graph and a list of clustering algorithms</p></a></li>
<li><a href='#c_rs_table'><p>Contingency table from membership vectors</p></a></li>
<li><a href='#clustAnalytics-package'><p>clustAnalytics: Cluster Evaluation on Graphs</p></a></li>
<li><a href='#conductance'><p>Conductance</p></a></li>
<li><a href='#contingency_to_membership_vectors'><p>Computes possible membership vectors from contingency table</p></a></li>
<li><a href='#count_contingency_tables_log'><p>Natural logarithm of the number of contingency tables</p></a></li>
<li><a href='#coverage'><p>Coverage</p></a></li>
<li><a href='#cut_ratio'><p>Cut Ratio</p></a></li>
<li><a href='#density_ratio'><p>Density Ratio</p></a></li>
<li><a href='#edges_inside'><p>Edges Inside</p></a></li>
<li><a href='#estimate_H_fraction_r_rows'><p>Estimates |H_0|/|H_r*|</p></a></li>
<li><a href='#estimate_H_fractions'><p>Estimates |H_i|/|H_{i+1}| for the first r rows</p></a></li>
<li><a href='#evaluate_significance'><p>Evaluates significance of cluster algorithm results on a graph</p></a></li>
<li><a href='#evaluate_significance_r'><p>Evaluates the significance of a graph's clusters</p></a></li>
<li><a href='#expansion'><p>Expansion</p></a></li>
<li><a href='#FOMD'><p>FOMD (Fraction Over Median Degree)</p></a></li>
<li><a href='#g_forex'><p>Forex correlation network</p></a></li>
<li><a href='#H_fractions_rows'><p>Estimates |H_i|/|H_(i+1)| for the first n_rows rows</p></a></li>
<li><a href='#igraph_to_edgelist'><p>Returns edgelist with weights from a weighted igraph graph</p></a></li>
<li><a href='#internal_density'><p>Internal Density</p></a></li>
<li><a href='#log_omega_estimation'><p>Approximation of log(omega(a,b))</p></a></li>
<li><a href='#make_graph_weighted'><p>Make graph weighted</p></a></li>
<li><a href='#max_odf'><p>Max Out Degree Fraction</p></a></li>
<li><a href='#normalized_cut'><p>Normalized cut</p></a></li>
<li><a href='#out_degree_fractions'><p>Maximum, Average, and Flake Out Degree Fractions of a Graph Partition</p></a></li>
<li><a href='#reduced_mutual_information'><p>Reduced Mutual Information</p></a></li>
<li><a href='#relabel'><p>Relabels membership vector</p></a></li>
<li><a href='#rewireCpp'><p>Randomizes a weighted graph while keeping the degree distribution constant.</p></a></li>
<li><a href='#scoring_functions'><p>Scoring Functions of a Graph Partition</p></a></li>
<li><a href='#sort_matrix'><p>Sort matrix</p></a></li>
<li><a href='#triangle_participation_ratio_communities'><p>Triangle Participation Ratio (community-wise)</p></a></li>
<li><a href='#walk_step'><p>Performs a step of the Markov Chain Monte Carlo method</p></a></li>
<li><a href='#weighted_clustering_coefficient'><p>Weighted clustering coefficient of a weighted graph.</p></a></li>
<li><a href='#weighted_transitivity'><p>Weighed transitivity of a weighted graph.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cluster Evaluation on Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Martí Renedo Mirambell</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martí Renedo Mirambell &lt;marti.renedo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluates the stability and significance of clusters on 'igraph' graphs.
    Supports weighted and unweighted graphs. Implements the cluster evaluation methods
    defined by Arratia A, Renedo M (2021) &lt;<a href="https://doi.org/10.7717%2Fpeerj-cs.600">doi:10.7717/peerj-cs.600</a>&gt;. Also includes an
    implementation of the Reduced Mutual Information introduced by Newman et al. (2020) 
    &lt;<a href="https://doi.org/10.1103%2FPhysRevE.101.042304">doi:10.1103/PhysRevE.101.042304</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), mcclust, mclust, truncnorm, boot, fossil,
aricode, dplyr, Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraphdata, knitr, rmarkdown, testthat,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/martirm/clustAnalytics">https://github.com/martirm/clustAnalytics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/martirm/clustAnalytics/issues">https://github.com/martirm/clustAnalytics/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), igraph</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 22:51:27 UTC; blaug</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 23:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_subgraphs'>Applies function to each subgraph of a graph</h2><span id='topic+apply_subgraphs'></span>

<h3>Description</h3>

<p>Applies function to each subgraph of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_subgraphs(g, com, f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_subgraphs_+3A_g">g</code></td>
<td>
<p>igraph graph</p>
</td></tr>
<tr><td><code id="apply_subgraphs_+3A_com">com</code></td>
<td>
<p>vector of memberships that determines the subgraphs (i.e. all elements
with the same label will form a subgraph).</p>
</td></tr>
<tr><td><code id="apply_subgraphs_+3A_f">f</code></td>
<td>
<p>Function to apply. Takes a graph as input and returns a scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with the result of each subgraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
apply_subgraphs(g=karate, com=V(karate)$Faction, f=gorder)
</code></pre>

<hr>
<h2 id='auxiliary_functions'>Auxiliary Functions of a Graph Partition</h2><span id='topic+auxiliary_functions'></span>

<h3>Description</h3>

<p>Given a weighted graph and a partition into communities, returns the
internal edge weight, the size, and the cut weight for each community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxiliary_functions(g, com, edgelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxiliary_functions_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object)</p>
</td></tr>
<tr><td><code id="auxiliary_functions_+3A_com">com</code></td>
<td>
<p>Community membership vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
<tr><td><code id="auxiliary_functions_+3A_edgelist">edgelist</code></td>
<td>
<p>alternatively, the edgelist of the graph</p>
</td></tr>
</table>

<hr>
<h2 id='average_degree'>Average Degree</h2><span id='topic+average_degree'></span>

<h3>Description</h3>

<p>Average degree (weighted degree, if the graph is weighted) of a graph's communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_degree(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_degree_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="average_degree_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the average degree of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
average_degree(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='average_odf'>Average Out Degree Fraction</h2><span id='topic+average_odf'></span>

<h3>Description</h3>

<p>Computes the Average Out Degree Fraction (Average ODF) of a graph (which can be weighted)
and its communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_odf(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_odf_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot; attribute, those will be used as weights (otherwise, all edges are assumed to be 1).</p>
</td></tr>
<tr><td><code id="average_odf_+3A_com">com</code></td>
<td>
<p>Community membership integer vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the Average ODF of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
average_odf(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='barabasi_albert_blocks'>Generates a Barabási-Albert graph with community structure</h2><span id='topic+barabasi_albert_blocks'></span>

<h3>Description</h3>

<p>Generates a Barabási-Albert graph with community structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barabasi_albert_blocks(
  m,
  p,
  B,
  t_max,
  G0 = NULL,
  t0 = NULL,
  G0_labels = NULL,
  sample_with_replacement = FALSE,
  type = "Hajek"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barabasi_albert_blocks_+3A_m">m</code></td>
<td>
<p>number of edges added at each step.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_p">p</code></td>
<td>
<p>vector of label probabilities. If they don't sum 1, they will be scaled accordingly.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_b">B</code></td>
<td>
<p>matrix indicating the affinity of vertices of each label.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_t_max">t_max</code></td>
<td>
<p>maximum value of t (which corresponds to graph order)</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_g0">G0</code></td>
<td>
<p>initial graph</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_t0">t0</code></td>
<td>
<p>t value at which new vertex start to be attached. If G0 is provided,
this argument is ignored and assumed to be gorder(G0)+1. If it isn't, a G0
graph will be generated with order t0-1.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_g0_labels">G0_labels</code></td>
<td>
<p>labels of the initial graph. If NULL, they will all be set to 1.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_sample_with_replacement">sample_with_replacement</code></td>
<td>
<p>If TRUE, allows parallel edges.</p>
</td></tr>
<tr><td><code id="barabasi_albert_blocks_+3A_type">type</code></td>
<td>
<p>Either &quot;Hajek&quot; or &quot;block_first&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting graph, as an igraph object. The vertices have a
&quot;label&quot; attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- matrix(c(1, 0.2, 0.2, 1), ncol=2)
G &lt;- barabasi_albert_blocks(m=4, p=c(0.5, 0.5), B=B, t_max=100, type="Hajek", 
                            sample_with_replacement = FALSE)

</code></pre>

<hr>
<h2 id='boot_alg_list'>Performs nonparametric bootstrap to a graph and a list of clustering algorithms</h2><span id='topic+boot_alg_list'></span>

<h3>Description</h3>

<p>Performs nonparametric bootstrap on a graph's by resampling its vertices and
clustering the results using a list of clustering algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_alg_list(
  alg_list = list(Louvain = cluster_louvain, `label prop` = cluster_label_prop, walktrap
    = cluster_walktrap),
  g,
  R = 999,
  return_data = FALSE,
  type = "global"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_alg_list_+3A_alg_list">alg_list</code></td>
<td>
<p>List of igraph clustering algorithms</p>
</td></tr>
<tr><td><code id="boot_alg_list_+3A_g">g</code></td>
<td>
<p><code>igraph</code> graph object</p>
</td></tr>
<tr><td><code id="boot_alg_list_+3A_r">R</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_alg_list_+3A_return_data">return_data</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a list of &quot;<code>boot</code>&quot; objects
with the full results. Otherwise, returns a table with the mean results.</p>
</td></tr>
<tr><td><code id="boot_alg_list_+3A_type">type</code></td>
<td>
<p>Can be &quot;global&quot; (Variation of Information, Reduced Mutual Information, 
and adjusted Rand Index) or &quot;cluster-wise&quot; (Jaccard distance)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_data</code> is set to <code>TRUE</code>, returns a list of objects of
class &quot;<code>boot</code>&quot; (see <code><a href="boot.html#topic+boot">boot</a></code>). Otherwise, returns as table 
with the mean distances from the clusters in the original graph to the resampled
ones, for each of the algorithms.
</p>

<hr>
<h2 id='c_rs_table'>Contingency table from membership vectors</h2><span id='topic+c_rs_table'></span>

<h3>Description</h3>

<p>Given two membership vectors, returns the corresponding contingency table.
we assume the labels are &gt;=1 and numbered consecutively. If not consecutive
(some labels are unused) this implementation still works, but will be less
efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_rs_table(c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_rs_table_+3A_c1">c1</code>, <code id="c_rs_table_+3A_c2">c2</code></td>
<td>
<p>membership vectors (integer values containing the index of each community)</p>
</td></tr>
</table>

<hr>
<h2 id='clustAnalytics-package'>clustAnalytics: Cluster Evaluation on Graphs</h2><span id='topic+clustAnalytics'></span><span id='topic+clustAnalytics-package'></span>

<h3>Description</h3>

<p>Evaluates the stability and significance of clusters on 'igraph' graphs. Supports weighted and unweighted graphs. Implements the cluster evaluation methods defined by Arratia A, Renedo M (2021) <a href="https://doi.org/10.7717/peerj-cs.600">doi:10.7717/peerj-cs.600</a>. Also includes an implementation of the Reduced Mutual Information introduced by Newman et al. (2020) <a href="https://doi.org/10.1103/PhysRevE.101.042304">doi:10.1103/PhysRevE.101.042304</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/martirm/clustAnalytics">https://github.com/martirm/clustAnalytics</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/martirm/clustAnalytics/issues">https://github.com/martirm/clustAnalytics/issues</a>
</p>
</li></ul>


<hr>
<h2 id='conductance'>Conductance</h2><span id='topic+conductance'></span>

<h3>Description</h3>

<p>Conductance of a graph's communities, which is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{c_s}{2m_s + c_s}</code>
</p>
<p>,
where <code class="reqn">c_s</code> is the weight of the edges connecting the community s to the rest
of the graph, and m_s is the internal weight of the community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conductance(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conductance_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="conductance_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the conductance of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
conductance(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='contingency_to_membership_vectors'>Computes possible membership vectors from contingency table</h2><span id='topic+contingency_to_membership_vectors'></span>

<h3>Description</h3>

<p>Given a contingency table, obtains a possible pair of corresponding labelings.
That is, element M[i,j] is the number of elements that belong to community i
in the first labeling and j in the second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingency_to_membership_vectors(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingency_to_membership_vectors_+3A_m">M</code></td>
<td>
<p>the contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the two membership vectors
</p>

<hr>
<h2 id='count_contingency_tables_log'>Natural logarithm of the number of contingency tables</h2><span id='topic+count_contingency_tables_log'></span>

<h3>Description</h3>

<p>Given a contingency table, returns the natural logarithm of the number of
contingency tables that share the same column and row sums. This implementation
combines a Markov Chain Monte Carlo approximation with an analytical formula.
The input can be either M a contingency table, or two vectors of labels c1 and c2 
(in this case, we are counting contingency tables with the same column an row sums as
the one produced by c1 and c2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_contingency_tables_log(c1, c2, M = NULL, monte_carlo_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_contingency_tables_log_+3A_c1">c1</code>, <code id="count_contingency_tables_log_+3A_c2">c2</code></td>
<td>
<p>membership vectors</p>
</td></tr>
<tr><td><code id="count_contingency_tables_log_+3A_m">M</code></td>
<td>
<p>contingency table</p>
</td></tr>
<tr><td><code id="count_contingency_tables_log_+3A_monte_carlo_only">monte_carlo_only</code></td>
<td>
<p>Uses only the Monte Carlo approximation</p>
</td></tr>
</table>

<hr>
<h2 id='coverage'>Coverage</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p>Computes the coverage (fraction of internal edges with respect to the total
number of edges) of a graph and its communities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object).</p>
</td></tr>
<tr><td><code id="coverage_+3A_com">com</code></td>
<td>
<p>Community membership integer vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value of the coverage of <code>g</code> and <code>com</code>.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
coverage(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='cut_ratio'>Cut Ratio</h2><span id='topic+cut_ratio'></span>

<h3>Description</h3>

<p>The cut ratio of a graph's community is the total edge weight connecting the community
to the rest of the graph divided by number of unordered pairs of vertices such that one
belongs to the community and the other does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_ratio(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_ratio_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="cut_ratio_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the cut ratio of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
cut_ratio(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='density_ratio'>Density Ratio</h2><span id='topic+density_ratio'></span>

<h3>Description</h3>

<p>Density ratio of a graph's communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_ratio(g, com, type = "local")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_ratio_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
<tr><td><code id="density_ratio_+3A_type">type</code></td>
<td>
<p>can either be &quot;local&quot; or &quot;global&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the internal density of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
density_ratio(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='edges_inside'>Edges Inside</h2><span id='topic+edges_inside'></span>

<h3>Description</h3>

<p>Number of edges inside a graph's communities, or their accumulated weight if
the graph's edges are weighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_inside(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_inside_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="edges_inside_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the internal edge weight of each community
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
edges_inside(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='estimate_H_fraction_r_rows'>Estimates |H_0|/|H_r*|</h2><span id='topic+estimate_H_fraction_r_rows'></span>

<h3>Description</h3>

<p>This is the total number of contingency tables (of the same margins as M) divided 
by the number that match M until the r-th row (included, 0-indexed). Note that
if r==0, this is always 1 by definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_H_fraction_r_rows(M, r, error = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_H_fraction_r_rows_+3A_m">M</code></td>
<td>
<p>contingency table</p>
</td></tr>
<tr><td><code id="estimate_H_fraction_r_rows_+3A_r">r</code></td>
<td>
<p>row index</p>
</td></tr>
<tr><td><code id="estimate_H_fraction_r_rows_+3A_error">error</code></td>
<td>
<p>error for the convergence of the method</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_H_fractions'>Estimates |H_i|/|H_{i+1}| for the first r rows</h2><span id='topic+estimate_H_fractions'></span>

<h3>Description</h3>

<p>The product of all these ratios is is the total number of contingency tables (of the same margins as M) divided 
by the number that match M until the r-th row (included, 0-indexed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_H_fractions(M, r, error = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_H_fractions_+3A_m">M</code></td>
<td>
<p>contingency table</p>
</td></tr>
<tr><td><code id="estimate_H_fractions_+3A_r">r</code></td>
<td>
<p>row index</p>
</td></tr>
<tr><td><code id="estimate_H_fractions_+3A_error">error</code></td>
<td>
<p>error for the convergence of the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NumericVector containing all the ratios
</p>

<hr>
<h2 id='evaluate_significance'>Evaluates significance of cluster algorithm results on a graph</h2><span id='topic+evaluate_significance'></span>

<h3>Description</h3>

<p>Given a graph and a list of clustering algorithms, computes several scoring
functions on the clusters found by each of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_significance(
  g,
  alg_list = list(Louvain = cluster_louvain, `label prop` = cluster_label_prop, walktrap
    = cluster_walktrap),
  no_clustering_coef = FALSE,
  gt_clustering = NULL,
  w_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_significance_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object)</p>
</td></tr>
<tr><td><code id="evaluate_significance_+3A_alg_list">alg_list</code></td>
<td>
<p>List of clustering algorithms, which take an <code>igraph</code> graph as
input and return an object of the <code>communities</code> class.</p>
</td></tr>
<tr><td><code id="evaluate_significance_+3A_no_clustering_coef">no_clustering_coef</code></td>
<td>
<p>Logical. If <code>TRUE</code>, skips the computation of the clustering
coefficient, which is the most computationally costly of the scoring functions.</p>
</td></tr>
<tr><td><code id="evaluate_significance_+3A_gt_clustering">gt_clustering</code></td>
<td>
<p>Vector of integers that correspond to labels of the ground truth clustering. 
The scoring functions will be evaluated on it.</p>
</td></tr>
<tr><td><code id="evaluate_significance_+3A_w_max">w_max</code></td>
<td>
<p>Numeric. Upper bound for edge weights. Should be generally left as default (<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the values of scoring functions (see <code><a href="#topic+scoring_functions">scoring_functions</a></code>) 
of the clusters obtained by
applying the clustering algorithms to the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
evaluate_significance(karate)
</code></pre>

<hr>
<h2 id='evaluate_significance_r'>Evaluates the significance of a graph's clusters</h2><span id='topic+evaluate_significance_r'></span>

<h3>Description</h3>

<p>Computes community scoring functions to the communities obtained by applying 
the given clustering algorithms to a graph. These are compared to the same scores
for randomized versions of the graph obtained by a switching algorithm that
rewires edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_significance_r(
  g,
  alg_list = list(Louvain = cluster_louvain, `label prop` = cluster_label_prop, walktrap
    = cluster_walktrap),
  no_clustering_coef = FALSE,
  gt_clustering = NULL,
  table_style = "default",
  ignore_degenerate_cl = TRUE,
  Q = 100,
  lower_bound = 0,
  weight_sel = "const_var",
  n_reps = 5,
  w_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_significance_r_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object)</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_alg_list">alg_list</code></td>
<td>
<p>List of clustering algorithms, which take an <code>igraph</code> graph as
input and return an object of the <code>communities</code> class.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_no_clustering_coef">no_clustering_coef</code></td>
<td>
<p>Logical. If <code>TRUE</code>, skips the computation of the clustering
coefficient, which is the most computationally costly of the scoring functions.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_gt_clustering">gt_clustering</code></td>
<td>
<p>Vector of integers that correspond to labels of the ground truth clustering. 
The scoring functions will be evaluated on it.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_table_style">table_style</code></td>
<td>
<p>By default returns a table with three columns per algorithm: the original one,
the mean of the corresponding rewired scores (suffix &quot;_r&quot;) and it's percentile rank within the
distribution of rewired scores (suffix &quot;_percentile&quot;). If table_style == &quot;string&quot;, instead
returns a table with a column per algorithm where each element is of the form &quot;original|rewired(percentile)&quot;</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_ignore_degenerate_cl">ignore_degenerate_cl</code></td>
<td>
<p>Logical. If TRUE, when computing the means of the 
scoring functions, samples with only one cluster will be ignored.
See <a href="#topic+rewireCpp">rewireCpp</a>.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_q">Q</code></td>
<td>
<p>Numeric. Parameter that controls the number of iterations of the switching algorithm,
which will be Q times the order of the graph.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Numeric. Lower bound to the edge weights. The randomization
process will avoid steps that would make edge weights fall outside this
bound. It should generally be left as 0 to avoid negative weights.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_weight_sel">weight_sel</code></td>
<td>
<p>Can be either <code>const_var</code> or <code>max_weight</code>.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_n_reps">n_reps</code></td>
<td>
<p>Number of samples of the rewired graph.</p>
</td></tr>
<tr><td><code id="evaluate_significance_r_+3A_w_max">w_max</code></td>
<td>
<p>Numeric. Upper bound for edge weights. The randomization algorithm will avoid steps that would make 
edge weights fall outside this bound. Should be generally left as default (<code>NULL</code>), unless the network has 
by nature or by construction a known upper bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the results of each scoring function and algorithm. See <code>table_style</code> for details.
</p>

<hr>
<h2 id='expansion'>Expansion</h2><span id='topic+expansion'></span>

<h3>Description</h3>

<p>Given a graph (possibly weighted) split into communities, the expansion of a community
is the sum of all edge weights connecting it to the rest of the graph divided by the number
of vertices in the community
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expansion(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expansion_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="expansion_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the expansion of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
expansion(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='FOMD'>FOMD (Fraction Over Median Degree)</h2><span id='topic+FOMD'></span>

<h3>Description</h3>

<p>Given a weighted graph and a partition into communities, returns the fraction
of nodes of each community whose internal degree (i.e. the degree accounting
only intra-community edges) is greater than the median degree of the whole
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FOMD(g, com, edgelist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FOMD_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="FOMD_+3A_com">com</code></td>
<td>
<p>Community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
<tr><td><code id="FOMD_+3A_edgelist">edgelist</code></td>
<td>
<p>alternatively, the edgelist of the graph, as a matrix where the
first two columns to the vertices and the third is the weight of each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the FOMD of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
FOMD(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='g_forex'>Forex correlation network</h2><span id='topic+g_forex'></span>

<h3>Description</h3>

<p>Network built from correlations between time series of exchange rate returns.  
It was built from the 13 most traded currencies and with data of January 2009. 
It is a complete graph of 78 vertices (corresponding to pairs of currencies) 
and has edge weights bounded between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_forex
</code></pre>


<h3>Format</h3>

<p>An igraph object with 78 vertices and 3003 weighted edges
</p>

<hr>
<h2 id='H_fractions_rows'>Estimates |H_i|/|H_(i+1)| for the first n_rows rows</h2><span id='topic+H_fractions_rows'></span>

<h3>Description</h3>

<p>Estimates |H_i|/|H_(i+1)| for the first n_rows rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H_fractions_rows(M, n_rows, error = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_fractions_rows_+3A_m">M</code></td>
<td>
<p>contingency table</p>
</td></tr>
<tr><td><code id="H_fractions_rows_+3A_n_rows">n_rows</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="H_fractions_rows_+3A_error">error</code></td>
<td>
<p>for the convergence of the method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with all the |H_i|/|H_(i+1)| fractions
</p>

<hr>
<h2 id='igraph_to_edgelist'>Returns edgelist with weights from a weighted igraph graph</h2><span id='topic+igraph_to_edgelist'></span>

<h3>Description</h3>

<p>This function is just used internally for testing the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_to_edgelist(g, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_to_edgelist_+3A_g">g</code></td>
<td>
<p>igraph graph with weighted edges</p>
</td></tr>
<tr><td><code id="igraph_to_edgelist_+3A_sort">sort</code></td>
<td>
<p>sorts the edge list lexicographically before returning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where the first two columns indicate the incident vertices,
and the third is the weight of the corresponding edge.
</p>

<hr>
<h2 id='internal_density'>Internal Density</h2><span id='topic+internal_density'></span>

<h3>Description</h3>

<p>Internal density of a graph's communities. That is, the sum of weights of their 
edges divided by the number of unordered pairs of vertices (which is the number of potential edges).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal_density(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_density_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="internal_density_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the internal density of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
internal_density(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='log_omega_estimation'>Approximation of log(omega(a,b))</h2><span id='topic+log_omega_estimation'></span>

<h3>Description</h3>

<p>Where omega(a,b) is the number of contingency tables with a, b as row and column sums.
This approximation is only good for dense tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_omega_estimation(c1, c2, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_omega_estimation_+3A_c1">c1</code>, <code id="log_omega_estimation_+3A_c2">c2</code></td>
<td>
<p>membership vectors</p>
</td></tr>
<tr><td><code id="log_omega_estimation_+3A_base">base</code></td>
<td>
<p>base of the logarithm (e by default)</p>
</td></tr>
</table>

<hr>
<h2 id='make_graph_weighted'>Make graph weighted</h2><span id='topic+make_graph_weighted'></span>

<h3>Description</h3>

<p>Given a graph, create a &quot;weight&quot; attribute set to 1 for the edges if it doesn't
exist already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_graph_weighted(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_graph_weighted_+3A_g">g</code></td>
<td>
<p>igraph graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph graph with either all edge weights set to 1 (if the original
graph was unweighted), or to their original weights if they already existed
(in this case, the graph isn't modified at all).
</p>

<hr>
<h2 id='max_odf'>Max Out Degree Fraction</h2><span id='topic+max_odf'></span>

<h3>Description</h3>

<p>Computes the Maximum Out Degree Fraction (Max ODF) of a graph (which can be weighted)
and its communities.
</p>
<p>Computes the Flake Out Degree Fraction (Max ODF) of a graph (which can be weighted)
and its communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_odf(g, com)

max_odf(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_odf_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot; attribute, those will be used as weights (otherwise, all edges are assumed to be 1).</p>
</td></tr>
<tr><td><code id="max_odf_+3A_com">com</code></td>
<td>
<p>Community membership integer vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the Max ODF of each community.
</p>
<p>Numeric vector with the Max ODF of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>
<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
max_odf(karate, membership(cluster_louvain(karate)))
data(karate, package="igraphdata")
max_odf(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='normalized_cut'>Normalized cut</h2><span id='topic+normalized_cut'></span>

<h3>Description</h3>

<p>Normalized cut of a graph's communities, which is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{c_s}{2m_s+c_s}+\frac{c_s}{2(m-m_s)+c_s}</code>
</p>
<p>,
where <code class="reqn">c_s</code> is the weight of the edges connecting the community s to the rest
of the graph, <code class="reqn">m_s</code> is the internal weight of the community, and <code class="reqn">m</code> is
the total weight of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalized_cut(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalized_cut_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have a &quot;weight&quot;
attribute, those will be used as weights.</p>
</td></tr>
<tr><td><code id="normalized_cut_+3A_com">com</code></td>
<td>
<p>community membership integer vector. Each element corresponds to a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the normalized cut of each community.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
normalized_cut(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='out_degree_fractions'>Maximum, Average, and Flake Out Degree Fractions of a Graph Partition</h2><span id='topic+out_degree_fractions'></span>

<h3>Description</h3>

<p>Given a weighted graph and a partition into communities, returns the
maximum, average and flake out degree fractions of each community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out_degree_fractions(g, com, edgelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="out_degree_fractions_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object)</p>
</td></tr>
<tr><td><code id="out_degree_fractions_+3A_com">com</code></td>
<td>
<p>Community membership vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
<tr><td><code id="out_degree_fractions_+3A_edgelist">edgelist</code></td>
<td>
<p>alternatively, the edgelist of the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix where each row corresponds to a community, and the 
columns contain the max, average and flake ODFs respectively.
</p>

<hr>
<h2 id='reduced_mutual_information'>Reduced Mutual Information</h2><span id='topic+reduced_mutual_information'></span>

<h3>Description</h3>

<p>Computes the Newman's Reduced Mutual Information (RMI) as defined in 
(Newman et al. 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduced_mutual_information(
  c1,
  c2,
  base = 2,
  normalized = FALSE,
  method = "approximation2",
  warning = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduced_mutual_information_+3A_c1">c1</code>, <code id="reduced_mutual_information_+3A_c2">c2</code></td>
<td>
<p>membership vectors</p>
</td></tr>
<tr><td><code id="reduced_mutual_information_+3A_base">base</code></td>
<td>
<p>base of the logarithms used in the calculations. Changing it only scales the final value. By default set to e=exp(1).</p>
</td></tr>
<tr><td><code id="reduced_mutual_information_+3A_normalized">normalized</code></td>
<td>
<p>If true, computes the normalized version of the corrected mutual information.</p>
</td></tr>
<tr><td><code id="reduced_mutual_information_+3A_method">method</code></td>
<td>
<p>Can be &quot;hybrid&quot; (default, combines Monte Carlo with analytical formula), &quot;monte_carlo&quot;, 
approximation1&quot; (appropriate for partitions into many very small clusters), 
or &quot;approximation2&quot; (for partitions into few larger clusters).</p>
</td></tr>
<tr><td><code id="reduced_mutual_information_+3A_warning">warning</code></td>
<td>
<p>set to false to ignore the warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation is based on equations 23 (25 for the normalized case) and 29 in (Newman et al. 2020).
The evaluations of the <code class="reqn">\Gamma</code> functions can get too large and cause overflow 
issues in the intermediate steps, so the following term of equation 29:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2} \log \frac{\Gamma(\mu R) \Gamma(\nu S)} {(\Gamma(\nu)\Gamma(R))^S (\Gamma(\mu)\Gamma(S))^R } </code>
</p>

<p>is rewritten as 
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2} (\log\Gamma(\mu R) + \log\Gamma(\nu S) - S\log(\Gamma(\nu) - S\log(\Gamma(R) - R\log\Gamma(\mu) - R\log\Gamma(R)  )</code>
</p>
<p>,
and then the function <a href="base.html#topic+lgamma">lgamma</a> is used instead of <a href="base.html#topic+gamma">gamma</a>.
</p>


<h3>Value</h3>

<p>The value of Newman's RMI (a scalar).
</p>


<h3>References</h3>

<p>Newman MEJ, Cantwell GT, Young J (2020).
&ldquo;Improved mutual information measure for clustering, classification, and community detection.&rdquo;
<em>Phys. Rev. E</em>, <b>101</b>(4), 042304.
<a href="https://doi.org/10.1103/PhysRevE.101.042304">doi:10.1103/PhysRevE.101.042304</a>.
</p>

<hr>
<h2 id='relabel'>Relabels membership vector</h2><span id='topic+relabel'></span>

<h3>Description</h3>

<p>Takes a vector of vertex ids indicating community membership, and relabels the communities
to have consecutive values from 1 to the number of communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel(c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabel_+3A_c">c</code></td>
<td>
<p>numeric vector of vertex ids, not necessarily consecutive</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of consecutive vertex ids starting from one
</p>

<hr>
<h2 id='rewireCpp'>Randomizes a weighted graph while keeping the degree distribution constant.</h2><span id='topic+rewireCpp'></span>

<h3>Description</h3>

<p>Converts the graph to a weighted edge list in NumericMatrix, which is compatible with Rcpp.
The Rcpp function &quot;randomize&quot; is called, and then the resulting edge list is converted
back into an igraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewireCpp(
  g,
  Q = 100,
  weight_sel = "max_weight",
  lower_bound = 0,
  upper_bound = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewireCpp_+3A_g">g</code></td>
<td>
<p><code>igraph</code> graph, which can be weighted.</p>
</td></tr>
<tr><td><code id="rewireCpp_+3A_q">Q</code></td>
<td>
<p>Numeric. Parameter that controls the number of iterations, which will be Q times the order of the graph.</p>
</td></tr>
<tr><td><code id="rewireCpp_+3A_weight_sel">weight_sel</code></td>
<td>
<p>can be either &quot;const_var&quot; or &quot;max_weight&quot;.</p>
</td></tr>
<tr><td><code id="rewireCpp_+3A_lower_bound">lower_bound</code>, <code id="rewireCpp_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Bounds to the edge weights. The randomization
process will avoid steps that would make edge weights fall outside these
bounds. Set to NULL for no bound. By default, 0 and NULL respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rewired graph.
</p>

<hr>
<h2 id='scoring_functions'>Scoring Functions of a Graph Partition</h2><span id='topic+scoring_functions'></span>

<h3>Description</h3>

<p>Computes the scoring functions of a graph and its clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoring_functions(
  g,
  com,
  no_clustering_coef = TRUE,
  type = "local",
  weighted = TRUE,
  w_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoring_functions_+3A_g">g</code></td>
<td>
<p>Graph to be analyzed (as an <code>igraph</code> object). If the edges have 
a &quot;weight&quot; attribute, those will be used as weights (otherwise, all edges are assumed to be 1).</p>
</td></tr>
<tr><td><code id="scoring_functions_+3A_com">com</code></td>
<td>
<p>Community membership integer vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
<tr><td><code id="scoring_functions_+3A_no_clustering_coef">no_clustering_coef</code></td>
<td>
<p>Logical. If TRUE, skips the computation of the clustering
coefficient (which can be slow on large graphs).</p>
</td></tr>
<tr><td><code id="scoring_functions_+3A_type">type</code></td>
<td>
<p>can be &quot;local&quot; for a cluster by cluster analysis, or &quot;global&quot; for
a global analysis of the whole graph partition.</p>
</td></tr>
<tr><td><code id="scoring_functions_+3A_weighted">weighted</code></td>
<td>
<p>Is the graph weighted? If it is, doesn't compute TPR score.</p>
</td></tr>
<tr><td><code id="scoring_functions_+3A_w_max">w_max</code></td>
<td>
<p>Numeric. Upper bound for edge weights. Should be generally left as default (NULL).
Only affects the computation of the clustering coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type=="local"</code>, returns a dataframe with a row for each
community, and a column for each score. If <code>type=="global"</code>, returns a
single row with the weighted average scores.
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
scoring_functions(karate, membership(cluster_louvain(karate)))
</code></pre>

<hr>
<h2 id='sort_matrix'>Sort matrix</h2><span id='topic+sort_matrix'></span>

<h3>Description</h3>

<p>Given a matrix, rearranges rows and columns so that row sums and col sums
end up in ascending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_matrix(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_matrix_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rearranged matrix
</p>

<hr>
<h2 id='triangle_participation_ratio_communities'>Triangle Participation Ratio (community-wise)</h2><span id='topic+triangle_participation_ratio_communities'></span>

<h3>Description</h3>

<p>Computes the triangle participation ratio (proportion of vertices that belong 
to a triangle). The computation is done to the subgraphs induced by each of 
the communities in the given partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle_participation_ratio_communities(g, com)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_participation_ratio_communities_+3A_g">g</code></td>
<td>
<p>The input graph (as an igraph object). Edge weights and directions are ignored.</p>
</td></tr>
<tr><td><code id="triangle_participation_ratio_communities_+3A_com">com</code></td>
<td>
<p>Community membership vector. Each element corresponds to a vertex
of the graph, and contains the index of the community it belongs to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the triangle participation ratio of each community.
</p>

<hr>
<h2 id='walk_step'>Performs a step of the Markov Chain Monte Carlo method</h2><span id='topic+walk_step'></span>

<h3>Description</h3>

<p>Modifies the matrix while keeping the column and row sums constant, as well as
leaving the positions strictly preceding (k,l) in lexicographical order invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walk_step(M, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walk_step_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="walk_step_+3A_k">k</code>, <code id="walk_step_+3A_l">l</code></td>
<td>
<p>Coordinates of the first element that is not invariant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating whether the step left the matrix invariant
</p>

<hr>
<h2 id='weighted_clustering_coefficient'>Weighted clustering coefficient of a weighted graph.</h2><span id='topic+weighted_clustering_coefficient'></span>

<h3>Description</h3>

<p>Weighted clustering Computed using the definition given by McAssey, M. P. and Bijma, F. in 
&quot;A clustering coefficient for complete weighted networks&quot; (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_clustering_coefficient(g, upper_bound = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_clustering_coefficient_+3A_g">g</code></td>
<td>
<p>igraph graph</p>
</td></tr>
<tr><td><code id="weighted_clustering_coefficient_+3A_upper_bound">upper_bound</code></td>
<td>
<p>upper bound to the edge weights used to compute the integral</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weighted clustering coefficient of the graph (a scalar).
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_transitivity">weighted_transitivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
weighted_clustering_coefficient(karate)
</code></pre>

<hr>
<h2 id='weighted_transitivity'>Weighed transitivity of a weighted graph.</h2><span id='topic+weighted_transitivity'></span>

<h3>Description</h3>

<p>Computed using the definition given by McAssey, M. P. and Bijma, F. in 
&quot;A clustering coefficient for complete weighted networks&quot; (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_transitivity(g, upper_bound = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_transitivity_+3A_g">g</code></td>
<td>
<p>igraph graph</p>
</td></tr>
<tr><td><code id="weighted_transitivity_+3A_upper_bound">upper_bound</code></td>
<td>
<p>upper bound to the edge weights used to compute the integral</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weighted transitivity of the graph (a scalar).
</p>


<h3>See Also</h3>

<p>Other cluster scoring functions: 
<code><a href="#topic+FOMD">FOMD</a>()</code>,
<code><a href="#topic+average_degree">average_degree</a>()</code>,
<code><a href="#topic+average_odf">average_odf</a>()</code>,
<code><a href="#topic+conductance">conductance</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+cut_ratio">cut_ratio</a>()</code>,
<code><a href="#topic+density_ratio">density_ratio</a>()</code>,
<code><a href="#topic+edges_inside">edges_inside</a>()</code>,
<code><a href="#topic+expansion">expansion</a>()</code>,
<code><a href="#topic+internal_density">internal_density</a>()</code>,
<code><a href="#topic+max_odf">max_odf</a>()</code>,
<code><a href="#topic+normalized_cut">normalized_cut</a>()</code>,
<code><a href="#topic+scoring_functions">scoring_functions</a>()</code>,
<code><a href="#topic+weighted_clustering_coefficient">weighted_clustering_coefficient</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(karate, package="igraphdata")
weighted_transitivity(karate)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
