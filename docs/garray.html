<!DOCTYPE html><html lang="en"><head><title>Help for package garray</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {garray}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#garray-package'><p>garray: Generalized Array Arithmetic for Ragged Arrays with Named Margins</p></a></li>
<li><a href='#+5B.garray'><p>Indexing for the garray class</p></a></li>
<li><a href='#+25+2B+25'><p>Function composition operator</p></a></li>
<li><a href='#abind'><p>Combine generalized arrays</p></a></li>
<li><a href='#amap'><p>Mapping matching dimension of arrays with a function</p></a></li>
<li><a href='#amult'><p>Generalized array multiplication.</p></a></li>
<li><a href='#aperm.garray'><p>General array transposition</p></a></li>
<li><a href='#areduce'><p>Generalized and smart apply()/Reduce()/tapply() for data folding.</p></a></li>
<li><a href='#as.data.frame.garray'><p>Coerce to a Data Frame</p></a></li>
<li><a href='#awipe'><p>Generalized array's sweep() for data cleaning.</p></a></li>
<li><a href='#dim.garray'><p>Dimensions of a generalized array</p></a></li>
<li><a href='#garray'><p>Generalized and smart array</p></a></li>
<li><a href='#margins'><p>The margins and dimensions of a generalized array object</p></a></li>
<li><a href='#print.garray'><p>Print Values</p></a></li>
<li><a href='#psummary'><p>Parallel summary, inspired by pmax() and pmin().</p></a></li>
<li><a href='#read.ctable'><p>Read a complex table and return array in basic storagemode.</p></a></li>
<li><a href='#sdim'><p>Subdimensions of an array</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Array Arithmetic for Ragged Arrays with Named
Margins</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Qingsheng Huang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qingsheng Huang &lt;huangqqss@126.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Organize a so-called ragged array as generalized arrays, which
	is simply an array with sub-dimensions denoting the subdivision of
	dimensions (grouping of members within dimensions).
	By the margins (names of dimensions and sub-dimensions) in generalized
	arrays, operators and utility functions provided in this package
	automatically match the margins,
	doing map-reduce style parallel computation
	along margins.  Generalized arrays are also cooperative to R's native
	functions that work on simple arrays.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-05 15:56:53 UTC; alex</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-05 19:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='garray-package'>garray: Generalized Array Arithmetic for Ragged Arrays with Named Margins</h2><span id='topic+garray-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Organize a so-called ragged array as generalized arrays, which
is simply an array with sub-dimensions denoting the subdivision of
dimensions (grouping of members within dimensions).
By the margins (names of dimensions and sub-dimensions) in generalized
arrays, operators and utility functions provided in this package
automatically match the margins,
doing map-reduce style parallel computation
along margins.  Generalized arrays are also cooperative to R's native
functions that work on simple arrays.
</p>


<h3>Details</h3>

<p>R do vector to vector calculation, but has convention on how vectors
should be recycled or truncated.
The rule of match objects of different dimensions is simple and
elegance, but sometimes annoying.  MatLab and Python have different
rules doing such match.  Their rules are sometimes convinient but
bug-proning.
package:tensorA is smart in matching the margins, displaying
the usefulness of naming the dimension and do the automatical matching
when operating on two arrays.
</p>
<p>In addition, for a jagged (ragged) array R can
</p>

<ol>
<li><p> (like the so called Iliffe vector) have a list,
and each sublist is the members of a group, which is
unconvinient (most math function not accepts list) but most flexible,
running with lapply() (also ref. package:rowr);
</p>
</li>
<li><p> have a vector (values) recording all members and another (index)
vector recording the grouping, running with tapply() (and by/aggregate);
</p>
</li>
<li><p> have a matrix where each column/row is for a group and short groups
are filled with placeholder like NA.
</p>
</li></ol>

<p>Representations of (1) and (2) are inter-convertable via stack/unstack.
Map and reduce for (2) seems handy and can be less flexible than
tapply(), since the grouping is continuous and is repeating,
naturally when members among groups are actually similar.
package:lambda.tools allows block operations but the matching are not
automatically.
</p>
<p>It is needed to clarify that operation on subdimensions means whether
operating within every group independently (similar to apply(MARGIN))
or operating among groups, maintaining the contain of a group
(apply() achieves this via apply() on the complement margins).
Similarly, should the length of a subdimensions be the sizes of groups
or the number of groups?
I think the first convention is compatible with apply().
Thus when utility functions of this package operate on subdimension,
they operate within every group independently.
Not like simple arrays that their margins are orthogonal and complement,
for generalized arrays, there is no complement margins for
subdimentions, since the array is ragged.
When some operations concerning comparing among groups, special tricks
are needed (may be I will implement some of these tricks as
utility functions in the future, for example, getting the number of
groups corresponding to a subdimension).
</p>
<p>One of the advantages of the library is to do parallel calculation
automatically.  Map and reduce operations have both serial and
parallel implementation.  When <code>options(mc.cores)</code> is set to a value
no less than 2, the attaching of garray library will triger
<code>.onAttach()</code>, which defined <code>.LAPPLY</code> and <code>.MAPPLY</code>, which are the
working horse of <code>amap()</code> and <code>areduce()</code>, by the parallel
implementation.
To double check (not needed by regular user) the activation of
parallel, run
<code>amap(function(x) Sys.getpid(), garray(1:4, margins="I"), "I")</code>.
If elements the return are of the same, <code>amap()</code> runs in serial;
if they are of different, it runs in parallel.
</p>
<p>Design:
</p>

<ul>
<li><p> Naming convention:
</p>

<ul>
<li><p> &quot;simple array&quot; - object that is.array() is TRUE;
</p>
</li>
<li><p> &quot;generalized array&quot; - object that is.garray() is TRUE;
</p>
</li>
<li><p> &quot;array&quot; - generalized array, especially in issued message.
</p>
</li></ul>

</li>
<li><p> In this world, only 2 types of data are welcome: array and scalar.
</p>
</li>
<li><p> Most functions also work for simple array, with warnings.
</p>
</li>
<li><p> Attribute &quot;sdim&quot; of simple array are neglected (since no superdim).
</p>
</li>
<li><p> Attribute class=&quot;garray&quot; is almost only for method dispatching.
The validity of a generalized array in fact depends on the
correctness of dimnames, which is tested by <code>is.garray()</code>.
</p>
</li></ul>


<hr>
<h2 id='+5B.garray'>Indexing for the garray class</h2><span id='topic++5B.garray'></span><span id='topic++5B'></span><span id='topic++5B+3C-'></span><span id='topic++5B+3C-.garray'></span>

<h3>Description</h3>

<p>Indexing along margins as usual <code>[.array</code>, and along subdim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garray'
...[drop=TRUE]
#`[.garray`(..., drop=TRUE)
#x[i]
#x[i,j,...,drop=TRUE]
#x[m]
#x[l]
#x[M=i,N=j,...]

#\method{[}{garray}(...) &lt;- value
#`[&lt;-.garray`(..., value)
#x[i] &lt;- value
#x[i,j,...] &lt;- value
#x[m] &lt;- value
#x[l] &lt;- value
#x[M=i,N=j,...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.garray_+3A_drop">drop</code></td>
<td>
<p>Whether indeces where 1==dim are removed.  Different from
R's native <code>[</code>, a garray will become a garray or scalar, never a vector.</p>
</td></tr>
<tr><td><code id="+2B5B.garray_+3A_value">value</code></td>
<td>
<p>An array or a scalar.</p>
</td></tr>
<tr><td><code id="+2B5B.garray_+3A_x">x</code></td>
<td>
<p>A generalized array from which elements are extracted or replaced.</p>
</td></tr>
<tr><td><code id="+2B5B.garray_+3A_i">i</code>, <code id="+2B5B.garray_+3A_j">j</code>, <code id="+2B5B.garray_+3A_m">m</code>, <code id="+2B5B.garray_+3A_l">l</code>, <code id="+2B5B.garray_+3A_m">M</code>, <code id="+2B5B.garray_+3A_n">N</code>, <code id="+2B5B.garray_+3A_...">...</code></td>
<td>
<p>In addition to the native styles (<code>i</code>, <code>j</code>, etc.)
accepted by <code>[</code>, can be:
</p>

<ol>
<li><p> a matrix <code>m</code> with column names,
which (<code>colnames(m)</code>) is a permutation of margins of the array.
</p>
</li>
<li><p> an list <code>l &lt;- list(i,j,...)</code>, can be unnamed or named,
where NULL means to select all;
</p>
</li>
<li><p> arguments with names (<code>M</code>, <code>N</code>, etc), where <code>NULL</code> and missing
means to select all.
</p>
</li></ol>

<p>These extensions make indexing 3 times slower than native indexing.
Since it is hard to assign MissingArg in list(), at the moment
MissingArg is only safe in native R subsettting style.
Using NULL to select all like MissingArg is actually not consistent
in semantic of other uses of NULL. As shown by what <code>c()</code> returns,
NULL is a generalized form of <code>logical(0)</code>, <code>integer(0)</code>,
and <code>character(0)</code>, all of which means to select none when indexing.
So take care of NULL if indexing with variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mm &lt;- matrix(c(1:3,1), 2, 2, dimnames=list(NULL, c("B","A")))
a &lt;- garray(1:27, c(A=3,B=9), sdim=list(AA=c(a=2,b=1),BB=c(a=3)))
b &lt;- a[mm]
c1 &lt;- a[B=1:2,A=NULL]
c2 &lt;- a[B=1:2,A=]
c3 &lt;- a[B=1:2]
c4 &lt;- a[list(B=1:2)]
c5 &lt;- a[list(B=1:2,A=NULL)]
c6 &lt;- a[list(NULL,1:2)]
d1 &lt;- a[,] ; d1[B=1:2,A=NULL]       &lt;- c1*10
d2 &lt;- a[,] ; d2[B=1:2,A=]           &lt;- c1*10
d3 &lt;- a[,] ; d3[B=1:2]              &lt;- c1*10
d4 &lt;- a[,] ; d4[list(B=1:2)]        &lt;- c1*10
d5 &lt;- a[,] ; d5[list(B=1:2,A=NULL)] &lt;- c1*10
d6 &lt;- a[,] ; d6[B=1:2,A=NULL] &lt;- 1
d7 &lt;- a[,] ; d7[mm] &lt;- 1000
d8 &lt;- a[,] ; d8[mm] &lt;- 1:2*1000
e1 &lt;- a[AA=1,drop=FALSE]
e11 &lt;- a[AA=c(1,1),drop=FALSE]
e2 &lt;- a[AA="b",drop=FALSE]
ebb &lt;- a[AA=c("b","b"),drop=FALSE]
e3 &lt;- a[,] ; e3[AA="b"] &lt;- e2*10
e33 &lt;- a[,] ; e33[AA=c("b","b")] &lt;- c(e2*0.1, e2*100)
# Work in the same manner of `e33[c(3,3),] &lt;- c(e2*0.1, e2*100)`.
e4 &lt;- a[A=c(TRUE,FALSE,FALSE),drop=FALSE]
e5 &lt;- a[A=TRUE,drop=FALSE]
e6 &lt;- a[B=c(TRUE,FALSE,FALSE),drop=FALSE]
e7 &lt;- a[AA=TRUE,drop=FALSE]
e8 &lt;- a[AA=c(TRUE,FALSE),drop=FALSE]
</code></pre>

<hr>
<h2 id='+25+2B+25'>Function composition operator</h2><span id='topic++25+2B+25'></span>

<h3>Description</h3>

<p>Composite functions <code>a</code> and <code>b</code> into <code>a(b(...))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %+% b
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B2B+2B25_+3A_a">a</code></td>
<td>
<p>A function that can be called with one argument.</p>
</td></tr>
<tr><td><code id="+2B25+2B2B+2B25_+3A_b">b</code></td>
<td>
<p>A function that can be called with one or more argument,
and result of <code>b()</code> can be passed to <code>a()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new function, whose
arguments are what <code>b()</code> can accept, and whose result is what <code>a()</code>
can return.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lse &lt;- log%+%sum%+%exp
lse(1:10)
#logsumexp(1:10)	# actual logsumexp() is more sophistic
log(sum(exp(1:10)))
sum &lt;- sd
lse(1:10)	# lse() is fixed at definition
log(sum(exp(1:10)))
(log%+%sum%+%exp)(1:10)	# now is (log%+%sd%+%exp)
</code></pre>

<hr>
<h2 id='abind'>Combine generalized arrays</h2><span id='topic+abind'></span>

<h3>Description</h3>

<p>Combine generalized arrays, similar to the manner cbind and rbind work.
Put a sequence of generalized arrays and get a single generalized array
of the same or one more margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abind(..., margins = character(), along = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abind_+3A_...">...</code></td>
<td>
<p>arrays, or a list of several arrays.  Margins of
these arrays should be the same.</p>
</td></tr>
<tr><td><code id="abind_+3A_margins">margins</code></td>
<td>
<p>Resulting margins.  If includes a totally new margin (not
used by any arrays in <code>...</code>), then
<code>along</code> is neglected and the new margin setting <code>along</code>.
If no new name and <code>length(along)==0L</code>, the last <code>margins</code> become along.
If <code>0L==length(margins)</code>, <code>along</code> will become last dimensions of output.</p>
</td></tr>
<tr><td><code id="abind_+3A_along">along</code></td>
<td>
<p>The dimension along which to bind the arrays.
The arrays may have different lengths along that dimension,
and are bind along it, with addition subdimension '*.bind.from'
indicating the composition
of the <code>along</code> dimension.  Some arrays may not
have that margin, then the dimension of these arrays expand to 1.
If <code>along</code> is a totally new margin, it is created.
In such case, all arrays should have the same dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combine sdim correctly.
Saving or dropping of subdimensions follow a few rules: subdimensions of
the margin with bound along are dropped; of the other margins are save
unless the names of subdimensions are the same; subdimensions of the
same names are dropped except the first one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- garray(1:24, c(4,6),
	dimnames=list(X=1:4, Y=letters[1:6]),
 	sdim=list(XX=c(x1=3,x2=1), YY=c(y1=1,y2=2)))
b &lt;- garray(1:6/10,6,dimnames=list(Y=letters[1:6]))
ab &lt;- abind(a=a, b=b, along="X")
#abind(a, b, margins=c("X","Y"))	# Error
ab2 &lt;- abind(a=a, b=b, margins=c("X","Y"), along="X")
aa &lt;- abind(a=a, a=a, along="Z")
ab3 &lt;- abind(a, b, along="X")
</code></pre>

<hr>
<h2 id='amap'>Mapping matching dimension of arrays with a function</h2><span id='topic+amap'></span><span id='topic+Ops.garray'></span>

<h3>Description</h3>

<p>Generalized and smart mapply()/Map()/outer()/sweep() for data mapping.
Matching is checked automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amap(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, VECTORIZED = NA)

## S3 method for class 'garray'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amap_+3A_fun">FUN</code></td>
<td>
<p>Known vectorized function is recognized if passed in
as character.  Other functions will be vectorized by <code>.mapply()</code>.</p>
</td></tr>
<tr><td><code id="amap_+3A_...">...</code></td>
<td>
<p>Arrays with margins (names of dimnames) and maybe with sdim.
Orders of their margins can be different, but the extent along a
margin is matched. Unmatched margins are broadcasting like outer().
Scalar (length 1 vector) do not contribute margins and
not broadcast here (they will broadcast by <code>.mapply()</code> later).</p>
</td></tr>
<tr><td><code id="amap_+3A_moreargs">MoreArgs</code></td>
<td>
<p>a list of other arguments to 'FUN', no matching of margins.</p>
</td></tr>
<tr><td><code id="amap_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>logical, attempt to reduce the result to exclude recursive
structure (no list hierachy but plain generalized array).</p>
</td></tr>
<tr><td><code id="amap_+3A_vectorized">VECTORIZED</code></td>
<td>
<p>Whether FUN is vectorized will affect the behaviours.
Some combination of FUN and VECTORIZED is not simply slowing down,
but produces meaningless results or even stop (e.g., cumsum).
TRUE - call <code>FUN</code> once with arrays being reorganize on dimensions;
FALSE - call <code>FUN</code> many times (via <code>.mapply</code>), with each cell of arrays.</p>
</td></tr>
<tr><td><code id="amap_+3A_e1">e1</code>, <code id="amap_+3A_e2">e2</code></td>
<td>
<p>Generalized arrays, being operands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dimensions is deduced from inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- garray(1:24, c(4,6,2), dimnames=list(X=1:4, Y=letters[1:6], Z=NULL),
	sdim=list(XX=c(x1=3,x2=1), YY=c(y1=1,y2=2)))
b &lt;- garray(1:6/10,6,dimnames=list(Y=letters[1:6]))
c &lt;- garray(1:4/100,c(X=4))
d &lt;- garray(1:4/1000,c(Y=4))
e &lt;- garray(1:2/1000,c(X=2))
f &lt;- garray(0,c(Z=2))
g &lt;- garray(0,c(ZZ=2))
m1 &lt;- amap(psummary,c,a,b,      0.0001, VECTORIZED=FALSE)
m2 &lt;- amap(sum,     c,a,b,      0.0001, VECTORIZED=FALSE)
m3 &lt;-               c+a+b+      0.0001
n1 &lt;- amap(sum,     c,a,b,d,    0.0001, VECTORIZED=FALSE)
n2 &lt;- amap(sum,     c,a,b,e,    0.0001, VECTORIZED=FALSE)
n3 &lt;- amap(sum,     c,a,b,e,f,  0.0001, VECTORIZED=FALSE)
p1 &lt;- amap(sum,     c,a,b,e,f,g,0.0001, VECTORIZED=FALSE)
q1 &lt;- amap(sum, c,a,b,e,f,g,0.0001, SIMPLIFY=FALSE, VECTORIZED=FALSE)
q2 &lt;- amap(c,   c,a,b,e,f,g,0.0001, SIMPLIFY=FALSE, VECTORIZED=FALSE)
q3 &lt;- amap(list,c,a,b,e,f,g,0.0001, SIMPLIFY=FALSE, VECTORIZED=FALSE)
m1==m2
m2==m3
m2==aperm(m3, 3:1)
</code></pre>

<hr>
<h2 id='amult'>Generalized array multiplication.</h2><span id='topic+amult'></span><span id='topic++25X+25'></span>

<h3>Description</h3>

<p>Default to Einstein summation convention, without explicitly subscripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amult(X, Y, FUN = "*", SUM = "sum", BY = NULL, MoreArgs = NULL,
  ..., SIMPLIFY = TRUE, VECTORIZED = TRUE)

X %X% Y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amult_+3A_x">X</code>, <code id="amult_+3A_y">Y</code></td>
<td>
<p>Generalized arrays that can be multiplied.</p>
</td></tr>
<tr><td><code id="amult_+3A_fun">FUN</code></td>
<td>
<p>The 'multiply' function.</p>
</td></tr>
<tr><td><code id="amult_+3A_sum">SUM</code></td>
<td>
<p>The 'reduce' function.</p>
</td></tr>
<tr><td><code id="amult_+3A_by">BY</code></td>
<td>
<p>margins excluded from summary by SUM.</p>
</td></tr>
<tr><td><code id="amult_+3A_moreargs">MoreArgs</code>, <code id="amult_+3A_simplify">SIMPLIFY</code>, <code id="amult_+3A_vectorized">VECTORIZED</code></td>
<td>
<p>Argument used by 'amap()'.</p>
</td></tr>
<tr><td><code id="amult_+3A_...">...</code></td>
<td>
<p>Argument used by 'areduce()'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Margins shared by X and Y are parallelly mapped by FUN,
and then reduced by SUM (inner product like <code>%*%</code>);
margins in BY and shared by X and Y are simply mapped by FUN
but excluded from reducing (parallel product like <code>*</code>);
other margins are extended repeatly (outer product like <code>%o%</code>).
Shared margins not to be mapped have to be renamed (like outer product).
For special FUN and SUM, fast algorithms are implemented.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- garray(1:24, c(4,6), list(X=LETTERS[1:4], Y=letters[1:6]),
	sdim=list(XX=c(x1=3,x2=1), YY=c(y1=1,y2=2)))
b &lt;- garray(1:20, c(Z=5, X=4))
c &lt;- garray(1:120, c(X=4,Y=6,Z=5))
m1 &lt;- amult(a, b)
m2 &lt;- amult(a, b, `*`, sum)
m3 &lt;- amult(b, a)
all.equal(m1, m2)
all.equal(m1, m3)
all.equal(m1, t(m3))
n1 &lt;- amult(a, c, `*`, sum)
n2 &lt;- a%X%c
all.equal(n1, n2)
amult(garray(1:5,margins="I"), garray(1:8,margins="J"))
amult(garray(1:8,c(I=2,J=4)), garray(1:9,c(K=3,L=3)))
</code></pre>

<hr>
<h2 id='aperm.garray'>General array transposition</h2><span id='topic+aperm.garray'></span>

<h3>Description</h3>

<p>Restore garray attributes that discarded by aperm.default().
Cannot permute between subdimension (means to promote subdimension of
equal length
into regular dim and reduce dim into subdimension), sorry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garray'
aperm(a, perm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aperm.garray_+3A_a">a</code></td>
<td>
<p>A generalized array to be transposed.</p>
</td></tr>
<tr><td><code id="aperm.garray_+3A_perm">perm</code></td>
<td>
<p>Desired margins after permutation, integer or character.</p>
</td></tr>
<tr><td><code id="aperm.garray_+3A_...">...</code></td>
<td>
<p>Useless, potential arguments inherited from the S3 generic.</p>
</td></tr>
</table>

<hr>
<h2 id='areduce'>Generalized and smart apply()/Reduce()/tapply() for data folding.</h2><span id='topic+areduce'></span>

<h3>Description</h3>

<p>Generalized and smart apply()/Reduce()/tapply() for data folding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areduce(FUN, X, MARGIN, ..., SIMPLIFY = TRUE, SAFE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="areduce_+3A_fun">FUN</code></td>
<td>
<p>Usually a summary function (like <code>all</code> and <code>sum</code>).</p>
</td></tr>
<tr><td><code id="areduce_+3A_x">X</code></td>
<td>
<p>A garray, with margins (names of dimnames) and maybe with sdim.</p>
</td></tr>
<tr><td><code id="areduce_+3A_margin">MARGIN</code></td>
<td>
<p>Some margins of X and names of sdim.
MARGIN=character() means to reduce all margins (over no margin).
In such case, areduce() is not needed actually.</p>
</td></tr>
<tr><td><code id="areduce_+3A_...">...</code></td>
<td>
<p>Further arguments to 'FUN', no matching of margins.</p>
</td></tr>
<tr><td><code id="areduce_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>TRUE - simplifies the result list to vector of atomic
if possible, and triggers warning and not simplifies if impossible;
FALSE - not simplifies for non speed-up function, and issues warning
(and have to simplify) for speed-up function; NA - simplifies but no
warning if impossible.</p>
</td></tr>
<tr><td><code id="areduce_+3A_safe">SAFE</code></td>
<td>
<p>TRUE - use safe but slow implementation, in which data splited
from the array are reorganized into small arrays (as are being subset
by <code>[]</code>) and passed to FUN (other attributes are dropped, however);
FALSE - faster, data are passed to FUN as dimension-less vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (similar to return of apply() or tapply()), with the
trailing margins the same as MARGIN, while the leading margins
depend on FUN and SIMPLIFY.  If FUN returns a scalar or SIMPLIFY=FALSE,
then no leading margins.  In MARGIN, subdimension is replaced with superdims.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- garray(1:24, c(4,6),
	dimnames=list(X=LETTERS[1:4], Y=letters[1:6]),
	sdim=list(XX=c(x1=3,x2=1), YY=c(y1=1,y2=2)))
x1 &lt;- areduce("sum", a, c("X"))
x2 &lt;- areduce(`sum`, a, c("X"))
stopifnot(garray(c(66,72,78,84), margins="X")==x1, x2==x1)
yy1 &lt;- areduce("sum", a, c("YY"))
yy2 &lt;- areduce(`sum`, a, c("YY"))
stopifnot(garray(c(10,68,58,164), margins="Y")==yy1, yy2==yy1)
xyy1 &lt;- areduce("sum", a, c("X","YY"))
xyy2 &lt;- areduce(`sum`, a, c("X","YY"))
stopifnot(xyy1==xyy2)
xxyy1 &lt;- areduce("sum", a, c("XX","YY"))
xxyy2 &lt;- areduce(`sum`, a, c("XX","YY"))
stopifnot(garray(c(6,4,48,20,42,16,120,44), c(X=2,Y=4))==xxyy1)
stopifnot(xxyy2==xxyy1)
b &lt;- garray(1:24, c(3,4,2),
	dimnames=list(X=LETTERS[1:3], Y=letters[1:4], Z=NULL),
	sdim=list(XX=c(x1=2,x2=1), YY=c(y1=1,y2=1)))
xxyyz1 &lt;- areduce("sum", b, c("XX","YY","Z"))
xxyyz2 &lt;- areduce(`sum`, b, c("XX","YY","Z"))
stopifnot(xxyyz1==xxyyz2)
xyz1 &lt;- areduce(identity, b, c("XX","YY","Z"), SIMPLIFY=FALSE)
xyz2 &lt;- areduce("c",      b, c("XX","YY","Z"), SIMPLIFY=FALSE)
xy1 &lt;- areduce(identity, b, c("XX","YY"), SIMPLIFY=FALSE, SAFE=TRUE)
stopifnot(identical(dimnames(xy1[2,3][[1]]), list(X="C",Y="c",Z=NULL)))
# garray of lists, cannot use `xyz1==xyz2` etc to compare.
</code></pre>

<hr>
<h2 id='as.data.frame.garray'>Coerce to a Data Frame</h2><span id='topic+as.data.frame.garray'></span>

<h3>Description</h3>

<p>Convert a 2D generalized array into a data.frame,
making <code>print()</code> work correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garray'
as.data.frame(x, row.names = NULL, optional = FALSE,
  col.names = NULL, ..., stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.garray_+3A_x">x</code></td>
<td>
<p>A generalized array object.</p>
</td></tr>
<tr><td><code id="as.data.frame.garray_+3A_row.names">row.names</code>, <code id="as.data.frame.garray_+3A_optional">optional</code>, <code id="as.data.frame.garray_+3A_stringsasfactors">stringsAsFactors</code>, <code id="as.data.frame.garray_+3A_...">...</code></td>
<td>
<p>See the same arguments in
?as.data.frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.garray_+3A_col.names">col.names</code></td>
<td>
<p>'NULL' or a character vector giving the column names.</p>
</td></tr>
</table>

<hr>
<h2 id='awipe'>Generalized array's sweep() for data cleaning.</h2><span id='topic+awipe'></span>

<h3>Description</h3>

<p>Return a generalized array, by wiping out a summary statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awipe(X, FUN = "-", STATS = "mean", MARGIN = NULL, MoreArgs = NULL,
  ..., SIMPLIFY = TRUE, VECTORIZED = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="awipe_+3A_x">X</code></td>
<td>
<p>A generalized array.</p>
</td></tr>
<tr><td><code id="awipe_+3A_fun">FUN</code></td>
<td>
<p>The wiping function.</p>
</td></tr>
<tr><td><code id="awipe_+3A_stats">STATS</code></td>
<td>
<p>Numeric array or function.</p>
</td></tr>
<tr><td><code id="awipe_+3A_margin">MARGIN</code></td>
<td>
<p>NULL - STATS is an array; character - STATS is a function,
and by X being reduced along MARGIN, X is wiped.  Length 0 character
vector means reducing along no margin, resulting in a scalar (in
this case, for example, <code>areduce(sum, X)</code> is the same as <code>sum(X)</code>.</p>
</td></tr>
<tr><td><code id="awipe_+3A_moreargs">MoreArgs</code>, <code id="awipe_+3A_simplify">SIMPLIFY</code>, <code id="awipe_+3A_vectorized">VECTORIZED</code></td>
<td>
<p>Argument used by 'amap()'.</p>
</td></tr>
<tr><td><code id="awipe_+3A_...">...</code></td>
<td>
<p>Argument used by 'areduce()'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- garray(1:24, c(4,6), list(X=LETTERS[1:4], Y=letters[1:6]),
	sdim=list(XX=c(x1=3,x2=1), YY=c(y1=1,y2=2)))
m1 &lt;- awipe(a, MARGIN="XX")
m2 &lt;- awipe(a, `-`, mean, "XX")
</code></pre>

<hr>
<h2 id='dim.garray'>Dimensions of a generalized array</h2><span id='topic+dim.garray'></span><span id='topic+dim'></span><span id='topic+dim+3C-'></span><span id='topic+dim+3C-.garray'></span>

<h3>Description</h3>

<p>Retrieve or set the dimension of a generalized array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garray'
dim(x)

## S3 replacement method for class 'garray'
dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.garray_+3A_x">x</code></td>
<td>
<p>An generalized array.</p>
</td></tr>
<tr><td><code id="dim.garray_+3A_value">value</code></td>
<td>
<p>An integer (can be coerced from double numeric) vector, with
names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>dim</code> and <code>dim&lt;-</code> are internal generic primitive functions.
Here <code>dim.garray</code> and <code>dim&lt;-.garray</code> are methods for 'garray's, which
returns and setting with the named dimensions (margins).  The two
function is usually used as, for example, <code>dim(arr)</code> and
<code>dim(arr) &lt;- c(A=3,B=2)</code>.
Native R saves the names of dim but seldom uses it.  However, it is
undocumented and not stable because some functions
discard it (like: t()) .  This package will totally neglect it but
keeps the margins in dimnames.
</p>

<hr>
<h2 id='garray'>Generalized and smart array</h2><span id='topic+garray'></span><span id='topic+garray.array'></span><span id='topic+as.garray'></span><span id='topic+as.garray.garray'></span><span id='topic+as.garray.default'></span><span id='topic+is.garray'></span><span id='topic+is.garray.duck'></span><span id='topic+is.scalar'></span>

<h3>Description</h3>

<p>Creates or tests for generalized arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garray(data, dim = NULL, dimnames = NULL, margins = NULL,
  sdim = attr(data, "sdim", exact = TRUE))

garray.array(x, sdim)

as.garray(x, ...)

## S3 method for class 'garray'
as.garray(x, ...)

## Default S3 method:
as.garray(x, ...)

is.garray(x)

is.garray.duck(x)

is.scalar(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garray_+3A_data">data</code></td>
<td>
<p>Usually a simple array, and can be a vector without dimensions.</p>
</td></tr>
<tr><td><code id="garray_+3A_dim">dim</code></td>
<td>
<p>An integer vector giving the maximal indices in each dimension.</p>
</td></tr>
<tr><td><code id="garray_+3A_dimnames">dimnames</code></td>
<td>
<p>A list (or it will be ignored) with for each dimension
one component, either ‘NULL’ or a character vector.</p>
</td></tr>
<tr><td><code id="garray_+3A_margins">margins</code></td>
<td>
<p>Override the names of dim and of dimnames.</p>
</td></tr>
<tr><td><code id="garray_+3A_sdim">sdim</code></td>
<td>
<p>Optional, a named list of numeric vectors indicating the
subdivision of some of the dimensions.  The value vill become,
after validated, the attribute sdim.  See 'Details'
and '?sdim'.</p>
</td></tr>
<tr><td><code id="garray_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="garray_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized arrays are generalized because they handle dimensions and
subdimensions that are ragged; and they are also smart
because they automatically match dimensions by margins
(names of dimnames).
Margins is implemented similar to R's native class &quot;table&quot;, i.e.,
use names of dimnames to store the margins
</p>
<p>Attribute sdim denotes subdimensions, which are the subdivision of
dimensions or grouping of members of a dimension, for organizing a
ragged array.
It is a named list of numeric vectors, each of which indicates the
lengths of subdivision groups within a dimension.  Every name of the
list prefixed with a margin of the generalized array. By the matching
of sdim names and dim names, utility functions figure out which
dimensions the sub dimensions reside in.  Sum of a vector of the
list usually equals to the extent of the corresponding dimension.
If they are not equal and the extent can not be divided exactly
by the sum, the subdimension is invalid and will be dropped.
If the extent can be divided exactly
by the sum, the subdimension is still valid but non-canonical.
Non-canonical subdimension can be provided to <code>garray()</code> and <code>sdim&lt;-</code>
as argument, and the two functions canonicalize it.
Other utility functions cannot handle non-canonical subdimension,
thus manually constructing objects of garray class is permitted but
dangerous.
Values of each vector of the list denotes the
repeating times of subdimension residing in the coresponding dimension
(called superdim).
More than 1 subdimension reside in the same superdim is allowed.
This feature allows dividing a subdimension further,
organizing the subdims
into hierachy.
</p>
<p>By definition and for S3 dispatching, <code>class(.)="garray"</code> is required, but
simple arrays with proper margins actually work correctly with most
functionalities of this package.  For the sake of compatibility and
reducing warning message, <code>is.garray.duck()</code> tests whether the array
has proper margins.
</p>
<p>A still problem is that attributes in R are fragile, even indexing
will drop most attributes.  Utility functions and methods for
dispatching for 'garray' implemented in this package guaranttee to
save the margins (names of dimnames) and subdimension (attr(*,'sdim')).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>garray.array</code>: A simple and faster version of garray(),
mainly for internal usage.  Note that garray() is not generic function,
thus garray.array() will never be called by dispatching.
</p>
</li>
<li> <p><code>is.garray</code>: <code>is.garray</code> do simple validation, no check for validity
of sdim because it is too expensive.
Operation of sdim by this package is always guaranteed the validity.
</p>
</li>
<li> <p><code>is.garray.duck</code>: <code>is.garray.duck</code> do duck-typing validation, ignoring
the class
</p>
</li>
<li> <p><code>is.scalar</code>: Test whether the vector or array is actually a scalar
(<code>length(x)==1L</code>).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- garray(1:27, c(A=3,B=9), sdim=list(AA=c(a=2,b=1),BB=c(a=3)))
a2 &lt;- garray(1:27, c(A=3,B=9), sdim=list(AA=c(a=2,b=1),BB=c(a=4)))
</code></pre>

<hr>
<h2 id='margins'>The margins and dimensions of a generalized array object</h2><span id='topic+margins'></span><span id='topic+margins+3C-'></span><span id='topic+remargins'></span>

<h3>Description</h3>

<p>Margins means the names of dimnames of an array.
<code>margins&lt;-</code> and <code>remargins</code> are for renaming, but
<code>margins&lt;-</code> ignores the names of <code>value</code> while
<code>remargins</code> according to the names of <code>value</code> renames the margins. Doing
so, <code>remargins</code> may also keep sdim.  <code>margins&lt;-</code> always removes sdim.
For <code>remargins</code> the length of value can be shorter than that of the
margins if the value has names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margins(x)

margins(x) &lt;- value

remargins(x, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="margins_+3A_x">x</code></td>
<td>
<p>A generalized array.</p>
</td></tr>
<tr><td><code id="margins_+3A_value">value</code></td>
<td>
<p>A character vector will become the margins (names of dimnames)
of the generalized array.
<code>margins&lt;-</code> ignores the names of <code>value</code> while
<code>remargins</code> according to the names of <code>value</code> renames the margins.
For <code>remargins</code> the length of value can be shorter than that of the
margins if the value has names.</p>
</td></tr>
</table>

<hr>
<h2 id='print.garray'>Print Values</h2><span id='topic+print.garray'></span>

<h3>Description</h3>

<p>Print out a generalized array and returns it <em>invisibly</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garray'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.garray_+3A_x">x</code></td>
<td>
<p>A generalized array object.</p>
</td></tr>
<tr><td><code id="print.garray_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='psummary'>Parallel summary, inspired by pmax() and pmin().</h2><span id='topic+psummary'></span><span id='topic+psummary.garray'></span><span id='topic+psummary.default'></span>

<h3>Description</h3>

<p>Functions of Summary group are all, any, max, min, prod, range, and sum,
which reduce a vector into a scalar (except range), thus the name
of psummary().  Of course, other FUN can be passed-in,
but functions like range() that returns a non-scalar vector result
in unpredictable return.  For arguments of different
size, pmin() and pmax() make fractional recycling and issue warning,
but psummary() error since as.data.frame() do not fractionally recycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psummary(...)

## S3 method for class 'garray'
psummary(...)

## Default S3 method:
psummary(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psummary_+3A_...">...</code></td>
<td>
<p>Usually in the form <code>psummary(x, y, z, FUN=sum, na.rm=TRUE)</code>,
alternaitvely <code>psummary(list(x, y, z), FUN=sum, na.rm=TRUE)</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='read.ctable'>Read a complex table and return array in basic storagemode.</h2><span id='topic+read.ctable'></span>

<h3>Description</h3>

<p>A complex table has
several row and colume headers, some of which indicate the hierarchy
of the dimensions (thus the returned array may have more dimensions than
row and column), some of which are real row.names and
col.names that will be turn into dimnames, and some of which are
additional attributes.  Cells of non-header are all in a same format
(like double).  The original header are preserved as attributes.
The dimnames strictly save the layout of the matrix, thus row.names
and col.names should be carefully chosen for matching the actual
dimension.  Sometime aperm() is needed after this function.
Sparse table, where dimnames is not complete (unbalanced) and needs
non-fractionally recycling, is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ctable(file, header, row.names, col.names, ...,
  storagemode = "double")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.ctable_+3A_file">file</code></td>
<td>
<p>The name of the file to be read in, see ('file' in ?read.table).</p>
</td></tr>
<tr><td><code id="read.ctable_+3A_header">header</code></td>
<td>
<p>hierarchy structure of the header, a list of length 2,
assigning the index of row and col header,
affecting parsing of the input table;</p>
</td></tr>
<tr><td><code id="read.ctable_+3A_row.names">row.names</code>, <code id="read.ctable_+3A_col.names">col.names</code></td>
<td>
<p>a list, whose elements can be
a character vector assigning the name of one dimension directly, or
a integer scalar which is the index (icol,irow) of row,col-header
that will be extracted; since the row and the col headers can have
hierarchy in the input table and the hierarchy will be organized into
addisional dimensions, rownames indicate the names of dimensions that
are from the row of the input table, while colnames, the col; in the
input table, the header can be in two pattern: AAA and AOO;
in the AAA pattern, the names are repeated for the cells that are in
the same index in high dimension, while in the AOO pattern, the names
appear once at the first and the other cells that are in the same index
in high dimension are left blank; in the
output array, row,col.names are not necessary <code>dimnames[[1]]</code> and
<code>dimnames[[2]]</code>;
if all elements of the list are a integer scalar, then the list can
also be coded as a integer vector (since they are the same for lapply);</p>
</td></tr>
<tr><td><code id="read.ctable_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to ‘read.table’.</p>
</td></tr>
<tr><td><code id="read.ctable_+3A_storagemode">storagemode</code></td>
<td>
<p>The storagemode of return matrix, usually 'double'.</p>
</td></tr>
</table>

<hr>
<h2 id='sdim'>Subdimensions of an array</h2><span id='topic+sdim'></span><span id='topic+sdim+3C-'></span>

<h3>Description</h3>

<p>Retireve or set the subdimension of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdim(x)

sdim(x, warn = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdim_+3A_x">x</code></td>
<td>
<p>A generalized array.</p>
</td></tr>
<tr><td><code id="sdim_+3A_warn">warn</code></td>
<td>
<p>Whether issue warning when some of subdimensions are invalid
and get dropped.</p>
</td></tr>
<tr><td><code id="sdim_+3A_value">value</code></td>
<td>
<p>A named list of numeric vectors indicating the
subdivision of some of the dimensions.  The value vill become,
after validated, the attribute sdim.  See '?garray'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Validation of subdimension is expensive because its consistency with dim need
checking.  Thus most of functions do not validate it.
Operations of subdimension with functions discussed here are guaranteed to
be always keeping the consistency.
</p>


<h3>Value</h3>

<p>The subdimensions (a non-empty list) or NULL
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
