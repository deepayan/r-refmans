<!DOCTYPE html><html lang="en-US"><head><title>Help for package matrixprofiler</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixprofiler}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contrast'><p>Contrast Profile Computation</p></a></li>
<li><a href='#mass'><p>Computes the Distance between the 'data' and the 'query'.</p></a></li>
<li><a href='#matrixprofiler'><p>Matrix Profile for R</p></a></li>
<li><a href='#motifs_discords_small'><p>Just a synthetic dataset for testing</p></a></li>
<li><a href='#mov_mean'><p>Several moving window functions</p></a></li>
<li><a href='#stamp'><p>Matrix Profile Computation</p></a></li>
<li><a href='#znorm'><p>Math Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matrix Profile for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francisco Bischoff &lt;fbischoff@med.up.pt&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is the core functions needed by the 'tsmp' package.  The
    low level and carefully checked mathematical functions are here.
    These are implementations of the Matrix Profile concept that was
    created by CS-UCR <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matrix-profile-foundation/matrixprofiler">https://github.com/matrix-profile-foundation/matrixprofiler</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matrix-profile-foundation/matrixprofiler/issues">https://github.com/matrix-profile-foundation/matrixprofiler/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.1.0), Rcpp (&ge; 1.0.9), RcppParallel (&ge; 5.1.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>debugme (&ge; 1.1.0), spelling (&ge; 2.2.0), testthat (&ge; 3.1.4),
xml2 (&ge; 1.3.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.9), RcppParallel (&ge; 5.1.5), RcppProgress (&ge;
0.4.2), RcppThread (&ge; 2.1.3)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-26 02:13:50 UTC; franz</td>
</tr>
<tr>
<td>Author:</td>
<td>Francisco Bischoff
    <a href="https://orcid.org/0000-0002-5301-8672"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Michael Yeh <a href="https://orcid.org/0000-0002-9807-2963"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Diego Silva <a href="https://orcid.org/0000-0002-5184-9413"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Yan Zhu <a href="https://orcid.org/0000-0002-5952-2108"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Hoang Dau <a href="https://orcid.org/0000-0003-2439-5185"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Michele Linardi <a href="https://orcid.org/0000-0002-3249-2068"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [res, ccp, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-26 12:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='contrast'>Contrast Profile Computation</h2><span id='topic+contrast'></span>

<h3>Description</h3>

<p>Computes the contrast profile of two (classes of) time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrast(
  negative_data,
  positive_data,
  window_size,
  positive_matrix = NULL,
  exclusion_zone = 0.5,
  distance = c("euclidean", "pearson"),
  n_workers = 1L,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrast_+3A_negative_data">negative_data</code></td>
<td>
<p>Required. Any 1-dimension series of numbers (<code>matrix</code>, <code>vector</code>, <code>ts</code> etc.) where the pattern is not present</p>
</td></tr>
<tr><td><code id="contrast_+3A_positive_data">positive_data</code></td>
<td>
<p>Required. Any 1-dimension series of numbers (<code>matrix</code>, <code>vector</code>, <code>ts</code> etc.) where the pattern is present</p>
</td></tr>
<tr><td><code id="contrast_+3A_window_size">window_size</code></td>
<td>
<p>Required. An integer defining the rolling window size.</p>
</td></tr>
<tr><td><code id="contrast_+3A_positive_matrix">positive_matrix</code></td>
<td>
<p>Optional. A precomputed self-similar matrix profile of the positive data.</p>
</td></tr>
<tr><td><code id="contrast_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>A numeric. Defines the size of the area around the rolling window that will be ignored to avoid
trivial matches. Default is <code>0.5</code>, i.e., half of the <code>window_size</code>.</p>
</td></tr>
<tr><td><code id="contrast_+3A_distance">distance</code></td>
<td>
<p>A string. Currently accepts <code>euclidean</code> and <code>pearson</code>. Defaults to <code>euclidean</code>.</p>
</td></tr>
<tr><td><code id="contrast_+3A_n_workers">n_workers</code></td>
<td>
<p>An integer. The number of threads using for computing. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="contrast_+3A_progress">progress</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) will show a progress bar. Useful for long computations.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Constrast Profile</h4>

<p>This algorithm returns the contrast profile of two time series, which shows the position of patters that are similar in the
positive data, but at the same time very dissimilar in the negative data.  In other words, this means that such a pattern
represents well positive data and may be taken as a &quot;signature&quot; of that class. More information can be found in the references.
</p>



<h3>Value</h3>

<p>Returns a <code>list</code> with the <code>contrast_profile</code>, <code>plato</code>, <code>plato_nn</code>, <code>plato_idx</code>, <code>plato_nn_idx</code>, <code>w</code>, <code>ez</code>, <code>euclidean</code>
values
</p>


<h3>References</h3>


<ul>
<li><p> R. Mercer, S. Alaee, A. Abdoli, S. Singh, A. Murillo and E. Keogh, &quot;Matrix Profile XXIII: Contrast Profile:
A Novel Time Series Primitive that Allows Real World Classification,&quot; 2021 IEEE International Conference on Data Mining (ICDM), 2021,
pp. 1240-1245, doi: 10.1109/ICDM51629.2021.00151.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp &lt;- contrast(motifs_discords_small, rev(motifs_discords_small), 50)

</code></pre>

<hr>
<h2 id='mass'>Computes the Distance between the 'data' and the 'query'.</h2><span id='topic+mass'></span><span id='topic+mass_pre'></span>

<h3>Description</h3>

<p>This algorithm will use a rolling window, to computes the distance thorough the whole data. This means that the
minimum distance found is the <em>motif</em> and the maximum distance is the <em>discord</em> on that time series. <strong>Attention</strong>
you need first to create an object using <code>mass_pre()</code>. Read below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass(
  pre_obj,
  data,
  query = data,
  index = 1,
  version = c("v3", "v2"),
  n_workers = 1
)

mass_pre(
  data,
  window_size,
  query = NULL,
  type = c("normalized", "non_normalized", "absolute", "weighted"),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mass_+3A_pre_obj">pre_obj</code></td>
<td>
<p>Required. This is the object resulting from <code>mass_pre()</code>. The is no <em>MASS</em> without a <em>pre</em>.</p>
</td></tr>
<tr><td><code id="mass_+3A_data">data</code></td>
<td>
<p>Required. Any 1-dimension series of numbers (<code>matrix</code>, <code>vector</code>, <code>ts</code> etc.)</p>
</td></tr>
<tr><td><code id="mass_+3A_query">query</code></td>
<td>
<p>Optional. Accepts the same types as <code>data</code> and is used for join-similarity. Defaults to <code>data</code> for
self-similarity. <strong>IMPORTANT</strong> Use the same data used on <code>mass_pre()</code>.</p>
</td></tr>
<tr><td><code id="mass_+3A_index">index</code></td>
<td>
<p>An <code>integer</code>. This is the index of the rolling window that will be used. Must be between <code>1</code> and
<code>length(data) - window_size + 1</code>.</p>
</td></tr>
<tr><td><code id="mass_+3A_version">version</code></td>
<td>
<p>A <code>string</code>. Chooses the version of MASS what will be used. Ignored if <code>mass_pre()</code> is not the
&quot;normalized&quot; type.</p>
</td></tr>
<tr><td><code id="mass_+3A_n_workers">n_workers</code></td>
<td>
<p>An <code>integer</code> The number of threads using for computing. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mass_+3A_window_size">window_size</code></td>
<td>
<p>Required. An integer defining the rolling window size.</p>
</td></tr>
<tr><td><code id="mass_+3A_type">type</code></td>
<td>
<p>This changes how the MASS algorithm will compare the rolling window and the data. (See details).</p>
</td></tr>
<tr><td><code id="mass_+3A_weights">weights</code></td>
<td>
<p>Optional. It is used when the <code>type</code> is <code>weighted</code>, and has to be the same size as the <code>window_size</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are currently four ways to compare the window with the data:
</p>

<ol>
<li> <p><strong>normalized</strong>: this normalizes the data and the query window. This is the most frequently used.
</p>
</li>
<li> <p><strong>non_normalized</strong>: this won't normalize the query window. The data still being normalized.
</p>
</li>
<li> <p><strong>absolute</strong>: this won't normalize both the data and the query window.
</p>
</li>
<li> <p><strong>weighted</strong>: this normalizes the data and query window, and also apply a weight vector on the query.
</p>
</li></ol>



<h3>Value</h3>

<p><code>mass()</code> returns a <code>list</code> with the <code>distance_profile</code> and the <code>last_product</code> that is only useful for computing the
Matrix Profile.
</p>
<p><code>mass_pre()</code> returns a <code>list</code> with several precomputations to be used on MASS later. <strong>Attention</strong> use this before
<code>mass()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pre &lt;- mass_pre(motifs_discords_small, 50)
dist_profile &lt;- mass(pre, motifs_discords_small)
pre &lt;- mass_pre(motifs_discords_small, 50)
dist_profile &lt;- mass(pre, motifs_discords_small)
</code></pre>

<hr>
<h2 id='matrixprofiler'>Matrix Profile for R</h2><span id='topic+matrixprofiler'></span>

<h3>Description</h3>

<p>This package is derived from the former package <code>tsmp</code>. It is intended to make a clear separation of what is the
Matrix Profile computation and what are the data mining process we can do using Matrix Profile.
</p>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its generality,
versatility, simplicity and scalability. In particular it has implications for time series motif discovery, time
series joins, shapelet discovery (classification), density estimation, semantic segmentation, visualization, rule
discovery, clustering etc.
</p>


<h3>Parallel backend</h3>

<p>This package uses RcppParallel in order to do multithreading computations. By default it uses the 'TBB' backend.
If por any reason you want to change the backend to 'tinythread', you may use:
<code>Sys.setenv(RCPP_PARALLEL_BACKEND = "tinythread")</code>. To configure back to 'TBB', use
<code>Sys.setenv(RCPP_PARALLEL_BACKEND = "tbb")</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Zhu Y, Ulanova L, Begum N, Ding Y, Dau HA, et al. Matrix profile I: All pairs similarity joins
for time series: A unifying view that includes motifs, discords and shapelets. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;1317-22.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Imamura m, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A New Primitive for Time
Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Zimmerman Z, Senobari NS, Yeh CM, Funning G. Matrix Profile II : Exploiting a Novel Algorithm
and GPUs to Break the One Hundred Million Barrier for Time Series Motifs and Joins. Icdm. 2016 Jan 22;54(1):739-48.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>

<hr>
<h2 id='motifs_discords_small'>Just a synthetic dataset for testing</h2><span id='topic+motifs_discords_small'></span>

<h3>Description</h3>

<p>Just a synthetic dataset for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>motifs_discords_small
</code></pre>


<h3>Format</h3>

<p>A <code>vector</code> with 875 observations
</p>

<hr>
<h2 id='mov_mean'>Several moving window functions</h2><span id='topic+mov_mean'></span><span id='topic+mov_var'></span><span id='topic+mov_sum'></span><span id='topic+mov_max'></span><span id='topic+mov_min'></span><span id='topic+mov_std'></span><span id='topic+movmean_std'></span><span id='topic+muinvn'></span><span id='topic+zero_crossing'></span>

<h3>Description</h3>

<p>These functions do not handle NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mov_mean(
  data,
  window_size,
  type = c("ogita", "normal", "weighted", "fading"),
  eps = 0.9
)

mov_var(
  data,
  window_size,
  type = c("ogita", "normal", "weighted", "fading"),
  eps = 0.9
)

mov_sum(
  data,
  window_size,
  type = c("ogita", "normal", "weighted", "fading"),
  eps = 0.9
)

mov_max(data, window_size)

mov_min(data, window_size)

mov_std(data, window_size, rcpp = TRUE)

movmean_std(data, window_size, rcpp = TRUE)

muinvn(data, window_size, n_workers = 1)

zero_crossing(data, window_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mov_mean_+3A_data">data</code></td>
<td>
<p>A <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="mov_mean_+3A_window_size">window_size</code></td>
<td>
<p>An <code>integer</code>. The size of the rolling window.</p>
</td></tr>
<tr><td><code id="mov_mean_+3A_type">type</code></td>
<td>
<p>A <code>string</code>. Select between several algorithms. Default is <code>ogita</code> (See details).</p>
</td></tr>
<tr><td><code id="mov_mean_+3A_eps">eps</code></td>
<td>
<p>A <code>numeric</code>. Used only for fading algorithms (See details), otherwise has no effect.</p>
</td></tr>
<tr><td><code id="mov_mean_+3A_rcpp">rcpp</code></td>
<td>
<p>A <code>logical</code>. If <code>TRUE</code> will use the Rcpp implementation, otherwise will use the R implementation,
that may or not be slower.</p>
</td></tr>
<tr><td><code id="mov_mean_+3A_n_workers">n_workers</code></td>
<td>
<p>An <code>integer</code>. The number of threads using for computing. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some functions may use different algorithms to compute the results.
The available types are:
</p>

<ol>
<li> <p><strong>ogita</strong>: This is the default. It uses the Ogita <em>et al.</em>, Accurate Sum, and Dot Product for precision. It is not
the fastest algorithm, but the time spent vs. guarantee of precision worth it.
</p>
</li>
<li> <p><strong>normal</strong>: This uses the <code>cumsum</code> method that is faster, but unreliable in some situations (I have to find the
references, but is true).
</p>
</li>
<li> <p><strong>weighted</strong>: This uses Rodrigues P., <em>et al.</em> algorithm that uses a weighted window for online purposes. The
<code>eps</code> argument controls the factor. (The function is not online yet)
</p>
</li>
<li> <p><strong>fading</strong>: This also uses Rodrigues P., <em>et al.</em> algorithm that in this case, uses a fading factor, also for
online purposes. he <code>eps</code> argument controls the factor. (The function is not online yet)
</p>
</li></ol>

<p>Another important detail is that the <em>standard deviation</em> we use for all computations is the <em>population</em> (i.e.:
divided by <code>n</code>), not the <em>sample</em> (i.e.: divided by <code>n - 1</code>). That is why we also provide the internally the
<code style="white-space: pre;">&#8288;:::std()&#8288;</code> function that computes the <em>population</em>, differently from <code>stats::sd()</code> that is the <em>sample</em> kind. Further
more, <code>movmean_std()</code> shall be used when you need both results in one computation. This is faster than call
<code>mov_mean()</code> followed by <code>mov_std()</code>. Finally, <code>muinvn()</code> is kept like that for historical reasons, as it is the
function used by <code>mpx()</code>. It returns the <code>sig</code> (stable inverse centered norm) instead of <code>std</code> (<code>sig</code> is equals to
<code>1 / (std * sqrt(window_size))</code>).
</p>


<h3>Value</h3>

<p><code>mov_mean()</code> returns a <code>vector</code> with moving <code>avg</code>.
</p>
<p><code>mov_var()</code> returns a <code>vector</code> with moving <code>var</code>.
</p>
<p><code>mov_sum()</code> returns a <code>vector</code> with moving <code>sum</code>.
</p>
<p><code>mov_max()</code> returns a <code>vector</code> with moving <code>max</code>.
</p>
<p><code>mov_min()</code> returns a <code>vector</code> with moving <code>min</code>.
</p>
<p><code>mov_std()</code> returns a <code>vector</code> with moving <code>sd</code>.
</p>
<p><code>movmean_std()</code> returns a <code>list</code> with <code>vectors</code> of the moving <code>avg</code>, <code>sd</code>, <code>sig</code>, <code>sum</code> and <code>sqrsum</code>.
</p>
<p><code>muinvn()</code> returns a <code>list</code> with <code>vectors</code> of moving <code>avg</code> and <code>sig</code>.
</p>
<p><code>zero_crossing()</code> returns a <code>vector</code> of times the data crossed the 'zero' line inside a rolling window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mov &lt;- mov_mean(motifs_discords_small, 50)
mov &lt;- mov_var(motifs_discords_small, 50)
mov &lt;- mov_sum(motifs_discords_small, 50)
mov &lt;- mov_max(motifs_discords_small, 50)
mov &lt;- mov_min(motifs_discords_small, 50)
mov &lt;- mov_std(motifs_discords_small, 50)
mov &lt;- movmean_std(motifs_discords_small, 50)
mov &lt;- muinvn(motifs_discords_small, 50)
zero_cross &lt;- zero_crossing(motifs_discords_small, 50)
</code></pre>

<hr>
<h2 id='stamp'>Matrix Profile Computation</h2><span id='topic+stamp'></span><span id='topic+stomp'></span><span id='topic+scrimp'></span><span id='topic+mpx'></span>

<h3>Description</h3>

<p>STAMP Computes the best so far Matrix Profile and Profile Index for Univariate Time Series.
</p>
<p>STOMP is a faster implementation with the caveat that is not anytime as STAMP or SCRIMP.
</p>
<p>SCRIMP is a faster implementation, like STOMP, but has the ability to return anytime results as STAMP.
</p>
<p>MPX is by far the fastest implementation with the caveat that is not anytime as STAMP or SCRIMP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp(
  data,
  window_size,
  query = NULL,
  exclusion_zone = 0.5,
  s_size = 1,
  n_workers = 1,
  progress = TRUE
)

stomp(
  data,
  window_size,
  query = NULL,
  exclusion_zone = 0.5,
  n_workers = 1,
  progress = TRUE,
  left_right_profile = FALSE
)

scrimp(
  data,
  window_size,
  query = NULL,
  exclusion_zone = 0.5,
  s_size = 1,
  pre_scrimp = 0.25,
  n_workers = 1,
  progress = TRUE
)

mpx(
  data,
  window_size,
  query = NULL,
  exclusion_zone = 0.5,
  s_size = 1,
  idxs = TRUE,
  distance = c("euclidean", "pearson"),
  n_workers = 1,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stamp_+3A_data">data</code></td>
<td>
<p>Required. Any 1-dimension series of numbers (<code>matrix</code>, <code>vector</code>, <code>ts</code> etc.) (See details).</p>
</td></tr>
<tr><td><code id="stamp_+3A_window_size">window_size</code></td>
<td>
<p>Required. An integer defining the rolling window size.</p>
</td></tr>
<tr><td><code id="stamp_+3A_query">query</code></td>
<td>
<p>(not yet on <code>scrimp()</code>) Optional. Another 1-dimension series of numbers for an AB-join similarity.
Default is <code>NULL</code> (See details).</p>
</td></tr>
<tr><td><code id="stamp_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>A numeric. Defines the size of the area around the rolling window that will be ignored to avoid
trivial matches. Default is <code>0.5</code>, i.e., half of the <code>window_size</code>.</p>
</td></tr>
<tr><td><code id="stamp_+3A_s_size">s_size</code></td>
<td>
<p>A numeric. Used on anytime algorithms (stamp, scrimp, mpx) if only part of the computation is needed.
Default is <code>1.0</code> (means 100%).</p>
</td></tr>
<tr><td><code id="stamp_+3A_n_workers">n_workers</code></td>
<td>
<p>An integer. The number of threads using for computing. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="stamp_+3A_progress">progress</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) will show a progress bar. Useful for long computations. (See
details)</p>
</td></tr>
<tr><td><code id="stamp_+3A_left_right_profile">left_right_profile</code></td>
<td>
<p>(<code>stomp()</code> only) A boolean. If <code>TRUE</code>, the function will return the left and right profiles.</p>
</td></tr>
<tr><td><code id="stamp_+3A_pre_scrimp">pre_scrimp</code></td>
<td>
<p>A numeric. If not zero, pre_scrimp is computed, using a fraction of the data. Default is <code>0.25</code>.
This parameter is ignored when using multithread or AB-join.</p>
</td></tr>
<tr><td><code id="stamp_+3A_idxs">idxs</code></td>
<td>
<p>(<code>mpx()</code> only) A logical. Specifies if the computation will return the Profile Index or not. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stamp_+3A_distance">distance</code></td>
<td>
<p>(<code>mpx()</code> only) A string. Currently accepts <code>euclidean</code> and <code>pearson</code>. Defaults to <code>euclidean</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its generality,
versatility, simplicity and scalability. In particular it has implications for time series motif discovery, time
series joins, shapelet discovery (classification), density estimation, semantic segmentation, visualization, rule
discovery, clustering etc.
</p>
<p><code>progress</code>, it is really recommended to use it as feedback for long computations. It indeed adds some
(neglectable) overhead, but the benefit of knowing that your computer is still computing is much bigger than the
seconds you may lose in the final benchmark. About <code>n_workers</code>, for Windows systems, this package uses TBB for
multithreading, and Linux and macOS, use TinyThread++. This may or not raise some issues in the future, so we must be
aware of slower processing due to different mutexes implementations or even unexpected crashes. The Windows version
is usually more reliable. The <code>data</code> and <code>query</code> parameters will be internally converted to a single vector using
<code>as.numeric()</code>, thus, bear in mind that a multidimensional matrix may not work as you expect, but most 1-dimensional
data types will work normally. If <code>query</code> is provided, expect the same pre-procesment done for <code>data</code>; in addition,
<code>exclusion_zone</code> will be ignored and set to <code>0</code>. Both <code>data</code> and <code>query</code> doesn't need to have the same size and they
can be interchanged if both are provided. The difference will be in the returning object. AB-Join returns the Matrix
Profile 'A' and 'B' i.e., the distance between a rolling window from query to data and from data to query.
</p>


<h4>stamp</h4>

<p>The anytime STAMP computes the Matrix Profile and Profile Index in such manner that it can be stopped before its
complete calculation and return the best so far results allowing ultra-fast approximate solutions.
</p>



<h4>stomp</h4>

<p>The STOMP uses a faster implementation to compute the Matrix Profile and Profile Index. It can be stopped earlier by
the user, but the result is not considered anytime, just incomplete. For a anytime algorithm, use <code>stamp()</code> or
<code>scrimp()</code>.
</p>



<h4>scrimp</h4>

<p>The SCRIMP algorithm was the anytime solution for stomp. It is as fast as stomp but allows the user to cancel the
computation and get an approximation of the final result. This implementation uses the SCRIMP++ code. This means
that, at first, it will compute the pre-scrimp (a very fast and good approximation), and continue improving with
scrimp. The exception is if you use multithreading, that skips the pre-scrimp stage.
</p>



<h4>mpx</h4>

<p>This algorithm was developed apart from the main Matrix Profile branch that relies on Fast Fourier Transform (FFT) at
least in one part of the process. This algorithm doesn't use FFT at all and is several times faster. It also relies
on Ogita's work for better precision computing mean and standard deviation (part of the process).
</p>



<h3>Value</h3>

<p>Returns a <code>list</code> with the <code>matrix_profile</code>, <code>profile_index</code> (if <code>idxs</code> is <code>TRUE</code> in <code>mpx()</code>), and some
information about the settings used to build it, like <code>ez</code> and <code>partial</code> when the algorithm is finished early.
</p>


<h3>This document</h3>

<p>Last updated on 2023-01-25 using R version 4.2.2.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Zhu Y, Ulanova L, Begum N, Ding Y, Dau HA, et al. Matrix profile I: All pairs similarity joins
for time series: A unifying view that includes motifs, discords and shapelets. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;1317-22.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Imamura m, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A New Primitive for Time
Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Zimmerman Z, Senobari NS, Yeh CM, Funning G. Matrix Profile II : Exploiting a Novel Algorithm
and GPUs to Break the One Hundred Million Barrier for Time Series Motifs and Joins. Icdm. 2016 Jan 22;54(1):739-48.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p><code>mass()</code> for the underlying algorithm that finds best match of a query.
</p>
<p><code>mpxab()</code> for the forward and reverse join-similarity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- stamp(motifs_discords_small, 50)
mp &lt;- stomp(motifs_discords_small, 50)
mp &lt;- scrimp(motifs_discords_small, 50)
mp &lt;- mpx(motifs_discords_small, 50)
</code></pre>

<hr>
<h2 id='znorm'>Math Functions</h2><span id='topic+znorm'></span><span id='topic+ed_corr'></span><span id='topic+corr_ed'></span><span id='topic+mode'></span><span id='topic+std'></span><span id='topic+normalize'></span><span id='topic+complexity'></span><span id='topic+binary_split'></span>

<h3>Description</h3>

<p><code>znorm()</code>: Normalizes data for mean Zero and Standard Deviation One
</p>
<p><code>ed_corr()</code>: Converts euclidean distances into correlation values
</p>
<p><code>corr_ed()</code>: Converts correlation values into euclidean distances
</p>
<p><code>mode()</code>: Returns the most common value from a vector of integers
</p>
<p><code>std()</code>: Population SD, as R always calculate with n-1 (sample), here we fix it.
</p>
<p><code>normalize()</code>: Normalizes data to be between min and max.
</p>
<p><code>complexity()</code>: Computes the complexity index of the data
</p>
<p><code>binary_split()</code>: Creates a vector with the indexes of binary split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>znorm(data, rcpp = TRUE)

ed_corr(data, w, rcpp = TRUE)

corr_ed(data, w, rcpp = TRUE)

mode(x, rcpp = FALSE)

std(data, na.rm = FALSE, rcpp = TRUE)

normalize(data, min_lim = 0, max_lim = 1, rcpp = FALSE)

complexity(data)

binary_split(n, rcpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="znorm_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="znorm_+3A_rcpp">rcpp</code></td>
<td>
<p>A <code>logical</code>. If <code>TRUE</code> will use the Rcpp implementation, otherwise will use the R implementation,
that may or not be slower.</p>
</td></tr>
<tr><td><code id="znorm_+3A_w">w</code></td>
<td>
<p>the window size</p>
</td></tr>
<tr><td><code id="znorm_+3A_x">x</code></td>
<td>
<p>a <code>vector</code> of <code>integers</code>.</p>
</td></tr>
<tr><td><code id="znorm_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical. If <code>TRUE</code> remove the <code>NA</code> values from the computation.</p>
</td></tr>
<tr><td><code id="znorm_+3A_min_lim">min_lim</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="znorm_+3A_max_lim">max_lim</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="znorm_+3A_n">n</code></td>
<td>
<p>size of the vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>znorm()</code>: Returns the normalized data
</p>
<p><code>ed_corr()</code>: Returns the converted values from euclidean distance to correlation values.
</p>
<p><code>corr_ed()</code>: Returns the converted values from euclidean distance to correlation values.
</p>
<p><code>mode()</code>: Returns the most common value from a vector of integers.
</p>
<p><code>std()</code>: Returns the corrected standard deviation from sample to population.
</p>
<p><code>normalize()</code>: Returns the normalized data between min and max.
</p>
<p><code>complexity()</code>: Returns the complexity index of the data provided (normally a subset).
</p>
<p><code>complexity()</code>: Returns a <code>vector</code> with the binary split indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normalized &lt;- znorm(motifs_discords_small)
fake_data &lt;- c(rep(3, 100), rep(2, 100), rep(1, 100))
correlation &lt;- ed_corr(fake_data, 50)
fake_data &lt;- c(rep(0.5, 100), rep(1, 100), rep(0.1, 100))
euclidean &lt;- corr_ed(fake_data, 50)
fake_data &lt;- c(1, 1, 4, 5, 2, 3, 1, 7, 9, 4, 5, 2, 3)
mode &lt;- mode(fake_data)
fake_data &lt;- c(1, 1.4, 4.3, 5.1, 2, 3.6, 1.24, 2, 9, 4.3, 5, 2.1, 3)
res &lt;- std(fake_data)
fake_data &lt;- c(1, 1.4, 4.3, 5.1, 2, 3.6, 1.24, 1, 9, 4.3, 5, 2.1, 3)
res &lt;- normalize(fake_data)
fake_data &lt;- c(1, 1.4, 4.3, 5.1, 2, 3.6, 1.24, 8, 9, 4.3, 5, 2.1, 3)
res &lt;- complexity(fake_data)
fake_data &lt;- c(10)
res &lt;- binary_split(fake_data)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
