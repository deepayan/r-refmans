<!DOCTYPE html><html><head><title>Help for package georob</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {georob}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#georob-package'><p>The georob Package</p></a></li>
<li><a href='#compress'><p>Compact Storage of Symmetric and Triangular Matrices</p></a></li>
<li><a href='#control.georob'><p>Control Parameters for georob</p></a></li>
<li><a href='#cv'><p>Generic Cross-validation</p></a></li>
<li><a href='#cv.georob'><p>Cross-Validating a Spatial Linear Model Fitted by <code>georob</code></p></a></li>
<li><a href='#default.aniso'><p>Setting Default Values of Variogram Parameters</p></a></li>
<li><a href='#elevation'><p>Elevation Data</p></a></li>
<li><a href='#fit.variogram.model'><p>Fitting Model Functions to Sample Variograms</p></a></li>
<li><a href='#gencorr'><p>Variogram Models</p></a></li>
<li><a href='#georob'><p>Robust Fitting of Spatial Linear Models</p></a></li>
<li><a href='#georobModelBuilding'><p>S3 Methods for Stepwise Building Fixed-Effects Models for Class <code>georob</code></p></a></li>
<li><a href='#georobObject'><p>Fitted georob Object</p></a></li>
<li><a href='#georobS3methods'><p>Common S3 Methods for Class <code>georob</code></p></a></li>
<li><a href='#georobSimulation'><p>Simulating Realizations of Gaussian Processes</p></a></li>
<li><a href='#internal.functions'><p>Internal Functions of Package <span class="pkg">georob</span></p></a></li>
<li><a href='#lgnpp'><p>Unbiased Back-Transformations for Log-normal Kriging</p></a></li>
<li><a href='#param.names'><p>Names and Permissible Ranges of Variogram Parameters</p></a></li>
<li><a href='#plot.georob'><p>Plot Methods for Class <code>georob</code></p></a></li>
<li><a href='#pmm'><p>Parallelized Matrix Multiplication</p></a></li>
<li><a href='#predict.georob'><p>Predict Method for Robustly Fitted Spatial Linear Models</p></a></li>
<li><a href='#profilelogLik'><p>Profile Likelihood</p></a></li>
<li><a href='#reexported-fun'><p>Re-Exported Functions from <span class="rlang"><b>R</b></span> package imports</p></a></li>
<li><a href='#sample.variogram'><p>Computing (Robust) Sample Variograms of Spatial Data</p></a></li>
<li><a href='#validate.predictions'><p>Summary Statistics of (Cross-)Validation Prediction Errors</p></a></li>
<li><a href='#wolfcamp'><p>Wolfcamp Aquifer Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3-19</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-09</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Geostatistical Analysis of Spatial Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for efficiently fitting linear models with spatially correlated errors by robust (Kuensch et al. (2011) &lt;<a href="https://doi.org/10.3929%2Fethz-a-009900710">doi:10.3929/ethz-a-009900710</a>&gt;) and Gaussian (Harville (1977) &lt;<a href="https://doi.org/10.1080%2F01621459.1977.10480998">doi:10.1080/01621459.1977.10480998</a>&gt;) (Restricted) Maximum Likelihood and for computing robust and customary point and block external-drift Kriging predictions (Cressie (1993) &lt;<a href="https://doi.org/10.1002%2F9781119115151">doi:10.1002/9781119115151</a>&gt;), along with utility functions for variogram modelling in ad hoc geostatistical analyses, model building, model evaluation by cross-validation, (conditional) simulation of Gaussian processes (Davies and Bryant (2013) &lt;<a href="https://doi.org/10.18637%2Fjss.v055.i09">doi:10.18637/jss.v055.i09</a>&gt;), unbiased back-transformation of Kriging predictions of log-transformed data (Cressie (2006) &lt;<a href="https://doi.org/10.1007%2Fs11004-005-9022-8">doi:10.1007/s11004-005-9022-8</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.14), sp(&ge; 0.9-60)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, constrainedKriging(&ge; 0.2-7), fields, graphics, lmtest,
methods, nlme, nleqslv, parallel, quantreg, robustbase(&ge;
0.90-2), snowfall, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gstat, multcomp, lattice</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | <a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: GPL (&ge; 2) | LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-09 17:18:36 UTC; papritz</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Papritz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Papritz &lt;papritz@retired.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-10 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='georob-package'>The georob Package</h2><span id='topic+georob-package'></span><span id='topic+georobPackage'></span><span id='topic+georobIntro'></span>

<h3>Description</h3>

<p>This is a summary of the features and functionality of
<span class="pkg">georob</span>, a package in <span class="rlang"><b>R</b></span> for customary and robust geostatistical
analyses.</p>


<h3>Details</h3>

<p><span class="pkg">georob</span> is a package for customary and robust analyses of
geostatistical data.
Such data, say <code class="reqn">y_i=y(\boldsymbol{s}_i)</code>, are
recorded at a set of locations,
<code class="reqn">\boldsymbol{s}_i</code>, <code class="reqn">i=1,2, \ldots, n</code>, in a
domain <code class="reqn">G \in \mathrm{I}\!\mathrm{R}^d</code>, <code class="reqn">d \in (1,2,3)</code>, along
with covariate information
<code class="reqn">x_j(\boldsymbol{s}_i)</code>, <code class="reqn">j=1,2,
  \ldots, p</code>.
</p>



<h4>Model</h4>

<p>We use the following model for the data
<code class="reqn">y_i=y(\boldsymbol{s}_{i})</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y(\boldsymbol{s}_i) =
      Z(\boldsymbol{s}_i) + \varepsilon =
      \boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
         \boldsymbol{\beta} +
      B(\boldsymbol{s}_i) +
      \varepsilon_i,</code>
</p>

<p>where
<code class="reqn">Z(\boldsymbol{s}_i)=\boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
         \boldsymbol{\beta} +
      B(\boldsymbol{s}_i)</code> is the so-called signal,
<code class="reqn">\boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
      \boldsymbol{\beta}</code>
is the external drift,
<code class="reqn">\{B(\boldsymbol{s})\}</code> is an unobserved stationary or
intrinsic spatial Gaussian random field with zero mean, and
<code class="reqn">\varepsilon_i</code> is an
<em>i.i.d</em> error from a possibly long-tailed distribution with scale parameter
<code class="reqn">\tau</code> (<code class="reqn">\tau^2</code> is usually called nugget effect).
In vector form the model is written as
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{Y} = \boldsymbol{X} \boldsymbol{\beta} + \boldsymbol{B} + \boldsymbol{\varepsilon},</code>
</p>

<p>where <code class="reqn">\boldsymbol{X}</code> is the model matrix with the
rows
<code class="reqn">\boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}</code>.
</p>
<p>The (generalized) covariance matrix of the vector of
spatial Gaussian random effects
<code class="reqn">\boldsymbol{B}</code>
is denoted by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{E}[
      \boldsymbol{B}\,
      \boldsymbol{B}^\mathrm{T}] =
      \boldsymbol{\Gamma}_\theta =
      \sigma_{\mathrm{n}}^2\boldsymbol{I} +
      \sigma^2\boldsymbol{V}_\alpha =
      \sigma_B^2 \, \boldsymbol{V}_{\alpha,\xi} =
      \sigma_B^2 \, ((1-\xi) \, \boldsymbol{I} +
      \xi\, \boldsymbol{V}_\alpha )
      ,</code>
</p>

<p>where
<code class="reqn">\sigma_{\mathrm{n}}^2</code>
is the variance of seemingly uncorrelated micro-scale variation in
<code class="reqn">B(\boldsymbol{s})</code>
that cannot be resolved with the chosen sampling design,
<code class="reqn">\boldsymbol{I}</code> is the identity matrix,
<code class="reqn">\sigma^2</code> is the variance of the captured auto-correlated variation in
<code class="reqn">B(\boldsymbol{s})</code>,
<code class="reqn">\sigma_B^2=\sigma_{\mathrm{n}}^2+\sigma^2</code>
is the signal variance, and
<code class="reqn">\xi=\sigma^2/\sigma_B^2</code>.
To estimate both
<code class="reqn">\sigma_{\mathrm{n}}^2</code> and <code class="reqn">\tau^2</code> (and not only their sum), one needs
replicated measurements for some of the
<code class="reqn">\boldsymbol{s}_i</code>.
</p>
<p>We define
<code class="reqn">\boldsymbol{V}_{\alpha}</code>
to be the (generalized) correlation matrix with elements
</p>
<p style="text-align: center;"><code class="reqn">(\boldsymbol{V}_{\alpha})_{ij} =
      \gamma_0 - \gamma(|\boldsymbol{A}\;(
      \boldsymbol{s}_i-\boldsymbol{s}_j)|),</code>
</p>

<p>where the constant <code class="reqn">\gamma_0</code> is chosen large enough so that
<code class="reqn">\boldsymbol{V}_{\alpha}</code>
is positive definite,
<code class="reqn">\gamma(\cdot)</code> is a valid stationary or intrinsic variogram, and
<code class="reqn">\boldsymbol{A} =
      \boldsymbol{A}(\alpha, f_1, f_2; \omega, \phi, \zeta)</code>
is a matrix that is used to model geometrically anisotropic auto-correlation.
In more detail,
<code class="reqn">\boldsymbol{A}</code>
maps an arbitrary point on an ellipsoidal surface with constant semi-variance in
<code class="reqn"> \mathrm{I}\!\mathrm{R}^3</code>,
centred on the origin, and having lengths of semi-principal axes,
<code class="reqn">\boldsymbol{p}_1</code>,
<code class="reqn">\boldsymbol{p}_2</code>,
<code class="reqn">\boldsymbol{p}_3</code>,
equal to
<code class="reqn">|\boldsymbol{p}_1|=\alpha</code>,
<code class="reqn">|\boldsymbol{p}_2|=f_1\,\alpha</code> and
<code class="reqn">|\boldsymbol{p}_3|=f_2\,\alpha</code>,
<code class="reqn">0 &lt; f_2 \leq f_1 \leq 1</code>,
respectively, onto the surface of the unit ball centred on the origin.
</p>
<p>The orientation of the ellipsoid is defined by the three angles
<code class="reqn">\omega</code>, <code class="reqn">\phi</code> and <code class="reqn">\zeta</code>:
</p>

<dl>
<dt><code class="reqn">\omega</code></dt><dd><p>is the azimuth of <code class="reqn">\boldsymbol{p}_1</code>
(= angle between north and the projection
of
<code class="reqn">\boldsymbol{p}_1</code>
onto the <code class="reqn">x</code>-<code class="reqn">y</code>-plane,
measured from north to south positive clockwise in degrees),
</p>
</dd>
<dt><code class="reqn">\phi</code></dt><dd><p>is 90 degrees minus the latitude of
<code class="reqn">\boldsymbol{p}_1</code>
(= angle between the zenith and
<code class="reqn">\boldsymbol{p}_1</code>,
measured from zenith to nadir positive clockwise in degrees), and
</p>
</dd>
<dt><code class="reqn">\zeta</code></dt><dd><p>is the angle between
<code class="reqn">\boldsymbol{p}_2</code>
and the direction of the line, say <code class="reqn">y^\prime</code>,
defined by the intersection between the
<code class="reqn">x</code>-<code class="reqn">y</code>-plane and the plane orthogonal to
<code class="reqn">\boldsymbol{p}_1</code> running through the origin
(<code class="reqn">\zeta</code> is measured from <code class="reqn">y^\prime</code> positive counter-clockwise in degrees).
</p>
</dd>
</dl>

<p>The transformation matrix is given by
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{A}=
      \left(\begin{array}{ccc}
        1/\alpha &amp; 0 &amp; 0\\
        0 &amp; 1/(f_1\,\alpha) &amp; 0\\
        0 &amp; 0 &amp; 1/(f_2\,\alpha) \\
      \end{array}\right)
      (
        \boldsymbol{C}_1,
        \boldsymbol{C}_2,
        \boldsymbol{C}_3,
      )
    </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{C}_1^\mathrm{T} = ( \sin\omega \sin\phi, -\cos\omega \cos\zeta - \sin\omega \cos\phi \sin\zeta, \cos\omega \sin\zeta - \sin\omega \cos\phi \cos\zeta )
    </code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{C}_2^\mathrm{T} = ( \cos\omega \sin\phi, \sin\omega \cos\zeta - \cos\omega \cos\phi \sin\zeta, -\sin\omega \sin\zeta - \cos\omega \cos\phi\cos\zeta )
    </code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{C}_3^\mathrm{T} = (\cos\phi, \sin\phi \sin\zeta, \sin\phi \cos\zeta )
    </code>
</p>

<p>To model geometrically anisotropic variograms in
<code class="reqn"> \mathrm{I}\!\mathrm{R}^2</code>
one has to set <code class="reqn">\phi=90</code> and <code class="reqn">f_2 = 1</code>,
and for <code class="reqn">f_1 = f_2 = 1</code>
one obtains the model for isotropic auto-correlation
with range parameter <code class="reqn">\alpha</code>.
Note that for isotropic auto-correlation the software processes data for
which <code class="reqn">d</code> may exceed 3.
</p>
<p>Two remarks are in order:
</p>

<ol>
<li><p> Clearly, the (generalized) covariance matrix of the observations
<code class="reqn">\boldsymbol{Y}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Cov}[\boldsymbol{Y},\boldsymbol{Y}^\mathrm{T}]
        = \tau^2 \boldsymbol{I} + \boldsymbol{\Gamma}_\theta.
      </code>
</p>

</li>
<li><p> Depending on the context, the term &ldquo;variogram
parameters&rdquo; denotes sometimes all parameters of a geometrically
anisotropic variogram model, but in places only the parameters of an
isotropic variogram model, i.e. <code class="reqn">\sigma^2, \ldots, \alpha,
      \ldots</code> and <code class="reqn">f_1, \ldots, \zeta</code> are denoted by the term
&ldquo;anisotropy parameters&rdquo;.  In the sequel
<code class="reqn">\boldsymbol{\theta}</code> is used to denote all
variogram and anisotropy parameters except the nugget effect
<code class="reqn">\tau^2</code>.
</p>
</li></ol>




<h4>Estimation</h4>

<p>The unobserved spatial random effects
<code class="reqn">\boldsymbol{B}</code> at the data locations
<code class="reqn">\boldsymbol{s}_i</code>
and the model parameters
<code class="reqn">\boldsymbol{\beta}</code>, <code class="reqn">\tau^2</code> and
<code class="reqn">\boldsymbol{\theta}^\mathrm{T} =
      (\sigma^2, \sigma_{\mathrm{n}}^2, \alpha, \ldots,  f_{1}, f_{2},
        \omega, \phi, \zeta)
    </code>
are unknown and are estimated in <span class="pkg">georob</span> either by Gaussian
(<cite>Harville, 1977</cite>) or robust (<cite>Künsch et al., 2011</cite>)
restricted maximum likelihood (REML) or
Gaussian maximum likelihood (ML). Here <var>...</var>
denote further parameters of the variogram such as the smoothness parameter
of the Whittle-Matérn model.
</p>
<p>In brief, the robust REML method is based on the insight that for
given <code class="reqn">\boldsymbol{\theta}</code> and <code class="reqn">\tau^2</code> the
Kriging predictions (= BLUP) of
<code class="reqn">\boldsymbol{B}</code> and the generalized least
squares (GLS = ML) estimates of
<code class="reqn">\boldsymbol{\beta}</code> can be obtained
simultaneously by maximizing
</p>
<p style="text-align: center;"><code class="reqn">
      - \sum_i
        \left(
          \frac{
            y_i -
            \boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
            \boldsymbol{\beta} -
            B(\boldsymbol{s}_i)
          }{\tau}
        \right)^2 -
        \boldsymbol{B}^{\mathrm{T}}
        \boldsymbol{\Gamma}^{-1}_\theta
        \boldsymbol{B}
    </code>
</p>

<p>with respect to
<code class="reqn">\boldsymbol{B}</code> and
<code class="reqn">\boldsymbol{\beta}</code>, e.g.
<cite>Harville (1977)</cite>.

Hence, the BLUP of <code class="reqn">\boldsymbol{B}</code>,
ML estimates of <code class="reqn">\boldsymbol{\beta}</code>,
<code class="reqn">\boldsymbol{\theta}</code> and <code class="reqn">\tau^2</code>
are obtained by maximizing
</p>
<p style="text-align: center;"><code class="reqn">
      - \log(\det(
        \tau^2 \boldsymbol{I} +
        \boldsymbol{\Gamma}_\theta
      )) -
      \sum_i
        \left(
          \frac{
            y_i -
            \boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
            \boldsymbol{\beta} -
            B(\boldsymbol{s}_i)
          }{\tau}
        \right)^2 -
        \boldsymbol{B}^{\mathrm{T}}
        \boldsymbol{\Gamma}^{-1}_\theta
        \boldsymbol{B}
    </code>
</p>

<p>jointly with respect to
<code class="reqn">\boldsymbol{B}</code>,
<code class="reqn">\boldsymbol{\beta}</code>,
<code class="reqn">\boldsymbol{\theta}</code> and  <code class="reqn">\tau^2</code>
or by solving the respective estimating equations.
</p>
<p>The estimating equations can then by robustified by
</p>

<ul>
<li><p> replacing the standardized errors, say
<code class="reqn">\varepsilon_i/\tau = (
          y_i - \boldsymbol{x}(\boldsymbol{s}_i)^\mathrm{T}
          \boldsymbol{\beta} -
          B(\boldsymbol{s}_i)
        ) / \tau</code>,
by a bounded or re-descending <code class="reqn">\psi</code>-function,
<code class="reqn">\psi_c(\varepsilon_i/\tau)</code>,
of them (e.g. <cite>Maronna et al, 2006, chap. 2</cite>) and by
</p>
</li>
<li><p> introducing suitable bias correction terms for Fisher consistency at
the Gaussian model,
</p>
</li></ul>

<p>see <cite>Künsch et al. (2011)</cite> for details.
The robustified estimating equations
are solved numerically by a combination of iterated re-weighted least squares
(IRWLS) to estimate <code class="reqn">\boldsymbol{B}</code> and
<code class="reqn">\boldsymbol{\beta}</code> for given
<code class="reqn">\boldsymbol{\theta}</code> and <code class="reqn">\tau^2</code>
and nonlinear root finding by the function
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> of the <span class="rlang"><b>R</b></span> package <span class="pkg">nleqslv</span>
to get <code class="reqn">\boldsymbol{\theta}</code> and  <code class="reqn">\tau^2</code>.
The robustness of the procedure is controlled by the tuning parameter <code class="reqn">c</code>
of the <code class="reqn">\psi_c</code>-function. For <code class="reqn">c \ge 1000</code> the algorithm computes
Gaussian (RE)ML estimates and customary plug-in Kriging predictions.
Instead of solving the Gaussian (RE)ML estimating equations, our software then
maximizes the Gaussian (restricted) log-likelihood using  <code><a href="stats.html#topic+nlminb">nlminb</a></code> or
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p><span class="pkg">georob</span> uses variogram models that were provided formerly by the
now archived <span class="rlang"><b>R</b></span> package <span class="pkg">RandomFields</span> and are now implemented in
the function <code><a href="#topic+gencorr">gencorr</a></code> of <span class="pkg">georob</span>.
Currently, estimation of the parameters of the following models is
implemented:
</p>
<p><code>"RMaskey"</code>, <code>"RMbessel"</code>, <code>"RMcauchy"</code>,
<code>"RMcircular"</code>, <code>"RMcubic"</code>, <code>"RMdagum"</code>, <br />
<code>"RMdampedcos"</code>, <code>"RMdewijsian"</code>, <code>"RMexp"</code> (default),
<code>"RMfbm"</code>, <code>"RMgauss"</code>, <br /> <code>"RMgencauchy"</code>,
<code>"RMgenfbm"</code>, <code>"RMgengneiting"</code>, <code>"RMgneiting"</code>,
<code>"RMlgd"</code>, <br /> <code>"RMmatern"</code>, <code>"RMpenta"</code>, <code>"RMqexp"</code>,
<code>"RMspheric"</code>, <code>"RMstable"</code>, <code>"RMwave"</code>, <br />
<code>"RMwhittle"</code>.
</p>
<p>For most variogram parameters, closed-form expressions of <code class="reqn">\partial
    \gamma/ \partial \theta_i</code> and <code class="reqn">\partial \gamma/
    \partial \tau^2</code> are used in the computations.
However, for the parameter <code class="reqn">\nu</code> of the models <code>"RMbessel"</code>,
<code>"RMmatern"</code> and <code>"RMwhittle"</code> <code class="reqn">\partial \gamma/ \partial
    \nu</code> is evaluated numerically by the function
<code><a href="stats.html#topic+numericDeriv">numericDeriv</a></code>, and this results in an increase in
computing time when <code class="reqn">\nu</code> is estimated.  </p>




<h4>Prediction</h4>

<p>Customary and robust plug-in external drift point Kriging predictions
can be computed for an non-sampled location
<code class="reqn">\boldsymbol{s}_0</code>
from the covariates
<code class="reqn">\boldsymbol{x}(\boldsymbol{s}_0)</code>,
the estimated parameters
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>,
<code class="reqn">\widehat{\boldsymbol{\theta}}</code>
and the predicted random effects
<code class="reqn">\widehat{\boldsymbol{B}}</code>
by
</p>
<p style="text-align: center;"><code class="reqn">
      \widehat{Y}(\boldsymbol{s}_0) = \widehat{Z}(\boldsymbol{s}_0) =
      \boldsymbol{x}(\boldsymbol{s}_0)^\mathrm{T}
      \widehat{\boldsymbol{\beta}} +
      \boldsymbol{\gamma}^\mathrm{T}_{\widehat{\theta}}(\boldsymbol{s}_0)
      \boldsymbol{\Gamma}^{-1}_{\widehat{\theta}}
      \widehat{\boldsymbol{B}},
    </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Gamma}_{\widehat{\theta}}</code>
is the estimated (generalized) covariance matrix of
<code class="reqn">\boldsymbol{B}</code> and
<code class="reqn">\boldsymbol{\gamma}_{\widehat{\theta}}(\boldsymbol{s}_0)</code>
is the vector with the estimated (generalized) covariances between
<code class="reqn">\boldsymbol{B}</code> and
<code class="reqn">B(\boldsymbol{s}_0)</code>.
Kriging variances can be computed as well, based on approximated covariances of
<code class="reqn">\widehat{\boldsymbol{B}}</code> and
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>
(see <cite>Künsch et al., 2011</cite>, and appendices of
<cite>Nussbaum et al., 2014</cite>, for details).
</p>
<p>The package <span class="pkg">georob</span> provides in addition software for computing
customary and robust external drift <em>block</em> Kriging predictions.
The required integrals of the generalized covariance function are
computed by functions of the <span class="rlang"><b>R</b></span> package <span class="pkg">constrainedKriging</span>.  </p>




<h4>Functionality</h4>

<p>For the time being, the functionality of <span class="pkg">georob</span> is limited
to geostatistical analyses of <em>single</em> response variables.
No software is currently available for customary and robust
multivariate geostatistical analyses.
<span class="pkg">georob</span> offers functions for:
</p>

<ol>
<li><p> Robustly fitting a spatial linear model to data that are
possibly contaminated by independent errors from a long-tailed
distribution by robust REML (see functions <code><a href="#topic+georob">georob</a></code> &mdash;
which also fits such models efficiently by Gaussian (RE)ML &mdash;
<code><a href="#topic+profilelogLik">profilelogLik</a></code> and <code><a href="#topic+control.georob">control.georob</a></code>).
</p>
</li>
<li><p> Extracting estimated model components (see
<code><a href="#topic+residuals.georob">residuals.georob</a></code>, <code><a href="#topic+rstandard.georob">rstandard.georob</a></code>,

<code><a href="#topic+ranef.georob">ranef.georob</a></code>).
</p>
</li>
<li><p> Robustly estimating sample variograms and for fitting variogram
model functions to them (see <code><a href="#topic+sample.variogram">sample.variogram</a></code> and
<code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>).
</p>
</li>
<li><p> Model building by forward and backward selection of covariates
for the external drift (see <code><a href="#topic+waldtest.georob">waldtest.georob</a></code>,
<code><a href="#topic+step.georob">step.georob</a></code>, <code><a href="#topic+add1.georob">add1.georob</a></code>,
<code><a href="#topic+drop1.georob">drop1.georob</a></code>, <code><a href="#topic+extractAIC.georob">extractAIC.georob</a></code>, <br />
<code><a href="#topic+logLik.georob">logLik.georob</a></code>, <code><a href="#topic+deviance.georob">deviance.georob</a></code>).  For a
robust fit, the log-likelihood is not defined.  The function then
computes the (restricted) log-likelihood of an equivalent Gaussian
model with heteroscedastic nugget (see <code><a href="#topic+deviance.georob">deviance.georob</a></code>
for details).
</p>
</li>
<li><p> Assessing the goodness-of-fit and predictive power of the model
by <var>K</var>-fold cross-validation (see <code><a href="#topic+cv.georob">cv.georob</a></code> and
<code><a href="#topic+validate.predictions">validate.predictions</a></code>).
</p>
</li>
<li><p> Computing customary and robust external drift point and block
Kriging predictions (see <code><a href="#topic+predict.georob">predict.georob</a></code>,
<code><a href="#topic+control.predict.georob">control.predict.georob</a></code>).
</p>
</li>
<li><p> Unbiased back-transformation of both point and block Kriging
predictions of log-transformed data to the original scale of the
measurements (see <code><a href="#topic+lgnpp">lgnpp</a></code>).
</p>
</li>
<li><p> Computing unconditional and conditional Gaussian simulations
from a fitted spatial linear model (see <code><a href="#topic+condsim">condsim</a></code>).
</p>
</li></ol>




<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Harville, D. A. (1977) Maximum likelihood approaches to variance
component estimation and to related problems, <em>Journal of the
American Statistical Association</em>, <b>72</b>, 320&ndash;340,
<a href="https://doi.org/10.1080/01621459.1977.10480998">doi:10.1080/01621459.1977.10480998</a>.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A.
(in preparation) Robust Geostatistics.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A.
(2011) Robust estimation of the external drift and the variogram of
spatial data.  Proceedings of the ISI 58th World Statistics Congress of
the International Statistical Institute.  <a href="https://doi.org/10.3929/ethz-a-009900710">doi:10.3929/ethz-a-009900710</a>
</p>
<p>Maronna, R. A., Martin, R. D. and Yohai, V. J. (2006) <em>Robust
Statistics Theory and Methods</em>, Wiley, Hoboken, <a href="https://doi.org/10.1002/0470010940">doi:10.1002/0470010940</a>.
</p>
<p>Nussbaum, M., Papritz, A., Baltensweiler, A. and Walthert, L. (2014)
Estimating soil organic carbon stocks of Swiss forest soils by robust
external-drift kriging.  <em>Geoscientific Model Development</em>,
<b>7</b>, 1197&ndash;1210.  <a href="https://doi.org/10.5194/gmd-7-1197-2014">doi:10.5194/gmd-7-1197-2014</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>

<hr>
<h2 id='compress'>Compact Storage of Symmetric and Triangular Matrices</h2><span id='topic+compress'></span><span id='topic+expand'></span>

<h3>Description</h3>

<p>The utility function <code>compress</code> stores symmetric or triangular
matrices compactly by retaining only the diagonal and either the
lower or upper off-diagonal elements.  The function <code>expand</code>
restores such compressed matrices again to a square form.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  compress(m)

  expand(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_+3A_m">m</code></td>
<td>
<p>either a single symmetric, lower or upper triangular
matrix or a list of such matrices.  The type of <code>m</code> (or of its
component matrices) must be defined by the attribute <code>struc</code> with
possible values <code>"sym"</code> (symmetric), <code>"lt"</code> (lower triangular)
or <code>"ut"</code> (upper triangular).</p>
</td></tr>
<tr><td><code id="compress_+3A_object">object</code></td>
<td>
<p>a single compressed matrix or a list of such matrices
generated by <code>compress</code>, see <em>Value</em>.  The type of
<code>object</code> (or of its components) must be defined by the
attribute <code>struc</code> with possible values <code>"sym"</code> (symmetric),
<code>"lt"</code> (lower triangular) or <code>"ut"</code> (upper triangular).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>m</code> is a single square matrix then <code>compress</code> generates a
compressed matrix, which is a list with two components:
</p>
<table>
<tr><td><code>diag</code></td>
<td>
<p>a vector with the diagonal elements of <code>m</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>a vector with off-diagonal elements.</p>
</td></tr>
</table>
<p>If <code>m</code> is a list of square matrices then the result is also a list
of compressed matrices.
</p>
<p><code>expand</code> creates a square matrix if <code>object</code> is a list with
components <code>diag</code> and <code>tri</code> and a list of square matrices if
<code>object</code> is a list of such lists.  If <code>m</code> or <code>objects</code> are
lists that contain other components than square or compressed matrices
then these additional components are returned unchanged.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

r.logzn.rob &lt;- georob(log(zinc) ~ sqrt(dist) + ffreq, data = meuse,
    locations = ~ x + y, variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1)

cov2cor(expand(r.logzn.rob[["cov"]][["cov.betahat"]]))
</code></pre>

<hr>
<h2 id='control.georob'>Control Parameters for georob</h2><span id='topic+control.georob'></span><span id='topic+param.transf'></span><span id='topic+fwd.transf'></span><span id='topic+dfwd.transf'></span><span id='topic+bwd.transf'></span><span id='topic+control.rq'></span><span id='topic+control.nleqslv'></span><span id='topic+control.optim'></span><span id='topic+control.nlminb'></span>

<h3>Description</h3>

<p>This page documents parameters used to control <code><a href="#topic+georob">georob</a></code>.  It
describes the arguments of the functions <code>control.georob</code>,
<code>param.transf</code>, <code>fwd.transf</code>, <code>dfwd.transf</code>,
<code>bwd.transf</code>, <code>control.rq</code>, <code>control.nleqslv</code>,
<code>control.nlminb</code> and <code>control.optim</code>, which all serve to
control the behaviour of <code><a href="#topic+georob">georob</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.georob(ml.method = c("REML", "ML"), reparam = TRUE,
    maximizer = c("nlminb", "optim"), initial.param = TRUE,
    initial.fixef = c("lmrob", "rq", "lm"), bhat = NULL,
    min.rweight = 0.25,
    param.tf = param.transf(), fwd.tf = fwd.transf(),
    deriv.fwd.tf = dfwd.transf(), bwd.tf = bwd.transf(),
    psi.func = c("logistic", "t.dist", "huber"),
    irwls.maxiter = 50,
    irwls.ftol = 1.e-5, force.gradient = FALSE,
    min.condnum = 1.e-12, zero.dist = sqrt(.Machine[["double.eps"]]),
    error.family.estimation = c("gaussian", "long.tailed"),
    error.family.cov.effects = c("gaussian", "long.tailed"),
    error.family.cov.residuals = c("gaussian", "long.tailed"),
    cov.bhat = TRUE, full.cov.bhat = FALSE, cov.betahat = TRUE,
    cov.delta.bhat = TRUE, full.cov.delta.bhat = TRUE,
    cov.delta.bhat.betahat = TRUE,
    cov.ehat = TRUE, full.cov.ehat = FALSE,
    cov.ehat.p.bhat = FALSE, full.cov.ehat.p.bhat = FALSE,
    hessian = TRUE,
    rq = control.rq(), lmrob = lmrob.control(),
    nleqslv = control.nleqslv(),
    optim = control.optim(), nlminb = control.nlminb(),
    pcmp = control.pcmp(), ...)

param.transf(variance = "log", snugget = "log", nugget = "log", scale = "log",
    alpha = c(
      RMaskey = "log", RMdewijsian = "logit2", RMfbm = "logit2", RMgencauchy = "logit2",
      RMgenfbm = "logit2", RMlgd = "identity", RMqexp = "logit1", RMstable = "logit2"
    ),
    beta = c(RMdagum = "logit1", RMgencauchy = "log", RMlgd = "log"),
    delta = "logit1", gamma = c(RMcauchy = "log", RMdagum = "logit1"),
    kappa = "logit3", lambda = "log", mu = "log", nu = "log",
    f1 = "log", f2  ="log", omega = "identity", phi = "identity", zeta = "identity")

fwd.transf(...)

dfwd.transf(...)

bwd.transf(...)

control.rq(tau = 0.5, rq.method = c("br", "fnb", "pfn"),
    rq.alpha = 0.1, ci = FALSE, iid = TRUE,
    interp = TRUE, tcrit = TRUE, rq.beta = 0.99995, eps = 1e-06,
    Mm.factor = 0.8, max.bad.fixup = 3, ...)

control.nleqslv(method = c("Broyden", "Newton"),
    global = c("dbldog", "pwldog", "qline", "gline", "none"),
    xscalm = c("fixed", "auto"), control = list(ftol = 1e-04), ...)

control.optim(method = c("BFGS", "Nelder-Mead", "CG",
        "L-BFGS-B", "SANN", "Brent"), lower = -Inf, upper = Inf,
    control = list(reltol = 1e-05), ...)

control.nlminb(control = list(rel.tol = 1.e-5), lower = -Inf,
    upper = Inf, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.georob_+3A_ml.method">ml.method</code></td>
<td>
<p>a character keyword defining whether Gaussian maximum
likelihood (<code>ML</code>) or restricted maximum likelihood (<code>REML</code>
default) estimates will be computed (ignored if <code>tuning.psi &lt;=
  tuning.psi.nr</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_reparam">reparam</code></td>
<td>
<p>a logical scalar.  If <code>TRUE</code> (default) the
re-parametrized variance parameters <code class="reqn">\sigma_B^2</code>, <code class="reqn">\eta</code> and
<code class="reqn">\xi</code> are estimated by Gaussian (RE)ML, otherwise the original
parameters <code class="reqn">\tau^2</code>, <code class="reqn">\sigma_{\mathrm{n}}^2</code> and
<code class="reqn">\sigma^2</code> (cf.  subsection <em>Estimating variance parameters by
Gaussian (RE)ML</em>, section <em>Details</em> of <code><a href="#topic+georob">georob</a></code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_maximizer">maximizer</code></td>
<td>
<p>a character keyword defining whether the Gaussian
(restricted) log-likelihood is maximized by <code><a href="stats.html#topic+nlminb">nlminb</a></code>
(default) or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_initial.param">initial.param</code></td>
<td>
<p>a logical scalar, controlling whether initial values
of variogram parameters are computed for solving the robustified
estimating equations of the variogram and anisotropy parameters.  If
<code>initial.param = TRUE</code> (default) robust initial values of parameters
are computed by discarding outlying observations based on the
&ldquo;robustness weights&rdquo; of the initial fit of the regression model by
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code> and fitting the spatial linear model by
Gaussian REML to the pruned data set.  For <code>initial.param = FALSE</code>
no initial parameter values are computed and the estimating equations are
solved with the initial values passed by <code>param</code> and <code>aniso</code> to
<code>georob</code> (see <em>Details</em> of <code><a href="#topic+georob">georob</a></code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_initial.fixef">initial.fixef</code></td>
<td>
<p>a character keyword defining whether the function
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code> or <code><a href="quantreg.html#topic+rq">rq</a></code> is used to
compute robust initial estimates of the regression parameters
<code class="reqn">\boldsymbol{\beta}</code> (default <code>"lmrob"</code>).
If the fixed effects model matrix has not full columns rank, then
<code><a href="stats.html#topic+lm">lm</a></code> is used to compute initial values of the
regression coefficients.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_bhat">bhat</code></td>
<td>
<p>a numeric vector with initial values for the spatial random
effects <code class="reqn">\widehat{\boldsymbol{B}}</code>, with
<code class="reqn">\widehat{\boldsymbol{B}}=\boldsymbol{0}</code> if <code>bhat</code> is
equal to <code>NULL</code> (default).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_min.rweight">min.rweight</code></td>
<td>
<p>a positive numeric with the &ldquo;robustness
weight&rdquo; of the initial <code><a href="robustbase.html#topic+lmrob">lmrob</a></code> fit that
observations must exceed to be used for computing robust initial
estimates of variogram parameters by setting <code>initial.param = TRUE</code>
(see <code><a href="#topic+georob">georob</a></code>; default <code>0.25</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_param.tf">param.tf</code></td>
<td>
<p>a function such as <code>param.transf</code>, which returns a
named list of character strings that define the transformations to be
applied to the variogram parameters for model fitting, see
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_fwd.tf">fwd.tf</code></td>
<td>
<p>a function such as <code>fwd.transf</code>, which returns a named
list of invertible functions to be used to transform variogram
parameters, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_deriv.fwd.tf">deriv.fwd.tf</code></td>
<td>
<p>a function such as <code>dfwd.transf</code>, which
returns a named list of functions corresponding to the first derivatives
of <code>fwd.tf</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_bwd.tf">bwd.tf</code></td>
<td>
<p>a function such as <code>bwd.transf</code>, which returns the
named list of inverse functions corresponding to <code>fwd.tf</code>, see
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_psi.func">psi.func</code></td>
<td>
<p>a character keyword defining what <code class="reqn">\psi_c</code>-function
should be used for robust model fitting.  Possible values are
<code>"logistic"</code> (a scaled and shifted logistic CDF, default),
<code>"t.dist"</code> (re-descending <code class="reqn">\psi_c</code>-function associated with
Student <code class="reqn">t</code>-distribution with <code class="reqn">c</code> degrees of freedom) and
<code>"huber"</code> (Huber's <code class="reqn">\psi_c</code>-function).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_irwls.maxiter">irwls.maxiter</code></td>
<td>
<p>a positive integer equal to the maximum number of
IRWLS iterations to solve the estimating equations of
<code class="reqn">\boldsymbol{B}</code> and <code class="reqn">\boldsymbol{\beta}</code> (default
<code>50</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_irwls.ftol">irwls.ftol</code></td>
<td>
<p>a positive numeric with the convergence criterion for
IRWLS. Convergence is assumed if the objective function change of a IRWLS
iteration does not exceed <code>ftol</code>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_force.gradient">force.gradient</code></td>
<td>
<p>a logical scalar controlling whether the estimating
equations or the gradient of the Gaussian restricted log-likelihood are
evaluated even if all variogram parameters are fixed (default
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_min.condnum">min.condnum</code></td>
<td>
<p>a positive numeric with the minimum acceptable
ratio of smallest to largest singular value of the model matrix
<code class="reqn">\boldsymbol{X}</code> (default <code>1.e-12</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_zero.dist">zero.dist</code></td>
<td>
<p>a positive numeric equal to the maximum distance,
separating two sampling locations that are still considered as being
coincident.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_error.family.estimation">error.family.estimation</code></td>
<td>
<p>a character keyword, defining the
probability distribution for <code class="reqn">\varepsilon</code> (default:
<code>"gaussian"</code>) that is used to approximate the covariance of
<code class="reqn">\widehat{\boldsymbol{B}}</code> when solving the
estimating equations, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_error.family.cov.effects">error.family.cov.effects</code></td>
<td>
<p>a character keyword, defining the
probability distribution for <code class="reqn">\varepsilon</code> (default:
<code>"gaussian"</code>) that is used to approximate the covariances of
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>,
<code class="reqn">\widehat{\boldsymbol{B}}</code> and
<code class="reqn">\boldsymbol{B}-\widehat{\boldsymbol{B}}</code>,
see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_error.family.cov.residuals">error.family.cov.residuals</code></td>
<td>
<p>a character keyword, defining the
probability distribution for <code class="reqn">\varepsilon</code> (default:<br />
<code>"long.tailed"</code>) that is used to approximate the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y}
  - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}} -
  \widehat{\boldsymbol{B}}</code> and <code class="reqn">\widehat{\boldsymbol{\varepsilon}} +
  \widehat{\boldsymbol{B}} =\boldsymbol{Y}
  - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}}</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.bhat">cov.bhat</code></td>
<td>
<p>a logical scalar controlling whether the covariances of
<code class="reqn">\widehat{\boldsymbol{B}}</code> are returned by <code>georob</code>
(default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_full.cov.bhat">full.cov.bhat</code></td>
<td>
<p>a logical scalar controlling whether the full
covariance matrix (<code>TRUE</code>) or only the variance vector of
<code class="reqn">\widehat{\boldsymbol{B}}</code> is returned (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.betahat">cov.betahat</code></td>
<td>
<p>a logical scalar controlling whether the covariance
matrix of <code class="reqn">\widehat{\boldsymbol{\beta}}</code> is returned
(default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.delta.bhat">cov.delta.bhat</code></td>
<td>
<p>a logical scalar controlling whether the covariances of
<code class="reqn">\boldsymbol{B}-
  \widehat{\boldsymbol{B}}</code> are returned (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_full.cov.delta.bhat">full.cov.delta.bhat</code></td>
<td>
<p>a logical scalar controlling whether the full covariance
matrix (<code>TRUE</code>) or only the variance vector of
<code class="reqn">\boldsymbol{B}-
  \widehat{\boldsymbol{B}}</code> is returned (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.delta.bhat.betahat">cov.delta.bhat.betahat</code></td>
<td>
<p>a logical scalar controlling whether the covariance
matrix of <code class="reqn">\boldsymbol{B}-
  \widehat{\boldsymbol{B}}</code> and
<code class="reqn">\widehat{\boldsymbol{\beta}}</code> is returned
(default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.ehat">cov.ehat</code></td>
<td>
<p>a logical scalar controlling whether the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y}
  - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}} -
  \widehat{\boldsymbol{B}}</code> are returned (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_full.cov.ehat">full.cov.ehat</code></td>
<td>
<p>a logical scalar controlling whether the full covariance
matrix (<code>TRUE</code>) or only the variance vector of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y}
  - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}} -
  \widehat{\boldsymbol{B}}</code> is returned (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_cov.ehat.p.bhat">cov.ehat.p.bhat</code></td>
<td>
<p>a logical scalar controlling whether the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}} +
  \widehat{\boldsymbol{B}} =\boldsymbol{Y}
  - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}}</code> are returned (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_full.cov.ehat.p.bhat">full.cov.ehat.p.bhat</code></td>
<td>
<p>a logical scalar controlling whether the full
covariance matrix (<code>TRUE</code>) or only the variance vector
of <code class="reqn">\widehat{\boldsymbol{\varepsilon}}
  + \widehat{\boldsymbol{B}}
  =\boldsymbol{Y} - \boldsymbol{X}
  \widehat{\boldsymbol{\beta}}</code> is returned (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_hessian">hessian</code></td>
<td>
<p>a logical scalar controlling whether for Gaussian
(RE)ML the Hessian should be computed at the MLEs.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_rq">rq</code></td>
<td>
<p>a list of arguments passed to <code>rq</code> or a function such as
<code>control.rq</code> that generates such a list (see
<code><a href="quantreg.html#topic+rq">rq</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_lmrob">lmrob</code></td>
<td>
<p>a list of arguments passed to the <code>control</code> argument of
<code>lmrob</code> or a function such as
<code>lmrob.control</code> that generates such a list (see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_nleqslv">nleqslv</code></td>
<td>
<p>a list of arguments passed to
<code>nleqslv</code> or a function such as
<code>control.nleqslv</code> that generates such a list (see
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_nlminb">nlminb</code></td>
<td>
<p>a list of arguments passed to <code>nlminb</code>
or a function such as <code>control.nlminb</code> that generates such a list
(see <code><a href="stats.html#topic+nlminb">nlminb</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_optim">optim</code></td>
<td>
<p>a list of arguments passed to <code>optim</code> or a function
such as <code>control.optim</code> that generates such a list (see
<code><a href="stats.html#topic+optim">optim</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_pcmp">pcmp</code></td>
<td>
<p>a list of arguments, passed  e.g. to <code><a href="#topic+pmm">pmm</a></code> or a
function such as <code>control.pcmp</code> that generates such a list
(see <code><a href="#topic+control.pcmp">control.pcmp</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_...">...</code></td>
<td>
<p>for <code>fwd.transf</code>, <code>dfwd.transf</code> and
<code>bwd.transf</code> a named vector of functions, extending the definition
of transformations for variogram parameters (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="control.georob_+3A_variance">variance</code>, <code id="control.georob_+3A_snugget">snugget</code>, <code id="control.georob_+3A_nugget">nugget</code>, <code id="control.georob_+3A_scale">scale</code>, <code id="control.georob_+3A_alpha">alpha</code>, <code id="control.georob_+3A_beta">beta</code>, <code id="control.georob_+3A_delta">delta</code>, <code id="control.georob_+3A_gamma">gamma</code>, <code id="control.georob_+3A_kappa">kappa</code>, <code id="control.georob_+3A_lambda">lambda</code>, <code id="control.georob_+3A_mu">mu</code>, <code id="control.georob_+3A_nu">nu</code></td>
<td>
<p>character strings with names of transformation
functions of the variogram parameters.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_f1">f1</code>, <code id="control.georob_+3A_f2">f2</code>, <code id="control.georob_+3A_omega">omega</code>, <code id="control.georob_+3A_phi">phi</code>, <code id="control.georob_+3A_zeta">zeta</code></td>
<td>
<p>character strings with names of
transformation functions of the anisotropy variogram parameters.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_tau">tau</code>, <code id="control.georob_+3A_rq.method">rq.method</code>, <code id="control.georob_+3A_rq.alpha">rq.alpha</code>, <code id="control.georob_+3A_ci">ci</code>, <code id="control.georob_+3A_iid">iid</code>, <code id="control.georob_+3A_interp">interp</code>, <code id="control.georob_+3A_tcrit">tcrit</code></td>
<td>
<p>arguments passed
as <code>...</code> to <code><a href="quantreg.html#topic+rq">rq</a></code>.  Note that only <code>"br"</code>,
<code>"fnb"</code> and <code>"pfn"</code> methods of <code>rq()</code> are currently
supported.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_rq.beta">rq.beta</code>, <code id="control.georob_+3A_eps">eps</code>, <code id="control.georob_+3A_mm.factor">Mm.factor</code>, <code id="control.georob_+3A_max.bad.fixup">max.bad.fixup</code></td>
<td>
<p>arguments passed as
<code>...</code> to <code><a href="quantreg.html#topic+rq">rq</a></code>.</p>
</td></tr>
<tr><td><code id="control.georob_+3A_method">method</code>, <code id="control.georob_+3A_global">global</code>, <code id="control.georob_+3A_xscalm">xscalm</code>, <code id="control.georob_+3A_control">control</code>, <code id="control.georob_+3A_lower">lower</code>, <code id="control.georob_+3A_upper">upper</code>, <code id="control.georob_+3A_reltol">reltol</code>, <code id="control.georob_+3A_rel.tol">rel.tol</code></td>
<td>
<p>arguments passed to related arguments of
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code> and
<code><a href="stats.html#topic+optim">optim</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Parameter transformations</h4>

<p>The arguments <code>param.tf</code>, <code>fwd.tf</code>, <code>deriv.fwd.tf</code>,
<code>bwd.tf</code> define the transformations of the variogram parameters for
RE(ML) estimation.  Implemented are currently <code>"log"</code>,
<code>"logit1"</code>, <code>"logit2"</code>, <code>"logit3"</code> (various variants of
logit-transformation, see code of function <code>fwd.transf</code>) and <code>"identity"</code> (= no)
transformations.  These are the possible values that the many arguments
of the function <code>param.transf</code> accept (as quoted character strings)
and these are the names of the list components returned by
<code>fwd.transf</code>, <code>dfwd.transf</code> and <code>bwd.transf</code>.  Additional
transformations can be implemented by:
</p>

<ol>
<li><p> Extending the function definitions by arguments like
</p>
<p><code>fwd.tf = fwd.transf(my.fun = function(x) your transformation)</code>,<br />
<code>deriv.fwd.tf = dfwd.transf(my.fun = function(x) your derivative)</code>,<br />
<code>bwd.tf = bwd.transf(my.fun = function(x) your back-transformation)</code>,
</p>
</li>
<li><p> Assigning to a given argument of <code>param.transf</code> the name of
the new function, e.g.<br /> <code>variance = "my.fun"</code>.  </p>
</li></ol>

<p>Note that the values given for the arguments of <code>param.transf</code>
must match the names of the functions returned by <code>fwd.transf</code>,
<code>dfwd.transf</code> and <code>bwd.transf</code>.
</p>



<h4>Approximation of covariances of fixed and random effects and
residuals</h4>

<p>The robustified estimating equations of robust REML depend on the
covariances of <code class="reqn">\widehat{\boldsymbol{B}}</code>.
These covariances (and the covariances of
<code class="reqn">\boldsymbol{B}-\widehat{\boldsymbol{B}}</code>,
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>,
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}</code>,
<code class="reqn">\widehat{\boldsymbol{\varepsilon}} +
    \widehat{\boldsymbol{B}}</code>) are
approximated by expressions that in turn depend on the variances of
<code class="reqn">\varepsilon</code>,
<code class="reqn">\psi(\varepsilon/\tau)</code> and the expectation
of <code class="reqn">\psi'(\varepsilon/\tau) (= \partial / \partial \varepsilon \,
    \psi(\varepsilon/\tau))</code>.  The arguments
<code>error.family.estimation</code>, <code>error.family.cov.effects</code> and<br />
<code>error.family.cov.residuals</code> control what parametric distribution
for <code class="reqn">\varepsilon</code> is used to compute the variance of
<code class="reqn">\varepsilon</code>,
<code class="reqn">\psi(\varepsilon/\tau)</code> and the expectation
of <code class="reqn">\psi'(\varepsilon/\tau)</code> when
</p>

<ul>
<li><p> solving the estimating equations (<code>error.family.estimation</code>),
</p>
</li>
<li><p> computing the covariances of
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>,
<code class="reqn">\widehat{\boldsymbol{B}}</code> and
<code class="reqn">\boldsymbol{B}-\widehat{\boldsymbol{B}}</code>
(<code>error.family.cov.effects</code>) and
</p>
</li>
<li><p> computing the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y}
      - \boldsymbol{X}
      \widehat{\boldsymbol{\beta}} -
      \widehat{\boldsymbol{B}}</code> and <code class="reqn">\widehat{\boldsymbol{\varepsilon}} +
      \widehat{\boldsymbol{B}}
      =\boldsymbol{Y} - \boldsymbol{X}
      \widehat{\boldsymbol{\beta}}</code><br /> (<code>error.family.cov.residuals</code>).
</p>
</li></ul>

<p>Possible options are: <code>"gaussian"</code> or <code>"long.tailed"</code>.  In
the latter case the probability density function of
<code class="reqn">\varepsilon</code> is assumed to be proportional to
<code class="reqn">1/\tau \, \exp(-\rho_c(\varepsilon/\tau))</code>, where
<code class="reqn">\psi_c(x)=\rho_c^\prime(x)</code>.
</p>



<h3>Value</h3>

<p><code>control.georob</code>, <code>control.rq</code>, <code>control.nleqslv</code>,
<code>control.optim</code> and <code>control.nlminb</code> all create lists with
control parameters passed to <code><a href="#topic+georob">georob</a></code>,
<code><a href="quantreg.html#topic+rq">rq</a></code>, <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>, see arguments
above and the help pages of the respective functions for information
about the components of these lists.  Note that the list returned by
<code>control.georob</code> contains some components (<code>irwls.initial</code>,
<code>tuning.psi.nr</code>, <code>cov.bhat.betahat</code>,
<code>aux.cov.pred.target</code>) that cannot be changed by the user.
</p>
<p><code>param.transf</code> generates a list with character strings that
define what transformations are used for estimating the variogram
parameters, and <code>fwd.transf</code>, <code>bwd.transf</code> and
<code>dfwd.transf</code> return lists of functions with forward and backward
transformations and the first derivatives of the forward
transformations, see section <em>Parameter transformations</em> above.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

r.logzn.rob &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1, control = control.georob(cov.bhat = TRUE,
    cov.ehat.p.bhat = TRUE, initial.fixef = "rq"), verbose = 2)

qqnorm(rstandard(r.logzn.rob, level = 0)); abline(0, 1)
qqnorm(ranef(r.logzn.rob, standard = TRUE)); abline(0, 1)
</code></pre>

<hr>
<h2 id='cv'>Generic Cross-validation</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Generic function for cross-validating models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_object">object</code></td>
<td>
<p>any model object.</p>
</td></tr>
<tr><td><code id="cv_+3A_...">...</code></td>
<td>
<p>additional arguments as required by the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the respective documentation.</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a model fitted by
<code>georob</code>.  </p>

<hr>
<h2 id='cv.georob'>Cross-Validating a Spatial Linear Model Fitted by <code>georob</code></h2><span id='topic+cv.georob'></span>

<h3>Description</h3>

<p>This function assesses the goodness-of-fit of a spatial linear model by
<var>K</var>-fold cross-validation.  In more detail, the model is re-fitted
<var>K</var> times by robust (or Gaussian) (RE)ML, excluding each time
<var>1/K</var>th of the data.  The re-fitted models are used to compute robust
(or customary) external Kriging predictions for the omitted observations.
If the response variable is log-transformed then the Kriging predictions
can be optionally transformed back to the original scale of the
measurements.  S3methods for evaluating and plotting diagnostic summaries
of the cross-validation errors are described for the function
<code><a href="#topic+validate.predictions">validate.predictions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'georob'
cv(object, formula = NULL, subset = NULL,
    method = c("block", "random"), nset = 10L, seed = NULL,
    sets = NULL, duplicates.in.same.set = TRUE, re.estimate = TRUE,
    param = object[["variogram.object"]][[1]][["param"]],
    fit.param = object[["variogram.object"]][[1]][["fit.param"]],
    aniso = object[["variogram.object"]][[1]][["aniso"]],
    fit.aniso = object[["variogram.object"]][[1]][["fit.aniso"]],
    variogram.object = NULL,
    use.fitted.param = TRUE, return.fit = FALSE,
    reduced.output = TRUE, lgn = FALSE,
    mfl.action = c("offset", "stop"),
    ncores = min(nset, parallel::detectCores()), verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.georob_+3A_object">object</code></td>
<td>
<p>an object of class of <code>"georob"</code>, see
<code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_formula">formula</code></td>
<td>
<p>an optional formula for the regression model passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_method">method</code></td>
<td>
<p>a character keyword, controlling whether subsets are formed
by partitioning data set into contiguous spatial <code>block</code>s by
<code><a href="stats.html#topic+kmeans">kmeans</a></code> (default) or <code>random</code>ly.  Ignored if
<code>sets</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_nset">nset</code></td>
<td>
<p>a positive integer defining the number <var>K</var> of subsets into
which the data set is partitioned (default: <code>nset = 10</code>).  Ignored
if <code>sets</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_seed">seed</code></td>
<td>
<p>an optional integer seed to initialize random number generation,
see <code><a href="base.html#topic+set.seed">set.seed</a></code>. Ignored if <code>sets</code> is non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_sets">sets</code></td>
<td>
<p>an optional vector of the same length as the response vector
of the fitted model and with positive integers taking values in
<code class="reqn">(1,2,\ldots,K)</code>, defining in this way the <code class="reqn">K</code> subsets into which
the data set is split.  If <code>sets = NULL</code> (default) the partition is
randomly generated by <code><a href="stats.html#topic+kmeans">kmeans</a></code> or
<code><a href="stats.html#topic+runif">runif</a></code> (using possibly <code>seed</code>).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_duplicates.in.same.set">duplicates.in.same.set</code></td>
<td>
<p>a logical scalar controlling whether
replicated observations at a given location are assigned to the same
subset when partitioning the data (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_re.estimate">re.estimate</code></td>
<td>
<p>a logical scalar controlling whether the model is
re-fitted to the reduced data sets before computing the Kriging
predictions (<code>TRUE</code>, default) or whether the model passed in
<code>object</code> is used to compute the predictions for the omitted
observations, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_param">param</code></td>
<td>
<p>a named numeric vector or a matrix or data frame with
initial values of variogram parameters passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.  If <code>param</code> is
a matrix (or a data frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[1]][["param"]])</code> columns with
initial values of variogram parameters for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[1]][["param"]])</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_fit.param">fit.param</code></td>
<td>
<p>a named logical vector or a matrix or data frame
defining which variogram parameters should be adjusted by
<code><a href="stats.html#topic+update">update</a></code>.  If <code>fit.param</code> is a matrix (or a data
frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[1]][["fit.param"]])</code> columns
with variogram parameter fitting flags for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[1]][["fit.param"]])</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_aniso">aniso</code></td>
<td>
<p>a named numeric vector or a matrix or data frame with
initial values of anisotropy parameters passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.  If <code>aniso</code> is
a matrix (or a data frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[1]][["aniso"]])</code> columns with
initial values of anisotropy parameters for the <code>nset</code>
cross-validation sets, and <code>colnames(aniso)</code> must match<br />
<code>names(object[["variogram.object"]][[1]][["aniso"]])</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_fit.aniso">fit.aniso</code></td>
<td>
<p>a named logical vector or a matrix or data frame
defining which anisotropy parameters should be adjusted by
<code><a href="stats.html#topic+update">update</a></code>.  If <code>fit.aniso</code> is a matrix (or a data
frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[1]][["fit.aniso"]])</code> columns
with anisotropy parameter fitting flags for the <code>nset</code>
cross-validation sets, and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[1]][["fit.aniso"]])</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_variogram.object">variogram.object</code></td>
<td>
<p>an optional list that gives initial values for
fitting a possibly nested variogram model for the cross-validation sets.
Each component is a list with the following components:
</p>

<ul>
<li><p><code>param</code>: an optional named numeric vector or a matrix or
data frame with initial values of variogram parameters passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.  If <code>param</code>
is a matrix (or a data frame) then it must have <code>nset</code> rows
and<br /> <code>length(object[["variogram.object"]][[i]][["param"]])</code>
columns with initial values of variogram parameters for the
<code>nset</code> cross-validation sets (<var>i</var> is the <var>i</var>th variogram
structure), and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[i]][["param"]])</code>.
</p>
</li>
<li><p><code>fit.param</code>: an optional named logical vector or a matrix
or data frame defining which variogram parameters should be adjusted
by <code><a href="stats.html#topic+update">update</a></code>.  If <code>fit.param</code> is a matrix (or
a data frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[i]][["fit.param"]])</code>
columns with variogram parameter fitting flags for the <code>nset</code>
cross-validation sets (<var>i</var> is the <var>i</var>th variogram structure),
and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[i]][["fit.param"]])</code>.
</p>
</li>
<li><p><code>aniso</code>: an optional named numeric vector or a matrix or
data frame with initial values of anisotropy parameters passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.  If <code>aniso</code>
is a matrix (or a data frame) then it must have <code>nset</code> rows
and<br /> <code>length(object[["variogram.object"]][[i]][["aniso"]])</code>
columns with initial values of anisotropy parameters for the
<code>nset</code> cross-validation sets (<var>i</var> is the <var>i</var>th variogram
structure), and <code>colnames(aniso)</code> must match<br />
<code>names(object[["variogram.object"]][[i]][["aniso"]])</code>.
</p>
</li>
<li><p><code>fit.aniso</code>: an optional named logical vector or a matrix
or data frame defining which anisotropy parameters should be adjusted
by <code><a href="stats.html#topic+update">update</a></code>.  If <code>fit.aniso</code> is a matrix (or
a data frame) then it must have <code>nset</code> rows and<br />
<code>length(object[["variogram.object"]][[i]][["fit.aniso"]])</code>
columns with anisotropy parameter fitting flags for the <code>nset</code>
cross-validation sets(<var>i</var> is the <var>i</var>th variogram structure),
and <code>colnames(param)</code> must match<br />
<code>names(object[["variogram.object"]][[i]][["fit.aniso"]])</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="cv.georob_+3A_use.fitted.param">use.fitted.param</code></td>
<td>
<p>a logical scalar controlling whether fitted values
of <code>param</code> (and <code>aniso</code> are used as initial values when
variogram parameters are fitted for the cross-validation sets (default
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_return.fit">return.fit</code></td>
<td>
<p>a logical scalar controlling whether information about the fit
should be returned when re-estimating the model with the reduced data
sets (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_reduced.output">reduced.output</code></td>
<td>
<p>a logical scalar controlling whether the complete fitted
model objects, fitted to the reduced data sets, are returned
(<code>FALSE</code>) or only some components (<code>TRUE</code>, default, see
<em>Value</em>).  Ignored if <code>return.fit = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_lgn">lgn</code></td>
<td>
<p>a logical scalar controlling whether Kriging predictions of a
log-transformed response should be transformed back to the original scale
of the measurements (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_mfl.action">mfl.action</code></td>
<td>
<p>a character keyword controlling what is done when some
levels of factor(s) are not present in any of the subsets used to fit the
model.  The function either stops (<code>"stop"</code>) or treats the
respective factors as model offset (<code>"offset"</code>, default).</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer controlling how many cores are used for
parallelized computations, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console during model fitting.  Passed by
<code><a href="stats.html#topic+update">update</a></code> to <code><a href="#topic+georob">georob</a></code>.</p>
</td></tr>
<tr><td><code id="cv.georob_+3A_...">...</code></td>
<td>
<p>additional arguments passed by <code><a href="stats.html#topic+update">update</a></code>
to <code><a href="#topic+georob">georob</a></code>, see <em>Details</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Note</b> that <em>the data frame passed as</em> <code>data</code>
<em>argument to</em> <code>georob</code> <em>must exist in the user workspace
when calling <code>cv.georob</code></em>.
</p>
<p><code>cv.georob</code> uses the packages <span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for
parallelized computations.  By default, the function uses <code class="reqn">K</code> CPUs
but not more than are physically available (as returned by
<code><a href="parallel.html#topic+detectCores">detectCores</a></code>).
</p>
<p><code>cv.georob</code> uses the function <code><a href="stats.html#topic+update">update</a></code> to
re-estimated the model with the reduced data sets.  Therefore, any
argument accepted by <code><a href="#topic+georob">georob</a></code> except <code>data</code> can be
changed when re-fitting the model.  Some of them (e.g. <code>formula</code>,
<code>subset</code>, etc.)  are explicit arguments of <code>cv.georob</code>, but
also the remaining ones can be passed by <code>...</code> to the function.
</p>
<p>Practitioners in geostatistics commonly cross-validate a fitted model
without re-estimating the model parameters with the reduced data sets.
This is clearly an unsound practice (see <cite>Hastie et al., 2009, sec.
7.10</cite>).  Therefore, the argument <code>re.estimate</code> should always be set
to <code>TRUE</code>.  The alternative is provided only for historic reasons.
</p>


<h3>Value</h3>

<p>The method <code>cv.georob</code> returns an object of class <code>cv.georob</code>,
which is a list with the two
components <code>pred</code> and <code>fit</code>.
</p>
<p><code>pred</code> is a data frame with the coordinates and the
cross-validation prediction results with the following variables:
</p>
<table>
<tr><td><code>subset</code></td>
<td>
<p>an integer vector defining to which of the <code class="reqn">K</code> subsets
an observation was assigned.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the values of the (possibly log-transformed) response.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>the Kriging predictions.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the Kriging standard errors.</p>
</td></tr>
</table>
<p>If <code>lgn = TRUE</code> then <code>pred</code> has the additional variables:
</p>
<table>
<tr><td><code>lgn.data</code></td>
<td>
<p>the untransformed response.</p>
</td></tr>
<tr><td><code>lgn.pred</code></td>
<td>
<p>the unbiased back-transformed predictions of a
log-transformed response.</p>
</td></tr>
<tr><td><code>lgn.se</code></td>
<td>
<p>the Kriging standard errors of the back-transformed
predictions of a<br /> log-transformed response.</p>
</td></tr>
</table>
<p>The second component <code>fit</code> contains either the full outputs of
<code>georob</code>, fitted for the <code class="reqn">K</code> reduced data sets
(<code>reduced.output = FALSE</code>), or <code class="reqn">K</code> lists with the components
<code>tuning.psi</code>, <code>converged</code>, <br /> <code>convergence.code</code>,
<code>gradient</code>, <code>variogram.object</code>, <code>coefficients</code> along with
the standard errors of
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>, see
<code><a href="#topic+georobObject">georobObject</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Hastie, T., Tibshirani, R. and Friedman, J. (2009) <em>The Elements of
Statistical Learning; Data Mining, Inference and Prediction</em>, Springer,
New York, <a href="https://doi.org/10.1007/978-0-387-84858-7">doi:10.1007/978-0-387-84858-7</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+validate.predictions">validate.predictions</a></code> for validating Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define number of cores for parallel computations
if(interactive()) ncpu &lt;- 10L else ncpu &lt;- 1L

data(meuse)

r.logzn &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
  variogram.model = "RMexp",
  param = c(variance = 0.15, nugget = 0.05, scale = 200),
  tuning.psi = 1000)

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.logzn.cv.1 &lt;- cv(r.logzn, seed = 1, lgn = TRUE, ncores = 1, verbose = 1)

  r.logzn.cv.2 &lt;- cv(r.logzn, formula = .~. + ffreq, seed = 1, lgn = TRUE,
      ncores = ncpu)

  plot(r.logzn.cv.1, type = "bs")
  plot(r.logzn.cv.2, type = "bs", add = TRUE, col = "red")

  legend("topright", lty = 1, col = c("black", "red"), bty = "n",
      legend = c("log(Zn) ~ sqrt(dist)", "log(Zn) ~ sqrt(dist) + ffreq"))
}
</code></pre>

<hr>
<h2 id='default.aniso'>Setting Default Values of Variogram Parameters</h2><span id='topic+default.aniso'></span><span id='topic+default.fit.param'></span><span id='topic+default.fit.aniso'></span>

<h3>Description</h3>

<p>Auxiliary functions to set sensible default values for anisotropy
parameters and for controlling what variogram and anisotropy parameters
should be estimated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
default.aniso(f1 = 1., f2 = 1., omega = 90., phi = 90., zeta = 0.)

default.fit.param(
  variance = TRUE, snugget = FALSE, nugget = TRUE, scale = TRUE,
  alpha = FALSE, beta = FALSE, delta = FALSE, gamma = FALSE,
  kappa = FALSE, lambda = FALSE, mu = FALSE, nu = FALSE)

default.fit.aniso(f1 = FALSE, f2 = FALSE, omega = FALSE,
  phi = FALSE, zeta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default.aniso_+3A_variance">variance</code></td>
<td>
<p>variance (sill <code class="reqn">\sigma^2</code>) of the
auto-correlated component of the Gaussian random field
<code class="reqn">B(\boldsymbol{s})</code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_snugget">snugget</code></td>
<td>
<p>variance (spatial nugget
<code class="reqn">\sigma^2_{\mathrm{n}}</code>) of the seemingly spatially
uncorrelated component of <code class="reqn">B(\boldsymbol{s})</code>
(micro-scale spatial variation; default value <code>snugget = 0</code>).</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_nugget">nugget</code></td>
<td>
<p>variance (nugget <code class="reqn">\tau^2</code>) of the independent error
<code class="reqn">\varepsilon(\boldsymbol{s})</code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_scale">scale</code></td>
<td>
<p>range parameter (<code class="reqn">\alpha</code>) of the variogram.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_alpha">alpha</code>, <code id="default.aniso_+3A_beta">beta</code>, <code id="default.aniso_+3A_delta">delta</code>, <code id="default.aniso_+3A_gamma">gamma</code>, <code id="default.aniso_+3A_kappa">kappa</code>, <code id="default.aniso_+3A_lambda">lambda</code>, <code id="default.aniso_+3A_mu">mu</code>, <code id="default.aniso_+3A_nu">nu</code></td>
<td>
<p>names of
additional variogram parameters such as the smoothness parameter
<code class="reqn">\nu</code> of the Whittle-Matérn model (see
<code><a href="#topic+gencorr">gencorr</a></code> and <code><a href="#topic+param.names">param.names</a></code>).</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_f1">f1</code></td>
<td>
<p>positive ratio <code class="reqn">f_1</code> of lengths of second and first
semi-principal axes of an ellipsoidal surface with constant semi-variance
in <code class="reqn">\mathrm{I}\!\mathrm{R}^3</code> (default <code>f1 = 1</code>), see
subsection <em>Model</em> of <code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_f2">f2</code></td>
<td>
<p>positive ratio <code class="reqn">f_2</code> of lengths of third and first
semi-principal axes of the semi-variance ellipsoid (default <code>f2 =
  1</code>), see subsection <em>Model</em> of <code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_omega">omega</code></td>
<td>
<p>azimuth in degrees of the first semi-principal axis of the
semi-variance ellipsoid (default <code>omega = 90</code>), see subsection
<em>Model</em> of <code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_phi">phi</code></td>
<td>
<p>90 degrees minus altitude of the first semi-principal axis of
the semi-variance ellipsoid (default <code>phi = 90</code>), see subsection
<em>Model</em> of <code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
<tr><td><code id="default.aniso_+3A_zeta">zeta</code></td>
<td>
<p>angle in degrees between the second semi-principal axis and
the direction of the line defined by the intersection between the
<code class="reqn">x</code>-<code class="reqn">y</code>-plane and the plane orthogonal to the first
semi-principal axis of the semi-variance ellipsoid through the origin
(default <code>zeta = 0</code>), see subsection <em>Model</em> of
<code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a named numeric vector with initial values of anisotropy
parameters (<code>default.aniso</code>) or named logical vectors, controlling
what parameters should be estimated (<code>default.fit.param</code>,<br />
<code>default.fit.aniso</code>).</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default.aniso(f1 = 0.5, omega = 45)
default.fit.param(scale=FALSE, alpha = TRUE)
default.fit.aniso(f1 = TRUE, omega = TRUE)
</code></pre>

<hr>
<h2 id='elevation'>Elevation Data</h2><span id='topic+elevation'></span>

<h3>Description</h3>

<p>Surface elevation data taken from <cite>Davis (1972)</cite>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(elevation)</code></pre>


<h3>Format</h3>

<p>A data frame with 52 observations on the following 3 variables:
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector with the easting coordinate in
multiplies of 50 feet.</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector with the northing coordinate in
multiplies of 50 feet..</p>
</dd>
<dt><code>height</code></dt><dd><p>a numeric vector with the elevation in
multiples of 10 feet.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data were imported from the package <span class="pkg">geoR</span>.
</p>


<h3>Source</h3>

<p>Davis, J.C. (1973) <em>Statistics and Data Analysis in Geology</em>, Wiley,
New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elevation)
summary(elevation)
</code></pre>

<hr>
<h2 id='fit.variogram.model'>Fitting Model Functions to Sample Variograms</h2><span id='topic+control.fit.variogram.model'></span><span id='topic+fit.variogram.model'></span><span id='topic+print.fitted.variogram'></span><span id='topic+summary.fitted.variogram'></span><span id='topic+print.summary.fitted.variogram'></span><span id='topic+lines.fitted.variogram'></span>

<h3>Description</h3>

<p>The function <code>fit.variogram.model</code> fits a variogram model to a sample
variogram by (weighted) non-linear least squares.  The function
<code>control.fit.variogram.model</code> generates a list with steering parameters which
control <code>fit.variogram.model</code>.  There are <code>print</code>, <code>summary</code>
and <code>lines</code> methods for summarizing and displaying fitted variogram
models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.variogram.model(sv,
    variogram.model = c("RMexp", "RMaskey", "RMbessel", "RMcauchy",
        "RMcircular", "RMcubic", "RMdagum", "RMdampedcos", "RMdewijsian",
        "RMfbm", "RMgauss", "RMgencauchy", "RMgenfbm", "RMgengneiting",
        "RMgneiting", "RMlgd", "RMmatern", "RMpenta", "RMqexp",
        "RMspheric", "RMstable", "RMwave", "RMwhittle"),
    param, fit.param = default.fit.param()[names(param)],
	  aniso = default.aniso(), fit.aniso = default.fit.aniso(),
    variogram.object = NULL,
    max.lag = max(sv[["lag.dist"]]), min.npairs = 30,
    weighting.method = c("cressie", "equal", "npairs"),
    control = control.fit.variogram.model(),
    verbose = 0)

control.fit.variogram.model(maximizer = c("nlminb", "optim"),
    param.tf = param.transf(), fwd.tf = fwd.transf(),
    deriv.fwd.tf = dfwd.transf(), bwd.tf = bwd.transf(),
    hessian = TRUE, optim = control.optim(), nlminb = control.nlminb())

## S3 method for class 'fitted.variogram'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'fitted.variogram'
summary(object, correlation = FALSE, signif = 0.95, ...)

## S3 method for class 'fitted.variogram'
lines(x, what = c("variogram", "covariance", "correlation"),
    from = 1.e-6, to, n = 501, xy.angle = 90, xz.angle = 90,
    col = 1:length(xy.angle), pch = 1:length(xz.angle), lty = "solid", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.variogram.model_+3A_sv">sv</code></td>
<td>
<p>an object of class <code>sample.variogram</code>, see
<code><a href="#topic+sample.variogram">sample.variogram</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_variogram.model">variogram.model</code></td>
<td>
<p>a character keyword defining the variogram model
to be fitted.  Currently, most basic variogram models provided formerly
by the now archived package <span class="pkg">RandomFields</span> can be fitted (see
<em>Details</em> of <code><a href="#topic+georob">georob</a></code> and <code><a href="#topic+gencorr">gencorr</a></code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_param">param</code></td>
<td>
<p>a named numeric vector with initial values of the variogram
parameters.  The following parameter names are allowed (see
<em>Details</em> of <code><a href="#topic+georob">georob</a></code> and <code><a href="#topic+georobPackage">georobPackage</a></code> for
information about the parametrization of variogram models):
</p>

<ul>
<li><p><code>variance</code>: variance (sill <code class="reqn">\sigma^2</code>) of the
auto-correlated component of the Gaussian random field
<code class="reqn">B(\boldsymbol{s})</code>.
</p>
</li>
<li><p><code>snugget</code>: variance
(spatial nugget <code class="reqn">\sigma^2_{\mathrm{n}}</code>)
of the seemingly spatially uncorrelated component of
<code class="reqn">B(\boldsymbol{s})</code>
(micro-scale spatial variation; default value<br />  <code>snugget = 0</code>).
</p>
</li>
<li><p><code>nugget</code>: variance (nugget <code class="reqn">\tau^2</code>) of the
independent errors
<code class="reqn">\varepsilon(\boldsymbol{s})</code>.
</p>
</li>
<li><p><code>scale</code>: range parameter (<code class="reqn">\alpha</code>) of the variogram.
</p>
</li>
<li><p>names of additional variogram parameters such as the smoothness
parameter <code class="reqn">\nu</code> of the Whittle-Matérn model (see
<code><a href="#topic+gencorr">gencorr</a></code> and <code><a href="#topic+param.names">param.names</a></code>). </p>
</li></ul>

</td></tr>
<tr><td><code id="fit.variogram.model_+3A_fit.param">fit.param</code></td>
<td>
<p>a named logical vector (or a function such as
<code><a href="#topic+default.fit.param">default.fit.param</a></code> that creates this vector) with the same
names as used for <code>param</code>, defining which parameters are adjusted
(<code>TRUE</code>) and which are kept fixed at their initial values
(<code>FALSE</code>) when fitting the model.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_aniso">aniso</code></td>
<td>
<p>a named numeric vector with initial values (or a function such as
<code><a href="#topic+default.aniso">default.aniso</a></code> that creates this vector) for fitting
geometrically anisotropic variogram models.  The names of <code>aniso</code>
are matched against the following names (see <em>Details</em> and
<code><a href="#topic+georobPackage">georobPackage</a></code> for information about the parametrization of
variogram models):
</p>

<ul>
<li><p><code>f1</code>: ratio <code class="reqn">f_1</code> of lengths of second and first
semi-principal axes of an ellipsoidal surface with constant
semi-variance in <code class="reqn">\mathrm{I}\!\mathrm{R}^3</code> (default <code>f1 = 1</code>).
</p>
</li>
<li><p><code>f2</code>: ratio <code class="reqn">f_2</code> of lengths of third and first
semi-principal axes of the semi-variance ellipsoid (default <code>f2 = 1</code>).
</p>
</li>
<li><p><code>omega</code>: azimuth in degrees of the first semi-principal axis
of the semi-variance ellipsoid (default <code>omega = 90</code>).
</p>
</li>
<li><p><code>phi</code>: 90 degrees minus altitude of the first semi-principal axis
of the semi-variance ellipsoid (default <code>phi = 90</code>).
</p>
</li>
<li><p><code>zeta</code>: angle in degrees between the second semi-principal
axis and the direction of the line defined by the intersection
between the <code class="reqn">x</code>-<code class="reqn">y</code>-plane and the plane orthogonal to the
first semi-principal axis of the semi-variance ellipsoid through the
origin (default <code>zeta = 0</code>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="fit.variogram.model_+3A_fit.aniso">fit.aniso</code></td>
<td>
<p>a named logical vector (or a function such as
<code><a href="#topic+default.fit.aniso">default.fit.aniso</a></code> that creates this vector) with the same
names as used for <code>aniso</code>, defining which parameters are adjusted
(<code>TRUE</code>) and which are kept fixed at their initial values
(<code>FALSE</code>) when fitting the model.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_variogram.object">variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model.  Each component is itself a list with the following
components:
</p>

<ul>
<li><p><code>variogram.model</code>: a character keyword defining the variogram
model, see respective argument above.
</p>
</li>
<li><p><code>param</code>: a named numeric vector with initial values of the
variogram parameters, see respective argument above.
</p>
</li>
<li><p><code>fit.param</code>: a named logical vector defining which parameters are
adjusted, see respective argument above.
</p>
</li>
<li><p><code>aniso</code>: a named numeric vector with initial values for fitting
geometrically anisotropic variogram models, see respective argument
above.
</p>
</li>
<li><p><code>fit.param</code>: a named logical vector defining which anisotropy
parameters are adjusted, see respective argument above.
</p>
</li></ul>

<p>Note that the arguments <code>variogram.model</code>, <code>param</code>,
<code>fit.param</code>, <code>aniso</code> and<br /> <code>fit.aniso</code> are ignored when
<code>variogram.object</code> is passed to <code>fit.variogram.model</code>. </p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_max.lag">max.lag</code></td>
<td>
<p>a positive numeric defining the maximum lag distance to be
used for fitting or plotting variogram models (default all lag classes).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_min.npairs">min.npairs</code></td>
<td>
<p>a positive integer defining the minimum number of data
pairs required so that a lag class is used for fitting a variogram
model (default <code>30</code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_weighting.method">weighting.method</code></td>
<td>
<p>a character keyword defining the weights for
non-linear least squares.  Possible values are:
</p>

<ul>
<li> <p><code>"equal"</code>: no weighting ,
</p>
</li>
<li> <p><code>"npairs"</code>: weighting by number of data pairs in a lag class,
</p>
</li>
<li> <p><code>"cressie"</code>: &ldquo;Cressie's weights&rdquo; (default, see
<cite>Cressie, 1993, sec.  2.6.2</cite>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="fit.variogram.model_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console during model fitting.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_control">control</code></td>
<td>
<p>a list with the components <code>maximizer</code>,
<code>param.tf</code>, <code>fwd.tf</code>, <code>bwd.tf</code>, <code>hessian</code>,
<code>optim</code> and <code>nlminb</code>  or a function such as
<code>control.fit.variogram.model</code> that generates such a list.
See <code><a href="#topic+control.georob">control.georob</a></code> for information on
<code>maximizer</code>, <code>param.tf</code>, <code>fwd.tf</code>,
<code>bwd.tf</code>, <code>hessian</code>, <code>optim</code> and <code>nlminb</code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_maximizer">maximizer</code></td>
<td>
<p>a character keyword defining the optimizer for nonlinear
least squares.  Possible values are <code><a href="stats.html#topic+nlminb">nlminb</a></code> (default)
or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_hessian">hessian</code></td>
<td>
<p>a logical scalar controlling whether the Hessian should be
computed at the nonlinear least squares estimates.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_param.tf">param.tf</code></td>
<td>
<p>a function such as <code><a href="#topic+param.transf">param.transf</a></code>, which
returns a named vector of character strings that define the
transformations to be applied to the variogram parameters for model
fitting, see <code><a href="#topic+control.georob">control.georob</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_fwd.tf">fwd.tf</code></td>
<td>
<p>a function such as <code><a href="#topic+fwd.transf">fwd.transf</a></code>, which returns
a named list of invertible functions to be used to transform variogram
parameters, see <code><a href="#topic+control.georob">control.georob</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_deriv.fwd.tf">deriv.fwd.tf</code></td>
<td>
<p>a function such as <code>dfwd.transf</code>, which
returns a named list of functions corresponding to the first derivatives
of <code>fwd.tf</code>, see <code><a href="#topic+control.georob">control.georob</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_bwd.tf">bwd.tf</code></td>
<td>
<p>a function such as <code><a href="#topic+bwd.transf">bwd.transf</a></code>, which returns
the named list of inverse functions corresponding to <code>fwd.tf</code>, see
see <code><a href="#topic+control.georob">control.georob</a></code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_nlminb">nlminb</code></td>
<td>
<p>a list of arguments passed to <code>nlminb</code> or a function
such as <code><a href="#topic+control.nlminb">control.nlminb</a></code> that generates such a list (see
<code><a href="stats.html#topic+nlminb">nlminb</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_optim">optim</code></td>
<td>
<p>a list of arguments passed to <code>optim</code> or a function
such as <code><a href="#topic+control.optim">control.optim</a></code> that generates such a list (see
<code><a href="stats.html#topic+optim">optim</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_object">object</code>, <code id="fit.variogram.model_+3A_x">x</code></td>
<td>
<p>an object of class <code>fitted.variogram</code>.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating the number of decimal digits
to print.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_correlation">correlation</code></td>
<td>
<p>a logical scalar controlling whether the correlation matrix of
the fitted variogram parameters is computed (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_signif">signif</code></td>
<td>
<p>a numeric with the confidence level for computing
confidence intervals for variogram parameters (default <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_what">what</code></td>
<td>
<p>a character keyword with the quantity that should be
displayed (default <code>"variogram"</code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_from">from</code></td>
<td>
<p>a numeric with the minimal lag distance used in plotting
variogram models.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_to">to</code></td>
<td>
<p>a numeric with the maximum lag distance used in plotting
variogram models (default: largest lag distance of current plot).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_n">n</code></td>
<td>
<p>a positive integer specifying the number of equally spaced lag
distances for which semi-variances are evaluated in plotting variogram
models (default <code>501</code>).</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_xy.angle">xy.angle</code></td>
<td>
<p>a numeric vector with azimuth angles (in degrees,
clockwise positive from north) in <code class="reqn">x</code>-<code class="reqn">y</code>-plane for which
semi-variances should be plotted.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_xz.angle">xz.angle</code></td>
<td>
<p>a numeric vector with angles in <code class="reqn">x</code>-<code class="reqn">z</code>-plane (in
degrees, clockwise positive from zenith to south) for which semi-variances
should be plotted.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_col">col</code></td>
<td>
<p>a vector with colours of curves to distinguish curves relating
to different azimuth angles in <code class="reqn">x</code>-<code class="reqn">y</code>-plane.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_pch">pch</code></td>
<td>
<p>a vector with the plotting symbols added to lines to
distinguish curves relating to different angles in
<code class="reqn">x</code>-<code class="reqn">z</code>-plane.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_lty">lty</code></td>
<td>
<p>a vector with the line types for plotting variogram models.</p>
</td></tr>
<tr><td><code id="fit.variogram.model_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametrization of geometrically anisotropic variograms is
described in detail in <code><a href="#topic+georobPackage">georobPackage</a></code>, and the section
<em>Details</em> of <code><a href="#topic+georob">georob</a></code> describes how the parameter
estimates are constrained to permissible ranges.  The same
mechanisms are used in <code>fit.variogram.model</code>.
</p>
<p>The method <code>summary</code> computes confidence intervals of the estimated
variogram and anisotropy parameters from the Hessian matrix of the residual
sums of squares, based on the asymptotic normal distribution of least
squares estimates.  Note that the Hessian matrix with respect to the
<em>transformed</em> variogram and anisotropy parameters is used for this.
Hence the inverse Hessian matrix is the covariance matrix of the
transformed parameters, confidence intervals are first computed for the
transformed parameters and the limits of these intervals are transformed
back to the original scale of the parameters.  Optionally, <code>summary</code>
reports the correlation matrix of the <em>transformed</em> parameters, also
computed from the Hessian matrix.
</p>


<h3>Value</h3>

<p>The function <code>fit.variogram.model</code> generates an object of class
<code>fitted.variogram</code> which is a list with the following components:
</p>
<table>
<tr><td><code>sse</code></td>
<td>
<p>the value of the object function (weighted residual sum of
squares) evaluated at the solution.</p>
</td></tr>
<tr><td><code>variogram.object</code></td>
<td>
<p>the estimated parameters of a possibly nested
variograms model.  This is a list that contains for each variogram model
structure the following components:
</p>

<ul>
<li><p><code>variogram.model</code>: the name of the fitted parametric
variogram model.
</p>
</li>
<li><p><code>param</code>: a named numeric vector with the (estimated)
variogram parameters.
</p>
</li>
<li><p><code>fit.param</code>: a named logical vector with the flags
defining what variogram parameters were estimated.
</p>
</li>
<li><p><code>isotropic</code>: logical indicating whether an isotropic
variogram was fitted.
</p>
</li>
<li><p><code>aniso</code>: a named numeric vector with the (estimated)
anisotropy parameters.
</p>
</li>
<li><p><code>fit.aniso</code>: a named logical vector with the flags
defining what anisotropy parameters were estimated.
</p>
</li>
<li><p><code>sincos</code>: a list with <code>sin</code> and <code>cos</code> of the
angles <code class="reqn">\omega</code>, <code class="reqn">\phi</code> and <code class="reqn">\zeta</code> that define the
orientation of the anisotropy ellipsoid.
</p>
</li>
<li><p><code>rotmat</code>: the matrix <code class="reqn">(\boldsymbol{C}_1,
      \boldsymbol{C}_2, \boldsymbol{C}_3)</code> (see
<code><a href="#topic+georobPackage">georobPackage</a></code>).
</p>
</li>
<li><p><code>sclmat</code>: a vector with the elements 1, <code class="reqn">1/f_1</code>,
<code class="reqn">1/f_2</code> (see <code><a href="#topic+georobPackage">georobPackage</a></code>).  
</p>
</li></ul>

</td></tr>
<tr><td><code>param.tf</code></td>
<td>
<p>a character vector listing the transformations of the
variogram parameters used for model fitting.</p>
</td></tr>
<tr><td><code>fwd.tf</code></td>
<td>
<p>a list of functions for variogram parameter transformations.</p>
</td></tr>
<tr><td><code>bwd.tf</code></td>
<td>
<p>a list of functions for <em>inverse</em> variogram parameter
transformations.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>a logical scalar indicating whether numerical
maximization by <code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>
converged.</p>
</td></tr>
<tr><td><code>convergence.code</code></td>
<td>
<p>a diagnostic integer issued by
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code> (component
<code>convergence</code>) about convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>a named integer vector of length two with the number of
function and gradient evaluations by <code><a href="stats.html#topic+nlminb">nlminb</a></code> or
<code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a numeric vector with the residuals, that is the sample
semi-variance minus the fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a numeric vector with the modelled semi-variances.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a numeric vector with the weights used for fitting.</p>
</td></tr>
<tr><td><code>hessian.tfpa</code></td>
<td>
<p>a symmetric matrix with the Hessian at the solution
with respect to the transformed variogram and anisotropy parameters
(missing if <code>hessian</code> is false).  This Hessian is used by
<code>summary.fitted.variogram</code> to compute confidence intervals
for the estimated parameters.</p>
</td></tr>
<tr><td><code>hessian.ntfpa</code></td>
<td>
<p>a symmetric matrix with the Hessian at the solution
with respect to the non-transformed variogram and anisotropy parameters
(missing if <code>hessian</code> is false).
</p>
</td></tr>
</table>
<p>The function <code>control.fit.variogram.model</code> returns a list with
parameters to steer <br /> <code>fit.variogram.model</code>, see arguments of
the function above for its components.
</p>
<p>The method <code>print.fitted.variogram</code> invisibly returns the fitted
variogram model unchanged.
</p>
<p>The method <code>summary.fitted.variogram</code> returns an object of class
<code>summary.fitted.variogram</code> which is a list containing a subset of
the components of the fitted variogram object (<code>call</code>,
<code>residuals</code>, <code>weights</code>, <code>converged</code>,
<code>convergence.code</code>, <code>iter</code>, <code>sse</code>,
<code>variogram.object</code>), the matrix <code>param.aniso</code> with the
estimated values of the variogram parameters along with the bounds of the
confidence intervals and optionally the correlation matrix
<code>cor.tf.param</code> of the estimated transformed parameters.  There is a
<code>print</code> method for objects of class <code>summary.fitted.variogram</code>
which returns invisibly the object unchanged.
</p>
<p>The method <code>lines.fitted.variogram</code> is called for its side effects
and returns the value <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993) <em>Statistics for Spatial Data</em>, Wiley, New
York, <a href="https://doi.org/10.1002/9781119115151">doi:10.1002/9781119115151</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
<code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wolfcamp)

## fitting an isotropic IRF(0) model
r.sv.iso &lt;- sample.variogram(pressure~1, data = wolfcamp,
    locations = ~x + y, lag.dist.def = seq(0, 200, by = 15))
plot(r.sv.iso, type = "l")

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.irf0.iso &lt;- fit.variogram.model(r.sv.iso, variogram.model = "RMfbm",
      param = c(variance = 100, nugget = 1000, scale = 1., alpha = 1.),
      fit.param = default.fit.param(scale = FALSE, alpha = TRUE))
  summary(r.irf0.iso, correlation = TRUE)
  lines(r.irf0.iso, line.col = "red")
}

## fitting an anisotropic IRF(0) model
r.sv.aniso &lt;- sample.variogram(pressure~1, data = wolfcamp,
    locations = ~x + y, lag.dist.def = seq(0, 200, by = 15),
    xy.angle.def = c(0., 22.5, 67.5, 112.5, 157.5, 180.))
plot(r.sv.aniso, type = "l")

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.irf0.aniso &lt;- fit.variogram.model(r.sv.aniso, variogram.model = "RMfbm",
      param = c(variance = 100, nugget = 1000, scale = 1., alpha = 1.5),
      fit.param = default.fit.param(scale = FALSE, alpha = TRUE),
      aniso = default.aniso(f1 = 0.4, omega = 135.),
      fit.aniso = default.fit.aniso(f1 = TRUE, omega = TRUE),
      control = control.fit.variogram.model(
        maximizer = "optim",
        optim = control.optim(
          method = "BFGS", hessian = TRUE, control = list(maxit = 5000)
        )
      ))
  summary(r.irf0.aniso, correlation = TRUE)

  lines(r.irf0.aniso, xy.angle = seq(0, 135, by = 45))
}
</code></pre>

<hr>
<h2 id='gencorr'>Variogram Models</h2><span id='topic+gencorr'></span>

<h3>Description</h3>

<p>The function <code>gencorr</code> computes intrinsic or
stationary isotropic generalized correlations (= negative semi-variances
computed with sill (variance) parameter equal to 1) for a set of basic
variogram models formerly made available by the function <code>RFfctn</code> of
the now archived <span class="rlang"><b>R</b></span> package <span class="pkg">RandomFields</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gencorr(x, variogram.model, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gencorr_+3A_x">x</code></td>
<td>
<p>a numeric vector with scaled lag distances, i.e. lag distances
divided by the range parameter <code>param["scale"]</code>.</p>
</td></tr>
<tr><td><code id="gencorr_+3A_variogram.model">variogram.model</code></td>
<td>
<p>a character keyword defining the variogram model.
Currently, the following models are implemented:<br />
<code>"RMaskey"</code>, <code>"RMbessel"</code>, <code>"RMcauchy"</code>,
<code>"RMcircular"</code>, <code>"RMcubic"</code>, <code>"RMdagum"</code>, <br />
<code>"RMdampedcos"</code>, <code>"RMdewijsian"</code>, <code>"RMexp"</code> (default),
<code>"RMfbm"</code>, <code>"RMgauss"</code>, <br /> <code>"RMgencauchy"</code>,
<code>"RMgenfbm"</code>, <code>"RMgengneiting"</code>, <code>"RMgneiting"</code>,
<code>"RMlgd"</code>, <br /> <code>"RMmatern"</code>, <code>"RMpenta"</code>, <code>"RMqexp"</code>,
<code>"RMspheric"</code>, <code>"RMstable"</code>, <code>"RMwave"</code>, <br />
<code>"RMwhittle"</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="gencorr_+3A_param">param</code></td>
<td>
<p>a named numeric vector with values of the additional
parameters of the variogram models such as the smoothness parameter of
the Whittle-Matérn model, see <code><a href="#topic+param.names">param.names</a> for the names of
  these parameters</code>.  Note that some variogram models (e.g.
<code>"RMcircular"</code>) do not have any additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name and parametrization of the variogram models originate from the
function <code>RFfctn</code> of <span class="pkg">RandomFields</span>.  The equations and further
information are taken (with minor modifications) from the help pages of
the respective functions of the archived <span class="rlang"><b>R</b></span> package <span class="pkg">RandomFields</span>,
version 3.3.14 (<cite>Schlather et al., 2022</cite>).  Note that the variance
(sill, <code>param["variance"]</code>) and the range parameters
(<code>param["scale"]</code>) are assumed to be equal to 1 in the following
formulae, and <code class="reqn">x</code> is the lag distance.  The variogram functions are
stationary and are valid for any number of dimensions if not mentioned
otherwise.
</p>
<p>The following  intrinsic or stationary isotropic variogram
functions <code class="reqn">\gamma(x)</code> are implemented in <code>gencorr</code>:
</p>

<ul>
<li> <p><code>RMaskey</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x)= 1 - (1-x)^\alpha 1_{[0,1]}(x)
    </code>
</p>

<p><code class="reqn">1_{[0,1]}(x)</code> is the indicator function equal to 1 for <code class="reqn">x \in
    [0,1]</code> and 0 otherwise.  This variogram function is
valid for dimension <code class="reqn">d</code> if <code class="reqn">\alpha \ge (d+1)/2</code>.  For
<code class="reqn">\alpha=1</code> we get the well-known triangle (or tent) model, which is
only valid on the real line.
</p>
</li>
<li> <p><code>RMbessel</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - 2^\nu \Gamma(\nu+1) x^{-\nu} J_\nu(x)
    </code>
</p>

<p>where <code class="reqn">\nu \ge \frac{d-2}2</code>, <code class="reqn">\Gamma</code> denotes
the gamma function and <code class="reqn">J_\nu</code> is a Bessel function of first kind.
This models a hole effect (see <cite>Chilès and Delfiner, 1999,
p. 92</cite>).
An important case is <code class="reqn">\nu=-0.5</code> which gives the variogram
function
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x)= 1 - \cos(x)</code>
</p>

<p>and which is only valid for <code class="reqn">d=1</code> (this equals <code>RMdampedcos</code>
for <code class="reqn">\lambda = 0</code>).
A second important case is <code class="reqn">\nu=0.5</code> with variogram function
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = \left(1 - \frac{\sin(x)}{x}\right) 1_{x&gt;0}
    </code>
</p>

<p>which is valid for <code class="reqn">d \le 3</code>. This coincides with <code>RMwave</code>.
</p>
</li>
<li> <p><code>RMcauchy</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = 1 - (1 + x^2)^{-\gamma}</code>
</p>

<p>where <code class="reqn">\gamma &gt; 0</code>.  The parameter <code class="reqn">\gamma</code> determines the
asymptotic power law.  The smaller <code class="reqn">\gamma</code>, the longer the
long-range dependence.  The generalized Cauchy Family
(<code>RMgencauchy</code>) includes this family for the choice <code class="reqn">\alpha =
    2</code> and <code class="reqn">\beta = 2 \gamma</code>.
</p>
</li>
<li> <p><code>RMcircular</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left(1 -\frac{2}{\pi} \left(x \sqrt{1-x^2} + \arcsin(x)\right)\right) 1_{[0,1]}(x)
    </code>
</p>

<p>This variogram function is valid only for dimensions <code class="reqn">d \le 2</code>.
</p>
</li>
<li> <p><code>RMcubic</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - (1-7 x^2 + 8.75 x^3 - 3.5 x^5 + 0.75 x^7) 1_{[0,1]}(x)
    </code>
</p>

<p>The model is only valid for dimensions <code class="reqn">d \le 3</code>.  It is a 2 times
differentiable variogram function with compact support (see
<cite>Chilès and Delfiner, 1999, p. 84</cite>).
</p>
</li>
<li> <p><code>RMdagum</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = (1+x^{-\beta})^{-\gamma / \beta}
    </code>
</p>

<p>The parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> can be varied in the
intervals <code class="reqn">(0,1]</code> and <code class="reqn">(0,1)</code>, respectively.  Like the
generalized Cauchy model (<code>RMgencauchy</code>) the Dagum family can be
used to model separately fractal dimension and Hurst effect
(see <cite>Berg et al., 2008</cite>).
</p>
</li>
<li> <p><code>RMdampedcos</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \exp(-\lambda x) \cos(x)
    </code>
</p>

<p>The model is valid for any dimension <code class="reqn">d</code>.  However, depending on
the dimension of the random field the following bound
<code class="reqn">
      \lambda \ge 1/{\tan(\pi/(2d))}
    </code> has to be respected.
This variogram function models a hole effect
(see <cite>Chilès and Delfiner, 1999, p. 92</cite>).
For <code class="reqn">\lambda = 0</code> we obtain
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x)= 1 - \cos(x)</code>
</p>
<p> which is only valid
for <code class="reqn">d=1</code> and corresponds to <code>RMbessel</code> for <code class="reqn">\nu=-0.5</code>.
</p>
</li>
<li> <p><code>RMdewijsian</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = \log(1 + x^{\alpha})
    </code>
</p>

<p>where <code class="reqn">\alpha \in (0,2]</code>.  This is an intrinsic variogram function.
Originally, the logarithmic model <code class="reqn">\gamma(x)
    = \log(x)</code> was named after de Wijs and
reflects a principle of
similarity (see  <cite>Chilès and Delfiner, 1999, p. 90</cite>).  But
note that <code class="reqn">\gamma(x) = \log(x)</code> is not
a valid variogram function.
</p>
</li>
<li> <p><code>RMexp</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = 1 - e^{-x}</code>
</p>

<p>This model is a special case of the Whittle model
(<code>RMwhittle</code>) if <code class="reqn">\nu=0.5</code>
and of the stable family (<code>RMstable</code>)
if <code class="reqn">\nu = 1</code>. Moreover, it is the continuous-time analogue
of the first order auto-regressive time series covariance structure.
</p>
</li>
<li> <p><code>RMfbm</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = x^\alpha</code>
</p>

<p>where <code class="reqn">\alpha \in (0,2)</code>.  This is an
intrinsically stationary variogram function.  For <code class="reqn">\alpha=1</code>
we get a variogram function corresponding to a standard
Brownian Motion.  For <code class="reqn">\alpha \in (0,2)</code> the
quantity <code class="reqn">H = \frac{\alpha}{2}</code> is called Hurst index
and determines the fractal dimension <code class="reqn">D = d + 1 - H</code> of the corresponding
Gaussian sample paths where <code class="reqn">d</code> is the
dimension of the random field
(see <cite>Chilès and Delfiner, 1999, p. 89</cite>).
</p>
</li>
<li> <p><code>RMgauss</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = 1 - e^{-x^2}</code>
</p>

<p>The Gaussian model has an infinitely differentiable variogram
function.  This smoothness is artificial.  Furthermore, this often
leads to singular matrices and therefore numerically instable
procedures (see <cite>Stein, 1999, p. 29</cite>).  The Gaussian model is included in
the stable class (<code>RMstable</code>) for the choice <code class="reqn">\alpha = 2</code>.
</p>
</li>
<li> <p><code>RMgencauchy</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = 1 - (1 + x^\alpha)^{-\beta/\alpha}</code>
</p>

<p>where <code class="reqn">\alpha \in (0,2]</code> and <code class="reqn">\beta &gt;
    0</code>.  This model has a smoothness parameter <code class="reqn">\alpha</code> and
a parameter <code class="reqn">\beta</code> which determines the asymptotic power law.
More precisely, this model admits simulating random fields where
fractal dimension <em>D</em> of the Gaussian sample path and Hurst
coefficient <em>H</em> can be chosen independently (compare also with
<code>RMlgd</code>): Here, we have <code class="reqn">D = d + 1 - \alpha/2, \alpha \in
    (0,2]</code> and <code class="reqn"> H = 1 -
    \beta/2, \beta &gt; 0</code>.  The smaller <code class="reqn">\beta</code>, the longer the
long-range dependence.  The variogram function is very regular
near the origin, because its Taylor expansion only contains even terms
and reaches its sill slowly.  Note that the Cauchy Family
(<code>RMcauchy</code>) is included in this family for the choice <code class="reqn">\alpha
    = 2</code> and <code class="reqn">\beta = 2 \gamma</code>.
</p>
</li>
<li> <p><code>RMgenfbm</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = (1 + x^{\alpha})^{\delta/\alpha} - 1
    </code>
</p>

<p>where <code class="reqn">\alpha \in (0,2)</code> and <code class="reqn">\delta \in
    (0,1)</code>. This is an intrinsic variogram function.
</p>
</li>
<li> <p><code>RMgengneiting</code>
This is a family of stationary models whose elements are specified by
the two parameters <code class="reqn">\kappa</code> and <code class="reqn">\mu</code> with <code class="reqn">\kappa</code> being a
non-negative integer and <code class="reqn">\mu \ge \frac{d}{2}</code> with
<code class="reqn">d</code> denoting the dimension of the random field (the models can be
used for any dimension).  Let <code class="reqn">\beta = \mu + 2\kappa +1/2</code>.
</p>
<p>For <code class="reqn">\kappa = 0</code> the model equals the Askey model (<code>RMaskey</code>)
and is therefore not implemented.
</p>
<p>For <code class="reqn">\kappa = 1</code> the model is given by
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left(1+\beta x \right)(1-x)^{\beta} 1_{[0,1]}(x),
        \qquad \beta = \mu +2.5,
    </code>
</p>

<p>If <code class="reqn">\kappa = 2</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left(1 + \beta x + \frac{\beta^{2} - 1}{3}
        x^{2} \right)(1-x)^{\beta} 1_{[0,1]}(x), \qquad
        \beta = \mu+4.5,
    </code>
</p>

<p>and for <code class="reqn">\kappa = 3</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left( 1 + \beta x + \frac{(2\beta^{2}-3)}{5} x^{2}+
        \frac{(\beta^2 - 4)\beta}{15} x^{3} \right)(1-x)^\beta 1_{[0,1]}(x),
        \beta = \mu+6.5,
    </code>
</p>

<p>A special case of this family is <code>RMgneiting</code> (with
<code class="reqn">s = 1</code> there) for the choice <code class="reqn">\kappa = 3, \mu =
    3/2</code>.
</p>
</li>
<li> <p><code>RMgneiting</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - (1 + 8 s x + 25 s^2 x^2 + 32 s^3 x^3)(1-s x)^8
    </code>
</p>

<p>if <code class="reqn">0 \le x \le \frac{1}{s}</code> and
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x)= 1</code>
</p>
<p> otherwise.  Here,
<code class="reqn">s=0.301187465825</code>.   This variogram function is
valid only for dimensions less than or equal to 3.  It is 6 times
differentiable and has compact support.  This model is an alternative
to <code>RMgauss</code> as its graph is hardly distinguishable from the graph
of the Gaussian model, but possesses neither the mathematical nor the
numerical disadvantages of the Gaussian model.  It is a special case of
<code>RMgengneiting</code> for the choice <code class="reqn">\kappa=3, \mu=1.5</code>.
</p>
</li>
<li> <p><code>RMlgd</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = \frac{\beta}{\alpha + \beta} x^{\alpha} 1_{[0,1]}(x) +
        (1 - \frac{\alpha}{\alpha + \beta} x^{-\beta}) 1_{x&gt;1}(x)
    </code>
</p>

<p>where <code class="reqn">\beta &gt;0</code> and <code class="reqn">0 &lt; \alpha \le (3-d)/2</code>, with <code class="reqn">d</code> denoting the dimension of the random field.
The model is only valid for dimension <code class="reqn">d=1,2</code>.  This model admits
simulating random fields where fractal dimension <code class="reqn">D</code> of the
Gaussian sample and Hurst coefficient <code class="reqn">H</code> can be chosen
independently (compare also <code>RMgencauchy</code>): Here, the random field
has fractal dimension <code class="reqn">D = d+1 - \alpha/2</code> and Hurst coefficient
<code class="reqn">H = 1-\beta/2</code> for <code class="reqn">0&lt; \beta \le 1</code>.
</p>
</li>
<li> <p><code>RMmatern</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \frac{2^{1-\nu}}{\Gamma(\nu)} (\sqrt{2\nu}x)^\nu
        K_\nu(\sqrt{2\nu}x)
    </code>
</p>

<p>where <code class="reqn">\nu &gt; 0</code> and <code class="reqn">K_\nu</code> is the modified Bessel function of
second kind.  This is one of 3 possible parametrizations (Whittle,
Matérn, Handcock-Wallis) of the Whittle-Matérn model.  The
Whittle-Matérn model is the model of choice if the smoothness of a
random field is to be parametrized: the sample paths of a Gaussian
random field with this covariance structure are <code class="reqn">m</code> times
differentiable if and only if <code class="reqn">\nu &gt; m</code> (see <cite>Gneiting and Guttorp,
2010, p.  24</cite>).  Furthermore, the fractal dimension <code class="reqn">D</code> of the
Gaussian sample paths is determined by <code class="reqn">\nu</code>: We have <code class="reqn">D = d +
    1 - \nu, \nu \in (0,1)</code> and <code class="reqn">D = d</code>
for <code class="reqn">\nu &gt; 1</code> where <code class="reqn">d</code> is the dimension of the random
field (see <cite>Stein, 1999, p. 32</cite>).  If <code class="reqn">\nu=0.5</code> the Matérn
model equals <code>RMexp</code>.  For <code class="reqn">\nu</code> tending to <code class="reqn">\infty</code> a
rescaled Gaussian model <code>RMgauss</code> appears as limit for the
Handcock-Wallis parametrization.
</p>
</li>
<li> <p><code>RMpenta</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left(1 - \frac{22}{3}x^{2} + 33 x^{4} - \frac{77}{2} x^{5} +
        \frac{33}{2} x^{7} - \frac{11}{2} x^{9} + \frac{5}{6}x^{11}\right) 1_{[0,1]}(x)
    </code>
</p>

<p>The model is only valid for dimensions <code class="reqn">d \le 3</code>.  It has
a 4 times differentiable variogram function with compact support (cf.
<cite>Chilès and Delfiner, 1999, p. 84</cite>).
</p>
</li>
<li> <p><code>RMqexp</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x)= 1 - \frac{2 e^{-x} - \alpha e^{-2x}}{ 2 - \alpha }</code>
</p>

<p>where <code class="reqn">\alpha \in [0,1]</code>.
</p>
</li>
<li> <p><code>RMspheric</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = 1 - \left(1 - \frac{3}{2} x + \frac{1}{2} x^3\right)  1_{[0,1]}(x)
    </code>
</p>

<p>This variogram model is valid only for dimensions less than or equal
to 3 and has compact support.
</p>
</li>
<li> <p><code>RMstable</code>
</p>
<p style="text-align: center;"><code class="reqn">\gamma(x) = 1 - e^{-x^\alpha}</code>
</p>

<p>where <code class="reqn">\alpha \in (0,2]</code>.  The parameter
<code class="reqn">\alpha</code> determines the fractal dimension <code class="reqn">D</code> of the Gaussian
sample paths: <code class="reqn">D = d + 1 - \alpha/2</code> where <code class="reqn">d</code> is the dimension
of the random field.  For <code class="reqn">\alpha &lt; 2</code> the Gaussian sample paths
are not differentiable (see <cite>Gelfand et al., 2010, p.  25</cite>).  The stable
family includes the exponential model (<code>RMexp</code>) for <code class="reqn">\alpha =
    1</code> and the Gaussian model ( <code>RMgauss</code>) for <code class="reqn">\alpha = 2</code>.
</p>
</li>
<li> <p><code>RMwave</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x) = \left(1 - \frac{\sin(x)}{x}\right) 1_{x&gt;0}
    </code>
</p>

<p>The model is only valid for dimensions <code class="reqn">d \le 3</code>.  It is a special
case of <code>RMbessel</code> for <code class="reqn">\nu = 0.5</code>.  This variogram models a
hole effect (see <cite>Chilès and Delfiner, 1999, p. 92</cite>).
</p>
</li>
<li> <p><code>RMwhittle</code>
</p>
<p style="text-align: center;"><code class="reqn">
      \gamma(x)=1 - \frac{2^{1- \nu}}{\Gamma(\nu)} x^{\nu}K_{\nu}(x)
    </code>
</p>

<p>where <code class="reqn">\nu &gt; 0</code> and <code class="reqn">K_\nu</code> is the modified Bessel function of
second kind.  This is one of 3 possible parametrizations (Whittle,
Matérn, Handcock-Wallis) of the
Whittle-Matérn model, for further details, see
information for entry <code>RMmatern</code> above.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector with generalized correlations (= negative semi-variances
computed with variance parameter <code>param["variance"] = 1</code>).
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a></p>


<h3>References</h3>

<p>Berg, C., Mateau, J., Porcu, E. (2008) The dagum family of isotropic
correlation functions, <em>Bernoulli</em>, <b>14</b>, 1134&ndash;1149,
<a href="https://doi.org/10.3150/08-BEJ139">doi:10.3150/08-BEJ139</a>.
</p>
<p>Chilès, J.-P., Delfiner, P. (1999) <em>Geostatistics
Modeling Spatial Uncertainty</em>, Wiley, New York,
<a href="https://doi.org/10.1002/9780470316993">doi:10.1002/9780470316993</a>.
</p>
<p>Gneiting, T. (2002) Compactly supported correlation functions.
<em>Journal of Multivariate Analysis</em>, <b>83</b>, 493&ndash;508,
<a href="https://doi.org/10.1006/jmva.2001.2056">doi:10.1006/jmva.2001.2056</a>.
</p>
<p>Gneiting, T., Schlather, M. (2004) Stochastic models which separate
fractal dimension and Hurst effect.  <em>SIAM review</em> <b>46</b>,
269&ndash;282, <a href="https://doi.org/10.1137/S0036144501394387">doi:10.1137/S0036144501394387</a>.
</p>
<p>Gneiting, T., Guttorp, P. (2010) Continuous Parameter Stochastic Process
Theory, In Gelfand, A. E., Diggle, P. J., Fuentes, M., Guttrop, P. (Eds.)
<em>Handbook of Spatial Statistics</em>, CRC Press, Boca Raton, p. 17&ndash;28,
<a href="https://doi.org/10.1201/9781420072884">doi:10.1201/9781420072884</a>.
</p>
<p>Schlather M., Malinowski A., Oesting M., Boecker D., Strokorb K., Engelke
S., Martini J., Ballani F., Moreva O., Auel J., Menck P.J., Gross S.,
Ober U., Ribeiro P., Ripley B.D., Singleton R., Pfaff B., R Core Team
(2022).  <em>RandomFields: Simulation and Analysis of Random Fields</em>.
<span class="rlang"><b>R</b></span> package version 3.3.14,
<a href="https://cran.r-project.org/src/contrib/Archive/RandomFields/">https://cran.r-project.org/src/contrib/Archive/RandomFields/</a>.
</p>
<p>Stein, M. L. (1999) <em>Interpolation of Spatial Data: Some Theory for
Kriging</em>, Springer, New York, <a href="https://doi.org/10.1007/978-1-4612-1494-6">doi:10.1007/978-1-4612-1494-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scaled lag distances
x &lt;- seq(0, 3, length.out = 100)

## generalized correlations stable model
y &lt;- gencorr(x, variogram.model = "RMstable", param = c(alpha = 1.5))
plot(x, y)

## generalized correlations circular model
y &lt;- gencorr(x, variogram.model = "RMcircular")
plot(x, y)
</code></pre>

<hr>
<h2 id='georob'>Robust Fitting of Spatial Linear Models</h2><span id='topic+georob'></span>

<h3>Description</h3>

<p>The function <code>georob</code> fits a linear model with spatially correlated
errors to geostatistical data that are possibly contaminated by
independent outliers.  The regression coefficients and the parameters of
the variogram model are estimated by robust or Gaussian restricted
maximum likelihood (REML) or by Gaussian maximum likelihood (ML).</p>


<h3>Usage</h3>

<pre><code class='language-R'>georob(formula, data, subset, weights, na.action, model = TRUE,
    x = FALSE, y = FALSE, contrasts = NULL, offset, locations,
    variogram.model = c("RMexp", "RMaskey", "RMbessel", "RMcauchy",
        "RMcircular", "RMcubic", "RMdagum", "RMdampedcos", "RMdewijsian",
        "RMfbm", "RMgauss", "RMgencauchy", "RMgenfbm", "RMgengneiting",
        "RMgneiting", "RMlgd", "RMmatern", "RMpenta", "RMqexp",
        "RMspheric", "RMstable", "RMwave", "RMwhittle"),
    param, fit.param = default.fit.param()[names(param)],
	  aniso = default.aniso(), fit.aniso = default.fit.aniso(),
    variogram.object = NULL,
    tuning.psi = 2, control = control.georob(),
    verbose = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georob_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the regression model for the
external drift to be fit (mandatory argument).  See
<code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+formula">formula</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="georob_+3A_data">data</code></td>
<td>
<p>an optional data frame, a
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>, list or environment (or another
object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the variables in the model and the coordinates where the data
was recorded.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>georob</code> is called.</p>
</td></tr>
<tr><td><code id="georob_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="georob_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process, currently ignored.  </p>
</td></tr>
<tr><td><code id="georob_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the
data contain <code>NA</code>s.  The default is set by the <code>na.action</code>
argument of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is
unset.  The &ldquo;factory-fresh&rdquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
Another possible value is <code>NULL</code>, no action.  Value
<code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="georob_+3A_model">model</code>, <code id="georob_+3A_x">x</code>, <code id="georob_+3A_y">y</code></td>
<td>
<p>logical scalars.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the response)
are returned.  The model frame is augmented by the coordinates.</p>
</td></tr>
<tr><td><code id="georob_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code> of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="georob_+3A_offset">offset</code></td>
<td>
<p>this optional argument can be used to specify an <em>a
priori</em> known component to be included in the linear predictor during
fitting.  An <code><a href="stats.html#topic+offset">offset</a></code> term can be included in the formula
instead or as well, and if both are specified their sum is used.</p>
</td></tr>
<tr><td><code id="georob_+3A_locations">locations</code></td>
<td>
<p>a one-sided formula defining the variables
that are used as coordinates of the locations were the data was
recorded (mandatory argument).</p>
</td></tr>
<tr><td><code id="georob_+3A_variogram.model">variogram.model</code></td>
<td>
<p>a character keyword defining the variogram model
to be fitted.  Currently, most basic variogram models provided formerly
by the now archived package <span class="pkg">RandomFields</span> can be fitted (see
<em>Details</em> and <code><a href="#topic+gencorr">gencorr</a></code>).</p>
</td></tr>
<tr><td><code id="georob_+3A_param">param</code></td>
<td>
<p>a named numeric vector with initial values of the
variogram parameters (mandatory argument).  The names of <code>param</code>
are matched against the following names (see <em>Details</em> and
<code><a href="#topic+georobPackage">georobPackage</a></code> for information about the parametrization of
variogram models):
</p>

<ul>
<li><p><code>variance</code>: variance (sill <code class="reqn">\sigma^2</code>) of the
auto-correlated component of the Gaussian random field
<code class="reqn">B(\boldsymbol{s})</code>.
</p>
</li>
<li><p><code>snugget</code>: variance
(spatial nugget <code class="reqn">\sigma^2_{\mathrm{n}}</code>)
of the seemingly spatially uncorrelated component of
<code class="reqn">B(\boldsymbol{s})</code>
(micro-scale spatial variation; default value<br />  <code>snugget = 0</code>).
</p>
</li>
<li><p><code>nugget</code>: variance (nugget <code class="reqn">\tau^2</code>) of the
independent errors
<code class="reqn">\varepsilon(\boldsymbol{s})</code>.
</p>
</li>
<li><p><code>scale</code>: range parameter (<code class="reqn">\alpha</code>) of the variogram.
</p>
</li>
<li><p>names of additional variogram parameters such as the smoothness
parameter <code class="reqn">\nu</code> of the Whittle-Matérn model (see
<code><a href="#topic+gencorr">gencorr</a></code> and <code><a href="#topic+param.names">param.names</a></code>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="georob_+3A_fit.param">fit.param</code></td>
<td>
<p>a named logical vector (or a function such as
<code><a href="#topic+default.fit.param">default.fit.param</a></code> that creates this vector) with the same
names as used for <code>param</code>, defining which parameters are adjusted
(<code>TRUE</code>) and which are kept fixed at their initial values
(<code>FALSE</code>) when fitting the model.</p>
</td></tr>
<tr><td><code id="georob_+3A_aniso">aniso</code></td>
<td>
<p>a named numeric vector with initial values (or a function such as
<code><a href="#topic+default.aniso">default.aniso</a></code> that creates this vector) for fitting
geometrically anisotropic variogram models.  The names of <code>aniso</code>
are matched against the following names (see <em>Details</em> and
<code><a href="#topic+georobPackage">georobPackage</a></code> for information about the parametrization of
variogram models):
</p>

<ul>
<li><p><code>f1</code>: ratio <code class="reqn">f_1</code> of lengths of second and first
semi-principal axes of an ellipsoidal surface with constant
semi-variance in <code class="reqn">\mathrm{I}\!\mathrm{R}^3</code> (default <code>f1 = 1</code>).
</p>
</li>
<li><p><code>f2</code>: ratio <code class="reqn">f_2</code> of lengths of third and first
semi-principal axes of the semi-variance ellipsoid (default <code>f2 = 1</code>).
</p>
</li>
<li><p><code>omega</code>: azimuth in degrees of the first semi-principal axis
of the semi-variance ellipsoid (default <code>omega = 90</code>).
</p>
</li>
<li><p><code>phi</code>: 90 degrees minus latitude of the first semi-principal axis
of the semi-variance ellipsoid (default <code>phi = 90</code>).
</p>
</li>
<li><p><code>zeta</code>: angle in degrees between the second semi-principal
axis and the direction of the line defined by the intersection
between the <code class="reqn">x</code>-<code class="reqn">y</code>-plane and the plane orthogonal to the
first semi-principal axis of the semi-variance ellipsoid through the
origin (default <code>zeta = 0</code>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="georob_+3A_fit.aniso">fit.aniso</code></td>
<td>
<p>a named logical vector (or a function such as
<code><a href="#topic+default.fit.aniso">default.fit.aniso</a></code> that creates this vector) with the same
names as used for <code>aniso</code>, defining which parameters are adjusted
(<code>TRUE</code>) and which are kept fixed at their initial values
(<code>FALSE</code>) when fitting the model.</p>
</td></tr>
<tr><td><code id="georob_+3A_variogram.object">variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model.  Each component is itself a list with the following
components:
</p>

<ul>
<li><p><code>variogram.model</code>: a mandatory character keyword defining
the variogram model, see respective argument above.
</p>
</li>
<li><p><code>param</code>: a mandatory named numeric vector with initial
values of the variogram parameters, see respective argument above.
</p>
</li>
<li><p><code>fit.param</code>: an optional named logical vector defining
which parameters are adjusted, see respective argument above.
</p>
</li>
<li><p><code>aniso</code>: an optional named numeric vector with initial
values for fitting geometrically anisotropic variogram models, see
respective argument above.
</p>
</li>
<li><p><code>fit.param</code>: an optional named logical vector defining
which anisotropy parameters are adjusted, see respective argument
above.
</p>
</li></ul>

<p>Note that the arguments <code>variogram.model</code>, <code>param</code>,
<code>fit.param</code>, <code>aniso</code> and<br /> <code>fit.aniso</code> are ignored when
<code>variogram.object</code> is passed to <code>georob</code>. </p>
</td></tr>
<tr><td><code id="georob_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>positive numeric.  The tuning constant <code class="reqn">c</code> of the
<code class="reqn">\psi_c</code>-function of the robust REML algorithm.</p>
</td></tr>
<tr><td><code id="georob_+3A_control">control</code></td>
<td>
<p>a list specifying parameters that control the behaviour of
<code>georob</code>.  Use the function <code><a href="#topic+control.georob">control.georob</a></code> and see its
help page for the components of <code>control</code>.</p>
</td></tr>
<tr><td><code id="georob_+3A_verbose">verbose</code></td>
<td>
<p>positive integer controlling logging of diagnostic
messages to the console during model fitting.  <code>verbose = 0</code> largely
suppresses such messages and <code>verbose = 4</code> asks for most verbose
output (see <code>control</code> arguments of <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>,
<code><a href="stats.html#topic+nlminb">nlminb</a></code> and <code><a href="stats.html#topic+optim">optim</a></code> and
<code><a href="#topic+control.georob">control.georob</a></code> for information how to fine tuning
diagnostic output generated by <code>nleqslv</code>, <code>nlminb</code> and
<code>optim</code>).</p>
</td></tr>
<tr><td><code id="georob_+3A_...">...</code></td>
<td>
<p>further arguments passed to function (e.g. <code>object.</code>
used internally for updating <code>georob</code> objects). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>georob</code> fits a spatial linear model by robust (<cite>Künsch et al., 2011</cite>, <cite>Künsch
et al., in preparation</cite>) or Gaussian RE(ML) (<cite>Harville, 1977</cite>).
<code><a href="#topic+georobPackage">georobPackage</a></code> describes the employed model and briefly
sketches the robust REML estimation and the robust external drift Kriging
method.  Here, we describe further details of <code>georob</code>.
</p>


<h4>Implemented variograms</h4>

<p>Currently, most basic variogram models provided formerly by the now
archived package <span class="pkg">RandomFields</span> can be fitted by <code>georob</code> (see
argument <code>variogram.model</code> and <code><a href="#topic+gencorr">gencorr</a></code> for a list of
implemented models).  Some of these models have in addition to
<code>variance</code>, <code>snugget</code>, <code>nugget</code> and <code>scale</code> further
parameters.  Initial values of these parameters (<code>param</code>) and
fitting flags (<code>fit.param</code>) must be passed to <code>georob</code> by the
same names as used for the models <code>RM...</code> in
<code><a href="#topic+gencorr">gencorr</a></code>.  Use the function <code><a href="#topic+param.names">param.names</a></code> to
list additional parameters of a given variogram.model.
</p>
<p>The arguments <code>fit.param</code> and <code>fit.aniso</code> are used to control
what variogram and anisotropy parameters are estimated and which are
kept at the constant initial values.  The functions<br />
<code><a href="#topic+default.fit.param">default.fit.param</a></code> and <code><a href="#topic+default.fit.aniso">default.fit.aniso</a></code> set
reasonable default values for these arguments.  Note, as an aside, that
the function <code><a href="#topic+default.aniso">default.aniso</a></code> sets (default) values of the
anisotropy parameters for an isotropic variogram.
</p>



<h4>Estimating parameters of power function variogram</h4>

<p>The intrinsic variogram model <code>RMfbm</code> is over-parametrized when
both the <code>variance</code> (plus possibly <code>snugget</code>) and the
<code>scale</code> are estimated.  Therefore, to estimate the parameters of
this model, <code>scale</code> must be kept fixed at an arbitrary value by
using <code>fit.param["scale"] = FALSE</code>.</p>



<h4>Estimating parameters of geometrically anisotropic variograms</h4>

<p>The subsection <strong>Model</strong> of <code><a href="#topic+georobPackage">georobPackage</a></code> describes
how such models are parametrized and gives definitions the various
elements of <code>aniso</code>.  Some additional remarks might be helpful:
</p>

<ul>
<li><p> The first semi-principal axis points into the direction with
the farthest reaching auto-correlation, which is described by the range
parameter <code>scale</code> (<code class="reqn">\alpha</code>).
</p>
</li>
<li><p> The ranges in the direction of the second and third
semi-principal axes are given by <code class="reqn">f_1\alpha</code> and <code class="reqn">f_2
      \alpha</code>, with <code class="reqn">0 &lt; f_2 \leq f_1 \leq 1</code>.
</p>
</li>
<li><p> The default values for <code>aniso</code> (<code class="reqn">f_1=1</code>, <code class="reqn">f_2=1</code>)
define an isotropic variogram model.
</p>
</li>
<li><p> Valid ranges for the angles characterizing the orientation of
the semi-variance ellipsoid are (in degrees): <code class="reqn">\omega</code> [0, 180],
<code class="reqn">\phi</code> [0, 180], <code class="reqn">\zeta</code> [-90, 90].  </p>
</li></ul>
 


<h4>Estimating variance of micro-scale variation</h4>

<p>Simultaneous estimation of the variance of the micro-scale variation
(<code>snugget</code>, <code class="reqn">\sigma_\mathrm{n}^2</code>), appears seemingly
as spatially uncorrelated with a given sampling design, and of the
variance (<code>nugget</code>, <code class="reqn">\tau^2</code>) of the independent errors
requires that for some locations
<code class="reqn">\boldsymbol{s}_i</code> replicated observations are
available.  Locations less or equal than <code>zero.dist</code> apart are
thereby considered as being coincident (see
<code><a href="#topic+control.georob">control.georob</a></code>).
</p>



<h4>Constraining estimates of variogram parameters</h4>

<p>Parameters of variogram models can vary only within certain bounds (see
<code><a href="#topic+param.bounds">param.bounds</a></code> and <code><a href="#topic+gencorr">gencorr</a></code>
for allowed ranges).  <code>georob</code> uses three mechanisms to constrain
parameter estimates to permissible ranges:
</p>

<ol>
<li> <p><em>Parameter transformations</em>: By default, all variance
(<code>variance</code>, <code>snugget</code>, <code>nugget</code>), the range
<code>scale</code>, the anisotropy parameters <code>f1</code> and <code>f2</code> and
many of the additional parameters are log-transformed before
solving the estimating equations or maximizing the restricted
log-likelihood and this warrants that the estimates are always
positive (see <code><a href="#topic+control.georob">control.georob</a></code> for detailed explanations
how to control parameter transformations).
</p>
</li>
<li> <p><em>Checking permissible ranges</em>: The additional parameters
of the variogram models such as the smoothness parameter <code class="reqn">\nu</code>
of the Whittle-Matérn model are forced to stay in the permissible
ranges by signalling an error to <code>nleqslv</code>, <code>nlminb</code> or
<code>optim</code> if the current trial values are invalid.  These
functions then graciously update the trial values of the parameters
and carry their task on.  However, it is clear that such a
procedure likely gets stuck at a point on the boundary of the
parameter space and is therefore just a workaround for avoiding
runtime errors due to invalid parameter values.
</p>
</li>
<li> <p><em>Exploiting the functionality of <code>nlminb</code> and
<code>optim</code></em>: If a spatial model is fitted non-robustly, then the
arguments <code>lower</code>, <code>upper</code> (and <code>method</code> of
<code><a href="stats.html#topic+optim">optim</a></code>) can be used to constrain the parameters
(see <code><a href="#topic+control.optim">control.optim</a></code> how to pass them to <code>optim</code>).
For <code>optim</code> one has to use the arguments <code>method =
        "L-BFGS-B"</code>, <code>lower = <var>l</var></code>, <code>upper = <var>u</var></code>, where
<var>l</var> and <var>u</var> are numeric vectors with the lower and upper
bounds of the <em>transformed</em> parameters in the order as they
appear in<br /> <code>c(variance, snugget, nugget, scale,
        ...)[fit.param], aniso[fit.aniso])</code>,<br /> where <code>...</code> are
additional parameters of isotropic variogram models (use <br />
<code>param.names(variogram.model)</code> to display the names and the
order of the additional parameters for <code>variogram.model</code>).
For <code>nlminb</code> one has to use the arguments <code>lower =
        <var>l</var></code>, <code>upper = <var>u</var></code>, where <var>l</var> and <var>u</var> are
numeric vectors as described above.
</p>
</li></ol>




<h4>Computing robust initial estimates of parameters for robust
REML</h4>

<p>To solve the robustified estimating equations for
<code class="reqn">\boldsymbol{B}</code> and
<code class="reqn">\boldsymbol{\beta}</code> the following initial
estimates are used:
</p>

<ul>
<li> <p><code class="reqn"> \widehat{\boldsymbol{B}}=
      \boldsymbol{0},</code> if this turns out to be
infeasible, initial values can be passed to <code>georob</code> by the
argument <code>bhat</code> of <code><a href="#topic+control.georob">control.georob</a></code>.
</p>
</li>
<li> <p><code class="reqn">\widehat{\boldsymbol{\beta}}</code> is
either estimated robustly by the function
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code>, <code><a href="quantreg.html#topic+rq">rq</a></code> or
non-robustly by <code><a href="stats.html#topic+lm">lm</a></code> (see argument
<code>initial.fixef</code> of <code><a href="#topic+control.georob">control.georob</a></code>).
</p>
</li></ul>

<p>Finding the roots of the robustified estimating equations of the
variogram and anisotropy parameters is more sensitive to a good choice
of initial values than maximizing the Gaussian (restricted)
log-likelihood with respect to the same parameters.  If the initial
values for <code>param</code> and <code>aniso</code> are not sufficiently close to
the roots of the system of nonlinear equations, then
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> may fail to find them.
Setting <code>initial.param = TRUE</code> (see <code><a href="#topic+control.georob">control.georob</a></code>)
allows one to find initial values that are
often sufficiently close to the roots so that
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> converges.  This is achieved by:
</p>

<ol>
<li><p> Initial values of the regression parameters are computed by
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code> irrespective of the choice for
<code>initial.fixef</code> (see <code><a href="#topic+control.georob">control.georob</a></code>).
</p>
</li>
<li><p> Observations with &ldquo;robustness weights&rdquo; of the
<code>lmrob</code> fit, satisfying<br />
<code class="reqn">\psi_c(\widehat{\varepsilon}_i/\widehat{\tau})/(\widehat{\varepsilon}_i/\widehat{\tau})
      \leq \mbox{\code{min.rweight}}</code>, are discarded (see
<code><a href="#topic+control.georob">control.georob</a></code>).
</p>
</li>
<li><p> The model is fit to the pruned data set by Gaussian REML using
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</li>
<li><p> The resulting estimates of the variogram parameters
(<code>param</code>, <code>aniso</code>) are used as initial estimates for the
subsequent robust fit of the model by <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.
</p>
</li></ol>

<p>Note that for step 3 above, initial values of <code>param</code> and
<code>aniso</code> must be provided to <code>georob</code>.
</p>



<h4>Estimating variance parameters by Gaussian (RE)ML</h4>

<p>Unlike robust REML, where robustified estimating equations are solved
for the variance parameters <code>nugget</code> (<code class="reqn">\tau^2</code>),
<code>variance</code> (<code class="reqn">\sigma^2</code>), and possibly <code>snugget</code>
(<code class="reqn">\sigma_{\mathrm{n}}^2</code>), for Gaussian (RE)ML the
variances can be re-parametrized to
</p>

<ul>
<li><p> the signal variance
<code class="reqn">\sigma_B^2 = \sigma^2 + \sigma_{\mathrm{n}}^2</code>,
</p>
</li>
<li><p> the inverse relative nugget
<code class="reqn">\eta = \sigma_B^2 / \tau^2</code> and
</p>
</li>
<li><p> the relative auto-correlated signal variance
<code class="reqn">\xi = \sigma^2/\sigma_B^2</code>.
</p>
</li></ul>

<p><code>georob</code> maximizes then a (restricted) <em>profile
log-likelihood</em> that depends only on <code class="reqn">\eta</code>, <code class="reqn">\xi</code>,
<code class="reqn">\alpha</code>, ..., and <code class="reqn">\sigma_B^2</code> is estimated by an explicit
expression that depends on these parameters (e.g. <cite>Diggle and
Ribeiro, 2006, p.  113</cite>).  This is usually more efficient than
maximizing the (restricted) log-likelihood with respect to the original
variance parameters <code class="reqn">\tau^2</code>,
<code class="reqn">\sigma_{\mathrm{n}}^2</code> and <code class="reqn">\sigma^2</code>.
<code>georob</code> chooses the parametrization automatically, but the user
can control it by the argument <code>reparam</code> of the function
<code><a href="#topic+control.georob">control.georob</a></code>.
</p>



<h3>Value</h3>

<p>An object of class <code>georob</code> representing a robust (or Gaussian) (RE)ML
fit of a spatial linear model.  See
<code><a href="#topic+georobObject">georobObject</a></code> for the components of the fit.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a><br />
with contributions by Cornelia Schwierz.
</p>


<h3>References</h3>

<p>Diggle, P. J. and Ribeiro, P. J. R. (2006) Model-based Geostatistics.
Springer, New York, <a href="https://doi.org/10.1007/978-0-387-48536-2">doi:10.1007/978-0-387-48536-2</a>.
</p>
<p>Harville, D. A. (1977) Maximum likelihood approaches to variance
component estimation and to related problems, <em>Journal of the
American Statistical Association</em>, <b>72</b>, 320&ndash;340,
<a href="https://doi.org/10.1080/01621459.1977.10480998">doi:10.1080/01621459.1977.10480998</a>.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A. (in
preparation) Robust Geostatistics.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A.
(2011) Robust estimation of the external drift and the variogram of
spatial data.  Proceedings of the ISI 58th World Statistics Congress of
the International Statistical Institute.  <a href="https://doi.org/10.3929/ethz-a-009900710">doi:10.3929/ethz-a-009900710</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################
## meuse data ##
################
data(meuse)

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)
summary(r.logzn.reml, correlation = TRUE)
plot(r.logzn.reml, lag.dist.def = seq(0, 2000, by = 100))

## robust REML fit
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.logzn.rob &lt;- update(r.logzn.reml, tuning.psi = 1)

  summary(r.logzn.rob, correlation = TRUE)
  lines(r.logzn.rob, col = "red")
}


###################
## wolfcamp data ##
###################
data(wolfcamp)

## fitting isotropic IRF(0) model

r.irf0.iso &lt;- georob(pressure ~ 1, data = wolfcamp, locations = ~ x + y,
    variogram.model = "RMfbm",
    param = c(variance = 10, nugget = 1500, scale = 1, alpha = 1.5),
    fit.param = default.fit.param(scale = FALSE, alpha = TRUE),
    tuning.psi = 1000)

summary(r.irf0.iso)
plot(r.irf0.iso, lag.dist.def = seq(0, 200, by = 7.5))

## fitting anisotropic IRF(0) model
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.irf0.aniso &lt;- georob(pressure ~ 1, data = wolfcamp, locations = ~ x + y,
      variogram.model = "RMfbm",
      param = c(variance = 5.9, nugget = 1450, scale = 1, alpha = 1),
      fit.param = default.fit.param(scale = FALSE, alpha = TRUE),
      aniso = default.aniso(f1 = 0.51, omega = 148.),
      fit.aniso = default.fit.aniso(f1 = TRUE, omega = TRUE),
      tuning.psi = 1000)
  summary(r.irf0.aniso)
  plot(r.irf0.aniso, lag.dist.def = seq(0, 200, by = 7.5),
      xy.angle.def = c(0, 22.5, 67.5, 112.5, 157.5, 180.),
      add = TRUE, col = 2:5)

  pchisq(2*(r.irf0.aniso[["loglik"]] - r.irf0.iso[["loglik"]]), 2, lower = FALSE)
}
</code></pre>

<hr>
<h2 id='georobModelBuilding'>S3 Methods for Stepwise Building Fixed-Effects Models for Class <code>georob</code></h2><span id='topic+georobModelBuilding'></span><span id='topic+add1.georob'></span><span id='topic+deviance.georob'></span><span id='topic+drop1.georob'></span><span id='topic+extractAIC.georob'></span><span id='topic+logLik.georob'></span><span id='topic+step'></span><span id='topic+step.default'></span><span id='topic+step.georob'></span><span id='topic+waldtest'></span><span id='topic+waldtest.georob'></span>

<h3>Description</h3>

<p>This page documents the methods <code>deviance</code>,
<code>logLik</code>, <code>extractAIC</code>, <code>add1</code>, <code>drop1</code>,
<code>step</code> and <code>waldtest</code> for the class <code>georob</code>.  The package
<code>georob</code> provides a generic <code>step</code> function and a default
method which is identical with the (non-generic) function
<code><a href="stats.html#topic+step">step</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'georob'
deviance(object, warn = TRUE, REML = FALSE, ...)

## S3 method for class 'georob'
logLik(object, warn = TRUE, REML = FALSE, ...)

## S3 method for class 'georob'
extractAIC(fit, scale = 0, k = 2, ...)

## S3 method for class 'georob'
add1(object, scope, scale = 0, test = c("none", "Chisq"), k = 2,
    trace = FALSE, fixed = TRUE, use.fitted.param = TRUE, verbose = 0,
    ncores = 1, ...)

## S3 method for class 'georob'
drop1(object, scope, scale = 0, test = c("none", "Chisq"), k = 2,
    trace = FALSE, fixed = TRUE, use.fitted.param = TRUE, verbose = 0,
    ncores = 1, ...)

step(object, ...)

## Default S3 method:
step(object, scope, scale = 0,
    direction = c("both", "backward", "forward"), trace = 1,
    keep = NULL, steps = 1000, k = 2, ...)

## S3 method for class 'georob'
step(object, scope, scale = 0,
    direction = c("both", "backward", "forward"), trace = 1,
    keep = NULL, steps = 1000, k = 2,
    fixed.add1.drop1 = TRUE, fixed.step = fixed.add1.drop1,
    use.fitted.param = TRUE, verbose = 0, ncores = 1, ...)

## S3 method for class 'georob'
waldtest(object, ..., vcov = NULL, test = c("F", "Chisq"),
    name = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georobModelBuilding_+3A_object">object</code>, <code id="georobModelBuilding_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>georob</code>, see
<code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_direction">direction</code></td>
<td>
<p>a character keyword with the mode of stepwise search,
see <code><a href="stats.html#topic+step">step</a></code>.  </p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_fixed">fixed</code>, <code id="georobModelBuilding_+3A_fixed.add1.drop1">fixed.add1.drop1</code></td>
<td>
<p>a logical scalar controlling whether the
variogram parameters are <em>not</em> adjusted when <code>add</code>ing or
<code>drop</code>ping model terms by <code>add1</code> and <code>drop1</code> (default
<code>TRUE</code>), see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_fixed.step">fixed.step</code></td>
<td>
<p>a logical scalar controlling whether the variogram
parameters are <em>not</em> adjusted after having called <code>add1</code> and
<code>drop1</code> in <code>step</code> (default <code>TRUE</code>), see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_k">k</code></td>
<td>
<p>a numeric specifying the 'weight' of the equivalent degrees of
freedom (=: edf) part in the AIC formula, see
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_keep">keep</code></td>
<td>
<p>a filter function whose input is a fitted model object and the
associated <code>AIC</code> statistic, and whose output is arbitrary,
see <code><a href="stats.html#topic+step">step</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_name">name</code></td>
<td>
<p>a function for extracting a suitable name/description from a
fitted model object.  By default the name is queried by calling
<code><a href="stats.html#topic+formula">formula</a></code>, see
<code><a href="lmtest.html#topic+waldtest">waldtest</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_ncores">ncores</code></td>
<td>
<p>an integer specifying the number of cores used for
parallelized execution of <code>add1</code> and <code>drop1</code>.  If larger than
one then the minimum of <code>ncores</code>, <code>parallel::detectCores()</code>
and the number of terms to be added or dropped determines the number of
cores that is actually used.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_reml">REML</code></td>
<td>
<p>a logical scalar controlling whether the restricted log-likelihood
should be extracted (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_scale">scale</code></td>
<td>
<p>a numeric, currently not used, see
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_scope">scope</code></td>
<td>
<p>defines the range of models examined in the stepwise search.
This should be either a single formula, or a list containing
components <code>upper</code> and <code>lower</code>, both formulae,
see <code><a href="stats.html#topic+step">step</a></code> for details.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_steps">steps</code></td>
<td>
<p>a numeric with the maximum number of steps to be considered
(default is 1000), see <code><a href="stats.html#topic+step">step</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_test">test</code></td>
<td>
<p>a character keyword specifying whether to compute the large
sample Chi-squared statistic (with asymptotic Chi-squared distribution)
or the finite sample F statistic (with approximate F distribution), see
<code><a href="lmtest.html#topic+waldtest">waldtest</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_trace">trace</code></td>
<td>
<p>a numeric.  If positive, information is printed during the
running of <code>step</code>, see <code><a href="stats.html#topic+step">step</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_use.fitted.param">use.fitted.param</code></td>
<td>
<p>a logical scalar controlling whether fitted
values of <code>param</code> (and <code>aniso</code> are used as initial values
when variogram parameters are fitted afresh for <code>add</code>ing and
<code>drop</code>ping terms from the model (default <code>TRUE</code>).  If equal
to <code>FALSE</code> then the initial values in <code>object[["call"]]</code> are
used.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_vcov">vcov</code></td>
<td>
<p>a function for estimating the covariance matrix of the
regression coefficients, see <code><a href="lmtest.html#topic+waldtest">waldtest</a></code>.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console during model fitting, see <code><a href="#topic+georob">georob</a></code>
(default <code>0</code>).</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_warn">warn</code></td>
<td>
<p>a logical scalar controlling whether warnings should be
suppressed.</p>
</td></tr>
<tr><td><code id="georobModelBuilding_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods (see in particular
<code>waldtest.default</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a non-robust fit the  function <code>deviance</code> returns the residual deviance
</p>
<p style="text-align: center;"><code class="reqn">(\boldsymbol{Y} - \boldsymbol{X} \widehat{\boldsymbol{\beta}})^{\mathrm{T}}
    (\widehat{\tau}^2 \boldsymbol{I} +
    \boldsymbol{\Gamma}_{\widehat{\theta}})^{-1}
    (\boldsymbol{Y} - \boldsymbol{X} \widehat{\boldsymbol{\beta}})
    </code>
</p>

<p>(see <code><a href="#topic+georobPackage">georobPackage</a></code> for an explanation of the notation).
For a robust fit the deviance is not defined. The function then computes with a warning
the deviance of an equivalent Gaussian model with heteroscedastic nugget
<code class="reqn">\tau^2/\boldsymbol{w}</code> where <code class="reqn">\boldsymbol{w}</code> are
the &ldquo;robustness weights&rdquo; <code>rweights</code>, see <code><a href="#topic+georobObject">georobObject</a></code>.
</p>
<p><code>logLik</code> returns the maximized (restricted) log-likelihood.  For
a robust fit, the log-likelihood is not defined.  The function then
computes the (restricted) log-likelihood of an equivalent Gaussian model with
heteroscedastic nugget (see above).
</p>
<p>The methods <code>extractAIC</code>, <code>add1</code>, <code>drop1</code> and <code>step</code>
are used for stepwise model building. <br /> If <code>fixed=TRUE</code> or
<code>fixed.add1.drop1=TRUE</code> (default) then the variogram parameters are
kept fixed at the values of <code>object</code>.  For
<code>fixed=FALSE</code> or <code>fixed.add1.drop1=FALSE</code> the variogram
parameters are fitted afresh for each model tested by <code>add1</code> and
<code>drop1</code>.  Then either the variogram parameters in
<code>object$initial.objects</code> (<code>use.fitted.param=FALSE</code>) or the
fitted parameters of <code>object</code> (<code>use.fitted.param=TRUE</code>) are
used as initial values.  For <code>fixed.step=TRUE</code> the variogram
parameters are <em>not</em> fitted afresh by <code>step</code> after the calls to
<code>drop1</code> and <code>add1</code> have been completed, unlike for
<code>fixed.step=FALSE</code> where the parameters are estimated afresh for
the new model that minimized AIC (BIC) in the previous step.
</p>
<p>In addition, the functions of the <span class="rlang"><b>R</b></span> package <span class="pkg">multcomp</span> can be used
to test general linear hypotheses about the fixed effects of the model.
</p>


<h3>Value</h3>

<p>The method <code>deviance.georob</code> returns the deviance of the fitted
spatial linear model with the attributes <code>log.det.covmat</code>
containing the logarithm of the determinant of the covariance matrix
<code class="reqn">
    \tau^2 \boldsymbol{I} + \boldsymbol{\Gamma}_\theta
  </code>
of the observations and optionally
<code>log.det.xticovmatx</code> with the logarithm of the determinant of
<code class="reqn">
    \boldsymbol{X}^\mathrm{T} (\tau^2
    \boldsymbol{I} + \boldsymbol{\Gamma}_\theta)^{-1} \boldsymbol{X}
  </code>, when <code>REML = true</code>,
see <em>Details</em> above.
</p>
<p>The method <code>logLik.georob</code> returns an object of class <code>logLik</code>
with the maximized (restricted) log-likelihood, see <em>Details</em> above
and <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>
<p>The method <code>extractAIC.georob</code> returns a numeric vector of length 2
with the first and second elements giving the equivalent degrees of
freedom and the (generalized) Akaike Information Criterion for the fitted
model <code>fit</code>.
</p>
<p>The methods <code>add1.georob</code> and <code>drop1.georob</code> return objects of
class <code>anova</code> which are <code><a href="base.html#topic+data.frame">data.frame</a></code>s summarizing the
differences in fit between models.  In addition to the customary
variables <code>Df</code> and <code>AIC</code> the output contains a logical variable
<code>Converged</code> which signals (non-)convergence when fitting the
respective sub-model.
</p>
<p>The generic function <code>step</code> returns the stepwise selected model plus
optionally some additional attributes depending on the method.
</p>
<p>The methods <code>step.default</code> and <code>step.georob</code> return the
stepwise-selected model with up to two additional components
(<code>anova</code>, <code>keep</code>), see <code><a href="stats.html#topic+step">step</a></code> for details.
</p>
<p>The method <code>waldtest.georob</code> returns an object of class <code>anova</code>
which contains the residual degrees of freedom, the difference in degrees
of freedom, Wald statistic (either &quot;Chisq&quot; or &quot;F&quot;) and corresponding
<var>p</var>-value.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)
summary(r.logzn.reml, correlation = TRUE)

deviance(r.logzn.reml)
logLik(r.logzn.reml)

waldtest(r.logzn.reml, .~. + ffreq)

step(r.logzn.reml, ~ sqrt(dist) + ffreq + soil)

## robust REML fit
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s

  r.logzn.rob &lt;- update(r.logzn.reml, tuning.psi = 1)

  deviance(r.logzn.rob)
  logLik(r.logzn.rob)
  logLik(r.logzn.rob, REML=TRUE)

  step(r.logzn.rob, ~ sqrt(dist) + ffreq + soil, fixed.step=FALSE, trace=2)
}
</code></pre>

<hr>
<h2 id='georobObject'>Fitted georob Object</h2><span id='topic+georobObject'></span>

<h3>Description</h3>

<p>An object of class <code>georob</code> as returned by <code><a href="#topic+georob">georob</a></code> and
representing a (robustly) fitted spatial linear model.  Objects of this
class have methods for model building (see
<code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code>) and cross-validation (see
<code><a href="#topic+cv.georob">cv.georob</a></code>), for computing (robust) Kriging predictions (see
<code><a href="#topic+predict.georob">predict.georob</a></code>), for plotting (see
<code><a href="#topic+plot.georob">plot.georob</a></code>) and for common generic functions (see
<code><a href="#topic+georobMethods">georobMethods</a></code>).  </p>


<h3>Value</h3>

<p>A <code>georob</code> object is a list with following components:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>the maximized (restricted) Gaussian log-likelihood of a
non-robust (RE)ML fit or <code>NA</code> for a robust fit if
<code>tuning.psi</code> is less than <code>tuning.psi.nr</code>.</p>
</td></tr>
<tr><td><code>variogram.object</code></td>
<td>
<p>the estimated parameters of a possibly nested
variograms model.  This is a list that contains for each variogram model
structure the following components:
</p>

<ul>
<li><p><code>variogram.model</code>: the name of the fitted parametric variogram
model.
</p>
</li>
<li><p><code>param</code>: a named numeric vector with the (estimated) variogram
parameters.
</p>
</li>
<li><p><code>fit.param</code>: a named logical vector with the flags defining what
variogram parameters were estimated.
</p>
</li>
<li><p><code>isotropic</code>: logical indicating whether an isotropic
variogram was fitted.
</p>
</li>
<li><p><code>aniso</code>: a named numeric vector with the (estimated)
anisotropy parameters.
</p>
</li>
<li><p><code>fit.aniso</code>: a named logical vector with the flags defining what
anisotropy parameters were estimated.
</p>
</li>
<li><p><code>sincos</code>: a list with <code>sin</code> and <code>cos</code> of the
angles <code class="reqn">\omega</code>, <code class="reqn">\phi</code> and <code class="reqn">\zeta</code> that define the
orientation of the anisotropy ellipsoid (see <code><a href="#topic+georobPackage">georobPackage</a></code>).
</p>
</li>
<li><p><code>rotmat</code>: the matrix
<code class="reqn">(\boldsymbol{C}_1,
      \boldsymbol{C}_2,
      \boldsymbol{C}_3)</code> (see
<code><a href="#topic+georobPackage">georobPackage</a></code>).
</p>
</li>
<li><p><code>sclmat</code>: a vector with the elements 1, <code class="reqn">1/f_1</code>,
<code class="reqn">1/f_2</code> (see <code><a href="#topic+georobPackage">georobPackage</a></code>). 
</p>
</li></ul>

</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>a named numeric vector with the estimating equations
(robust REML) or the gradient of the maximized (restricted) log-likelihood
(Gaussian (RE)ML) evaluated at the solution.</p>
</td></tr>
<tr><td><code>tuning.psi</code></td>
<td>
<p>the value of the tuning constant <code class="reqn">c</code> of the
<code class="reqn">\psi_c</code>-function.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector with the estimated regression coefficients
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a named vector with the fitted values of the
external drift
<code class="reqn">\boldsymbol{X}\widehat{\boldsymbol{\beta}}</code>.</p>
</td></tr>
<tr><td><code>bhat</code></td>
<td>
<p>a named vector with the predicted spatial random effects
<code class="reqn">\widehat{\boldsymbol{B}}</code> at the data locations.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a named vector with the residuals
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y} -
  \boldsymbol{X} \widehat{\boldsymbol{\beta}} -
  \widehat{\boldsymbol{B}}</code>.</p>
</td></tr>
<tr><td><code>rweights</code></td>
<td>
<p>a named numeric vector with the &ldquo;robustness weights&rdquo;
<code class="reqn">\psi_c(\widehat{\varepsilon}_i/\widehat{\tau}) /
    (\widehat{\varepsilon}_i/\widehat{\tau})</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>a logical scalar indicating whether numerical maximization of
the (restricted)<br /> log-likelihood by <code>nlminb</code> or <code>optim</code> or root
finding by <code>nleqslv</code> converged.</p>
</td></tr>
<tr><td><code>convergence.code</code></td>
<td>
<p>a diagnostic integer issued by
<code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="stats.html#topic+optim">optim</a></code> (component
<code>convergence</code>) or <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> (component
<code>termcd</code>) about convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>a named integer vector of length two, indicating either
</p>

<ul>
<li><p> the number of function and gradient evaluations when maximizing
the (restricted) Gaussian log-likelihood by <code><a href="stats.html#topic+nlminb">nlminb</a></code>
or <code><a href="stats.html#topic+optim">optim</a></code>, or
</p>
</li>
<li><p> the number of function and Jacobian evaluations when solving
the robustified estimating equations by
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.
</p>
</li></ul>

</td></tr>
<tr><td><code>Tmat</code></td>
<td>
<p>the compressed design matrix for replicated observations at
coincident locations (integer vector that contains for each observation
the row index of the respective unique location).</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a list with covariance matrices (or diagonal variance
vectors).  Covariance matrices are stored in <em>compressed form</em> (see
<code><a href="#topic+compress">compress</a></code>) and can be expanded to square matrices by
<code><a href="#topic+expand">expand</a></code>.  What <code>cov</code> actually contains depends on the
flags passed to <code>georob</code> for computing covariances (see
<code><a href="#topic+control.georob">control.georob</a></code>).  Possible components are:
</p>

<ul>
<li> <p><code>cov.bhat</code>: the covariances of
<code class="reqn">\widehat{\boldsymbol{B}}</code>.
</p>
</li>
<li> <p><code>cov.betahat</code>: the covariances of
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>.
</p>
</li>
<li> <p><code>cov.delta.bhat</code>: the covariances of
<code class="reqn">\boldsymbol{B}- \widehat{\boldsymbol{B}}</code>.
</p>
</li>
<li> <p><code>cov.delta.bhat.betahat</code>: the covariances of
<code class="reqn">\boldsymbol{B}- \widehat{\boldsymbol{B}}</code>
and
<code class="reqn">\widehat{\boldsymbol{\beta}}</code>.
</p>
</li>
<li> <p><code>cov.ehat</code>: the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}}=\boldsymbol{Y} -
      \boldsymbol{X} \widehat{\boldsymbol{\beta}} -
      \widehat{\boldsymbol{B}}</code>.
</p>
</li>
<li> <p><code>cov.ehat.p.bhat</code>: the covariances of
<code class="reqn">\widehat{\boldsymbol{\varepsilon}} +
      \widehat{\boldsymbol{B}}
      =\boldsymbol{Y} -
      \boldsymbol{X} \widehat{\boldsymbol{\beta}}</code>.
</p>
</li>
<li> <p><code>cov.pred.target</code>: a covariance term required for the
back-trans-<br /> formation of Kriging predictions of log-transformed data.
</p>
</li></ul>

</td></tr>
<tr><td><code>expectations</code></td>
<td>
<p>a named numeric vector with the expectations of
<code class="reqn">\partial \psi_c(x)/\partial x</code> and <code class="reqn">\psi_c^2(x)</code>
with respect to a standard normal distribution (<code>exp.gauss.dpsi</code>,
<code>var.gauss.psi</code>) and the expectations of
<code class="reqn">\varepsilon^2</code> and <code class="reqn">\psi_c^2(x)</code> with respect to the
long-tailed distribution of <code class="reqn">\varepsilon</code>
(<code>var.f0.eps</code>, <code>var.f0.psi</code>).</p>
</td></tr>
<tr><td><code>Valphaxi.objects</code></td>
<td>
<p>a list of matrices in <em>compressed form</em> with
(among others) the following components:
</p>

<ul>
<li> <p><code>Valpha</code>: a list with the (generalized) correlation
matrices (<code>Valpha</code>) of the nested variogram models structures
along with the constants (<code>gcr.constant</code>) added to the respective
semi-variance matrices.
</p>
</li>
<li> <p><code>Valphaxi</code>: the (generalized) correlation matrix
<code class="reqn">\boldsymbol{V}_{\alpha,\xi} =
      \boldsymbol{\Gamma}_{\alpha,\xi} /
      (\sigma_{\mathrm{n}}^2+\sigma^2 )</code> that includes the spatial nugget effect.
</p>
</li>
<li> <p><code>Valphaxi.inverse</code>: the inverse of
<code class="reqn">\boldsymbol{V}_{\alpha,\xi}</code>.
</p>
</li>
<li> <p><code>log.det.Valphaxi</code>:
<code class="reqn">\log(\det(\boldsymbol{V}_{\alpha,\xi}))</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code>zhat.objects</code></td>
<td>
<p>a list of matrices in (partly) <em>compressed form</em> with
the following components:
</p>

<ul>
<li> <p><code>Aalphaxi</code>: the matrix
<code class="reqn">(\boldsymbol{X}^T
      \boldsymbol{V}_{\alpha,\xi}^{-1}\boldsymbol{X})^{-1}
      \boldsymbol{X}^T\boldsymbol{V}_{\alpha,\xi}^{-1}
      </code>.
</p>
</li>
<li> <p><code>Palphaxi</code>: the matrix
<code class="reqn">\boldsymbol{I}-
      \boldsymbol{X} \boldsymbol{A}_{\alpha,\xi}
      </code>.
</p>
</li>
<li> <p><code>Valphaxi.inverse.Palphaxi</code>: the matrix
<code class="reqn">\boldsymbol{V}^{-1}_{\alpha,\xi}
      \boldsymbol{P}_{\alpha,\xi} </code>.
</p>
</li></ul>

</td></tr>
<tr><td><code>locations.object</code></td>
<td>
<p>a list with 3 components:
</p>

<ul>
<li> <p><code>locations</code>: a formula indicating the coordinates of the
measurement locations.
</p>
</li>
<li> <p><code>coordinates</code>: a numeric matrix with the coordinates
of the measurement locations.
</p>
</li>
<li> <p><code>lag.vectors</code>: a numeric matrix with the lag vectors
between any distinct pairs of measurement locations.
</p>
</li></ul>

</td></tr>
<tr><td><code>initial.objects</code></td>
<td>
<p>a list with 3 components:
</p>

<ul>
<li> <p><code>coefficients</code>: initial estimates of
<code class="reqn">\boldsymbol{\beta}</code> computed either by
<code><a href="robustbase.html#topic+lmrob">lmrob</a></code> or <code><a href="quantreg.html#topic+rq">rq</a></code>.
</p>
</li>
<li> <p><code>bhat</code>: initial predictions of
<code class="reqn">\boldsymbol{B}</code>.
</p>
</li>
<li> <p><code>variogram.object</code>: the initial values of the parameters
of a possibly nested variograms model.  This is a list with the same
structure as described above for the component
<code>variogram.object</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code>hessian.tfpa</code></td>
<td>
<p>a symmetric matrix with the Hessian (observed
Fisher information) at the solution with respect to the transformed
variogram and anisotropy parameters if the model was fitted non-robustly
with the argument <code>hessian = TRUE</code> (see
<code><a href="#topic+control.georob">control.georob</a></code>).  Missing otherwise.  This Hessian is used
by <code><a href="#topic+summary.georob">summary.georob</a></code> to compute confidence intervals for the
estimated parameters.</p>
</td></tr>
<tr><td><code>hessian.ntfpa</code></td>
<td>
<p>a symmetric matrix with the Hessian (observed
Fisher information) at the solution with respect to the non-transformed
variogram and anisotropy parameters if the model was fitted non-robustly
with the argument <code>hessian = TRUE</code> (see
<code><a href="#topic+control.georob">control.georob</a></code>).  Missing otherwise.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a list with control parameters generated by
<code><a href="#topic+control.georob">control.georob</a></code>.</p>
</td></tr>
<tr><td><code>MD</code></td>
<td>
<p>optionally a matrix of robust distances in the space spanned by
<code class="reqn">\boldsymbol{X}</code> (see argument <code>compute.rd</code>
of <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code> and
<code><a href="#topic+control.georob">control.georob</a></code>).</p>
</td></tr>
<tr><td><code>model</code>, <code>x</code>, <code>y</code></td>
<td>
<p>if requested the model frame, the model matrix and the
response, respectively.</p>
</td></tr>
<tr><td><code>na.action</code>, <code>offset</code>, <code>contrasts</code>, <code>xlevels</code>, <code>rank</code>, <code>df.residual</code>, <code>call</code>, <code>terms</code></td>
<td>
<p>further
components of the fit as described for an object of class
<code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>

<hr>
<h2 id='georobS3methods'>Common S3 Methods for Class <code>georob</code></h2><span id='topic+georobS3methods'></span><span id='topic+georobMethods'></span><span id='topic+coef.georob'></span><span id='topic+fixed.effects'></span><span id='topic+fixed.effects.georob'></span><span id='topic+fixef'></span><span id='topic+fixef.georob'></span><span id='topic+model.frame.georob'></span><span id='topic+model.matrix.georob'></span><span id='topic+nobs.georob'></span><span id='topic+print.coef.georob'></span><span id='topic+print.georob'></span><span id='topic+print.summary.georob'></span><span id='topic+random.effects'></span><span id='topic+random.effects.georob'></span><span id='topic+ranef'></span><span id='topic+ranef.georob'></span><span id='topic+resid.georob'></span><span id='topic+residuals.georob'></span><span id='topic+rstandard.georob'></span><span id='topic+summary.georob'></span><span id='topic+vcov.georob'></span>

<h3>Description</h3>

<p>This page documents the methods <code>coef</code>, <code>fixef</code>,
<code>fixed.effects</code>, <code>model.frame</code>, <code>model.matrix</code>,
<code>nobs</code>, <code>print</code>, <code>ranef</code>, <code>random.effects</code>,
<code>resid</code>, <code>residuals</code>, <code>rstandard</code>, 
<code>summary</code> and <code>vcov</code> for the class <code>georob</code> which extract
the respective components or summarize a <code>georob</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'georob'
coef(object, what = c("trend", "variogram"), ...)

## S3 method for class 'georob'
fixef(object, ...)

## S3 method for class 'georob'
fixed.effects(object, ...)

## S3 method for class 'georob'
model.frame(formula, ...)

## S3 method for class 'georob'
model.matrix(object, ...)

## S3 method for class 'georob'
nobs(object, ...)

## S3 method for class 'georob'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'georob'
ranef(object, standard = FALSE, ...)

## S3 method for class 'georob'
random.effects(object, standard = FALSE, ...)

## S3 method for class 'georob'
resid(object,
    type = c("working", "response", "deviance", "pearson", "partial"),
    terms = NULL,
    level = 1, ...)

## S3 method for class 'georob'
residuals(object,
    type = c("working", "response", "deviance", "pearson", "partial"),
    terms  = NULL,
    level = 1, ...)

## S3 method for class 'georob'
rstandard(model, level = 1, ...)

## S3 method for class 'georob'
summary(object, correlation = FALSE, signif = 0.95, ...)

## S3 method for class 'georob'
vcov(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georobS3methods_+3A_object">object</code>, <code id="georobS3methods_+3A_model">model</code>, <code id="georobS3methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>georob</code>, see
<code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_formula">formula</code></td>
<td>
<p>a model <code><a href="stats.html#topic+formula">formula</a></code> or
<code><a href="stats.html#topic+terms">terms</a></code> object or an object of class <code>georob</code>, see
<code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_correlation">correlation</code></td>
<td>
<p>a logical scalar controlling whether the correlation
matrix of the estimated regression coefficients and of the fitted
variogram parameters (only for non-robust fits) is computed (default
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating the number of decimal digits to print.</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_level">level</code></td>
<td>
<p>an optional integer giving the level for extracting the
residuals from <code>object</code>.  <code>level = 0</code> extracts the regression
residuals <code class="reqn">\widehat{B}(\boldsymbol{s}) +
  \widehat{\varepsilon}(\boldsymbol{s})</code> and <code>level = 1</code> (default) only the estimated errors
<code class="reqn">\widehat{\varepsilon}(\boldsymbol{s})</code>.</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_signif">signif</code></td>
<td>
<p>a numeric with the confidence level for computing
confidence intervals for variogram parameters (default <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_standard">standard</code></td>
<td>
<p>a logical scalar controlling whether the spatial random effects
<code class="reqn">\boldsymbol{B}</code> should be standardized (default
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_type">type</code></td>
<td>
<p>a character keyword indicating the type of residuals to
compute, see <code><a href="stats.html#topic+residuals.lm">residuals.lm</a></code>.
<code>type = "huber"</code>
computes &lsquo;huberized&rsquo; residuals <code class="reqn">\widehat{\sigma} /
  \gamma_1\psi(\widehat{\varepsilon}(\boldsymbol{s}) /
  \widehat{\sigma})</code>.
</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_terms">terms</code></td>
<td>
<p>If <code>type = "terms"</code>, which terms (default is all terms).</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_what">what</code></td>
<td>
<p>If <code>what = "trend"</code> (default) the function <code>coef</code>
extracts the coefficients of the trend model and for <code>what =
  "variogram"</code> the variogram parameters.</p>
</td></tr>
<tr><td><code id="georobS3methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For robust REML fits <code>deviance</code> returns (possibly with a warning)
the deviance of the Gaussian REML fit of the equivalent Gaussian spatial
linear model with heteroscedastic nugget.
</p>
<p>The methods <code>model.frame</code>, <code>model.matrix</code> and <code>nobs</code>
extract the model frame, model matrix and the number of observations, see
help pages of respective generic functions.
</p>
<p>The methods <code>residuals</code> (and <code>resid</code>) extract either the
estimated independent errors
<code class="reqn">\widehat{\varepsilon}(\boldsymbol{s})</code>
or the sum of the latter quantities and the spatial random effects
<code class="reqn">\widehat{B}(\boldsymbol{s})</code>.
<code>rstandard</code> does the same but standardizes the residuals to unit
variance.  <code>ranef</code> (<code>random.effects</code>) extracts the spatial
random effects with the option to standardize them as well, and
<code>fixef</code> (<code>fixed.effects</code>) extracts the fitted fixed-effects
regression coefficients, which may of course also be obtained by
<code>coef</code>.
</p>
<p>For Gaussian REML the method <code>summary</code> computes confidence intervals
of the estimated variogram and anisotropy parameters from the Hessian
matrix of the (restricted) log-likelihood (= observed Fisher
information), based on the asymptotic normal distribution of (RE)ML
estimates.  Note that the Hessian matrix with respect to the
<em>transformed</em> variogram and anisotropy parameters is used for this.
Hence the inverse Hessian matrix is the covariance matrix of the
transformed parameters, confidence intervals are first computed for the
transformed parameters and the limits of these intervals are transformed
back to the orginal scale of the parameters.  Optionally, <code>summary</code>
reports the correlation matrix of the <em>transformed</em> parameters, also
computed from the Hessian matrix.
</p>
<p>Note that the methods <code>coef</code> and <code>summary</code> generate objects of
class <code>coef.georob</code> and <code>summary.georob</code>, respectively, for
which only <code>print</code> methods are available.
</p>
<p>Besides, the default methods of the generic functions
<code><a href="stats.html#topic+confint">confint</a></code>,
<code><a href="stats.html#topic+df.residual">df.residual</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+termplot">termplot</a></code> and
<code><a href="stats.html#topic+update">update</a></code> can be used for objects of class
<code>georob</code>.
</p>


<h3>Value</h3>

<p>The methods <code>fixef.georob</code> and <code>fixed.effects.georob</code> return
the numeric vector of estimated fixed-effects regression coefficients, and
<code>vcov.georob</code> returns the covariance matrix of the estimated
regression coefficients.
</p>
<p>The method <code>coef.georob</code> returns an object of class
<code>coef.georob</code> which is a numeric vector with estimated fixed-effects
regression coefficients or variogram and anisotropy parameters.  There is
a <code>print</code> method for objects of class <code>coef.georob</code> which
returns invisibly the object unchanged.
</p>
<p>The methods <code>resid.georob</code>, <code>residuals.georob</code> and
<code>rstandard.georob</code> return numeric vectors of (standardized)
residuals, and <code>ranef.georob</code> and <code>random.effects.georob</code> the
numeric vector of (standardized) spatial random effects, see
<em>Details</em>.
</p>
<p>The methods <code>model.frame.georob</code> and <code>model.matrix.georob</code>
return a model frame and the fixed-effects model matrix, respectively,
and <code>nobs.georob</code> returns the number of observations used to fit a
spatial linear model.
</p>
<p>The method <code>summary.georob</code> generates an object of class
<code>summary.georob</code> which is a list with components extracted directly
from <code>object</code> (<code>call</code>, <code>residuals</code>, <code>bhat</code>,
<code>rweights</code>, <code>converged</code>, <code>convergence.code</code>, <code>iter</code>,
<code>loglik</code>, <code>variogram.object</code>, <code>gradient</code>,
<code>tuning.psi</code>, <code>df.residual</code>, <code>control</code>, <code>terms</code>)
and complemented by the following components:
</p>

<dl>
<dt><code>scale</code></dt><dd><p>the square root of the estimated nugget effect
<code class="reqn">\tau^2</code>.</p>
</dd>
<dt><code>coefficients</code></dt><dd><p>a 4-column matrix with estimated regression
coefficients, their standard errors, <var>t</var>-statistics and
corresponding (two-sided) <var>p</var>-values.</p>
</dd>
<dt><code>correlation</code></dt><dd><p>an optional <code><a href="#topic+compress">compress</a></code>ed
lower-triagonal matrix with the Pearson correlation coefficients of the
estimated regression coefficients.</p>
</dd>
<dt><code>param.aniso</code></dt><dd><p>either a vector (robust REML) or a 3-column
matrix (Gaussian REML) with estimated variogram and anisotropy
parameters, complemented for Gaussian REML with confidence limits, see
<em>Details</em>.</p>
</dd>
<dt><code>cor.tf.param</code></dt><dd><p>an optional <code><a href="#topic+compress">compress</a></code>ed
lower-triagonal matrix with the Pearson correlation coefficients of
estimated transformed variogram and anisotropy parameters, see
<em>Details</em>.</p>
</dd>
<dt><code>se.residuals</code></dt><dd><p>a vector with the standard errors of the
estimated <code class="reqn">\varepsilon</code>.</p>
</dd>
</dl>

<p>There is a <code>print</code> methods for class <code>summary.georob</code> which
invisibly returns the object unchanged.
</p>
<p>The method <code>print.georob</code> invisibly returns the object unchanged.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)
summary(r.logzn.reml, correlation = TRUE)

## robust REML fit
r.logzn.rob &lt;- update(r.logzn.reml, tuning.psi = 1)

summary(r.logzn.rob, correlation = TRUE)

## residual diagnostics
old.par &lt;- par(mfrow = c(2,3))

plot(fitted(r.logzn.reml), rstandard(r.logzn.reml))
abline(h = 0, lty = "dotted")
qqnorm(rstandard(r.logzn.reml))
abline(0, 1)
qqnorm(ranef(r.logzn.reml, standard = TRUE))
abline(0, 1)
plot(fitted(r.logzn.rob), rstandard(r.logzn.rob))
abline(h = 0, lty = "dotted")
qqnorm(rstandard(r.logzn.rob))
abline(0, 1)
qqnorm(ranef(r.logzn.rob, standard = TRUE))
abline(0, 1)

par(old.par)
</code></pre>

<hr>
<h2 id='georobSimulation'>Simulating Realizations of Gaussian Processes</h2><span id='topic+georobSimulation'></span><span id='topic+condsim'></span><span id='topic+control.condsim'></span>

<h3>Description</h3>

<p>This page documents the function <code>condsim</code> that
simulates (un)conditional realizations of Gaussian processes from the
parameters of a spatial linear model estimated by the function
<code><a href="#topic+georob">georob</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  condsim(object, newdata, nsim, seed, type =  c("response", "signal"),
    locations, trend.coef = NULL,
    variogram.model = NULL, param = NULL, aniso = NULL, variogram.object = NULL,
    control = control.condsim(), verbose = 0)

  control.condsim(use.grid = FALSE, grid.refinement = 2.,
    condsim = TRUE, ce.method = c( "standard", "approximate" ),
    ce.grid.expansion = 1., include.data.sites = FALSE,
    means = FALSE, trend.covariates = FALSE, covariances = FALSE,
    ncores = 1, mmax = 10000, pcmp = control.pcmp())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georobSimulation_+3A_object">object</code></td>
<td>
<p>an object of class <code>georob</code> (mandatory argument), see
<code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_newdata">newdata</code></td>
<td>
<p>a mandatory data frame,
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>,
<code><a href="sp.html#topic+SpatialPixels">SpatialPixels</a></code> or
<code><a href="sp.html#topic+SpatialGrid">SpatialGrid</a></code> object,
with the coordinates of points for which simulations are computed
and in which to look for variables required for computing fitted values
or Kriging predictions,  see <code><a href="#topic+predict.georob">predict.georob</a></code>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_nsim">nsim</code></td>
<td>
<p>a positive interger with the number of (condititional)
realizations to compute (mandatory argument).</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_seed">seed</code></td>
<td>
<p>an integer seed to initialize random number generation,
see <code><a href="base.html#topic+set.seed">set.seed</a></code> (mandatory argument).</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_type">type</code></td>
<td>
<p>a character keyword defining what target quantity should be
simulated.  Possible values are
</p>

<ul>
<li> <p><code>"signal"</code>: the &ldquo;signal&rdquo;
<code class="reqn">Z(\boldsymbol{s}) =
      \boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta} +
      B(\boldsymbol{s})</code> of
the process,
</p>
</li>
<li> <p><code>"response"</code>: the observations
<code class="reqn">Y(\boldsymbol{s}) =
      Z(\boldsymbol{s}) +
      \varepsilon(\boldsymbol{s}),</code>  (default),
</p>
</li></ul>

<p>see <code><a href="#topic+georobPackage">georobPackage</a></code> for details on the model specification.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_locations">locations</code></td>
<td>
<p>an optional one-sided formula specifying what variables
of <code>newdata</code> are the coordinates of the points for which simulations
are computed (default<br />
<code>object[["locations.objects"]][["locations"]]</code>).</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_trend.coef">trend.coef</code></td>
<td>
<p>an optional numeric vector with the coefficients of the
trend model to be used for computing the (conditional) mean function of
the random process see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_variogram.model">variogram.model</code></td>
<td>
<p>an optional character keyword defining the
variogram model to be used for the simulations, see <code><a href="#topic+georob">georob</a></code>
and <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_param">param</code></td>
<td>
<p>an optional named numeric vector with values of the
variogram parameters used for the simulations, see <code><a href="#topic+georob">georob</a></code>
and <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_aniso">aniso</code></td>
<td>
<p>an optional named numeric vector with values of anisotropy
parameters of a variogram used for the simulations, see
<code><a href="#topic+georob">georob</a></code> and <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_variogram.object">variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model used for the simulations, see <code><a href="#topic+georob">georob</a></code> and
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_control">control</code></td>
<td>
<p>a list with the components <code>use.grid</code>,
<code>grid.refinement</code>, <code>condsim</code>,
<code>ce.method</code>, <code>ce.grid.expansion</code>,
<code>include.data.sites</code>,
<code>means</code>, <code>trend.covariates</code>,<br />  <code>covariances</code>,
<code>ncores</code>, <code>mmax</code> and <code>pcmp</code> or a function such as
<code>control.condsim</code> that generates such a list, see
arguments of <code>control.condsim</code> for details.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console.<br /> <code>verbose = 0</code> (default) suppresses
such messages.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_use.grid">use.grid</code></td>
<td>
<p>a logical scalar (default <code>FALSE</code>) to control whether
(conditional) realizations are computed for a rectangular grid instead of
the coordinates of points contained in <code>newdata</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_grid.refinement">grid.refinement</code></td>
<td>
<p>a numeric that defines a factor by which the
minimum differences of the coordinates between any pair of points in
<code>newdata</code> are divided to setup the simulation grid, should be &gt; 1
(default 2), see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_condsim">condsim</code></td>
<td>
<p>a logical scalar to control whether conditional
(<code>TRUE</code> default) or unconditional simulations (<code>FALSE</code>) are
computed.  </p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_ce.method">ce.method</code></td>
<td>
<p>a character keyword to select the method to simulate
realizations by the circulant embedding algorithm, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_ce.grid.expansion">ce.grid.expansion</code></td>
<td>
<p>a numeric with the factor by which the
dimensions of the simulation grid is expanded in the circulant embedding
algorithm. Should be <code class="reqn">\ge 1</code> (default 1).</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_include.data.sites">include.data.sites</code></td>
<td>
<p>a logical scalar, to control whether
(conditionally) simulated values are computed also for the points of the
original data set used to estimate the model parameters and contained in
<code>object</code>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_means">means</code></td>
<td>
<p>a logical scalar, to control whether
the (un)conditional means are included in the output.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_trend.covariates">trend.covariates</code></td>
<td>
<p>a logical scalar, to control whether
the covariates required for the trend model are included in the output.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_covariances">covariances</code></td>
<td>
<p>a logical scalar, to control whether the covariances
between the points of the original data set used to estimate the model
parameters (<code>attr gcvmat.d.d</code>, <br /> <code><a href="#topic+compress">compress</a></code>ed matrix) and
the covariances between the simulation and the original data points
(<code>attr gcvmat.s.d</code>, matrix) are returned as attributes of the
output.  Note that these covariances are only returned if
<code>condsim = TRUE</code>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer controlling how many cores are
used for parallelized computations, defaults to 1.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_mmax">mmax</code></td>
<td>
<p>a positive integer equal to the maximum number (default
<code>10000</code>) of prediction items, computed in sub-tasks executed in
parallel, see section <em>Details</em> of <code><a href="#topic+predict.georob">predict.georob</a></code>.</p>
</td></tr>
<tr><td><code id="georobSimulation_+3A_pcmp">pcmp</code></td>
<td>
<p>a list of arguments, passed  e.g. to <code><a href="#topic+pmm">pmm</a></code> or a
function such as <code>control.pcmp</code> that generates such a list
(see <code><a href="#topic+control.pcmp">control.pcmp</a></code> for allowed arguments).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>General</h4>

<p><code>condsim</code> (conditionally) simulates from a Gaussian process that
has a linear mean function with parameters
<code class="reqn">\boldsymbol{\beta}</code> and an auto-correlation structure
characterized by a parametric variogram model and variogram parameters
<code class="reqn">\tau^2</code> and <code class="reqn">\boldsymbol{\theta}</code> (see
<code><a href="#topic+georobPackage">georobPackage</a></code> for the employed parametrization of the
spatial linear model).  The parameters of the mean and auto-correlation
function are either taken from the spatial linear model estimated by
<code><a href="#topic+georob">georob</a></code> and passed by the argument
<code>object</code> to <code>condsim</code> or from the optional arguments
<code>trend.coef</code> (<code class="reqn">\boldsymbol{\beta}</code>)
and <code>variogram.model</code>, <code>param</code>, <code>aniso</code> or <br />
<code>variogram.object</code> (<code class="reqn">\tau^2</code>,
<code class="reqn">\boldsymbol{\theta}</code>).
</p>
<p>Simulated values are computed for the points in <code>newdata</code> and
optionally also for the data points in <code>object</code> if
<code>include.data.sites = TRUE</code>.  Both unconditional and conditional
simulations can be computed.  In the latter cases, the simulated values
are always conditioned to the response data used to fit the spatial
linear model by <code><a href="#topic+georob">georob</a></code> and contained in <code>object</code>.
</p>



<h4>Unconditional simulation</h4>

<p>Unconditional realizations are either computed for the exact locations of
the points in <code>newdata</code> (<code>use.grid = FALSE</code>), irrespective of
the fact whether these are arranged on a regular grid or not.
Simulations are then generated by the Cholesky matrix decomposition
method (e.g. <cite>Chilès and Delfiner, 1999, sec.
7.2.2</cite>).
</p>
<p>For <code>use.grid = TRUE</code> the points in <code>newdata</code> are matched to a
rectangular simulation grid and the simulations are generated for all
nodes of this grid by the circulant embedding method (<cite>Davis and
Bryant, 2013</cite>; <cite>Dietrich and Newsam, 1993</cite>; <cite>Wood and Chan,
1994</cite>).  For large problems this approach may be substantially faster and
less memory demanding than the Cholesky matrix decomposition method.
</p>
<p>For circulant embedding, first a rectangular simulation grid is
constructed from the coordinates of the points in <code>newdata</code> and
<code>object</code>.  The spacings of the simulation grid is equal to the
minimum coordinate differences between any pair of points in
<code>newdata</code>, divided by <code>grid.refinement</code>.  The spatial extent of
the simulation grid is chosen such that it covers the bounding boxes of
all points in <code>newdata</code> and <code>object</code>.  The points in
<code>newdata</code> and <code>object</code> are then matched to the closest nodes of
the simulation grid.  If the same node is assigned to a point in
<code>object</code> and <code>newdata</code> then the point in <code>object</code> is kept
and the concerned point in <code>newdata</code> is omitted.
</p>
<p>The rectangular simulation grid is then expanded to the larger circulant
embedding grid, and the eigenvalues of the so-called <em>base matrix</em>
(= first row of the covariance matrix of the nodes of the circulant
embedding grid with block circulant structure, see <cite>Davies and Bryant,
2013)</cite> are computed by fast discrete Fourier transform (FFT).  It may
happen that some of the eigenvalues of the base matrix are negative.  The
standard circulant embedding algorithm then fails.
</p>
<p>Two approaches are implemented in <code>condsim</code> to handle this
situation:
</p>

<ul>
<li><p> First, one may use the <em>approximate circulant embedding</em>
method by choosing <code>ce.method = "approximate"</code>.  This sets the
negative eigenvalues of the base matrix to zero and scales the
eigenvalues, see <cite>Chan and Wood (1994, sec.  4</cite>, choice <code class="reqn">\rho =
    \rho_2</code>).
</p>
</li>
<li><p> Second, one may attempt to avoid the problem of negative
eigenvalues by increasing the size of the simulation (and circulant
embedding) grids.  This can be achieved by choosing a value <code class="reqn">&gt; 1</code>
for the argument <code>ce.grid.expansion</code>, see respective parts in
<cite>Dietrich and Newsam (1993, sec.  4)</cite> and <cite>Wood and Chan
(1994, sec.  3)</cite>.
</p>
</li></ul>

<p>Note that the dimension of the simulation and embedding grids are chosen
such that the number of nodes is a highly composite integer.  This allows
efficient FFT.
</p>



<h4>Conditional simulation</h4>

<p>For both the Cholesky matrix decomposition and the circulant embedding
approach, simulations are conditioned to data by the Kriging method,
see <cite>Chilès and Delfiner, 1999, sec. 7.3</cite>.
</p>



<h4>Parallelized computations</h4>

<p><code>condsim</code> uses the packages <span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for
parallelized computations.  Three tasks can be executed in parallel:
</p>

<ul>
<li><p> Computation of (generalized correlations), see
<code><a href="#topic+control.pcmp">control.pcmp</a></code> how to do this.
</p>
</li>
<li><p> Computation of Kriging predictions required for conditional
simulations, see section <em>Details</em> of
<code><a href="#topic+predict.georob">predict.georob</a></code>.
</p>
</li>
<li><p> Fast Fourier transform of realizations of standard normal
deviates generated for the nodes of the base matrix (see
<cite>Davies and Bryant, 2013, steps 3&ndash;5 of algorithm)</cite>.  If there are
<code>nsim</code> realizations to simulate, the task is split into
<code>ceiling(nsim / ncores)</code> sub-tasks that are then distributed to
<code>ncores</code> CPUs.  Evidently, <code>ncores = 1</code> (default) suppresses
parallel execution.
</p>
</li></ul>




<h3>Value</h3>

<p>The output generated by <code>condsim</code> is an object of a &ldquo;similar&rdquo;
class as <code>newdata</code> (data frame,<br />
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></code>, <br />
<code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>).
</p>
<p>The data frame or the
<code>data</code> slot of the <code>Spatial...DataFrame</code> objects
have the following components:
</p>

<ul>
<li><p> the coordinates of the prediction points (only present if
<code>newdata</code> is a data frame).
</p>
</li>
<li> <p><code>expct</code>: optionally the (un)conditional means.
</p>
</li>
<li><p> optionally the covariates required for the trend model.
</p>
</li>
<li> <p><code>sim.1</code>, <code>sim.2</code>, ...: the (un)conditionally
simulated realizations.
</p>
</li></ul>

<p>The function <code>control.condsim</code> returns a list with parameters to
steer <code>condsim</code>, see arguments above.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Chilès, J.-P., Delfiner, P. (1999) <em>Geostatistics
Modeling Spatial Uncertainty</em>, Wiley, New York,
<a href="https://doi.org/10.1002/9780470316993">doi:10.1002/9780470316993</a>.
</p>
<p>Davies, T. M., Bryant, D. (2013) On circulant embedding for gaussian
random fields in R, <em>Journal of Statistical Software</em>, <b>55</b>,
1&ndash;21, <a href="https://doi.org/10.18637/jss.v055.i09">doi:10.18637/jss.v055.i09</a>.
</p>
<p>Dietrich, C. R., Newsam, G. N. (1993) A fast and exact method for
multidimensional gaussian stochastic simulations, <em>Water Resources
Research</em>, <b>9</b>, 2861&ndash;2869, <a href="https://doi.org/10.1029/93WR01070">doi:10.1029/93WR01070</a>.
</p>
<p>Wood, A. T. A., Chan, G. (1994) Simulation of stationary gaussian
processes in <code class="reqn">[0,1]^d</code>, <em>Journal of Computational and Graphcal
Statistics</em>, <b>3</b>, 409&ndash;432, <a href="https://doi.org/10.2307/1390903">doi:10.2307/1390903</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)
data(meuse.grid)

## convert to SpatialGridDataFrame
meuse.grid.sgdf &lt;- meuse.grid
coordinates(meuse.grid.sgdf) &lt;- ~ x + y
gridded(meuse.grid.sgdf) &lt;- TRUE
fullgrid(meuse.grid.sgdf) &lt;- TRUE

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse,
    locations = ~ x + y, variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)

## Unconditional simulations using circulant embedding on rectangular
## simulation grid
r.sim.1 &lt;- condsim(r.logzn.reml, newdata = meuse.grid.sgdf, nsim = 2, seed = 1,
    control = control.condsim(use.grid = TRUE, condsim = FALSE))
spplot(r.sim.1, zcol = "sim.1", at = seq(3.5, 8.5, by = 0.5))

## Conditional simulations using circulant embedding
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.sim.2 &lt;- condsim(r.logzn.reml, newdata = meuse.grid.sgdf, nsim = 2, seed = 1,
      control = control.condsim(use.grid = FALSE, condsim = TRUE))
  spplot(r.sim.2, zcol = "sim.2", at = seq(3.5, 8.5, by = 0.5))
}
</code></pre>

<hr>
<h2 id='internal.functions'>Internal Functions of Package <span class="pkg">georob</span></h2><span id='topic+check.newdata'></span><span id='topic+covariances.fixed.random.effects'></span><span id='topic+crpsnorm'></span><span id='topic+estimate.zhat'></span><span id='topic+estimating.equations.theta'></span><span id='topic+estimating.equations.z'></span><span id='topic+f.aux.Qstar'></span><span id='topic+f.aux.RSS'></span><span id='topic+f.aux.Valphaxi'></span><span id='topic+f.aux.add1.drop1'></span><span id='topic+f.aux.crpsnorm'></span><span id='topic+f.aux.eeq'></span><span id='topic+f.aux.gcr'></span><span id='topic+f.aux.gradient.nll'></span><span id='topic+f.aux.gradient.npll'></span><span id='topic+f.aux.print.gradient'></span><span id='topic+f.aux.tf.param.fwd'></span><span id='topic+f.call.set_allfitxxx_to_false'></span><span id='topic+f.call.set_allxxx_to_fitted_values'></span><span id='topic+f.call.set_onefitxxx_to_value'></span><span id='topic+f.call.set_onexxx_to_value'></span><span id='topic+f.call.set_x_to_value'></span><span id='topic+f.call.set_x_to_value_in_fun'></span><span id='topic+f.diag'></span><span id='topic+f.psi.function'></span><span id='topic+f.reparam.bkw'></span><span id='topic+f.reparam.fwd'></span><span id='topic+f.robust.uk'></span><span id='topic+f.stop.cluster'></span><span id='topic+georob.fit'></span><span id='topic+getCall.georob'></span><span id='topic+gradient.negative.loglikelihood'></span><span id='topic+likelihood.calculations'></span><span id='topic+negative.log-likelihood'></span><span id='topic+partial.derivatives.variogram'></span><span id='topic+safe_pchisq'></span><span id='topic+sim.chol.decomp'></span><span id='topic+sim.circulant.embedding'></span><span id='topic+simple.kriging.weights'></span><span id='topic+update.zhat'></span>

<h3>Description</h3>

<p>The unexported internal functions
</p>

<ul>
<li><p><code>check.newdata</code>
</p>
</li>
<li><p><code>covariances.fixed.random.effects</code>
</p>
</li>
<li><p><code>crpsnorm</code>

</p>
</li>
<li><p><code>estimate.zhat</code>
</p>
</li>
<li><p><code>estimating.equations.theta</code>
</p>
</li>
<li><p><code>estimating.equations.z</code>
</p>
</li>
<li><p><code>f.aux.Qstar</code>
</p>
</li>
<li><p><code>f.aux.RSS</code>
</p>
</li>
<li><p><code>f.aux.Valphaxi</code>
</p>
</li>
<li><p><code>f.aux.add1.drop1</code>
</p>
</li>
<li><p><code>f.aux.crpsnorm</code>
</p>
</li>
<li><p><code>f.aux.eeq</code>
</p>
</li>
<li><p><code>f.aux.gcr</code>
</p>
</li>
<li><p><code>f.aux.gradient.nll</code>
</p>
</li>
<li><p><code>f.aux.gradient.npll</code>
</p>
</li>
<li><p><code>f.aux.print.gradient</code>
</p>
</li>
<li><p><code>f.aux.tf.param.fwd</code>
</p>
</li>
<li><p><code>f.call.set_allfitxxx_to_false</code>
</p>
</li>
<li><p><code>f.call.set_allxxx_to_fitted_values</code>
</p>
</li>
<li><p><code>f.call.set_onefitxxx_to_value</code>
</p>
</li>
<li><p><code>f.call.set_onexxx_to_value</code>
</p>
</li>
<li><p><code>f.call.set_x_to_value</code>
</p>
</li>
<li><p><code>f.call.set_x_to_value_in_fun</code>
</p>
</li>
<li><p><code>f.diag</code>
</p>
</li>
<li><p><code>f.psi.function</code>
</p>
</li>
<li><p><code>f.reparam.bkw</code>
</p>
</li>
<li><p><code>f.reparam.fwd</code>
</p>
</li>
<li><p><code>f.robust.uk</code>
</p>
</li>
<li><p><code>f.stop.cluster</code>
</p>
</li>
<li><p><code>georob.fit</code>
</p>
</li>
<li><p><code>getCall.georob</code>
</p>
</li>
<li><p><code>gradient.negative.loglikelihood</code>
</p>
</li>
<li><p><code>likelihood.calculations</code>
</p>
</li>
<li><p><code>negative.log-likelihood</code>
</p>
</li>
<li><p><code>partial.derivatives.variogram</code>


</p>
</li>
<li><p><code>safe_pchisq</code>
</p>
</li>
<li><p><code>sim.chol.decomp</code>
</p>
</li>
<li><p><code>sim.circulant.embedding</code>
</p>
</li>
<li><p><code>simple.kriging.weights</code>

</p>
</li>
<li><p><code>update.zhat</code>
</p>
</li></ul>

<p>are not intended for direct use.  However, as any unexported function, they
can be accessed by typing <code>georob:::<var>function-name</var></code>.
</p>


<h3>Value</h3>

<p>No information because functions are not meant to called by users.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a><br />
with contributions by Cornelia Schwierz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of (RE)ML variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data; and finally
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>,
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>

<hr>
<h2 id='lgnpp'>Unbiased Back-Transformations for Log-normal Kriging</h2><span id='topic+lgnpp'></span>

<h3>Description</h3>

<p>The function <code>lgnpp</code> back-transforms point or block Kriging
predictions of a log-transformed response variable computed by
<code><a href="#topic+predict.georob">predict.georob</a></code>.  Alternatively, the function averages
log-normal point Kriging predictions for a block and approximates the mean
squared prediction error of the block mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgnpp(object, newdata, locations, is.block = FALSE, all.pred = NULL,
    extended.output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgnpp_+3A_object">object</code></td>
<td>
<p>an object with Kriging predictions of a log-transformed
response variable as obtained by
<code><a href="stats.html#topic+predict">predict</a>(<var>georob-object, ...</var>)</code>.</p>
</td></tr>
<tr><td><code id="lgnpp_+3A_newdata">newdata</code></td>
<td>
<p>an optional object as passed as argument <code>newdata</code> to
<code><a href="#topic+predict.georob">predict.georob</a></code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="lgnpp_+3A_locations">locations</code></td>
<td>
<p>an optional one-sided formula specifying what variables
of <code>newdata</code> are the coordinates of the prediction points, see
<code><a href="#topic+predict.georob">predict.georob</a></code>.</p>
</td></tr>
<tr><td><code id="lgnpp_+3A_is.block">is.block</code></td>
<td>
<p>an optional logical scalar (default <code>FALSE</code>) specifying
whether point predictions contained in <code>object</code> are considered to
belong to a single block and should be averaged after
back-transformation.  Ignored if <code>object</code> contains block Kriging
predictions, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="lgnpp_+3A_all.pred">all.pred</code></td>
<td>
<p>an optional positive integer or an object as obtained by
<code>lgnpp(predict(<var>georob-object, ...</var>))</code>, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="lgnpp_+3A_extended.output">extended.output</code></td>
<td>
<p>a logical scalar controlling whether the
covariance matrix of the errors of the back-transformed point predictions
is added as an attribute to the result, see <em>Details</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>lgnpp</code> performs three tasks:
</p>


<h4>1. Back-transformation of point Kriging predictions of a
log-transformed response</h4>

<p>The usual, marginally unbiased back-transformation for log-normal point
Kriging is used:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{U}(\boldsymbol{s}) = \exp( \widehat{Z}(\boldsymbol{s}) +
      1/2 (  \mathrm{Var}_{\hat{\theta}}[ Z(\boldsymbol{s})]
      - \mathrm{Var}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s})])),</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{Cov}_{\hat{\theta}}[
      U(\boldsymbol{s}_i) - \widehat{U}(\boldsymbol{s}_i),
      U(\boldsymbol{s}_j) - \widehat{U}(\boldsymbol{s}_j)
      ] = \mu_{\hat{\theta}}(\boldsymbol{s}_i) \mu_{\hat{\theta}}(\boldsymbol{s}_j)
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      \times \{
        \exp(\mathrm{Cov}_{\hat{\theta}}[Z(\boldsymbol{s}_i),Z(\boldsymbol{s}_j)])
        -2\exp(\mathrm{Cov}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s}_i),Z(\boldsymbol{s}_j)])
        +\exp(\mathrm{Cov}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s}_i),\widehat{Z}(\boldsymbol{s}_j)])
      \},
    </code>
</p>

<p>where <code class="reqn">\widehat{Z}</code> and <code class="reqn">\widehat{U}</code> denote the
log- and back-transformed predictions of the signal,
and
</p>
<p style="text-align: center;"><code class="reqn">\mu_{\hat{\theta}}(\boldsymbol{s}) \approx
      \exp(\boldsymbol{x}(\boldsymbol{s})\mathrm{^T}\widehat{\boldsymbol{\beta}}
      + 1/2 \mathrm{Var}_{\hat{\theta}}[Z(\boldsymbol{s})]).
    </code>
</p>

<p>The expressions for the required covariance terms can be found in the
Appendices of <cite>Nussbaum et al.  (2014)</cite>.  Instead of the signal
<code class="reqn">Z(\boldsymbol{s})</code>, predictions of the
log-transformed response <code class="reqn">Y(\boldsymbol{s})</code>
or the estimated trend
<code class="reqn">\boldsymbol{x}(\boldsymbol{s})^\mathrm{T}\widehat{\boldsymbol{\beta}}</code> of the log-transformed data can be back-transformed (see
<code><a href="#topic+georobPackage">georobPackage</a></code>).  The
above transformations are used if <code>object</code>
contains point Kriging predictions (see <code>predict.georob</code>,
<em>Value</em>) and if <code>is.block = FALSE</code> and <code>all.pred</code> is
missing.
</p>



<h4>2. Back-transformation of block Kriging predictions of a
log-transformed response</h4>

<p>Block Kriging predictions of a log-transformed response variable are
back-transformed by the approximately unbiased transformation proposed
by <cite>Cressie (2006, Appendix C)</cite>
</p>
<p style="text-align: center;"><code class="reqn">\widehat{U}(A) = \exp( \widehat{Z}(A) + 1/2 \{
    \mathrm{Var}_{\hat{\theta}}[Z(\boldsymbol{s})] + \widehat{\boldsymbol{\beta}}\mathrm{^T}
    \boldsymbol{M}(A) \widehat{\boldsymbol{\beta}} -
    \mathrm{Var}_{\hat{\theta}}[\widehat{Z}(A)]
    \}),
  </code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{E}_{\hat{\theta}}[\{U(A) - \widehat{U}(A))^2] = \mu_{\hat{\theta}}(A)^2 \{
    \exp(\mathrm{Var}_{\hat{\theta}}[Z(A)]) - 2 \exp(\mathrm{Cov}_{\hat{\theta}}[\widehat{Z}(A),Z(A)]) + \exp(\mathrm{Var}_{\hat{\theta}}[\widehat{Z}(A)])
    \}
  </code>
</p>

<p>where <code class="reqn">\widehat{Z}(A)</code> and <code class="reqn">\widehat{U}(A)</code> are the log- and
back-transformed predictions of the block mean <code class="reqn">U(A)</code>, respectively,
<code class="reqn">\boldsymbol{M}(A)</code> is the spatial
covariance matrix of the covariates
</p>
<p style="text-align: center;"><code class="reqn"> \boldsymbol{M}(A) = 1/|A| \int_A
  ( \boldsymbol{x}(\boldsymbol{s}) - \boldsymbol{x}(A) )
  ( \boldsymbol{x}(\boldsymbol{s}) - \boldsymbol{x}(A) )\mathrm{^T} \,d\boldsymbol{s}
  </code>
</p>

<p>within the block <code class="reqn">A</code> where
</p>
<p style="text-align: center;"><code class="reqn"> \boldsymbol{x}(A) = 1/|A| \int_A \boldsymbol{x}(\boldsymbol{s}) \,d\boldsymbol{s}
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn"> \mu_{\hat{\theta}}(A) \approx \exp(\boldsymbol{x}(A)\mathrm{^T}
    \widehat{\boldsymbol{\beta}} + 1/2 \mathrm{Var}_{\hat{\theta}}[Z(A)]).
  </code>
</p>

<p>This back-transformation is based on the assumption that both the point data
<code class="reqn">U(\boldsymbol{s})</code> and the block means
<code class="reqn">U(A)</code> follow  log-normal laws, which strictly cannot hold.  But
for small blocks the assumption works well as the bias and the loss of
efficiency caused by this assumption are small (<cite>Cressie, 2006</cite>;
<cite>Hofer et al., 2013</cite>).
</p>
<p>The above formulae are used by <code>lgnpp</code> if <code>object</code> contains
block Kriging predictions in the form of a
<code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>.  To approximate
<code class="reqn">\boldsymbol{M}(A)</code>, one needs the covariates
on a fine grid for the whole study domain in which the blocks lie.  The
covariates are passed <code>lgnpp</code> as argument <code>newdata</code>, where
<code>newdata</code> can be any spatial data frame accepted by
<code>predict.georob</code>.  For evaluating
<code class="reqn">\boldsymbol{M}(A)</code> the geometry of the blocks
is taken from the <code>polygons</code> slot of the<br />
<code>SpatialPolygonsDataFrame</code> passed as <code>object</code> to <code>lgnpp</code>.
</p>



<h4>3. Back-transformation and averaging of point Kriging predictions
of a log-transformed response</h4>

<p><code>lgnpp</code> allows as a further option to back-transform and
<em>average</em> point Kriging predictions passed as <code>object</code> to the
function.  One then assumes that the predictions in <code>object</code> refer
to points that lie in <em>a single</em> block.  Hence, one uses the
approximation
</p>
<p style="text-align: center;"><code class="reqn">\widehat{U}(A) \approx \frac{1}{K} \sum_{s_i \in A} \widehat{U}(\boldsymbol{s}_i)
  </code>
</p>

<p>to predict the block mean <code class="reqn">U(A)</code>, where <code class="reqn">K</code> is the number of
points in <code class="reqn">A</code>. The mean squared prediction error can be approximated by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{E}_{\hat{\theta}}[\{U(A) - \widehat{U}(A)\}^2] \approx \frac{1}{K^2}
    \sum_{s_i \in A} \sum_{s_j \in A}
    \mathrm{Cov}_{\hat{\theta}}[
    U(\boldsymbol{s}_i) - \widehat{U}(\boldsymbol{s}_i),
    U(\boldsymbol{s}_j) - \widehat{U}(\boldsymbol{s}_j)
    ].
    </code>
</p>

<p>In most instances, the evaluation of the above double sum is not feasible
because a large number of points is used to discretize the block <code class="reqn">A</code>.
<code>lgnpp</code> then uses the following approximations to compute the mean
squared error (see also Appendix E of <cite>Nussbaum et al., 2014</cite>):
</p>

<ul>
<li><p> Point prediction results are passed as <code>object</code> to <code>lgnpp</code>
only for a <em>random sample of points in <code class="reqn">A</code></em> (of size <code class="reqn">k</code>),
for which the evaluation of the above double sum is feasible.
</p>
</li>
<li><p> The prediction results for the <em>complete set of points</em>
within the block are passed as argument <code>all.pred</code> to
<code>lgnpp</code>.  These results are used to compute <code class="reqn">\widehat{U}(A)</code>.
</p>
</li>
<li><p> The mean squared error is then approximated by
</p>
<p style="text-align: center;"><code class="reqn">
      \mathrm{E}_{\hat{\theta}}[\{U(A) - \widehat{U}(A)\}^2] \approx
      \frac{1}{K^2} \sum_{s_i \in A} \mathrm{E}_{\hat{\theta}}[ \{ U(\boldsymbol{s}_i) - \widehat{U}(\boldsymbol{s}_i)\}^2]
    </code>
</p>

<p style="text-align: center;"><code class="reqn">+ \frac{K-1}{K k (k-1)} \sum_{s_i \in \mathrm{sample}}\sum_{s_j \in \mathrm{sample}, s_j \neq s_i}
    \mathrm{Cov}_{\hat{\theta}}[
    U(\boldsymbol{s}_i) - \widehat{U}(\boldsymbol{s}_i),
    U(\boldsymbol{s}_j) - \widehat{U}(\boldsymbol{s}_j)
    ].
    </code>
</p>

<p>The first term of the RHS (and <code class="reqn">\widehat{U}(A)</code>) can be
computed from the point Kriging results contained in <code>all.pred</code>,
and the double sum is evaluated from the full covariance matrices of
the predictions and the respective targets, passed to <code>lgnpp</code> as
<code>object</code> (one has to use the arguments
<code>control=control.predict.georob(full.covmat=TRUE)</code> for
<code><a href="#topic+predict.georob">predict.georob</a></code> when computing the point Kriging
predictions stored in <code>object</code>).
</p>
</li>
<li><p> If the prediction results are not available for the complete set
of points in <code class="reqn">A</code> then <code>all.pred</code> may be equal to <code class="reqn">K</code>.  The
block mean is then approximated by
</p>
<p style="text-align: center;"><code class="reqn">\widehat{U}(A) \approx \frac{1}{k} \sum_{s_i \in \mathrm{sample}}
    \widehat{U}(\boldsymbol{s}_i) </code>
</p>

<p>and the first term of the RHS of the expression for the mean squared
error by
</p>
<p style="text-align: center;"><code class="reqn"> \frac{1}{kK} \sum_{s_i \in \mathrm{sample}} \mathrm{E}_{\hat{\theta}}[ \{
      U(\boldsymbol{s}_i) -
      \widehat{U}(\boldsymbol{s}_i)\}^2].
    </code>
</p>

</li>
<li><p> By drawing samples repeatedly and passing the related Kriging
results as <code>object</code> to <code>lgnpp</code>, one can reduce the error of
the approximation of the mean squared error.
</p>
</li></ul>




<h3>Value</h3>

<p>If <code>is.block</code> is <code>FALSE</code> and <code>all.pred</code> is equal to
<code>NULL</code> <code>lgnpp</code> returns an updated object of the same class as
<code>object</code> (see section <em>Value</em> of <code><a href="#topic+predict.georob">predict.georob</a></code>).
The data frame with the point or block Kriging predictions is
complemented by <code>lgnpp</code> with the following new components:
</p>

<ul>
<li> <p><code>lgn.pred</code>: the back-transformed Kriging predictions of a
log-transformed response.
</p>
</li>
<li> <p><code>lgn.se</code>: the standard  errors of the
back-transformed predictions.
</p>
</li>
<li> <p><code>lgn.lower</code>, <code>lgn.upper</code>: the bounds of the
back-transformed prediction intervals.
</p>
</li></ul>

<p>If <code>is.block</code> is <code>TRUE</code> or <code>all.pred</code> not equal to
<code>NULL</code> <code>lgnpp</code> returns a named numeric vector with two
elements:
</p>

<ul>
<li> <p><code>mean</code>: the back-transformed block Kriging estimate, see
<em>Details</em>.
</p>
</li>
<li> <p><code>se</code>: the (approximated) block Kriging standard error, see
<em>Details</em>.
</p>
</li></ul>

<p>If <code>extended.output</code> is <code>TRUE</code> then the vector is supplemented
with the attribute <code>mse.lgn.pred</code> that contains the full covariance
matrix of the back-transformed point prediction errors.</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Cressie, N. (2006) Block Kriging for Lognormal Spatial Processes.
<em>Mathematical Geology</em>, <b>38</b>, 413&ndash;443,
<a href="https://doi.org/10.1007/s11004-005-9022-8">doi:10.1007/s11004-005-9022-8</a>.
</p>
<p>Hofer, C., Borer, F., Bono, R., Kayser, A. and Papritz, A. 2013.
Predicting topsoil heavy metal content of parcels of land: An empirical
validation of customary and constrained lognormal block Kriging and
conditional simulations.  <em>Geoderma</em>, <b>193&ndash;194</b>, 200&ndash;212,
<a href="https://doi.org/10.1016/j.geoderma.2012.08.034">doi:10.1016/j.geoderma.2012.08.034</a>.
</p>
<p>Nussbaum, M., Papritz, A., Baltensweiler, A. and Walthert, L. (2014)
Estimating soil organic carbon stocks of Swiss forest soils by robust
external-drift kriging.  <em>Geoscientific Model Development</em>,
<b>7</b>, 1197&ndash;1210.  <a href="https://doi.org/10.5194/gmd-7-1197-2014">doi:10.5194/gmd-7-1197-2014</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
meuse.grid.pixdf &lt;- meuse.grid
gridded(meuse.grid.pixdf) &lt;- TRUE

data(meuse.blocks, package = "constrainedKriging")

r.logzn.rob &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp", param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1., control = control.georob(cov.bhat = TRUE, full.cov.bhat = TRUE))

## point predictions of log(Zn)
r.pred.points.1 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
    control = control.predict.georob(extended.output = TRUE))
str(r.pred.points.1, max = 3)

## back-transformation of point predictions
r.backtf.pred.points &lt;- lgnpp(r.pred.points.1)
str(r.backtf.pred.points, max = 3)

spplot(r.backtf.pred.points, zcol = "lgn.pred", main = "Zn content")

## predicting mean Zn content for whole area
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  ## recompute point predictions with argument full.covmat = TRUE
  r.pred.points.2 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
      control = control.predict.georob(extended.output = TRUE, full.covmat = TRUE))
  str(r.pred.points.2, max = 3)
  r.block &lt;- lgnpp(r.pred.points.2, is.block = TRUE, all.pred = r.backtf.pred.points@data)
  r.block
}

## block predictions of log(Zn)
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.pred.block &lt;- predict(r.logzn.rob, newdata = meuse.blocks,
      control = control.predict.georob(extended.output = TRUE,
          pwidth = 75, pheight = 75, mmax = 50))
  r.backtf.pred.block &lt;- lgnpp(r.pred.block, newdata = meuse.grid)

  spplot(r.backtf.pred.block, zcol = "lgn.pred", main = "block means Zn content")
}
</code></pre>

<hr>
<h2 id='param.names'>Names and Permissible Ranges of Variogram Parameters</h2><span id='topic+param.names'></span><span id='topic+param.bounds'></span>

<h3>Description</h3>

<p>Auxiliary functions to query names and permissible ranges of variogram
parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>param.names(model)

param.bounds(model, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="param.names_+3A_model">model</code></td>
<td>
<p>a character keyword denoting a valid variogram,
see <code><a href="#topic+georob">georob</a></code> and <code><a href="#topic+georobPackage">georobPackage</a></code>.</p>
</td></tr>
<tr><td><code id="param.names_+3A_d">d</code></td>
<td>
<p>a positive integer with the number of dimensions of the survey
domain.</p>
</td></tr> </table>


<h3>Value</h3>

<p>Either a character vector with the names of the additional variogram
parameters such as the smoothness parameter of the
Whittle-Matérn model (<code>param.names</code>) or a named list
with the lower and upper bounds of permissible parameter ranges.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param.names("RMgengneiting")
param.bounds("RMgengneiting", d = 2)
</code></pre>

<hr>
<h2 id='plot.georob'>Plot Methods for Class <code>georob</code></h2><span id='topic+plot.georob'></span><span id='topic+lines.georob'></span>

<h3>Description</h3>

<p>The <code>plot</code> and <code>lines</code> methods for class
<code>georob</code> plot the variogram model, estimated by (robust) restricted
maximum likelihood.
<code>plot.georob</code> computes and plots in addition the
sample variogram of the (robust) regression residuals and can be used to
generate residual diagnostics plots (Tukey-Anscombe plot, normal QQ plots
of residuals and random effects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'georob'
plot(x, what = c( "variogram", "covariance", "correlation",
    "ta", "sl", "qq.res", "qq.ranef" ), add = FALSE, lag.dist.def,
    xy.angle.def = c(0, 180), xz.angle.def = c(0, 180), max.lag = Inf,
    estimator = c("mad", "qn", "ch", "matheron"), mean.angle = TRUE,
    level = what != "ta", smooth = what == "ta" || what == "sl",
    id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75,
    label.pos = c(4,2), col, pch, xlab, ylab, main, lty = "solid", ...)

## S3 method for class 'georob'
lines(x, what = c("variogram", "covariance", "correlation"),
    from = 1.e-6, to, n = 501, xy.angle = 90, xz.angle = 90,
    col = 1:length(xy.angle), pch = 1:length(xz.angle), lty = "solid", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.georob_+3A_x">x</code></td>
<td>
<p>an object of class <code>georob</code>, see <code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_what">what</code></td>
<td>
<p>a character keyword for the quantity that should be displayed.
Possible values are:
</p>

<ul>
<li> <p><code>"variogram"</code>: the variogram
</p>
</li>
<li> <p><code>"covariance"</code>: the covariance function
</p>
</li>
<li> <p><code>"correlation"</code>: the correlation function
</p>
</li>
<li> <p><code>"scale-location"</code>: square root of absolute regression
residuals plotted against fitted values (Scale-Location plot)
</p>
</li>
<li> <p><code>"ta"</code>: regression residuals plotted against fitted values
(Tukey-Anscombe plot)
</p>
</li>
<li> <p><code>"qq.res"</code>: normal Q-Q plot of standardized errors
<code class="reqn">\hat{\varepsilon}</code>
</p>
</li>
<li> <p><code>"qq.ranef"</code>: normal Q-Q plot of standardized random
effects <code class="reqn">\hat{B}</code>
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot.georob_+3A_add">add</code></td>
<td>
<p>a logical scalar controlling whether a new plot should be
generated (<code>FALSE</code>, default) or whether the information should be
added to the current plot (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_lag.dist.def">lag.dist.def</code></td>
<td>
<p>an optional numeric scalar defining a constant bin
width for grouping the lag distances or an optional numeric vector with
the upper bounds of a set of contiguous bins for computing the sample
variogram of the regression residuals, see
<code><a href="#topic+sample.variogram">sample.variogram</a></code>.  If missing then the sample variogram is
not computed.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_xy.angle.def">xy.angle.def</code></td>
<td>
<p>an numeric vector defining angular classes in the
horizontal plane for computing directional variograms.
<code>xy.angle.def</code> must contain an ascending sequence of azimuth angles
in degrees from north (positive clockwise to south), see
<code><a href="#topic+sample.variogram">sample.variogram</a></code>.  Omnidirectional variograms are computed
with the default <code>c(0,180)</code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_xz.angle.def">xz.angle.def</code></td>
<td>
<p>an numeric vector defining angular classes in the
<code class="reqn">x</code>-<code class="reqn">z</code>-plane for computing directional variograms.
<code>xz.angle.def</code> must contain an ascending sequence of angles in
degrees from zenith (positive clockwise to nadir), see
<code><a href="#topic+sample.variogram">sample.variogram</a></code>.  Omnidirectional variograms are computed
with the default <code>c(0,180)</code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_max.lag">max.lag</code></td>
<td>
<p>a positive numeric defining the largest lag distance for
which semi-variances should be computed (default no restriction).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_estimator">estimator</code></td>
<td>
<p>a character keyword defining the estimator for computing
the sample variogram.  Possible values are:
</p>

<ul>
<li> <p><code>"qn"</code>: Genton's robust
<code><a href="robustbase.html#topic+Qn">Qn</a></code>-estimator (default, <cite>Genton, 1998</cite>),
</p>
</li>
<li> <p><code>"mad"</code>: Dowd's robust MAD-estimator (<cite>Dowd, 1984</cite>),
</p>
</li>
<li> <p><code>"matheron"</code>: non-robust method-of-moments estimator,
</p>
</li>
<li> <p><code>"ch"</code>: robust Cressie-Hawkins estimator (<cite>Cressie and
Hawkins, 1980</cite>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot.georob_+3A_mean.angle">mean.angle</code></td>
<td>
<p>a logical scalar controlling whether the mean lag
vector (per combination of lag distance and angular class) is computed
from the mean angles of all the lag vectors falling into a given class
(<code>TRUE</code>, default) or from the mid-angles of the respective angular
classes (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_level">level</code></td>
<td>
<p>an integer giving the level for extracting the residuals
from <code>object</code> for <code>what = "ta"</code> or <code>what = "qq.res"</code>.
<code>level = 0</code> (default for <code>what == "ta"</code>) extracts the
regression residuals <code class="reqn">\widehat{B}(\boldsymbol{s}) +
  \widehat{\varepsilon}(\boldsymbol{s})</code> and <code>level = 1</code> (default for <code>what ==
  "qq.res"</code>) only the estimated errors
<code class="reqn">\widehat{\varepsilon}(\boldsymbol{s})</code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_smooth">smooth</code></td>
<td>
<p>a logical scalar controlling whether a
<code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code> is added to the Tukey-Anscombe plot
(default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_id.n">id.n</code></td>
<td>
<p>a numeric with the number of points to be labelled in each
plot, starting with the most extreme (see
<code><a href="robustbase.html#topic+plot.lmrob">plot.lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_labels.id">labels.id</code></td>
<td>
<p>a vector of labels, from which the labels for extreme
points will be chosen (see <code><a href="robustbase.html#topic+plot.lmrob">plot.lmrob</a></code>).
<code>NULL</code> uses observation numbers.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_cex.id">cex.id</code></td>
<td>
<p>a numeric with the magnification of point labels (see
<code><a href="robustbase.html#topic+plot.lmrob">plot.lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_label.pos">label.pos</code></td>
<td>
<p>a numeric for positioning of labels, for the left half
and right half of the graph respectively (see
<code><a href="robustbase.html#topic+plot.lmrob">plot.lmrob</a></code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_from">from</code></td>
<td>
<p>a numeric with the minimal lag distance for plotting
variogram models.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_to">to</code></td>
<td>
<p>a numeric with the maximum lag distance for plotting variogram
models (default: largest lag distance of current plot).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_n">n</code></td>
<td>
<p>a positive integer specifying the number of equally spaced lag
distances for which semi-variances are evaluated in plotting variogram
models (default <code>501</code>).</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_xy.angle">xy.angle</code></td>
<td>
<p>a numeric (vector) with azimuth angles (in degrees,
clockwise positive from north) in <code class="reqn">x</code>-<code class="reqn">y</code>-plane for which
semi-variances should be plotted.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_xz.angle">xz.angle</code></td>
<td>
<p>a numeric (vector) with angles in <code class="reqn">x</code>-<code class="reqn">z</code>-plane (in
degrees, clockwise positive from zenith to south) for which semi-variances
should be plotted.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_col">col</code></td>
<td>
<p>an optional vector with colours of points and curves to
distinguish items relating to different azimuth angles in
<code class="reqn">x</code>-<code class="reqn">y</code>-plane.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_pch">pch</code></td>
<td>
<p>an optional vector with symbols for points and curves to
distinguish items relating to different azimuth angles in
<code class="reqn">x</code>-<code class="reqn">z</code>-plane.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_lty">lty</code></td>
<td>
<p>line type for plotting variogram models.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_xlab">xlab</code>, <code id="plot.georob_+3A_ylab">ylab</code>, <code id="plot.georob_+3A_main">main</code></td>
<td>
<p>plot annotation, see
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.georob_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="#topic+plot.sample.variogram">plot.sample.variogram</a></code>, <code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code>
and graphical methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The method <code>plot.georob</code> returns no value, it is called for its side
effects.
</p>
<p>The method <code>lines.georob</code> is called for its side effects and returns
the value <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################
## meuse data ##
################
data(meuse)

## Gaussian REML fit
r.logzn.reml &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp",
    param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1000)
summary(r.logzn.reml, correlation = TRUE)
plot(r.logzn.reml, lag.dist.def = seq(0, 2000, by = 100))

## robust REML fit
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.logzn.rob &lt;- update(r.logzn.reml, tuning.psi = 1)

  summary(r.logzn.rob, correlation = TRUE)
  lines(r.logzn.rob, col = "red")
}
</code></pre>

<hr>
<h2 id='pmm'>Parallelized Matrix Multiplication</h2><span id='topic+pmm'></span><span id='topic+control.pcmp'></span>

<h3>Description</h3>

<p>This page documents the function <code>pmm</code> for parallelized matrix
multiplication and the function<br /> <code>control.pcmp</code>, which controls
the behaviour of <code>pmm</code> and other functions that execute tasks in
parallel.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmm(A, B, control = control.pcmp())

control.pcmp(pmm.ncores = 1, gcr.ncores = 1, max.ncores = parallel::detectCores(),
    f = 1, sfstop = FALSE, allow.recursive = FALSE,
    fork = !identical(.Platform[["OS.type"]], "windows"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmm_+3A_a">A</code>, <code id="pmm_+3A_b">B</code></td>
<td>
<p>two numeric matrices to be multiplied.</p>
</td></tr>
<tr><td><code id="pmm_+3A_control">control</code></td>
<td>
<p>a list with the arguments <code>pmm.ncores</code>,
<code>gcr.ncores</code>, <code>max.ncores</code>, <code>f</code>, <code>sfstop</code> and
<code>allow.recursive</code> or a function such as <code>control.pcmp</code> that
generates such a list.</p>
</td></tr>
<tr><td><code id="pmm_+3A_pmm.ncores">pmm.ncores</code></td>
<td>
<p>an integer (default 1) with the number of cores used
for parallelized matrix multiplication.</p>
</td></tr>
<tr><td><code id="pmm_+3A_gcr.ncores">gcr.ncores</code></td>
<td>
<p>an integer (default 1) with the number of cores used
for parallelized computation of (generalized) covariances or
semi-variances.</p>
</td></tr>
<tr><td><code id="pmm_+3A_max.ncores">max.ncores</code></td>
<td>
<p>maximum number of cores (integer, default all cores of
a machine) used for parallelized computations.</p>
</td></tr>
<tr><td><code id="pmm_+3A_f">f</code></td>
<td>
<p>an integer (default 1) with the number of tasks assigned to each
core in parallelized operations.</p>
</td></tr>
<tr><td><code id="pmm_+3A_sfstop">sfstop</code></td>
<td>
<p>a logical scalar controlling whether the SNOW socket
cluster is stopped after each parallelized matrix multiplication on
windows OS (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pmm_+3A_allow.recursive">allow.recursive</code></td>
<td>
<p>a logical scalar controlling whether parallelized
matrix multiplicaction and computation of generalized) covariances should
be allowed by child processes running already in parallel (default
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pmm_+3A_fork">fork</code></td>
<td>
<p>a logical scalar controlling whether forking should be used for
parallel computations (default <code>TRUE</code> on unix and <code>FALSE</code> on
windows operating systems).  Note that settting <code>fork = TRUE</code> on
windows suppresses parallel computations.</p>
</td></tr>
<tr><td><code id="pmm_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallelized matrix multiplication shortens computing time for large data
sets (<code class="reqn">n&gt;1000</code>).  However, spawning child processes requires itself
resources and increasing the number of cores for parallelized matrix
multiplication and parallelized computation of covariances does not always
result in reduced computing time.  Furthermore, these operations may be
initiated by child processes, that were itself spawned by functions like
<code><a href="#topic+cv.georob">cv.georob</a></code>, <code><a href="#topic+predict.georob">predict.georob</a></code>,
<code><a href="#topic+profilelogLik">profilelogLik</a></code>, <code><a href="#topic+add1.georob">add1.georob</a></code>,
<code><a href="#topic+drop1.georob">drop1.georob</a></code> and <code><a href="#topic+step.georob">step.georob</a></code>.  By default,
parallelized matrix multiplication and computation of covariances is then
suppressed to avoid that child processes itself spawn child processes.  To
allow parallelized matrix multipliation and parallelized computation of
covariances by child processes one has to use the argument
<code>allow.recursive = TRUE</code>.
</p>
<p>Note that very substantial reductions in computing time results when one
uses the <strong>OpenBLAS</strong> library instead of the reference BLAS library
that ships with R, see
<a href="https://www.openblas.net/">https://www.openblas.net/</a> and R FAQ for your OS. With OpenBLAS no
gains are obtained by using more than one core for matrix
multiplication, and one should therefore use the default arguments
<code>pmm.ncores = 1</code> for <code>control.pcmp()</code>.
</p>
<p><code>max.ncores</code> controls how many child processes are spawned in total.
This can be used to prevent that child processes spawn
themselves children which may result in a considerable number of child
processes.
</p>


<h3>Value</h3>


<dl>
<dt><code>pmm</code>:</dt><dd><p>the matrix product <code>A %*% B</code>,</p>
</dd>
<dt><code>control.pcmp</code>:</dt><dd><p>a list with components
<code>pmm.ncores</code>, <code>gcr.ncores</code>, <code>max.ncores</code>, <code>f</code>,
<code>sfstop</code>,<br /> <code>allow.recursive</code>.</p>
</dd> </dl>
 

<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  A &lt;- as.matrix(dist(rnorm(2000)))
  B &lt;- as.matrix(dist(rnorm(2000)))
  system.time(C &lt;- A %*% B)
  system.time(C &lt;- pmm(
      A, B, control = control.pcmp(pmm.ncores = 2L)))
}
</code></pre>

<hr>
<h2 id='predict.georob'>Predict Method for Robustly Fitted Spatial Linear Models</h2><span id='topic+predict.georob'></span><span id='topic+control.predict.georob'></span>

<h3>Description</h3>

<p>Robust and customary external drift Kriging prediction
based on a spatial linear models fitted by <code>georob</code>. The
<code>predict</code> method for the class <code>georob</code> computes fitted values, point
and block Kriging predictions as
well as model terms for display by <code><a href="stats.html#topic+termplot">termplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'georob'
predict(object, newdata, type =  c("signal", "response", "trend", "terms"),
    terms = NULL, se.fit = TRUE, signif = 0.95, locations,
    variogram.model = NULL, param = NULL, aniso = NULL, variogram.object = NULL,
    control = control.predict.georob(), verbose = 0, ...)

control.predict.georob(full.covmat = FALSE, extended.output = FALSE,
    mmax = 10000, ncores = pcmp[["max.ncores"]], pwidth = NULL, pheight = NULL,
    napp = 1, pcmp = control.pcmp())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.georob_+3A_object">object</code></td>
<td>
<p>an object of class <code>"georob"</code> (mandatory argument),
see <code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame,
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> or an (optional) object of class
<code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>,
<code><a href="sp.html#topic+SpatialPixels">SpatialPixels</a></code> or
<code><a href="sp.html#topic+SpatialGrid">SpatialGrid</a></code>,
in which to look for variables
with which to compute fitted values or Kriging predictions, see <em>Details</em>.<br /> If
<code>newdata</code> is a <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> then
block Kriging predictions are computed, otherwise point Kriging
predictions.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_type">type</code></td>
<td>
<p>a character keyword defining what target quantity should be
predicted (computed).  Possible values are
</p>

<ul>
<li> <p><code>"signal"</code>: the &ldquo;signal&rdquo;
<code class="reqn">Z(\boldsymbol{s}) =
      \boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta} +
      B(\boldsymbol{s})</code> of
the process (default),
</p>
</li>
<li> <p><code>"response"</code>: the observations
<code class="reqn">Y(\boldsymbol{s}) =
      Z(\boldsymbol{s}) +
      \varepsilon(\boldsymbol{s}),</code>
</p>
</li>
<li> <p><code>"trend"</code>: the external drift
<code class="reqn">\boldsymbol{x}(\boldsymbol{s})^\mathrm{T}
      \boldsymbol{\beta},</code>
</p>
</li>
<li> <p><code>"terms"</code>: the model terms.
</p>
</li></ul>

</td></tr>
<tr><td><code id="predict.georob_+3A_terms">terms</code></td>
<td>
<p>If <code>type = "terms"</code>, which terms (default is all terms).</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_se.fit">se.fit</code></td>
<td>
<p>a logical scalar, only used if <code>type</code> is equal to
<code>"terms"</code>, see <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_signif">signif</code></td>
<td>
<p>a positive numeric scalar equal to the tolerance or confidence level
for computing respective intervals.  If <code>NULL</code> no intervals are
computed.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_locations">locations</code></td>
<td>
<p>an optional one-sided formula specifying what variables
of <code>newdata</code> are the coordinates of the prediction points<br />
(default: <code>object[["locations.objects"]][["locations"]]</code>).</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_variogram.model">variogram.model</code></td>
<td>
<p>an optional character keyword defining the
variogram model to be used for Kriging, see <code><a href="#topic+georob">georob</a></code> and
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_param">param</code></td>
<td>
<p>an optional named numeric vector with values of the
variogram parameters used for Kriging, see <code><a href="#topic+georob">georob</a></code> and
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_aniso">aniso</code></td>
<td>
<p>an optional named numeric vector with values of anisotropy
parameters of a variogram used for Kriging, see <code><a href="#topic+georob">georob</a></code> and
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_variogram.object">variogram.object</code></td>
<td>
<p>an optional list that defines a possibly nested
variogram model used for Kriging, see <code><a href="#topic+georob">georob</a></code> and
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_control">control</code></td>
<td>
<p>a list with the components <code>full.covmat</code>,
<code>extended.output</code>, <code>mmax</code>, <code>ncores</code>, <code>pwidth</code>,
<code>pheight</code>, <code>napp</code> and <code>pcmp</code> or a function such as
<code>control.predict.georob</code> that generates such a list.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_full.covmat">full.covmat</code></td>
<td>
<p>a logical scalar controlling whether the full
covariance matrix of the prediction errors is returned (<code>TRUE</code>) or
only the vector with its diagonal elements (<code>FALSE</code>, default), see
<em>Value</em> for an explanation of the effect of <code>full.covmat</code>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_extended.output">extended.output</code></td>
<td>
<p>a logical scalar controlling whether the covariance
matrices of the Kriging predictions and of the data should be computed, see
<em>Details</em> (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_mmax">mmax</code></td>
<td>
<p>a positive integer equal to the maximum number (default
<code>10000</code>) of prediction items, computed in a sub-task in parallelized
computations, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer controlling how many cores are used for
parallelized computations, see <em>Details</em>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_pwidth">pwidth</code>, <code id="predict.georob_+3A_pheight">pheight</code>, <code id="predict.georob_+3A_napp">napp</code></td>
<td>
<p>numeric scalars, used to tune numeric
integration of semi-variances for block Kriging, see
<code><a href="constrainedKriging.html#topic+preCKrige">preCKrige</a></code>.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_pcmp">pcmp</code></td>
<td>
<p>a list of arguments passed to <code><a href="#topic+pmm">pmm</a></code> and other
functions that carry out parallelized computations or a function such as
<code><a href="#topic+control.pcmp">control.pcmp</a></code> that generates such a list (see
<code><a href="#topic+control.pcmp">control.pcmp</a></code> for allowed arguments).</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console.<br />  <code>verbose = 0</code> (default) largely suppresses
such messages.</p>
</td></tr>
<tr><td><code id="predict.georob_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>control.predict.georob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is an object of class <code>SpatialPoints</code>,
<code>SpatialPixels</code> or <code>SpatialGrid</code> then the drift model may only
use the coordinates as covariates (universal Kriging).  Furthermore the
names used for the coordinates in <code>newdata</code> must be the same as in
<code>data</code> when creating <code>object</code> (argument <code>locations</code> of
<code>predict.georob</code> should not be used).  Note that the result returned
by <code>predict.georob</code> is then an object of class
<code>SpatialPointsDataFrame</code>, <code>SpatialPixelsDataFrame</code> or
<code>SpatialGridDataFrame</code>.
</p>
<p>The <code>predict</code> method for class <code>georob</code> uses the packages
<span class="pkg">parallel</span> and <span class="pkg">snowfall</span> for parallelized
computation of Kriging predictions.  If there are <code class="reqn">m</code> items to
predict, the task is split into <code>ceiling(m/mmax)</code> sub-tasks that are
then distributed to <code>ncores</code> CPUs.  Evidently, <code>ncores = 1</code>
suppresses parallel execution.  By default, the function uses all
available CPUs as returned by <code><a href="parallel.html#topic+detectCores">detectCores</a></code>.  <br />
Note that if <code>full.covmat</code> is <code>TRUE</code> <code>mmax</code> must exceed
<code class="reqn">m</code> (and parallel execution is not possible).
</p>
<p>The argument <code>extended.output = TRUE</code> is used to compute all
quantities required for (approximately) unbiased back-transformation of
Kriging predictions of log-transformed data to the original scale of the
measurements by <code><a href="#topic+lgnpp">lgnpp</a></code>.  In more detail, the following items
are computed:
</p>

<ul>
<li> <p><code>trend</code>: the fitted values,
<code class="reqn">\boldsymbol{x}(\boldsymbol{s})\mathrm{^T}\widehat{\boldsymbol{\beta}}</code>,
</p>
</li>
<li> <p><code>var.pred</code>: the variances of the Kriging predictions,
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[\widehat{Y}(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s})]</code>,
</p>
</li>
<li> <p><code>cov.pred.target</code>: the covariances between the predictions and the
prediction targets,<br />
<code class="reqn">\mathrm{Cov}_{\hat{\theta}}[\widehat{Y}(\boldsymbol{s}),Y(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Cov}_{\hat{\theta}}[\widehat{Z}(\boldsymbol{s}),Z(\boldsymbol{s})]</code>,
</p>
</li>
<li> <p><code>var.target</code>: the variances of the prediction targets
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[Y(\boldsymbol{s})]</code> or
<code class="reqn">\mathrm{Var}_{\hat{\theta}}[Z(\boldsymbol{s})]</code>.
</p>
</li></ul>

<p>Note that the component <code>var.pred</code> is also  present if
<code>type</code> is equal to <code>"trend"</code>, irrespective of the choice for <code>extended.output</code>.
This component contains then the variances of the fitted values.
</p>


<h3>Value</h3>

<p>The method <code>predict.georob</code> returns, depending on its arguments, the
following objects:
</p>
<p>If <code>type</code> is equal to <code>"terms"</code> then a vector, a matrix, or a
list with prediction results along with bounds and standard errors, see
<code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.  Otherwise, the structure and contents
of the output generated by <code>predict.georob</code> are determined by the
class of <code>newdata</code> and the logical flags <code>full.covmat</code> and
<code>extended.output</code>:
</p>
<p>If <code>full.covmat</code> is <code>FALSE</code> then the result is an object of a &quot;similar&quot;
class as <code>newdata</code> (data frame,
<code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code>,
<code><a href="sp.html#topic+SpatialPixelsDataFrame">SpatialPixelsDataFrame</a></code>
<code><a href="sp.html#topic+SpatialGridDataFrame">SpatialGridDataFrame</a></code>, <br />
<code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code>).
</p>
<p>The data frame or the
<code>data</code> slot of the <code>Spatial...DataFrame</code> objects
have the following components:
</p>

<ul>
<li><p> the coordinates of the prediction points (only present if
<code>newdata</code> is a data frame).
</p>
</li>
<li> <p><code>pred</code>: the Kriging predictions (or fitted values).
</p>
</li>
<li> <p><code>se</code>: the root mean squared prediction errors (Kriging
standard errors).
</p>
</li>
<li> <p><code>lower</code>, <code>upper</code>: the limits of tolerance/confidence
intervals,
</p>
</li>
<li> <p><code>trend</code>, <code>var.pred</code>, <code>cov.pred.target</code>,
<code>var.target</code>: only present if <code>extended.output</code> is <code>TRUE</code>,
see <em>Details</em>.
</p>
</li></ul>

<p>If <code>full.covmat</code> is <code>TRUE</code> then <code>predict.georob</code> returns a list
with the following components:
</p>

<ul>
<li> <p><code>pred</code>: a data frame or a <code>Spatial...DataFrame</code> object
as described above for<br /> <code>full.covmat = FALSE</code>.
</p>
</li>
<li> <p><code>mse.pred</code>: the full covariance matrix of the prediction errors,
<code class="reqn">Y(\boldsymbol{s})-\widehat{Y}(\boldsymbol{s})</code> or
<code class="reqn">Z(\boldsymbol{s})-\widehat{Z}(\boldsymbol{s})</code>
see <em>Details</em>.
</p>
</li>
<li> <p><code>var.pred</code>: the full covariance matrix of the
Kriging predictions, see <em>Details</em>.
</p>
</li>
<li> <p><code>cov.pred.target</code>: the full covariance matrix of the
predictions and the prediction targets, see <em>Details</em>.
</p>
</li>
<li> <p><code>var.target</code>: the full covariance matrix of the
prediction targets, see <em>Details</em>.
</p>
</li></ul>

<p>The function <code>control.predict.georob</code> returns a list with control
parameters to steer <code>predict.georob</code>, see arguments of the
function above for its components.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Nussbaum, M., Papritz, A., Baltensweiler, A. and Walthert, L. (2014)
Estimating soil organic carbon stocks of Swiss forest soils by robust
external-drift kriging.  <em>Geoscientific Model Development</em>,
<b>7</b>, 1197&ndash;1210.  <a href="https://doi.org/10.5194/gmd-7-1197-2014">doi:10.5194/gmd-7-1197-2014</a>.
</p>
<p>Künsch, H. R., Papritz, A., Schwierz, C. and Stahel, W. A. (2011) Robust
estimation of the external drift and the variogram of spatial data.
Proceedings of the ISI 58th World Statistics Congress of the International
Statistical Institute.
<a href="https://doi.org/10.3929/ethz-a-009900710">doi:10.3929/ethz-a-009900710</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse)

data(meuse.grid)
coordinates(meuse.grid) &lt;- ~x+y
meuse.grid.pixdf &lt;- meuse.grid
gridded(meuse.grid.pixdf) &lt;- TRUE

data(meuse.blocks, package = "constrainedKriging")

r.logzn.rob &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
    variogram.model = "RMexp", param = c(variance = 0.15, nugget = 0.05, scale = 200),
    tuning.psi = 1., control = control.georob(cov.bhat = TRUE, full.cov.bhat = TRUE))

## point predictions of log(Zn)
r.pred.points.1 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
    control = control.predict.georob(extended.output = TRUE))
str(r.pred.points.1, max = 3)

## back-transformation of point predictions
r.backtf.pred.points &lt;- lgnpp(r.pred.points.1)
str(r.backtf.pred.points, max = 3)

spplot(r.backtf.pred.points, zcol = "lgn.pred", main = "Zn content")

## predicting mean Zn content for whole area
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  ## recompute point predictions with argument full.covmat = TRUE
  r.pred.points.2 &lt;- predict(r.logzn.rob, newdata = meuse.grid.pixdf,
      control = control.predict.georob(extended.output = TRUE, full.covmat = TRUE))
  str(r.pred.points.2, max = 3)
  r.block &lt;- lgnpp(r.pred.points.2, is.block = TRUE, all.pred = r.backtf.pred.points@data)
  r.block
}

## block predictions of log(Zn)
if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.pred.block &lt;- predict(r.logzn.rob, newdata = meuse.blocks,
      control = control.predict.georob(extended.output = TRUE,
          pwidth = 75, pheight = 75, mmax = 50))
  r.backtf.pred.block &lt;- lgnpp(r.pred.block, newdata = meuse.grid)

  spplot(r.backtf.pred.block, zcol = "lgn.pred", main = "block means Zn content")
}
</code></pre>

<hr>
<h2 id='profilelogLik'>Profile Likelihood</h2><span id='topic+profilelogLik'></span>

<h3>Description</h3>

<p>The function <code>profilelogLik</code> computes for an array of fixed
variogram parameters the profile log-likelihood by maximizing the
(restricted) log-likelihood with respect to the remaining variogram
parameters, the fixed and random effects.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>  profilelogLik(object, values, use.fitted = TRUE, verbose = 0,
    ncores = min(parallel::detectCores(), NROW(values)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profilelogLik_+3A_object">object</code></td>
<td>
<p>an object of class <code>"georob"</code> (mandatory argument),
see <code><a href="#topic+georobObject">georobObject</a></code>.</p>
</td></tr>
<tr><td><code id="profilelogLik_+3A_values">values</code></td>
<td>
<p>a <code>data.frame</code> or a <code>matrix</code> with the values of
the variogram and anisotropy parameters that should be kept fixed
(mandatory argument, see <code><a href="#topic+georob">georob</a></code> and
<code><a href="#topic+georobPackage">georobPackage</a></code> for information about the parametrization of
variogram models).  The names of the columns of <code>values</code> must match
the names of variogram and anisotropy parameters.</p>
</td></tr>
<tr><td><code id="profilelogLik_+3A_use.fitted">use.fitted</code></td>
<td>
<p>a logical scalar controlling whether the fitted variogram
parameters of <code>object</code> should be used as initial values (default
<code>TRUE</code>) when maximizing the profile log-likelihood or the initial
values used to generate <code>object</code>.</p>
</td></tr>
<tr><td><code id="profilelogLik_+3A_verbose">verbose</code></td>
<td>
<p>a positive integer controlling logging of diagnostic
messages to the console during model fitting, see <code><a href="#topic+georob">georob</a></code>.</p>
</td></tr>
<tr><td><code id="profilelogLik_+3A_ncores">ncores</code></td>
<td>
<p>a positive integer controlling how many cores are used for
parallelized computations, see <em>Details</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For robust REML fits <code>profilelogLik</code> returns (possibly with a
warning) the log-likelihood of the Gaussian (RE)ML fit of the equivalent
Gaussian spatial linear model with heteroscedastic nugget.
</p>
<p><b>Note</b> that <em>the data frame passed as</em> <code>data</code>
<em>argument to</em> <code>georob</code> <em>must exist in the user workspace
when calling <code>profilelogLik</code></em>.
</p>
<p><code>profilelogLik</code> uses the packages <span class="pkg">parallel</span> and
<span class="pkg">snowfall</span> for parallelized computation of the profile
likelihood.  By default, the function uses <code>NROW(values)</code> CPUs but
not more than are physically available (as returned by
<code><a href="parallel.html#topic+detectCores">detectCores</a></code>).
</p>
<p><code>profilelogLik</code> uses the function <code><a href="stats.html#topic+update">update</a></code> to
re-estimated the model with partly fixed variogram parameters.
Therefore, any argument accepted by <code><a href="#topic+georob">georob</a></code> except
<code>data</code> can be changed when re-fitting the model.  Some of them (e.g.
<code>verbose</code>) are explicit arguments of
<code>profilelogLik</code>, but also the remaining ones can be passed by
<code>...</code> to the function.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the columns of <code>values</code>, a column
<code>loglik</code> (contains the maximized [restricted] log-likelihood),
columns with the estimated variogram and fixed effect parameters, columns
with the gradient of the (restricted) log-likelihood (or the roots of the
estimating equations) and a column <code>converged</code>, indicating whether
convergence has occurred when fitting the respective model.  </p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>; and finally
</p>
<p><code><a href="#topic+sample.variogram">sample.variogram</a></code> and <code><a href="#topic+fit.variogram.model">fit.variogram.model</a></code>
for robust estimation and modelling of sample variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define number of cores for parallel computations
if(interactive()) ncpu &lt;- 2L else ncpu &lt;- 1L

data(meuse)

r.logzn.ml &lt;- georob(log(zinc)~sqrt(dist), data=meuse, locations=~x+y,
    variogram.model="RMexp", param=c(variance=0.15, nugget=0.05, scale=200),
    tuning.psi=1000, control=control.georob(ml.method="ML"))

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.prflik &lt;- profilelogLik(r.logzn.ml, values=expand.grid(scale=seq(75, 600, by=25)),
      ncores = ncpu)

  plot(loglik~scale, r.prflik, type="l")
  abline(v=r.logzn.ml$variogram.object[[1]]$param["scale"], lty="dotted")
  abline(h=r.logzn.ml$loglik-0.5*qchisq(0.95, 1), lty="dotted")
}
</code></pre>

<hr>
<h2 id='reexported-fun'>Re-Exported Functions from <span class="rlang"><b>R</b></span> package imports</h2><span id='topic+K'></span><span id='topic+lmrob.control'></span>

<h3>Description</h3>

<p>The imported functions <code><a href="constrainedKriging.html#topic+K">K</a></code>,
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>,
and <code><a href="lmtest.html#topic+waldtest">waldtest</a></code> are re-exported for ease of use without
attaching the respective packages.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>K(dist, model)

lmrob.control(setting, seed = NULL, nResample = 500, tuning.chi = NULL,
  bb = 0.5, tuning.psi = NULL, max.it = 50, groups = 5, n.group = 400,
  k.fast.s = 1, best.r.s = 2, k.max = 200, maxit.scale = 200, k.m_s = 20,
  refine.tol = 1e-7, rel.tol = 1e-7, scale.tol = 1e-10, solve.tol = 1e-7,
  zero.tol = 1e-10, trace.lev = 0, mts = 1000,
  subsampling = c("nonsingular", "simple"), compute.rd = FALSE,
  method = "MM", psi = "bisquare", numpoints = 10, cov = NULL,
  split.type = c("f", "fi", "fii"), fast.s.large.n = 2000,
  # only for outlierStats() :
  eps.outlier = function(nobs) 0.1 / nobs,
  eps.x = function(maxx) .Machine$double.eps^(.75)*maxx,
  compute.outlier.stats = method, warn.limit.reject = 0.5,
  warn.limit.meanrw = 0.5, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reexported-fun_+3A_dist">dist</code></td>
<td>
<p>a numeric vector with distances.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_model">model</code></td>
<td>
<p>an object of class &ldquo;<code>covmodel</code>&rdquo; that defines an
isotropic covariance model, see
<code><a href="constrainedKriging.html#topic+covmodel">covmodel</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_setting">setting</code></td>
<td>
<p>a string specifying alternative default values, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_seed">seed</code></td>
<td>
<p><code>NULL</code> or an integer vector compatible with
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.
</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_nresample">nResample</code></td>
<td>
<p>number of re-sampling candidates to be used to find the
initial S-estimator, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>tuning constant vector for the S-estimator, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_bb">bb</code></td>
<td>
<p>expected value under the normal model of the &ldquo;chi&rdquo;, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code></p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>tuning constant vector for the redescending
M-estimator, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_max.it">max.it</code></td>
<td>
<p>integer specifying the maximum number of IRWLS iterations,
see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_groups">groups</code></td>
<td>
<p>(for the fast-S algorithm): Number of random subsets to use
when the data set is large, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_n.group">n.group</code></td>
<td>
<p>(for the fast-S algorithm): Size of each of the
<code>groups</code> above, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_k.fast.s">k.fast.s</code></td>
<td>
<p>(for the fast-S algorithm): Number of local improvement
steps (&ldquo;<em>I-steps</em>&rdquo;) for each re-sampling candidate, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_best.r.s">best.r.s</code></td>
<td>
<p>(for the fast-S algorithm): Number of of best candidates
to be iterated further, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_k.max">k.max</code></td>
<td>
<p>(for the fast-S algorithm): maximal number of refinement
steps for the &ldquo;fully&rdquo; iterated best candidates, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_maxit.scale">maxit.scale</code></td>
<td>
<p>integer specifying the maximum number of C level
<code>find_scale()</code> iterations (in fast-S and M-S algorithms), see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_k.m_s">k.m_s</code></td>
<td>
<p>(for the M-S algorithm): specifies after how many
unsuccessful refinement steps the algorithm stops, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_refine.tol">refine.tol</code></td>
<td>
<p>(for the fast-S algorithm): relative convergence
tolerance for the fully iterated best candidates, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_rel.tol">rel.tol</code></td>
<td>
<p>(for the RWLS iterations of the MM algorithm): relative
convergence tolerance for the parameter vector, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_scale.tol">scale.tol</code></td>
<td>
<p>(for the scale estimation iterations of the S
algorithm): relative convergence tolerance for the <code>scale</code>
<code class="reqn">\sigma(.)</code>, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_solve.tol">solve.tol</code></td>
<td>
<p>(for the S algorithm): relative tolerance for inversionsee
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_zero.tol">zero.tol</code></td>
<td>
<p>for checking 0-residuals in the S algorithm, non-negative
number, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_trace.lev">trace.lev</code></td>
<td>
<p>integer indicating if the progress of the MM-algorithm
and the fast-S algorithms should be traced, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_mts">mts</code></td>
<td>
<p>maximum number of samples to try in subsampling algorithm, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_subsampling">subsampling</code></td>
<td>
<p>type of subsampling to be used, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_compute.rd">compute.rd</code></td>
<td>
<p>a logical scalar indicating if robust distances (based on the
MCD robust covariance estimator) are to be computed for the robust
diagnostic plots, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_method">method</code></td>
<td>
<p>string specifying the estimator-chain, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_psi">psi</code></td>
<td>
<p>string specifying the type <code class="reqn">\psi</code>-function used., see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_numpoints">numpoints</code></td>
<td>
<p>number of points used in Gauss quadrature, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code></p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_cov">cov</code></td>
<td>
<p>function or string with function name to be used to calculate
covariance matrix estimate, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_split.type">split.type</code></td>
<td>
<p>determines how categorical and continuous variables are
split, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_fast.s.large.n">fast.s.large.n</code></td>
<td>
<p>minimum number of observations required to switch
from ordinary &ldquo;fast S&rdquo; algorithm to an efficient &ldquo;large n&rdquo;
strategy, see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code></p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_eps.outlier">eps.outlier</code></td>
<td>
<p>limit on the robustness weight below which an
observation is considered to be an outlier, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_eps.x">eps.x</code></td>
<td>
<p>limit on the absolute value of the elements of the design
matrix below which an element is considered zero, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_compute.outlier.stats">compute.outlier.stats</code></td>
<td>
<p>vector of character strings, each valid to
be used as <code>method</code> argument, see
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code></p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_warn.limit.reject">warn.limit.reject</code></td>
<td>
<p>see <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code>.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_warn.limit.meanrw">warn.limit.meanrw</code></td>
<td>
<p>limit of the mean robustness per factor level
below which (<code class="reqn">\leq</code>) a warning is produced.  Set to <code>NULL</code>
to disable warning.</p>
</td></tr>
<tr><td><code id="reexported-fun_+3A_...">...</code></td>
<td>
<p>some methods for the generic function
<code><a href="lmtest.html#topic+waldtest">waldtest</a></code> require additional arguments, see
respective help pages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="constrainedKriging.html#topic+K">K</a></code> is required for
computing block Kriging predictions by the function
<code><a href="constrainedKriging.html#topic+f.point.block.cov">f.point.block.cov</a></code> of the package
<span class="pkg">constrainedKriging</span>.
</p>
<p>Furthermore, the function <code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code> allows
to pass tuning parameters to the function <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>
of the package <span class="pkg">robustbase</span>, which is used for computing robust
initial values of the regression coefficients.  </p>


<h3>Value</h3>

<p>See help pages of <code><a href="constrainedKriging.html#topic+K">K</a></code> and
<code><a href="robustbase.html#topic+lmrob.control">lmrob.control</a></code> for the output generated by these
functions.
</p>

<hr>
<h2 id='sample.variogram'>Computing (Robust) Sample Variograms of Spatial Data</h2><span id='topic+sample.variogram'></span><span id='topic+sample.variogram.default'></span><span id='topic+sample.variogram.formula'></span><span id='topic+sample.variogram.georob'></span><span id='topic+summary.sample.variogram'></span><span id='topic+print.summary.sample.variogram'></span><span id='topic+plot.sample.variogram'></span>

<h3>Description</h3>

<p>The function <code>sample.variogram</code> computes the
sample (empirical) variogram of a spatial variable by the method-of-moment
and three robust estimators.  Both omnidirectional and direction-dependent
variograms can be computed, the latter for observation locations in a
three-dimensional domain.  There are <code>summary</code> and <code>plot</code>
methods for summarizing and displaying sample variograms.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sample.variogram(object, ...)

## Default S3 method:
sample.variogram(object, locations, lag.dist.def,
    xy.angle.def = c(0, 180), xz.angle.def = c(0, 180), max.lag = Inf,
    estimator = c("qn", "mad", "matheron", "ch"), mean.angle = TRUE, ...)

## S3 method for class 'formula'
sample.variogram(object, data, subset, na.action,
    locations, lag.dist.def, xy.angle.def = c(0, 180),
    xz.angle.def = c(0, 180), max.lag = Inf,
    estimator = c("qn", "mad", "matheron", "ch"), mean.angle = TRUE, ...)

## S3 method for class 'georob'
sample.variogram(object, lag.dist.def,
    xy.angle.def = c(0, 180), xz.angle.def = c(0, 180), max.lag = Inf,
    estimator = c("qn", "mad", "matheron", "ch"), mean.angle = TRUE, ...)

## S3 method for class 'sample.variogram'
summary(object, ...)

## S3 method for class 'sample.variogram'
plot(x, type = "p", add = FALSE,
    xlim = c(0, max(x[["lag.dist"]])),
    ylim = c(0, 1.1 * max(x[["gamma"]])), col, pch, lty, cex = 0.8,
    xlab = "lag distance", ylab = "semivariance",
    annotate.npairs = FALSE, npairs.pos = 3, npairs.cex = 0.7,
    legend = nlevels(x[["xy.angle"]]) &gt; 1 || nlevels(x[["xz.angle"]]) &gt; 1,
    legend.pos = "topleft", ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.variogram_+3A_object">object</code></td>
<td>
<p>a numeric vector with the values of the response for which
the sample variogram should be computed
(<code>sample.variogram.default</code>), a formula, specifying in its left part
the response variable (right part of formula is ignored,
<code>sample.variogram.formula</code>), an object of class <code>georob</code><br />
(<code>sample.variogram.georob</code>) or an object of class<br />
<code>sample.variogram</code> (<code>summary.sample.variogram</code>).</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_locations">locations</code></td>
<td>
<p>a numeric matrix with the coordinates of the locations
where the response was observed (<code>sample.variogram.default</code>) or a
one-sided formula specifying the coordinates
(<code>sample.variogram.formula</code>).  The matrix may have an arbitrary
number of columns for an omnidirectional variogram, but at most 3 columns
if a directional variogram is computed.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or another
object coercible by<br /> <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame)
containing the response variable and the coordinates where the data
was recorded.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>sample.variogram</code> is called.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used for estimating the variogram.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the
data contain <code>NA</code>s.  The default is set by the <code>na.action</code>
argument of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is
unset.  The &ldquo;factory-fresh&rdquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.
Another possible value is <code>NULL</code>, no action.  Value
<code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_lag.dist.def">lag.dist.def</code></td>
<td>
<p>a numeric scalar defining a constant bin
width for grouping the lag distances or a numeric vector with the bounds
of a set of contiguous bins (upper bounds of bins except for the first
element of <code>lag.dist.def</code> which is the lower bound of the first
bin). This argument is mandatory.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_xy.angle.def">xy.angle.def</code></td>
<td>
<p>an numeric vector defining angular classes
in the horizontal plane for computing directional variograms.
<code>xy.angle.def</code> must contain an ascending sequence of azimuth angles
in degrees from north (positive clockwise to south), see <em>Details</em>.
Omnidirectional variograms are computed with the default
<code>c(0,180)</code>.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_xz.angle.def">xz.angle.def</code></td>
<td>
<p>an numeric vector defining angular classes
in the <code class="reqn">x</code>-<code class="reqn">z</code>-plane for computing directional variograms.
<code>xz.angle.def</code> must contain an ascending sequence of angles in
degrees from zenith (positive clockwise to nadir), see
<em>Details</em>.  Omnidirectional variograms are computed with the default
<code>c(0,180)</code>.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_max.lag">max.lag</code></td>
<td>
<p>a positive numeric defining the largest lag distance for
which semi variances should be computed (default no restriction).</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_estimator">estimator</code></td>
<td>
<p>a character keyword defining the estimator for computing
the sample variogram.  Possible values are:
</p>

<ul>
<li> <p><code>"qn"</code>: Genton's robust
<code><a href="robustbase.html#topic+Qn">Qn</a></code>-estimator (default, <cite>Genton, 1998</cite>),
</p>
</li>
<li> <p><code>"mad"</code>: Dowd's robust MAD-estimator (<cite>Dowd, 1984</cite>),
</p>
</li>
<li> <p><code>"matheron"</code>: non-robust method-of-moments estimator,
</p>
</li>
<li> <p><code>"ch"</code>: robust Cressie-Hawkins estimator (<cite>Cressie and
Hawkins, 1980</cite>).
</p>
</li></ul>

</td></tr>
<tr><td><code id="sample.variogram_+3A_mean.angle">mean.angle</code></td>
<td>
<p>a logical scalar controlling whether the mean lag vector (per
combination of lag distance and angular class) is computed from the mean
angles of all the lag vectors falling into a given class (<code>TRUE</code>,
default) or from the mid-angles of the respective angular classes
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_x">x</code></td>
<td>
<p>an object of class <code>sample.variogram</code>.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_type">type</code>, <code id="sample.variogram_+3A_xlim">xlim</code>, <code id="sample.variogram_+3A_ylim">ylim</code>, <code id="sample.variogram_+3A_xlab">xlab</code>, <code id="sample.variogram_+3A_ylab">ylab</code></td>
<td>
<p>see respective arguments of
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_add">add</code></td>
<td>
<p>a logical scalar controlling whether a new plot should be
generated (<code>FALSE</code>, default) or whether the information should be
added to the current plot (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_col">col</code></td>
<td>
<p>a vector with the colours of plotting symbols for distinguishing semi variances
for angular classes in the <code class="reqn">x</code>-<code class="reqn">y</code>-plane.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_pch">pch</code></td>
<td>
<p>a vector with the types of plotting symbols for distinguishing
semi variances for angular classes in the <code class="reqn">x</code>-<code class="reqn">z</code>-plane.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_lty">lty</code></td>
<td>
<p>the line type.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_cex">cex</code></td>
<td>
<p>a numeric with the character expansion factor for plotting
symbols.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_annotate.npairs">annotate.npairs</code></td>
<td>
<p>a logical scalar controlling whether the plotting symbols
should be annotated by the number of data pairs per lag class.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_npairs.pos">npairs.pos</code></td>
<td>
<p>an integer defining the position where text annotation
about number of pairs should be plotted, see
<code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_npairs.cex">npairs.cex</code></td>
<td>
<p>a numeric defining the character expansion for text
annotation about number of pairs.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_legend">legend</code></td>
<td>
<p>a logical scalar controlling whether a
<code><a href="graphics.html#topic+legend">legend</a></code> should be plotted.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_legend.pos">legend.pos</code></td>
<td>
<p>a character keyword defining where to place the
legend, see <code><a href="graphics.html#topic+legend">legend</a></code> for possible values.</p>
</td></tr>
<tr><td><code id="sample.variogram_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="graphics.html#topic+plot.formula">plot.formula</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The angular classes in the <code class="reqn">x</code>-<code class="reqn">y</code>- and <code class="reqn">x</code>-<code class="reqn">z</code>-plane are
defined by vectors of ascending angles on the half circle.  The <code class="reqn">i</code>th
angular class is defined by the vector elements, say <var>l</var> and <var>u</var>,
with indices <code class="reqn">i</code> and <code class="reqn">i+1</code>.  A lag vector belongs to the
<code class="reqn">i</code>th angular class if its azimuth (or angle from zenith), say
<code class="reqn">\varphi</code>, satisfies <code class="reqn"> l &lt; \varphi \leq u</code>.
If the first and the last element of <code>xy.angle.def</code> or
<code>xz.angle.def</code> are equal to <code>0</code> and <code>180</code> degrees,
respectively, then the first and the last angular class are
&ldquo;joined&rdquo;, i.e., if there are <code class="reqn">K</code> angles, there will be only
<code class="reqn">K-2</code> angular classes and the first class is defined by the interval
( <var>xy.angle.def</var>[<var>K</var>-1]-180, <var>xy.angle.def</var>[2] ] and the last
class by ( <var>xy.angle.def</var>[<var>K</var>-2], <var>xy.angle.def</var>[<var>K</var>-1]].
</p>


<h3>Value</h3>

<p>All methods of the generic function <code>sample.variogram</code>
return an object of class  <code>sample.variogram</code>, which
is a data frame with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>lag.dist</code> </td><td style="text-align: left;"> the mean lag distance of the lag class, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xy.angle</code> </td><td style="text-align: left;"> the angular class in the <code class="reqn">x</code>-<code class="reqn">y</code>-plane, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xz.angle</code> </td><td style="text-align: left;"> the angular class in the <code class="reqn">x</code>-<code class="reqn">z</code>-plane, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gamma</code> </td><td style="text-align: left;"> the estimated semi-variance of the lag class, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>npairs</code> </td><td style="text-align: left;"> the number of data pairs in the lag class, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lag.x</code> </td><td style="text-align: left;"> the <code class="reqn">x</code>-component of the mean lag vector of the lag class, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lag.x</code> </td><td style="text-align: left;"> the <code class="reqn">y</code>-component of the mean lag vector of the lag class, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lag.z</code> </td><td style="text-align: left;"> the <code class="reqn">z</code>-component of the mean lag vector of the lag class.</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The method <code>summary.sample.variogram</code> returns an object of class
<code>summary.sample.variogram</code> which is list with the components
<code>log.dist</code>, <code>npairs</code>, <code>xy.angle</code> and <code>xz.angle</code>, see
description for object of class <code>sample.variogram</code> above.  There is a
<code>print</code> method for objects of class <code>summary.sample.variogram</code>
which invisibly returns the object unchanged.
</p>
<p>The method <code>plot.sample.variogram</code> is called for its side effects and
invisibly returns the object <code>sample.variogram</code> unchanged.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Cressie, N. and Hawkins, D. M. (1980) Robust Estimation of the Variogram:
I. <em>Mathematical Geology</em>, <b>12</b>, 115&ndash;125,
<a href="https://doi.org/10.1007/BF01035243">doi:10.1007/BF01035243</a>.
</p>
<p>Dowd, P. A. (1984) The variogram and Kriging: Robust and resistant
estimators.  In <em>Geostatistics for Natural Resources
Characterization</em>, Verly, G., David, M., Journel, A. and Marechal, A.
(Eds.)  Dordrecht: D. Reidel Publishing Company, Part I, 1, 91&ndash;106,
<a href="https://doi.org/10.1007/978-94-009-3699-7">doi:10.1007/978-94-009-3699-7</a>.
</p>
<p>Genton, M. (1998) Highly Robust Variogram Estimation.  <em>Mathematical
Geology</em>, <b>30</b>, 213&ndash;220, <a href="https://doi.org/10.1023/A%3A1021728614555">doi:10.1023/A:1021728614555</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georobPackage">georobPackage</a></code> for a description of the model and a brief summary of the algorithms;
</p>
<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+georobObject">georobObject</a></code> for a description of the class <code>georob</code>;
</p>
<p><code><a href="#topic+profilelogLik">profilelogLik</a></code> for computing profiles of Gaussian likelihoods;
</p>
<p><code><a href="#topic+plot.georob">plot.georob</a></code> for display of RE(ML) variogram estimates;
</p>
<p><code><a href="#topic+control.georob">control.georob</a></code> for controlling the behaviour of <code>georob</code>;
</p>
<p><code><a href="#topic+georobModelBuilding">georobModelBuilding</a></code> for stepwise building models of class <code>georob</code>;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>;
</p>
<p><code><a href="#topic+georobMethods">georobMethods</a></code> for further methods for the class <code>georob</code>;
</p>
<p><code><a href="#topic+predict.georob">predict.georob</a></code> for computing robust Kriging predictions;
</p>
<p><code><a href="#topic+lgnpp">lgnpp</a></code> for unbiased back-transformation of Kriging prediction
of log-transformed data;
</p>
<p><code><a href="#topic+georobSimulation">georobSimulation</a></code> for simulating realizations of a Gaussian process
from model fitted by <code>georob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wolfcamp)

## omnidirectional sample variogram
r.sv.iso &lt;- sample.variogram(pressure~1, data = wolfcamp,
    locations = ~x + y, lag.dist.def = seq(0, 200, by = 15))

plot(r.sv.iso, type = "l")

## direction-dependent sample variogram
r.sv.aniso &lt;- sample.variogram(pressure~1, data = wolfcamp,
    locations = ~x + y, lag.dist.def = seq(0, 200, by = 15),
    xy.angle.def = c(0., 22.5, 67.5, 112.5, 157.5, 180.))
plot(r.sv.aniso, type = "l", add = TRUE, col = 2:5)
</code></pre>

<hr>
<h2 id='validate.predictions'>Summary Statistics of (Cross-)Validation Prediction Errors</h2><span id='topic+validate.predictions'></span><span id='topic+plot.cv.georob'></span><span id='topic+print.cv.georob'></span><span id='topic+summary.cv.georob'></span><span id='topic+print.summary.cv.georob'></span>

<h3>Description</h3>

<p>Functions to compute and plot summary statistics of prediction errors to
(cross-)validate fitted spatial linear models by the criteria proposed by
<cite>Gneiting et al.  (2007)</cite> for assessing probabilistic forecasts.</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.predictions(data, pred, se.pred,
    statistic = c("crps", "pit", "mc", "bs", "st"), ncutoff = NULL)

## S3 method for class 'cv.georob'
plot(x,
    type = c("sc", "lgn.sc", "ta", "qq", "hist.pit", "ecdf.pit", "mc", "bs"),
    smooth = TRUE, span = 2/3, ncutoff = NULL, add = FALSE,
    col, pch, lty, main, xlab, ylab, ...)

## S3 method for class 'cv.georob'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'cv.georob'
summary(object, se = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.predictions_+3A_data">data</code></td>
<td>
<p>a numeric vector with observations about a response
(mandatory argument).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_pred">pred</code></td>
<td>
<p>a numeric vector with predictions for the response (mandatory
argument).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_se.pred">se.pred</code></td>
<td>
<p>a numeric vector with prediction standard errors
(mandatory argument).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_statistic">statistic</code></td>
<td>
<p>a character keyword defining what statistic of the
prediction errors should be computed.
Possible values are (see <em>Details</em>):
</p>

<ul>
<li> <p><code>"crps"</code>: continuous ranked probability score (default),
</p>
</li>
<li> <p><code>"pit"</code>: probability integral transform,
</p>
</li>
<li> <p><code>"mc"</code>: average predictive distribution (marginal
calibration),
</p>
</li>
<li> <p><code>"bs"</code>: Brier score,
</p>
</li>
<li> <p><code>"st"</code>: mean and dispersion statistics of (standardized)
prediction errors.
</p>
</li></ul>

</td></tr>
<tr><td><code id="validate.predictions_+3A_ncutoff">ncutoff</code></td>
<td>
<p>a positive integer (<code class="reqn">N</code>) giving the number of quantiles,
for which CDFs are evaluated (<code>type = "mc"</code>), or the number of
thresholds for which the Brier score is computed (<code>type = "bs"</code>),
see <em>Details</em> (default: <code>min(500, length(data))</code>).</p>
</td></tr>

















<tr><td><code id="validate.predictions_+3A_x">x</code>, <code id="validate.predictions_+3A_object">object</code></td>
<td>
<p>objects of class <code>cv.georob</code>.</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating the number of decimal digits to print.</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_type">type</code></td>
<td>
<p>a character keyword defining what type of plot is created by the
<code>plot.cv.georob</code>.  Possible values are:
</p>

<ul>
<li> <p><code>"sc"</code>: a scatter-plot of the (possibly log-transformed) response
vs.  the respective predictions (default).
</p>
</li>
<li> <p><code>"lgn.sc"</code>: a scatter-plot of the untransformed response
against back-<br /> transformed predictions of the log-transformed response.
</p>
</li>
<li> <p><code>"ta"</code>: Tukey-Anscombe plot (plot of standardized prediction
errors vs. predictions).
</p>
</li>
<li> <p><code>"qq"</code>: normal QQ plot of standardized prediction errors.
</p>
</li>
<li> <p><code>"hist.pit"</code>: histogram of probability integral transform, see
<em>Details</em>.
</p>
</li>
<li> <p><code>"ecdf.pit"</code>: empirical CDF of probability integral
transform, see <em>Details</em>.
</p>
</li>
<li> <p><code>"mc"</code>: a marginal calibration plot, see <em>Details</em>,
</p>
</li>
<li> <p><code>"bs"</code>: a plot of Brier score vs. threshold, see
<em>Details</em>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="validate.predictions_+3A_smooth">smooth</code></td>
<td>
<p>a logical scalar controlling whether scatter plots of data
vs.  predictions should be smoothed by
<code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_span">span</code></td>
<td>
<p>a numeric with the smoothness parameter for loess (see
<code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code>).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_add">add</code></td>
<td>
<p>a logical scalar controlling whether the current high-level plot is
added to an existing graphics without cleaning the frame before (default:
<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_main">main</code>, <code id="validate.predictions_+3A_xlab">xlab</code>, <code id="validate.predictions_+3A_ylab">ylab</code></td>
<td>
<p>title and axes labels of plot.</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_col">col</code>, <code id="validate.predictions_+3A_pch">pch</code>, <code id="validate.predictions_+3A_lty">lty</code></td>
<td>
<p>color, symbol and line type.</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_se">se</code></td>
<td>
<p>a logical scalar controlling if the standard errors of the
averaged continuous ranked probability score and of the mean and
dispersion statistics of the prediction errors (see <em>Details</em>) are
computed from the respective values of the <code class="reqn">K</code>
cross-validation subsets (default: <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="validate.predictions_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>validate.predictions</code> computes the items required to evaluate (and
plot) the diagnostic criteria proposed by <cite>Gneiting et al. (2007)</cite> for
assessing the <em>calibration</em> and the <em>sharpness</em> of
probabilistic predictions of (cross-)validation data.  To this aim,
<code>validate.predictions</code> uses the assumption that the prediction
errors
<code class="reqn">Y(\boldsymbol{s})-\widehat{Y}(\boldsymbol{s})</code>
follow normal distributions with zero mean and standard deviations equal
to the Kriging standard errors.  This assumption is an approximation if
the errors <code class="reqn">\varepsilon</code> come from a long-tailed
distribution.  Furthermore, for the time being, the Kriging variance of
the <em>response</em> <code class="reqn">Y</code> is approximated by adding the estimated
nugget <code class="reqn">\widehat{\tau}^2</code> to the Kriging variance of the
signal <code class="reqn">Z</code>.  This approximation likely underestimates the mean
squared prediction error of the response if the errors come from a
long-tailed distribution.  Hence, for robust Kriging, the standard errors of
the (cross-)validation errors are likely too small.
</p>
<p>Notwithstanding these difficulties and imperfections, <code>validate.predictions</code> computes
</p>

<ul>
<li><p> the <em>probability integral transform</em> (PIT),
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{PIT}_i = F_i(y_i),</code>
</p>

<p>where <code class="reqn">F_i(y_i)</code> denotes the (plug-in) predictive CDF evaluated at
<code class="reqn">y_i</code>, the value of the <code class="reqn">i</code>th (cross-)validation datum,
</p>
</li>
<li><p> the <em>average predictive CDF</em> (plug-in)
</p>
<p style="text-align: center;"><code class="reqn">\bar{F}_n(y)=1/n \sum_{i=1}^n F_i(y),</code>
</p>

<p>where <code class="reqn">n</code> is the number of (cross-)validation observations and the
<code class="reqn">F_i</code> are evaluated at <code class="reqn">N</code> quantiles equal to the set of
distinct <code class="reqn">y_i</code> (or a subset of size <code class="reqn">N</code> of them),
</p>
</li>
<li><p> the <em>Brier Score</em> (plug-in)
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{BS}(y) = 1/n \sum_{i=1}^n \left(F_i(y) - I(y_i \leq y) \right)^2,</code>
</p>

<p>where <code class="reqn">I(x)</code> is the indicator function for the event <code class="reqn">x</code>, and
the Brier score is again evaluated at the unique values of the (cross-)validation
observations (or a subset of size <code class="reqn">N</code> of them),
</p>
</li>
<li><p> the <em>averaged continuous ranked probability score</em>, CRPS, a
strictly proper scoring criterion to rank predictions, which is related
to the Brier score by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{CRPS} = \int_{-\infty}^\infty \mathrm{BS}(y) \,dy.</code>
</p>

</li></ul>

<p><cite>Gneiting et al. (2007)</cite> proposed the following plots to validate
probabilistic predictions:
</p>

<ul>
<li><p> A histogram (or a plot of the empirical CDF) of the PIT values.
For ideal predictions, with observed coverages of prediction intervals
matching nominal coverages, the PIT values have an uniform
distribution.
</p>
</li>
<li><p> Plots of <code class="reqn">\bar{F}_n(y)</code> and of the empirical CDF of
the data, say <code class="reqn">\widehat{G}_n(y)</code>, and of their
difference, <code class="reqn">\bar{F}_n(y)-\widehat{G}_n(y)</code>
vs <code class="reqn">y</code>.  The forecasts are said to be <em>marginally calibrated</em>
if <code class="reqn">\bar{F}_n(y)</code> and <code class="reqn">\widehat{G}_n(y)</code>
match.
</p>
</li>
<li><p> A plot of <code class="reqn">\mathrm{BS}(y)</code> vs.  <code class="reqn">y</code>.  Probabilistic
predictions are said to be <em>sharp</em> if the area under this curve,
which equals CRPS, is minimized.
</p>
</li></ul>

<p>The <code>plot</code> method for class <code>cv.georob</code> allows to create
these plots, along with scatter-plots of observations and predictions,
Tukey-Anscombe and normal QQ plots of the standardized prediction
errors.
</p>
<p><code>summary.cv.georob</code> computes the mean and dispersion statistics
of the (standardized) prediction errors (by a call to
<code>validate.prediction</code> with argument <code>statistic = "st"</code>, see
<em>Value</em>) and the averaged continuous ranked probability score
(<code>crps</code>).  If present in the <code>cv.georob</code> object, the error
statistics are also computed for the errors of the unbiasedly
back-transformed predictions of a log-transformed response.  If <code>se</code>
is <code>TRUE</code> then these statistics are evaluated separately for the
<code class="reqn">K</code> cross-validation subsets and the standard errors of the means of
these statistics are returned as well.
</p>
<p>The <code>print</code> method for class <code>cv.georob</code> returns the mean
and dispersion statistics of the (standardized) prediction errors.
</p>


<h3>Value</h3>

<p>Depending on the argument <code>statistic</code>, the function
<code>validate.predictions</code> returns
</p>

<ul>
<li><p> a numeric vector of PIT values if <code>statistic</code> is equal to <code>"pit"</code>,
</p>
</li>
<li><p> a named numeric vector with summary statistics of the
(standardized) prediction errors if <code>statistic</code> is equal to <code>"st"</code>.  The
following statistics are computed:
</p>

<table>
<tr>
 <td style="text-align: right;">
      <code>me</code>     </td><td style="text-align: left;"> mean prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>mede</code>   </td><td style="text-align: left;"> median prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>rmse</code>   </td><td style="text-align: left;"> root mean squared prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>made</code>   </td><td style="text-align: left;"> median absolute prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>qne</code>    </td><td style="text-align: left;"> Qn dispersion measure of prediction errors
      (see <code><a href="robustbase.html#topic+Qn">Qn</a></code>) </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>msse</code>   </td><td style="text-align: left;"> mean squared standardized prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>medsse</code> </td><td style="text-align: left;"> median squared standardized prediction error </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>

</li>
<li><p> a data frame if <code>statistic</code> is equal to <code>"mc"</code> or
<code>"bs"</code> with the components (see <em>Details</em>):
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>z</code> </td><td style="text-align: left;"> the sorted unique (cross-)validation
      observations (or a subset of size
    <code>ncutoff</code> of them)</td>
</tr>
<tr>
 <td style="text-align: right;">
      <code>ghat</code> </td><td style="text-align: left;"> the empirical CDF of the (cross-)validation
      observations <code class="reqn">\widehat{G}_n(y)</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>fbar</code> </td><td style="text-align: left;">  the average predictive distribution <code class="reqn">\bar{F}_n(y)</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>bs</code> </td><td style="text-align: left;"> the Brier score <code class="reqn">\mathrm{BS}(y)</code></td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

</li></ul>

<p>The method <code>print.cv.georob</code> invisibly returns the object unchanged.
</p>
<p>The method <code>summary.cv.georob</code> returns an object of class
<code>summary.cv.georob</code> which is a list with 3 components:
</p>

<ul>
<li> <p><code>st</code> a numeric vector with summary statistics of the
(standardized) prediction errors of the possibly log-transformed
response, see output of function <code>validate.predictions</code> for
argument <code>statistic = "st"</code> above.
</p>
</li>
<li> <p><code>crps</code> the value of the continuous ranked probability score.
</p>
</li>
<li> <p><code>st.lgn</code> a numeric vector with summary statistics of the
(standardized) prediction errors of the back-transformed response if
argument <code>lgn = TRUE</code> and <code>NULL</code> otherwise.
</p>
</li></ul>

<p>There is a <code>print</code> method for objects of class <code>summary.cv.georob</code>
which invisibly returns the object unchanged.
</p>
<p>The method <code>plot.georob</code> is called for its side effects and
invisibly returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Papritz <a href="mailto:papritz@retired.ethz.ch">papritz@retired.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Gneiting, T., Balabdaoui, F. and Raftery, A. E.(2007) Probabilistic
forecasts, calibration and sharpness.  <em>Journal of the Royal
Statistical Society Series B</em> <b>69</b>, 243&ndash;268,<br />
<a href="https://doi.org/10.1111/j.1467-9868.2007.00587.x">doi:10.1111/j.1467-9868.2007.00587.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+georob">georob</a></code> for (robust) fitting of spatial linear models;
</p>
<p><code><a href="#topic+cv.georob">cv.georob</a></code> for assessing the goodness of a fit by <code>georob</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define number of cores for parallel computations
if(interactive()) ncpu &lt;- 10L else ncpu &lt;- 1L

data(meuse)

r.logzn &lt;- georob(log(zinc) ~ sqrt(dist), data = meuse, locations = ~ x + y,
  variogram.model = "RMexp",
  param = c(variance = 0.15, nugget = 0.05, scale = 200),
  tuning.psi = 1000)

if(interactive()){
  ## example is run only in interactive session because cpu times exceeds 5 s
  r.logzn.cv.1 &lt;- cv(r.logzn, seed = 1, lgn = TRUE, ncores = 1, verbose = 1)

  r.logzn.cv.2 &lt;- cv(r.logzn, formula = .~. + ffreq, seed = 1, lgn = TRUE,
      ncores = ncpu)

  summary(r.logzn.cv.1, se = TRUE)
  summary(r.logzn.cv.2, se = TRUE)

  op &lt;- par(mfrow = c(2,2))
  plot(r.logzn.cv.1, type = "lgn.sc")
  plot(r.logzn.cv.2, type = "lgn.sc", add = TRUE, col = "red")
  abline(0, 1, lty= "dotted")
  plot(r.logzn.cv.1, type = "ta")
  plot(r.logzn.cv.2, type = "ta", add = TRUE, col = "red")
  abline(h=0, lty= "dotted")
  plot(r.logzn.cv.2, type = "mc", col = "red")
  plot(r.logzn.cv.1, type = "bs")
  plot(r.logzn.cv.2, type = "bs", add = TRUE, col = "red")
  legend("topright", lty = 1, col = c("black", "red"), bty = "n",
      legend = c("log(Zn) ~ sqrt(dist)", "log(Zn) ~ sqrt(dist) + ffreq"))
  par(op)
}
</code></pre>

<hr>
<h2 id='wolfcamp'>Wolfcamp Aquifer Data</h2><span id='topic+wolfcamp'></span>

<h3>Description</h3>

<p>Piezometric head measurements taken at the Wolfcamp Aquifer, Texas, USA.
See <cite>Cressie (1993, p. 212&ndash;214)</cite> for description of the scientific
problem and the data.  Original data were converted to SI units:
coordinates are given in kilometers and pressure heads in meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wolfcamp)</code></pre>


<h3>Format</h3>

<p>A data frame with 85 observations on the following 3 variables:
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector with the easting coordinate in
kilometers.</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector with the northing coordinate in
kilometers.</p>
</dd>
<dt><code>pressure</code></dt><dd><p>a numeric vector with the piezometric head in
meters.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data were imported from the package <span class="pkg">geoR</span>.
</p>


<h3>Source</h3>

<p>Harper, W.V. and Furr, J.M. (1986) Geostatistical analysis of
potentiometric data in the Wolfcamp Aquifer of the Palo Duro Basin,
Texas.  <em>Technical Report BMI/ONWI-587, Bettelle Memorial Institute,
Columbus, OH</em>.
</p>


<h3>References</h3>

<p>Cressie, N. A. C. (1993) <em>Statistics for Spatial Data</em>, Wiley, New
York, <a href="https://doi.org/10.1002/9781119115151">doi:10.1002/9781119115151</a>.
</p>
<p>Papritz, A. and Moyeed, R. (2001) Parameter uncertainty in spatial
prediction: checking its importance by cross-validating the Wolfcamp
and Rongelap data sets, <em>GeoENV 2000: Geostatistical for
Environmental Applications</em>. Eds P. Monestiez, D. Allard,
R. Froidevaux. Kluwer, <a href="https://doi.org/10.1007/978-94-010-0810-5">doi:10.1007/978-94-010-0810-5</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wolfcamp)
summary(wolfcamp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
