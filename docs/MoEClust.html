<!DOCTYPE html><html lang="en"><head><title>Help for package MoEClust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MoEClust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MoEClust-package'><p>MoEClust: Gaussian Parsimonious Clustering Models with Covariates and a Noise Component</p></a></li>
<li><a href='#ais'><p>Australian Institute of Sport data</p></a></li>
<li><a href='#aitken'><p>Aitken Acceleration</p></a></li>
<li><a href='#as.Mclust'><p>Convert MoEClust objects to the Mclust class</p></a></li>
<li><a href='#CO2data'><p>GNP and CO2 Data Set</p></a></li>
<li><a href='#drop_constants'><p>Drop constant variables from a formula</p></a></li>
<li><a href='#drop_levels'><p>Drop unused factor levels to predict from unseen data</p></a></li>
<li><a href='#expert_covar'><p>Account for extra variability in covariance matrices with expert covariates</p></a></li>
<li><a href='#FARI'><p>Compute the Frobenius (adjusted) Rand index</p></a></li>
<li><a href='#force_posiDiag'><p>Force diagonal elements of a triangular matrix to be positive</p></a></li>
<li><a href='#MoE_AvePP'><p>Average posterior probabilities of a fitted MoEClust model</p></a></li>
<li><a href='#MoE_clust'><p>MoEClust: Gaussian Parsimonious Clustering Models with Covariates and a Noise Component</p></a></li>
<li><a href='#MoE_compare'><p>Choose the best MoEClust model</p></a></li>
<li><a href='#MoE_control'><p>Set control values for use with MoEClust</p></a></li>
<li><a href='#MoE_crit'><p>MoEClust BIC, ICL, and AIC Model-Selection Criteria</p></a></li>
<li><a href='#MoE_cstep'><p>C-step for MoEClust Models</p></a></li>
<li><a href='#MoE_dens'><p>Density for MoEClust Mixture Models</p></a></li>
<li><a href='#MoE_entropy'><p>Entropy of a fitted MoEClust model</p></a></li>
<li><a href='#MoE_estep'><p>E-step for MoEClust Models</p></a></li>
<li><a href='#MoE_gpairs'><p>Generalised Pairs Plots for MoEClust Mixture Models</p></a></li>
<li><a href='#MoE_mahala'><p>Mahalanobis Distance Outlier Detection for Multivariate Response</p></a></li>
<li><a href='#MoE_news'><p>Show the NEWS file</p></a></li>
<li><a href='#MoE_plotCrit'><p>Model Selection Criteria Plot for MoEClust Mixture Models</p></a></li>
<li><a href='#MoE_plotGate'><p>Plot MoEClust Gating Network</p></a></li>
<li><a href='#MoE_plotLogLik'><p>Plot the Log-Likelihood of a MoEClust Mixture Model</p></a></li>
<li><a href='#MoE_Similarity'><p>Plot the Similarity Matrix of a MoEClust Mixture Model</p></a></li>
<li><a href='#MoE_stepwise'><p>Stepwise model/variable selection for MoEClust models</p></a></li>
<li><a href='#MoE_Uncertainty'><p>Plot Clustering Uncertainties</p></a></li>
<li><a href='#noise_vol'><p>Approximate Hypervolume Estimate</p></a></li>
<li><a href='#plot.MoEClust'><p>Plot MoEClust Results</p></a></li>
<li><a href='#predict.MoE_expert'><p>Predictions from MoEClust expert networks</p></a></li>
<li><a href='#predict.MoE_gating'><p>Predictions from MoEClust gating networks</p></a></li>
<li><a href='#predict.MoEClust'><p>Predictions for MoEClust models</p></a></li>
<li><a href='#quant_clust'><p>Quantile-Based Clustering for Univariate Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Parsimonious Clustering Models with Covariates and a
Noise Component</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustering via parsimonious Gaussian Mixtures of Experts using the MoEClust models introduced by Murphy and Murphy (2020) &lt;<a href="https://doi.org/10.1007%2Fs11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;. This package fits finite Gaussian mixture models with a formula interface for supplying gating and/or expert network covariates using a range of parsimonious covariance parameterisations from the GPCM family via the EM/CEM algorithm. Visualisation of the results of such models using generalised pairs plots and the inclusion of an additional noise component is also facilitated. A greedy forward stepwise search algorithm is provided for identifying the optimal model in terms of the number of components, the GPCM covariance parameterisation, and the subsets of gating/expert network covariates.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=MoEClust">https://cran.r-project.org/package=MoEClust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Keefe-Murphy/MoEClust/issues">https://github.com/Keefe-Murphy/MoEClust/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice (&ge; 0.12), matrixStats (&ge; 1.0.0), mclust (&ge; 6.1),
mvnfast, nnet (&ge; 7.3-0), vcd</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster (&ge; 1.4.0), clustMD (&ge; 1.2.1), geometry (&ge; 0.4.0),
knitr, rmarkdown, snow</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-05 18:07:59 UTC; Keefe</td>
</tr>
<tr>
<td>Author:</td>
<td>Keefe Murphy <a href="https://orcid.org/0000-0002-7709-3159"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Brendan Murphy
    <a href="https://orcid.org/0000-0002-5668-7046"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keefe Murphy &lt;keefe.murphy@mu.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MoEClust-package'>MoEClust: Gaussian Parsimonious Clustering Models with Covariates and a Noise Component</h2><span id='topic+MoEClust'></span><span id='topic+MoEClust-package'></span>

<h3>Description</h3>

<p>Clustering via parsimonious Gaussian Mixtures of Experts using the <em>MoEClust</em> models introduced by Murphy and Murphy (2020) &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;. This package fits finite Gaussian mixture models with gating and/or expert network covariates using a range of parsimonious covariance parameterisations from the GPCM family via the EM/CEM algorithm. Visualisation of the results of such models using generalised pairs plots and the inclusion of an additional noise component is also facilitated.
</p>


<h3>Details</h3>


<dl>
<dt>Type: </dt><dd><p>Package</p>
</dd>
<dt>Package: </dt><dd><p><span class="pkg">MoEClust</span></p>
</dd>
<dt>Version: </dt><dd><p>1.6.0</p>
</dd>
<dt>Date: </dt><dd><p>2025-03-05 (this version), 2017-11-28 (original release)</p>
</dd>
<dt>Licence: </dt><dd><p>GPL (&gt;= 3)</p>
</dd>
</dl>



<h3>Usage</h3>

<p>The most important function in the <span class="pkg">MoEClust</span> package is: <code><a href="#topic+MoE_clust">MoE_clust</a></code>, for fitting the model via EM/CEM with gating and/or expert network covariates, supplied via formula interfaces.
</p>
<p><code><a href="#topic+MoE_compare">MoE_compare</a></code> is provided for conducting model selection between different results from <code><a href="#topic+MoE_clust">MoE_clust</a></code> using different covariate combinations &amp;/or initialisation strategies, etc.
</p>
<p><code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code> is provided for conducting a greedy forward stepwise search to identify the optimal model in terms of the number of components, GPCM covariance type, and the subsets of gating/expert network covariates.
</p>
<p><code><a href="#topic+MoE_control">MoE_control</a></code> allows supplying additional arguments to <code><a href="#topic+MoE_clust">MoE_clust</a></code> and <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code> which govern, among other things, controls on the inclusion of an additional noise component and controls on the initialisation of the allocations for the EM/CEM algorithm.
</p>
<p>A dedicated plotting function (<code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>) exists for visualising the results using generalised pairs plots, for examining the gating network, and/or log-likelihood, and/or clustering uncertainties, and/or similarity matrix, and/or graphing model selection criteria values. The generalised pairs plots (<code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>) visualise all pairwise relationships between clustered response variables and associated continuous, categorical, and/or ordinal covariates in the gating &amp;/or expert networks, coloured according to the MAP classification, and also give the marginal distributions of each variable (incl. the covariates) along the diagonal.
</p>
<p>An <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code> method is provided to coerce the output of class <code>"MoEClust"</code> from <code><a href="#topic+MoE_clust">MoE_clust</a></code> to the <code>"Mclust"</code> class, to facilitate use of plotting and other functions for the <code>"Mclust"</code> class within the <span class="pkg">mclust</span> package. As per <span class="pkg">mclust</span>, <span class="pkg">MoEClust</span> also facilitates modelling with an additional noise component (with or without the mixing proportion for the noise component depending on covariates).
</p>
<p>Finally, a <code><a href="#topic+predict.MoEClust">predict</a></code> method is provided for predicting the fitted response and probability of cluster membership (and by extension the MAP classification) for new data, in the form of new covariates and new response data, or new covariates only.
</p>
<p>Other functions also exist, e.g. <code><a href="#topic+MoE_crit">MoE_crit</a></code>, <code><a href="#topic+MoE_dens">MoE_dens</a></code>, <code><a href="#topic+MoE_estep">MoE_estep</a></code>, <code><a href="#topic+MoE_compare">MoE_compare</a></code>, and <code><a href="#topic+aitken">aitken</a></code>, which are all used within <code><a href="#topic+MoE_clust">MoE_clust</a></code> but are nonetheless made available for standalone use. 
</p>
<p>The package also contains two data sets: <code>ais</code> and <code>CO2data</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy [aut, cre], Thomas Brendan Murphy [ctb]
</p>
<p><strong>Maintainer</strong>: Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://cran.r-project.org/package=MoEClust">https://cran.r-project.org/package=MoEClust</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Keefe-Murphy/MoEClust">https://github.com/Keefe-Murphy/MoEClust</a>
</p>
</li></ul>

<p>Further details and examples are given in the associated vignette document:
</p>
<pre>vignette("MoEClust", package = "MoEClust")</pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)

# Fit two sets of models
res1  &lt;- MoE_clust(ais[,3:7], G=2, gating= ~ BMI, expert= ~ sex,
                   modelNames=c("VEE", "EVE", "VVE"), network.data=ais)
res2  &lt;- MoE_clust(ais[,3:7], G=2, equalPro=TRUE, expert= ~ sex,
                   modelNames=c("VEE", "EVE", "VVE"), network.data=ais) 
        
# Compare the best model from each set of results
(comp &lt;- MoE_compare(res1, res2, optimal.only=TRUE))

# Produce a plot for the optimal model                                                   
plot(comp$optimal, what="gpairs", show.dens=TRUE)

# Summarise its classification table, component parameters, and gating/expert networks
summary(comp$optimal, classification=TRUE, parameters=TRUE, networks=TRUE)

data(CO2data)
CO2   &lt;- CO2data$CO2
GNP   &lt;- CO2data$GNP

# Fit a range of models 
m1    &lt;- MoE_clust(CO2, G=1:3)
m2    &lt;- MoE_clust(CO2, G=2:3, gating= ~ GNP)
m3    &lt;- MoE_clust(CO2, G=1:3, expert= ~ GNP)
m4    &lt;- MoE_clust(CO2, G=2:3, gating= ~ GNP, expert= ~ GNP)
m5    &lt;- MoE_clust(CO2, G=2:3, equalPro=TRUE)
m6    &lt;- MoE_clust(CO2, G=2:3, expert= ~ GNP, equalPro=TRUE)

# Extract the model with highest BIC
(comp &lt;- MoE_compare(m1, m2, m3, m4, m5, m6, criterion="bic"))
 
# See if a better model can be found using greedy forward stepwise selection
# Conduct a stepwise search on the same data
(mod1 &lt;- MoE_stepwise(CO2, CO2data[,"GNP", drop=FALSE]))

# Conduct another stepwise search considering models with a noise component
(mod2 &lt;- MoE_stepwise(CO2, CO2data[,"GNP", drop=FALSE], noise=TRUE))

# Compare all sets of results to choose the optimal model
(best &lt;- MoE_compare(mod1, mod2, comp, pick=1)$optimal)
</code></pre>

<hr>
<h2 id='ais'>Australian Institute of Sport data</h2><span id='topic+ais'></span>

<h3>Description</h3>

<p>Data on 102 male and 100 female athletes collected at the Australian Institute of Sport, courtesy of Richard Telford and Ross Cunningham.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ais)
</code></pre>


<h3>Format</h3>

<p>A data frame with 202 observations on the following 13 variables:
</p>

<dl>
<dt><code>sex</code></dt><dd><p>categorical, levels = <code>female, male</code></p>
</dd>
<dt><code>sport</code></dt><dd><p>categorical, levels = <code>B_Ball, Field, Gym, Netball, Row, Swim, T_400m, Tennis, T_Sprnt, W_Polo</code></p>
</dd>
<dt><code>RCC</code></dt><dd><p>red cell count (numeric)</p>
</dd>
<dt><code>WCC</code></dt><dd><p>white cell count (numeric)</p>
</dd>
<dt><code>Hc</code></dt><dd><p>Hematocrit (numeric)</p>
</dd>
<dt><code>Hg</code></dt><dd><p>Hemoglobin (numeric)</p>
</dd>
<dt><code>Fe</code></dt><dd><p>plasma ferritin concentration (numeric)</p>
</dd>
<dt><code>BMI</code></dt><dd><p>body mass index: <code>Wt/(Ht)^2</code> (numeric)</p>
</dd>
<dt><code>SSF</code></dt><dd><p>sum of skin folds (numeric)</p>
</dd>
<dt><code>Bfat</code></dt><dd><p>body fat percentage (numeric)</p>
</dd>
<dt><code>LBM</code></dt><dd><p>lean body mass (numeric)</p>
</dd>
<dt><code>Ht</code></dt><dd><p>height, cm (numeric)</p>
</dd>
<dt><code>Wt</code></dt><dd><p>weight, kg (numeric)</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data have been made publicly available in connection with the book by Cook and Weisberg (1994).
</p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1994), <em>An Introduction to Regression Graphics</em>. Volume 405 of <em>Wiley Series in Probability and Statistics</em>, New York, NY, USA: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais, package="MoEClust")
pairs(ais[,c(3:7)], col=as.numeric(ais$sex), main = "AIS data")
apply(ais[,c(3:7)], 2, summary)
</code></pre>

<hr>
<h2 id='aitken'>Aitken Acceleration</h2><span id='topic+aitken'></span>

<h3>Description</h3>

<p>Calculates the Aitken acceleration estimate of the final converged maximised log-likelihood under the EM/CEM framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aitken(loglik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aitken_+3A_loglik">loglik</code></td>
<td>
<p>A vector of three consecutive log-likelihood values. These three values should be in ascending order, though this is not checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The final converged maximised log-likelihood can be used to determine convergence of the EM/CEM algorithm within <code><a href="#topic+MoE_clust">MoE_clust</a></code>, i.e. by checking whether the absolute difference between the previous log-likelihood estimate and the final converged maximised log-likelihood estimate is less than some tolerance.
</p>


<h3>Value</h3>

<p>A list with the following named components:
</p>
<table role = "presentation">
<tr><td><code>ll</code></td>
<td>
<p>The most current estimate of the log-likelihood, i.e. <code>loglik[3]</code>.</p>
</td></tr>
<tr><td><code>linf</code></td>
<td>
<p>The most current estimate of the final converged maximised log-likelihood.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The Aitken acceleration value where typically <code>0 &lt;= a &lt;= 1</code>. When <code>a &lt; 0</code>, a numerical issue or bug has occurred; when <code>a &gt; 1</code>, the algorithm is accelerating and should not be stopped.</p>
</td></tr>
<tr><td><code>ldiff</code></td>
<td>
<p>The difference between <code>linf</code> and the <em>previous</em> estimate of the log-likelihood, i.e. <code>loglik[2]</code>, in accordance with McNicholas et al. (2010).</p>
</td></tr>
</table>
<p>When the <code>"aitken"</code> method is employed within <code><a href="#topic+MoE_clust">MoE_clust</a></code> (via <code><a href="#topic+MoE_control">MoE_control</a></code>), <code>ll</code> at convergence gives the log-likelihood achieved by the estimated parameters, while <code>linf</code> at convergence estimates the log-likelihood that would be achieved after an infinite number of EM/CEM iterations.
</p>


<h3>Note</h3>

<p>Within <code><a href="#topic+MoE_clust">MoE_clust</a></code>, as specified by the <code>stopping</code> argument of <code><a href="#topic+MoE_control">MoE_control</a></code>, <code>"aitken"</code> is the default method used to assess convergence. The other option monitors the <code>"relative"</code> change in log-likelihood against some tolerance. See <code><a href="#topic+MoE_control">MoE_control</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Boehning, D., Dietz, E., Schaub, R., Schlattmann, P. and Lindsay, B. G. (1994). The distribution of the likelihood ratio for mixtures of densities from the one-parameter exponential family. <em>Annals of the Institute of Statistical Mathematics</em>, 46(2): 373-388.
</p>
<p>McNicholas, P. D., Murphy, T. B., McDaid, A. F. and Frost, D. (2010). Serial and parallel implementations of model-based clustering via parsimonious Gaussian mixture models. <em>Computational Statistics &amp; Data Analysis</em>, 54(3): 711-723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_control">MoE_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a1 &lt;- aitken(-c(449.61534, 442.84221, 436.58999)))
a1$ldiff &lt; 1e-05 # FALSE
(a2 &lt;- aitken(-c(442.84221, 436.58999, 436.58998)))
a2$ldiff &lt; 1e-05 # FALSE
(a3 &lt;- aitken(-c(436.58999, 436.58998, 436.58998)))
a3$ldiff &lt; 1e-05 # TRUE
</code></pre>

<hr>
<h2 id='as.Mclust'>Convert MoEClust objects to the Mclust class</h2><span id='topic+as.Mclust'></span><span id='topic+as.Mclust.MoEClust'></span>

<h3>Description</h3>

<p>Converts an object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code> and converts it to an object of class <code>"Mclust"</code> as generated by fitting <code><a href="mclust.html#topic+Mclust">Mclust</a></code>, to facilitate use of plotting and other functions for the <code>"Mclust"</code> class within the <span class="pkg">mclust</span> package. Some caution is advised when converting models with gating &amp;/or expert covariates (see Note below) and users are always encouraged to use the dedicated <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> function for objects of the <code>"MoEClust"</code> class instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MoEClust'
as.Mclust(x,
         expert.covar = TRUE,
         signif = 0L,
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.Mclust_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code> or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="as.Mclust_+3A_expert.covar">expert.covar</code></td>
<td>
<p>Logical (defaults to <code>TRUE</code>) governing whether the extra variability in the component means is added to the MVN ellipses corresponding to the component covariance matrices in the presence of expert network covariates. See the function <code><a href="#topic+expert_covar">expert_covar</a></code>.</p>
</td></tr>
<tr><td><code id="as.Mclust_+3A_signif">signif</code></td>
<td>
<p>Significance level for outlier removal. Must be a single number in the interval [0, 1). Corresponds to the percentage of data to be considered extreme and therefore removed (half of <code>signif</code> at each endpoint, on a column-wise basis). The default, <code>0</code>, corresponds to no outlier removal. <strong>Only</strong> invoke this argument as an aid to visualisation via <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code>.</p>
</td></tr>
<tr><td><code id="as.Mclust_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixing proportions are averaged over observations in components in the presence of gating network covariates during the coercion. For models with expert network covariates, the means are given by the posterior means of the fitted values of the expert network.
</p>
<p>In the presence of expert network covariates, the component-specific covariance matrices are (by default, via the argument <code>expert.covar</code>) modified for plotting purposes via the function <code><a href="#topic+expert_covar">expert_covar</a></code>, in order to account for the extra variability of the means, usually resulting in bigger shapes &amp; sizes for the MVN ellipses.
</p>
<p>The <code>signif</code> argument is intended only to aid visualisation via <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code>, as plots therein can be sensitive to outliers, particularly with regard to axis limits. However, users are always encouraged to use the dedicated <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> function for objects of the <code>"MoEClust"</code> class instead (see Note below).
</p>


<h3>Value</h3>

<p>An object of class <code>"Mclust"</code>. See <code>methods(class="Mclust")</code> for a (non-exhaustive) list of functions which can be applied to this class.
</p>


<h3>Note</h3>

<p>Plots may be quite misleading in the presence of gating &amp;/or (especially) expert network covariates when the <code>what</code> argument is <code>"density"</code> within <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code>; users are <strong>strongly</strong> encouraged to use <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> with <code>response.type="density"</code> &amp;/or <code>show.dens=TRUE</code> instead.
</p>
<p>Predictions (via <code><a href="mclust.html#topic+predict.Mclust">predict.Mclust</a></code>) will also be misleading in the presence of covariates of any kind when <code>newdata</code> is supplied; thus, users are <strong>strongly</strong> encouraged to use <code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code> instead. 
</p>
<p>The functions <code><a href="mclust.html#topic+clustCombi">clustCombi</a></code> and <code><a href="mclust.html#topic+clustCombiOptim">clustCombiOptim</a></code> can be safely used (provided <code>as.Mclust(x)</code> is supplied as the <code>object</code> argument to <code><a href="mclust.html#topic+clustCombi">clustCombi</a></code>), as they only rely on <code>x$z</code> and <code>x$G</code> only. See the examples below.
</p>
<p>Users may expect MoEClust models with no covariates of any kind to be identical to models fitted via <span class="pkg">mclust</span>, but this is not necessarily true: see the <code><a href="#topic+MoE_control">MoE_control</a></code> argument <code>asMclust</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Fraley, C. and Raftery, A. E. (2002). Model-based clustering, discriminant analysis, and density estimation. <em>Journal of the American Statistical Association</em>, 97(458): 611-631.
</p>
<p>Scrucca L., Fop M., Murphy T. B. and Raftery A. E. (2016). mclust 5: clustering, classification and density estimation using Gaussian finite mixture models. <em>The R Journal</em>, 8(1): 289-317.
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+Mclust">Mclust</a></code>, <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code>, <code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code>, <code><a href="#topic+expert_covar">expert_covar</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="mclust.html#topic+clustCombi">clustCombi</a></code>, <code><a href="mclust.html#topic+clustCombiOptim">clustCombiOptim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mclust)

# Fit a gating network mixture of experts model to the ais data
data(ais)
mod   &lt;- MoE_clust(ais[,3:7], G=3, gating= ~ BMI + sex, modelNames="EEE", network.data=ais)

# Convert to the "Mclust" class and examine the classification
mod2  &lt;- as.Mclust(mod)
plot(mod2, what="classification")

# Examine the uncertainty
plot(mod2, what="uncertainty")

# Return the optimal number of clusters according to entropy
combi &lt;- mclust::clustCombi(object=mod2)
optim &lt;- mclust::clustCombiOptim(object=combi)
table(mod2$classification, ais$sex)
table(optim$cluster.combi, ais$sex)

# Compare plot.MoEClust and plot.Mclust for univariate mixtures
data(CO2data)
res &lt;- MoE_clust(CO2data$CO2, G=2, expert = ~ GNP, modelNames="V", network.data=CO2data)
plot(as.Mclust(res), what="classification")
plot(as.Mclust(res), what="density")
plot(as.Mclust(res), what="uncertainty") 

# Proper version of what="density" plot:
MoE_gpairs(res, show.map=FALSE, cov.ind=0, show.dens=TRUE)

# Equivalent what="uncertainty" plot:
MoE_Uncertainty(res)
</code></pre>

<hr>
<h2 id='CO2data'>GNP and CO2 Data Set</h2><span id='topic+CO2data'></span>

<h3>Description</h3>

<p>This data set gives the gross national product (GNP) per capita in 1996 for various countries as well as their estimated carbon dioxide (CO2) emission per capita for the same year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CO2data)
</code></pre>


<h3>Format</h3>

<p>This data frame consists of 28 countries and the following variables:
</p>

<dl>
<dt><code>GNP</code></dt><dd><p>The gross product per capita in 1996.</p>
</dd>
<dt><code>CO2</code></dt><dd><p>The estimated carbon dioxide emission per capita in 1996.</p>
</dd>
<dt><code>country</code></dt><dd><p>An abbreviation pertaining to the country measures (e.g. <code>"GRC"</code> = Greece and <code>"CH"</code> = Switzerland).</p>
</dd>
</dl>



<h3>References</h3>

<p>Hurn, M., Justel, A. and Robert, C. P. (2003) Estimating mixtures of regressions, <em>Journal of Computational and Graphical Statistics</em>, 12(1): 55-79.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CO2data, package="MoEClust")
plot(CO2data$GNP, CO2data$CO2, type="n", ylab=expression('CO'[2]))
text(CO2data$GNP, CO2data$CO2, CO2data$country)
</code></pre>

<hr>
<h2 id='drop_constants'>Drop constant variables from a formula</h2><span id='topic+drop_constants'></span>

<h3>Description</h3>

<p>Drops constant variables from the RHS of a formula taking the data set (<code>dat</code>), the formula (<code>formula</code>), and an optional subset vector (<code>sub</code>) as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_constants(dat,
               formula,
               sub = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_constants_+3A_dat">dat</code></td>
<td>
<p>A <code>data.frame</code> where rows correspond to observations and columns correspond to variables. Ideally column names should be present.</p>
</td></tr>
<tr><td><code id="drop_constants_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code>: a symbolic description of the model to be fitted. Variables in the <code>formula</code> not present in the columns of <code>dat</code> will automatically be discarded. The <code>formula</code> may include interactions, transformations, or higher order terms: the latter <strong>must</strong> be specified explicitly using the <code>AsIs</code> operator (<code><a href="base.html#topic+I">I</a></code>).</p>
</td></tr>
<tr><td><code id="drop_constants_+3A_sub">sub</code></td>
<td>
<p>An optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated formula with constant variables removed.
</p>


<h3>Note</h3>

<p>Formulas with and without intercepts are accommodated.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_levels">drop_levels</a></code>, <code><a href="base.html#topic+I">I</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
hema  &lt;- as.matrix(ais[,3:7])
sex   &lt;- ais$sex
BMI   &lt;- ais$BMI

# Set up a no-intercept regression formula with constant column 'sex'
form1 &lt;- as.formula(hema ~ sex + BMI + I(BMI^2) - 1)
sub   &lt;- ais$sex == "male"

# Try fitting a linear model
mod1  &lt;- try(lm(form1, data=ais, subset=sub), silent=TRUE)
inherits(mod1, "try-error") # TRUE

# Remove redundant variables from formula &amp; try again
form2 &lt;- drop_constants(ais, form1, sub)
mod2  &lt;- try(lm(form2, data=ais, subset=sub), silent=TRUE)
inherits(mod2, "try-error") # FALSE
</code></pre>

<hr>
<h2 id='drop_levels'>Drop unused factor levels to predict from unseen data</h2><span id='topic+drop_levels'></span>

<h3>Description</h3>

<p>Drops unseen factor levels in <code>newdata</code> for which predictions are required from a <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="nnet.html#topic+multinom">multinom</a></code> model <code>fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_levels(fit,
            newdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_levels_+3A_fit">fit</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="nnet.html#topic+multinom">multinom</a></code> model.</p>
</td></tr>
<tr><td><code id="drop_levels_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing variables with which to predict.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> like <code>newdata</code> with unseen factor levels replaced by <code>NA</code>.
</p>


<h3>Note</h3>

<p>This function is so far untested for models other than <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="nnet.html#topic+multinom">multinom</a></code>, though it <em>may</em> still work for other classes.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_constants">drop_constants</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
hema  &lt;- as.matrix(ais[,3:7])
BMI   &lt;- ais$BMI
sport &lt;- ais$sport
sub   &lt;- ais$sport != "Row"

# Fit a linear model
mod   &lt;- lm(hema ~ BMI + sport, data=ais, subset=sub)

# Make predictions
pred1 &lt;- try(predict(mod, newdata=ais), silent=TRUE)
inherits(pred1, "try-error") #TRUE

# Remove unused levels and try again
pred2 &lt;- try(predict(mod, newdata=drop_levels(mod, ais)), silent=TRUE)
inherits(pred2, "try-error") #FALSE
anyNA(pred2)                 #TRUE
</code></pre>

<hr>
<h2 id='expert_covar'>Account for extra variability in covariance matrices with expert covariates</h2><span id='topic+expert_covar'></span>

<h3>Description</h3>

<p>In the presence of expert network covariates, this helper function modifies the component-specific covariance matrices of a <code>"MoEClust"</code> object, in order to account for the extra variability due to the component means, usually resulting in bigger shapes &amp; sizes for the MVN ellipses in <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> plots. The function also works for univariate response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expert_covar(x,
             weighted = TRUE,
             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expert_covar_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="expert_covar_+3A_weighted">weighted</code></td>
<td>
<p>A logical indicating whether the estimated cluster membership probabilities should be used to provide a weighted estimate of the variability due to the component means. Defaults to <code>TRUE</code>. The option <code>weighted=FALSE</code> is provided only so that previous behaviour under earlier versions of <span class="pkg">MoEClust</span> can be recovered but is otherwise not recommended.</p>
</td></tr>
<tr><td><code id="expert_covar_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a>(x, what="gpairs")</code>, and <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>, for visualisation purposes.
</p>


<h3>Value</h3>

<p>The <code>variance</code> component only from the <code>parameters</code> list from the output of a call to <code><a href="#topic+MoE_clust">MoE_clust</a></code>, modified accordingly.
</p>


<h3>Note</h3>

<p>The <code>modelName</code> of the resulting <code>variance</code> object may not correspond to the model name of the <code>"MoEClust"</code> object, in particular <code>scale</code>, <code>shape</code>, &amp;/or <code>orientation</code> may no longer be constrained across clusters, and <code>cholsigma</code>, if it was in the input, will be discarded from the output. Usually, the <code>modelName</code> of the transformed <code>variance</code> object will be <code>"VVV"</code> for multivariate data and <code>"V"</code> for univariate data, but not always. Furthermore, the output will drop certain row and column names from the result.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res   &lt;- MoE_clust(ais[,3:7], G=2, gating= ~ 1, expert= ~ sex,
                   network.data=ais, modelNames="EEE", equalPro=TRUE)

# Extract the variance object
res$parameters$variance

# Modify the variance object
expert_covar(res)
</code></pre>

<hr>
<h2 id='FARI'>Compute the Frobenius (adjusted) Rand index</h2><span id='topic+FARI'></span>

<h3>Description</h3>

<p>This function efficiently computes fuzzy generalisations of the Rand and adjusted Rand indices for comparing two partitions, allowing either or both partitions to be &ldquo;soft&rdquo; or &ldquo;hard&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FARI(z1,
     z2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FARI_+3A_z1">z1</code>, <code id="FARI_+3A_z2">z2</code></td>
<td>
<p>A <code class="reqn">n * G</code> matrix representing a hard partition (all entries 0 or 1) or soft cluster-membership probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>z1</code> &amp;/or <code>z2</code> is supplied as a vector of cluster labels, they will be coerced to an appropriate matrix via <code><a href="mclust.html#topic+unmap">unmap</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following named components:
</p>

<dl>
<dt><code>FRI</code></dt><dd><p>Measure of Frobenius Rand index between <code>z1</code> and <code>z2</code>.</p>
</dd>
<dt><code>FARI</code></dt><dd><p>Measure of Frobenius adjusted Rand index between <code>z1</code> and <code>z2</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The number of columns of the matrices <code>z1</code> and <code>z2</code> need not be equal.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Andrew, J. L., Browne, R., and Hvingelby, C. D. (2022). On assessments of agreement between fuzzy partitions. <em>Journal of Classification</em>, 39(2): 326-342.
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+unmap">unmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE",
                gating=~BMI, expert=~sex, network.data=ais)
m2 &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE", 
                equalPro=TRUE, expert=~sex, network.data=ais)
m3 &lt;- MoE_clust(ais[,3:7], G=2, modelNames="VEE", algo="CEM", tau0=0.1)

# FARI between two soft partitions
FARI(m1$z, m2$z)
# FARI between soft and hard partitions
FARI(m1$z, m3$z)
# FARI between soft partition and hard classification
FARI(m1$z, m2$classification)
# FARI between hard partition and hard classification
FARI(m3$z, m3$classification)
# FARI between hard classification and hard classification
FARI(m1$classification, m2$classification)
</code></pre>

<hr>
<h2 id='force_posiDiag'>Force diagonal elements of a triangular matrix to be positive</h2><span id='topic+force_posiDiag'></span>

<h3>Description</h3>

<p>This function ensures that the triangular matrix in a QR (or other) decomposition has positive values along its diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_posiDiag(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force_posiDiag_+3A_x">x</code></td>
<td>
<p>A matrix, which must be either upper-triangular or lower-triangular.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An upper or lower triangular matrix with positive diagonal entries such that the matrix is still a valid decomposition of the matrix the input <code>x</code> is a decomposition of.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], G=3, modelNames="EEE")
sig &lt;- res$parameters$variance
a   &lt;- force_posiDiag(sig$cholSigma)
b   &lt;- chol(sig$Sigma)
all.equal(a, b)                    #TRUE
all.equal(crossprod(a), sig$Sigma) #TRUE
all.equal(crossprod(b), sig$Sigma) #TRUE
</code></pre>

<hr>
<h2 id='MoE_AvePP'>Average posterior probabilities of a fitted MoEClust model</h2><span id='topic+MoE_AvePP'></span>

<h3>Description</h3>

<p>Calculates the per-component average posterior probabilities of a fitted MoEClust model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_AvePP(x,
          group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_AvePP_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with gating and/or expert covariates and/or a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_AvePP_+3A_group">group</code></td>
<td>
<p>A logical indicating whether the average posterior probabilities should be computed <em>per component</em>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>group=TRUE</code>, this function calculates AvePP, the average posterior probabilities of membership for each component for the observations assigned to that component via MAP probabilities. Otherwise, an overall measure of clustering certainty is returned.
</p>


<h3>Value</h3>

<p>When <code>group=TRUE</code>, a named vector of numbers, of length equal to the number of components (G), in the range [1/G,1], such that <em>larger</em> values indicate clearer separation of the clusters. Note that <code>G=x$G</code> for models without a noise component and <code>G=x$G + 1</code> for models with a noise component. When <code>group=FALSE</code>, a single number in the same range is returned.
</p>


<h3>Note</h3>

<p>This function will always return values of <code>1</code> for all components for models fitted using the <code>"CEM"</code> algorithm (see <code><a href="#topic+MoE_control">MoE_control</a></code>), or models with only one component.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="#topic+MoE_entropy">MoE_entropy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], G=3, gating= ~ BMI + sex, 
                 modelNames="EEE", network.data=ais)

# Calculate the AvePP per component
MoE_AvePP(res)

# Calculate an overall measure of clustering certainty
MoE_AvePP(res, group=FALSE)
</code></pre>

<hr>
<h2 id='MoE_clust'>MoEClust: Gaussian Parsimonious Clustering Models with Covariates and a Noise Component</h2><span id='topic+MoE_clust'></span><span id='topic+print.MoEClust'></span><span id='topic+summary.MoEClust'></span>

<h3>Description</h3>

<p>Fits MoEClust models: Gaussian Mixture of Experts models with GPCM/<span class="pkg">mclust</span>-family covariance structures. In other words, performs model-based clustering via the EM/CEM algorithm where covariates are allowed to enter neither, either, or both the mixing proportions (gating network) and/or component densities (expert network) of a Gaussian Parsimonious Clustering Model, with or without an additional noise component. Additional arguments are available via the function <code><a href="#topic+MoE_control">MoE_control</a></code>, including the specification of a noise component, controls on the initialisation of the algorithm, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_clust(data,
          G = 1:9,
          modelNames = NULL,
          gating = ~1,
          expert = ~1,
          control = MoE_control(...),
          network.data = NULL,
          ...)

## S3 method for class 'MoEClust'
print(x,
      digits = 3L,
      ...)

## S3 method for class 'MoEClust'
summary(object,
        classification = TRUE,
        parameters = FALSE,
        networks = FALSE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_clust_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. Categorical variables are not allowed. If a matrix or data frame, rows correspond to observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_g">G</code></td>
<td>
<p>An integer vector specifying the number(s) of mixture components (clusters) to fit. Defaults to <code>G=1:9</code>. Must be a strictly positive integer, unless a noise component is included in the estimation, in which case <code>G=0</code> is allowed and <em>also</em> included by default. (see <code><a href="#topic+MoE_control">MoE_control</a></code>).</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_modelnames">modelNames</code></td>
<td>
<p>A vector of character strings indicating the models to be fitted in the EM/CEM phase of clustering. With <code>n</code> observations and <code>d</code> variables, the defaults are:
</p>

<table>
<tr>
 <td style="text-align: left;">
for univariate data </td><td style="text-align: left;"> <code>c("E", "V")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
for multivariate data <code class="reqn">n &gt; d</code> </td><td style="text-align: left;"> <code>mclust.options("emModelNames")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
for high-dimensional multivariate data <code class="reqn">n \leq d</code> </td><td style="text-align: left;"> <code>c("EII", "VII", "EEI", "EVI", "VEI", "VVI")</code>
</td>
</tr>

</table>

<p>For single-component models these options reduce to:
</p>

<table>
<tr>
 <td style="text-align: left;">
for univariate data </td><td style="text-align: left;"> <code>"E"</code></td>
</tr>
<tr>
 <td style="text-align: left;">
for multivariate data <code class="reqn">n &gt; d</code> </td><td style="text-align: left;"> <code>c("EII", "EEI", "EEE")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
for high-dimensional multivariate data <code class="reqn">n \leq d</code>  </td><td style="text-align: left;"> <code>c("EII", "EEI")</code>
</td>
</tr>

</table>

<p>For zero-component models with a noise component only the <code>"E"</code> and <code>"EII"</code> models will be fitted for univariate and multivariate data, respectively, although this is clearly for naming consistency only. The help file for <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code> further describes the available models (though the <code>"X"</code> in the single-component models will be coerced to <code>"E"</code> if supplied that way). For single-component models, other model names equivalent to those above can be supplied, but will be coerced to those above.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_gating">gating</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> for determining the model matrix for the multinomial logistic regression in the gating network when fixed covariates enter the mixing proportions. Defaults to <code>~1</code>, i.e. no covariates. This will be ignored where <code>G=1</code>. Continuous, categorical, and/or ordinal covariates are allowed. Logical covariates will be coerced to factors. Interactions, transformations, and higher order terms are permitted: the latter <strong>must</strong> be specified explicitly using the <code>AsIs</code> operator (<code><a href="base.html#topic+I">I</a></code>). The specification of the LHS of the formula is ignored. Intercept terms are included by default.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_expert">expert</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> for determining the model matrix for the (multivariate) WLS in the expert network when fixed covariates are included in the component densities. Defaults to <code>~1</code>, i.e. no covariates. Continuous, categorical, and/or ordinal covariates are allowed. Logical covariates will be coerced to factors. Interactions, transformations, and higher order terms are permitted: the latter <strong>must</strong> be specified explicitly using the <code>AsIs</code> operator (<code><a href="base.html#topic+I">I</a></code>). The specification of the LHS of the formula is ignored. Intercept terms are included by default.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the EM/CEM and other aspects of the algorithm. The defaults are set by a call to <code><a href="#topic+MoE_control">MoE_control</a></code>. In particular, arguments pertaining to the inclusion of an additional noise component are documented here.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_network.data">network.data</code></td>
<td>
<p>An optional data frame (or a matrix with named columns) in which to look for the covariates in the <code>gating</code> &amp;/or <code>expert</code> network formulas, if any. If not found in <code>network.data</code>, any supplied <code>gating</code> &amp;/or <code>expert</code> covariates are taken from the environment from which <code>MoE_clust</code> is called. Try to ensure the names of variables in <code>network.data</code> do not match any of those in <code>data</code>.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_...">...</code></td>
<td>
<p>An alternative means of passing control parameters directly via the named arguments of <code><a href="#topic+MoE_control">MoE_control</a></code>. Do not pass the output from a call to <code><a href="#topic+MoE_control">MoE_control</a></code> here! This argument is only relevant for the <code><a href="#topic+MoE_clust">MoE_clust</a></code> function and will be ignored for the associated <code>print</code> and <code>summary</code> functions.</p>
</td></tr>
<tr><td><code id="MoE_clust_+3A_x">x</code>, <code id="MoE_clust_+3A_object">object</code>, <code id="MoE_clust_+3A_digits">digits</code>, <code id="MoE_clust_+3A_classification">classification</code>, <code id="MoE_clust_+3A_parameters">parameters</code>, <code id="MoE_clust_+3A_networks">networks</code></td>
<td>
<p>Arguments required for the <code>print</code> and <code>summary</code> functions: <code>x</code> and <code>object</code> are objects of class <code>"MoEClust"</code> resulting from a call to <code><a href="#topic+MoE_clust">MoE_clust</a></code>, while <code>digits</code> gives the number of decimal places to round to for printing purposes (defaults to <code>3</code>). <code>classification</code>, <code>parameters</code>, and <code>networks</code> are logicals which govern whether a table of the MAP classification of observations, the mixture component parameters, and the gating/expert network coefficients are printed, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function effectively allows 6 different types of Gaussian Mixture of Experts model (as well as the different models in the GPCM/<span class="pkg">mclust</span> family, for each): i) the standard finite Gaussian mixture with no covariates, ii) fixed covariates only in the gating network, iii) fixed covariates only in the expert network, iv) the full Mixture of Experts model with fixed covariates entering both the mixing proportions and component densities. By constraining the mixing proportions to be equal (see <code>equalPro</code> in <code><a href="#topic+MoE_control">MoE_control</a></code>) two extra special cases are facilitated when gating covariates are excluded. 
</p>
<p>Note that having the same covariates in both networks is allowed. So too are interactions, transformations, and higher order terms (see <code><a href="stats.html#topic+formula">formula</a></code>): the latter <strong>must</strong> be specified explicitly using the <code>AsIs</code> operator (<code><a href="base.html#topic+I">I</a></code>). Covariates can be continuous, categorical, logical, or ordinal, but the response must always be continuous.
</p>
<p>While model selection in terms of choosing the optimal number of components and the GPCM/<span class="pkg">mclust</span> model type is performed within <code><a href="#topic+MoE_clust">MoE_clust</a></code>, using one of the <code>criterion</code> options within <code><a href="#topic+MoE_control">MoE_control</a></code>, choosing between multiple fits with different combinations of covariates or different initialisation settings can be done by supplying objects of class <code>"MoEClust"</code> to <code><a href="#topic+MoE_compare">MoE_compare</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class <code>"MoEClust"</code>) with the following named entries, mostly corresponding to the chosen optimal model (as determined by the <code>criterion</code> within <code><a href="#topic+MoE_control">MoE_control</a></code>):
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The input data, as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code>modelName</code></td>
<td>
<p>A character string denoting the GPCM/<span class="pkg">mclust</span> model type at which the optimal <code>criterion</code> occurs.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations in the <code>data</code>.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The dimension of the <code>data</code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The optimal number of mixture components according to <code>criterion</code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>A matrix of <em>all</em> BIC values with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. May include missing entries: <code>NA</code> represents models which were not visited, <code>-Inf</code> represents models which were terminated due to error, for which a log-likelihood could not be estimated. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustBIC"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
<tr><td><code>ICL</code></td>
<td>
<p>A matrix of <em>all</em> ICL values with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. May include missing entries: <code>NA</code> represents models which were not visited, <code>-Inf</code> represents models which were terminated due to error, for which a log-likelihood could not be estimated. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustICL"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>A matrix of <em>all</em> AIC values with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. May include missing entries: <code>NA</code> represents models which were not visited, <code>-Inf</code> represents models which were terminated due to error, for which a log-likelihood could not be estimated. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustAIC"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>The BIC value corresponding to the optimal model. May not necessarily be the optimal BIC.</p>
</td></tr>
<tr><td><code>icl</code></td>
<td>
<p>The ICL value corresponding to the optimal model. May not necessarily be the optimal ICL.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>The AIC value corresponding to the optimal model. May not necessarily be the optimal AIC.</p>
</td></tr>
<tr><td><code>gating</code></td>
<td>
<p>An object of class <code>"MoE_gating"</code> (for which dedicated <code>print</code>, <code>summary</code>, and <code><a href="#topic+predict.MoE_gating">predict</a></code> methods exist) and either <code>"multinom"</code> or <code>"glm"</code> (only for single-component models or noise-only models) giving the <code><a href="nnet.html#topic+multinom">multinom</a></code> regression coefficients of the <code>gating</code> network. If <code>gating</code> covariates were <em>NOT</em> supplied (or the best model has just one component), this corresponds to a RHS of <code>~1</code>, otherwise the supplied <code>gating</code> formula. As such, a fitted <code>gating</code> network is always returned even in the absence of supplied covariates or clusters. The number of parameters to penalise by for <code><a href="#topic+MoE_crit">MoE_crit</a></code> is given by <code>length(coef(gating))</code>, and the <code>gating</code> formula used is stored here as an attribute. If there is a noise component (and the option <code>noise.gate=TRUE</code> is invoked), its coefficients are those for the <em>last</em> component. <strong>Users are cautioned against making inferences about statistical significance from summaries of the coefficients in the gating network</strong>.</p>
</td></tr>
<tr><td><code>expert</code></td>
<td>
<p>An object of class <code>"MoE_expert"</code> (for which dedicated <code>print</code>, <code>summary</code>, and <code><a href="#topic+predict.MoE_expert">predict</a></code> methods exist) and <code>"lm"</code> giving the (multivariate) WLS regression coefficients of the <code>expert</code> network. If <code>expert</code> covariates were NOT supplied, this corresponds to a RHS of <code>~1</code>, otherwise the supplied <code>expert</code> formula. As such, a fitted <code>expert</code> network is always returned even in the absence of supplied covariates. The number of parameters to penalise by for <code><a href="#topic+MoE_crit">MoE_crit</a></code> is given by <code>G * length(coef(expert[[1]]))</code>, and the <code>expert</code> formula used is stored here is an attribute. <strong>Users are cautioned against making inferences about statistical significance from summaries of the coefficients in the expert network</strong>.</p>
</td></tr>
<tr><td><code>LOGLIK</code></td>
<td>
<p>A matrix of <em>all</em> maximal log-likelihood values with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. May include missing entries: <code>NA</code> represents models which were not visited, <code>-Inf</code> represents models which were terminated due to error, for which a log-likelihood could not be estimated. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustLOGLIK"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The vector of increasing log-likelihood values for every EM/CEM iteration under the optimal model. The last element of this vector is the maximum log-likelihood achieved by the parameters returned at convergence.</p>
</td></tr>
<tr><td><code>linf</code></td>
<td>
<p>An asymptotic estimate of the final converged maximised log-likelihood. Returned when <code>stopping="aitken"</code> and <code>G &gt; 1</code> (see <code><a href="#topic+MoE_control">MoE_control</a></code> and <code><a href="#topic+aitken">aitken</a></code>), otherwise the last element of <code>loglik</code> is returned instead.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of estimated parameters in the optimal model (i.e. the number of &lsquo;used&rsquo; degrees of freedom). Subtract this number from <code>n</code> to get the degrees of freedom. The number of parameters due to the gating network, expert network, and covariance matrices are also stored here as attributes of <code>df</code>.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>The total number of EM/CEM iterations for the optimal model.</p>
</td></tr>
<tr><td><code>hypvol</code></td>
<td>
<p>The hypervolume parameter for the noise component if required, otherwise set to <code>NA</code> (see <code><a href="#topic+MoE_control">MoE_control</a></code>).</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list with the following named components:
</p>

<dl>
<dt><code>pro</code></dt><dd><p>The mixing proportions: either a vector of length <code>G</code> or, if <code>gating</code> covariates were supplied, a matrix with an entry for each observation (rows) and component (columns).</p>
</dd>
<dt><code>mean</code></dt><dd><p>The means of each component. If there is more than one component, this is a matrix whose <em>k</em>-th column is the mean of the <em>k</em>-th component of the mixture model.
</p>
<p>For models with expert network covariates, this is given by the posterior mean of the fitted values, otherwise the posterior mean of the response is reported. For models with expert network covariates, the <em>observation-specific</em> component means can be accessed by calling <code><a href="#topic+predict.MoE_expert">predict</a></code> on the <code>expert</code> object above.</p>
</dd>
<dt><code>variance</code></dt><dd><p>A list of variance parameters of each component of the model. The components of this list depend on the model type specification. See the help file for <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code> for details. Also see <code><a href="#topic+expert_covar">expert_covar</a></code> for an alternative approach to summarising the variance parameters in the presence of expert network covariates.</p>
</dd>
<dt><code>Vinv</code></dt><dd><p>The inverse of the hypervolume parameter for the noise component if required, otherwise set to <code>NULL</code> (see <code><a href="#topic+MoE_control">MoE_control</a></code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The final responsibility matrix whose <code>[i,k]</code>-th entry is the probability that observation <em>i</em> belonds to the <em>k</em>-th component. If there is a noise component, its values are found in the <em>last</em> column.</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>The vector of cluster labels for the chosen model corresponding to <code>z</code>, i.e. <code>max.col(z)</code>. Observations belonging to the noise component, if any, will belong to component <code>0</code>.</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>The uncertainty associated with the <code>classification</code>.</p>
</td></tr>
<tr><td><code>net.covs</code></td>
<td>
<p>A data frame gathering the unique set of covariates used in the <code>gating</code> and <code>expert</code> networks, if any. Will contain zero columns in the absence of gating or expert network covariates. Supplied gating covariates will be excluded if the optimal model has only one component. May have fewer columns than covariates supplied via the <code>network.data</code> argument also, as only the included covariates are gathered here.</p>
</td></tr>
<tr><td><code>resid.data</code></td>
<td>
<p>In the presence of expert network covariates, this is the augmented data actually used in the clustering at convergence, as a list of <code>G</code> matrices of WLS residuals of dimension <code>n * d</code>. Will contain zero columns in the absence of expert network covariates.</p>
</td></tr>
<tr><td><code>DF</code></td>
<td>
<p>A matrix giving the numbers of estimated parameters (i.e. the number of &lsquo;used&rsquo; degrees of freedom) for <em>all</em> visited models, with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. Subtract these numbers from <code>n</code> to get the degrees of freedom. May include missing entries: <code>NA</code> represents models which were not visited, <code>-Inf</code> represents models which were terminated due to error, for which parameters could not be estimated. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustDF"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
<tr><td><code>ITERS</code></td>
<td>
<p>A matrix giving the total number of EM/CEM iterations for <em>all</em> visited models, with <code>length{G}</code> rows and <code>length(modelNames)</code> columns. May include missing entries: <code>NA</code> represents models which were not visited, <code>Inf</code> represents models which were terminated due to singularity/error and thus would never have converged. Inherits the classes <code>"MoECriterion"</code> and <code>"mclustITERS"</code>, for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.</p>
</td></tr>
</table>
<p>Dedicated <code><a href="#topic+plot.MoEClust">plot</a></code>, <code><a href="#topic+predict.MoEClust">predict</a></code>, <code>print</code>, and <code>summary</code> functions exist for objects of class <code>"MoEClust"</code>. The results can be coerced to the <code>"Mclust"</code> class to access other functions from the <span class="pkg">mclust</span> package via <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>.
</p>


<h3>Note</h3>

<p>Where <code>BIC</code>, <code>ICL</code>, <code>AIC</code>, <code>LOGLIK</code>, <code>DF</code>, and <code>ITERS</code> contain <code>NA</code> entries, this corresponds to a model which was not run; for instance a VVV model is never run for single-component models as it is equivalent to EEE. As such, one can consider the value as not really missing, but equivalent to the EEE value. <code>BIC</code>, <code>ICL</code>, <code>AIC</code>, <code>LOGLIK</code>, <code>DF</code>, and <code>ITERS</code> all inherit the classes <code>"MoECriterion"</code> and <code>"mclustBIC"</code>, <code>"mclustICL"</code>, etc., for which dedicated <code>print</code>, <code>summary</code>, and <code>plot</code> methods exist.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>
<p>Fraley, C. and Raftery, A. E. (2002). Model-based clustering, discriminant analysis, and density estimation. <em>Journal of the American Statistical Association</em>, 97(458): 611-631.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code> for identifying the optimal model and its covariates via greedy forward stepwise selection.
</p>
<p><code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="#topic+MoE_compare">MoE_compare</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code>, <code><a href="#topic+predict.MoE_gating">predict.MoE_gating</a></code>, <code><a href="#topic+predict.MoE_expert">predict.MoE_expert</a></code>, <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>, <code><a href="#topic+MoE_crit">MoE_crit</a></code>, <code><a href="#topic+MoE_estep">MoE_estep</a></code>, <code><a href="#topic+MoE_cstep">MoE_cstep</a></code>, <code><a href="#topic+MoE_dens">MoE_dens</a></code>, <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code>, <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code>, <code><a href="#topic+expert_covar">expert_covar</a></code>, <code><a href="#topic+aitken">aitken</a></code>, <code><a href="base.html#topic+I">I</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
hema  &lt;- ais[,3:7]
sex   &lt;- ais$sex
BMI   &lt;- ais$BMI

# Fit a standard finite mixture model
m1    &lt;- MoE_clust(hema, G=2:3)

# Allow covariates to enter the mixing proportions
m2    &lt;- MoE_clust(hema, G=2:3, gating= ~ sex + BMI)

# Allow covariates to enter the component densities
m3    &lt;- MoE_clust(hema, G=2:3, expert= ~ sex)

# Allow covariates to enter both the gating &amp; expert network
m4    &lt;- MoE_clust(hema, G=2:3, gating= ~ BMI, expert= ~ sex)

# Fit an equal mixing proportion model with an expert network covariate
m5    &lt;- MoE_clust(hema, G=2:3, expert= ~ sex + BMI, equalPro=TRUE)

# Fit models with gating covariates &amp; an additional noise component
m6    &lt;- MoE_clust(hema, G=2:3, tau0=0.1, gating= ~ BMI, network.data=ais)

# Extract the model with highest BIC
(comp &lt;- MoE_compare(m1, m2, m3, m4, m5, m6, criterion="bic"))
 
# See if a better model can be found using greedy forward stepwise selection
(step &lt;- MoE_stepwise(ais[,3:7], ais))
(comp &lt;- MoE_compare(comp, step, optimal.only=TRUE))
(best &lt;- comp$optimal)
(summ &lt;- summary(best, classification=TRUE, parameters=TRUE, networks=TRUE))

# Examine the expert network in greater detail
# (but refrain from inferring statistical significance!)
summary(best$expert)

# Visualise the results, incl. the gating network and log-likelihood
plot(best, what="gpairs", show.dens=TRUE)
plot(best, what="gating") # equal mixing proportions!
plot(best, what="loglik")

# Visualise the results using the 'lattice' package
z   &lt;- factor(best$classification, labels=paste0("Cluster", seq_len(best$G)))
lattice::splom(~ hema | sex, groups=z)
lattice::splom(~ hema | z, groups=sex)
</code></pre>

<hr>
<h2 id='MoE_compare'>Choose the best MoEClust model</h2><span id='topic+MoE_compare'></span><span id='topic+print.MoECompare'></span>

<h3>Description</h3>

<p>Takes one or more sets of MoEClust models fitted by <code><a href="#topic+MoE_clust">MoE_clust</a></code> (or <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code>) and ranks them according to the BIC, ICL, or AIC. It's possible to respect the internal ranking within each set of models, or to discard models within each set which were already deemed sub-optimal. This function can help with model selection via exhaustive or stepwise searches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_compare(...,
            criterion = c("bic", "icl", "aic"),
            pick = 10L,
            optimal.only = FALSE)

## S3 method for class 'MoECompare'
print(x,
      index = seq_len(x$pick),
      posidens = TRUE,
      rerank = FALSE,
      digits = 3L,
      details = TRUE, 
      maxi = length(index),
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_compare_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>"MoEClust"</code> outputted by <code><a href="#topic+MoE_clust">MoE_clust</a></code>. All models must have been fit to the same data set. A single <em>named</em> list of such objects can also be supplied. Additionally, objects of class <code>"MoECompare"</code> outputted by this very function can also be supplied here.
</p>
<p>This argument is only relevant for the <code><a href="#topic+MoE_compare">MoE_compare</a></code> function and will be ignored for the associated <code>print</code> function.</p>
</td></tr>
<tr><td><code id="MoE_compare_+3A_criterion">criterion</code></td>
<td>
<p>The criterion used to determine the ranking. Defaults to <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="MoE_compare_+3A_pick">pick</code></td>
<td>
<p>The (integer) number of models to be ranked and compared. Defaults to <code>10L</code>. Will be constrained by the number of models within the <code>"MoEClust"</code> objects supplied via <code>...</code> if <code>optimal.only</code> is <code>FALSE</code>, otherwise constrained simply by the number of <code>"MoEClust"</code> objects supplied. Setting <code>pick=Inf</code> is a valid way to select all models.</p>
</td></tr>
<tr><td><code id="MoE_compare_+3A_optimal.only">optimal.only</code></td>
<td>
<p>Logical indicating whether to only rank models already deemed optimal within each <code>"MoEClust"</code> object (<code>TRUE</code>), or to allow models which were deemed suboptimal enter the final ranking (<code>FALSE</code>, the default). See <code>details</code>.</p>
</td></tr>
<tr><td><code id="MoE_compare_+3A_x">x</code>, <code id="MoE_compare_+3A_index">index</code>, <code id="MoE_compare_+3A_posidens">posidens</code>, <code id="MoE_compare_+3A_rerank">rerank</code>, <code id="MoE_compare_+3A_digits">digits</code>, <code id="MoE_compare_+3A_details">details</code>, <code id="MoE_compare_+3A_maxi">maxi</code></td>
<td>
<p>Arguments required for the associated <code>print</code> function:
</p>

<dl>
<dt><code>x</code></dt><dd><p>An object of class <code>"MoECompare"</code> resulting from a call to <code><a href="#topic+MoE_compare">MoE_compare</a></code>.</p>
</dd>
<dt><code>index</code></dt><dd><p>A logical or numeric vector giving the indices of the rows of the table of ranked models to print. This defaults to the full set of ranked models. It can be useful when the table of ranked models is large to examine a subset via this <code>index</code> argument, for display purposes. See <code>rerank</code>.</p>
</dd>
<dt><code>posidens</code></dt><dd><p>A logical indicating whether models which have been flagged for having positive log-densities should be included in the comparison (defaults to <code>TRUE</code>). Such models may correspond to spurious solutions and can be discarded by specifying <code>posidens=FALSE</code>. Only relevant if any of the <code>"MoEClust"</code> objects being compared were themselves run with <code>posidens=TRUE</code>.</p>
</dd>
<dt><code>rerank</code></dt><dd><p>A logical indicating whether the ranks should be recomputed when subsetting using <code>index</code>. Defaults to <code>FALSE</code>. Only relevant when <code>details=TRUE</code>.</p>
</dd>
<dt><code>digits</code></dt><dd><p>The number of decimal places to round model selection criteria to (defaults to <code>3</code>).</p>
</dd>
<dt><code>details</code></dt><dd><p>Logical indicating whether some additional details should be printed, defaults to <code>TRUE</code>. Exists to facilitate <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code> printing.</p>
</dd>
<dt><code>maxi</code></dt><dd><p>A number specifying the maximum number of rows/models to print. Defaults to <code>length(index)</code>.</p>
</dd></dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to conduct model selection on <code>"MoEClust"</code> objects, fit to the same data set, with different combinations of gating/expert network covariates or different initialisation settings.
</p>
<p>Model selection will have already been performed in terms of choosing the optimal number of components and GPCM/<span class="pkg">mclust</span> model type within each supplied set of results, but <code><a href="#topic+MoE_compare">MoE_compare</a></code> will respect the internal ranking of models when producing the final ranking if <code>optimal.only</code> is <code>FALSE</code>: otherwise only those models already deemed optimal within each <code>"MoEClust"</code> object will be ranked.
</p>
<p>As such if two sets of results are supplied when <code>optimal.only</code> is <code>FALSE</code>, the 1st, 2nd, and 3rd best models could all belong to the first set of results, meaning a model deemed suboptimal according to one set of covariates could be superior to one deemed optimal under another set of covariates.
</p>


<h3>Value</h3>

<p>A list of class <code>"MoECompare"</code>, for which a dedicated print function exists, containing the following elements (each of length <code>pick</code>, and ranked according to <code>criterion</code>, where appropriate):
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>The name of the data set to which the models were fitted.</p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>
<p>The single optimal model (an object of class <code>"MoEClust"</code>) among those supplied, according to the chosen <code>criterion</code>.</p>
</td></tr>
<tr><td><code>pick</code></td>
<td>
<p>The final number of ranked models. May be different (i.e. less than) the supplied <code>pick</code> value.</p>
</td></tr>
<tr><td><code>MoENames</code></td>
<td>
<p>The names of the supplied <code>"MoEClust"</code> objects.</p>
</td></tr>
<tr><td><code>modelNames</code></td>
<td>
<p>The <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The optimal numbers of components.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The numbers of estimated parameters.</p>
</td></tr>
<tr><td><code>iters</code></td>
<td>
<p>The numbers of EM/CEM iterations.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>BIC values, ranked according to <code>criterion</code> (not necessarily <code>"bic"</code>).</p>
</td></tr>
<tr><td><code>icl</code></td>
<td>
<p>ICL values, ranked according to <code>criterion</code> (not necessarily <code>"icl"</code>).</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC values, ranked according to <code>criterion</code> (not necessarily <code>"aic"</code>).</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Maximal log-likelihood values.</p>
</td></tr>
<tr><td><code>gating</code></td>
<td>
<p>The gating formulas.</p>
</td></tr>
<tr><td><code>expert</code></td>
<td>
<p>The expert formulas.</p>
</td></tr>
<tr><td><code>algo</code></td>
<td>
<p>The algorithm used for fitting the model - either <code>"EM"</code>, <code>"CEM"</code>, <code>"cemEM"</code>.</p>
</td></tr>
<tr><td><code>equalPro</code></td>
<td>
<p>Logical indicating whether mixing proportions were constrained to be equal across components.</p>
</td></tr>
<tr><td><code>hypvol</code></td>
<td>
<p>Hypervolume parameters for the noise component if relevant, otherwise set to <code>NA</code> (see <code><a href="#topic+MoE_control">MoE_control</a></code>).</p>
</td></tr>
<tr><td><code>noise</code></td>
<td>
<p>The type of noise component fitted (if any). Only displayed if at least one of the compared models has a noise component.</p>
</td></tr>
<tr><td><code>noise.gate</code></td>
<td>
<p>Logical indicating whether gating covariates were allowed to influence the noise component's mixing proportion. Only printed for models with a noise component, when at least one of the compared models has gating covariates.</p>
</td></tr>
<tr><td><code>equalNoise</code></td>
<td>
<p>Logical indicating whether the mixing proportion of the noise component for <code>equalPro</code> models is also equal (<code>TRUE</code>) or estimated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>criterion</code> argument here need not comply with the criterion used for model selection within each <code>"MoEClust"</code> object, but be aware that a mismatch in terms of <code>criterion</code> <em>may</em> require the optimal model to be re-fit in order to be extracted, thereby slowing down <code><a href="#topic+MoE_compare">MoE_compare</a></code>.
</p>
<p>If random starts had been used via <code>init.z="random.hard"</code> or <code>init.z="soft.random"</code>, the <code>optimal</code> model may not necessarily correspond to the highest-ranking model in the presence of a criterion mismatch, due to the randomness of the initialisation. 
</p>
<p>A dedicated <code>print</code> function exists for objects of class <code>"MoECompare"</code>.
</p>
<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> and <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code> can both also be called on objects of class <code>"MoECompare"</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code> for identifying the optimal model and its covariates via greedy forward stepwise selection.
</p>
<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CO2data)
CO2   &lt;- CO2data$CO2
GNP   &lt;- CO2data$GNP

# Fit a range of models 
m1    &lt;- MoE_clust(CO2, G=1:3)
m2    &lt;- MoE_clust(CO2, G=2:3, gating= ~ GNP)
m3    &lt;- MoE_clust(CO2, G=1:3, expert= ~ GNP)
m4    &lt;- MoE_clust(CO2, G=2:3, gating= ~ GNP, expert= ~ GNP)
m5    &lt;- MoE_clust(CO2, G=2:3, equalPro=TRUE)
m6    &lt;- MoE_clust(CO2, G=2:3, expert= ~ GNP, equalPro=TRUE)
m7    &lt;- MoE_clust(CO2, G=2:3, expert= ~ GNP, tau0=0.1)

# Rank only the optimal models and examine the best model
(comp &lt;- MoE_compare(m1, m2, m3, m4, m5, m6, m7, optimal.only=TRUE))
(best &lt;- comp$optimal)
(summ &lt;- summary(best, classification=TRUE, parameters=TRUE, networks=TRUE))

# Examine all models visited, including those already deemed suboptimal
# Only print models with expert covariates &amp; more than one component
comp2 &lt;- MoE_compare(m1, m2, m3, m4, m5, m6, m7, pick=Inf)
print(comp2, index=comp2$expert != "None" &amp; comp2$G &gt; 1)

# Conduct a stepwise search on the same data
(mod1 &lt;- MoE_stepwise(CO2, GNP))

# Conduct another stepwise search considering models with a noise component
(mod2 &lt;- MoE_stepwise(CO2, GNP, noise=TRUE))

# Compare both sets of results to choose the optimal model
(best &lt;- MoE_compare(mod1, mod2, optimal.only=TRUE)$optimal)
</code></pre>

<hr>
<h2 id='MoE_control'>Set control values for use with MoEClust</h2><span id='topic+MoE_control'></span>

<h3>Description</h3>

<p>Supplies a list of arguments (with defaults) for use with <code><a href="#topic+MoE_clust">MoE_clust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_control(init.z = c("hc", "quantile", "kmeans", "mclust", 
                       "random.hard", "soft.random", "list"),
            noise.args = list(...),
            asMclust = FALSE,
            equalPro = FALSE,
            exp.init = list(...),
            algo = c("EM", "CEM", "cemEM"),
            criterion = c("bic", "icl", "aic"),
            stopping = c("aitken", "relative"),
            z.list = NULL, 
            nstarts = 1L,
            eps = .Machine$double.eps,
            tol = c(1e-05, sqrt(.Machine$double.eps), 1e-08),
            itmax = c(.Machine$integer.max, .Machine$integer.max, 1000L),
            hc.args = list(...),
            km.args = list(...),
            posidens = TRUE,
            init.crit = c("bic", "icl"),
            warn.it = 0L,
            MaxNWts = 1000L,
            verbose = interactive(),
            ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_control_+3A_init.z">init.z</code></td>
<td>
<p>The method used to initialise the cluster labels for the <em>non-noise</em> components. Defaults to <code>"hc"</code>, i.e. model-based agglomerative hierarchical clustering tree as per <code><a href="mclust.html#topic+hc">hc</a></code>, for multivariate data (see <code>hc.args</code>), or <code>"quantile"</code>-based clustering as per <code><a href="#topic+quant_clust">quant_clust</a></code> for univariate data (unless there are expert network covariates incorporated via <code>exp.init$joint</code> &amp;/or <code>exp.init$clustMD</code>, in which case the default is again <code>"hc"</code>). The <code>"quantile"</code> option is thus only available for univariate data when expert network covariates are not incorporated via <code>exp.init$joint</code> &amp;/or <code>exp.init$clustMD</code>, or when expert network covariates are not supplied.
</p>
<p>Other options include <code>"kmeans"</code> (see <code>km.args</code>), <code>"random.hard"</code> or <code>"soft.random"</code> initialisation (see <code>nstarts</code> below), where <code>init.z="soft.random"</code> is only available when <code>algo != "EM"</code>, a user-supplied <code>"list"</code> (see <code>z.list</code> below), and a full run of <code><a href="mclust.html#topic+Mclust">Mclust</a></code> (itself initialised via a model-based agglomerative hierarchical clustering tree, again see <code>hc.args</code>), although this last option <code>"mclust"</code> will be coerced to <code>"hc"</code> if there are no <code>gating</code> &amp;/or <code>expert</code> covariates within <code><a href="#topic+MoE_clust">MoE_clust</a></code> (in order to better reproduce <code><a href="mclust.html#topic+Mclust">Mclust</a></code> output).
</p>
<p>When <code>init.z="list"</code>, <code>exp.init$clustMD</code> is forced to <code>FALSE</code>; otherwise, when <code>exp.init$clustMD=TRUE</code> and the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded, the <code>init.z</code> argument instead governs the method by which a call to <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> is initialised. In this instance, <code>"quantile"</code> will instead default to <code>"hc"</code>, and the arguments to <code>hc.args</code> and <code>km.args</code> will be ignored (unless all <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types fail for a given number of components).
</p>
<p>When <code>init.z="mclust"</code> or <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> is successfully invoked (via <code>exp.init$clustMD</code>), the argument <code>init.crit</code> (see below) specifies the model-selection criterion (<code>"bic"</code> or <code>"icl"</code>) by which the optimal <code><a href="mclust.html#topic+Mclust">Mclust</a></code> or <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model type to initialise with is determined, and <code>criterion</code> remains unaffected.
</p>
<p>Finally, when the model includes expert network covariates and <code>exp.init$mahalanobis=TRUE</code>, the argument <code>exp.init$estart</code> (see below) can be used to modify the behaviour of <code>init.z="random.hard"</code> or <code>init.z="soft.random"</code> when <code>nstarts &gt; 1</code>, toggling between a full run of the EM algorithm for each random initialisation (i.e. <code>exp.init$estart=FALSE</code>, the default), or a single run of the EM algorithm starting from the best initial partition obtained among the random starts according to the iterative reallocation initialisation routine (i.e. <code>exp.init$estart=TRUE</code>).</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_noise.args">noise.args</code></td>
<td>
<p>A list supplying select named parameters to control inclusion of a noise component in the estimation of the mixture. If either or both of the arguments <code>tau0</code> &amp;/or <code>noise.init</code> are supplied, a noise component is added to the the model in the estimation.
</p>

<dl>
<dt><code>tau0</code></dt><dd><p>Prior mixing proportion for the noise component. If supplied, a noise component will be added to the model in the estimation, with <code>tau0</code> giving the prior probability of belonging to the noise component. Typically supplied as a scalar in the interval (0, 1), e.g. <code>0.1</code>, such that the same prior probability of belonging to the noise component applies to <em>all</em> observations. However, <code>tau0</code> can also be supplied as a vector (with length equal to the number of observations), which may be particularly useful when gating covariates are present and <code>noise.args$noise.gate</code> is <code>TRUE</code>. Finally, note that this argument can be supplied instead of or in conjunction with the argument <code>noise.init</code> below.</p>
</dd>
<dt><code>noise.init</code></dt><dd><p>A logical or numeric vector indicating an initial guess as to which observations are noise in the data. If numeric, the entries should correspond to row indices of the data. If supplied, a noise component will be added to the model in the estimation. This argument can be used in conjunction with <code>tau0</code> above, or can be replaced by that argument also.</p>
</dd>
<dt><code>noise.gate</code></dt><dd><p>A logical indicating whether gating network covariates influence the mixing proportion for the noise component, if any. Defaults to <code>TRUE</code>, but leads to greater parsimony if <code>FALSE</code>. Only relevant in the presence of a noise component; only effects estimation in the presence of gating covariates.</p>
</dd>
<dt><code>noise.meth</code></dt><dd><p>The method used to estimate the volume when a noise component is invoked. Defaults to <code><a href="mclust.html#topic+hypvol">hypvol</a></code>. For univariate data, this argument is ignored and the range of the data is used instead (unless <code>noise.vol</code> below is specified). The options <code>"convexhull"</code> and <code>"ellipsoidhull"</code> require loading the <span class="pkg">geometry</span> and <span class="pkg">cluster</span> packages, respectively. This argument is only relevant if <code>noise.vol</code> below is not supplied.</p>
</dd>
<dt><code>noise.vol</code></dt><dd><p>This argument can be used to override the argument <code>noise.meth</code> by specifying the (hyper)volume directly, i.e. specifying an improper uniform density. This will override the use of the range of the response data for univariate data if supplied. Note that the (hyper)volume, rather than its inverse, is supplied here. This can affect prediction and the location of the MVN ellipses for <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> plots (see <code><a href="#topic+noise_vol">noise_vol</a></code>).</p>
</dd>
<dt><code>equalNoise</code></dt><dd><p>Logical which is <strong>only</strong> invoked when <code>equalPro=TRUE</code> and gating covariates are not supplied. Under the default setting (<code>FALSE</code>), the mixing proportion for the noise component is estimated, and remaining mixing proportions are equal; when <code>TRUE</code> all components, including the noise component, have equal mixing proportions.</p>
</dd>
<dt><code>discard.noise</code></dt><dd><p>A logical governing how the means are summarised in <code>parameters$mean</code> and by extension the location of the MVN ellipses in <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> plots for models with <em>both</em> expert network covariates and a noise component (otherwise this argument is irrelevant). 
</p>
<p>The means for models with expert network covariates are summarised by the posterior mean of the fitted values. By default (<code>FALSE</code>), the mean of the noise component is accounted for in the posterior mean. Otherwise, or when the mean of the noise component is unavailable (due to having been manually supplied via <code>noise.args$noise.vol</code>), the <code>z</code> matrix is renormalised after discarding the column corresponding to the noise component prior to computation of the posterior mean. The renormalisation approach can be forced by specifying <code>noise.args$discard.noise=TRUE</code>, even when the mean of the noise component is available. For models with a noise component fitted with <code>algo="CEM"</code>, a small extra E-step is conducted for observations assigned to the non-noise components in this case.</p>
</dd>
</dl>

<p>In particular, the argument <code>noise.meth</code> will be ignored for high-dimensional <code>n &lt;= d</code> data, in which case the argument <code>noise.vol</code> <em>must be</em> specified. Note that this forces <code>noise.args$discard.noise</code> to <code>TRUE</code>. See <code><a href="#topic+noise_vol">noise_vol</a></code> for more details.
</p>
<p>The arguments <code>tau0</code> and <code>noise.init</code> can be used separately, to provide alternative means to invoke a noise component. However, they can also be supplied together, in which case observations corresponding to <code>noise.init</code> have probability <code>tau0</code> (rather than 1) of belonging to the noise component. This strategy also works when <code>tau0</code> is supplied as a vector.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_asmclust">asMclust</code></td>
<td>
<p>The default values of <code>stopping</code> and <code>hc.args$hcUse</code> (see below) are such that results for models with <em>no covariates in either network</em> are liable to differ from results for equivalent models obtained via <code><a href="mclust.html#topic+Mclust">Mclust</a></code>. <span class="pkg">MoEClust</span> uses <code>stopping="aitken"</code> and <code>hcUse="VARS"</code> by default, while <span class="pkg">mclust</span> always implicitly uses <code>stopping="relative"</code> and defaults to <code>hcUse="SVD"</code>.
</p>
<p><code>asMclust</code> is a logical variable (<code>FALSE</code>, by default) which functions as a simple convenience tool for overriding <strong>only</strong> these two arguments (even if explicitly supplied!) such that they behave like the function <code><a href="mclust.html#topic+Mclust">Mclust</a></code>. Other <em>user-specified</em> arguments which differ from <span class="pkg">mclust</span> are not affected by <code>asMclust</code>, as their defaults already correspond to <span class="pkg">mclust</span>. Results may still differ slightly as <span class="pkg">MoEClust</span> calculates log-likelihood values with greater precision and may also differ slightly in other numerical aspects which affect parameter estimation or convergence in some cases. Finally, note that <code>asMclust=TRUE</code> can be invoked even for models with covariates which are not accommodated by <span class="pkg">mclust</span>.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_equalpro">equalPro</code></td>
<td>
<p>Logical variable indicating whether or not the mixing proportions are to be constrained to be equal in the model. Default: <code>equalPro = FALSE</code>. Only relevant when <code>gating</code> covariates are <em>not</em> supplied within <code><a href="#topic+MoE_clust">MoE_clust</a></code>, otherwise ignored. In the presence of a noise component (see <code>noise.args</code>), only the mixing proportions for the non-noise components are constrained to be equal (by default, see <code>equalNoise</code>), after accounting for the noise component.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_exp.init">exp.init</code></td>
<td>
<p>A list supplying select named parameters to control the initialisation routine in the presence of <em>expert</em> network covariates (otherwise ignored):
</p>

<dl>
<dt><code>joint</code></dt><dd><p>A logical indicating whether the initial partition is obtained on the joint distribution of the responses &amp; expert network covariates (defaults to <code>TRUE</code>) or just the responses (<code>FALSE</code>). By default, only continuous expert covariates are considered (see <code>exp.init$clustMD</code> below). Only relevant when <code>init.z</code> is neither <code>"random.hard"</code> nor <code>"soft.random"</code> (unless <code>exp.init$clustMD=TRUE</code>, in which case <code>init.z</code> specifies the initialisation routine for a call to <code><a href="clustMD.html#topic+clustMD">clustMD</a></code>, where <code>init.z="random.hard"</code> &amp; <code>init.z="soft.random"</code> <em>both</em> map to the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> argument <code>startCL="random"</code>). This will render the <code>"quantile"</code> option of <code>init.z</code> for univariate data unusable if continuous expert covariates are supplied &amp;/or categorical/ordinal expert covariates are supplied when <code>exp.init$clustMD=TRUE</code> and the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded.</p>
</dd>
<dt><code>mahalanobis</code></dt><dd><p>A logical indicating whether to iteratively reallocate observations during the initialisation phase to the component corresponding to the expert network regression to which it's closest to the fitted values of in terms of Mahalanobis distance (defaults to <code>TRUE</code>). This will ensure that each component can be well modelled by a single expert prior to running the EM/CEM algorithm.</p>
</dd>
<dt><code>estart</code></dt><dd><p>A logical governing the behaviour of <code>init.z="random.hard"</code> or <code>init.z="soft.random"</code> when <code>nstarts &gt; 1</code> in the presence of expert network covariates. Only relevant when <code>exp.init$mahalanobis=TRUE</code>. Defaults to <code>FALSE</code>; i.e. all random starts are put through full runs of the EM algorithm. When <code>TRUE</code>, all random starts are put through the initial iterative reallocation routine prior to a full run of EM for only the single best random initial partition obtained. See the last set of <strong>Examples</strong> below.</p>
</dd>
<dt><code><a href="clustMD.html#topic+clustMD">clustMD</a></code></dt><dd><p>A logical indicating whether categorical/ordinal covariates should be incorporated when using the joint distribution of the response and expert network covariates for initialisation (defaults to <code>FALSE</code>). Only relevant when <code>exp.init$joint=TRUE</code>. Requires the use of the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package. Note that initialising in this manner involves fitting all <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types in parallel for all numbers of components considered, and may fail (especially) in the presence of nominal expert network covariates.
</p>
<p>Unless <code>init.z="list"</code>, supplying this argument as <code>TRUE</code> when the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded has the effect of superseding the <code>init.z</code> argument: this argument now governs instead how the call to <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> is initialised (unless all <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types fail for a given number of components, in which case <code>init.z</code> is invoked <em>instead</em> to initialise for <code>G</code> values for which all <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types failed). Similarly, the arguments <code>hc.args</code> and <code>km.args</code> will be ignored (again, unless all <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types fail for a given number of components).</p>
</dd>
<dt><code>max.init</code></dt><dd><p>The maximum number of iterations for the Mahalanobis distance-based reallocation procedure when <code>exp.init$mahalanobis</code> is <code>TRUE</code>. Defaults to <code>.Machine$integer.max</code>.</p>
</dd>
<dt><code>identity</code></dt><dd><p>A logical indicating whether the identity matrix (corresponding to the use of the Euclidean distance) is used in place of the covariance matrix of the residuals (corresponding to the use of the Mahalanobis distance). Defaults to <code>FALSE</code> for multivariate response data but defaults to <code>TRUE</code> for univariate response data. Setting <code>identity=TRUE</code> with multivariate data may be advisable when the dimensions of the data are such that the covariance matrix cannot be inverted (otherwise, the pseudo-inverse is used under the <code>FALSE</code> default).</p>
</dd>
<dt><code>drop.break</code></dt><dd><p>When <code>exp.init$mahalanobis=TRUE</code> observations will be completely in or out of a component during the initialisation phase. As such, it may occur that constant columns will be present when building a given component's expert regression (particularly for categorical covariates). It may also occur, due to this partitioning, that &quot;unseen&quot; data, when calculating the residuals, will have new factor levels. When <code>exp.init$drop.break=TRUE</code>, the Mahalanobis distance based initialisation phase will explicitly fail in either of these scenarios.
</p>
<p>Otherwise, <code><a href="#topic+drop_constants">drop_constants</a></code> and <code><a href="#topic+drop_levels">drop_levels</a></code> will be invoked when <code>exp.init$drop.break</code> is <code>FALSE</code> (the default) to <em>try</em> to remedy the situation. In any case, only a warning that the initialisation step failed will be printed, regardless of the value of <code>exp.init$drop.break</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="MoE_control_+3A_algo">algo</code></td>
<td>
<p>Switch controlling whether models are fit using the <code>"EM"</code> (the default) or <code>"CEM"</code> algorithm. The option <code>"cemEM"</code> allows running the EM algorithm starting from convergence of the CEM algorithm.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_criterion">criterion</code></td>
<td>
<p>When either <code>G</code> or <code>modelNames</code> is a vector, <code>criterion</code> determines whether the <code>"bic"</code> (Bayesian Information Criterion), <code>"icl"</code> (Integrated Complete Likelihood), <code>"aic"</code> (Akaike Information Criterion) is used to determine the &lsquo;best&rsquo; model when gathering output. Note that all criteria will be returned in any case.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_stopping">stopping</code></td>
<td>
<p>The criterion used to assess convergence of the EM/CEM algorithm. The default (<code>"aitken"</code>) uses Aitken's acceleration method via <code><a href="#topic+aitken">aitken</a></code>, otherwise the <code>"relative"</code> change in log-likelihood is monitored (which may be less strict). The <code>"relative"</code> option corresponds to the stopping criterion used by <code><a href="mclust.html#topic+Mclust">Mclust</a></code>: see <code>asMclust</code> above. 
</p>
<p>Both stopping rules are ultimately governed by <code>tol[1]</code>. When the <code>"aitken"</code> method is employed, the asymptotic estimate of the final converged maximised log-likelihood is also returned as <code>linf</code> for models with 2 or more components, though the largest element of the returned vector <code>loglik</code> still gives the log-likelihood value achieved by the parameters returned at convergence, under both <code>stopping</code> methods (see <code><a href="#topic+MoE_clust">MoE_clust</a></code>).</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_z.list">z.list</code></td>
<td>
<p>A user supplied list of initial cluster allocation matrices, with number of rows given by the number of observations, and numbers of columns given by the range of component numbers being considered. In particular, <code>z.list</code> must only include columns corresponding to <em>non-noise</em> components when using this method to initialise in the presence of a noise component. Only relevant if <code>init.z="z.list"</code>. These matrices are allowed correspond to both soft or hard clusterings, and will be internally normalised so that the rows sum to 1 (or coerced always to a 'hard' matrix if <code>algo != "EM"</code>). See <code>noise.init</code> and <code>tau0</code> above for details on initialisation in the presence of a noise component.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_nstarts">nstarts</code></td>
<td>
<p>The number of random initialisations to use when <code>init.z="random.hard"</code> or <code>init.z="soft.random"</code>. Defaults to <code>1</code>. When there are no expert covariates (or when <code>exp.init$mahalanobis=FALSE</code> or <code>exp.init$estart=FALSE</code>), the results will be based on the random start yielding the highest estimated log-likelihood after each initial partition is subjected to a full run of the EM algorithm. Note, in this case, that all <code>nstarts</code> random initialisations are affected by <code>exp.init$mahalanobis</code>, if invoked in the presence of expert network covariates, which may remove some of the randomness. 
</p>
<p>Conversely, if <code>exp.init$mahalanobis=TRUE</code> and <code>exp.init$estart=TRUE</code>, all <code>nstarts</code> random starts are put through the initial iterative reallocation routine and only the single best initial partition uncovered is put through the full run of the EM algorithm. See <code>init.z</code> and <code>exp.init$estart</code> above for more details, though note that <code>exp.init$mahalanobis=TRUE</code> and <code>exp.init$estart=FALSE</code>, by default.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_eps">eps</code></td>
<td>
<p>A scalar tolerance associated with deciding when to terminate computations due to computational singularity in covariances. Smaller values of <code>eps</code> allow computations to proceed nearer to singularity. The default is the relative machine precision <code>.Machine$double.eps</code>, which is approximately <em>2e-16</em> on IEEE-compliant machines.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_tol">tol</code></td>
<td>
<p>A vector of length three giving <em>relative</em> convergence tolerances for 1) the log-likelihood of the EM/CEM algorithm, 2) parameter convergence in the inner loop for models with iterative M-step (<code>"VEI", "VEE", "EVE", "VVE", "VEV"</code>), and 3) optimisation in the multinomial logistic regression in the gating network, respectively. The default is <code>c(1e-05, sqrt(.Machine$double.eps), 1e-08)</code>. If only one number is supplied, it is used as the tolerance for all three cases given.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_itmax">itmax</code></td>
<td>
<p>A vector of length three giving integer limits on the number of iterations for 1) the EM/CEM algorithm, 2) the inner loop for models with iterative M-step (<code>"VEI", "VEE", "EVE", "VVE", "VEV"</code>), and 3) the multinomial logistic regression in the gating network, respectively.
</p>
<p>The default is <code>c(.Machine$integer.max, .Machine$integer.max, 1000L)</code>, allowing termination to be completely governed by <code>tol[1]</code> &amp; <code>tol[2]</code> for the inner and outer loops of the EM/CEM algorithm. If only one number is supplied, it is used as the iteration limit for the outer loop only and the other elements of <code>itmax</code> retain their usual defaults.
</p>
<p>If, for any model with gating covariates, the multinomial logistic regression in the gating network fails to converge in <code>itmax[3]</code> iterations at any stage of the EM/CEM algorithm, an appropriate warning will be printed, prompting the user to modify this argument.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_hc.args">hc.args</code></td>
<td>
<p>A list supplying select named parameters to control the initialisation of the cluster allocations when <code>init.z="hc"</code> (or when <code>init.z="mclust"</code>, which itself relies on <code><a href="mclust.html#topic+hc">hc</a></code>), unless <code>exp.init$clustMD=TRUE</code>, the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded, and none of the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types fail (otherwise irrelevant):
</p>

<dl>
<dt><code>hcUse</code></dt><dd><p>A string specifying the type of input variables to be used. This defaults to <code>"VARS"</code> here, unlike <span class="pkg">mclust</span> which defaults to <code>"SVD"</code>. Other allowable values are documented in <code><a href="mclust.html#topic+mclust.options">mclust.options</a></code>. See <code>asMclust</code> above.</p>
</dd>
<dt><code>hc.meth</code></dt><dd><p>A character string indicating the model to be used when hierarchical clustering (see <code><a href="mclust.html#topic+hc">hc</a></code>) is employed for initialisation (either when <code>init.z="hc"</code> or <code>init.z="mclust"</code>). Defaults to <code>"EII"</code> for high-dimensional data, or <code>"VVV"</code> otherwise.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="MoE_control_+3A_km.args">km.args</code></td>
<td>
<p>A list supplying select named parameters to control the initialisation of the cluster allocations when <code>init.z="kmeans"</code>, unless <code>exp.init$clustMD=TRUE</code>, the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded, and none of the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> model types fail (otherwise irrelevant):
</p>

<dl>
<dt><code>kstarts</code></dt><dd><p>The number of random initialisations to use. Defaults to <code>10</code>.</p>
</dd>
<dt><code>kiters</code></dt><dd><p>The maximum number of K-Means iterations allowed. Defaults to <code>10</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="MoE_control_+3A_posidens">posidens</code></td>
<td>
<p>A logical governing whether to continue running the algorithm even in the presence of positive log-densities. Defaults to <code>TRUE</code>, but setting <code>posidens=FALSE</code> can help to safeguard against spurious solutions, which will be instantly terminated if positive log-densities are encountered. Note that versions of <span class="pkg">MoEClust</span> prior to and including version <code>1.3.1</code> always implicitly assumed <code>posidens=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_init.crit">init.crit</code></td>
<td>
<p>The criterion to be used to determine the optimal model type to initialise with, when <code>init.z="mclust"</code> or when <code>exp.init$clustMD=TRUE</code> and the <code><a href="clustMD.html#topic+clustMD">clustMD</a></code> package is loaded (one of <code>"bic"</code> or <code>"icl"</code>). Defaults to <code>"icl"</code> when <code>criterion="icl"</code>, otherwise defaults to <code>"bic"</code>. The <code>criterion</code> argument remains unaffected.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_warn.it">warn.it</code></td>
<td>
<p>A single number giving the iteration count at which a warning will be printed if the EM/CEM algorithm has failed to converge. Defaults to <code>0</code>, i.e. no warning (which is true for any <code>warn.it</code> value less than <code>3</code>), otherwise the message is printed regardless of the value of <code>verbose</code>. If non-zero, <code>warn.it</code> should be moderately large, but obviously less than <code>itmax[1]</code>. A warning will always be printed if one of more models fail to converge in <code>itmax[1]</code> iterations.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>The maximum allowable number of weights in the call to <code><a href="nnet.html#topic+multinom">multinom</a></code> for the multinomial logistic regression in the gating network. There is no intrinsic limit in the code, but increasing <code>MaxNWts</code> will probably allow fits that are very slow and time-consuming. It may be necessary to increase <code>MaxNWts</code> when categorical concomitant variables with many levels are included or the number of components is high.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print messages pertaining to progress to the screen during fitting. By default is <code>TRUE</code> if the session is interactive, and <code>FALSE</code> otherwise. If <code>FALSE</code>, warnings and error messages will still be printed to the screen, but everything else will be suppressed.</p>
</td></tr>
<tr><td><code id="MoE_control_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+MoE_control">MoE_control</a></code> is provided for assigning values and defaults within <code><a href="#topic+MoE_clust">MoE_clust</a></code> and <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code>.
</p>
<p>While the <code>criterion</code> argument controls the choice of the optimal number of components and GPCM/<span class="pkg">mclust</span> model type, <code><a href="#topic+MoE_compare">MoE_compare</a></code> is provided for choosing between fits with different combinations of covariates or different initialisation settings.
</p>


<h3>Value</h3>

<p>A named list in which the names are the names of the arguments and the values are the values supplied to the arguments.
</p>


<h3>Note</h3>

<p>Note that successfully invoking <code>exp.init$clustMD</code> (though it defaults to <code>FALSE</code>) affects the role of the arguments <code>init.z</code>, <code>hc.args</code>, and <code>km.args</code>. Please read the documentation above carefully in this instance.
</p>
<p>The initial allocation matrices before and after the invocation of the <code>exp.init</code> related arguments are both stored as attributes in the object returned by <code><a href="#topic+MoE_clust">MoE_clust</a></code> (named <code>"Z.init"</code> and <code>"Exp.init"</code>, respectively). If <code>init.z="random.hard"</code> or <code>init.z="soft.random"</code> and <code>nstarts &gt; 1</code>, the allocations corresponding to the best random start are stored (regardless of whether <code>exp.init$estart</code> is invoked or not). This can be useful for supplying <code>z.list</code> for future fits.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code>, <code><a href="#topic+aitken">aitken</a></code>, <code><a href="mclust.html#topic+Mclust">Mclust</a></code>, <code><a href="mclust.html#topic+hc">hc</a></code>, <code><a href="mclust.html#topic+mclust.options">mclust.options</a></code>, <code><a href="#topic+quant_clust">quant_clust</a></code>, <code><a href="clustMD.html#topic+clustMD">clustMD</a></code>, <code><a href="#topic+noise_vol">noise_vol</a></code>, <code><a href="mclust.html#topic+hypvol">hypvol</a></code>, <code><a href="geometry.html#topic+convhulln">convhulln</a></code>, <code><a href="cluster.html#topic+ellipsoidhull">ellipsoidhull</a></code>, <code><a href="#topic+MoE_compare">MoE_compare</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl1 &lt;- MoE_control(criterion="icl", itmax=100, warn.it=15, init.z="random.hard", nstarts=5)

data(CO2data)
GNP   &lt;- CO2data$GNP
res   &lt;- MoE_clust(CO2data$CO2, G=2, expert = ~ GNP, control=ctrl1)

# Alternatively, specify control arguments directly
res2  &lt;- MoE_clust(CO2data$CO2, G=2, expert = ~ GNP, stopping="relative")

# Supplying ctrl1 without naming it as 'control' can throw an error
## Not run: 
res3  &lt;- MoE_clust(CO2data$CO2, G=2, expert = ~ GNP, ctrl1)
## End(Not run)

# Similarly, supplying control arguments via a mix of the ... construct
# and the named argument 'control' also throws an error
## Not run: 
res4  &lt;- MoE_clust(CO2data$CO2, G=2, expert = ~ GNP, control=ctrl1, init.z="kmeans")
## End(Not run)

# Initialise via the mixed-type joint distribution of response &amp; covariates
# Let the ICL criterion determine the optimal clustMD model type
# Constrain the mixing proportions to be equal
ctrl2 &lt;- MoE_control(exp.init=list(clustMD=TRUE), init.crit="icl", equalPro=TRUE)
data(ais)
library(clustMD)
res4  &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE", expert= ~ sex,
                   network.data=ais, control=ctrl2)

# Include a noise component by specifying its prior mixing proportion
res5  &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE", expert= ~ sex,
                   network.data=ais, tau0=0.1)
                   
# Include a noise component via an initial guess of which observations are noise
mdist &lt;- mahalanobis(ais[,3:7], colMeans(ais[,3:7]), cov(ais[,3:7]))
cutp  &lt;- qchisq(p=0.95, df=ncol(ais[,3:7]))
res6  &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE", expert= ~ sex,
                   network.data=ais, noise.init=mdist &gt; cutp)
                   
# Include a noise component by specifying tau0 as a vector
res7  &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EVE", expert= ~ sex,
                   network.data=ais, tau0=pchisq(mdist, df=ncol(ais[,3:7])))                                    
                   
# Investigate the use of random starts
sex  &lt;- ais$sex
# resA uses deterministic starting values (by default) for each G value
 system.time(resA &lt;- MoE_clust(ais[,3:7], G=2, expert=~sex, equalPro=TRUE))
# resB passes each random start through the entire EM algorithm for each G value
 system.time(resB &lt;- MoE_clust(ais[,3:7], G=2, expert=~sex, equalPro=TRUE,
                               init.z="random.hard", nstarts=10))
# resC passes only the "best" random start through the EM algorithm for each G value
# this time, we also use soft rather than hard random starts
 system.time(resC &lt;- MoE_clust(ais[,3:7], G=2, expert=~sex, equalPro=TRUE,
                               init.z="soft.random", nstarts=10, estart=TRUE))
# Here, all three settings (given here in order of speed) identify &amp; converge to the same model
 MoE_compare(resA, resC, resB)
</code></pre>

<hr>
<h2 id='MoE_crit'>MoEClust BIC, ICL, and AIC Model-Selection Criteria</h2><span id='topic+MoE_crit'></span>

<h3>Description</h3>

<p>Computes the BIC (Bayesian Information Criterion), ICL (Integrated Complete Likelihood), and AIC (Akaike Information Criterion) for parsimonious mixture of experts models given the log-likelihood, the dimension of the data, the number of mixture components in the model, the numbers of parameters in the gating and expert networks respectively, and, for the ICL, the numbers of observations in each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_crit(modelName,
         loglik,
         n,
         d,
         G,
         gating.pen = G - 1L,
         expert.pen = G * d,
         z = NULL,
         df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_crit_+3A_modelname">modelName</code></td>
<td>
<p>A character string indicating the model. The help file for <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code> describes the available models. Not necessary if <code>df</code> is supplied.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_loglik">loglik</code></td>
<td>
<p>The log-likelihood for a data set with respect to the Gaussian mixture model specified in the <code>modelName</code> argument.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_n">n</code>, <code id="MoE_crit_+3A_d">d</code>, <code id="MoE_crit_+3A_g">G</code></td>
<td>
<p>The number of observations in the data, dimension of the data, and number of components in the Gaussian mixture model, respectively, used to compute <code>loglik</code>. <code>d</code> &amp; <code>G</code> are not necessary if <code>df</code> is supplied.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_gating.pen">gating.pen</code></td>
<td>
<p>The number of parameters of the <em>gating</em> network of the MoEClust model. Defaults to <code>G - 1</code>, which corresponds to no gating covariates. If covariates are included, this should be the number of regression coefficients in the fitted <code>gating</code> object. If there are no covariates and mixing proportions are further assumed to be present in equal proportion, <code>gating.pen</code> should be <code>0</code>. The number of parameters used in the estimation of the noise component, if any, should also be included. Not necessary if <code>df</code> is supplied.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_expert.pen">expert.pen</code></td>
<td>
<p>The number of parameters of the <em>expert</em> network of the MoEClust model. Defaults to <code>G * d</code>, which corresponds to no expert covariates. If covariates are included, this should be the number of regression coefficients in the fitted <code>expert</code> object. Not necessary if <code>df</code> is supplied.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_z">z</code></td>
<td>
<p>The <code>n</code> times <code>G</code> responsibility matrix whose <code>[i,k]</code>-th entry is the probability that observation <em>i</em> belongs to the <em>k</em>-th component.. If supplied the ICL is also computed and returned, otherwise only the BIC and AIC.</p>
</td></tr>
<tr><td><code id="MoE_crit_+3A_df">df</code></td>
<td>
<p>An alternative way to specify the number of estimated parameters (or &lsquo;used&rsquo; degrees of freedom) exactly. If supplied, the arguments <code>modelName</code>, <code>d</code>, <code>G</code>, <code>gating.pen</code>, and <code>expert.pen</code>, which are used to calculate the number of parameters, will be ignored. The number of parameters used in the estimation of the noise component, if any, should also be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is vectorised with respect to the arguments <code>modelName</code> and <code>loglik</code>.
</p>
<p>If <code>model</code> is an object of class <code>"MoEClust"</code> with <code>G</code> components, the number of parameters for the <code>gating.pen</code> and <code>expert.pen</code> are <code>length(coef(model$gating))</code> and <code>G * length(coef(model$expert[[1]]))</code>, respectively.
</p>
<p>Models with a noise component are facilitated here too, provided the extra number of parameters are accounted for by the user.
</p>


<h3>Value</h3>

<p>A simplified array containing the BIC, AIC, number of estimated parameters (<code>df</code>) and, if <code>z</code> is supplied, also the ICL, for each of the given input arguments.
</p>


<h3>Note</h3>

<p>In order to speed up repeated calls to the function inside <code><a href="#topic+MoE_clust">MoE_clust</a></code>, no checks take place.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Biernacki, C., Celeux, G. and Govaert, G. (2000). Assessing a mixture model for clustering with the integrated completed likelihood. <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 22(7): 719-725.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="mclust.html#topic+nVarParams">nVarParams</a></code>, <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MoE_crit(modelName=c("VVI", "VVE", "VVV"), n=120, d=8,
         G=3, loglik=c(-4036.99, -3987.12, -3992.45))

data(CO2data)
GNP   &lt;- CO2data$GNP
model &lt;- MoE_clust(CO2data$CO2, G=1:2, expert= ~ GNP)
G     &lt;- model$G
name  &lt;- model$modelName
ll    &lt;- max(model$loglik)
n     &lt;- length(CO2data$CO2)
z     &lt;- model$z

# Compare BIC from MoE_crit to the BIC of the model
(bic2 &lt;- MoE_crit(modelName=name, loglik=ll, n=n, d=1, G=G, z=z,
                  expert.pen=G * length(coef(model$expert[[1]])))["bic",])
identical(unname(bic2), model$bic) #TRUE

# Make the same comparison with the known number of estimated parameters
(bic3 &lt;- MoE_crit(loglik=ll, n=n, df=model$df, z=z)["bic",])
identical(unname(bic3), bic2)      #TRUE
</code></pre>

<hr>
<h2 id='MoE_cstep'>C-step for MoEClust Models</h2><span id='topic+MoE_cstep'></span>

<h3>Description</h3>

<p>Function to compute the assignment matrix z and the conditional log-likelihood for MoEClust models, with the aid of <code><a href="#topic+MoE_dens">MoE_dens</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_cstep(data,
          mus,
          sigs,
          log.tau = 0L,
          Vinv = NULL,
          Dens = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_cstep_+3A_data">data</code></td>
<td>
<p>If there are no expert network covariates, <code>data</code> should be a numeric matrix or data frame, wherein rows correspond to observations (n) and columns correspond to variables (d). If there are expert network covariates, this should be a list of length G containing matrices/data.frames of (multivariate) WLS residuals for each component.</p>
</td></tr>
<tr><td><code id="MoE_cstep_+3A_mus">mus</code></td>
<td>
<p>The mean for each of G components. If there is more than one component, this is a matrix whose k-th column is the mean of the k-th component of the mixture model. For the univariate models, this is a G-vector of means. In the presence of expert network covariates, all values should be equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="MoE_cstep_+3A_sigs">sigs</code></td>
<td>
<p>The <code>variance</code> component in the parameters list from the output to e.g. <code><a href="#topic+MoE_clust">MoE_clust</a></code>. The components of this list depend on the specification of <code>modelName</code> (see <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code> for details). The number of components <code>G</code>, the number of variables <code>d</code>, and the <code>modelName</code> are inferred from <code>sigs</code>.</p>
</td></tr>
<tr><td><code id="MoE_cstep_+3A_log.tau">log.tau</code></td>
<td>
<p>If covariates enter the gating network, an n times G matrix of mixing proportions, otherwise a G-vector of mixing proportions for the components of the mixture. <strong>Must</strong> be on the log-scale in both cases. The default of <code>0</code> effectively means densities (or log-densities) aren't scaled by the mixing proportions.</p>
</td></tr>
<tr><td><code id="MoE_cstep_+3A_vinv">Vinv</code></td>
<td>
<p>An estimate of the reciprocal hypervolume of the data region. See the function <code><a href="#topic+noise_vol">noise_vol</a></code>. Used only if an initial guess as to which observations are noise is supplied. Mixing proportion(s) must be included for the noise component also.</p>
</td></tr>
<tr><td><code id="MoE_cstep_+3A_dens">Dens</code></td>
<td>
<p>(Optional) A numeric matrix whose <code>[i,k]</code>-th entry is the <strong>log</strong>-density of observation <em>i</em> in component <em>k</em>, scaled by the mixing proportions, to which the function is to be applied, typically obtained by <code><a href="#topic+MoE_dens">MoE_dens</a></code> but this is not necessary. If this is supplied, all other arguments are ignored, otherwise <code><a href="#topic+MoE_dens">MoE_dens</a></code> is called according to the other supplied arguments. If a vector is supplied, it will be coerced to a matrix with one row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>G</code> columns containing 1 where the observation belongs to the cluster indicated by the column number, and 0 otherwise.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The estimated conditional log-likelihood.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended for joint use with <code><a href="#topic+MoE_dens">MoE_dens</a></code>, using the <strong>log</strong>-densities. Caution is advised using this function without explicitly naming the arguments. Models with a noise component are facilitated here too.
</p>
<p>The C-step can be replaced by an E-step, see <code><a href="#topic+MoE_estep">MoE_estep</a></code> and the <code>algo</code> argument to <code><a href="#topic+MoE_control">MoE_control</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_dens">MoE_dens</a></code>, <code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_estep">MoE_estep</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MoE_cstep can be invoked for fitting MoEClust models via the CEM algorithm
# via the 'algo' argument to MoE_control:
data(ais)
hema   &lt;- ais[,3:7]
model  &lt;- MoE_clust(hema, G=3, gating= ~ BMI + sex, modelNames="EEE", network.data=ais, algo="CEM")
Dens   &lt;- MoE_dens(data=hema, mus=model$parameters$mean,
                   sigs=model$parameters$variance, log.tau=log(model$parameters$pro))

# Construct the z matrix and compute the conditional log-likelihood
Cstep  &lt;- MoE_cstep(Dens=Dens)
(ll    &lt;- Cstep$loglik)

# Check that the z matrix &amp; classification are the same as those from the model
identical(max.col(Cstep$z), as.integer(unname(model$classification))) #TRUE
identical(Cstep$z, model$z)                                           #TRUE

# Call MoE_cstep directly
Cstep2 &lt;- MoE_cstep(data=hema, sigs=model$parameters$variance,
                    mus=model$parameters$mean, log.tau=log(model$parameters$pro))
identical(Cstep2$loglik, ll)                                          #TRUE
</code></pre>

<hr>
<h2 id='MoE_dens'>Density for MoEClust Mixture Models</h2><span id='topic+MoE_dens'></span>

<h3>Description</h3>

<p>Computes densities (or log-densities) of observations in MoEClust mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_dens(data,
         mus,
         sigs,
         log.tau = 0L,
         Vinv = NULL,
         logarithm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_dens_+3A_data">data</code></td>
<td>
<p>If there are no expert network covariates, <code>data</code> should be a numeric matrix or data frame, wherein rows correspond to observations (n) and columns correspond to variables (d). If there are expert network covariates, this should be a list of length G containing matrices/data.frames of (multivariate) WLS residuals for each component.</p>
</td></tr>
<tr><td><code id="MoE_dens_+3A_mus">mus</code></td>
<td>
<p>The mean for each of G components. If there is more than one component, this is a matrix whose k-th column is the mean of the k-th component of the mixture model. For the univariate models, this is a G-vector of means. In the presence of expert network covariates, all values should be equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="MoE_dens_+3A_sigs">sigs</code></td>
<td>
<p>The <code>variance</code> component in the parameters list from the output to e.g. <code><a href="#topic+MoE_clust">MoE_clust</a></code>. The components of this list depend on the specification of <code>modelName</code> (see <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code> for details). The number of components <code>G</code>, the number of variables <code>d</code>, and the <code>modelName</code> are inferred from <code>sigs</code>.</p>
</td></tr>
<tr><td><code id="MoE_dens_+3A_log.tau">log.tau</code></td>
<td>
<p>If covariates enter the gating network, an n times G matrix of mixing proportions, otherwise a G-vector of mixing proportions for the components of the mixture. <strong>Must</strong> be on the log-scale in both cases. The default of <code>0</code> effectively means densities (or log-densities) aren't scaled by the mixing proportions.</p>
</td></tr>
<tr><td><code id="MoE_dens_+3A_vinv">Vinv</code></td>
<td>
<p>An estimate of the reciprocal hypervolume of the data region. See the function <code><a href="#topic+noise_vol">noise_vol</a></code>. Used only if an initial guess as to which observations are noise is supplied. Mixing proportion(s) must be included for the noise component also.</p>
</td></tr>
<tr><td><code id="MoE_dens_+3A_logarithm">logarithm</code></td>
<td>
<p>A logical value indicating whether or not the logarithm of the component densities should be returned. This defaults to <code>TRUE</code>, otherwise component densities are returned, obtained from the component log-densities by exponentiation. The <strong>log</strong>-densities can be passed to <code><a href="#topic+MoE_estep">MoE_estep</a></code> or <code><a href="#topic+MoE_cstep">MoE_cstep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix whose <code>[i,k]</code>-th entry is the density or log-density of observation <em>i</em> in component <em>k</em>, scaled by the mixing proportions. These densities are unnormalised.
</p>


<h3>Note</h3>

<p>This function is intended for joint use with <code><a href="#topic+MoE_estep">MoE_estep</a></code> or <code><a href="#topic+MoE_cstep">MoE_cstep</a></code>, using the <strong>log</strong>-densities. Note that models with a noise component are facilitated here too.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_estep">MoE_estep</a></code>, <code><a href="#topic+MoE_cstep">MoE_cstep</a></code>, <code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
hema  &lt;- ais[,3:7]
model &lt;- MoE_clust(hema, G=3, gating= ~ BMI + sex, modelNames="EEE", network.data=ais)
Dens  &lt;- MoE_dens(data=hema, mus=model$parameters$mean,
                  sigs=model$parameters$variance, log.tau=log(model$parameters$pro))

# Construct the z matrix and compute the log-likelihood
Estep &lt;- MoE_estep(Dens=Dens)
(ll   &lt;- Estep$loglik)

# Check that the z matrix &amp; classification are the same as those from the model
identical(max.col(Estep$z), as.integer(unname(model$classification))) #TRUE
identical(Estep$z, model$z)                                           #TRUE

# The same can be done for models with expert covariates &amp;/or a noise component
# Note for models with expert covariates that the mean has to be supplied as 0,
# and the data has to be supplied as "resid.data"
m2    &lt;- MoE_clust(hema, G=2, expert= ~ sex, modelNames="EVE", network.data=ais, tau0=0.1)
Dens2 &lt;- MoE_dens(data=m2$resid.data, sigs=m2$parameters$variance, mus=0, 
                  log.tau=log(m2$parameters$pro), Vinv=m2$parameters$Vinv)
</code></pre>

<hr>
<h2 id='MoE_entropy'>Entropy of a fitted MoEClust model</h2><span id='topic+MoE_entropy'></span>

<h3>Description</h3>

<p>Calculates the normalised entropy of a fitted MoEClust model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_entropy(x,
            group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_entropy_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with gating and/or expert covariates and/or a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_entropy_+3A_group">group</code></td>
<td>
<p>A logical (defaults to <code>FALSE</code>) indicating whether component-specific average entropies should be returned instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>group</code> is <code>FALSE</code>, this function calculates the normalised entropy via </p>
<p style="text-align: center;"><code class="reqn">H=-\frac{1}{n\log(G)}\sum_{i=1}^n\sum_{g=1}^G\hat{z}_{ig}\log(\hat{z}_{ig})</code>
</p>
<p>,
where <code class="reqn">n</code> and <code class="reqn">G</code> are the sample size and number of components, respectively, and <code class="reqn">\hat{z}_{ig}</code> is the estimated posterior probability at convergence that observation <code class="reqn">i</code> belongs to component <code class="reqn">g</code>. Note that <code>G=x$G</code> for models without a noise component and <code>G=x$G + 1</code> for models with a noise component. 
</p>
<p>When <code>group</code> is <code>TRUE</code>, </p>
<p style="text-align: center;"><code class="reqn">H_i=-\frac{1}{\log(G)}\sum_{g=1}^G\hat{z}_{ig}\log(\hat{z}_{ig})</code>
</p>
<p> is computed for each observation and averaged according to the MAP classification.
</p>


<h3>Value</h3>

<p>When <code>group</code> is <code>FALSE</code>, a single number, given by <code class="reqn">1-H</code>, in the range [0,1], such that <em>larger</em> values indicate clearer separation of the clusters. Otherwise, a vector of length <code>G</code> containing the per-component averages of the observation-specific entries is returned.
</p>


<h3>Note</h3>

<p>This function will always return a normalised entropy of <code>1</code> for models fitted using the <code>"CEM"</code> algorithm (see <code><a href="#topic+MoE_control">MoE_control</a></code>), or models with only one component.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="#topic+MoE_AvePP">MoE_AvePP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], G=3, gating= ~ BMI + sex, 
                 modelNames="EEE", network.data=ais)

# Calculate the normalised entropy
MoE_entropy(res)

# Calculate the normalised entropy per cluster
MoE_entropy(res, group=TRUE)
</code></pre>

<hr>
<h2 id='MoE_estep'>E-step for MoEClust Models</h2><span id='topic+MoE_estep'></span>

<h3>Description</h3>

<p>Softmax function to compute the responsibility matrix z and the log-likelihood for MoEClust models, with the aid of <code><a href="#topic+MoE_dens">MoE_dens</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_estep(data,
          mus,
          sigs,
          log.tau = 0L,
          Vinv = NULL,
          Dens = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_estep_+3A_data">data</code></td>
<td>
<p>If there are no expert network covariates, <code>data</code> should be a numeric matrix or data frame, wherein rows correspond to observations (n) and columns correspond to variables (d). If there are expert network covariates, this should be a list of length G containing matrices/data.frames of (multivariate) WLS residuals for each component.</p>
</td></tr>
<tr><td><code id="MoE_estep_+3A_mus">mus</code></td>
<td>
<p>The mean for each of G components. If there is more than one component, this is a matrix whose k-th column is the mean of the k-th component of the mixture model. For the univariate models, this is a G-vector of means. In the presence of expert network covariates, all values should be equal to <code>0</code>.</p>
</td></tr>
<tr><td><code id="MoE_estep_+3A_sigs">sigs</code></td>
<td>
<p>The <code>variance</code> component in the parameters list from the output to e.g. <code><a href="#topic+MoE_clust">MoE_clust</a></code>. The components of this list depend on the specification of <code>modelName</code> (see <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code> for details). The number of components <code>G</code>, the number of variables <code>d</code>, and the <code>modelName</code> are inferred from <code>sigs</code>.</p>
</td></tr>
<tr><td><code id="MoE_estep_+3A_log.tau">log.tau</code></td>
<td>
<p>If covariates enter the gating network, an n times G matrix of mixing proportions, otherwise a G-vector of mixing proportions for the components of the mixture. <strong>Must</strong> be on the log-scale in both cases. The default of <code>0</code> effectively means densities (or log-densities) aren't scaled by the mixing proportions.</p>
</td></tr>
<tr><td><code id="MoE_estep_+3A_vinv">Vinv</code></td>
<td>
<p>An estimate of the reciprocal hypervolume of the data region. See the function <code><a href="#topic+noise_vol">noise_vol</a></code>. Used only if an initial guess as to which observations are noise is supplied. Mixing proportion(s) must be included for the noise component also.</p>
</td></tr>
<tr><td><code id="MoE_estep_+3A_dens">Dens</code></td>
<td>
<p>(Optional) A numeric matrix whose <code>[i,k]</code>-th entry is the <strong>log</strong>-density of observation <em>i</em> in component <em>k</em>, scaled by the mixing proportions, to which the <code><a href="mclust.html#topic+softmax">softmax</a></code> function is to be applied, typically obtained by <code><a href="#topic+MoE_dens">MoE_dens</a></code> but this is not necessary. If this is supplied, all other arguments are ignored, otherwise <code><a href="#topic+MoE_dens">MoE_dens</a></code> is called according to the other supplied arguments. If a vector is supplied, it will be coerced to a matrix with one row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>
<table role = "presentation">
<tr><td><code>z</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>G</code> columns containing the probability of cluster membership for each of <code>n</code> observations and <code>G</code> clusters.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The estimated log-likelihood, computed efficiently via <code><a href="mclust.html#topic+logsumexp">logsumexp</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This softmax function is intended for joint use with <code><a href="#topic+MoE_dens">MoE_dens</a></code>, using the <strong>log</strong>-densities. Caution is advised using this function without explicitly naming the arguments. Models with a noise component are facilitated here too.
</p>
<p>The E-step can be replaced by a C-step, see <code><a href="#topic+MoE_cstep">MoE_cstep</a></code> and the <code>algo</code> argument to <code><a href="#topic+MoE_control">MoE_control</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_dens">MoE_dens</a></code>, <code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_cstep">MoE_cstep</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="mclust.html#topic+logsumexp">logsumexp</a></code>, <code><a href="mclust.html#topic+mclustVariance">mclustVariance</a></code>, <code><a href="mclust.html#topic+softmax">softmax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
hema   &lt;- ais[,3:7]
model  &lt;- MoE_clust(hema, G=3, gating= ~ BMI + sex, modelNames="EEE", network.data=ais)
Dens   &lt;- MoE_dens(data=hema, mus=model$parameters$mean,
                   sigs=model$parameters$variance, log.tau=log(model$parameters$pro))

# Construct the z matrix and compute the log-likelihood
Estep  &lt;- MoE_estep(Dens=Dens)
(ll    &lt;- Estep$loglik)

# Check that the z matrix &amp; classification are the same as those from the model
identical(max.col(Estep$z), as.integer(unname(model$classification))) #TRUE
identical(Estep$z, model$z)                                           #TRUE

# Call MoE_estep directly
Estep2 &lt;- MoE_estep(data=hema, sigs=model$parameters$variance,
                    mus=model$parameters$mean, log.tau=log(model$parameters$pro))
identical(Estep2$loglik, ll)                                          #TRUE

# The same can be done for models with expert covariates &amp;/or a noise component
# Note for models with expert covariates that the mean has to be supplied as 0,
# and the data has to be supplied as "resid.data"
m2     &lt;- MoE_clust(hema, G=2, expert= ~ sex, modelNames="EVE", network.data=ais, tau0=0.1)
Estep3 &lt;- MoE_estep(data=m2$resid.data, sigs=m2$parameters$variance, mus=0, 
                    log.tau=log(m2$parameters$pro), Vinv=m2$parameters$Vinv)
</code></pre>

<hr>
<h2 id='MoE_gpairs'>Generalised Pairs Plots for MoEClust Mixture Models</h2><span id='topic+MoE_gpairs'></span>

<h3>Description</h3>

<p>Produces a matrix of plots showing pairwise relationships between continuous response variables and continuous/categorical/logical/ordinal associated covariates, as well as the clustering achieved, according to fitted MoEClust mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_gpairs(res,
           response.type = c("points", "uncertainty", "density"),
           subset = list(...),
           scatter.type = c("lm", "points"),
           conditional = c("stripplot", "boxplot"),
           addEllipses = c("outer", "yes", "no", "inner", "both"),
           expert.covar = TRUE,
           border.col = c("purple", "black", "brown", "brown", "navy"),
           bg.col = c("cornsilk", "white", "palegoldenrod", "palegoldenrod", "cornsilk"),
           outer.margins = list(bottom = grid::unit(2, "lines"),
                                left = grid::unit(2, "lines"),
                                top = grid::unit(2, "lines"),
                                right = grid::unit(2, "lines")),
           outer.labels = NULL,
           outer.rot = c(0, 90),
           gap = 0.05,
           buffer = 0.025,
           uncert.cov = FALSE,
           scatter.pars = list(...),
           density.pars = list(...),
           diag.pars = list(...),
           stripplot.pars = list(...),
           boxplot.pars = list(...),
           barcode.pars = list(...),
           mosaic.pars = list(...),
           axis.pars = list(...),
           ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_gpairs_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_response.type">response.type</code></td>
<td>
<p>The type of plot desired for the scatterplots comparing continuous response variables. Defaults to <code>"points"</code>. See <code>scatter.pars</code> below.
</p>
<p>Points can also be sized according to their associated clustering uncertainty with the option <code>"uncertainty"</code>. In doing so, the transparency of the points will also be proportional to their clustering uncertainty, provided the device supports transparency. See also <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code> for an alternative means of visualising observation-specific cluster uncertainties (especially for univariate data). See <code>scatter.pars</code> below, and note that models fitted via the <code>"CEM"</code> algorithm will have no associated clustering uncertainty.
</p>
<p>Alternatively, the bivariate <em>parametric</em> <code>"density"</code> contours can be displayed (see <code>density.pars</code>), provided there is at least one Gaussian component in the model. Caution is advised when producing density plots for models with covariates in the expert network; the required number of evaluations of the (multivariate) Gaussian density for each panel (<code>res$G * prod(density.pars$grid.size)</code>) increases by a factor of <code>res$n</code>, thus plotting may be slow (particularly for large data sets). However, this is offset somewhat by using pre-calculated densities from the corresponding upper-triangular panels when producing the lower-triangular panels. See <code>density.pars</code> below.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_subset">subset</code></td>
<td>
<p>A list giving named arguments for producing only a subset of panels:
</p>

<dl>
<dt><code>show.map</code></dt><dd><p>Logical indicating whether to show panels involving the MAP classification (defaults to <code>TRUE</code>, unless there is only one component, in which case the MAP classification is never plotted.).</p>
</dd>
<dt><code>data.ind</code></dt><dd><p>For subsetting response variables: a vector of column indices corresponding to the variables in the columns of <code>res$data</code> which should be shown. Defaults to all. Can be <code>0</code>, in order to suppress plotting the response variables. Alternatively, character strings matching the column names of <code>res$data</code> can be supplied here.</p>
</dd>
<dt><code>cov.ind</code></dt><dd><p>For subsetting covariates: a vector of column indices corresponding to the covariates in the columns <code>res$net.covs</code> which should be shown. Defaults to all. Can be <code>0</code>, in order to suppress plotting the covariates. Alternatively, character strings matching the column names of <code>res$net.covs</code> can be supplied here.</p>
</dd>
<dt><code>submat</code></dt><dd><p>Can take the values <code>"all"</code> (default), <code>"upper"</code>, <code>"lower"</code>, or <code>"diagonal"</code>, for displaying all panels or only the upper/lower triangular panels or diagonal (marginal) panels of the plot matrix.</p>
</dd>
</dl>

<p>The results of the subsetting must ensure that at least one panel of some sort can be plotted. The arguments <code>data.ind</code> and <code>cov.ind</code> can also be used to simply reorder the panels, without actually subsetting. Diagonal panels are always drawn, regardless of the value of <code>submat</code> (but can be somewhat suppressed using <code>diag.pars$show.hist=FALSE</code> <strong>and</strong> <code>diag.pars$show.dens=FALSE</code>; see <code>diag.pars</code> below). When <code>diag.pars$diagonal=TRUE</code> (the default), the triangular portions are the <code>"upper"</code>-right and <code>"lower"</code>-left, whereas they are the <code>"upper"</code>-left and <code>"lower"</code>-right when <code>diag.pars$diagonal=FALSE</code>. Generally, <code>submat="upper"</code> should be preferable to <code>submat="lower"</code>, as it ensures that response variables and covariates are displayed as appropriate on the y-axes and x-axes, respectively.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_scatter.type">scatter.type</code></td>
<td>
<p>A vector of length 2 (or 1) giving the plot type for the upper and lower triangular portions of the plot, respectively, pertaining to the associated covariates. Defaults to <code>"lm"</code> for covariate vs. response panels and <code>"points"</code> otherwise. Only relevant for models with continuous covariates in the gating &amp;/or expert network. <code>"ci"</code> and <code>"lm"</code> type plots are only produced for plots pairing covariates with response, and never response vs. response or covariate vs. covariate. Note that lines &amp;/or confidence intervals will only be drawn for continuous covariates included in the expert network; to include covariates included only in the gating network also, the options <code>"lm2"</code> or <code>"ci2"</code> can be used but this is not generally advisable. See <code>scatter.pars</code> below.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_conditional">conditional</code></td>
<td>
<p>A vector of length 2 (or 1) giving the plot type for the upper and lower triangular portions of the plot, respectively, for plots involving a mix of categorical and continuous variables. Defaults to <code>"stripplot"</code> in the upper triangle and <code>"boxplot"</code> in the lower triangle (see <code><a href="lattice.html#topic+panel.stripplot">panel.stripplot</a></code> and <code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>). <code>"violin"</code> and <code>"barcode"</code> plots can also be produced. Only relevant for models with categorical covariates in the gating &amp;/or expert network, unless <code>show.MAP</code> is <code>TRUE</code>. Comparisons of two categorical variables (which can only ever be covariates or the MAP classification) are always displayed via mosaic plots (see <code><a href="vcd.html#topic+strucplot">strucplot</a></code>). 
</p>
<p>All <code>conditional</code> panel types can be customised further; see <code>stripplot.pars</code>, <code>boxplot.pars</code> (for both <code>"boxplot"</code> and <code>"violin"</code> plots), <code>barcode.pars</code>, and <code>mosaic.pars</code> below. Note that when <code>conditional</code> is of length 1, that plot type will be used in <em>both</em> the upper and lower triangular portions of the plot, where relevant.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_addellipses">addEllipses</code></td>
<td>
<p>Controls whether to add MVN ellipses with axes corresponding to the within-cluster covariances for the response data. The options <code>"inner"</code> and <code>"outer"</code> (the default) will colour the axes or the perimeter of those ellipses, respectively, according to the cluster they represent (according to <code>scatter.pars$eci.col</code>). The option <code>"both"</code> will obviously colour both the axes and the perimeter. The <code>"yes"</code> or <code>"no"</code> options merely govern whether the ellipses are drawn, i.e. <code>"yes"</code> draws ellipses without any colouring. Ellipses are only ever drawn for multivariate data, and only when <code>response.type</code> is <code>"points"</code> or <code>"uncertainty"</code>.
</p>
<p>Ellipses are centered on the posterior mean of the fitted values when there are expert network covariates, otherwise on the posterior mean of the response variables. In the presence of expert network covariates, the component-specific covariance matrices are also (by default, via the argument <code>expert.covar</code> below) modified for plotting purposes via the function <code><a href="#topic+expert_covar">expert_covar</a></code>, in order to account for the extra variability of the means, usually resulting in bigger shapes &amp; sizes for the MVN ellipses.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_expert.covar">expert.covar</code></td>
<td>
<p>Logical (defaults to <code>TRUE</code>) governing whether the extra variability in the component means is added to the MVN ellipses corresponding to the component covariance matrices in the presence of expert network covariates. See the function <code><a href="#topic+expert_covar">expert_covar</a></code>. Only relevant when <code>response.type</code> is <code>"points"</code> or <code>"uncertainty"</code> when <code>addEllipses</code> is invoked accordingly, and only relevant for models with expert network covariates and multivariate responses.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_border.col">border.col</code></td>
<td>
<p>A vector of length 5 (or 1) containing <em>border</em> colours for plots against the MAP classification, response vs. response, covariate vs. response, response vs. covariate, and covariate vs. covariate panels, respectively.
</p>
<p>Defaults to <code>c("purple", "black", "brown", "brown", "navy")</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_bg.col">bg.col</code></td>
<td>
<p>A vector of length 5 (or 1) containing <em>background</em> colours for plots against the MAP classification, response vs. response, covariate vs. response, response vs. covariate, and covariate vs. covariate panels, respectively.
</p>
<p>Defaults to <code>c("cornsilk", "white", "palegoldenrod", "palegoldenrod", "cornsilk")</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_outer.margins">outer.margins</code></td>
<td>
<p>A list of length 4 with units as components named <code>bottom</code>, <code>left</code>, <code>top</code>, and <code>right</code>, giving the outer margins; the defaults uses two lines of text. A vector of length 4 with units (ordered properly) will work, as will a vector of length 4 with numeric variables (interpreted as lines). May need to be increased to accommodate outer labels in some cases.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_outer.labels">outer.labels</code></td>
<td>
<p>The default is typically <code>NULL</code>, for alternating labels around the perimeter. If <code>"all"</code>, all labels are printed, and if <code>"none"</code>, no labels are printed. If <code>subset$submat="upper"</code> or <code>subset$submat="lower"</code>, <code>outer.labels</code> instead defaults to <code>"all"</code>.
</p>
<p>Note that axis labels always correspond to the <em>range</em> of the depicted variable, and thus should not be interpreted as indicating counts or densities for the diagonal panels when <code>diag.pars$show.hist=TRUE</code> &amp;/or <code>diag.pars$show.dens=TRUE</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_outer.rot">outer.rot</code></td>
<td>
<p>A 2-vector (<code>x</code>, <code>y</code>) rotating the top/bottom outer labels <code>x</code> degrees and the left/right outer labels <code>y</code> degrees. Only works for categorical labels of boxplot, mosaic, strip plot, and violin plot panels. Defaults to <code>c(0, 90)</code>. Reordering via <code>data.ind</code> or <code>cov.ind</code> may improve appearance of outer labels in some cases.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_gap">gap</code></td>
<td>
<p>The gap between the tiles; defaulting to <code>0.05</code> of the width of a tile.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_buffer">buffer</code></td>
<td>
<p>The fraction by which to expand the range of quantitative variables to provide plots that will not truncate plotting symbols. Defaults to <code>0.025</code>, i.e. 2.5 percent of the range. Particularly useful when ellipses are drawn (see <code>addEllipses</code>) to ensure ellipses are visible in full.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_uncert.cov">uncert.cov</code></td>
<td>
<p>A logical indicating whether the expansion factor for points on plots involving covariates should also be modified when <code>response.type="uncertainty"</code>. Defaults to <code>FALSE</code>, and only relevant for scatterplot and strip plot panels. When <code>TRUE</code>, <code>scatter.pars$uncert.pch</code> is invoked as the plotting symbols for covariate-related scatterplot and strip plot panels, otherwise <code>scatter.pars$scat.pch</code> and <code>stripplot.pars$strip.pch</code> are invoked for such panels.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_scatter.pars">scatter.pars</code></td>
<td>
<p>A list supplying select parameters for the continuous vs. continuous scatterplots.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(scat.pch=res$classification, uncert.pch=19,
     scat.col=res$classification, scat.size=unit(0.25, "char"), 
     eci.col=1:res$G, noise.size=unit(0.2, "char")),</pre>
<p>where <code>scat.pch</code>, <code>scat.col</code>, and <code>scat.size</code> give the plotting symbols, colours, and sizes of the points in scatterplot panels, respectively. Note that <code>eci.col</code> gives both a) the colour of the fitted lines &amp;/or confidence intervals for expert-related panels when <code>scatter.type</code> is one of <code>"ci"</code> or <code>"lm"</code> and b) the colour of the ellipses (if any) when <code>addEllipses</code> is one of <code>"outer"</code>, <code>"inner"</code>, or <code>"both"</code> and the response data is multivariate. Note that <code>eci.col</code> will inherit a suitable default from <code>scat.col</code> instead if the latter is supplied but the former is not. 
</p>
<p>Note also that <code>scat.size</code> will be modified on an observation-by-observation level when <code>response.type</code> is <code>"uncertainty"</code>. Furthermore, note that the behaviour for plotting symbols when <code>response.type="uncertainty"</code> changes compared to <code>response.type="points"</code> depending on the value of the <code>uncert.cov</code> argument above. <code>uncert.pch</code> gives the plotting symbol used for all scatterplot (and strip plot) panels when <code>response.type="uncertainty"</code> and <code>uncert.cov</code> is <code>TRUE</code>. However, when <code>uncert.cov</code> is <code>FALSE</code>, <code>scat.pch</code> is invoked for scatterplots involving covariates and <code>uncert.pch</code> is used for panels involving only response variables. Finally, <code>noise.size</code> can be used to modify <code>scat.size</code> for observations assigned to the noise component (if any), but only when <code>response.type="points"</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_density.pars">density.pars</code></td>
<td>
<p>A list supplying select parameters for visualising the bivariate <em>parametric</em> density contours, only when <code>response.type</code> is <code>"density"</code>.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(grid.size=c(100, 100), dcol="grey50", dens.points=FALSE,
     nlevels=11, show.labels=!dens.points, label.style="mixed"),</pre>
<p>where <code>grid.size</code> is a vector of length two giving the number of points in the x &amp; y directions of the grid over which the density is evaluated, respectively (though <code>density.pars$grid.size</code> can also be supplied as a scalar, which will be automatically recycled to a vector of length 2), and <code>dcol</code> is either a single colour or a vector of length <code>nlevels</code> colours. <code>dens.points</code> governs whether points should be overlaid when <code>response.type="density"</code> (in other words, <code>dens.points=TRUE</code> is akin to specifying <code>response.type="points"</code> and <code>response.type="density"</code> simultaneously) and <code>show.labels</code> governs whether the density contours should be labelled. Note that contours are not labelled when <code>dens.points=TRUE</code> by default. Finally, <code>label.style</code> can take the values <code>"mixed"</code>, <code>"flat"</code>, or <code>"align"</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_diag.pars">diag.pars</code></td>
<td>
<p>A list supplying select parameters for panels along the diagonal.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(diag.fontsize=9, diagonal=TRUE, hist.color=hist.color, 
     show.hist=TRUE, show.counts=TRUE, show.dens=FALSE, dens.grid=100),</pre>
<p>where <code>hist.color</code> is a vector of length 4, giving the colours for the response variables, gating covariates, expert covariates, and covariates entering both networks, respectively. By default, diagonal panels for response variables are <code>ifelse(diag.pars$show.dens, "white", "black")</code> and covariates of any kind are <code>"dimgrey"</code>. <code>hist.color</code> also governs the outer colour for mosaic panels and the fill colour for boxplot, and violin panels (except for those involving the MAP classification; see <code>boxplot.pars</code> below). However, in the case of response vs. (categorical) covariates boxplots and violin plots, the fill colour is always <code>"white"</code>. The MAP classification is always coloured by cluster membership, by default. The argument <code>show.counts</code> is only relevant for categorical variables.
</p>
<p>The argument <code>show.dens</code> toggles whether <em>parametric</em> density estimates are drawn over the diagonal panels for each response variable. When <code>show.dens=TRUE</code>, the component densities are shown via thin lines, with colours given by <code>scatter.pars$scat.col</code>, while a thick <code>"black"</code> line is used for the overall mixture density. This argument can be used with or without <code>show.hist</code> also being <code>TRUE</code>. Finally, the grid size when <code>show.dens=TRUE</code> is given by <code>diag.grid=100</code> by default. As per <code>response.type="density"</code>, plotting is liable to be a little slower when <code>show.dens=TRUE</code> for models with expert network covariates. This is why <code>show.dens=FALSE</code> by default; otherwise it is recommended to be set to <code>TRUE</code>.
</p>
<p>When <code>diagonal=TRUE</code> (the default), the diagonal from the top left to the bottom right is used for displaying the marginal distributions of variables (via histograms, with or without overlaid density estimates, or barplots, as appropriate). Specifying <code>diagonal=FALSE</code> will place the diagonal running from the top right down to the bottom left (with <code>subset$submat</code> accounted for accordingly).</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_stripplot.pars">stripplot.pars</code></td>
<td>
<p>A list supplying select parameters for continuous vs. categorical panels when one or both of the entries of <code>conditional</code> is <code>"stripplot"</code>.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(strip.pch=res$classification, strip.size=unit(0.5, "char"),
     strip.col=res$classification, jitter=TRUE, size.noise=unit(0.4, "char")),</pre>
<p>where <code>strip.size</code> and <code>size.noise</code> retain the definitions for the similar arguments under <code>scatter.pars</code> above. However, <code>stripplot.pars$size.noise</code> is invoked regardless of the <code>response.type</code> (in contrast to <code>scatter.pars$noise.size</code>). Notably, <code>strip.col</code> will inherit a suitable default from <code>scatter.pars$scat.col</code> if the latter is supplied but the former is not. Note also that the <code>strip.pch</code> default is modified to <code>scatter.pars$uncert.pch</code> if <code>uncert.cov</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_boxplot.pars">boxplot.pars</code></td>
<td>
<p>A list supplying select parameters for continuous vs. categorical panels when one or both of the entries of <code>conditional</code> is <code>"boxplot"</code> or <code>"violin"</code>.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(box.pch="|", box.col="black", varwidth=FALSE,
     notch=FALSE, notch.frac=0.5, box.fill=1:res$G).</pre>
<p>All of the above are relevant for <code>"boxplot"</code> panels, are passed to <code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code> when producing boxplots, and retain the same definitions as the similarly named arguments therein. However, only <code>box.col</code>, <code>varwidth</code>, and <code>box.fill</code> are relevant for <code>"violin"</code> panels, and in both cases <code>box.fill</code> is only invoked for panels where the categorical variable is the MAP classification (i.e. when <code>subset$show.map=TRUE</code>). See <code>diag.pars$hist.color</code> for controlling the colours of non-MAP-related boxplot/violin panels. Notably, <code>box.fill</code> will inherit a suitable default from <code>scatter.pars$scat.col</code> if the latter is supplied but the former is not.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_barcode.pars">barcode.pars</code></td>
<td>
<p>A list supplying select parameters for continuous vs. categorical panels when one or both of the entries of <code>conditional</code> is <code>"barcode"</code>.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(bar.col=res$G:1, nint=0, ptsize=scatter.pars$scat.size, 
     ptpch=scatter.pars$scat.pch, bcspace=NULL, use.points=FALSE),</pre>
<p>where <code>bar.col</code> will inherit a suitable default from <code>scatter.pars$scat.col</code> if the latter is supplied but the former is not. See the help file for <code>barcode::barcode</code> for details on the remaining arguments. Note that the arguments <code>ptsize</code> and <code>ptpch</code>, which are only relevant when <code>use.points=TRUE</code> are given by the corresponding <code>scatter.pars$scat.size</code>/<code>scatter.pars$noise.size</code> and <code>scatter.pars$scat.pch</code> arguments, by default.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_mosaic.pars">mosaic.pars</code></td>
<td>
<p>A list supplying select parameters for categorical vs. categorical panels (if any). 
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(shade=NULL, gp_labels=grid::gpar(fontsize=9), 
     gp_args=list(), gp=list(), mfill=TRUE, mcol=1:res$G).</pre>
<p>The current default arguments and values thereof are passed through to <code><a href="vcd.html#topic+strucplot">strucplot</a></code> for producing mosaic tiles. When <code>shade</code> is not <code>FALSE</code>, <code>mfill</code> is a logical which governs the colouring scheme for panels (if any) involving the MAP classification. When <code>mfill</code> is <code>TRUE</code> (the default), <code>gp</code> is invoked here in such a way that tiles will inherit appropriate interior colours via <code>gp$fill</code> from <code>mcol</code> and a <code>"black"</code> outer colour via <code>gp$col</code>. When <code>mfill</code> is <code>FALSE</code>, or the panel involves two categorical covariates, the outer colours are inherited from <code>mcol</code> and the interior fill colour is inherited from <code>bg.col</code>. See <code>diag.pars$hist.color</code> for controlling the interior fill colour of non-MAP-related mosaic panels. Notably, <code>mcol</code> will inherit a suitable default from <code>scatter.pars$scat.col</code> if the latter is supplied but the former is not.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_axis.pars">axis.pars</code></td>
<td>
<p>A list supplying select parameters for controlling the axes.
</p>
<p><code>NULL</code> is equivalent to:
</p>
<pre>list(n.ticks=5, axis.fontsize=9).</pre>
<p>The argument <code>n.ticks</code> will be overwritten for categorical variables with fewer than 5 levels.</p>
</td></tr>
<tr><td><code id="MoE_gpairs_+3A_...">...</code></td>
<td>
<p>Catches unused arguments. Alternatively, named arguments can be passed directly here to any/all of <code>scatter.pars</code>, <code>density.pars</code>, <code>diag.pars</code>, <code>stripplot.pars</code>, <code>boxplot.pars</code>, <code>barcode.pars</code>, <code>mosaic.pars</code>, and <code>axis.pars</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generalised pairs plot showing all pairwise relationships between clustered response variables and associated gating &amp;/or expert network continuous &amp;/or categorical variables, coloured according to the MAP classification, with the marginal distributions of each variable along the diagonal.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> which accepts the default arguments, and also produces other types of plots. Caution is advised producing generalised pairs plots when the dimension of the data is large.
</p>
<p>Note that all colour-related defaults in <code>scatter.pars</code>, <code>stripplot.pars</code>, <code>barcode.pars</code>, and <code>mosaic.pars</code> above assume a specific colour-palette (see <code><a href="mclust.html#topic+mclust.options">mclust.options</a>("classPlotColors")</code>). Thus, for instance, specifying <code>scatter.pars$scat.col=res$classification</code> will produce different results compared to leaving this argument unspecified. This is especially true for models with a noise component, for which the default is handled quite differently (for one thing, <code>res$G</code> is the number of <em>non-noise</em> components). Similarly, all <code>pch</code>-related defaults in <code>scatter.pars</code> and <code>stripplot.pars</code> above assume a specific set of plotting symbols also (see <code><a href="mclust.html#topic+mclust.options">mclust.options</a>("classPlotSymbols")</code>). Generally, all colour and symbol related arguments are strongly recommended to be left at their default values, unless being supplied as a single character string, e.g. <code>"black"</code> for colours. To help in this regard, colour-related arguments sensibly inherent their defaults from <code>scatter.pars$scat.col</code> if that is supplied and the argument in question is not.
</p>


<h3>Warning</h3>

<p>For <code>MoEClust</code> models with more than one expert network covariate, fitted lines produced in continuous covariate vs. continuous response scatterplots via <code>scatter.type="lm"</code> or <code>scatter.type="ci"</code> will <strong>NOT</strong> correspond to the coefficients in the expert network (<code>res$expert</code>).
</p>
<p>Caution is advised when producing <code>"barcode"</code> plots for the <code>conditional</code> panels. In some cases, resizing the graphics device after the production of the plot will result in distortion because of the way the rotation of non-horizontal barcodes is performed. Thus, when <code>any(conditional == "barcode")</code>, it is advisable to ensure the dimensions of the overall plot are square. Furthermore, such plots may not display correctly anyway in RStudio's &ldquo;Plots&rdquo; pane and so a different graphics device may need to be used (but not subsequently resized).
</p>
<p>Caution is also advised when producing generalised pairs plots when the dimension of the data is large.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>
<p>Emerson, J. W., Green, W. A., Schloerke, B., Crowley, J., Cook, D., Hofmann, H. and Wickham, H. (2013). The generalized pairs plot. <em>Journal of Computational and Graphical Statistics</em>, 22(1): 79-91.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code>, <code><a href="#topic+expert_covar">expert_covar</a></code>, <code><a href="lattice.html#topic+panel.stripplot">panel.stripplot</a></code>, <code><a href="lattice.html#topic+panel.bwplot">panel.bwplot</a></code>, <code><a href="lattice.html#topic+panel.violin">panel.violin</a></code>, <code><a href="vcd.html#topic+strucplot">strucplot</a></code>, <code><a href="mclust.html#topic+mclust.options">mclust.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res   &lt;- MoE_clust(ais[,3:7], G=2, gating= ~ BMI, expert= ~ sex,
                   network.data=ais, modelNames="EVE")
MoE_gpairs(res)

# Produce the same plot, but with a violin plot in the lower triangle.
# Colour the outline of the mosaic tiles rather than the interior using mfill.
# Size points in the response vs. response panels by their clustering uncertainty.

MoE_gpairs(res, conditional=c("stripplot", "violin"),
           mfill=FALSE, response.type="uncertainty")

# Instead show the bivariate density contours of the response variables (without labels).
# (Plotting may be slow when response.type="density" for models with expert covariates.)
# Use different colours for histograms of covariates in the gating/expert/both networks.
# Also use different colours for response vs. covariate &amp; covariate vs. response panels.

MoE_gpairs(res, response.type="density", show.labels=FALSE, dens.points=TRUE,
           hist.color=c("black", "cyan", "hotpink", "chartreuse"),
           bg.col=c("whitesmoke", "white", "mintcream", "mintcream", "floralwhite"))
           
# Examine effect of expert.covar &amp; diag.grid in conjunction with show.dens &amp; show.hist
MoE_gpairs(res, show.dens=TRUE, expert.covar=FALSE, show.hist=FALSE, diag.grid=20)
MoE_gpairs(res, show.dens=TRUE, expert.covar=TRUE, show.hist=TRUE, diag.grid=200)
           
# Explore various options to subset and rearrange the panels
MoE_gpairs(res, data.ind=5:1, cov.ind=0, 
           show.map=FALSE, show.hist=FALSE, 
           submat="upper", diagonal=FALSE)          
           
# Produce a generalised pairs plot for a model with a noise component.
# Reorder the covariates and omit the variables "Hc" and "Hg".
# Use barcode plots for the categorical/continuous pairs.
# Magnify the size of scatter points assigned to the noise component.

resN  &lt;- MoE_clust(ais[,3:7], G=2, gating= ~ SSF + Ht, expert= ~ sex,
                   network.data=ais, modelNames="EEE", tau0=0.1, noise.gate=FALSE)
                   
# Note that non-horizontal barcode panels may not display correctly in RStudio's "Plots" pane 
# it may be necessary to first open a new device:
# dev.new()
MoE_gpairs(resN, data.ind=c(1,2,5), cov.ind=c(3,1,2), use.points=TRUE,
           conditional="barcode", noise.size=grid::unit(0.5, "char"))
           
# Plots can be modified to show only a single (diagonal) panel of interest
MoE_gpairs(resN, data.ind=0, cov.ind=0)
MoE_gpairs(resN, data.ind=0, cov.ind="sex", show.map=FALSE)
MoE_gpairs(resN, data.ind="RCC", cov.ind=0, show.map=FALSE, show.dens=TRUE)
</code></pre>

<hr>
<h2 id='MoE_mahala'>Mahalanobis Distance Outlier Detection for Multivariate Response</h2><span id='topic+MoE_mahala'></span>

<h3>Description</h3>

<p>Computes the Mahalanobis distance between the response variable(s) and the fitted values of linear regression models with multivariate or univariate responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_mahala(fit,
           resids,
           squared = FALSE,
           identity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_mahala_+3A_fit">fit</code></td>
<td>
<p>A fitted <code><a href="stats.html#topic+lm">lm</a></code> model, inheriting either the <code>"mlm"</code> or <code>"lm"</code> class.</p>
</td></tr>
<tr><td><code id="MoE_mahala_+3A_resids">resids</code></td>
<td>
<p>The residuals. Can be residuals for observations included in the model, or residuals arising from predictions on unseen data. Must be coercible to a matrix with the number of columns being the number of response variables. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="MoE_mahala_+3A_squared">squared</code></td>
<td>
<p>A logical. By default (<code>FALSE</code>), the generalized interpoint distance is computed. Set this flag to <code>TRUE</code> for the squared value.</p>
</td></tr>
<tr><td><code id="MoE_mahala_+3A_identity">identity</code></td>
<td>
<p>A logical indicating whether the identity matrix is used in place of the precision matrix in the Mahalanobis distance calculation. Defaults to <code>FALSE</code> for multivariate response data but defaults to <code>TRUE</code> for univariate response data, where <code>TRUE</code> corresponds to the use of the Euclidean distance. Setting <code>identity=TRUE</code> with multivariate data may be advisable when the dimensions of the data are such that the covariance matrix cannot be inverted (otherwise, the pseudo-inverse is used under the <code>FALSE</code> default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector giving the Mahalanobis distance (or squared Mahalanobis distance) between response(s) and fitted values for each observation.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>
<p>Mahalanobis, P. C. (1936). On the generalized distance in statistics. <em>Proceedings of the National Institute of Sciences, India</em>, 2(1): 49-55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ais)
hema &lt;- as.matrix(ais[,3:7])
mod  &lt;- lm(hema ~ sex + BMI, data=ais)
res  &lt;- hema - predict(mod)
MoE_mahala(mod, res, squared=TRUE)

data(CO2data)
CO2  &lt;- CO2data$CO2
GNP  &lt;- CO2data$GNP
mod2 &lt;- lm(CO2 ~ GNP, data=CO2data)
pred &lt;- predict(mod2)
res2 &lt;- CO2 - pred
maha &lt;- MoE_mahala(mod2, res2)

# Highlight outlying observations
plot(GNP, CO2, type="n", ylab=expression('CO'[2]))
lines(GNP, pred, col="red")
points(GNP, CO2, cex=maha, lwd=2)
text(GNP, CO2, col="blue", 
     labels=replace(as.character(CO2data$country), maha &lt; 1, ""))
     
# Replicate initialisation strategy using 2 randomly chosen components
# Repeat the random initialisation if necessary
# (until 'crit' at convergence is minimised)
G       &lt;- 3L
z       &lt;- sample(seq_len(G), nrow(CO2data), replace=TRUE)
old     &lt;- Inf
crit    &lt;- .Machine$double.xmax
while(crit &lt; old)   {
  Sys.sleep(1)
  old   &lt;- crit
  maha  &lt;- NULL
  plot(GNP, CO2, type="n", ylab=expression('CO'[2]))
  for(g in seq_len(G)) { 
   ind  &lt;- which(z == g)
   mod  &lt;- lm(CO2 ~ GNP, data=CO2data, sub=ind)
   pred &lt;- predict(mod, newdata=CO2data[,"CO2", drop=FALSE])
   maha &lt;- cbind(maha, MoE_mahala(mod, CO2 - pred))
   lines(GNP, pred, col=g + 1L)
  }
  min.M &lt;- rowMins(maha)
  crit  &lt;- sum(min.M)
  z     &lt;- max.col(maha == min.M)
  points(GNP, CO2, cex=min.M, lwd=2, col=z + 1L)
  text(GNP, CO2, col=z + 1L, 
       labels=replace(as.character(CO2data$country), which(min.M &lt;= 1), ""))
}
crit
</code></pre>

<hr>
<h2 id='MoE_news'>Show the NEWS file</h2><span id='topic+MoE_news'></span>

<h3>Description</h3>

<p>Show the <code>NEWS</code> file of the <span class="pkg">MoEClust</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_news()
</code></pre>


<h3>Value</h3>

<p>The <span class="pkg">MoEClust</span> <code>NEWS</code> file, provided the session is interactive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MoE_news()
</code></pre>

<hr>
<h2 id='MoE_plotCrit'>Model Selection Criteria Plot for MoEClust Mixture Models</h2><span id='topic+MoE_plotCrit'></span>

<h3>Description</h3>

<p>Plots the BIC, ICL, AIC, or log-likelihood values of a fitted <code>MoEClust</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_plotCrit(res,
             criterion = c("bic", "icl", "aic", "loglik", "df", "iters"),
             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_plotCrit_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_plotCrit_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to be plotted. Defaults to <code>"bic"</code>. Recall that <code><a href="#topic+MoE_control">MoE_control</a></code> only allows <code>"bic"</code>, <code>"icl"</code>, and <code>"aic"</code> to be used as model selection criteria within <code><a href="#topic+MoE_clust">MoE_clust</a></code>. The same applies to <code><a href="#topic+MoE_control">MoE_control</a></code>. Uppercase <code>crit</code> will be coerced to lowercase.</p>
</td></tr>
<tr><td><code id="MoE_plotCrit_+3A_...">...</code></td>
<td>
<p>Catches other arguments, or additional arguments to be passed to <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code> (or equivalent functions for the other <code>criterion</code> arguments). In particular, the argument <code>legendArgs</code> to <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code> can be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the values of the chosen <code>criterion</code>. The values themselves can also be returned invisibly.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code> which accepts the default arguments, and also produces other types of plots.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(ais)
# res   &lt;- MoE_clust(ais[,3:7], expert= ~ sex, network.data=ais)
# (crit &lt;- MoE_plotCrit(res))

# Plots can also be produced directly
# plot(res$ICL)
</code></pre>

<hr>
<h2 id='MoE_plotGate'>Plot MoEClust Gating Network</h2><span id='topic+MoE_plotGate'></span>

<h3>Description</h3>

<p>Plots the gating network for fitted MoEClust models, i.e. the observation index against the mixing proportions for that observation, coloured by cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_plotGate(res,
             x.axis = NULL,
             type = "b",
             pch = 1,
             xlab = "Observation",
             ylab = expression(widehat(tau)[g]),
             ylim = c(0, 1),
             col = NULL,
             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_plotGate_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_plotGate_+3A_x.axis">x.axis</code></td>
<td>
<p>Optional argument for the x-axis against which the mixing proportions are plotted. Defaults to <code>1:res$n</code> if missing. Supplying <code>x.axis</code> changes the defaults for the <code>type</code> and <code>xlab</code> arguments. Users are advised to only use quantities related to the gating network of the fitted model here. Furthermore, use of the <code>x.axis</code> argument is not recommended for models with more than one gating network covariate.</p>
</td></tr>
<tr><td><code id="MoE_plotGate_+3A_type">type</code>, <code id="MoE_plotGate_+3A_pch">pch</code>, <code id="MoE_plotGate_+3A_xlab">xlab</code>, <code id="MoE_plotGate_+3A_ylab">ylab</code>, <code id="MoE_plotGate_+3A_ylim">ylim</code>, <code id="MoE_plotGate_+3A_col">col</code></td>
<td>
<p>These graphical parameters retain their definitions from <code><a href="graphics.html#topic+matplot">matplot</a></code>. <code>col</code> defaults to the settings in <code><a href="mclust.html#topic+mclust.options">mclust.options</a></code>. Note that the default value of <code>type</code> changes depending on whether <code>x.axis</code> is supplied and whether the gating network contains multiple covariates &amp;/or categorical covariates.</p>
</td></tr>
<tr><td><code id="MoE_plotGate_+3A_...">...</code></td>
<td>
<p>Catches unused arguments, or additional arguments to be passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the gating network of the fitted MoEClust model. The parameters of the gating network can also be returned invisibly.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_plotGate">MoE_plotGate</a></code> which accepts the default arguments, and also produces other types of plots.
</p>
<p>By default, the noise component (if any) will be coloured <code>"darkgrey"</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res   &lt;- MoE_clust(ais[,3:7], gating= ~ BMI, G=3, modelNames="EEE",
                   network.data=ais, noise.gate=FALSE, tau0=0.1)

# Plot against the observation index and examine the gating network coefficients
(gate &lt;- MoE_plotGate(res))

# Plot against BMI
MoE_plotGate(res, x.axis=ais$BMI, xlab="BMI")

# Plot against a categorical covariate
res2  &lt;- MoE_clust(ais[,3:7], gating= ~ sex, G=3, modelNames="EVE", network.data=ais)
MoE_plotGate(res2, x.axis=ais$sex, xlab="sex")
</code></pre>

<hr>
<h2 id='MoE_plotLogLik'>Plot the Log-Likelihood of a MoEClust Mixture Model</h2><span id='topic+MoE_plotLogLik'></span>

<h3>Description</h3>

<p>Plots the log-likelihood at every iteration of the EM/CEM algorithm used to fit a MoEClust mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_plotLogLik(res,
               type = "l",
               xlab = "Iteration",
               ylab = "Log-Likelihood",
               xaxt = "n",
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_plotLogLik_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_plotLogLik_+3A_type">type</code>, <code id="MoE_plotLogLik_+3A_xlab">xlab</code>, <code id="MoE_plotLogLik_+3A_ylab">ylab</code>, <code id="MoE_plotLogLik_+3A_xaxt">xaxt</code></td>
<td>
<p>These graphical parameters retain their usual definitions from <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="MoE_plotLogLik_+3A_...">...</code></td>
<td>
<p>Catches unused arguments, or additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the log-likelihood versus the number EM iterations. A list with the vector of log-likelihood values and the final value at convergence can also be returned invisibly.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_plotLogLik">MoE_plotLogLik</a></code> which accepts the default arguments, and also produces other types of plots.
</p>
<p><code>res$LOGLIK</code> can also be plotted, to compare maximal log-likelihood values for all fitted models.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], gating= ~ BMI, expert= ~ sex, tau0=0.1,
                 G=2, modelNames="EVE", network.data=ais)
(ll &lt;- MoE_plotLogLik(res))
</code></pre>

<hr>
<h2 id='MoE_Similarity'>Plot the Similarity Matrix of a MoEClust Mixture Model</h2><span id='topic+MoE_Similarity'></span>

<h3>Description</h3>

<p>Produces a heatmap of the similarity matrix constructed from the <code>res$z</code> matrix at convergence of a MoEClust mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_Similarity(res,
               col = grDevices::heat.colors(30L, rev=TRUE), 
               reorder = TRUE, 
               legend = TRUE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_Similarity_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_Similarity_+3A_col">col</code></td>
<td>
<p>A vector of colours as per <code><a href="graphics.html#topic+image">image</a></code>. Will be checked for validity.</p>
</td></tr>
<tr><td><code id="MoE_Similarity_+3A_reorder">reorder</code></td>
<td>
<p>A logical (defaults to <code>TRUE</code>) indicating whether observations should be reordered for visual clarity.</p>
</td></tr>
<tr><td><code id="MoE_Similarity_+3A_legend">legend</code></td>
<td>
<p>A logical (defaults to <code>TRUE</code>) indicating whether to append a colour key legend.</p>
</td></tr>
<tr><td><code id="MoE_Similarity_+3A_...">...</code></td>
<td>
<p>Catches unused arguments, or arguments to be passed to <code><a href="stats.html#topic+hclust">hclust</a></code> when <code>reorder=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The similarity matrix in the form of a heatmap is plotted; the matrix itself can also be returned invisibly. The invisibly returned matrix will also be reordered if <code>reordered=TRUE</code>.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_Similarity">MoE_Similarity</a></code> which accepts the default arguments, and also produces other types of plots.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
mod &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EEE", gating= ~ SSF + Ht,
                 expert= ~ sex, network.data=ais, tau0=0.1, noise.gate=FALSE)
sim &lt;- MoE_Similarity(mod)
</code></pre>

<hr>
<h2 id='MoE_stepwise'>Stepwise model/variable selection for MoEClust models</h2><span id='topic+MoE_stepwise'></span>

<h3>Description</h3>

<p>Conducts a greedy forward stepwise search to identify the optimal <code>MoEClust</code> model according to some <code>criterion</code>. Components and/or <code>gating</code> covariates and/or <code>expert</code> covariates are added to new <code><a href="#topic+MoE_clust">MoE_clust</a></code> fits at each step, while each step is evaluated for all valid <code>modelNames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_stepwise(data,
             network.data = NULL,
             gating = NULL,
             expert = NULL,
             modelNames = NULL,
             fullMoE = FALSE,
             noise = FALSE,
             initialModel = NULL,
             initialG = NULL,
             stepG = TRUE,
             criterion = c("bic", "icl", "aic"),
             equalPro = c("all", "both", "yes", "no"),
             noise.gate = c("all", "both", "yes", "no"),
             verbose = interactive(),
             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_stepwise_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. Categorical variables are not allowed. If a matrix or data frame, rows correspond to observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_network.data">network.data</code></td>
<td>
<p>An optional matrix or data frame in which to look for the covariates specified in the <code>gating</code> &amp;/or <code>expert</code> networks, if any. Must include column names. Columns in <code>network.data</code> corresponding to columns in <code>data</code> will be automatically removed. While a single covariate can be supplied as a vector (provided the '<code>$</code>' operator or '<code>[]</code>' subset operator are not used), it is safer to supply a named 1-column matrix or data frame in this instance.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_gating">gating</code></td>
<td>
<p>A vector giving the names of columns in <code>network.data</code> used to define the scope of the gating network. By default, the initial model will contain no covariates (unless <code>initialModel</code> is supplied with gating covariates), thereafter all variables in <code>gating</code> (save for those in <code>initialModel</code>, if any) will be considered for inclusion where appropriate.
</p>
<p>If <code>gating</code> is not supplied (or set to <code>NULL</code>), <em>all</em> variables in <code>network.data</code> will be considered for the gating network. <code>gating</code> can also be supplied as <code>NA</code>, in which case <em>no</em> gating network covariates will ever be considered (save for those in <code>initialModel</code>, if any). Supplying <code>gating</code> and <code>expert</code> can be used to ensure different subsets of covariates enter different parts of the model.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_expert">expert</code></td>
<td>
<p>A vector giving the names of columns in <code>network.data</code> used to define the scope of the expert network. By default, the initial model will contain no covariates (unless <code>initialModel</code> is supplied with expert covariates), thereafter all variables in <code>expert</code> (save for those in <code>initialModel</code>, if any) will be considered for inclusion where appropriate.
</p>
<p>If <code>expert</code> is not supplied (or set to <code>NULL</code>), <em>all</em> variables in <code>network.data</code> will be considered for the expert network. <code>expert</code> can also be supplied as <code>NA</code>, in which case <em>no</em> expert network covariates will ever be considered (save for those in <code>initialModel</code>, if any). Supplying <code>expert</code> and <code>gating</code> can be used to ensure different subsets of covariates enter different parts of the model.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_modelnames">modelNames</code></td>
<td>
<p>A character string of valid model names, to be used to restrict the size of the search space, if desired. By default, <em>all</em> valid model types are explored. Rather than considering the changing of the model type as an additional step, every step is evaluated over all entries in <code>modelNames</code>. See <code><a href="#topic+MoE_clust">MoE_clust</a></code> for more details. 
</p>
<p>Note that if <code>initialModel</code> is supplied (see below), <code>modelNames</code> will be augmented with <code>initialModel$modelName</code> if needs be.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_fullmoe">fullMoE</code></td>
<td>
<p>A logical which, when <code>TRUE</code>, ensures that only models where the same covariates enter both parts of the model (the gating and expert networks) are considered. This restricts the search space to exclude models where covariates differ across networks. Thus, the search is likely to be faster, at the expense of potentially missing out on optimal models. Defaults to <code>FALSE</code>. 
</p>
<p>Furthermore, when <code>TRUE</code>, the set of candidate covariates is automatically taken to be the <strong>union</strong> of the <em>named</em> covariates in <code>gating</code> and <code>expert</code>, for convenience. In other words, <code>gating=NA</code> will only work if <code>expert=NA</code> also, and both should be set to <code>NULL</code> in order to consider all potential covariates. 
</p>
<p>In addition, caution is advised using this argument in conjunction with <code>initialModel</code>, which must satisfy the constraint that the same set of covariates be used in both parts of the model, for initial models where gating covariates are allowable. Finally, note that this argument does not preclude a model with only expert covariates included if the number of components is such that the inclusion of gating covariates is infeasible.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_noise">noise</code></td>
<td>
<p>A logical indicating whether to assume all models contain an additional noise component (<code>TRUE</code>) or not (<code>FALSE</code>, the default). If <code>initialModel</code> or <code>initialG</code> is not specified, the search starts from a <code>G=0</code> noise-only model when <code>noise</code> is <code>TRUE</code>, otherwise the search starts from a <code>G=1</code> model with no covariates when <code>noise</code> is <code>FALSE</code>. See <code><a href="#topic+MoE_control">MoE_control</a></code> for more details. Note, however, that if the model specified in <code>initialModel</code> contains a noise component, the value of the <code>noise</code> argument will be overridden to <code>TRUE</code>; similarly, if the <code>initialModel</code> model does not contain a noise component, <code>noise</code> will be overridden to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_initialmodel">initialModel</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code> or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. This gives the initial model to use at the first step of the selection algorithm, to which components and/or covariates etc. can be added. Especially useful if the model is expected to have more than one component <em>a priori</em> (see <code>initialG</code> below as an alternative). The <code>initialModel</code> model must have been fitted to the same data in <code>data</code>. 
</p>
<p>If <code>initialModel</code> is not specified, the search starts from a <code>G=0</code> noise-only model when <code>noise</code> is <code>TRUE</code>, otherwise the search starts from a <code>G=1</code> model with no covariates when <code>noise</code> is <code>FALSE</code>. If <code>initialModel</code> <em>is</em> supplied and it contains a noise component, only models with a noise component will be considered thereafter (i.e. the <code>noise</code> argument can be overridden by the <code>initialModel</code> argument). If <code>initialModel</code> contains gating &amp;/or expert covariates, these covariates will be included in all subsequent searches, with covariates in <code>expert</code> and <code>gating</code> still considered as candidates for additional inclusion, as normal.
</p>
<p>However, while <code>initialModel</code> <em>can</em> include covariates not specified in <code>gating</code> &amp;/or <code>expert</code>, the <code>initialModel$modelName</code> <strong>should</strong> be included in the specified <code>modelNames</code>; if it is not, <code>modelNames</code> will be forcibly augmented with <code>initialModel$modelName</code> (as stated above). Furthermore, it is assumed that <code>initialModel</code> is already optimal with respect to the model type. If it is not, the algorithm may be liable to converge to a sub-optimal model, and so a warning will be printed if the function suspects that this <em>might</em> be the case.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_initialg">initialG</code></td>
<td>
<p>A single (positive) integer giving the number of mixture components (clusters) to initialise the stepwise search algorithm with. This is a simpler alternative to the <code>initialModel</code> argument, to be used when the only prior knowledge relates to the number of components, and not other features of the model (e.g. the covariates which should be included). Consequently, <code>initialG</code> is only relevant when <code>initialModel</code> is not supplied. When neither <code>initialG</code> nor <code>initialModel</code> is specified, the search starts from a <code>G=0</code> noise-only model when <code>noise</code> is <code>TRUE</code>, otherwise the search starts from a <code>G=1</code> model with no covariates when <code>noise</code> is <code>FALSE</code>. See <code>stepG</code> below for fixing the number of components at this <code>initialG</code> value.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_stepg">stepG</code></td>
<td>
<p>A logical indicating whether the algorithm should consider incrementing the number of components at each step. Defaults to <code>TRUE</code>; use <code>FALSE</code> when searching only over configurations with the same number of components is of interest. Setting <code>stepG</code> to <code>FALSE</code> is possible with or without specifying <code>initialModel</code> or <code>initialG</code>, but is primarily intended for use when one of these arguments is supplied, otherwise the algorithm will be stuck forever with only one component.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_criterion">criterion</code></td>
<td>
<p>The model selection criterion used to determine the optimal action at each step. Defaults to <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_equalpro">equalPro</code></td>
<td>
<p>A character string indicating whether models with equal mixing proportions should be considered. <code>"both"</code> means models with both equal and unequal mixing proportions will be considered, <code>"yes"</code> means only models with equal mixing proportions will be considered, and <code>"no"</code> means only models with unequal mixing proportions will be considered. Notably, no setting for <code>equalPro</code> is enough to rule out models with <code>gating</code> covariates from consideration.
</p>
<p>The default (<code>"all"</code>) is equivalent to <code>"both"</code> with the addition that all possible mixing proportion constraints will be tried for the <code>initialModel</code> (if any, provided it doesn't contain gating covariate(s)) or <code>initialG</code> <em>before</em> adding a component or additional covariates; otherwise, this <code>equalPro</code> argument only governs whether mixing proportion constraints are considered as components are added.
</p>
<p>Considering <code>"all"</code> (or <code>"both"</code>) equal and unequal mixing proportion models increases the search space and the computational burden, but this argument becomes irrelevant after a model, if any, with gating network covariate(s) is considered optimal for a given step. The <code>"all"</code> default is <strong>strongly</strong> recommended so that viable candidate models are not missed out on, particularly when <code>initialModel</code> or <code>initialG</code> are given. However, this does not guarantee that an optimal model will not be skipped; if <code>equalPro</code> is restricted via <code>"yes"</code> or <code>"no"</code>, a suboptimal model at one step may ultimately lead to a better final model, in some edge cases. See <code><a href="#topic+MoE_control">MoE_control</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_noise.gate">noise.gate</code></td>
<td>
<p>A character string indicating whether models where the gating network for the noise component depends on covariates are considered. <code>"yes"</code> means only models where this is the case will be considered, <code>"no"</code> means only models for which the noise component's mixing proportion is constant will be considered and <code>"both"</code> means both of these scenarios will be considered.
</p>
<p>The default (<code>"all"</code>) is equivalent to <code>"both"</code> with the addition that all possible gating network noise settings will be tried for the <code>initialModel</code> (if any, provided it contains gating covariates and a noise component) <em>before</em> adding a component or additional covariates; otherwise, this <code>noise.gate</code> argument only governs the inclusion/exclusion of this constraint as components or covariates are added.
</p>
<p>Considering <code>"all"</code> (or <code>"both"</code>) settings increases the search space and the computational burden, but this argument is only relevant when <code>noise=TRUE</code> and <code>gating</code> covariates are being considered. The <code>"all"</code> default is <strong>strongly</strong> recommended so that viable candidate models are not missed out on, particularly when <code>initialModel</code> or <code>initialG</code> are given. However, this does not guarantee that an optimal model will not be skipped; if <code>noise.gate</code> is restricted via <code>"yes"</code> or <code>"no"</code>, a suboptimal model at one step may ultimately lead to a better final model, in some edge cases. See <code><a href="#topic+MoE_control">MoE_control</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print messages pertaining to progress to the screen during fitting. By default is <code>TRUE</code> if the session is interactive, and <code>FALSE</code> otherwise. If <code>FALSE</code>, warnings and error messages will still be printed to the screen, but everything else will be suppressed.</p>
</td></tr>
<tr><td><code id="MoE_stepwise_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+MoE_control">MoE_control</a></code>, <em>except for those arguments of the same name which are already listed here</em>, e.g. <code>equalPro</code> and <code>noise.gate</code>. Note that these arguments will be supplied to <em>all</em> candidate models for every step. For arguments specific to <code><a href="#topic+MoE_control">MoE_control</a></code> (e.g. <code>stopping</code>, <code>algo</code>, etc.), it is recommended to run <code>MoE_stepwise</code> multiple times while toggling these arguments, if desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>modelNames</code>, <code>equalPro</code>, and <code>noise.gate</code> are provided for computational convenience. They can be used to reduce the number of models under consideration at each stage. 
</p>
<p>The same is true of the arguments <code>gating</code> and <code>expert</code>, which can each separately (or jointly, if <code>fullMoE</code> is <code>TRUE</code>) be made to consider all variables in <code>network.data</code>, or a subset, or none at all. 
</p>
<p>Finally, <code>initialModel</code> or <code>initialG</code> can be used to kick-start the search algorithm by incorporating prior information in a more direct way; in the latter case, only in the form of the number of components; in the former case, a full model with a given number of components, certain included gating and expert network covariates, and a certain model type can give the model an even more informed head start. In either case, the <code>stepG</code> argument can be used to fix the number of components and only search over different configurations of covariates.
</p>
<p>Without any prior information, it is best to accept the defaults at the expense of a longer run-time.
</p>


<h3>Value</h3>

<p>An object of class <code>"MoECompare"</code> containing information on all visited models and the optimal model (accessible via <code>x$optimal</code>).
</p>


<h3>Note</h3>

<p>It is advised to run this function once with <code>noise=FALSE</code> and once with <code>noise=TRUE</code> and then choose the optimal model across both sets of results.
</p>
<p>At present, only additions (of components and covariates) are considered. In future updates, it may be possible to allow both additions and removals.
</p>
<p>The function will attempt to remove duplicate variables found in both <code>data</code> and <code>network.data</code>; in particular, they will be removed from <code>network.data</code>. Users are however advised to carefully specify <code>data</code> and <code>network.data</code> such that there are no duplicates, especially if the desired variable(s) should belong to <code>network.data</code>.
</p>
<p>Finally, if the user intends to search for the best model according to the <code>"icl"</code> <code>criterion</code>, then specifying either <code>initialModel</code> or <code>initialG</code> is advisable. This is because the algorithm otherwise starts with a single component and thus there is no entropy term, meaning the stepwise search can quickly and easily get stuck at <code>G=1</code>. See the examples below.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_compare">MoE_compare</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(CO2data)
# Search over all models where the single covariate can enter either network
# (mod1  &lt;- MoE_stepwise(CO2data$CO2, CO2data[,"GNP", drop=FALSE]))
#
# data(ais)
# Only look for EVE &amp; EEE models with at most one expert network covariate
# Do not consider any gating covariates and only consider models with equal mixing proportions
# (mod2  &lt;- MoE_stepwise(ais[,3:7], ais, gating=NA, expert="sex",
#                        equalPro="yes", modelNames=c("EVE", "EEE")))
#
# Look for models with noise &amp; only those where the noise component's mixing proportion is constant
# Speed up the search with an initialModel, fix G, and restrict the covariates &amp; model type
# init   &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EEE", 
#                     expert= ~ sex, network.data=ais, tau0=0.1)
# (mod3  &lt;- MoE_stepwise(ais[,3:7], ais, noise=TRUE, expert="sex",
#                        gating=c("SSF", "Ht"), noise.gate="no", 
#                        initialModel=init, stepG=FALSE, modelNames="EEE"))
#
# Compare both sets of results (with &amp; without a noise component) for the ais data
# (comp1 &lt;- MoE_compare(mod2, mod3, optimal.only=TRUE))
# comp1$optimal
#
# Target a model for the AIS data which is optimal in terms of ICL, without any restrictions
# mod4   &lt;- MoE_stepwise(ais[,3:7], ais, criterion="icl")
# 
# This gets stuck at a G=1 model, so specify an initial G value as a head start
# mod5   &lt;- MoE_stepwise(ais[,3:7], ais, criterion="icl", initialG=2)
#
# Check that specifying an initial G value enables a better model to be found
# (comp2 &lt;- MoE_compare(mod4, mod5, optimal.only=TRUE, criterion="icl"))

# Finally, restrict the search to full MoE models only
# Notice that the candidate covariates are the union of gating and expert
# Notice also that the algorithm initially traverses models with only
#   expert covariates when the inclusion of gating covariates is infeasible
# mod6   &lt;- MoE_stepwise(ais[,3:7], ais, fullMoE=TRUE, gating="BMI", expert="Bfat")
</code></pre>

<hr>
<h2 id='MoE_Uncertainty'>Plot Clustering Uncertainties</h2><span id='topic+MoE_Uncertainty'></span>

<h3>Description</h3>

<p>Plots the clustering uncertainty for every observation from a fitted <code>"MoEClust"</code> model, including models with a noise component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoE_Uncertainty(res,
                type = c("barplot", "profile"),
                truth = NULL,
                decreasing = FALSE,
                col = c("cluster", "uncertain", "none"),
                rug1d = TRUE,
                ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MoE_Uncertainty_+3A_res">res</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_type">type</code></td>
<td>
<p>The type of plot to be produced (defaults to <code>"barplot"</code>). The <code>"profile"</code> option instead displays uncertainties in increasing/decreasing order of magnitude (see <code>decreasing</code>).</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_truth">truth</code></td>
<td>
<p>An optional argument giving the true classification of the data. When <code>truth</code> is supplied and <code>type="barplot"</code>, misclassified observations are highlighted in a different colour, otherwise observations with uncertainty greater than <code>1/res$G</code> are given in a different colour. When <code>truth</code> is supplied and <code>type="profile"</code>, the uncertainty of misclassified observations is marked by vertical lines on the plot.</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_decreasing">decreasing</code></td>
<td>
<p>A logical indicating whether uncertainties should be ordered in decreasing order (defaults to <code>FALSE</code>). Only relevant when <code>type="profile"</code>.</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_col">col</code></td>
<td>
<p>Only relevant when <code>truth=NULL</code>. A character string indicating whether points should be coloured according to their <code>"cluster"</code>-memberships (the default) in <code>res$classification</code>, according to whether they exceed the threshold to be deemed <code>"uncertain"</code>, or not at all (<code>"none"</code>). <code>"cluster"</code> is inadvisable when the number of clusters <code>res$G</code> is large.</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_rug1d">rug1d</code></td>
<td>
<p>A logical which is relevant only when <code>type="barplot"</code> and <code>res$d == 1</code>, i.e. the model was fitted to univariate data. When <code>rug1d=TRUE</code>, the x-axis is given by the actual observations (indicated with a rug), otherwise the x-axis is given by the indices of the observations as per similar plots when <code>res$d &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="MoE_Uncertainty_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The y-axis of this plot runs from <code>0</code> to <code>1 - 1/res$G</code>, with a horizontal line also drawn at <code>1/res$G</code>. When <code>type="barplot"</code>, uncertainties greater than this value are given a different colour when <code>truth</code> is not supplied, otherwise misclassified observations are given a different colour. Note, however, that <code class="reqn">G^{(0)}</code> = <code>res$G + 1</code> is used in place of <code>res$G</code> for models with a noise component.
</p>


<h3>Value</h3>

<p>A plot showing the clustering uncertainty of each observation (sorted in increasing/decreasing order when <code>type="profile"</code>). The (unsorted) vector of uncertainties can also be returned invisibly. When <code>truth</code> is supplied, the indices of the misclassified observations are also invisibly returned.
</p>


<h3>Note</h3>

<p><code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code> is a wrapper to <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code> which accepts the default arguments, and also produces other types of plots.
</p>
<p>An alternative means of visualising clustering uncertainties (at least for multivariate data) is provided by the functions <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> and <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>, specifically when their argument <code>response.type</code> is given as <code>"uncertainty"</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+plot.MoEClust">plot.MoEClust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], gating= ~ sex, G=3, modelNames="EEE", network.data=ais)

# Produce an uncertainty barplot
MoE_Uncertainty(res)

# Change the colour scheme
MoE_Uncertainty(res, col="uncertain")

# Produce an uncertainty profile plot
MoE_Uncertainty(res, type="profile")

# Let's assume the true clusters correspond to sex
(ub &lt;- MoE_Uncertainty(res, truth=ais$sex))
(up &lt;- MoE_Uncertainty(res, type="profile", truth=ais$sex))

# Examine the effect of rug1d for univariate models
mod &lt;- MoE_clust(CO2data$CO2, expert=~GNP, G=2, modelNames="V", network.data=CO2data)
MoE_Uncertainty(mod, rug1d=FALSE)
MoE_Uncertainty(mod)
</code></pre>

<hr>
<h2 id='noise_vol'>Approximate Hypervolume Estimate</h2><span id='topic+noise_vol'></span>

<h3>Description</h3>

<p>Computes simple approximations to the hypervolume of univariate and multivariate data sets. Also returns the location of the centre of mass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_vol(data,
          method = c("hypvol", "convexhull", "ellipsoidhull"),
          reciprocal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_vol_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. Categorical variables are not allowed, and covariates should not be included. If a matrix or data frame, rows correspond to observations and columns correspond to variables. There <strong>must</strong> be more observations than variables.</p>
</td></tr>
<tr><td><code id="noise_vol_+3A_method">method</code></td>
<td>
<p>The method used to estimate the hypervolume. The default method uses the function <code><a href="mclust.html#topic+hypvol">hypvol</a></code>. The <code>"convexhull"</code> and <code>"ellipsoidhull"</code> options require loading the <span class="pkg">geometry</span> and <span class="pkg">cluster</span> packages, respectively. This argument is only relevant for multivariate data; for univariate data, the range of the data is used. Note that the <code>"convexhull"</code> <code>method</code> is liable to be slow when <code>data</code> has many columns.</p>
</td></tr>
<tr><td><code id="noise_vol_+3A_reciprocal">reciprocal</code></td>
<td>
<p>A logical variable indicating whether or not the reciprocal hypervolume is desired rather than the hypervolume itself. The default is to return the hypervolume.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following two elements:
</p>

<dl>
<dt><code>vol</code></dt><dd><p>A hypervolume estimate (or its inverse). 
</p>
<p>This can be used as the hypervolume parameter for the noise component when observations are designated as noise in <code><a href="#topic+MoE_clust">MoE_clust</a></code>.</p>
</dd>
<dt><code>loc</code></dt><dd><p>A vector of length <code>ncol(data)</code> giving the location of the centre of mass.
</p>
<p>This can help in predicting the fitted values of models fitted with noise components via <code><a href="#topic+MoE_clust">MoE_clust</a></code>.</p>
</dd></dl>



<h3>Note</h3>

<p>This function is called when adding a noise component to <code>MoEClust</code> models via the function <code>MoE_control</code>, specifically using its arguments <code>noise.meth</code> &amp;/or <code>tau0</code>. The function internally only uses the response variables, and not the covariates. However, one can bypass the invocation of this function by specifying the <code>noise.vol</code> argument of <code><a href="#topic+MoE_control">MoE_control</a></code> directly. This is explicitly necessary for models for high-dimensional data which include a noise component for which this function cannot estimate a (hyper)volume.
</p>
<p>Note that supplying the volume manually to <code><a href="#topic+MoE_clust">MoE_clust</a></code> can affect the summary of the means in <code>parameters$mean</code> and by extension the location of the MVN ellipses in <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> plots for models with <em>both</em> expert network covariates and a noise component. The location cannot be estimated when the volume is supplied manually; in this case, prediction is made on the basis of renormalising the <code>z</code> matrix after discarding the column corresponding to the noise component. Otherwise, the mean of the noise component is accounted for. The renormalisation approach can be forced by specifying <code>noise.args$discard.noise=TRUE</code>, even when the mean of the noise component is available.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+hypvol">hypvol</a></code>, <code><a href="geometry.html#topic+convhulln">convhulln</a></code>, <code><a href="cluster.html#topic+ellipsoidhull">ellipsoidhull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
noise_vol(ais[,3:7], reciprocal=TRUE)

noise_vol(ais[,3:7], reciprocal=FALSE, method="convexhull")
</code></pre>

<hr>
<h2 id='plot.MoEClust'>Plot MoEClust Results</h2><span id='topic+plot.MoEClust'></span>

<h3>Description</h3>

<p>Plot results for fitted MoE_clust mixture models with gating &amp;/or expert network covariates: generalised pairs plots, model selection criteria, the log-likelihood vs. the EM iterations, and the gating network are all currently visualisable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MoEClust'
plot(x,
     what = c("gpairs", "gating", "criterion", "loglik", "similarity", "uncertainty"),
     ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MoEClust_+3A_x">x</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Models with a noise component are facilitated here too.</p>
</td></tr>
<tr><td><code id="plot.MoEClust_+3A_what">what</code></td>
<td>
<p>The type of graph requested:
</p>

<dl>
<dt><code>gpairs</code></dt><dd><p>A generalised pairs plot. To further customise this plot, arguments to <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code> can be supplied.</p>
</dd>
<dt><code>gating</code></dt><dd><p>The gating network. To further customise this plot, arguments to <code><a href="#topic+MoE_plotGate">MoE_plotGate</a></code> and <code><a href="graphics.html#topic+matplot">matplot</a></code> can be supplied.</p>
</dd>
<dt><code>criterion</code></dt><dd><p>The model selection criteria. To further customise this plot, arguments to <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code> and <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code> can be supplied.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>The log-likelihood vs. the iterations of the EM algorithm. To further customise this plot, arguments to <code><a href="#topic+MoE_plotLogLik">MoE_plotLogLik</a></code> and <code><a href="base.html#topic+plot">plot</a></code> can be supplied.</p>
</dd>
<dt><code>similarity</code></dt><dd><p>The similarity matrix constructed from <code>x$z</code> at convergence, in the form of a heatmap. To further customise this plot, arguments to <code><a href="#topic+MoE_Similarity">MoE_Similarity</a></code> can be supplied.</p>
</dd>
<dt><code>uncertainty</code></dt><dd><p>The clustering uncertainty for every observation. To further customise this plot, arguments to <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code> can be supplied.</p>
</dd>
</dl>

<p>By default, all of the above graphs are produced.</p>
</td></tr>
<tr><td><code id="plot.MoEClust_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+MoE_plotGate">MoE_plotGate</a></code>, <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code>, <code><a href="#topic+MoE_plotLogLik">MoE_plotLogLik</a></code>, <code><a href="#topic+MoE_Similarity">MoE_Similarity</a></code>, <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>, <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code> and <code><a href="base.html#topic+plot">plot</a></code>. In particular, the argument <code>legendArgs</code> to <code><a href="mclust.html#topic+plot.mclustBIC">plot.mclustBIC</a></code> can be passed to <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more flexibility in plotting, use <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+MoE_plotGate">MoE_plotGate</a></code>, <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code>, <code><a href="#topic+MoE_plotLogLik">MoE_plotLogLik</a></code>, <code><a href="#topic+MoE_Similarity">MoE_Similarity</a></code>, and <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code> directly.
</p>


<h3>Value</h3>

<p>The visualisation according to <code>what</code> of the results of a fitted <code>MoEClust</code> model.
</p>


<h3>Note</h3>

<p>Other plotting options are available by first calling <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code> on the fitted object, and then calling <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code> on the results. However, caution is advised for models with gating &amp;/or expert covariates (see the Note in <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>).
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_stepwise">MoE_stepwise</a></code>, <code><a href="#topic+MoE_gpairs">MoE_gpairs</a></code>, <code><a href="#topic+MoE_plotGate">MoE_plotGate</a></code>, <code><a href="#topic+MoE_plotCrit">MoE_plotCrit</a></code>, <code><a href="#topic+MoE_plotLogLik">MoE_plotLogLik</a></code>, <code><a href="#topic+MoE_Similarity">MoE_Similarity</a></code>, <code><a href="#topic+MoE_Uncertainty">MoE_Uncertainty</a></code>, <code><a href="#topic+as.Mclust.MoEClust">as.Mclust</a></code>, <code><a href="mclust.html#topic+plot.Mclust">plot.Mclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
res &lt;- MoE_clust(ais[,3:7], gating= ~ BMI, expert= ~ sex,
                 G=2, modelNames="EVE", network.data=ais)

# Plot the gating network
plot(res, what="gating", x.axis=ais$BMI, xlab="BMI")

# Plot the log-likelihood
plot(res, what="loglik", col="blue")

# Plot the uncertainty profile
plot(res, what="uncertainty", type="profile")

# Produce a generalised pairs plot
plot(res, what="gpairs")

# Produce a heatmap of the similarity matrix
plot(res, what="similarity")

# Modify the gpairs plot by passing arguments to MoE_gpairs()
plot(res, what="gpairs", response.type="density", varwidth=TRUE, show.dens=TRUE,
     data.ind=c(5,3,4,1,2), jitter=FALSE, show.counts=FALSE)
</code></pre>

<hr>
<h2 id='predict.MoE_expert'>Predictions from MoEClust expert networks</h2><span id='topic+predict.MoE_expert'></span><span id='topic+fitted.MoE_expert'></span><span id='topic+residuals.MoE_expert'></span>

<h3>Description</h3>

<p>Predictions (point estimates) of observation-specific component means from each (non-noise) component's expert network linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MoE_expert'
predict(object,
        newdata = NULL,
        simplify = FALSE,
        droplevels = FALSE,
        ...)

## S3 method for class 'MoE_expert'
fitted(object,
       ...)

## S3 method for class 'MoE_expert'
residuals(object,
          ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MoE_expert_+3A_object">object</code></td>
<td>
<p>An object of class <code>"MoE_expert"</code> (typically <code>x$expert</code>, where <code>x</code> is of class <code>"MoEClust"</code>).</p>
</td></tr>
<tr><td><code id="predict.MoE_expert_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data frame of test examples. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.MoE_expert_+3A_simplify">simplify</code></td>
<td>
<p>Logical indicating whether to simplify the output (in the form of a list) to a 3-dimensional array with dimensions given by the number of new observations, the number of variables, and the number of clusters. The first dimension of such an array is of length <code>1</code> when there are no expert network covariates, in which case the entries correspond to <code>object$parameters$mean</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.MoE_expert_+3A_droplevels">droplevels</code></td>
<td>
<p>A logical indicating whether unseen factor levels in categorical variables within <code>newdata</code> should be dropped (with <code>NA</code> predicted in their place). Defaults to <code>FALSE</code>. See <code><a href="#topic+drop_levels">drop_levels</a></code>.</p>
</td></tr>
<tr><td><code id="predict.MoE_expert_+3A_...">...</code></td>
<td>
<p>Catches unused arguments or allows the <code>simplify</code> argument to be passed through <code>fitted</code> and <code>residuals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is effectively just a shortcut to <code>lapply(x$expert, predict.lm, newdata=...)</code>. It can also be thought of as a wrapper to <code><a href="#topic+predict.MoEClust">predict.MoEClust</a>(x, ...)$mean</code>, although it returns a list (by default) rather than a 3-dimensional array and also <em>always</em> preserves the dimensions of <code>newdata</code>, even for models without expert network covariates.
</p>


<h3>Value</h3>

<p>For <code>simplify=FALSE</code>, either a list of vectors or predictions (for univariate data) or a list of matrices of predictions (for multivariate data). These lists are of the same length as number of non-noise components in the fitted model. When <code>simplify=TRUE</code>, a 3-dimensional array of predictions is returned, with respective dimensions given by the number of observations, variables, and non-noise components.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+predict.MoE_gating">predict.MoE_gating</a></code>, <code><a href="#topic+drop_levels">drop_levels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CO2data)
res &lt;- MoE_clust(CO2data$CO2, G=3, equalPro=TRUE, expert= ~ GNP, network.data=CO2data)
predict(res$expert)

# Try with newdata and simplify=TRUE
predict(res$expert, newdata=CO2data[1:5,"GNP", drop=FALSE], simplify=TRUE)
</code></pre>

<hr>
<h2 id='predict.MoE_gating'>Predictions from MoEClust gating networks</h2><span id='topic+predict.MoE_gating'></span><span id='topic+fitted.MoE_gating'></span><span id='topic+residuals.MoE_gating'></span>

<h3>Description</h3>

<p>Predicts mixing proportions from MoEClust gating networks. Effectively akin to predicting from a multinomial logistic regression via <code><a href="nnet.html#topic+multinom">multinom</a></code>, although here the noise component (if any) is properly accounted for. So too are models with no gating covariates at all, or models with the equal mixing proportion constraint. Prior probabilities are returned by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MoE_gating'
predict(object,
        newdata = NULL,
        type = c("probs", "class"),
        keep.noise = TRUE,
        droplevels = FALSE,
        ...)

## S3 method for class 'MoE_gating'
fitted(object,
       ...)

## S3 method for class 'MoE_gating'
residuals(object,
          ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MoE_gating_+3A_object">object</code></td>
<td>
<p>An object of class <code>"MoE_gating"</code> (typically <code>x$gating</code>, where <code>x</code> is of class <code>"MoEClust"</code>).</p>
</td></tr>
<tr><td><code id="predict.MoE_gating_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data frame of test examples. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.MoE_gating_+3A_type">type</code></td>
<td>
<p>The type of output desired. The default (<code>"probs"</code>) returns prior probabilities, while <code>"class"</code> returns labels indicating the most likely group <em>a priori</em>. Note that observations classified assigned the noise component (if any) are given a label of <code>0</code>.</p>
</td></tr>
<tr><td><code id="predict.MoE_gating_+3A_keep.noise">keep.noise</code></td>
<td>
<p>A logical indicating whether the output should acknowledge the noise component (if any). Defaults to <code>TRUE</code>; when <code>FALSE</code>, this column is discarded and the matrix of probabilities is renormalised accordingly.</p>
</td></tr>
<tr><td><code id="predict.MoE_gating_+3A_droplevels">droplevels</code></td>
<td>
<p>A logical indicating whether unseen factor levels in categorical variables within <code>newdata</code> should be dropped (with <code>NA</code> predicted in their place). Defaults to <code>FALSE</code>. See <code><a href="#topic+drop_levels">drop_levels</a></code>.</p>
</td></tr>
<tr><td><code id="predict.MoE_gating_+3A_...">...</code></td>
<td>
<p>Catches unused arguments or allows the <code>type</code> and <code>keep.noise</code> arguments to be passed through <code>fitted</code> and the <code>keep.noise</code> argument to be passed through <code>residuals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is effectively a shortcut to <code><a href="#topic+predict.MoEClust">predict.MoEClust</a>(x, ...)$pro</code>, which (unlike the <code>predict</code> method for <code><a href="nnet.html#topic+multinom">multinom</a></code> on which <code>predict.MoE_gating</code> is based) accounts for the various ways of treating gating covariates, equal mixing proportion constraints, and noise components, although its <code>type</code> argument defaults to <code>"probs"</code> rather than <code>"class"</code>.
</p>


<h3>Value</h3>

<p>The return value depends on whether <code>newdata</code> is supplied or not and whether the model includes gating covariates to begin with. When <code>newdata</code> is not supplied, the fitted values are returned (as a matrix if the model contained gating covariates, otherwise as a vector as per <code>x$parameters$pro</code>). If <code>newdata</code> is supplied, the output is always a matrix with the same number of rows as the <code>newdata</code>.
</p>


<h3>Note</h3>

<p>Note that the <code>keep.noise</code> argument does <strong>not</strong> correspond in any way to the <code>discard.noise</code> argument to <code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code>; there, the noise component is respected in the computation of the mixing proportions and only discarded (if at all) in the prediction of the responses.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.MoEClust">predict.MoEClust</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>, <code><a href="#topic+predict.MoE_expert">predict.MoE_expert</a></code>, <code><a href="#topic+drop_levels">drop_levels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
mod    &lt;- MoE_clust(ais[,3:7], G=2, modelNames="EEE", gating= ~ SSF + Ht,
                 expert= ~ sex, network.data=ais, tau0=0.1, noise.gate=FALSE)
(preds &lt;- predict(mod$gating, newdata=ais[1:5,]))

all.equal(preds, predict(mod, newdata=ais[1:5,])$pro) #TRUE

# Note that the predictions are not the same as the multinom predict method
# in this instance, owing to the invocation of noise.gate=FALSE above
mod2   &lt;- mod 
class(mod2$gating) &lt;- c("multinom", "nnet")
predict(mod2$gating, newdata=ais[1:5,], type="probs")

# We can make this function behave in the same way by invoking keep.noise=FALSE
predict(mod$gating, keep.noise=FALSE, newdata=ais[1:5,])

# ... although keep.noise=FALSE in predict.MoE_gating does not
# yield the same output as discard.noise=TRUE in predict.MoEClust
predict(mod, discard.noise=TRUE, newdata=ais[1:5,])$pro
</code></pre>

<hr>
<h2 id='predict.MoEClust'>Predictions for MoEClust models</h2><span id='topic+predict.MoEClust'></span><span id='topic+fitted.MoEClust'></span><span id='topic+residuals.MoEClust'></span>

<h3>Description</h3>

<p>Predicts both cluster membership probabilities and fitted response values from a <code>MoEClust</code> model, using covariates and response data, or covariates only. The predicted MAP classification, mixing proportions, and component means are all also reported in both cases, as well as the predictions of the expert network corresponding to the most probable component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MoEClust'
predict(object,
        newdata,
        resid = FALSE,
        discard.noise = FALSE,
        MAPresids = FALSE,
        use.y = TRUE,
        ...)

## S3 method for class 'MoEClust'
fitted(object,
       ...)

## S3 method for class 'MoEClust'
residuals(object,
          newdata,
          ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MoEClust_+3A_object">object</code></td>
<td>
<p>An object of class <code>"MoEClust"</code> generated by <code><a href="#topic+MoE_clust">MoE_clust</a></code>, or an object of class <code>"MoECompare"</code> generated by <code><a href="#topic+MoE_compare">MoE_compare</a></code>. Predictions for models with a noise component are facilitated here too (see <code>discard.noise</code>).</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_newdata">newdata</code></td>
<td>
<p>A list with two <em>named</em> components, each of which must be a <code>data.frame</code> or <code>matrix</code> with named columns, giving the data for which predictions are desired.
</p>

<dl>
<dt><code>new.x</code></dt><dd><p>The new covariates for the <code>gating</code> &amp;/or <code>expert</code> networks. <strong>Must</strong> be supplied when <code>newdata$new.y</code> is supplied.</p>
</dd>
<dt><code>new.y</code></dt><dd><p>(Optional) response data (see <code>use.y</code> below). When supplied, cluster and response prediction is based on both <code>newdata$new.x</code> and <code>newdata$new.y</code>, otherwise only on the covariates in <code>newdata$new.x</code>.</p>
</dd>
</dl>

<p>If supplied as a list with elements <code>new.x</code> and <code>new.y</code>, both <strong>must</strong> have the same number of rows.
</p>
<p>Alternatively, a single <code>data.frame</code> or <code>matrix</code> can be supplied and an attempt will be made to extract &amp; separate covariate and response columns (<em>if any</em>) into <code>newdata$new.x</code> and <code>newdata$new.y</code> based on the variable names in <code>object$data</code> and <code>object$net.covs</code>.
</p>
<p>When <code>newdata</code> is not supplied in any way, the covariates and response variables used in the fitting of the model are used here. It is possible to not supply <code>new.y</code> and to supply an empty <code>data.frame</code> or <code>matrix</code> for <code>new.x</code> (or to equivalently supply an empty <code>data.frame</code> or <code>matrix</code> for <code>newdata</code> itself) for models with no covariates of any kind, which effectively predicts the weighted mean of the component means.</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_resid">resid</code></td>
<td>
<p>A logical indicating whether to return the residuals also. Defaults to <code>FALSE</code>. Only allowed when response variables are supplied in some form. The function <code>residuals</code> is a wrapper to <code>predict</code> with the argument <code>resid</code> set to <code>TRUE</code>, with only the residuals returned.</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_discard.noise">discard.noise</code></td>
<td>
<p>A logical governing how predictions of the responses are made for models with a noise component (otherwise this argument is irrelevant). By default (<code>FALSE</code>), the mean of the noise component is accounted for. Otherwise, or when the mean of the noise component is unavailable (due to having been manually supplied through <code><a href="#topic+MoE_control">MoE_control</a></code> via <code>noise.args$noise.vol</code>), prediction of the responses is performed using a <code>z</code> matrix which is renormalised after discarding the column corresponding to the noise component. The renormalisation approach can be forced by specifying <code>TRUE</code>, even when the mean of the noise component is available. For models with a noise component fitted with <code>algo="CEM"</code>, a small extra E-step is conducted for observations assigned to the non-noise components in this case.</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_mapresids">MAPresids</code></td>
<td>
<p>A logical indicating whether residuals are computed against <code>y</code> (<code>TRUE</code>, the default) or <code>MAPy</code> when <code>FALSE</code>. Not relevant for models with equal mixing proportions when only <code>new.x</code> is available. See <strong>Value</strong> below for more details.</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_use.y">use.y</code></td>
<td>
<p>A logical indicating whether the response variables (if any are supplied either via <code>new.y</code> or via <code>newdata</code> itself) are actually used in the prediction. Defaults to <code>TRUE</code>, but useful when <code>FALSE</code> for computing residuals as though only the covariates in <code>new.x</code> were supplied. For out-of-sample prediction, typically <code>new.y</code> would not be supplied anyway and so the <code>use.y=TRUE</code> default becomes irrelevant.</p>
</td></tr>
<tr><td><code id="predict.MoEClust_+3A_...">...</code></td>
<td>
<p>Catches unused arguments (and allows the <code>predict</code> arguments <code>discard.noise</code> &amp;/or <code>use.y</code> to be passed through <code>fitted</code> or the <code>discard.noise</code>, <code>MAPresids</code>, and/or <code>use.y</code> arguments to be passed through <code>residuals</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions can also be made for models with a noise component, in which case <code>z</code> will include the probability of belonging to <code>"Cluster0"</code> &amp; <code>classification</code> will include labels with the value <code>0</code> for observations classified as noise (if any). The argument <code>discard.noise</code> governs how the responses are predicted in the presence of a noise component (see <code><a href="#topic+noise_vol">noise_vol</a></code> for more details).
</p>
<p>Note that the argument <code>discard.noise</code> is invoked for any models with a noise component, while the similar <code><a href="#topic+MoE_control">MoE_control</a></code> argument <code>noise.args$discard.noise</code> is only invoked for models with both a noise component and expert network covariates.
</p>
<p>Please be aware that a model considered optimal from a clustering point of view may not necessarily be optimal from a prediction point of view. In particular, full MoE models with covariates in both networks (for which both the cluster membership probabilities and component means are observation-specific) are recommended for out-of-sample prediction when only new covariates are observed (see <code>new.x</code> and <code>new.y</code> above, as well as <code>use.y</code>).
</p>


<h3>Value</h3>

<p>A list with the following named components, regardless of whether <code>newdata$new.x</code> and <code>newdata$new.y</code> were used, or <code>newdata$new.x</code> only.
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>Aggregated fitted values of the response variables.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A matrix whose <code>[i,k]</code>-th entry is the probability that observation <em>i</em> of the <code>newdata</code> belongs to the <em>k</em>-th component. For models with a noise component, the final column gives the probability of belonging to the so-called <em>Cluster0</em>.</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>The vector of predicted cluster labels for the <code>newdata</code>. <code>0</code> is returned for observations assigned to the noise component.</p>
</td></tr>
<tr><td><code>pro</code></td>
<td>
<p>The predicted mixing proportions for the <code>newdata</code>, i.e. predicted values of the gating network. <code>object$parameters$pro</code> is returned for models without gating network covariates. See <code><a href="#topic+predict.MoE_gating">predict.MoE_gating</a></code>.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The predicted component means for the <code>newdata</code>, i.e. predicted values of the expert network. Given as a 3-dimensional array with dimensions given by the number of new observations, the number of variables, and the number of clusters. The first dimension is of length <code>1</code> when there are no expert network covariates, in which case the entries correspond to <code>object$parameters$mean</code>. See <code><a href="#topic+predict.MoE_expert">predict.MoE_expert</a></code>.</p>
</td></tr>
<tr><td><code>MAPy</code></td>
<td>
<p>Fitted values of the single expert network to which each observation is most probably assigned. Not returned for models with equal mixing proportions when only <code>new.x</code> is available. Likely to only be of use for models with gating and expert covariates when only <code>new.x</code> is supplied. Note that <code>MAPy</code> and <code>y</code> will coincide for models fitted via the CEM algorithm (see <code><a href="#topic+MoE_control">MoE_control</a></code> and its argument <code>algo</code>).</p>
</td></tr>
</table>
<p>When <code>residuals</code> is called, only the residuals (governed by <code>MAPresids</code>) are returned; when <code>predict</code> is called with <code>resid=TRUE</code>, the list above will also contain the element <code>resids</code>, containing the residuals.
</p>
<p>The returned values of <code>pro</code> and <code>mean</code> are always the same, regardless of whether <code>newdata$new.x</code> and <code>newdata$new.y</code> were used, or <code>newdata$new.x</code> only.
</p>
<p>Finally, <code>fitted</code> is simply a wrapper to <code>predict.MoEClust(object)$y</code> without any <code>newdata</code>, and with the <code>resid</code> and <code>MAPresids</code> arguments also ignored.
</p>


<h3>Note</h3>

<p>Note that a dedicated <code><a href="#topic+predict.MoE_gating">predict</a></code> function is also provided for objects of class <code>"MoE_gating"</code> (typically <code>object$gating</code>, where <code>object</code> is of class <code>"MoEClust"</code>). This function is effectively a shortcut to <code>predict(object, ...)$pro</code>, which (unlike the <code>predict</code> method for <code><a href="nnet.html#topic+multinom">multinom</a></code> on which it is based) accounts for the various ways of treating gating covariates and noise components, although its <code>type</code> argument defaults to <code>"probs"</code> rather than <code>"class"</code>. Notably, its <code>keep.noise</code> argument behaves differently from the <code>discard.noise</code> argument here; here, the noise component is <strong>only</strong> discarded in the computation of the predicted responses. See <code><a href="#topic+predict.MoE_gating">predict.MoE_gating</a></code> for further details.
</p>
<p>Similarly, a dedicated <code><a href="#topic+predict.MoE_expert">predict</a></code> function is also provided for objects of class <code>"MoE_expert"</code> (typically <code>object$expert</code>, where <code>object</code> is of class <code>"MoE_expert"</code>). This function is effectively a wrapper to <code>predict(object, ...)$mean</code>, albeit it returns a list (by default) rather than a 3-dimensional array and also <em>always</em> preserves the dimensions of <code>newdata</code>, even for models without expert network covariates. See <code><a href="#topic+predict.MoE_expert">predict.MoE_expert</a></code> for further details.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K. and Murphy, T. B. (2020). Gaussian parsimonious clustering models with covariates and a noise component. <em>Advances in Data Analysis and Classification</em>, 14(2): 293-325. &lt;<a href="https://doi.org/10.1007/s11634-019-00373-8">doi:10.1007/s11634-019-00373-8</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MoE_clust">MoE_clust</a></code>, <code><a href="#topic+MoE_control">MoE_control</a></code>, <code><a href="#topic+noise_vol">noise_vol</a></code>, <code><a href="#topic+predict.MoE_gating">predict.MoE_gating</a></code>, <code><a href="#topic+predict.MoE_expert">predict.MoE_expert</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ais)
# Fit a MoEClust model and predict the same data
res     &lt;- MoE_clust(ais[,3:7], G=2, gating= ~ BMI, expert= ~ sex,
                     modelNames="EVE", network.data=ais)
pred1   &lt;- predict(res)

# Get only the fitted responses
fits    &lt;- fitted(res)
all.equal(pred1$y, fits) #TRUE

# Remove some rows of the data for prediction purposes
ind     &lt;- sample(1:nrow(ais), 5)
dat     &lt;- ais[-ind,]

# Fit another MoEClust model to the retained data
res2    &lt;- MoE_clust(dat[,3:7], G=3, gating= ~ BMI + sex,
                     modelNames="EEE", network.data=dat)

# Predict held back data using the covariates &amp; response variables
(pred2  &lt;- predict(res2, newdata=ais[ind,]))
# pred2 &lt;- predict(res2, newdata=list(new.y=ais[ind,3:7],
#                                     new.x=ais[ind,c("BMI", "sex")]))

# Get the residuals
residuals(res2, newdata=ais[ind,])

# Predict held back data using only the covariates
(pred3  &lt;- predict(res2, newdata=ais[ind,], use.y=FALSE))
# pred3 &lt;- predict(res2, newdata=list(new.x=ais[ind,c("BMI", "sex")]))
# pred3 &lt;- predict(res2, newdata=ais[ind,c("BMI", "sex")])
</code></pre>

<hr>
<h2 id='quant_clust'>Quantile-Based Clustering for Univariate Data</h2><span id='topic+quant_clust'></span>

<h3>Description</h3>

<p>Returns a quantile-based clustering for univariate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant_clust(x,
            G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quant_clust_+3A_x">x</code></td>
<td>
<p>A vector of numeric data.</p>
</td></tr>
<tr><td><code id="quant_clust_+3A_g">G</code></td>
<td>
<p>The desired number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of cluster labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CO2data)
quant_clust(CO2data$CO2, G=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
