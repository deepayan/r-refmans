<!DOCTYPE html><html><head><title>Help for package tsiR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsiR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#corr'><p>corr</p></a></li>
<li><a href='#derivative'><p>derivative</p></a></li>
<li><a href='#epitimes'><p>epitimes</p></a></li>
<li><a href='#estpars'><p>estpars</p></a></li>
<li><a href='#jagsfilter'><p>jagsfilter</p></a></li>
<li><a href='#logcorr'><p>logcorr</p></a></li>
<li><a href='#maxthreshold'><p>maxthreshold</p></a></li>
<li><a href='#mcmcestpars'><p>mcmcestpars</p></a></li>
<li><a href='#mcmctsir'><p>mcmctsir</p></a></li>
<li><a href='#plotbeta'><p>plotbeta</p></a></li>
<li><a href='#plotbreaks'><p>plotbreaks</p></a></li>
<li><a href='#plotcases'><p>plotcases</p></a></li>
<li><a href='#plotcomp'><p>plotcomp</p></a></li>
<li><a href='#plotdata'><p>plotdata</p></a></li>
<li><a href='#plotforward'><p>plotforward</p></a></li>
<li><a href='#plotLLE'><p>plotLLE</p></a></li>
<li><a href='#plotregression'><p>plotregression</p></a></li>
<li><a href='#plotres'><p>plotres</p></a></li>
<li><a href='#plotrho'><p>plotrho</p></a></li>
<li><a href='#plotsbar'><p>plotsbar</p></a></li>
<li><a href='#predicttsir'><p>predicttsir</p></a></li>
<li><a href='#residual.births'><p>residuals.births</p></a></li>
<li><a href='#residual.cases'><p>residuals.cases</p></a></li>
<li><a href='#runtsir'><p>runtsir</p></a></li>
<li><a href='#simulatetsir'><p>simulatetsir</p></a></li>
<li><a href='#TSIR_LE'><p>TSIR_LE</p></a></li>
<li><a href='#TSIR_LLE'><p>TSIR_LLE</p></a></li>
<li><a href='#tsiRdata'><p>tsiRdata</p></a></li>
<li><a href='#twentymeas'><p>Measles incidence data from 20 cities</p></a></li>
<li><a href='#vplayout'><p>vplayout</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Implementation of the TSIR Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-05</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the time-series Susceptible-Infected-Recovered (TSIR) model using a number of different fitting options for infectious disease time series data. The manuscript based on this package can be found here &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0185528">doi:10.1371/journal.pone.0185528</a>&gt;. The method implemented here is described by Finkenstadt and Grenfell (2000) &lt;<a href="https://doi.org/10.1111%2F1467-9876.00187">doi:10.1111/1467-9876.00187</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, kernlab, reshape2, grid</td>
</tr>
<tr>
<td>Contact:</td>
<td>adbecker at princeton dot edu</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-20 17:53:21 UTC; adbecker</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander D. Becker [aut, cre],
  Sinead E. Morris [ctb],
  Ottar N. Bjornstad [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander D. Becker &lt;adbecker@princeton.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-20 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='corr'>corr</h2><span id='topic+corr'></span>

<h3>Description</h3>

<p>Plot the correlation of the true data against the fitted resimulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_+3A_sim">sim</code></td>
<td>
<p>The dataframe or list produced by the 'runtsir' function.</p>
</td></tr>
</table>

<hr>
<h2 id='derivative'>derivative</h2><span id='topic+derivative'></span>

<h3>Description</h3>

<p>This function computes an 8 point derivative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative_+3A_x">X</code></td>
<td>
<p>The variable to differentiate with respect to.</p>
</td></tr>
<tr><td><code id="derivative_+3A_y">Y</code></td>
<td>
<p>The function / vector to differentiate.</p>
</td></tr>
</table>

<hr>
<h2 id='epitimes'>epitimes</h2><span id='topic+epitimes'></span>

<h3>Description</h3>

<p>The times at which we declare a new outbreak has started based on the threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epitimes(data, threshold, epi.length = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epitimes_+3A_data">data</code></td>
<td>
<p>The inputed data frame with the cases vector. This is the same data you put into runtsir.</p>
</td></tr>
<tr><td><code id="epitimes_+3A_threshold">threshold</code></td>
<td>
<p>The required number of cases observed to declare it an outbreak.</p>
</td></tr>
<tr><td><code id="epitimes_+3A_epi.length">epi.length</code></td>
<td>
<p>The required duration (in 52/IP weeks)  to declare it an outbreak.</p>
</td></tr>
</table>

<hr>
<h2 id='estpars'>estpars</h2><span id='topic+estpars'></span>

<h3>Description</h3>

<p>This function computes the set up to run the TSIR model, i.e. reconstructs susecptibles and
estimates beta and alpha. This can be plugged into simulatetsir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estpars(
  data,
  xreg = "cumcases",
  IP = 2,
  seasonality = "standard",
  regtype = "gaussian",
  sigmamax = 3,
  family = "gaussian",
  link = "identity",
  userYhat = numeric(),
  alpha = NULL,
  sbar = NULL,
  printon = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estpars_+3A_data">data</code></td>
<td>
<p>The data frame containing cases and interpolated births and populations.</p>
</td></tr>
<tr><td><code id="estpars_+3A_xreg">xreg</code></td>
<td>
<p>The x-axis for the regression. Options are 'cumcases' and 'cumbirths'. Defaults to 'cumcases'.</p>
</td></tr>
<tr><td><code id="estpars_+3A_ip">IP</code></td>
<td>
<p>The infectious period in weeks. This should be the same as your timestep. Defaults to 2 weeks.</p>
</td></tr>
<tr><td><code id="estpars_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of contact to use. Options are standard for 52/IP point contact or schoolterm for just a two point on off contact or none for a single contact parameter. Defaults to standard.</p>
</td></tr>
<tr><td><code id="estpars_+3A_regtype">regtype</code></td>
<td>
<p>The type of regression used in susceptible reconstruction.
Options are 'gaussian', 'lm' (linear model), 'spline' (smooth.spline with 2.5 degrees freedom),
'lowess' (with f = 2/3, iter = 1), 'loess' (degree 1), and 'user' which is just a user inputed vector.
Defaults to 'gaussian' and if that fails then defaults to loess.</p>
</td></tr>
<tr><td><code id="estpars_+3A_sigmamax">sigmamax</code></td>
<td>
<p>The inverse kernal width for the gaussian regression. Default is 3.
Smaller, stochastic outbreaks tend to need a lower sigma.</p>
</td></tr>
<tr><td><code id="estpars_+3A_family">family</code></td>
<td>
<p>The family in the GLM regression. One can use any of the GLM ones, but the options are essentially
'poisson' (with link='log'), 'gaussian' (with link='log' or 'identity'), or 'quasipoisson' (with link='log'). Default is 'gaussian'.</p>
</td></tr>
<tr><td><code id="estpars_+3A_link">link</code></td>
<td>
<p>The link function used with the glm family. Options are link='log' or 'identity'. Default is 'identity'.
to include some bayesian approaches. For 'bayesglm' we use a gaussian prior with mean 1e-4.</p>
</td></tr>
<tr><td><code id="estpars_+3A_useryhat">userYhat</code></td>
<td>
<p>The inputed regression vector if regtype='user'. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="estpars_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter. Defaults to NULL, i.e. the function estimates alpha.</p>
</td></tr>
<tr><td><code id="estpars_+3A_sbar">sbar</code></td>
<td>
<p>The mean number of susceptibles. Defaults to NULL, i.e. the function estimates sbar.</p>
</td></tr>
<tr><td><code id="estpars_+3A_printon">printon</code></td>
<td>
<p>Whether to show diagnostic prints or not, defaults to FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(kernlab)
London &lt;- twentymeas[["London"]]
parms &lt;- estpars(London)
names(parms)
sim &lt;- simulatetsir(London,parms=parms,inits.fit=FALSE)
plotres(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='jagsfilter'>jagsfilter</h2><span id='topic+jagsfilter'></span>

<h3>Description</h3>

<p>Used internally to filter jags results to give just the inference well use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jagsfilter(mcmcresults)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jagsfilter_+3A_mcmcresults">mcmcresults</code></td>
<td>
<p>is the input from the jags model.</p>
</td></tr>
</table>

<hr>
<h2 id='logcorr'>logcorr</h2><span id='topic+logcorr'></span>

<h3>Description</h3>

<p>Plot the correlation of the true data against the fitted resimulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logcorr(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logcorr_+3A_sim">sim</code></td>
<td>
<p>The dataframe or list produced by the 'runtsir' function.</p>
</td></tr>
</table>

<hr>
<h2 id='maxthreshold'>maxthreshold</h2><span id='topic+maxthreshold'></span>

<h3>Description</h3>

<p>A function used to optimize the threshold parameter to give the best fit to the data. Optimizes the fit based on R squared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxthreshold(
  data,
  nsim = 2,
  IP = 2,
  method = "deterministic",
  inits.fit = FALSE,
  parms,
  thresholdmin = 2,
  thresholdmax = 20,
  printon = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxthreshold_+3A_data">data</code></td>
<td>
<p>The time, cases, births, pop data frame.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to do.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_ip">IP</code></td>
<td>
<p>The infectious period, which should the time step of the data.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_method">method</code></td>
<td>
<p>The forward simulation method used, i.e. deterministic, negbin, pois.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_inits.fit">inits.fit</code></td>
<td>
<p>Whether or not to fit initial conditions as well. Defaults to FALSE here. This parameter is more necessary in more chaotic locations.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_parms">parms</code></td>
<td>
<p>The estimated parameters from estpars or mcmcestpars.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_thresholdmin">thresholdmin</code></td>
<td>
<p>The minimum number of cases to be considered an outbreak.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_thresholdmax">thresholdmax</code></td>
<td>
<p>The max number of cases to be considered an outbreak.</p>
</td></tr>
<tr><td><code id="maxthreshold_+3A_printon">printon</code></td>
<td>
<p>A T/F statement to print the progress.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(kernlab)
Mold &lt;- twentymeas[["Mold"]]
plotdata(Mold)
## Not run: 
parms &lt;- estpars(data=Mold,alpha=0.97)
tau &lt;- maxthreshold(data=Mold,parms=parms,
thresholdmin=8,thresholdmax=12,inits.fit=FALSE)
res &lt;- simulatetsir(data=Mold,parms=parms,
epidemics='break',threshold=tau,method='negbin',inits.fit=FALSE)
plotres(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmcestpars'>mcmcestpars</h2><span id='topic+mcmcestpars'></span>

<h3>Description</h3>

<p>This function computes the set up to run the TSIR model, i.e. reconstructes susecptibles and
estimates beta and alpha using MCMC computations. Used the same way as estpars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcestpars(
  data,
  xreg = "cumcases",
  IP = 2,
  regtype = "gaussian",
  sigmamax = 3,
  seasonality = "standard",
  userYhat = numeric(),
  update.iter = 10000,
  n.iter = 30000,
  n.chains = 3,
  n.adapt = 1000,
  burn.in = 100,
  sbar = NULL,
  alpha = NULL,
  printon = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcestpars_+3A_data">data</code></td>
<td>
<p>The data frame containing cases and interpolated births and populations.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_xreg">xreg</code></td>
<td>
<p>The x-axis for the regression. Options are 'cumcases' and 'cumbirths'. Defaults to 'cumcases'.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_ip">IP</code></td>
<td>
<p>The infectious period in weeks. Defaults to 2 weeks.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_regtype">regtype</code></td>
<td>
<p>The type of regression used in susceptible reconstruction.
Options are 'gaussian', 'lm' (linear model), 'spline' (smooth.spline with 2.5 degrees freedom),
'lowess' (with f = 2/3, iter = 1), 'loess' (degree 1), and 'user' which is just a user inputed vector.
Defaults to 'gaussian' and if that fails then defaults to loess.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_sigmamax">sigmamax</code></td>
<td>
<p>The inverse kernal width for the gaussian regression. Default is 3.
Smaller, stochastic outbreaks tend to need a lower sigma.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of contact to use. Options are standard for 52/IP point contact or schoolterm for just a two point on off contact or none for a single contact parameter. Defaults to standard.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_useryhat">userYhat</code></td>
<td>
<p>The inputed regression vector if regtype='user'. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_update.iter">update.iter</code></td>
<td>
<p>Number of MCMC iterations to use in the update aspect. Default is 10000.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of MCMC iterations to use. Default is 30000.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of MCMC chains to use. Default is 3.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Adaptive number for MCMC. Default is 1000.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_burn.in">burn.in</code></td>
<td>
<p>Burn in number. Default is 100.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_sbar">sbar</code></td>
<td>
<p>The mean number of susceptibles. Defaults to NULL, i.e. the function estimates sbar.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter. Defaults to NULL, i.e. the function estimates alpha.</p>
</td></tr>
<tr><td><code id="mcmcestpars_+3A_printon">printon</code></td>
<td>
<p>Whether to show diagnostic prints or not, defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='mcmctsir'>mcmctsir</h2><span id='topic+mcmctsir'></span>

<h3>Description</h3>

<p>This function runs the TSIR model using a MCMC estimation. The susceptibles are still reconstructed in the same way as the regular tsir model, however beta, alpha, and sbar (or whatever combination you enter) are estimated using rjargs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmctsir(
  data,
  xreg = "cumcases",
  IP = 2,
  nsim = 100,
  regtype = "gaussian",
  sigmamax = 3,
  userYhat = numeric(),
  update.iter = 10000,
  n.iter = 30000,
  n.chains = 3,
  n.adapt = 1000,
  burn.in = 100,
  method = "deterministic",
  epidemics = "cont",
  pred = "forward",
  seasonality = "standard",
  inits.fit = FALSE,
  threshold = 1,
  sbar = NULL,
  alpha = NULL,
  add.noise.sd = 0,
  mul.noise.sd = 0,
  printon = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmctsir_+3A_data">data</code></td>
<td>
<p>The data frame containing cases and interpolated births and populations.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_xreg">xreg</code></td>
<td>
<p>The x-axis for the regression. Options are 'cumcases' and 'cumbirths'. Defaults to 'cumcases'.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_ip">IP</code></td>
<td>
<p>The infectious period in weeks. Defaults to 2 weeks.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to do. Defaults to 100.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_regtype">regtype</code></td>
<td>
<p>The type of regression used in susceptible reconstruction.
Options are 'gaussian', 'lm' (linear model), 'spline' (smooth.spline with 2.5 degrees freedom),
'lowess' (with f = 2/3, iter = 1), 'loess' (degree 1), and 'user' which is just a user inputed vector.
Defaults to 'gaussian' and if that fails then defaults to loess.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_sigmamax">sigmamax</code></td>
<td>
<p>The inverse kernal width for the gaussian regression. Default is 3.
Smaller, stochastic outbreaks tend to need a lower sigma.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_useryhat">userYhat</code></td>
<td>
<p>The inputed regression vector if regtype='user'. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_update.iter">update.iter</code></td>
<td>
<p>Number of MCMC iterations to use in the update aspect. Default is 10000.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_n.iter">n.iter</code></td>
<td>
<p>Number of MCMC iterations to use. Default is 30000.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_n.chains">n.chains</code></td>
<td>
<p>Number of MCMC chains to use. Default is 3.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Adaptive number for MCMC. Default is 1000.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_burn.in">burn.in</code></td>
<td>
<p>Burn in number. Default is 100.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_method">method</code></td>
<td>
<p>The type of next step prediction used. Options are 'negbin' for negative binomial,
'pois' for poisson distribution, and 'deterministic'. Defaults to 'deterministic'.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_epidemics">epidemics</code></td>
<td>
<p>The type of data splitting. Options are 'cont' which doesn't split the data up at all,
and 'break' which breaks the epidemics up if there are a lot of zeros. Defaults to 'cont'.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_pred">pred</code></td>
<td>
<p>The type of prediction used. Options are 'forward' and 'step-ahead'. Defaults to 'forward'.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of contact to use. Options are standard for 52/IP point contact or schoolterm for just a two point on off contact or none for a single contact parameter. Defaults to standard.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_inits.fit">inits.fit</code></td>
<td>
<p>Whether or not to fit initial conditions using simple least squares as well. Defaults to FALSE. This parameter is more necessary in more chaotic locations.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_threshold">threshold</code></td>
<td>
<p>The cut off for a new epidemic if epidemics = 'break'. Defaults to 1.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_sbar">sbar</code></td>
<td>
<p>The mean number of susceptibles. Defaults to NULL, i.e. the function estimates sbar.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter. Defaults to NULL, i.e. the function estimates alpha.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_add.noise.sd">add.noise.sd</code></td>
<td>
<p>The sd for additive noise, defaults to zero.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_mul.noise.sd">mul.noise.sd</code></td>
<td>
<p>The sd for multiplicative noise, defaults to zero.</p>
</td></tr>
<tr><td><code id="mcmctsir_+3A_printon">printon</code></td>
<td>
<p>Whether to show diagnostic prints or not, defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='plotbeta'>plotbeta</h2><span id='topic+plotbeta'></span>

<h3>Description</h3>

<p>Plots the inferred beta with confidence intervals (when they can be calculated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbeta(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbeta_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
</table>

<hr>
<h2 id='plotbreaks'>plotbreaks</h2><span id='topic+plotbreaks'></span>

<h3>Description</h3>

<p>Plots the cases data with a line whenever the forward simulation is seeded using the real data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbreaks(data, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotbreaks_+3A_data">data</code></td>
<td>
<p>Data frame with the cases vector.</p>
</td></tr>
<tr><td><code id="plotbreaks_+3A_threshold">threshold</code></td>
<td>
<p>The epidemic threshold, i.e. the number of cases required to spark a new outbreak in the model.</p>
</td></tr>
</table>

<hr>
<h2 id='plotcases'>plotcases</h2><span id='topic+plotcases'></span>

<h3>Description</h3>

<p>Plots just the cases data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcases(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotcases_+3A_data">data</code></td>
<td>
<p>The data frame with cases.</p>
</td></tr>
</table>

<hr>
<h2 id='plotcomp'>plotcomp</h2><span id='topic+plotcomp'></span>

<h3>Description</h3>

<p>Plots just the comparison of the forward simulation fit to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcomp(sim, errtype = "95", max.plot = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotcomp_+3A_sim">sim</code></td>
<td>
<p>is list produced by runtsir or mcmctsir</p>
</td></tr>
<tr><td><code id="plotcomp_+3A_errtype">errtype</code></td>
<td>
<p>is the type of error bands to show. Defaults to '95' for 95 percent CI, the other option is 'sd' to standard deviation.</p>
</td></tr>
<tr><td><code id="plotcomp_+3A_max.plot">max.plot</code></td>
<td>
<p>the number of individual stochastic simulations to plot. Defaults to 10.</p>
</td></tr>
</table>

<hr>
<h2 id='plotdata'>plotdata</h2><span id='topic+plotdata'></span>

<h3>Description</h3>

<p>Plots the cases data as well as birth and population dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdata(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdata_+3A_data">data</code></td>
<td>
<p>The dataframe with time, cases, births, and pop.</p>
</td></tr>
</table>

<hr>
<h2 id='plotforward'>plotforward</h2><span id='topic+plotforward'></span>

<h3>Description</h3>

<p>Plots the forward simulation from the TSIR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotforward(dat, inverse = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotforward_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
<tr><td><code id="plotforward_+3A_inverse">inverse</code></td>
<td>
<p>a TRUE or FALSE option to plot the forward simulate negative (TRUE) or positive (FALSE). Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='plotLLE'>plotLLE</h2><span id='topic+plotLLE'></span>

<h3>Description</h3>

<p>Function to plot the Local Lyapunov Exponents. The output is of class ggplot2 so you can add standard
ggplot2 options to it if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLLE(LLE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLLE_+3A_lle">LLE</code></td>
<td>
<p>The output from TSIR_LLE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
require(kernlab)
require(ggplot2)
require(kernlab)
London &lt;- twentymeas$London
## just analyze the biennial portion of the data
London &lt;- subset(London, time &gt; 1950)

## define the interval to be 2 weeks
IP &lt;- 2

## first estimate paramters from the London data
parms &lt;- estpars(data=London, IP=2, regtype='gaussian',family='poisson',link='log')

## look at beta and alpha estimate
plotbeta(parms)

## simulate the fitted parameters
sim &lt;- simulatetsir(data=London,parms=parms,IP=2,method='deterministic',nsim=2)

## now lets predict forward 200 years using the mean birth rate,
## starting from rough initial conditions
times &lt;- seq(1965,2165, by = 1/ (52/IP))
births &lt;- rep(mean(London$births),length(times))
S0 &lt;- parms$sbar
I0 &lt;- 1e-5*mean(London$pop)

pred &lt;- predicttsir(times=times,births=births,
                   beta=parms$contact$beta,alpha=parms$alpha,
                  S0=S0,I0=I0,
                  nsim=50,stochastic=T)

## take the last 10 years
pred &lt;- lapply(pred, function(x)  tail(x, 52/IP * 20) )

## now compute the Lyapunov Exponent for the simulate and predicted model

simLE &lt;- TSIR_LE(
time=sim$res$time,
S=sim$simS$mean,
I=sim$res$mean,
alpha=sim$alpha,
  beta=sim$contact$beta,
IP=IP
)

predLE &lt;- TSIR_LE(
time=pred$I$time,
S=pred$S$X3,
I=pred$I$X3,
alpha=parms$alpha,
beta=parms$contact$beta,
IP=IP
)

simLE$LE
predLE$LE

simLLE &lt;- TSIR_LLE(simLE)
predLLE &lt;- TSIR_LLE(predLE)

plotLLE(simLLE)
plotLLE(predLLE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotregression'>plotregression</h2><span id='topic+plotregression'></span>

<h3>Description</h3>

<p>Plots the cumulative cases - cumulative births data and regression fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotregression(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotregression_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
</table>

<hr>
<h2 id='plotres'>plotres</h2><span id='topic+plotres'></span>

<h3>Description</h3>

<p>Plots diagnostics and results of the runtsir function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotres(dat, max.plot = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotres_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
<tr><td><code id="plotres_+3A_max.plot">max.plot</code></td>
<td>
<p>the number of individual stochastic simulations to plot. Defaults to 10.</p>
</td></tr>
</table>

<hr>
<h2 id='plotrho'>plotrho</h2><span id='topic+plotrho'></span>

<h3>Description</h3>

<p>Plots the inferred reporting rate, rho
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotrho(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotrho_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
</table>

<hr>
<h2 id='plotsbar'>plotsbar</h2><span id='topic+plotsbar'></span>

<h3>Description</h3>

<p>Plots the profile log likelihood calculation for inferred sbar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsbar(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsbar_+3A_dat">dat</code></td>
<td>
<p>the list produced from the runtsir, mcmctsir, and simulatetsir function.</p>
</td></tr>
</table>

<hr>
<h2 id='predicttsir'>predicttsir</h2><span id='topic+predicttsir'></span>

<h3>Description</h3>

<p>function to predict incidence and susceptibles using the tsir model. This is different than
simulatetsir as you are inputting parameters as vectors. The output is a data frame I and S with mean and confidence intervals of predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predicttsir(times, births, beta, alpha, S0, I0, nsim, stochastic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predicttsir_+3A_times">times</code></td>
<td>
<p>The time vector to predict the model from. This assumes that the time step is equal to IP</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_births">births</code></td>
<td>
<p>The birth vector (of length length(times) or a single element) where each element is the births in that given (52/IP) time step</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_beta">beta</code></td>
<td>
<p>The length(52/IP) beta vector of contact.</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric which acts as the homogeniety parameter.</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_s0">S0</code></td>
<td>
<p>The starting initial condition for S. This should be greater than one, i.e. not a fraction.</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_i0">I0</code></td>
<td>
<p>The starting initial condition for I. This should be greater than one, i.e. not a fraction.</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to perform.</p>
</td></tr>
<tr><td><code id="predicttsir_+3A_stochastic">stochastic</code></td>
<td>
<p>A TRUE / FALSE argument where FALSE is the deterministic model, and TRUE is a negative binomial distribution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(kernlab)
require(ggplot2)
require(kernlab)
require(tsiR)
London &lt;- twentymeas$London

London &lt;- subset(London, time &gt; 1950)

IP &lt;- 2
## first estimate paramters from the London data
parms &lt;- estpars(data=London, IP=2, regtype='gaussian')

plotbeta(parms)

## now lets predict forward 20 years using the mean birth rate,
## starting from rough initial conditions
births &lt;- min(London$births)
times &lt;- seq(1965,1985, by = 1/ (52/IP))
S0 &lt;- parms$sbar
I0 &lt;- 1e-5*mean(London$pop)

pred &lt;- predicttsir(times=times,births=births,
                    beta=parms$contact$beta,alpha=parms$alpha,
                    S0=S0,I0=I0,
                    nsim=50,stochastic=T)

## plot this prediction
ggplot(pred$I,aes(time,mean))+geom_line()+geom_ribbon(aes(ymin=low,ymax=high),alpha=0.3)



## End(Not run)
</code></pre>

<hr>
<h2 id='residual.births'>residuals.births</h2><span id='topic+residual.births'></span>

<h3>Description</h3>

<p>computes the residuals for when X is the cumulative births. Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.births(rho, Yhat, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual.births_+3A_rho">rho</code></td>
<td>
<p>The reporting rate, used to get units correct.</p>
</td></tr>
<tr><td><code id="residual.births_+3A_yhat">Yhat</code></td>
<td>
<p>The fitted regression line.</p>
</td></tr>
<tr><td><code id="residual.births_+3A_y">Y</code></td>
<td>
<p>The cumulative cases.</p>
</td></tr>
</table>

<hr>
<h2 id='residual.cases'>residuals.cases</h2><span id='topic+residual.cases'></span>

<h3>Description</h3>

<p>Computes the residuals for when X is the cumulative cases. Used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual.cases(Yhat, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residual.cases_+3A_yhat">Yhat</code></td>
<td>
<p>The fitted regression line.</p>
</td></tr>
<tr><td><code id="residual.cases_+3A_y">Y</code></td>
<td>
<p>The cumulative births.</p>
</td></tr>
</table>

<hr>
<h2 id='runtsir'>runtsir</h2><span id='topic+runtsir'></span>

<h3>Description</h3>

<p>This function runs the TSIR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runtsir(
  data,
  xreg = "cumcases",
  IP = 2,
  nsim = 10,
  regtype = "gaussian",
  sigmamax = 3,
  userYhat = numeric(),
  alpha = NULL,
  sbar = NULL,
  family = "gaussian",
  link = "identity",
  method = "deterministic",
  inits.fit = FALSE,
  epidemics = "cont",
  pred = "forward",
  threshold = 1,
  seasonality = "standard",
  add.noise.sd = 0,
  mul.noise.sd = 0,
  printon = F,
  fit = NULL,
  fittype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runtsir_+3A_data">data</code></td>
<td>
<p>The data frame containing cases and interpolated births and populations.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_xreg">xreg</code></td>
<td>
<p>The x-axis for the regression. Options are 'cumcases' and 'cumbirths'. Defaults to 'cumcases'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_ip">IP</code></td>
<td>
<p>The infectious period in weeks. Defaults to 2 weeks.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to do. Defaults to 100.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_regtype">regtype</code></td>
<td>
<p>The type of regression used in susceptible reconstruction.
Options are 'gaussian', 'lm' (linear model), 'spline' (smooth.spline with 2.5 degrees freedom),
'lowess' (with f = 2/3, iter = 1), 'loess' (degree 1), and 'user' which is just a user inputed vector.
Defaults to 'gaussian' and if that fails then defaults to loess.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_sigmamax">sigmamax</code></td>
<td>
<p>The inverse kernal width for the gaussian regression. Default is 3.
Smaller, stochastic outbreaks tend to need a lower sigma.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_useryhat">userYhat</code></td>
<td>
<p>The inputed regression vector if regtype='user'. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter. Defaults to NULL, i.e. the function estimates alpha.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_sbar">sbar</code></td>
<td>
<p>The mean number of susceptibles. Defaults to NULL, i.e. the function estimates sbar.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_family">family</code></td>
<td>
<p>The family in the GLM regression. One can use any of the GLM ones, but the options are essentially
'poisson' (with link='log'), 'gaussian' (with link='log' or 'identity'), or 'quasipoisson' (with link='log'). Default is 'gaussian'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_link">link</code></td>
<td>
<p>The link function used with the glm family. Options are link='log' or 'identity'. Default is 'identity'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_method">method</code></td>
<td>
<p>The type of next step prediction used. Options are 'negbin' for negative binomial,
'pois' for poisson distribution, and 'deterministic'. Defaults to 'deterministic'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_inits.fit">inits.fit</code></td>
<td>
<p>Whether or not to fit initial conditions using simple least squares as well. Defaults to FALSE. This parameter is more necessary in more chaotic locations.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_epidemics">epidemics</code></td>
<td>
<p>The type of data splitting. Options are 'cont' which doesn't split the data up at all,
and 'break' which breaks the epidemics up if there are a lot of zeros. Defaults to 'cont'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_pred">pred</code></td>
<td>
<p>The type of prediction used. Options are 'forward' and 'step-ahead'. Defaults to 'forward'.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_threshold">threshold</code></td>
<td>
<p>The cut off for a new epidemic if epidemics = 'break'. Defaults to 1.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_seasonality">seasonality</code></td>
<td>
<p>The type of contact to use. Options are standard for 52/IP point contact or schoolterm for just a two point on off contact, or none for a single contact parameter. Defaults to standard.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_add.noise.sd">add.noise.sd</code></td>
<td>
<p>The sd for additive noise, defaults to zero.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_mul.noise.sd">mul.noise.sd</code></td>
<td>
<p>The sd for multiplicative noise, defaults to zero.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_printon">printon</code></td>
<td>
<p>Whether to show diagnostic prints or not, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_fit">fit</code></td>
<td>
<p>Now removed but gives a warning.</p>
</td></tr>
<tr><td><code id="runtsir_+3A_fittype">fittype</code></td>
<td>
<p>Now removed but gives a warning.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(kernlab)
London &lt;- twentymeas[["London"]]
## Not run: 
plotdata(London)
res &lt;- runtsir(data=London,method='pois',nsim=10, IP=2,inits.fit=FALSE)
plotres(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulatetsir'>simulatetsir</h2><span id='topic+simulatetsir'></span>

<h3>Description</h3>

<p>This function just simulates the forward prediction given the data and a parms list generated from estpars or mcmcestpars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatetsir(
  data,
  nsim = 100,
  IP = 2,
  parms,
  method = "deterministic",
  epidemics = "cont",
  pred = "forward",
  threshold = 1,
  inits.fit = FALSE,
  add.noise.sd = 0,
  mul.noise.sd = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatetsir_+3A_data">data</code></td>
<td>
<p>The data frame containing cases and interpolated births and populations.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to do. Defaults to 100.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_ip">IP</code></td>
<td>
<p>The infectious period. Defaults to 2.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_parms">parms</code></td>
<td>
<p>Either the parameters estimated by estpars or mcmcestpars, or a list containing
beta, rho, Z, sbar, alpha, X, Y, Yhat, contact, alphalow, alphahigh, loglik, pop vectors.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_method">method</code></td>
<td>
<p>The type of next step prediction used. Options are 'negbin' for negative binomial,
'pois' for poisson distribution, and 'deterministic'. Defaults to 'deterministic'.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_epidemics">epidemics</code></td>
<td>
<p>The type of data splitting. Options are 'cont' which doesn't split the data up at all,
and 'break' which breaks the epidemics up if there are a lot of zeros. Defaults to 'cont'.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_pred">pred</code></td>
<td>
<p>The type of prediction used. Options are 'forward' and 'step-ahead'. Defaults to 'forward'.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_threshold">threshold</code></td>
<td>
<p>The cut off for a new epidemic if epidemics = 'break'. Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_inits.fit">inits.fit</code></td>
<td>
<p>Whether or not to fit initial conditions using simple least squares as well. Defaults to FALSE. This parameter is more necessary in more chaotic locations.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_add.noise.sd">add.noise.sd</code></td>
<td>
<p>The sd for additive noise, defaults to zero.</p>
</td></tr>
<tr><td><code id="simulatetsir_+3A_mul.noise.sd">mul.noise.sd</code></td>
<td>
<p>The sd for multiplicative noise, defaults to zero.</p>
</td></tr>
</table>

<hr>
<h2 id='TSIR_LE'>TSIR_LE</h2><span id='topic+TSIR_LE'></span>

<h3>Description</h3>

<p>A function to calculate the Lyapunov Exponennt (LE) from the TSIR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSIR_LE(time, S, I, alpha, beta, IP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSIR_LE_+3A_time">time</code></td>
<td>
<p>The time vector from the data or simulated data</p>
</td></tr>
<tr><td><code id="TSIR_LE_+3A_s">S</code></td>
<td>
<p>The S output from the simulated or predicted TSIR model</p>
</td></tr>
<tr><td><code id="TSIR_LE_+3A_i">I</code></td>
<td>
<p>The I output from the simulated or predicted TSIR model</p>
</td></tr>
<tr><td><code id="TSIR_LE_+3A_alpha">alpha</code></td>
<td>
<p>The homogeneity parameter from the simulated or predicted TSIR model</p>
</td></tr>
<tr><td><code id="TSIR_LE_+3A_beta">beta</code></td>
<td>
<p>The inferred contact rate, use beta = contact$beta where contact is an output from runtsir or simulatetsir</p>
</td></tr>
<tr><td><code id="TSIR_LE_+3A_ip">IP</code></td>
<td>
<p>The generation interval of the pathogen (in weeks)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(kernlab)
require(ggplot2)
require(kernlab)
London &lt;- twentymeas$London
## just analyze the biennial portion of the data
London &lt;- subset(London, time &gt; 1950)

## define the interval to be 2 weeks
IP &lt;- 2

## first estimate paramters from the London data
parms &lt;- estpars(data=London, IP=2, regtype='gaussian',family='poisson',link='log')

## look at beta and alpha estimate
plotbeta(parms)

## simulate the fitted parameters
sim &lt;- simulatetsir(data=London,parms=parms,IP=2,method='deterministic',nsim=2)

## now lets predict forward 200 years using the mean birth rate,
## starting from rough initial conditions
times &lt;- seq(1965,2165, by = 1/ (52/IP))
births &lt;- rep(mean(London$births),length(times))
S0 &lt;- parms$sbar
I0 &lt;- 1e-5*mean(London$pop)

pred &lt;- predicttsir(times=times,births=births,
                   beta=parms$contact$beta,alpha=parms$alpha,
                  S0=S0,I0=I0,
                  nsim=50,stochastic=T)

## take the last 10 years
pred &lt;- lapply(pred, function(x)  tail(x, 52/IP * 20) )

## now compute the Lyapunov Exponent for the simulate and predicted model

simLE &lt;- TSIR_LE(
time=sim$res$time,
S=sim$simS$mean,
I=sim$res$mean,
alpha=sim$alpha,
  beta=sim$contact$beta,
IP=IP
)

predLE &lt;- TSIR_LE(
time=pred$I$time,
S=pred$S$X3,
I=pred$I$X3,
alpha=parms$alpha,
beta=parms$contact$beta,
IP=IP
)

simLE$LE
predLE$LE



## End(Not run)
</code></pre>

<hr>
<h2 id='TSIR_LLE'>TSIR_LLE</h2><span id='topic+TSIR_LLE'></span>

<h3>Description</h3>

<p>A function to calculate the Local Lyapunov Exponennt (LLE) from the TSIR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSIR_LLE(LE, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSIR_LLE_+3A_le">LE</code></td>
<td>
<p>The output of TSIR_LE to pass the Jacobian elements</p>
</td></tr>
<tr><td><code id="TSIR_LLE_+3A_m">m</code></td>
<td>
<p>The window to sweep the time-varying Jacobian elements. Defaults to one.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
require(kernlab)
require(ggplot2)
require(kernlab)
London &lt;- twentymeas$London
## just analyze the biennial portion of the data
London &lt;- subset(London, time &gt; 1950)

## define the interval to be 2 weeks
IP &lt;- 2

## first estimate paramters from the London data
parms &lt;- estpars(data=London, IP=2, regtype='gaussian',family='poisson',link='log')

## look at beta and alpha estimate
plotbeta(parms)

## simulate the fitted parameters
sim &lt;- simulatetsir(data=London,parms=parms,IP=2,method='deterministic',nsim=2)

## now lets predict forward 200 years using the mean birth rate,
## starting from rough initial conditions
times &lt;- seq(1965,2165, by = 1/ (52/IP))
births &lt;- rep(mean(London$births),length(times))
S0 &lt;- parms$sbar
I0 &lt;- 1e-5*mean(London$pop)

pred &lt;- predicttsir(times=times,births=births,
                   beta=parms$contact$beta,alpha=parms$alpha,
                  S0=S0,I0=I0,
                  nsim=50,stochastic=T)

## take the last 10 years
pred &lt;- lapply(pred, function(x)  tail(x, 52/IP * 20) )

## now compute the Lyapunov Exponent for the simulate and predicted model

simLE &lt;- TSIR_LE(
time=sim$res$time,
S=sim$simS$mean,
I=sim$res$mean,
alpha=sim$alpha,
  beta=sim$contact$beta,
IP=IP
)

predLE &lt;- TSIR_LE(
time=pred$I$time,
S=pred$S$X3,
I=pred$I$X3,
alpha=parms$alpha,
beta=parms$contact$beta,
IP=IP
)

simLE$LE
predLE$LE

simLLE &lt;- TSIR_LLE(simLE)
predLLE &lt;- TSIR_LLE(predLE)

plotLLE(simLLE)
plotLLE(predLLE)

## End(Not run)

</code></pre>

<hr>
<h2 id='tsiRdata'>tsiRdata</h2><span id='topic+tsiRdata'></span>

<h3>Description</h3>

<p>A function to take in time cases births and pop vectors (of any lengths) and interpolate them using the given infectious period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsiRdata(time, cases, births, pop, IP = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsiRdata_+3A_time">time</code></td>
<td>
<p>The time vector.</p>
</td></tr>
<tr><td><code id="tsiRdata_+3A_cases">cases</code></td>
<td>
<p>The cases vector.</p>
</td></tr>
<tr><td><code id="tsiRdata_+3A_births">births</code></td>
<td>
<p>The births vector.</p>
</td></tr>
<tr><td><code id="tsiRdata_+3A_pop">pop</code></td>
<td>
<p>The population vector.</p>
</td></tr>
<tr><td><code id="tsiRdata_+3A_ip">IP</code></td>
<td>
<p>The infectious period (in weeks) to discretize to. Defaults to 2.</p>
</td></tr>
</table>

<hr>
<h2 id='twentymeas'>Measles incidence data from 20 cities
</h2><span id='topic+twentymeas'></span>

<h3>Description</h3>

<p>twentymeas is a list containing 20 dataframes with cases, births, populations. Each dataframe is a 22 year time series at biweekly (i.e. IP=2) intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("twentymeas")</code></pre>


<h3>Source</h3>

<p>From Bryan Grenfell</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(twentymeas)
london &lt;- twentymeas[["London"]]
plotdata(london)</code></pre>

<hr>
<h2 id='vplayout'>vplayout</h2><span id='topic+vplayout'></span>

<h3>Description</h3>

<p>the function just breaks up the plot area into a grid. Called internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vplayout(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vplayout_+3A_x">x</code></td>
<td>
<p>is the x location of the plot</p>
</td></tr>
<tr><td><code id="vplayout_+3A_y">y</code></td>
<td>
<p>is the y lcoation of the ploy</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
