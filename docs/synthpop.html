<!DOCTYPE html><html><head><title>Help for package synthpop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {synthpop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#codebook.syn'><p>Makes a codebook from a data frame</p></a></li>
<li><a href='#compare'>
<p>Comparison of synthesised and observed data</p></a></li>
<li><a href='#compare.fit.synds'>
<p>Compare model estimates based on synthesised and observed data</p></a></li>
<li><a href='#compare.synds'>
<p>Compare univariate distributions of synthesised and observed data</p></a></li>
<li><a href='#glm.synds, lm.synds'><p>Fitting (generalized) linear models to synthetic data</p></a></li>
<li><a href='#multi.compare'>
<p>Multivariate comparison of synthesised and observed data</p></a></li>
<li><a href='#multinom.synds'><p>Fitting multinomial models to synthetic data</p></a></li>
<li><a href='#numtocat.syn'><p>Group numeric variables before synthesis</p></a></li>
<li><a href='#polr.synds'><p>Fitting ordered logistic models to synthetic data</p></a></li>
<li><a href='#read.obs'><p>Importing original data sets form external files</p></a></li>
<li><a href='#replicated.uniques'><p>Replications in synthetic data</p></a></li>
<li><a href='#SD2011'>
<p>Social Diagnosis 2011 - Objective and Subjective Quality of Life in Poland</p></a></li>
<li><a href='#sdc'><p>Tools for statistical disclosure control (sdc)</p></a></li>
<li><a href='#summary.fit.synds'><p>Inference from synthetic data</p></a></li>
<li><a href='#summary.synds'><p>Synthetic data object summaries</p></a></li>
<li><a href='#syn'><p>Generating synthetic data sets</p></a></li>
<li><a href='#syn.bag'><p>Synthesis with bagging</p></a></li>
<li><a href='#syn.catall'><p>Synthesis of a group of categorical variables from a saturated model</p></a></li>
<li><a href='#syn.ctree, syn.cart'><p>Synthesis with classification and regression trees (CART)</p></a></li>
<li><a href='#syn.ipf'><p>Synthesis of a group of categorical variables by iterative</p>
proportional fitting</a></li>
<li><a href='#syn.lognorm, syn.sqrtnorm, syn.cubertnorm'><p>Synthesis by linear regression after transformation of</p>
a dependent variable</a></li>
<li><a href='#syn.logreg'><p>Synthesis by logistic regression</p></a></li>
<li><a href='#syn.nested'><p>Synthesis for a variable nested within another variable.</p></a></li>
<li><a href='#syn.norm'><p>Synthesis by linear regression</p></a></li>
<li><a href='#syn.normrank'><p>Synthesis by normal linear regression preserving</p>
the marginal distribution</a></li>
<li><a href='#syn.passive'><p>Passive synthesis</p></a></li>
<li><a href='#syn.pmm'><p>Synthesis by predictive mean matching</p></a></li>
<li><a href='#syn.polr'><p>Synthesis by ordered polytomous regression</p></a></li>
<li><a href='#syn.polyreg'><p>Synthesis by unordered polytomous regression</p></a></li>
<li><a href='#syn.ranger'><p>Synthesis with a fast implementation of random forests</p></a></li>
<li><a href='#syn.rf'><p>Synthesis with random forest</p></a></li>
<li><a href='#syn.sample'><p>Synthesis by simple random sampling</p></a></li>
<li><a href='#syn.satcat'><p>Synthesis from a saturated model based on all combinations of the</p>
predictor variables.</a></li>
<li><a href='#syn.smooth'><p>syn.smooth</p></a></li>
<li><a href='#syn.survctree'><p>Synthesis of survival time by classification and regression trees (CART)</p></a></li>
<li><a href='#synthpop-package'><p>Generating synthetic versions of sensitive microdata for statistical disclosure control</p></a></li>
<li><a href='#utility.gen'><p>Distributional comparison of synthesised and observed data</p></a></li>
<li><a href='#utility.tab'><p>Tabular utility</p></a></li>
<li><a href='#utility.tables'><p>Tables and plots of utility measures</p></a></li>
<li><a href='#write.syn'><p>Exporting synthetic data sets to external files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generating Synthetic Versions of Sensitive Microdata for
Statistical Disclosure Control</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Beata Nowok [aut, cre],
  Gillian M Raab [aut],
  Chris Dibben [ctb],
  Joshua Snoke [ctb],
  Caspar van Lissa [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Beata Nowok &lt;beata.nowok@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool for producing synthetic versions of microdata containing confidential information so that they are safe to be released to users for exploratory analysis. The key objective of generating synthetic data is to replace sensitive original values with synthetic ones causing minimal distortion of the statistical information contained in the data set. Variables, which can be categorical or continuous, are synthesised one-by-one using sequential modelling. Replacements are generated by drawing from conditional distributions fitted to the original data using parametric or classification and regression trees models. Data are synthesised via the function syn() which can be largely automated, if default settings are used, or with methods defined by the user. Optional parameters can be used to influence the disclosure risk and the analytical quality of the synthesised data. For a description of the implemented method see Nowok, Raab and Dibben (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v074.i11">doi:10.18637/jss.v074.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.synthpop.org.uk/">https://www.synthpop.org.uk/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, MASS, methods, nnet, ggplot2, graphics, stats, utils,
rpart, party, foreign, plyr, proto, polspline, randomForest,
ranger, classInt, mipfp, survival, stringr, rmutil, broman</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-31 09:22:55 UTC; beatan01</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-31 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='codebook.syn'>Makes a codebook from a data frame</h2><span id='topic+codebook.syn'></span>

<h3>Description</h3>

<p>Describes features of variables in a data frame relevant for synthesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codebook.syn(data, maxlevs = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codebook.syn_+3A_data">data</code></td>
<td>
<p>a data frame with a data set to be synthesised.</p>
</td></tr>
<tr><td><code id="codebook.syn_+3A_maxlevs">maxlevs</code></td>
<td>
<p>the number of factor levels above which separate tables with 
all labels are returned as part of <code>labs</code> component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components.
</p>
<p><code>tab</code> - a data frame with the following information about each variable:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>class of variable</p>
</td></tr>
<tr><td><code>nmiss</code></td>
<td>
<p>number of missing values (<code>NA</code>)</p>
</td></tr>
<tr><td><code>perctmiss</code></td>
<td>
<p>percentage of missing values</p>
</td></tr>
<tr><td><code>ndistinct</code></td>
<td>
<p>number of distinct values (excluding missing values)</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>range for numeric variables, maximum length for character 
variables, labels for factors with &lt;= maxlevs levels</p>
</td></tr>
</table>
<p><code>labs</code> - a list of extra tables with labels for each factor with number 
of levels greater than <code>maxlevs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>codebook.syn(SD2011)
</code></pre>

<hr>
<h2 id='compare'>
Comparison of synthesised and observed data
</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>A generic function for comparison of synthesised and observed data. 
The function invokes particular methods which depend on the class 
of the first argument. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> compare(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_object">object</code></td>
<td>
<p>a synthetic data object of class <code>synds</code> 
or <code>fit.synds</code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_data">data</code></td>
<td>
<p>an original observed data set.</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>additional arguments specific to a method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compare methods facilitate quality assessment of synthetic data by comapring 
them with the original observed data sets. The data themselves (for class 
<code>synds</code>) or models fitted to them (for class <code>fit.synds</code>) are 
compared.   
</p>


<h3>Value</h3>

<p>The value returned by <code>compare</code> depends on the class of its argument. 
See the documentation of the particular methods for details. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare.synds">compare.synds</a></code>, <code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>
</p>

<hr>
<h2 id='compare.fit.synds'>
Compare model estimates based on synthesised and observed data
</h2><span id='topic+compare.fit.synds'></span><span id='topic+print.compare.fit.synds'></span>

<h3>Description</h3>

<p>The same model that was used for the synthesised data set is fitted to the 
observed data set. The coefficients with confidence intervals for the 
observed data is plotted together with their estimates from synthetic data. 
When more than one synthetic data set has been generated (<code>object$m&gt;1</code>) 
combining rules are applied. Analysis-specific utility measures are used to
evaluate differences between synthetic and observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit.synds'
compare(object, data, plot = "Z", 
  print.coef = FALSE, return.plot = TRUE, plot.intercept = FALSE, 
  lwd = 1, lty = 1, lcol = c("#1A3C5A","#4187BF"), 
  dodge.height = .5, point.size = 2.5,
  population.inference = FALSE, ci.level = 0.95, ...)

## S3 method for class 'compare.fit.synds'
print(x, print.coef = x$print.coef, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.fit.synds_+3A_object">object</code></td>
<td>
<p>an object of type <code>fit.synds</code> created by fitting a model 
to synthesised data set using function <code><a href="#topic+glm.synds">glm.synds</a></code> or
<code><a href="#topic+lm.synds">lm.synds</a></code>.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_data">data</code></td>
<td>
<p>an original observed data set.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_plot">plot</code></td>
<td>
<p>values to be plotted: <code>"Z"</code> (Z scores) or <code>"coef"</code>
(coefficients).</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_print.coef">print.coef</code></td>
<td>
<p>a logical value determining whether tables of 
estimates for the original and synthetic data should be printed.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_return.plot">return.plot</code></td>
<td>
<p>a logical value indicating whether a confidence interval
plot should be returned.</p>
</td></tr>   
<tr><td><code id="compare.fit.synds_+3A_plot.intercept">plot.intercept</code></td>
<td>
<p>a logical value indicating whether estimates for 
intercept should be plotted.</p>
</td></tr>  
<tr><td><code id="compare.fit.synds_+3A_lwd">lwd</code></td>
<td>
<p>the line type.</p>
</td></tr>  
<tr><td><code id="compare.fit.synds_+3A_lty">lty</code></td>
<td>
<p>the line width.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_lcol">lcol</code></td>
<td>
<p>line colours.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_dodge.height">dodge.height</code></td>
<td>
<p>size of vertical shifts for confidence intervals to 
prevent overlaping.</p>
</td></tr> 
<tr><td><code id="compare.fit.synds_+3A_point.size">point.size</code></td>
<td>
<p>size of plotting symbols used to plot point estimates of 
coefficients.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_population.inference">population.inference</code></td>
<td>
<p>a logical value indicating whether intervals for 
inference to population quantities, as decribed by Karr et al. (2006), 
should be calculated and plotted. This option suppresses the lack-of-fit test 
and the standardised differences since these are based on differences 
standardised by the original interval widths.</p>
</td></tr> 
<tr><td><code id="compare.fit.synds_+3A_ci.level">ci.level</code></td>
<td>
<p>Confidence interval coverage as a proportion.</p>
</td></tr> 
<tr><td><code id="compare.fit.synds_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="compare.fit.synds_+3A_x">x</code></td>
<td>
<p>an object of class <code>compare.fit.synds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to evaluate whether the method used for 
synthesis is appropriate for the fitted model. If this is the case the 
estimates from the  synthetic dataof what would be expected from the original 
data <code>xpct(Beta)</code> <code>xpct(Z)</code> should not differ from the estimates from 
the observed data (<code>Beta</code> and <code>Z</code>) by more than would be expected from 
the standard errors (<code>se(Beta)</code> and <code>se(Z)</code>). For more details see the 
vignette on inference.
</p>


<h3>Value</h3>

<p>An object of class <code>compare.fit.synds</code> which is a list with the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to fit the model to the synthesised data set.</p>
</td></tr>
<tr><td><code>coef.obs</code></td>
<td>
<p>a data frame including estimates based on the observed
data: coefficients (<code>Beta</code>), their standard errors (<code>se(Beta)</code>)
and Z scores (<code>Z</code>).</p>
</td></tr>
<tr><td><code>coef.syn</code></td>
<td>
<p>a data frame including (combined) estimates based on 
the synthesised data: point estimates of observed data coefficients 
(<code>B.syn</code>), standard errors of those estimates (<code>se(B.syn)</code>), 
estimates of the observed standard errors (<code>se(Beta).syn</code>), Z scores 
estimates (<code>Z.syn</code>) and their standard errors (<code>se(Z.syn)</code>). 
Note that <code>se(B.syn)</code> and <code>se(Z.syn)</code> give the standard errors 
of the mean of the <code>m</code> syntheses and can be made very small by 
increasing <code>m</code> (see the vignette on inference for more details).</p>
</td></tr>
<tr><td><code>coef.diff</code></td>
<td>
<p>a data frame containing standardized differences between 
the coefficients estimated from the original data and those calculated 
from the combined synthetic data. The difference is standardized by dividing 
by the estimated standard error of the fit from the original. The corresponding 
p-values are calculated from a standard Normal distribution and represent the 
probability of achieving differences as large as those found if the model use 
for synthesis is compatible with the model that generated the original data.</p>
</td></tr>  
<tr><td><code>mean.abs.std.diff</code></td>
<td>
<p>Mean absolute standardized difference (over all 
coefficients).</p>
</td></tr> 
<tr><td><code>ci.overlap</code></td>
<td>
<p>a data frame containing the percentage of overlap between 
the estimated synthetic confidence intervals and the original sample 
confidence intervals for each parameter. When <code>population.inference = TRUE</code> 
overlaps are calculated as suggested by Karr et al. (2006). Otherwise 
a simpler overlap measure with intervals of equal length is calculated.</p>
</td></tr>
<tr><td><code>mean.ci.overlap</code></td>
<td>
<p>Mean confidence interval overlap (over all 
coefficients).</p>
</td></tr>    
<tr><td><code>lack.of.fit</code></td>
<td>
<p>lack-of-fit measure from all <code>m</code> synthetic data 
sets combined, calculated as follows, when <code>object$incomplete = FALSE</code>. 
The vector of mean differences (<code>diff</code>) between the coefficients 
calculated from the synthetic and original data provides 
a standardised <code>lack-of-fit = t(diff) %*% V^(-1) t(diff)</code>, where 
<code>%*%</code> represents the matrix product and <code>V^(-1)</code> is the 
inverse of the variance-covariance matrix for the mean coefficients 
from the original data. If the model used to synthesize the data is 
correct this quantity, which is a Mahalanobis distance measure, will 
follow a chi-squared distribution with degrees of freedom, and thus 
expectation, equal to the number of parameters (<code>p</code>) in the fitted 
model. When <code>object$incomplete = TRUE</code> the variance-covariance matrix
of the coefficients is estimated from the differences between the m 
estimates and the lack-of-fit statistic follows  a Hotelling's <code>T*2</code> 
distribution and the lack-of-fit statistic is referred to an <code>F(p, m - p)</code>.</p>
</td></tr>
<tr><td><code>lof.pvalue</code></td>
<td>
<p>p-value for the combined lack-of-fit test of the NULL 
hypothesis that the method used for synthesis retains all relationships 
between variables that influence the parameters of the fit.</p>
</td></tr>  
<tr><td><code>ci.plot</code></td>
<td>
<p><code>ggplot</code> of the the coefficients with confidence 
intervals for models based on observed and synthetic data. 
If <code>return.plot</code> was set to <code>FALSE</code> then <code>ci.plot</code> 
is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>print.coef</code></td>
<td>
<p>a logical value determining whether tables of 
estimates for the original and synthetic data should be printed.</p>
</td></tr>  
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the original (observed) data.</p>
</td></tr> 
<tr><td><code>ncoef</code></td>
<td>
<p>the number of coefficients in the fitted model (including an 
intercept).</p>
</td></tr> 
<tr><td><code>incomplete</code></td>
<td>
<p>whether methods for incomplete synthesis due to Reiter 
(2003) have been used in calculations.</p>
</td></tr>
<tr><td><code>population.inference</code></td>
<td>
<p>whether intervals as decribed by Karr et al. 
(2016) have been calculated.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Karr, A., Kohnen, C.N., Oganian, A., Reiter, J.P. and Sanil, A.P. (2006). 
A framework for evaluating the utility of data altered to protect 
confidentiality. <em>The American Statistician</em>, <b>60</b>(3), 224-232.
</p>
<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>
<p>Reiter, J.P. (2003) Inference for partially synthetic, public use microdata 
sets. <em>Survey Methodology</em>, <b>29</b>, 181-188.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[,c("sex","age","edu","smoke")]
s1 &lt;- syn(ods, m = 3)
f1 &lt;- glm.synds(smoke ~ sex + age + edu, data = s1, family = "binomial")
compare(f1, ods) 
compare(f1, ods, print.coef = TRUE, plot = "coef")
</code></pre>

<hr>
<h2 id='compare.synds'>
Compare univariate distributions of synthesised and observed data
</h2><span id='topic+compare.synds'></span><span id='topic+compare.data.frame'></span><span id='topic+compare.list'></span><span id='topic+print.compare.synds'></span>

<h3>Description</h3>

<p>Compare synthesised data set with the original (observed) data set
using percent frequency tables and histograms. When more than one
synthetic data set has been generated (<code>object$m &gt; 1</code>), by 
default pooled synthetic data are used for comparison.
</p>
<p>This function can be also used with synthetic data NOT created by
<code>syn()</code>, but then an additional parameter <code>cont.na</code> might
need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'synds'
compare(object, data, vars = NULL,
        msel = NULL, stat = "percents", breaks = 20,
        nrow = 2, ncol = 2, rel.size.x = 1,
        utility.stats = c("pMSE", "S_pMSE", "df"),
        utility.for.plot = "S_pMSE",
        cols = c("#1A3C5A","#4187BF"),
        plot = TRUE, table = FALSE, ...)

## S3 method for class 'data.frame'
compare(object, data, vars = NULL, cont.na = NULL,
        msel = NULL, stat = "percents", breaks = 20,
        nrow = 2, ncol = 2, rel.size.x = 1,
        utility.stats = c("pMSE", "S_pMSE", "df"),
        utility.for.plot = "S_pMSE",
        cols = c("#1A3C5A","#4187BF"),
        plot = TRUE, table = FALSE, ...)

## S3 method for class 'list'
compare(object, data, vars = NULL, cont.na = NULL,
        msel = NULL, stat = "percents", breaks = 20,
        nrow = 2, ncol = 2, rel.size.x = 1,
        utility.stats = c("pMSE", "S_pMSE", "df"),
        utility.for.plot = "S_pMSE",
        cols = c("#1A3C5A","#4187BF"),
        plot = TRUE, table = FALSE, ...)

## S3 method for class 'compare.synds'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.synds_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands for 'synthesised
data set'. It is typically created by function <code>syn()</code> and it includes
<code>object$m</code> synthesised data set(s) as <code>object$syn</code>. Alternatively,
when data are synthesised not using <code>syn()</code>, it can be a data frame
with a synthetic data set or a list of data frames with synthetic data sets,
all created from the same original data with the same variables and the same
method.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_data">data</code></td>
<td>
<p>an original (observed) data set.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_vars">vars</code></td>
<td>
<p>variables to be compared. If <code>vars</code> is <code>NULL</code>
(the default) all synthesised variables are compared.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list of codes for missing values for continuous
variables if different from the <code>R</code> missing data code <code>NA</code>.
The names of the list elements must correspond to the variables names for
which the missing data codes need to be specified.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_msel">msel</code></td>
<td>
<p>index or indices of synthetic data copies for which a comparison
is to be made. If <code>NULL</code> pooled synthetic data copies are compared
with the original data.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_stat">stat</code></td>
<td>
<p>determines whether tables and plots present percentages
<code>stat = "percents"</code>, the default, or counts <code>stat = "counts"</code>.
If <code>m &gt; 1</code> and <code>msel = NULL</code> average counts for synthetic data
are derived.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_breaks">breaks</code></td>
<td>
<p>the number of cells for the histogram.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows for the plotting area.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns for the plotting area.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_rel.size.x">rel.size.x</code></td>
<td>
<p>a number representing the relative size of x-axis labels.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_utility.stats">utility.stats</code></td>
<td>
<p>a single string or a vector of strings that determines
which utility measures to print. Must be a selection from:  
<code>"VW"</code>, <code>"FT"</code>,<code>"JSD"</code>, <code>"SPECKS"</code>, <code>"WMabsDD"</code>, 
<code>"U"</code>, <code>"G"</code>, <code>"pMSE"</code>, <code>"PO50"</code>, <code>"MabsDD"</code>, 
<code>"dBhatt"</code>,  <code>"S_VW"</code>, <code>"S_FT"</code>, <code>"S_JSD"</code>, 
<code>"S_WMabsDD"</code>, <code>"S_G"</code>, <code>"S_pMSE"</code>, <code>"df"</code>. 
If <code>utility.stats = "all"</code>, all of these will be printed. For more 
information see the details section for <code><a href="#topic+utility.tab">utility.tab</a></code>.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_utility.for.plot">utility.for.plot</code></td>
<td>
<p>a single string that determines which utility 
measure to print in facet labels of the plot. Set to <code>NULL</code> to
print variable names only.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_cols">cols</code></td>
<td>
<p>bar colors.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_plot">plot</code></td>
<td>
<p>a logical value with default set to <code>TRUE</code> indicating
whether plots should be produced.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_table">table</code></td>
<td>
<p>a logical value with default set to <code>FALSE</code> indicating
whether tables should be printed.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code id="compare.synds_+3A_x">x</code></td>
<td>
<p>an object of class <code>compare.synds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing data categories for numeric variables are plotted on the same plot
as non-missing values. They are indicated by <code>miss.</code> suffix.
</p>
<p>Numeric variables with fewer than 6 distinct values are changed to factors
in order to make plots more readable.
</p>


<h3>Value</h3>

<p>An object of class <code>compare.synds</code> which is a list including a list
of comparative frequency tables (<code>tables</code>) and a ggplot object
(<code>plots</code>) with bar charts/histograms. If multiple plots are produced
they and their corresponding frequency tables are stored as a list.
</p>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multi.compare">multi.compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[ , c("sex", "age", "edu", "marital", "ls", "income")]
s1  &lt;- syn(ods, cont.na = list(income = -8))

### synthetic data provided as a 'synds' object
compare(s1, ods, vars = "ls")
compare(s1, ods, vars = "income", stat = "counts",
        table = TRUE, breaks = 10)

### synthetic data provided as 'data.frame'
compare(s1$syn, ods, vars = "ls")
compare(s1$syn, ods, vars = "income", cont.na = list(income = -8),
        stat = "counts", table = TRUE, breaks = 10)
</code></pre>

<hr>
<h2 id='glm.synds+2C+20lm.synds'>Fitting (generalized) linear models to synthetic data</h2><span id='topic+glm.synds'></span><span id='topic+lm.synds'></span><span id='topic+print.fit.synds'></span>

<h3>Description</h3>

<p>Fits generalized linear models or simple linear models to the synthesised 
data set(s) using <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+lm">lm</a></code> 
function respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.synds(formula, family = "binomial", data,  ...)
lm.synds(formula, data, ...)

## S3 method for class 'fit.synds'
print(x, msel = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be estimated. 
A typical model has the form <code>response ~ predictors</code>. See
the documentation of <code><a href="stats.html#topic+glm">glm</a></code> and
<code><a href="stats.html#topic+formula">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_family">family</code></td>
<td>
<p>a description of the error distribution 
and link function to be used in the model. See the documentation of 
<code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code> for details.</p>
</td></tr>
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_data">data</code></td>
<td>
<p>an object of class <code>synds</code>, which stands
for 'synthesised data set'. It is typically created by
function <code><a href="#topic+syn">syn</a></code> and it includes <code>data$m</code> 
synthesised data set(s).</p>
</td></tr>
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+glm">glm</a></code> 
or <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_x">x</code></td>
<td>
<p>an object of class <code>fit.synds</code>.</p>
</td></tr>    
<tr><td><code id="glm.synds+2B2C+2B20lm.synds_+3A_msel">msel</code></td>
<td>
<p>index or indices of synthetic data copies for which coefficient
estimates are to be displayed. If <code>NULL</code> (default) the combined 
(average) coefficient estimates are printed.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>The <code><a href="base.html#topic+summary">summary</a></code> function (<code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>) can be 
used to obtain the combined results of models fitted to each of the <code>m</code>
synthetic data sets.
</p>
<p>An object of class <code>fit.synds</code>. It is a list with the following 
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code>glm.synds</code> or <code>lm.synds</code>.</p>
</td></tr>
<tr><td><code>mcoefavg</code></td>
<td>
<p>combined (average) coefficient estimates.</p>
</td></tr>
<tr><td><code>mvaravg</code></td>
<td>
<p>combined (average) variance estimates of <code>mcoef</code>.</p>
</td></tr>
<tr><td><code>analyses</code></td>
<td>
<p><code>summary.glm</code> or <code>summary.lm</code> object respectively
or a list of <code>m</code> such objects.</p>
</td></tr>
<tr><td><code>fitting.function</code></td>
<td>
<p>function used to fit the model.</p>
</td></tr>    
<tr><td><code>n</code></td>
<td>
<p>a number of cases in the original data.</p>
</td></tr>  
<tr><td><code>k</code></td>
<td>
<p>a number of cases in the synthesised data.</p>
</td></tr>  
<tr><td><code>proper</code></td>
<td>
<p>a logical value indicating whether synthetic data were 
generated using proper synthesis.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the observed data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a vector of synthesising methods applied to each variable
in the saved synthesised data.</p>
</td></tr>
<tr><td><code>incomplete</code></td>
<td>
<p>a logical value indicating whether the dependent variable 
in the model was not synthesised.</p>
</td></tr> 
<tr><td><code>mcoef</code></td>
<td>
<p>a matrix of coefficients estimates from all <code>m</code> syntheses.</p>
</td></tr>
<tr><td><code>mvar</code></td>
<td>
<p>a matrix of variance estimates from all <code>m</code> syntheses.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>,  
<code><a href="#topic+multinom.synds">multinom.synds</a></code>, <code><a href="#topic+polr.synds">polr.synds</a></code>, 
<code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>, <code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Logit model 
ods &lt;- SD2011[1:1000, c("sex", "age", "edu", "marital", "ls", "smoke")]
s1 &lt;- syn(ods, m = 3)
f1 &lt;- glm.synds(smoke ~ sex + age + edu + marital + ls, data = s1, family = "binomial")
f1
print(f1, msel = 1:2)
  
### Linear model
ods &lt;- SD2011[1:1000,c("sex", "age", "income", "marital", "depress")]
ods$income[ods$income == -8] &lt;- NA
s2 &lt;- syn(ods, m = 3)
f2 &lt;- lm.synds(depress ~ sex + age + log(income) + marital, data = s2)
f2
print(f2,1:3)
</code></pre>

<hr>
<h2 id='multi.compare'>
Multivariate comparison of synthesised and observed data
</h2><span id='topic+multi.compare'></span>

<h3>Description</h3>

<p>Graphical comparisons of a variable (<code>var</code>) in the synthesised data set 
with the original (observed) data set within subgroups defined by the 
variables in a vector <code>by</code>. <code>var</code> can be a factor or a continuous 
variable and the plots produced will depend on the class of <code>var</code>. 
The variables in <code>by</code> will usually be factors or variables with only 
a few values.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.compare(object, data, var = NULL, by = NULL, msel = NULL, 
  barplot.position = "fill", cont.type = "hist", y.hist = "count", 
  boxplot.point = TRUE, binwidth = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi.compare_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands for 'synthesised 
data set'. It is typically created by function <code>syn()</code> and it includes 
<code>object$m</code> synthesised data set(s).</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_data">data</code></td>
<td>
<p>an original (observed) data set.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_var">var</code></td>
<td>
<p>variable to be compared between observed and synthetic data within 
subgroups.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_by">by</code></td>
<td>
<p>variables to be tabulated or cross-tabulated to form groups.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_barplot.position">barplot.position</code></td>
<td>
<p>type of barplot. The default <code>"fill"</code> gives       
a single bar with the proportions in each group while <code>"dodge"</code> gives 
side-by-side bars with the numbers in each category.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_cont.type">cont.type</code></td>
<td>
<p>default <code>"hist"</code> gives histograms and <code>"boxplot"</code> 
gives boxplots.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_y.hist">y.hist</code></td>
<td>
<p>defines y scale for histograms - <code>"count"</code> is default;
<code>"density"</code> gives proportions.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_boxplot.point">boxplot.point</code></td>
<td>
<p>default (<code>TRUE</code>) adds individual points to boxplots.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_msel">msel</code></td>
<td>
<p>numbers of synthetic data sets to be used - must be numbers in 
the range <code>1:object$m</code>. If <code>NULL</code> pooled synthetic data copies are 
compared with the original data.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_binwidth">binwidth</code></td>
<td>
<p>sets width of a bin for histograms.</p>
</td></tr>
<tr><td><code id="multi.compare_+3A_...">...</code></td>
<td>
<p>additional parameters that can be supplied to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots as specified above. A table of the numbers in the subgroups is printed 
to the R console.
</p>
<p>Numeric variables with fewer than 6 distinct values are changed to factors 
in order to make plots more readable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare.synds">compare.synds</a></code>, <code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### default synthesis of selected variables
vars &lt;- c("sex", "age", "edu", "smoke")
ods  &lt;- na.omit(SD2011[1:1000, vars])
s1 &lt;- syn(ods)

### categorical var
multi.compare(s1, ods, var = "smoke", by = c("sex","edu"))

### numeric var
multi.compare(s1, ods, var = "age", by = c("sex"), y.hist = "density", binwidth = 5)
multi.compare(s1, ods, var = "age", by = c("sex", "edu"), cont.type = "boxplot")
</code></pre>

<hr>
<h2 id='multinom.synds'>Fitting multinomial models to synthetic data</h2><span id='topic+multinom.synds'></span>

<h3>Description</h3>

<p>Fits multinomial models to the synthesised data set(s) 
using the <code><a href="nnet.html#topic+multinom">multinom</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom.synds(formula, data,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom.synds_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be estimated. 
A typical model has the form <code>response ~ predictors</code>. See
the documentation of <code><a href="nnet.html#topic+multinom">multinom</a></code> and
<code><a href="stats.html#topic+formula">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="multinom.synds_+3A_data">data</code></td>
<td>
<p>an object of class <code>synds</code>, which stands
for 'synthesised data set'. It is typically created by
function <code><a href="#topic+syn">syn</a></code> and it includes <code>data$m</code> 
synthesised data set(s).</p>
</td></tr>
<tr><td><code id="multinom.synds_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="nnet.html#topic+multinom">multinom</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>To print the results the print function (<code><a href="#topic+print.fit.synds">print.fit.synds</a></code>) can
be used. The <code><a href="base.html#topic+summary">summary</a></code> function (<code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>) 
can be used to obtain the combined results of models fitted to each of the 
<code>m</code> synthetic data sets.
</p>
<p>An object of class <code>fit.synds</code>. It is a list with the following 
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code>multinom.synds</code>.</p>
</td></tr>
<tr><td><code>mcoefavg</code></td>
<td>
<p>combined (average) coefficient estimates.</p>
</td></tr>
<tr><td><code>mvaravg</code></td>
<td>
<p>combined (average) variance estimates of <code>mcoef</code>.</p>
</td></tr>
<tr><td><code>analyses</code></td>
<td>
<p>an object summarising the fit to each synthetic data set
or a list of <code>m</code> such objects. Note that this is different from 
the object created by <code>summary.multinom</code> to make it compatible 
with other fitting methods. In particular the coefficients are vectors, 
not matrices.</p>
</td></tr>
<tr><td><code>fitting.function</code></td>
<td>
<p>function used to fit the model.</p>
</td></tr>    
<tr><td><code>n</code></td>
<td>
<p>a number of cases in the original data.</p>
</td></tr>  
<tr><td><code>k</code></td>
<td>
<p>a number of cases in the synthesised data.</p>
</td></tr>  
<tr><td><code>proper</code></td>
<td>
<p>a logical value indicating whether synthetic data were 
generated using proper synthesis.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the observed data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a vector of synthesising methods applied to each variable
in the saved synthesised data.</p>
</td></tr>
<tr><td><code>incomplete</code></td>
<td>
<p>a logical value indicating whether the dependent variable
in the model was not synthesised.</p>
</td></tr> 
<tr><td><code>mcoef</code></td>
<td>
<p>a matrix of coefficients estimates from all <code>m</code> syntheses.</p>
</td></tr>
<tr><td><code>mvar</code></td>
<td>
<p>a matrix of variance estimates from all <code>m</code> syntheses.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="nnet.html#topic+multinom">multinom</a></code>, <code><a href="#topic+glm.synds">glm.synds</a></code>, 
<code><a href="#topic+polr.synds">polr.synds</a></code>, <code><a href="#topic+print.fit.synds">print.fit.synds</a></code>,
<code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>, <code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000, c("sex", "age", "edu", "marital", "ls", "smoke")]
s1 &lt;- syn(ods, m = 3)
f1 &lt;- multinom.synds(edu  ~ sex + age, data = s1)
summary(f1)
print(f1, msel = 1:2)
compare(f1, ods)
</code></pre>

<hr>
<h2 id='numtocat.syn'>Group numeric variables before synthesis</h2><span id='topic+numtocat.syn'></span>

<h3>Description</h3>

<p>Selected numeric variables are grouped into factors with ranges selected from 
the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numtocat.syn(data, numtocat = NULL, print.flag = TRUE, cont.na = NULL, 
             catgroups = 5, style.groups = "quantile") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numtocat.syn_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="numtocat.syn_+3A_numtocat">numtocat</code></td>
<td>
<p>a vector of numbers or variable names of numeric variables 
to be grouped into factors. If <code>NULL</code> all the numeric variables in data 
will be grouped.</p>
</td></tr>
<tr><td><code id="numtocat.syn_+3A_print.flag">print.flag</code></td>
<td>
<p>if TRUE a list of grouped variables is printed.</p>
</td></tr>
<tr><td><code id="numtocat.syn_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list that gives the values of the named variables to be 
treated as separate categories, often missing values like <code>-8</code>. See the 
corresponding parameter of <code>syn()</code>.</p>
</td></tr>
<tr><td><code id="numtocat.syn_+3A_catgroups">catgroups</code></td>
<td>
<p>a single integer or a vector of integers indicating the target 
number of groups for the variables in numtocat in the same order as numtocat, 
or as their relative postions in data. The achieved number of groups may be 
different if, for example there are fewer than <code>ngroups</code> distinct values.</p>
</td></tr>
<tr><td><code id="numtocat.syn_+3A_style.groups">style.groups</code></td>
<td>
<p>parameter of the function <code>classInt()</code> that determines 
how the breaks used to categorise each variable are chosen. See the help file 
for <code>classInt()</code> for details. The default setting <code>"quantile"</code> makes 
groups of approximately equal size. To divide into approximately equal ranges 
we suggest using <code>"fisher"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a data frame with the numeric variables replaced by factors grouped 
into ranges.</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>a named list of the breaks used to divide each numeric variable 
into categories.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a named list of the levels for the categories of each numeric 
variable.</p>
</td></tr>
<tr><td><code>orig</code></td>
<td>
<p>a data frame with the original numeric data.</p>
</td></tr>
<tr><td><code>cont.na</code></td>
<td>
<p>a named list of the levels for the categorical version of each 
numeric variable.</p>
</td></tr>
<tr><td><code>numtocat</code></td>
<td>
<p>names of the variables changed to categories.</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>positions in data of  the variables changed to categories.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>SD2011.cat &lt;- numtocat.syn(SD2011, cont.na = list(income = -8 , unempdur = -8, 
nofriend = -8))
summary(SD2011.cat$data)
</code></pre>

<hr>
<h2 id='polr.synds'>Fitting ordered logistic models to synthetic data</h2><span id='topic+polr.synds'></span>

<h3>Description</h3>

<p>Fits  ordered logistic  models to the synthesised data set(s) 
using the <code><a href="MASS.html#topic+polr">polr</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polr.synds(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polr.synds_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be estimated. A typical 
model has the form <code>response ~ predictors</code>. See the documentation of 
<code><a href="MASS.html#topic+polr">polr</a></code> and <code><a href="stats.html#topic+formula">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="polr.synds_+3A_data">data</code></td>
<td>
<p>an object of class <code>synds</code>, which stands for 'synthesised 
data set'. It is typically created by function <code><a href="#topic+syn">syn</a></code> and it 
includes <code>data$m</code> synthesised data set(s).</p>
</td></tr>
<tr><td><code id="polr.synds_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="MASS.html#topic+polr">polr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>To print the results the print function (<code><a href="#topic+print.fit.synds">print.fit.synds</a></code>) can
be used. The <code><a href="base.html#topic+summary">summary</a></code> function (<code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>)
can be used to obtain the combined results of models fitted to each of the 
<code>m</code> synthetic data sets.
</p>
<p>An object of class <code>fit.synds</code>. It is a list with the following 
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code>polr.synds</code>.</p>
</td></tr>
<tr><td><code>mcoefavg</code></td>
<td>
<p>combined (average) coefficient estimates.</p>
</td></tr>
<tr><td><code>mvaravg</code></td>
<td>
<p>combined (average) variance estimates of <code>mcoef</code>.</p>
</td></tr>
<tr><td><code>analyses</code></td>
<td>
<p>an object summarising the fit to each synthetic data set
or a list of <code>m</code> such objects. Note that this is different from  
the object created by <code>summary.polr</code> to make it compatible with other 
fitting methods for the <code>compare.fit.synds</code> and <code>summary.fit.synds</code> 
functions. In particular the coefficients combine the items coefficients 
and zeta from <code>summary.polr</code> to make a combined vector of coefficients.</p>
</td></tr>
<tr><td><code>fitting.function</code></td>
<td>
<p>function used to fit the model.</p>
</td></tr>    
<tr><td><code>n</code></td>
<td>
<p>a number of cases in the original data.</p>
</td></tr>  
<tr><td><code>k</code></td>
<td>
<p>a number of cases in the synthesised data.</p>
</td></tr>  
<tr><td><code>proper</code></td>
<td>
<p>a logical value indicating whether synthetic data were 
generated using proper synthesis.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the observed data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a vector of synthesising methods applied to each variable
in the saved synthesised data.</p>
</td></tr>
<tr><td><code>incomplete</code></td>
<td>
<p>a logical value indicating whether the dependent variable
in the model was not synthesised.</p>
</td></tr> 
<tr><td><code>mcoef</code></td>
<td>
<p>a matrix of coefficients estimates from all <code>m</code> syntheses.</p>
</td></tr>
<tr><td><code>mvar</code></td>
<td>
<p>a matrix of variance estimates from all <code>m</code> syntheses.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+polr">polr</a></code>, <code><a href="#topic+glm.synds">glm.synds</a></code>,  
<code><a href="#topic+multinom.synds">multinom.synds</a></code>, <code><a href="#topic+print.fit.synds">print.fit.synds</a></code>,
<code><a href="#topic+summary.fit.synds">summary.fit.synds</a></code>, <code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000, c("sex", "age", "edu", "marital", "ls", "smoke")]
s1 &lt;- syn(ods, m = 3)
f1 &lt;- polr.synds(edu  ~ sex + age, data = s1)
summary(f1)
print(f1, msel = 1:2)
compare(f1, ods)
</code></pre>

<hr>
<h2 id='read.obs'>Importing original data sets form external files</h2><span id='topic+read.obs'></span>

<h3>Description</h3>

<p>Imports data data sets form external files into a data frame. 
Currently supported files include: sav (SPSS), dta (Stata), xpt (SAS),
csv (comma-separated file), tab (tab-delimited file) and 
txt (delimited text files). For SPSS, Stata and SAS it uses functions from 
the <code>foreign</code> package with some adjustments where necessary.</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.obs(file, convert.factors = TRUE, lab.factors = FALSE, 
export.lab = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.obs_+3A_file">file</code></td>
<td>
<p>the name of the file (including extension) which the data are 
to be read from.</p>
</td></tr>
<tr><td><code id="read.obs_+3A_convert.factors">convert.factors</code></td>
<td>
<p>a logical value indicating whether variables with 
value labels in Stata and SPSS should be converted into R factors with 
those levels.</p>
</td></tr>
<tr><td><code id="read.obs_+3A_lab.factors">lab.factors</code></td>
<td>
<p>a logical value indicating whether variables with 
complete value labels but imported using their numeric codes 
(<code>convert.factors = FALSE</code>) should be converted 
from numeric to factor variables.</p>
</td></tr>
<tr><td><code id="read.obs_+3A_export.lab">export.lab</code></td>
<td>
<p>a logical variable indicating whether labels from SPSS or 
Stata should be exported to an external file.</p>
</td></tr>
<tr><td><code id="read.obs_+3A_...">...</code></td>
<td>
<p>additional parameters passed to read functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with an imported data set. For SPSS, Stata and SAS it has 
attributes with labels.</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.syn">write.syn</a></code>
</p>

<hr>
<h2 id='replicated.uniques'>Replications in synthetic data</h2><span id='topic+replicated.uniques'></span>

<h3>Description</h3>

<p>Determines which unique units in the synthesised data set(s)
replicates unique units in the original observed data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicated.uniques(object, data, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replicated.uniques_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands
for 'synthesised data set'. It is typically created by
function <code>syn()</code> and it includes <code>object$m</code> 
synthesised data set(s).</p>
</td></tr>
<tr><td><code id="replicated.uniques_+3A_data">data</code></td>
<td>
<p>the original observed data set.</p>
</td></tr>
<tr><td><code id="replicated.uniques_+3A_exclude">exclude</code></td>
<td>
<p>a single string or a vector of strings with name(s) 
of variable(s) to be excluded from the identification of uniques.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>replications</code></td>
<td>
<p>a vector (for <code>object$m = 1</code>) or a data frame
with <code>object$m</code> columns (for <code>object$m &gt; 1</code>) with logical 
values indicateing duplicates in <code>m</code>th synthetic data set.</p>
</td></tr>
<tr><td><code>no.replications</code></td>
<td>
<p>a single number or a vector of <code>object$m</code> integers
indicating the number of duplicates in the synthetic data set(s).</p>
</td></tr>  
<tr><td><code>no.uniques</code></td>
<td>
<p>a number of unique individuals in the original data set.</p>
</td></tr>  
<tr><td><code>per.replications</code></td>
<td>
<p>a single number or a vector of <code>object$m</code> numeric 
values indicating the percentage of duplicates in the synthetic data set(s).</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sdc">sdc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000,c("sex","age","edu","marital","smoke")]
s1 &lt;- syn(ods, m = 2)
replicated.uniques(s1,ods)
</code></pre>

<hr>
<h2 id='SD2011'>
Social Diagnosis 2011 - Objective and Subjective Quality of Life in Poland
</h2><span id='topic+SD2011'></span>

<h3>Description</h3>

<p>Sample of 5,000 individuals from the Social Diagnosis 2011 survey;
selected variables only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SD2011</code></pre>


<h3>Format</h3>

<p>A data frame with 5,000 observations on the following 35 variables:
</p>

<dl>
<dt>sex</dt><dd><p>Sex</p>
</dd>
<dt>age</dt><dd><p>Age of person, 2011</p>
</dd>
<dt>agegr</dt><dd><p>Age group, 2011</p>
</dd>
<dt>placesize</dt><dd><p>Category of the place of residence</p>
</dd>
<dt>region</dt><dd><p>Region (voivodeship)</p>
</dd>
<dt>edu</dt><dd><p>Highest educational qualification, 2011</p>
</dd>
<dt>eduspec</dt><dd><p>Discipline of completed qualification</p>
</dd>
<dt>socprof</dt><dd><p>Socio-economic status, 2011</p>
</dd>
<dt>unempdur</dt><dd><p>Total duration of unemployment in the last 2 years (in months)</p>
</dd>
<dt>income</dt><dd><p>Personal monthly net income</p>
</dd>
<dt>marital</dt><dd><p>Marital status</p>
</dd>
<dt>mmarr</dt><dd><p>Month of marriage</p>
</dd>
<dt>ymarr</dt><dd><p>Year of marriage</p>
</dd>
<dt>msepdiv</dt><dd><p>Month of separation/divorce</p>
</dd>
<dt>ysepdiv</dt><dd><p>Year of separation/divorce</p>
</dd>
<dt>ls</dt><dd><p>Perception of life as a whole</p>
</dd>
<dt>depress</dt><dd><p>Depression symptoms indicator</p>
</dd>
<dt>trust</dt><dd><p>View on interpersonal trust</p>
</dd>
<dt>trustfam</dt><dd><p>Trust in own family members</p>
</dd>
<dt>trustneigh</dt><dd><p>Trust in neighbours</p>
</dd>
<dt>sport</dt><dd><p>Active engagement in some form of sport or exercise</p>
</dd>
<dt>nofriend</dt><dd><p>Number of friends</p>
</dd>
<dt>smoke</dt><dd><p>Smoking cigarettes</p>
</dd>
<dt>nociga</dt><dd><p>Number of cigarettes smoked per day</p>
</dd>
<dt>alcabuse</dt><dd><p>Drinking too much alcohol</p>
</dd>
<dt>alcsol</dt><dd><p>Starting to use alcohol to cope with troubles</p>
</dd>
<dt>workab</dt><dd><p>Working abroad in 2007-2011</p>
</dd>
<dt>wkabdur</dt><dd><p>Total time spent on working abroad</p>
</dd>
<dt>wkabint</dt><dd><p>Plans to go abroad to work in the next two years</p>
</dd>
<dt>wkabintdur</dt><dd><p>Intended duration of working abroad</p>
</dd>
<dt>emcc</dt><dd><p>Intended destination country</p>
</dd>
<dt>englang</dt><dd><p>Knowledge of English language</p>
</dd>
<dt>height</dt><dd><p>Height of person</p>
</dd>
<dt>weight</dt><dd><p>Weight of person</p>
</dd>
<dt>bmi</dt><dd><p>Body mass index</p>
</dd>
</dl>


<h3>Note</h3>

<p>Please note that the original variable names have been changed to make them 
more self-explanatory. Some variable labels have been adjusted as well.</p>


<h3>Source</h3>

<p>Council for Social Monitoring. Social Diagnosis 2000-2011: integrated database.
<a href="http://www.diagnoza.com/index-en.html">http://www.diagnoza.com/index-en.html</a> [downloaded on 13/12/2013]
</p>


<h3>References</h3>

<p>Czapinski J. and Panek T. (Eds.) (2011). Social Diagnosis 2011. Objective and 
Subjective Quality of Life in Poland - full report. Contemporary Economics, 
Volume 5, Issue 3 (special issue) <a href="http://ce.vizja.pl/en/issues/volume/5/issue/3#art254">http://ce.vizja.pl/en/issues/volume/5/issue/3#art254</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  spineplot(englang ~ agegr, data = SD2011, xlab = "Age group", ylab = "Knowledge of English")
  boxplot(income ~ sex, data = SD2011[SD2011$income != -8,])
</code></pre>

<hr>
<h2 id='sdc'>Tools for statistical disclosure control (sdc)</h2><span id='topic+sdc'></span>

<h3>Description</h3>

<p>Labeling and removing unique replicates of unique actual (observed) individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdc(object, data, label = NULL, rm.replicated.uniques = FALSE, 
 uniques.exclude = NULL, recode.vars = NULL, bottom.top.coding = NULL, 
 recode.exclude = NULL, smooth.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdc_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands
for 'synthesised data set'. It is typically created by
function <code>syn()</code> and it includes <code>object$m</code> 
synthesised data set(s).</p>
</td></tr>
<tr><td><code id="sdc_+3A_data">data</code></td>
<td>
<p>the original (observed) data set.</p>
</td></tr>
<tr><td><code id="sdc_+3A_label">label</code></td>
<td>
<p>a single string with a label to be added to the synthetic data 
sets as a new variable to make it clear that the data are synthetic/fake.</p>
</td></tr>
<tr><td><code id="sdc_+3A_rm.replicated.uniques">rm.replicated.uniques</code></td>
<td>
<p>a logical value indicating whether unique 
replicates of units that are unique also in the orginal data set should 
be removed.</p>
</td></tr>
<tr><td><code id="sdc_+3A_uniques.exclude">uniques.exclude</code></td>
<td>
<p>a single string or a vector of strings with name(s) 
of variable(s) to be excluded from the identification of uniques.</p>
</td></tr>
<tr><td><code id="sdc_+3A_recode.vars">recode.vars</code></td>
<td>
<p>a single string or a vector of strings with name(s) 
of variable(s) to be bottom- or/and top-coded.</p>
</td></tr>
<tr><td><code id="sdc_+3A_bottom.top.coding">bottom.top.coding</code></td>
<td>
<p>a list of two-element vectors specifing 
bottom and top codes for each variable in <code>recode.vars</code>. 
If there is no need for bottom or top coding <code>NA</code> should be used.
If only one variable is to be recoded, codes can be given as 
a two-element vector.</p>
</td></tr>
<tr><td><code id="sdc_+3A_recode.exclude">recode.exclude</code></td>
<td>
<p>a list specifying for each variable in 
<code>recode.vars</code> values to be excluded from recoding, e.g. missing data 
codes. If all values should be considered for recoding <code>NA</code> should be 
used. If only one variable is to be recoded, code(s) can be given as 
a single number or a vector.</p>
</td></tr>
<tr><td><code id="sdc_+3A_smooth.vars">smooth.vars</code></td>
<td>
<p>a single string or a vector of strings with name(s) 
of numeric variable(s) to be smoothed (<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function is used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>object</code> provided as an argument adjusted in accordance with the 
other parameters' values.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+replicated.uniques">replicated.uniques</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000,c("sex","age","edu","marital","income")]
s1 &lt;- syn(ods, m = 2)
s1.sdc &lt;- sdc(s1, ods, label="false_data", rm.replicated.uniques = TRUE,
recode.vars = c("age","income"),
bottom.top.coding = list(c(20,80),c(NA,2000)),
recode.exclude = list(NA,c(NA,-8)))
</code></pre>

<hr>
<h2 id='summary.fit.synds'>Inference from synthetic data</h2><span id='topic+summary.fit.synds'></span><span id='topic+print.summary.fit.synds'></span>

<h3>Description</h3>

<p>Combines the results of models fitted to each of the <code>m</code> 
synthetic data sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit.synds'
summary(object, population.inference = FALSE, msel = NULL,
  real.varcov = NULL, incomplete = NULL, ...)

## S3 method for class 'summary.fit.synds'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fit.synds_+3A_object">object</code></td>
<td>
<p>an object of class <code>fit.synds</code> created by fitting a model to 
synthesised data set using function <code><a href="#topic+glm.synds">glm.synds</a></code>, 
<code><a href="#topic+lm.synds">lm.synds</a></code>,<code><a href="#topic+multinom.synds">multinom.synds</a></code> or <code><a href="#topic+polr.synds">polr.synds</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fit.synds_+3A_population.inference">population.inference</code></td>
<td>
<p>a logical value indicating whether inference 
should be made to population quantities. If <code>FALSE</code> inference is made
to the results that would be expected from an analysis of the original data. 
This option should be selected if the synthetic data are being used for 
exploratory analysis, but the final published results will be obtained by 
running code on the original confidential data. If <code>population.inference = TRUE</code> 
results would allow population inference to be made from the synthetic data. 
In both cases the inference will depend on the synthesising model being 
correct, but this can be checked by running the same analysis on the real 
data, see <code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fit.synds_+3A_msel">msel</code></td>
<td>
<p>index or indices of the synthetic datasets (<code>1</code>, <code>...</code>,
<code>m</code>), for which summaries of fitted models are to be produced. 
If <code>NULL</code> (default) only the summary of combined estimates is produced.</p>
</td></tr> 
<tr><td><code id="summary.fit.synds_+3A_real.varcov">real.varcov</code></td>
<td>
<p>the estimated variance-covariance matrix of the fit of the 
model to the original data. This parameter is used in the function 
<code>compare.fit.synds</code> which has the original data as one of its parameters.</p>
</td></tr>
<tr><td><code id="summary.fit.synds_+3A_incomplete">incomplete</code></td>
<td>
<p>Logical variable as to whether population inference for 
incomplete synthesis is to be used. If this is left at a <code>NULL</code> value 
it will be determined by whether the dependent variable has been synthesised. 
See also below as output.</p>
</td></tr>
<tr><td><code id="summary.fit.synds_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code id="summary.fit.synds_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.fit.synds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the estimates from each of the m synthetic data sets 
yields asymptotically unbiased estimates of the coefficients if the observed 
data conform to the distribution used for synthesis. The standard errors are 
estimated differently depending whether inference is made for the results that 
we would expect to obtain from the observed data or for the parameters of the 
population that we assume the observed data are sampled from. The standard 
errors also differ according to whether synthetic data were produced using 
simple or proper synthesis (for details see Raab et al. (2017)).</p>


<h3>Value</h3>

<p>An object of class <code>summary.fit.synds</code> which is a list with the 
following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code>glm.synds</code> or <code>lm.synds</code>.</p>
</td></tr>
<tr><td><code>proper</code></td>
<td>
<p>a logical value indicating whether synthetic data were 
generated using proper synthesis.</p>
</td></tr>
<tr><td><code>population.inference</code></td>
<td>
<p>a logical value indicating whether inference 
is made to population coefficients or to the results that would be expected 
from an analysis of the original data (see above).</p>
</td></tr> 
<tr><td><code>incomplete</code></td>
<td>
<p>a logical value indicating whether the dependent variable 
in the model was not synthesised. It is derived in the synthpop 
implementation of the fitting functions (<code><a href="#topic+lm.synds">lm.synds</a></code>, 
<code><a href="#topic+glm.synds">glm.synds</a></code>, <code><a href="#topic+multinom.synds">multinom.synds</a></code> and 
<code><a href="#topic+polr.synds">polr.synds</a></code>) and saved with the fitted object. When 
<code>TRUE</code> inference with <code>population.inference = TRUE</code> uses the 
method proposed by Reiter (2003) for what he terms partially synthetic
data. This method requires multiple syntheses (<code>m &gt; 1</code>). 
If <code>m = 1</code>, <code>incomplete = TRUE</code> and <code>population.inference = TRUE</code> 
the results will be still calculated and returned with warning. This will
usually give standard errors that are larger than they should be. This 
method can be forced by setting <code>incomplete = TRUE</code> as a parameter 
because it can also be used for complete synthesis.</p>
</td></tr> 
<tr><td><code>fitting.function</code></td>
<td>
<p>function used to fit the model.</p>
</td></tr> 
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the original (observed) data.</p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p>a matrix with combined estimates. If inference is 
required to the results that would be obtained from an analysis of the 
original data, (<code>population.inference = FALSE</code>) the coefficients are 
given by <code>xpct(Beta)</code>, the standard errors by <code>xpct(se.Beta)</code> and
the corresponding Z-statistic by <code>xpct(Z)</code>. If the synthetic data are 
to be used to make inferences to population quantities 
(<code>population.inference = TRUE</code>), the coefficients are given by 
<code>Beta.syn</code>, their standard errors by <code>se.Beta.syn</code> and the 
Z-statistic by <code>Z.syn</code> (see vignette on inference for more details).</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a number of cases in the original data.</p>
</td></tr> 
<tr><td><code>k</code></td>
<td>
<p>the number of cases in the synthesised data. Note that if <code>k</code> 
and <code>n</code> are not equal and <code>population.inference = FALSE</code> 
(the default), then the standard errors produced will estimate what would 
be expected by an analysis of the original data set of size <code>n</code>.</p>
</td></tr>
<tr><td><code>analyses</code></td>
<td>
<p><code>summary.glm</code> or <code>summary.lm</code> object respectively
or a list of <code>m</code> such objects.</p>
</td></tr> 
<tr><td><code>msel</code></td>
<td>
<p>index or indices of synthetic data copies for which summaries 
of fitted models are produced. If <code>NULL</code> only a summary of combined 
estimates is produced.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>
<p>Raab, G.M., Nowok, B. and Dibben, C. (2017). Practical data synthesis for 
large samples. <em>Journal of Privacy and Confidentiality</em>, <b>7</b>(3), 
67-97. Available at: 
<a href="https://journalprivacyconfidentiality.org/index.php/jpc/article/view/407">https://journalprivacyconfidentiality.org/index.php/jpc/article/view/407</a>
</p>
<p>Reiter, J.P. (2003) Inference for partially synthetic, public use microdata 
sets. <em>Survey Methodology</em>, <b>29</b>, 181-188.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+print">print</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000,c("sex","age","edu","ls","smoke")]
  
### simple synthesis
s1 &lt;- syn(ods, m = 5)
f1 &lt;- glm.synds(smoke ~ sex + age + edu + ls, data = s1, family = "binomial")
summary(f1)
summary(f1, population.inference = TRUE)
  
### proper synthesis
s2 &lt;- syn(ods, m = 5, method = "parametric", proper = TRUE)
f2 &lt;- glm.synds(smoke ~ sex + age + edu + ls, data = s2, family = "binomial")
summary(f2)
summary(f2, population.inference = TRUE)
</code></pre>

<hr>
<h2 id='summary.synds'>Synthetic data object summaries</h2><span id='topic+summary.synds'></span><span id='topic+print.summary.synds'></span>

<h3>Description</h3>

<p>Produces summaries of the synthesised variables. When more than one 
synthetic data set has been generated (object$m &gt; 1), by default summaries 
are calculated by averaging summary values for all synthetic data copies
(see <code>msel</code> argument).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'synds'
summary(object, msel = NULL, maxsum = 7, 
  digits = max(3, getOption("digits")-3), ...)

## S3 method for class 'summary.synds'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.synds_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>; a result of a call to 
<code><a href="#topic+syn">syn</a></code>.</p>
</td></tr>
<tr><td><code id="summary.synds_+3A_msel">msel</code></td>
<td>
<p>index or indices of synthetic data copies for which a summary 
is desired. If <code>NULL</code> (default) summaries are calculated by averaging 
summary values for all synthetic data copies.</p>
</td></tr>
<tr><td><code id="summary.synds_+3A_maxsum">maxsum</code></td>
<td>
<p>integer, indicating how many levels should be shown for factors.</p>
</td></tr>
<tr><td><code id="summary.synds_+3A_digits">digits</code></td>
<td>
<p>integer, used for number formatting with <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>    
<tr><td><code id="summary.synds_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
<tr><td><code id="summary.synds_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.synds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="base.html#topic+summary">summary</a></code> for more details.</p>


<h3>Value</h3>

<p>An object of class <code>summary.synds</code>, which is a list with the following 
components:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>the number of synthetic versions of the original (observed) data.</p>
</td></tr>
<tr><td><code>msel</code></td>
<td>
<p>index or indices of synthetic data copies for which a summary 
is produced. If <code>NULL</code> summaries are calculated by averaging 
summary values for all synthetic data copies.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a vector of synthesising methods applied to each variable
in the saved synthesised data.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a table or a list of tabels (if more than one synthetic data 
set is selected) with summaries of synthesised variables.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,<code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- syn(SD2011[,c("sex","age","edu","marital")], m = 3)
summary(s1)
summary(s1, msel = c(1,3))
</code></pre>

<hr>
<h2 id='syn'>Generating synthetic data sets</h2><span id='topic+syn'></span><span id='topic+syn.strata'></span><span id='topic+print.synds'></span>

<h3>Description</h3>

<p>Generates synthetic version(s) of a data set. Function <code>syn.strata()</code> 
performs stratified synthesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn(data, method = "cart", visit.sequence = (1:ncol(data)),
    predictor.matrix = NULL,  
    m = 1, k = nrow(data), proper = FALSE, 
    minnumlevels = 1, maxfaclevels = 60, 
    rules = NULL, rvalues = NULL, 
    cont.na = NULL, semicont = NULL, 
    smoothing = NULL, event = NULL, denom = NULL, 
    drop.not.used = FALSE, drop.pred.only = FALSE, 
    default.method = c("normrank", "logreg", "polyreg", "polr"),
    numtocat = NULL, catgroups = rep(5, length(numtocat)), 
    models = FALSE, print.flag = TRUE, seed = "sample", ...)
    
syn.strata(data, strata = NULL, 
    minstratumsize = 10 + 10 * length(visit.sequence),  
    tab.strataobs = TRUE, tab.stratasyn = FALSE,
    method = "cart", visit.sequence = (1:ncol(data)),
    predictor.matrix = NULL,
    m = 1, k = nrow(data), proper = FALSE, 
    minnumlevels = 1, maxfaclevels = 60, 
    rules = NULL, rvalues = NULL,
    cont.na = NULL, semicont = NULL, 
    smoothing = NULL, event = NULL, denom = NULL, 
    drop.not.used = FALSE, drop.pred.only = FALSE,
    default.method = c("normrank", "logreg", "polyreg", "polr"),
    numtocat = NULL, catgroups = rep(5,length(numtocat)), 
    models = FALSE, print.flag = TRUE, seed = "sample", ...)    
   
## S3 method for class 'synds'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn_+3A_data">data</code></td>
<td>
<p>a data frame or a matrix (<code>n</code> x <code>p</code>) containing the 
original data. Observations are in rows and variables are in columns.</p>
</td></tr>
<tr><td><code id="syn_+3A_method">method</code></td>
<td>
<p>a single string or a vector of strings of length
<code>ncol(data)</code> specifying the synthesising method to be
used for each variable in the data. Order of variables is exactly the
same as in <code>data</code>. If specified as a single string, the same method
is used for all variables in a visit sequence unless a data type or
a position in a visit sequence requires a different method. 
If <code>method</code> is set to <code>"parametric"</code> the
default synthesising method specified by the <code>default.method</code> argument
are applied. Variables that are transformations of other variables can
be synthesised using a passive method that is specified as a string 
starting with <code>~</code> (see <code><a href="#topic+syn.passive">syn.passive</a></code>). Variables that need 
not to be synthesised have the empty method <code>""</code>. By default all 
variables are synthesised using <code>"cart"</code> method, which is 
<code>rpart</code> implementation of a CART model (see <code><a href="#topic+syn.cart">syn.cart</a></code>). 
See details for more information on method.</p>
</td></tr>
<tr><td><code id="syn_+3A_visit.sequence">visit.sequence</code></td>
<td>
<p>a character vector of names of variables or an integer 
vector of their column indices specifying the order of synthesis.
The default sequence <code>1:ncol(data)</code> implies that column variables are
synthesised from left to right. See details for more information.</p>
</td></tr>
<tr><td><code id="syn_+3A_predictor.matrix">predictor.matrix</code></td>
<td>
<p>a square matrix of size <code>ncol(data)</code> specifying
the set of column predictors to be used for each target variable in the row.
Each entry has value 0 or 1. A value of 1 means that the column
variable is used as a predictor for the row variable. Order of
variables is exactly the same as in <code>data</code>. By default all
variables that are earlier in the visit sequence are used as predictors.
For the default visit sequence (<code>1:ncol(data)</code>) the default
<code>predictor.matrix</code> will have values of 1 in the lower triangle.
See details for more information.</p>
</td></tr>
<tr><td><code id="syn_+3A_m">m</code></td>
<td>
<p>number of synthetic copies of the original (observed) data to be 
generated. The default is <code>m = 1</code>.</p>
</td></tr>
<tr><td><code id="syn_+3A_k">k</code></td>
<td>
<p>a size of the synthetic data set (<code>k x p</code>),
which can be smaller or greater than the size of the original data 
set (<code>n x p</code>). The default is <code>nrow(data)</code> which means 
that the number of individuals in the synthesised data is the same 
as in the original (observed) data (<code>k = n</code>).</p>
</td></tr>
<tr><td><code id="syn_+3A_proper">proper</code></td>
<td>
<p>a logical value with default set to <code>FALSE</code>. 
If <code>TRUE</code> proper synthesis is conducted.</p>
</td></tr>
<tr><td><code id="syn_+3A_minnumlevels">minnumlevels</code></td>
<td>
<p>a minimum number of values a numeric variable should exceed
to be treated as numeric during the synthesis. Numeric variables with only 
<code>minnumlevels</code> or fewer distinct values are changed into factors. 
If set to <code>1</code> (default) numeric variables are left unchanged unless 
they have only one non-missing value.</p>
</td></tr>  
<tr><td><code id="syn_+3A_maxfaclevels">maxfaclevels</code></td>
<td>
<p>a maximum number of factor levels that can be handled.
It can be increased to allow the synthesis to run but too large a value may
cause computational problems, especially for parametric methods.</p>
</td></tr>
<tr><td><code id="syn_+3A_rules">rules</code></td>
<td>
<p>a named list of rules for restricted values. Restricted values 
are those that are determined explicitly by values of other variables.
The names of the list elements must correspond to the variables names for 
which the rules need to be specified.</p>
</td></tr>
<tr><td><code id="syn_+3A_rvalues">rvalues</code></td>
<td>
<p>a named list of the values corresponding to the rules
specified by <code>rules</code>.</p>
</td></tr>
<tr><td><code id="syn_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list of codes for missing values for continuous
variables if different from the <code>R</code> missing data code <code>NA</code>.
The names of the list elements must correspond to the variables names for 
which the missing data codes need to be specified.</p>
</td></tr>
<tr><td><code id="syn_+3A_semicont">semicont</code></td>
<td>
<p>a named list of values at which semi-continuous
variables have spikes. The names of the list elements must correspond 
to the names of the semi-continuous variables.</p>
</td></tr>     
<tr><td><code id="syn_+3A_smoothing">smoothing</code></td>
<td>
<p>a single string specifying a smoothing method for all numeric 
variables in the data or a named list specifying a smoothing method to be 
used for selected variables. Avaliable methods include: <code>"spline"</code> 
(recommended), <code>"rmean"</code>, <code>"density"</code>, and <code>""</code>).
Smoothing can only be applied to continuous variables synthesised using 
<code>sample</code>, <code>ctree</code>, <code>cart</code>, <code>rf</code>, <code>bag</code>, 
<code>ranger</code>, <code>normrank</code>, <code>pmm</code> or <code>nested</code> method. 
The names of the list elements must correspond to the names of the 
variables whose values are to be smoothed. Smoothing is applied to the 
synthesised values. For more details see <code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn_+3A_event">event</code></td>
<td>
<p>a named list specifying for survival data the names of 
corresponding event indicators. The names of the list elements 
must correspond to the names of the survival variables.</p>
</td></tr>
<tr><td><code id="syn_+3A_denom">denom</code></td>
<td>
<p>a named list specifying for variables to be modelled using 
binomial regression the names of corresponding denominator variables. 
The names of the list elements must correspond to the names of the 
variables to be modelled using binomial regression.</p>
</td></tr>
<tr><td><code id="syn_+3A_drop.not.used">drop.not.used</code></td>
<td>
<p>a logical value. If <code>TRUE</code> (default) variables not 
used in synthesis are not saved in the synthesised data and are not 
included in the corresponding synthesis parameters.</p>
</td></tr>
<tr><td><code id="syn_+3A_drop.pred.only">drop.pred.only</code></td>
<td>
<p>a logical value. If <code>TRUE</code> (default) variables not 
synthesised and used as predictors only are not saved in the synthesised 
data.</p>
</td></tr>
<tr><td><code id="syn_+3A_default.method">default.method</code></td>
<td>
<p>a vector of four strings containing the default
parametric synthesising methods for numerical variables, factors 
with two levels, unordered factors with more than two levels 
and ordered factors with more than two levels respectively. 
They are used when <code>method</code> is set to <code>"parametric"</code> or 
when there is an inconsistency between variable type and provided method.</p>
</td></tr>
<tr><td><code id="syn_+3A_numtocat">numtocat</code></td>
<td>
<p>a vector of numbers or names to indicate columns of <code>data</code>
that are to be divided into groups to allow the grouped variables to be 
synthesised as factors. The target number of groups for each variable is 
specified by <code>catgroups</code>. After the grouped variables have been synthesised 
the  numeric variables are synthesised from them by the method <code>syn.nested</code> 
and are placed in the same position in the synthetic data as in the original. 
The grouped variables are not stored in the synthetic data. If you want to keep
the categorised values you should change the relevant variables in <code>data</code> 
before running <code>syn()</code> with the function <code>numtocat.syn()</code></p>
</td></tr>
<tr><td><code id="syn_+3A_catgroups">catgroups</code></td>
<td>
<p>An integer or a vector of integers of the same length as
<code>numtocat</code> giving the target number of groups into which of the
numeric variables is to be categorised. The function <code>group_var</code>
from the <code>classInt</code> package performs the categorisation.</p>
</td></tr>
<tr><td><code id="syn_+3A_models">models</code></td>
<td>
<p>if <code>TRUE</code> parameters of models fitted to the original data 
and used to generate the synthetic values are stored.</p>
</td></tr>
<tr><td><code id="syn_+3A_print.flag">print.flag</code></td>
<td>
<p>if <code>TRUE</code> (default) synthesising history and 
information messages will be printed at the console. For silent 
computation use <code>print.flag = FALSE</code>.</p>
</td></tr>
<tr><td><code id="syn_+3A_seed">seed</code></td>
<td>
<p>an integer to be used as an argument for the <code>set.seed()</code>.
If no integer is provided, the default <code>"sample"</code> will generate one
and it will be stored. To prevent generating an integer set <code>seed</code>
to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="syn_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to synthesising functions. See 
section 'Details' below for more information.</p>
</td></tr>
<tr><td><code id="syn_+3A_strata">strata</code></td>
<td>
<p>a numeric vector with strata identifiers or a string vector with 
names of stratifying variable(s).</p>
</td></tr> 
<tr><td><code id="syn_+3A_minstratumsize">minstratumsize</code></td>
<td>
<p>minimum size of each stratum.</p>
</td></tr>    
<tr><td><code id="syn_+3A_tab.strataobs">tab.strataobs</code></td>
<td>
<p>a logical value indicating whether a frequency table of
the number of observations in strata in the original data set should be 
printed.</p>
</td></tr>   
<tr><td><code id="syn_+3A_tab.stratasyn">tab.stratasyn</code></td>
<td>
<p>a logical value indicating whether a frequency table of
the number of observations in strata in the synthetic data set(s) should 
be printed.</p>
</td></tr>           
<tr><td><code id="syn_+3A_x">x</code></td>
<td>
<p>an object of class <code>synds</code>; a result of a call to <code>syn()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only variables that are in <code>visit.sequence</code> with corresponding non-empty 
<code>method</code> are synthesised. The only exceptions are event indicators. They 
are synthesised along with the corresponding time to event variables and should
not be included in <code>visit.sequence</code>. All other variables (not in 
<code>visit.sequence</code> or in <code>visit.sequence</code> with a corresponding blank 
method) can be used as predictors. Including them in <code>visit.sequence</code> 
generates a default <code>predictor.matrix</code> reflecting the order of variables 
in the <code>visit.sequence</code> otherwise <code>predictor.matrix</code> has to be 
adjusted accordingly. All predictors of the variables that are not in
<code>visit.sequence</code> or are in <code>visit.sequence</code> but with a blank method
are removed from <code>predictor.matrix</code>.
</p>
<p>Variables to be synthesised that are not synthesised yet cannot be used
as predictors. Also all variables used in passive synthesis or in restricted
values rules (<code>rules</code>) have to be synthesised before the variables they
apply to.
</p>
<p>Mismatch between data type and synthesising method stops execution and
print an error message but numeric variables with number of levels less
than <code>minnumlevels</code> are changed into factors and methods are changed
automatically, if necessary, to methods for categorical variables. 
Methods for variables not in a visit sequence will be changed into blank.
</p>
<p>The built-in elementary synthesising methods defined by conditional 
distributions include:
</p>

<dl>
<dt>ctree, cart</dt><dd><p>classification and regression trees (CART), 
see <code><a href="#topic+syn.cart">syn.cart</a></code></p>
</dd>
<dt>bagging, random forests, ranger</dt><dd><p>methods using ensembles of CART trees, 
see <code><a href="#topic+syn.bag">syn.bag</a></code>, <code><a href="#topic+syn.rf">syn.rf</a></code>, and <code><a href="#topic+syn.ranger">syn.ranger</a></code></p>
</dd>
<dt>survctree</dt><dd><p>classification and regression trees (CART)
for duration time data (parametric methods for survival data are 
not implemented yet),  see <code><a href="#topic+syn.survctree">syn.survctree</a></code></p>
</dd>
<dt>norm</dt><dd><p>normal linear regression, see <code><a href="#topic+syn.norm">syn.norm</a></code></p>
</dd>
<dt>normrank</dt><dd><p>normal linear regression preserving the marginal 
distribution, see <code><a href="#topic+syn.normrank">syn.normrank</a></code></p>
</dd>
<dt>lognorm, sqrtnorm, cubertnorm</dt><dd><p>normal linear regression after 
natural logarithmic, square root and cube root transformation of 
a dependent variable respectively, see <code><a href="#topic+syn.lognorm">syn.lognorm</a></code></p>
</dd> 
<dt>logreg</dt><dd><p>logistic regression, see  <code><a href="#topic+syn.logreg">syn.logreg</a></code></p>
</dd>
<dt>polyreg</dt><dd><p>unordered polytomous regression, see 
<code><a href="#topic+syn.polyreg">syn.polyreg</a></code></p>
</dd>
<dt>polr</dt><dd><p>ordered polytomous regression, see <code><a href="#topic+syn.polr">syn.polr</a></code></p>
</dd>
<dt>pmm</dt><dd><p>predictive mean matching, see <code><a href="#topic+syn.pmm">syn.pmm</a></code></p>
</dd>
<dt>sample</dt><dd><p>random sample from the observed data, 
see <code><a href="#topic+syn.sample">syn.sample</a></code></p>
</dd>
<dt>passive</dt><dd><p>function of other synthesised data,  
see <code><a href="#topic+syn.passive">syn.passive</a></code></p>
</dd>
<dt>nested</dt><dd><p>bootstrap sample within each category of the original 
grouping variable, see <code><a href="#topic+syn.nested">syn.nested</a></code></p>
</dd>
<dt>satcat</dt><dd><p>bootstrap sample within each category of the 
crosstabulation of all the predictor variables, 
see <code><a href="#topic+syn.satcat">syn.satcat</a></code></p>
</dd>
</dl>

<p>These methods use a group of variables that are synthesised together. 
They must always be together at the start of the visit sequence:
</p>

<dl>
<dt>catall</dt><dd><p>fit a saturated log-linear model,
see <code><a href="#topic+syn.catall">syn.catall</a></code></p>
</dd>
<dt>ipf</dt><dd><p>fit a log-linear model, defined by its margins, by iterative 
proportional fitting  see <code><a href="#topic+syn.ipf">syn.ipf</a></code></p>
</dd>
</dl>

<p>The functions corresponding to these methods are called <code>syn.method</code>, 
where <code>method</code> is a string with the name of a synthesising method. 
For instance a function corresponding to <code>ctree</code> function is called
<code>syn.ctree</code>. A new synthesising method can be introduced by writing 
a function named <code>syn.newmethod</code> and then specifying <code>method</code> 
parameter of <code>syn()</code> function as <code>"newmethod"</code>.
</p>
<p>In order to use <code>"nested"</code> sampling, <code>method</code> parameter of <code>syn</code> 
function has to be specified as <code>"nested.varname"</code>, where <code>"varname"</code>
is the name of the grouped (less detailed) variable, the only one used in 
nested synthesis. A variable synthesised using <code>"nested"</code> method is 
excluded from synthesising other variables except when used for <code>"nested"</code> 
method.  
</p>
<p>Additional parameters can be passed to synthesising methods as part of the 
<code>dots</code> argument. They have to be named using period-separated method and 
parameter name (<code>method.parameter</code>). For instance, in order to set 
a <code>minbucket</code> (minimum number of observations in any terminal node of 
a CART model) for a <code>ctree</code> synthesising method, <code>ctree.minbucket</code>
has to be specified. The parameters are method-specific and will be used for 
all variables to be synthesised using that method. See help for 
<code>syn.method</code> for further details about the allowed parameters for 
a specific method.  
</p>


<h3>Value</h3>

<p>The <code><a href="base.html#topic+summary">summary</a></code> function (<code><a href="#topic+summary.synds">summary.synds</a></code>) can be used  
to obtain a summary of the synthesised variables.
</p>
<p>An object of class <code>synds</code>, which stands for 'synthesised 
data set'. It is a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>an original call to <code>syn()</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of synthetic versions of the original (observed) data.</p>
</td></tr>
<tr><td><code>syn</code></td>
<td>
<p>a data frame (for <code>m = 1</code>) or a list of <code>m</code> data frames 
(for <code>m &gt; 1</code>) with synthetic data set(s).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a vector of synthesising methods applied to each variable
in the saved synthesised data.</p>
</td></tr>
<tr><td><code>visit.sequence</code></td>
<td>
<p>a vector of column indices of the visiting sequence.
The indices refer to the columns in the saved synthesised data.</p>
</td></tr>
<tr><td><code>predictor.matrix</code></td>
<td>
<p>a matrix specifying the set of predictors used
for each variable in the saved synthesised data.</p>
</td></tr>
<tr><td><code>smoothing</code></td>
<td>
<p>a vector specifying smoothing methods 
applied to each variable in the saved synthesised data.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>a vector of integers specifying for survival data the column 
indices for corresponding event indicators. The indices refer to the 
columns in the saved synthesised data.</p>
</td></tr>
<tr><td><code>denom</code></td>
<td>
<p>a vector of integers specifying for variables modelled 
using binomial regression the column indices for corresponding 
denominator variables. The indices refer to the columns in the 
saved synthesised data.</p>
</td></tr>
<tr><td><code>proper</code></td>
<td>
<p>a logical value indicating whether proper synthesis was
conducted.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>a number of cases in the original data.</p>
</td></tr>  
<tr><td><code>k</code></td>
<td>
<p>a number of cases in the synthesised data.</p>
</td></tr>
<tr><td><code>rules</code></td>
<td>
<p>a list of rules for restricted values applied to the synthetic 
data.</p>
</td></tr>
<tr><td><code>rvalues</code></td>
<td>
<p>a list of the values corresponding to the rules
specified by <code>rules</code>.</p>
</td></tr>
<tr><td><code>cont.na</code></td>
<td>
<p>a list of codes for missing values for continuous variables.</p>
</td></tr>
<tr><td><code>semicont</code></td>
<td>
<p>a list of values for semi-continuous variables at which they 
have spikes.</p>
</td></tr>
<tr><td><code>drop.not.used</code></td>
<td>
<p>a logical value indicating whether variables not used
in synthesis are saved in the synthesised data and corresponding
synthesis parameters.</p>
</td></tr>
<tr><td><code>drop.pred.only</code></td>
<td>
<p>a logical value indicating whether variables not
synthesised and used as predictors only are saved in the synthesised data.</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>if <code>models = TRUE</code> a named list of estimates of models 
fitted to the original data and used to generate the synthetic values is 
returned from the <code>$fit</code> component of each method 
(e.g. <code>syn.cart()</code>). The list is ordered by the variables position 
in the data, and any models used to predict missing values are appended 
to the list.</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>an integer used as a <code>set.seed()</code> argument.</p>
</td></tr>   
<tr><td><code>var.lab</code></td>
<td>
<p>a vector of variable labels for data imported from SPSS using 
<code>read.obs()</code>.</p>
</td></tr>   
<tr><td><code>val.lab</code></td>
<td>
<p>a list of value labels for factors for data imported from SPSS 
using <code>read.obs()</code>.</p>
</td></tr>       
<tr><td><code>obs.vars</code></td>
<td>
<p>a vector of all variable names in the observed data set.</p>
</td></tr>
</table>
<p>When <code>syn.strata()</code> is used there are two additiona components:
</p>
<table>
<tr><td><code>strata.syn</code></td>
<td>
<p>a factor variable or a list of factor variables containing 
stratum values for all observation units in <code>syn</code>.</p>
</td></tr>
<tr><td><code>strata.lab</code></td>
<td>
<p>a character vector of strata labels.</p>
</td></tr>
</table>
<p>Note also that when <code>syn.strata</code> is used most values of the items are matrices 
with each row corresponding to a stratum or lists with one element per stratum.
</p>


<h3>Note</h3>

<p>See package vignette for additional information.</p>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare.synds">compare.synds</a></code>, <code><a href="#topic+summary.synds">summary.synds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### selection of variables
vars &lt;- c("sex","age","marital","income","ls","smoke")
ods  &lt;- SD2011[1:1000, vars]
 
### default synthesis
s1 &lt;- syn(ods)
s1
  
### synthesis with default parametric methods
s2 &lt;- syn(ods, method = "parametric", seed = 123)
s2$method
  
### multiple synthesis of selected variables with customised methods
s3 &lt;- syn(ods, visit.sequence = c(2, 1, 4, 5), m = 2,
          method = c("logreg","sample","","normrank","ctree",""),
          ctree.minbucket = 10)
summary(s3)
summary(s3, msel = 1:2)
  
### adjustment to the default predictor matrix 
s4.ini &lt;- syn(data = ods, visit.sequence = c(1, 2, 5, 3),
              m = 0, drop.not.used = FALSE)
pM.cor &lt;- s4.ini$predictor.matrix
pM.cor["marital","ls"] &lt;- 0
s4 &lt;- syn(data = ods, visit.sequence = c(1, 2, 5, 3),
          predictor.matrix = pM.cor)
  
### handling missing values in continuous variables
s5 &lt;- syn(ods, cont.na = list(income = c(NA, -8)))
  
### rules for restricted values - marital status of males under 18 should be 'single'
s6 &lt;- syn(ods, rules = list(marital = "age &lt; 18 &amp; sex == 'MALE'"),
          rvalues = list(marital = 'SINGLE'), method = "parametric", seed = 123)
with(s6$syn, table(marital[age &lt; 18 &amp; sex == 'MALE']))
### results for default parametric synthesis without the rule  
with(s2$syn, table(marital[age &lt; 18 &amp; sex == 'MALE']))

### synthesis with ipf for all variables
s7 &lt;- syn(ods[, 1:3], method = "ipf", numtocat = "age")

### alternatively group the numeric variable before synthesis to save
### the grouped data rather than the numeric in the synthetic data set
ods.cat &lt;- numtocat.syn(ods, numtocat = "age", catgroups = 10)$data
s8 &lt;- syn(ods.cat[, 1:3], method = "ipf")

### stratified synthesis
s9 &lt;- syn.strata(ods, strata = "sex")
</code></pre>

<hr>
<h2 id='syn.bag'>Synthesis with bagging</h2><span id='topic+syn.bag'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using bagging. It uses 
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code> function from the <span class="pkg">randomForest</span> package with 
number of sampled predictors equal to number of all predictors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.bag(y, x, xp, smoothing = "", proper = FALSE, ntree = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.bag_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method for numeric variable. See 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) a model is fitted 
to a bootstrapped sample of the original data.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow.</p>
</td></tr>
<tr><td><code id="syn.bag_+3A_...">...</code></td>
<td>
<p>additional parameters passed to 
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>...</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the model fitted to the observed data that was used to produce 
synthetic values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>...</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.rf">syn.rf</a></code>, <code><a href="#topic+syn.cart">syn.cart</a></code>,
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>, <code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.catall'>Synthesis of a group of categorical variables from a saturated model</h2><span id='topic+syn.catall'></span>

<h3>Description</h3>

<p>A saturated model is fitted to a table produced by cross-tabulating
all the variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.catall(x, k, proper = FALSE, priorn = 1, structzero = NULL, 
           maxtable = 1e8, epsilon = 0, rand = TRUE,  ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.catall_+3A_x">x</code></td>
<td>
<p>a data frame (<code>n</code> x <code>p</code>) of the set of original variables.</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_k">k</code></td>
<td>
<p>a number of rows in each synthetic data set - defaults to <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_proper">proper</code></td>
<td>
<p>if <code>proper = TRUE</code> <code>x</code> is replaced with a bootstrap 
sample before synthesis, thus effectively sampling from the posterior 
distribution of the model, given the data.</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_priorn">priorn</code></td>
<td>
<p>the sum of the parameters of the Dirichelet prior which can be 
thought of as a pseudo-count giving the number of observations that inform 
prior knowledge about the parameters.</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_structzero">structzero</code></td>
<td>
<p>a named list of lists that defines which cells in the table 
are structural zeros and will remain as zeros in the synthetic data, by 
leaving their prior as zeros. Each element of the <code>structzero</code> list is 
a list that describes a set of cells in the table defined by a combination 
of two or more variables and a name of each such element must consist of 
those variable names seperated by an underscore, e.g. <code>sex_edu</code>. 
The length of each such element is determined by the number of variables and 
each component gives the variable levels (numeric or labels) that define the 
structural zero cells (see an example below).</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_maxtable">maxtable</code></td>
<td>
<p>a number of cells in the cross-tabulation of all the variables
that will trigger a severe warning.</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_epsilon">epsilon</code></td>
<td>
<p>measures scale of laplace noise to be added under differential 
privacy (DP)</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_rand">rand</code></td>
<td>
<p>for DP versions determines if multinomial noise is to be added to 
DP counts. If it is set to false the DP adjusted counts are simply rounded 
to a whole number in a manner that preserves the desired sample size (k).</p>
</td></tr>
<tr><td><code id="syn.catall_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used in <code>syn</code> function the group of categorical variables 
with <code>method = "catall"</code> must all be together at the start of the 
<code>visit.sequence</code>. Subsequent variables in <code>visit.sequence</code> are then 
synthesised conditional on the synthesised values of the grouped variables.
A saturated model is fitted to a table produced by cross-tabulating all the 
variables. Prior probabilities for the proportions in each cell of the table
are specified from the parameters of a Dirichlet distribution with the same 
parameter for every cell in the table that is not a structural zero (see above).
The sum of these parameters is <code>priorn</code> so that each one is <code class="reqn">priorn/N</code>
where <code class="reqn">N</code> is the number of cells in the table that are not structural zeros.
The default <code>priorn = 1</code> can be thought of as equivalent to the knowledge 
that <code>1</code> observation would be equally likely to be in any cell that is not 
a structural zero. The posterior expectation, given the observed counts,
for the probability of being in a cell with observed count <code class="reqn">n_i</code>
is thus <code class="reqn">(n_i + priorn/N) / (N + priorn)</code>. The synthetic data are generated 
from a multinomial distribution with parameters given by these probabilities.
</p>
<p>Unlike <code>syn.satcat</code>, which fits saturated conditional models,
the synthesised data can include any combination of variables, except 
those defined by the combinations of variables in <code>structzero</code>.
</p>
<p>NOTE that when the function is called by setting elements of method in 
<code>syn()</code> to <code>"catall"</code>, the parameters <code>priorn</code>, <code>structzero</code>, 
<code>maxtable</code>, <code>epsilon</code>, and <code>rand</code> must be supplied to <code>syn</code> 
as e.g. <code>catall.priorn</code>.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a data frame of dimension <code>k x p</code> containing the synthesised data.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the cross-tabulation of all the original variables used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[, c(1, 4, 5, 6, 2, 10, 11)]
table(ods[, c("placesize", "region")])

# Each `placesize_region` sublist: 
# for each relevant level of `placesize` defined in the first element, 
# the second element defines regions (variable `region`) that do not 
# have places of that size.

struct.zero &lt;- list(
  placesize_region = list(placesize = "URBAN 500,000 AND OVER", 
                          region = c(2, 4, 5, 8:13, 16)),
  placesize_region = list(placesize = "URBAN 200,000-500,000", 
                          region = c(3, 4, 10:11, 13)),
  placesize_region = list(placesize = "URBAN 20,000-100,000", 
                          region = c(1, 3, 5, 6, 8, 9, 14:15)))

syncatall &lt;- syn(ods, method = c(rep("catall", 4), "ctree", "normrank", "ctree"),
                 catall.priorn = 2, catall.structzero = struct.zero)
</code></pre>

<hr>
<h2 id='syn.ctree+2C+20syn.cart'>Synthesis with classification and regression trees (CART)</h2><span id='topic+syn.cart'></span><span id='topic+syn.ctree'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using classification and
regression trees (without or with bootstrap).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.ctree(y, x, xp, smoothing = "", proper = FALSE, 
          minbucket = 5, mincriterion = 0.9, ...)
syn.cart(y, x, xp, smoothing = "", proper = FALSE, 
         minbucket = 5, cp = 1e-08, ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method for numeric variable. See 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) a CART 
model is fitted to a bootstrapped sample of the original data.</p>
</td></tr>  
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_minbucket">minbucket</code></td>
<td>
<p>the minimum number of observations in
any terminal node. See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> and
<code><a href="party.html#topic+ctree_control">ctree_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_cp">cp</code></td>
<td>
<p>complexity parameter. Any split that does not
decrease the overall lack of fit by a factor of cp is not
attempted. Small values of <code>cp</code> will grow large trees. 
See <code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_mincriterion">mincriterion</code></td>
<td>
<p><code>1 - p-value</code> of the test that must be 
exceeded for a split to be retained. Small values of 
<code>mincriterion</code> will grow large trees. 
See <code><a href="party.html#topic+ctree_control">ctree_control</a></code> for details.</p>
</td></tr>
<tr><td><code id="syn.ctree+2B2C+2B20syn.cart_+3A_...">...</code></td>
<td>
<p>additional parameters passed to 
<code><a href="party.html#topic+ctree_control">ctree_control</a></code> for <code>syn.ctree</code> and 
<code><a href="rpart.html#topic+rpart.control">rpart.control</a></code> for <code>syn.cart</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure for synthesis by a CART model is 
as follows: </p>
 <ol>
<li><p> Fit a classification 
or regression tree by binary recursive partitioning. 
</p>
</li>
<li><p> For each <code>xp</code> find the terminal node. </p>
</li>
<li><p> Randomly 
draw a donor from the members of the node and take the observed 
value of <code>y</code> from that draw as the synthetic value.</p>
</li></ol>

<p><code>syn.ctree</code> uses <code><a href="party.html#topic+ctree">ctree</a></code> function from the
<span class="pkg">party</span> package and <code>syn.cart</code> uses <code><a href="rpart.html#topic+rpart">rpart</a></code>
function from the <span class="pkg">rpart</span> package. They differ, among others, 
in a selection of a splitting variable and a stopping rule for the 
splitting process.
</p>
<p>A Guassian kernel smoothing can be applied to continuous variables 
by setting smoothing parameter to <code>"density"</code>. It is recommended 
as a tool to decrease the disclosure risk. Increasing <code>minbucket</code>
is another means of data protection. 
</p>
<p>CART models were suggested for generation of synthetic data by 
Reiter (2005) and then evaluated by Drechsler and Reiter (2011).
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted model which is an object of class <code>rpart.object</code> 
or <code>ctree.object</code> that can be printed or plotted.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Reiter, J.P. (2005). Using CART to generate partially synthetic, 
public use microdata. <em>Journal of Official Statistics</em>, 
<b>21</b>(3), 441&ndash;462.
</p>
<p>Drechsler, J. and Reiter, J.P. (2011). An empirical evaluation of easily 
implemented, nonparametric methods for generating synthetic datasets.
<em>Computational Statistics and Data Analysis</em>, <b>55</b>(12), 3232&ndash;3243.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.survctree">syn.survctree</a></code>,
<code><a href="rpart.html#topic+rpart">rpart</a></code>, <code><a href="party.html#topic+ctree">ctree</a></code>,
<code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.ipf'>Synthesis of a group of categorical variables by iterative 
proportional fitting</h2><span id='topic+syn.ipf'></span>

<h3>Description</h3>

<p>A fit to the table is obtained from the log-linear fit that matches the 
numbers in the margins specified by the margin parameters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.ipf(x, k, proper = FALSE, priorn = 1, structzero = NULL, 
        gmargins = "twoway", othmargins = NULL, tol = 1e-3,
        max.its = 5000, maxtable = 1e8, print.its = FALSE,
        epsilon = 0, rand = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.ipf_+3A_x">x</code></td>
<td>
<p>a data frame of the set of original data to be synthesised.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_k">k</code></td>
<td>
<p>a number of rows in each synthetic data set - defaults to <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_proper">proper</code></td>
<td>
<p>if <code>proper = TRUE</code> <code>x</code> is replaced with a bootstrap 
sample before synthesis, thus effectively sampling from the posterior 
distribution of the model, given the data.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_priorn">priorn</code></td>
<td>
<p>the sum of the parameters of the Dirichlet prior which can be 
thought of as a pseudo-count giving the number of observations that inform 
prior knowledge about the parameters.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_structzero">structzero</code></td>
<td>
<p>a named list of lists that defines which cells in the table 
are structural zeros and will remain as zeros in the synthetic data, by 
leaving their prior as zeros. Each element of the <code>structzero</code> list is 
a list that describes a set of cells in the table defined by a combination 
of two or more variables and a name of each such element must consist of 
those variable names seperated by an underscore, e.g. <code>sex_edu</code>. 
The length of each such element is determined by the number of variables and 
each component gives the variable levels (numeric or labels) that define the 
structural zero cells (see an example below).</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_gmargins">gmargins</code></td>
<td>
<p>a single character to define a group of margins. At present 
there is &quot;oneway&quot; and &quot;twoway&quot; option that creates, respectively, all 1-way 
and 2-way margins from the table.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_othmargins">othmargins</code></td>
<td>
<p>a list of margins that will be fitted. If <code>gmargins</code> is
not <code>NULL</code> <code>othmargins</code> will be added to them.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for <code><a href="mipfp.html#topic+Ipfp">Ipfp</a></code>.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_max.its">max.its</code></td>
<td>
<p>maximum umber of iterations allowed for <code><a href="mipfp.html#topic+Ipfp">Ipfp</a></code>.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_maxtable">maxtable</code></td>
<td>
<p>the number of cells in the cross-tabulation of all the 
variables that will trigger a severe warning.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_print.its">print.its</code></td>
<td>
<p>if true the iterations from <code><a href="mipfp.html#topic+Ipfp">Ipfp</a></code> will be 
printed on the console. Otherwise only a message as to whether the 
iterations have converged will be given at the end of the fitting.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon value for overall differential privacy (DP) parameter.
This is implemented by dividing the privacy budget equally over all the 
margins used to fit the data.</p>
</td></tr>  
<tr><td><code id="syn.ipf_+3A_rand">rand</code></td>
<td>
<p>when epsilon is &gt; 0 and DP synthetic data are created this 
determines whether the data are created by Poisson counts from the expected 
fitted counts in the cells of the DP adjusted data.</p>
</td></tr>
<tr><td><code id="syn.ipf_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used in <code>syn</code> function the group of variables with 
<code>method = "ipf"</code> must all be together at the start of the visit sequence. 
This function is designed for categorical variables, but it can also be used for 
numerical variables if they are categorised by specifying them in the 
<code>numtocat</code> parameter of the main function <code>syn</code>. Subsequent variables 
in <code>visit.sequence</code> are then synthesised conditional on the synthesised 
values of the grouped variables. A fit to the table is obtained from the 
log-linear fit that matches the numbers in the margins specified by the margin 
parameters. Prior probabilities for the proportions in each cell of the table 
are given by a Dirichlet distribution with the same parameter for every cell 
in the table that is not a structural zero. The sum of these parameters is 
<code>priorn</code>. The default <code>priorn = 1</code> can be thought of as equivalent 
to the knowledge that <code>1</code> observation would be equally likely to
fall in any cell of the table. The synthetic data are generated from a multinomial
distribution with parameters given by the expected posterior probabilities for 
each cell of the table. If the maximum likelihood estimate from the log-linear 
fit to cell <code class="reqn">c_i</code> is <code class="reqn">p_i</code> and the table has <code class="reqn">N</code> cells that are not
structural zeros then the expectation of the posterior probability
for this cell is <code class="reqn">(p_i + priorn/N^2) / (1 + priorn / N^2)</code> or
equivalently <code class="reqn">(N * p_i + priorn/N) / (N + priorn / N)</code>.
</p>
<p>Unlike <code>syn.satcat</code>, which fits saturated models from their conditional 
distrinutions, <code>x</code> can include any combination of variables, including 
those not present in the original data, except those defined by <code>structzero</code>.
</p>
<p>NOTE that when the function is called by setting elements of
method in <code>syn</code> to <code>"ipf"</code>, the parameters <code>priorn</code>,
<code>structzero</code>, <code>gmargins</code>, <code>othmargins</code>, <code>tol</code>, 
<code>max.its</code>, <code>maxtable</code>, <code>print.its</code>, <code>epsilon</code>, 
and <code>rand</code> must be supplied to <code>syn</code> as e.g. <code>ipf.priorn</code>.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a data frame with <code>k</code> rows containing the synthesised data.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a list made up of two lists: the margins fitted and the original 
data for each margin.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[, c(1, 4, 5, 6, 2, 10, 11)]
table(ods[, c("placesize", "region")])

# Each `placesize_region` sublist: 
# for each relevant level of `placesize` defined in the first element, 
# the second element defines regions (variable `region`) that do not 
# have places of that size.

struct.zero &lt;- list(
  placesize_region = list(placesize = "URBAN 500,000 AND OVER", 
                          region = c(2, 4, 5, 8:13, 16)),
  placesize_region = list(placesize = "URBAN 200,000-500,000", 
                          region = c(3, 4, 10:11, 13)),
  placesize_region = list(placesize = "URBAN 20,000-100,000", 
                          region = c(1, 3, 5, 6, 8, 9, 14:15)))

synipf &lt;- syn(ods, method = c(rep("ipf", 4), "ctree", "normrank", "ctree"), 
              ipf.gmargins = "twoway", ipf.othmargins = list(c(1, 2, 3)),
              ipf.priorn = 2, ipf.structzero = struct.zero)
</code></pre>

<hr>
<h2 id='syn.lognorm+2C+20syn.sqrtnorm+2C+20syn.cubertnorm'>Synthesis by linear regression after transformation of 
a dependent variable</h2><span id='topic+syn.lognorm'></span><span id='topic+syn.sqrtnorm'></span><span id='topic+syn.cubertnorm'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using linear regression
of an outcome variable transformed by natural logarithm (<code>lognorm</code>), 
square root (<code>sqrtnorm</code>) or cube root (<code>cubertnorm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.lognorm(y, x, xp, proper = FALSE, ...) 
syn.sqrtnorm(y, x, xp, proper = FALSE, ...)
syn.cubertnorm(y, x, xp, proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.lognorm+2B2C+2B20syn.sqrtnorm+2B2C+2B20syn.cubertnorm_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.lognorm+2B2C+2B20syn.sqrtnorm+2B2C+2B20syn.cubertnorm_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.lognorm+2B2C+2B20syn.sqrtnorm+2B2C+2B20syn.cubertnorm_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.lognorm+2B2C+2B20syn.sqrtnorm+2B2C+2B20syn.cubertnorm_+3A_proper">proper</code></td>
<td>
<p>a logical value specifying whether proper synthesis 
should be conducted. See details.</p>
</td></tr>
<tr><td><code id="syn.lognorm+2B2C+2B20syn.sqrtnorm+2B2C+2B20syn.cubertnorm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates synthetic values using the spread around the
fitted linear regression line of transformed <code>y</code> given <code>x</code>.
For proper synthesis first the regression coefficients are drawn
from normal distribution with mean and variance from the fitted model.
The synthetic values are transformed back to the original scale.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a data frame with regression coefficients and error estimates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.norm">syn.norm</a></code>, <code><a href="#topic+syn.normrank">syn.normrank</a></code></p>

<hr>
<h2 id='syn.logreg'>Synthesis by logistic regression</h2><span id='topic+syn.logreg'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data for binary or binomial 
response variable using logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.logreg(y, x, xp, denom = NULL, denomp = NULL, proper = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.logreg_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_denom">denom</code></td>
<td>
<p>an original denominator vector of length <code>n</code> for a binomial 
regression model.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_denomp">denomp</code></td>
<td>
<p>a synthesised denominator vector of length <code>k</code> for 
a binomial regression model.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_proper">proper</code></td>
<td>
<p>a logical value specifying whether proper synthesis 
should be conducted. See details.</p>
</td></tr>
<tr><td><code id="syn.logreg_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synthesis for binary response variables by the non-Bayesian or 
approximate Bayesian logistic regression model. The non-Bayesian 
method consists of the following steps: </p>
<ol>
<li><p> Fit a
logistic regression to the original data. 
</p>
</li>
<li><p> Calculate predicted inverse logits for synthesied covariates.
</p>
</li>
<li><p> Compare the inverse logits to a random (0,1) deviate and get synthetic 
values.</p>
</li></ol>
 
<p>The Bayesian version (for proper synthesis) includes additional step before 
computing inverse logits, namely drawing coefficients from normal distribution 
with mean and variance estimated in step 1.
</p>
<p>The method relies on the standard <code>glm.fit</code> function.
Warnings from <code>glm.fit</code> are suppressed. Perfect prediction
is handled by the data augmentation method.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a summary of the model fitted to the observed data and used
to produce synthetic values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
</p>

<hr>
<h2 id='syn.nested'>Synthesis for a variable nested within another variable.</h2><span id='topic+syn.nested'></span>

<h3>Description</h3>

<p>Synthesizes one variable (<code>y</code>) from another one (<code>x</code>) 
when <code>y</code> is nested in the categories of <code>x</code>. A bootstrap 
sample is created from the original values of <code>y</code> within each category 
of <code>xp</code> (the synthesised values of the grouping variable).</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.nested(y, x, xp, smoothing = "", cont.na = NA,  ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.nested_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code> for the nested variable.</p>
</td></tr>
<tr><td><code id="syn.nested_+3A_x">x</code></td>
<td>
<p>an original data vector of length <code>n</code> for the variable within 
which <code>y</code> is nested.</p>
</td></tr>
<tr><td><code id="syn.nested_+3A_xp">xp</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="syn.nested_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method. See <code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>  
<tr><td><code id="syn.nested_+3A_cont.na">cont.na</code></td>
<td>
<p>when y is numeric this can be a list or a vector giving values 
of <code>y</code> that indicate missing values.</p>
</td></tr>
<tr><td><code id="syn.nested_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example would be when <code>x</code> is a classification 
of occupations and <code>y</code> is a more detailed sub-classification. It is 
intended that <code>x</code> is a categorical (factor) variable.
A warning will be issued if the original <code>y</code> is not nested within <code>x</code>.
A variable synthesised by <code>syn.nested()</code> is automatically excluded from
predicting later variables because it will provide no extra information,
given its grouping variable.
<code>syn.nested()</code> is also used for the final synthesis of variables in 
<code>syn()</code> when the option <code>numtocat</code> is used to synthesise numerical 
variables as groups.</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a name of the method used for synthesis (<code>"nested"</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='syn.norm'>Synthesis by linear regression</h2><span id='topic+syn.norm'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using linear regression
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.norm(y, x, xp, proper = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.norm_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.norm_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.norm_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.norm_+3A_proper">proper</code></td>
<td>
<p>a logical value specifying whether proper synthesis 
should be conducted. See details.</p>
</td></tr>
<tr><td><code id="syn.norm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates synthetic values using the spread around the
fitted linear regression line of <code>y</code> given <code>x</code>.
For proper synthesis first the regression coefficients 
are drawn from normal distribution with mean and variance
from the fitted model.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a data frame with regression coefficients and error estimates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.normrank">syn.normrank</a></code>, <code><a href="#topic+syn.lognorm">syn.lognorm</a></code></p>

<hr>
<h2 id='syn.normrank'>Synthesis by normal linear regression preserving
the marginal distribution</h2><span id='topic+syn.normrank'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using linear regression analysis
and preserves the marginal distribution. Regression is carried out on
Normal deviates of ranks in the original variable. Synthetic values are 
assigned from the original values based on the synthesised ranks 
that are transformed from their synthesised Normal deviates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.normrank(y, x, xp, smoothing = "", proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.normrank_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.normrank_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.normrank_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.normrank_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method. See <code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.normrank_+3A_proper">proper</code></td>
<td>
<p>a logical value specifying whether proper synthesis 
should be conducted. See details.</p>
</td></tr>
<tr><td><code id="syn.normrank_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First generates synthetic values of Normal deviates of ranks of  
the values in <code>y</code> using the spread around the fitted 
linear regression line of Normal deviates of ranks given <code>x</code>. 
Then synthetic Normal deviates of ranks are transformed back to 
get synthetic ranks which are used to assign values from
<code>y</code>. 
For proper synthesis first the regression coefficients 
are drawn from normal distribution with mean and variance
from the fitted model.
A smoothing methods can be applied by setting smoothing parameter (see 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>). It is recommended as a tool to decrease the 
disclosure risk.</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a data frame with regression coefficients and error estimates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.norm">syn.norm</a></code>, <code><a href="#topic+syn.lognorm">syn.lognorm</a></code>, 
<code><a href="#topic+syn.smooth">syn.smooth</a></code></p>

<hr>
<h2 id='syn.passive'>Passive synthesis</h2><span id='topic+syn.passive'></span>

<h3>Description</h3>

<p>Derives a new variable according to a specified 
function of synthesised data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.passive(data, func)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.passive_+3A_data">data</code></td>
<td>
<p>a data frame with synthesised data.</p>
</td></tr> 
<tr><td><code id="syn.passive_+3A_func">func</code></td>
<td>
<p>a <code>formula</code> specifying transformations on data. 
It is specified as a string starting with <code>~</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any function of the synthesised data can be specified. Note that several operators such as 
<code>+</code>, <code>-</code>, <code>*</code> and <code>^</code> have different meanings in <code>formula</code> syntax. 
Use the identity function <code>I()</code> if they should be interpreted as arithmetic operators, 
e.g. <code>"~I(age^2)"</code>.
Function <code>syn()</code> checks whether the passive assignment is correct in the original data 
and fails with a warning if this is not true. The variables synthesised passively can be
used to predict later variables in the synthesis except when they are numeric variables 
with missing data. A warning is produced in this last case.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> including the result of applying 
the <code>formula</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a name of the method used for synthesis (<code>"passive"</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gillian Raab, 2021 based on Stef van Buuren, Karin Groothuis-Oudshoorn, 2000</p>


<h3>References</h3>

<p>Van Buuren, S. and Groothuis-Oudshoorn, K. (2011).
<code>mice</code>: Multivariate Imputation by Chained Equations
in <code>R</code>. <em>Journal of Statistical Software</em>,
<b>45</b>(3), 1-67. <a href="https://doi.org/10.18637/jss.v045.i03">doi:10.18637/jss.v045.i03</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### the examples shows how inconsistencies in the SD2011 data are picked up 
### by syn.passive()
ods &lt;- SD2011[, c("height", "weight", "bmi", "age", "agegr")]
ods$hsq &lt;- ods$height^2
ods$sex &lt;- SD2011$sex
meth &lt;- c("cart", "cart", "~I(weight / height^2 * 10000)",  
          "cart", "~I(cut(age, c(15, 24, 34, 44, 59, 64, 120)))", 
          "~I(height^2)", "logreg")

## Not run: 
### fails for bmi 
s1 &lt;- syn(ods, method = meth, seed = 6756, models = TRUE)

### fails for agegr
ods$bmi &lt;- ods$weight / ods$height^2 * 10000  
s2 &lt;- syn(ods, method = meth, seed = 6756, models = TRUE) 

### fails because of wrong order 
ods$agegr &lt;- cut(ods$age, c(15, 24, 34, 44, 59, 64, 120))
s3 &lt;- syn(ods, method = meth, visit.sequence = 7:1, 
          seed = 6756, models = TRUE)  

## End(Not run)

### runs without errors
ods$bmi   &lt;- ods$weight / ods$height^2 * 10000  
ods$agegr &lt;- cut(ods$age, c(15, 24, 34, 44, 59, 64, 120))
s4 &lt;- syn(ods, method = meth, seed = 6756, models = TRUE) 
### bmi and hsq do not predict sex because of missing values
s4$models$sex 

### hsq with no missing values used to predict sex  
ods2 &lt;- ods[!is.na(ods$height),]
s5 &lt;- syn(ods2, method = meth, seed = 6756, models = TRUE) 
s5$models$sex

### agegr with missing values used to predict sex because not numeric
ods3 &lt;- ods
ods3$age[1:4] &lt;- NA
ods3$agegr &lt;- cut(ods3$age, c(15, 24, 34, 44, 59, 64, 120))
s6 &lt;- syn(ods3, method = meth, seed = 6756, models = TRUE) 
s6$models$sex  
</code></pre>

<hr>
<h2 id='syn.pmm'>Synthesis by predictive mean matching</h2><span id='topic+syn.pmm'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using predictive mean
matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.pmm(y, x, xp, smoothing = "", proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.pmm_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.pmm_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.pmm_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.pmm_+3A_proper">proper</code></td>
<td>
<p>a logical value specifying whether proper synthesis 
should be conducted. See details.</p>
</td></tr>
<tr><td><code id="syn.pmm_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method. See documentation for 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.pmm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synthesis of <code>y</code> by predictive mean matching. The procedure
is as follows: </p>
 <ol>
<li><p> Fit a linear regression 
to the original data. </p>
</li>
<li><p> Compute predicted values <code>y.hat</code>
and <code>ysyn.hat</code> for the original <code>x</code> and synthesised 
<code>xp</code> covariates respectively.
</p>
</li>
<li><p> For each predicted value <code>ysyn.hat</code> find donor 
observations with the closest predicted values <code>y.hat</code> 
(ties are broken by random selection), randomly sample one of 
them and take its observed value <code>y</code> as the synthetic value. 
</p>
</li></ol>

<p>The Bayesian version (for proper synthesis) includes additional 
step before computing predicted values: </p>
<ul>
<li><p>Draw coefficients 
from normal distribution with mean and variance estimated in step 1 and use 
them to calculate predicted values for the synthesised covariates.</p>
</li></ul>



<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a data frame with regression coefficients and error estimates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.polr'>Synthesis by ordered polytomous regression</h2><span id='topic+syn.polr'></span>

<h3>Description</h3>

<p>Generates a synthetic categorical variable using
ordered polytomous regression (without or with bootstrap).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.polr(y, x, xp, proper = FALSE, maxit = 1000, trace = FALSE, 
  MaxNWts = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.polr_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) 
a model is fitted to a bootstrapped sample of the original data.</p>
</td></tr> 
<tr><td><code id="syn.polr_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_trace">trace</code></td>
<td>
<p>switch for tracing optimization for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>the maximum allowable number of weights for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polr_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+optim">optim</a></code> 
or <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates synthetic ordered categorical variables by the
proportional odds logistic regression (polr) model. The
function repeatedly applies logistic regression on the
successive splits. The model is also known as the
cumulative link model.
</p>
<p>The algorithm of <code>syn.polr</code> uses the
function <code><a href="MASS.html#topic+polr">polr</a></code> from the <span class="pkg">MASS</span> package.
</p>
<p>In order to avoid bias due to perfect prediction, the
data are augmented by the method of White, Daniel and Royston (2010).
</p>
<p>In case the call to <code><a href="MASS.html#topic+polr">polr</a></code> fails, 
usually because the data are very sparse, 
<code><a href="nnet.html#topic+multinom">multinom</a></code> function is used instead.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a summary of the model fitted to the observed data and used
to produce synthetic values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>White, I.R., Daniel, R. and Royston, P. (2010). Avoiding bias
due to perfect prediction in multiple imputation of
incomplete categorical variables. <em>Computational
Statistics and Data Analysis</em>, <b>54</b>, 2267&ndash;2275.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>,<code><a href="#topic+syn.polyreg">syn.polyreg</a></code>
<code><a href="nnet.html#topic+multinom">multinom</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>
</p>

<hr>
<h2 id='syn.polyreg'>Synthesis by unordered polytomous regression</h2><span id='topic+syn.polyreg'></span>

<h3>Description</h3>

<p>Generates a synthetic categorical variable using
unordered polytomous regression (without or with bootstrap).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.polyreg(y, x, xp, proper = FALSE, maxit = 1000, trace = FALSE, 
            MaxNWts = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.polyreg_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) 
a multinomial model is fitted to a bootstrapped sample of the original data.</p>
</td></tr> 
<tr><td><code id="syn.polyreg_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_trace">trace</code></td>
<td>
<p>switch for tracing optimization for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>the maximum allowable number of weights for <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
<tr><td><code id="syn.polyreg_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="nnet.html#topic+nnet">nnet</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates synthetic categorical variables by the polytomous 
regression model. The method consists of the following steps: </p>

<ol>
<li><p> Fit categorical response as a multinomial model.
</p>
</li>
<li><p> Compute predicted categories. </p>
</li>
<li><p> Add appropriate
noise to predictions.</p>
</li></ol>

<p>The algorithm of <code>syn.polyreg</code> uses the function 
<code><a href="nnet.html#topic+multinom">multinom</a></code> from the <span class="pkg">nnet</span> package. Any numerical 
variables are scaled to cover the range (0,1) before fitting. Warnings 
are printed if the algorithm fails to converge in <code>maxit</code> iterations
and also if the synthesised data has only one category. The latter may occur 
if the variable being synthesised is sparse so that the algorithm fails to 
iterate.
</p>
<p>In order to avoid bias due to perfect prediction, the
data are augmented by the method of White, Daniel and Royston (2010).   
</p>
<p>NOTE that when the function is called by setting elements of method in <code>syn()</code>
to <code>"polyreg"</code>, the parameters <code>maxit</code>, <code>trace</code> and <code>MaxNWts</code>
can be supplied to <code>syn()</code> as e.g. <code>polyreg.maxit</code>.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a summary of the model fitted to the observed data and used
to produce synthetic values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>White, I.R., Daniel, R. and Royston, P. (2010). Avoiding bias
due to perfect prediction in multiple imputation of
incomplete categorical variables. <em>Computational
Statistics and Data Analysis</em>, <b>54</b>, 2267&ndash;2275.</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.polr">syn.polr</a></code>,
<code><a href="nnet.html#topic+multinom">multinom</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>
</p>

<hr>
<h2 id='syn.ranger'>Synthesis with a fast implementation of random forests</h2><span id='topic+syn.ranger'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using a fast implementation of 
random forests. It uses <code><a href="ranger.html#topic+ranger">ranger</a></code> function 
from the <span class="pkg">ranger</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.ranger(y, x, xp, smoothing = "", proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.ranger_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.ranger_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.ranger_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.ranger_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method for numeric variable. See 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.ranger_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) a model is fitted 
to a bootstrapped sample of the original data.</p>
</td></tr>
<tr><td><code id="syn.ranger_+3A_...">...</code></td>
<td>
<p>additional parameters passed to 
<code><a href="ranger.html#topic+ranger">ranger</a></code>.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>...</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the model fitted to the observed data that was used to produce 
synthetic values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>...</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.rf">syn.rf</a></code>,
<code><a href="#topic+syn.bag">syn.bag</a></code>, <code><a href="#topic+syn.cart">syn.cart</a></code>,
<code><a href="ranger.html#topic+ranger">ranger</a></code>, <code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.rf'>Synthesis with random forest</h2><span id='topic+syn.rf'></span>

<h3>Description</h3>

<p>Generates univariate synthetic data using Breiman's random forest algorithm 
classification and regression. It uses <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> function 
from the <span class="pkg">randomForest</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.rf(y, x, xp, smoothing = "", proper = FALSE, ntree = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.rf_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method for numeric variable. See 
<code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) a model is fitted 
to a bootstrapped sample of the original data.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow.</p>
</td></tr>
<tr><td><code id="syn.rf_+3A_...">...</code></td>
<td>
<p>additional parameters passed to 
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>...</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted model which is an object of class <code>randomForest.</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>...</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.rf">syn.rf</a></code>,
<code><a href="#topic+syn.bag">syn.bag</a></code>, <code><a href="#topic+syn.cart">syn.cart</a></code>,
<code><a href="randomForest.html#topic+randomForest">randomForest</a></code>,
<code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.sample'>Synthesis by simple random sampling</h2><span id='topic+syn.sample'></span>

<h3>Description</h3>

<p>Generates a random sample from the observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.sample(y, xp, smoothing = "", cont.na = NA, proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.sample_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="syn.sample_+3A_xp">xp</code></td>
<td>
<p>a target length <code>k</code> of a synthetic data vector.</p>
</td></tr>
<tr><td><code id="syn.sample_+3A_smoothing">smoothing</code></td>
<td>
<p>smoothing method for numeric variable. See documentation
for <code><a href="#topic+syn.smooth">syn.smooth</a></code>.</p>
</td></tr>
<tr><td><code id="syn.sample_+3A_cont.na">cont.na</code></td>
<td>
<p>a vector of codes for missing values for continuous
variables that should be excluded from smoothing.</p>
</td></tr>  
<tr><td><code id="syn.sample_+3A_proper">proper</code></td>
<td>
<p>if <code>proper = TRUE</code> values are sampled from  
a bootstrapped sample of the original data.</p>
</td></tr>  
<tr><td><code id="syn.sample_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>sample</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple random sample with replacement is taken from the 
observed values in <code>y</code> and used as synthetic values. 
A Guassian kernel smoothing can be applied to continuous variables 
by setting smoothing parameter to <code>"density"</code>. It is recommended 
as a tool to decrease the disclosure risk.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic values of <code>y</code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>a name of the method used for synthesis (<code>"sample"</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.smooth">syn.smooth</a></code>
</p>

<hr>
<h2 id='syn.satcat'>Synthesis from a saturated model based on all combinations of the 
predictor variables.</h2><span id='topic+syn.satcat'></span>

<h3>Description</h3>

<p>Synthesises one variable (<code>y</code>) from all possible 
combinations of its precitors (<code>x</code>). A bootstrap sample is created 
from the original values of <code>y</code> within each unique combinations of 
of <code>xp</code> (the syntheisied values of the grouping variable).</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.satcat(y, x, xp, proper = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.satcat_+3A_y">y</code></td>
<td>
<p>an original data vector of length <code>n</code> for the satcat variable.</p>
</td></tr>
<tr><td><code id="syn.satcat_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) with the original predictor variables
for <code>y</code>.</p>
</td></tr>
<tr><td><code id="syn.satcat_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) with synthetic values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="syn.satcat_+3A_proper">proper</code></td>
<td>
<p>if <code>proper = TRUE</code> <code>x</code> and <code>y</code> are replaced 
with a bootstrap sample before synthesis, thus effectively sampling from 
the posterior distribution of the model, given the data.</p>
</td></tr> 
<tr><td><code id="syn.satcat_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is intended that the variables in <code>x</code> are categorical (factor) 
variables. If <code>y</code> is also a categorical variable <code>syn.satcat</code> will 
give the same results as fitting a saturated polychotomous regression model but 
will usually be much faster. <code>syn.satcat</code> will fail with an error message 
if previous syntheses have generated a combination of variables in <code>xp</code> 
that was not present in <code>x</code>. Use of the <code>syn.catall</code> method for 
grouped variables can overcome this.</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a data frame of dimension <code>k x p</code> containing the synthesised data.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the cross-tabulation of the original predictor variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[, c("region", "sex", "agegr", "placesize")]

s1 &lt;- syn(ods, method = c("sample", "cart", "satcat", "cart"))

## Not run: 
### mostly fails because too many small categories
s2 &lt;- syn(ods, method = c("sample", "cart", "cart", "satcat"))
## End(Not run)
</code></pre>

<hr>
<h2 id='syn.smooth'>syn.smooth</h2><span id='topic+syn.smooth'></span>

<h3>Description</h3>

<p>Implements three different smoothing methods for numeric data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.smooth(ysyn, yobs = NULL, smoothing = "spline", window = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.smooth_+3A_ysyn">ysyn</code></td>
<td>
<p>non-missing synthetic data to be smoothed.</p>
</td></tr>
<tr><td><code id="syn.smooth_+3A_yobs">yobs</code></td>
<td>
<p>original data used by all methodds to determine number of 
decimal places and by method <code>"density"</code> to identify 
top-coding.</p>
</td></tr>
<tr><td><code id="syn.smooth_+3A_smoothing">smoothing</code></td>
<td>
<p>a character vector that can take values <code>"spline"</code>, 
<code>"density"</code>, or <code>"rmean"</code>.</p>
</td></tr>
<tr><td><code id="syn.smooth_+3A_window">window</code></td>
<td>
<p>width of window for running mean.</p>
</td></tr>
<tr><td><code id="syn.smooth_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smooths numeric variables by three methods. Default is <code>"spline"</code> that  
uses a smoothing spline, others are <code>"density"</code> that uses a Gaussian 
kernel density estimator with bandwidth selected using the Sheather-Jones 
'solve-the-equation' method (see <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code>) and <code>"rmean"</code> 
that smooths with a running mean of width <code>"window"</code> (see 
<code><a href="broman.html#topic+runningmean">runningmean</a></code>). 
</p>


<h3>Value</h3>

<p>A vector of smoothed values of <code>ysyn</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.sample">syn.sample</a></code>, <code><a href="#topic+syn.normrank">syn.normrank</a></code>,
<code><a href="#topic+syn.pmm">syn.pmm</a></code>, <code><a href="#topic+syn.ctree">syn.ctree</a></code>, <code><a href="#topic+syn.cart">syn.cart</a></code>, 
<code><a href="#topic+syn.bag">syn.bag</a></code>, <code><a href="#topic+syn.rf">syn.rf</a></code>, <code><a href="#topic+syn.ranger">syn.ranger</a></code>,
<code><a href="#topic+syn.nested">syn.nested</a></code>
</p>

<hr>
<h2 id='syn.survctree'>Synthesis of survival time by classification and regression trees (CART)</h2><span id='topic+syn.survctree'></span>

<h3>Description</h3>

<p>Generates synthetic event indicator and time to event data using 
classification and regression trees (without or with bootstrap).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syn.survctree(y, yevent, x, xp, proper = FALSE, minbucket = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syn.survctree_+3A_y">y</code></td>
<td>
<p>a vector of length <code>n</code> with original time data.</p>
</td></tr>
<tr><td><code id="syn.survctree_+3A_yevent">yevent</code></td>
<td>
<p>a vector of length <code>n</code> with original event indicator data.</p>
</td></tr>
<tr><td><code id="syn.survctree_+3A_x">x</code></td>
<td>
<p>a matrix (<code>n</code> x <code>p</code>) of original covariates.</p>
</td></tr>
<tr><td><code id="syn.survctree_+3A_xp">xp</code></td>
<td>
<p>a matrix (<code>k</code> x <code>p</code>) of synthesised covariates.</p>
</td></tr>
<tr><td><code id="syn.survctree_+3A_proper">proper</code></td>
<td>
<p>for proper synthesis (<code>proper = TRUE</code>) a CART 
model is fitted to a bootstrapped sample of the original data.</p>
</td></tr>  
<tr><td><code id="syn.survctree_+3A_minbucket">minbucket</code></td>
<td>
<p>the minimum number of observations in
any terminal node. See <code><a href="party.html#topic+ctree_control">ctree_control</a></code>
for details.</p>
</td></tr>
<tr><td><code id="syn.survctree_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="party.html#topic+ctree">ctree</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure for synthesis by a CART model is as follows: 
</p>
<ol>
<li><p> Fit a tree-structured survival model by 
binary recursive partitioning (the terminal nodes include 
Kaplan-Meier estimates of the survival time). 
</p>
</li>
<li><p> For each <code>xp</code> find the terminal node. </p>
</li>
<li><p> Randomly 
draw a donor from the members of the node and take the observed 
value of <code>yevent</code> and <code>y</code> from that draw as the 
synthetic values.</p>
</li></ol>
    
<p>The function is used in <code>syn()</code> to generate survival times 
by setting elements of method in <code>syn()</code> to <code>"survctree"</code>.
Additional parameters related to <code><a href="party.html#topic+ctree">ctree</a></code> function, 
e.g. <code>minbucket</code> can be supplied to <code>syn()</code> as 
<code>survctree.minbucket</code>.
</p>
<p>Where the survival variable is censored this information must be supplied 
to <code>syn()</code> as a named list (event) that gives the name of the variable 
for each event indicator. Event variables can be a numeric variable with 
values 1/0 (1 = event), TRUE/FALSE (TRUE = event) or a factor with 2 levels 
(level 2 = event). The event variable(s) will be synthesised along with the 
survival time(s).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>syn.time</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic time values.</p>
</td></tr>
<tr><td><code>syn.event</code></td>
<td>
<p>a vector of length <code>k</code> with synthetic event indicator
values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fitted model which is an item of class <code>ctree.object</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+syn">syn</a></code>, <code><a href="#topic+syn.ctree">syn.ctree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### This example uses the data set 'mgus2' from the survival package.
### It has a follow-up time variable 'futime' and an event indicator 'death'.
library(survival)

### first exclude the 'id' variable and run a dummy synthesis to get 
### a method vector
ods &lt;- mgus2[-1]
s0 &lt;- syn(ods)

### create new method vector including 'survctree' for 'futime' and create 
### an event list for it; the names of the list element must correspond to 
### the name of the follow-up variable for which the event indicator
### need to be specified.
meth &lt;- s0$method
meth[names(meth) == "futime"] &lt;- "survctree"
evlist &lt;- list(futime = "death")

s1 &lt;- syn(ods, method = meth, event = evlist)

### evaluate outputs
## compare selected variables
compare(s1, ods, vars = c("futime", "death", "sex", "creat"))

## compare original and synthetic follow up time by an event indicator
multi.compare(s1, ods, var = "futime", by = "death")

## compare survival curves for original and synthetic data
par(mfrow = c(2,1))
plot(survfit(Surv(futime, death) ~ sex, data = ods), 
     col = 1:2, xlim = c(0,450), main = "Original data")
legend("topright", levels(ods$sex), col = 1:2, lwd = 1, bty = "n")
plot(survfit(Surv(futime, death) ~ sex, data = s1$syn), 
     col = 1:2, xlim = c(0,450), main = "Synthetic data")
</code></pre>

<hr>
<h2 id='synthpop-package'>Generating synthetic versions of sensitive microdata for statistical disclosure control</h2><span id='topic+synthpop-package'></span><span id='topic+synthpop'></span>

<h3>Description</h3>

<p>Generate synthetic versions of a data set using parametric or CART methods.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> synthpop</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.8-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-31</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Synthetic data are generated from the original (observed) data by the function 
<code><a href="#topic+syn">syn</a></code>. The package includes also tools to compare synthetic data with the 
observed data (<code><a href="#topic+compare.synds">compare.synds</a></code>) and to fit (generalized) linear model to 
synthetic data (<code><a href="#topic+lm.synds">lm.synds</a></code>, <code><a href="#topic+glm.synds">glm.synds</a></code>) and compare the estimates 
with those for the observed data (<code><a href="#topic+compare.fit.synds">compare.fit.synds</a></code>). More extensive 
documentation with illustrative examples is provided in the package vignette.</p>


<h3>Author(s)</h3>

<p>Beata Nowok, Gillian M Raab, and Chris Dibben based on package <span class="pkg">mice</span> 
(2.18) by Stef van Buuren and Karin Groothuis-Oudshoorn
</p>
<p>Maintainer: Beata Nowok &lt;beata.nowok@gmail.com&gt;
</p>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>

<hr>
<h2 id='utility.gen'>Distributional comparison of synthesised and observed data</h2><span id='topic+utility.gen'></span><span id='topic+utility.gen.synds'></span><span id='topic+utility.gen.data.frame'></span><span id='topic+utility.gen.list'></span><span id='topic+print.utility.gen'></span>

<h3>Description</h3>

<p>Distributional comparison of synthesised data set with the original (observed) 
data set using propensity scores.
</p>
<p>This function can be also used with synthetic data NOT created by 
<code>syn()</code>, but then additional parameters <code>not.synthesised</code> 
and <code>cont.na</code> might need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'synds'
utility.gen(object, data, 
            method = "cart", maxorder = 1, k.syn = FALSE, tree.method = "rpart",
            max.params = 400, print.stats = c("pMSE", "S_pMSE"), resamp.method = NULL, 
            nperms = 50, cp = 1e-3, minbucket = 5, mincriterion = 0, vars = NULL, 
            aggregate = FALSE, maxit = 200, ngroups = NULL, print.flag = TRUE,
            print.every = 10, digits = 6, print.zscores = FALSE, zthresh = 1.6,
            print.ind.results = FALSE, print.variable.importance = FALSE, ...)

## S3 method for class 'data.frame'
utility.gen(object, data, not.synthesised = NULL, cont.na = NULL, 
            method = "cart", maxorder = 1, k.syn = FALSE, tree.method = "rpart",
            max.params = 400, print.stats = c("pMSE", "S_pMSE"), resamp.method = NULL, 
            nperms = 50, cp = 1e-3, minbucket = 5, mincriterion = 0, vars = NULL, 
            aggregate = FALSE, maxit = 200, ngroups = NULL, print.flag = TRUE,
            print.every = 10, digits = 6, print.zscores = FALSE, zthresh = 1.6,
            print.ind.results = FALSE, print.variable.importance = FALSE, ...)

## S3 method for class 'list'
utility.gen(object, data, not.synthesised = NULL, cont.na = NULL, 
            method = "cart", maxorder = 1, k.syn = FALSE, tree.method = "rpart",
            max.params = 400, print.stats = c("pMSE", "S_pMSE"), resamp.method = NULL, 
            nperms = 50, cp = 1e-3, minbucket = 5, mincriterion = 0, vars = NULL, 
            aggregate = FALSE, maxit = 200, ngroups = NULL, print.flag = TRUE,
            print.every = 10, digits = 6, print.zscores = FALSE, zthresh = 1.6,
            print.ind.results = FALSE, print.variable.importance = FALSE, ...)


## S3 method for class 'utility.gen'
print(x, digits = NULL, zthresh = NULL, 
               print.zscores = NULL, print.stats = NULL,
               print.ind.results = NULL, print.variable.importance = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.gen_+3A_object">object</code></td>
<td>
<p>it can be an object of class <code>synds</code>, which stands for 
'synthesised data set'. It is typically created by function <code>syn()</code> 
and it includes <code>object$m</code> synthesised data set(s) as <code>object$syn</code>. 
This a single data set when <code>object$m = 1</code> or a list of length 
<code>object$m</code> when <code>object$m &gt; 1</code>. Alternatively, when data are 
synthesised not using <code>syn()</code>, it can be a data frame with a synthetic 
data set or a list of data frames with synthetic data sets, all created from 
the same original data with the same variables and the same method.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_data">data</code></td>
<td>
<p>the original (observed) data set.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_not.synthesised">not.synthesised</code></td>
<td>
<p>a vector of variable names for any variables that has 
been left unchanged in the synthetic data. Not required if oject is of 
class <code>synds</code></p>
</td></tr>
<tr><td><code id="utility.gen_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list of codes for missing values for continuous
variables if different from the <code>R</code> missing data code <code>NA</code>.
The names of the list elements must correspond to the variables names for 
which the missing data codes need to be specified. Not required if oject is
of class <code>synds</code></p>
</td></tr>  
<tr><td><code id="utility.gen_+3A_method">method</code></td>
<td>
<p>a single string specifying the method for modeling the propensity 
scores. Method can be selected from <code>"logit"</code> and <code>"cart"</code>. </p>
</td></tr> 
<tr><td><code id="utility.gen_+3A_maxorder">maxorder</code></td>
<td>
<p>maximum order of interactions to be considered in 
<code>"logit"</code> method. For model without interactions <code>0</code> should be
provided.</p>
</td></tr>   
<tr><td><code id="utility.gen_+3A_k.syn">k.syn</code></td>
<td>
<p>a logical indicator as to whether the sample size itself has 
been synthesised.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_tree.method">tree.method</code></td>
<td>
<p>implementation of <code>"cart"</code> method that is used when 
<code>method = "cart"</code>. It can be <code>"rpart"</code> or <code>"ctree"</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_max.params">max.params</code></td>
<td>
<p>the maximum number of parameters for a <code>"logit"</code> model 
which alerts the user to possible fitting failure.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_print.stats">print.stats</code></td>
<td>
<p>statistics to be printed must be a selection from
<code>"pMSE"</code>, <code>"SPECKS"</code>, <code>"PO50"</code>, <code>"S_pMSE"</code>, 
<code>"S_SPECKS"</code>, <code>"S_PO50"</code>. If <code>print.stats = "all"</code>, 
all of the measures mentioned above will be printed.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_resamp.method">resamp.method</code></td>
<td>
<p>method used for resampling estimates of standardized 
measures can be <code>"perm"</code>, <code>"pairs"</code> or <code>"none"</code>.  
Defaults to <code>"pairs"</code> if <code>print.stats</code> includes <code>"S_SPECKS"</code> 
or <code>"S_PO50"</code> or synthesis is incomplete else defaults to <code>"perm"</code>
if method is <code>"cart"</code> or to <code>NULL</code>, no resampling needed, 
if method is <code>"logit"</code>. <code>"none"</code> can be used to get results 
without standardized measures e.g. in simulations.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_nperms">nperms</code></td>
<td>
<p>number of permutations for the permutation test to obtain the 
null distribution of the utility measure when <code>resamp.method = "perm"</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_cp">cp</code></td>
<td>
<p>complexity parameter for classification with tree.method 
<code>"rpart"</code>. Small values grow bigger trees.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_minbucket">minbucket</code></td>
<td>
<p>minimum number of observations allowed in a leaf for 
classification when <code>method = "cart"</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_mincriterion">mincriterion</code></td>
<td>
<p>criterion between 0 and 1 to use to control 
<code>tree.method = "ctree"</code> when the tree will not be allowed to split 
further. A value of <code>0.95</code> would be equivalent to a <code>5%</code> 
significance test. Here we set it to <code>0</code> to effectively disable this 
test and grow large trees.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_vars">vars</code></td>
<td>
<p>variables to be included in the utility comparison. It can be 
a character vector of names of variables or an integer vector of their 
column indices. If none are specified all the variables in the synthesised 
data will be included.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_aggregate">aggregate</code></td>
<td>
<p>logical flag as to whether the data should be aggregated by 
collapsing identical rows before computation. This can lead to much faster 
computation when all the variables are categorical. Only works for 
<code>method = "logit"</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_maxit">maxit</code></td>
<td>
<p>maximum iterations to use when <code>method = "logit"</code>. If the 
model does not converge in this number a warning will suggest increasing 
it.</p>
</td></tr> 
<tr><td><code id="utility.gen_+3A_ngroups">ngroups</code></td>
<td>
<p>target number of groups for categorisation of each numeric 
variable: final number may differ if there are many repeated values. If 
<code>NULL</code> (default) variables are not categorised into groups.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_print.flag">print.flag</code></td>
<td>
<p>TRUE/FALSE to indicate if any messages should 
be printed during calculations. Change to FALSE for simulations.</p>
</td></tr>  
<tr><td><code id="utility.gen_+3A_print.every">print.every</code></td>
<td>
<p>controls the printing of progress of resampling when  
<code>resamp.method</code> is not <code>NULL</code>. When <code>print.every = 0</code> 
no progress is reported, otherwise the resample number is printed every 
<code>print.every</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="rpart.html#topic+rpart">rpart</a></code>, or <code><a href="party.html#topic+ctree">ctree</a></code>.</p>
</td></tr> 
<tr><td><code id="utility.gen_+3A_x">x</code></td>
<td>
<p>an object of class <code>utility.gen</code>.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_digits">digits</code></td>
<td>
<p>number of digits to print in the default output values.</p>
</td></tr>  
<tr><td><code id="utility.gen_+3A_zthresh">zthresh</code></td>
<td>
<p>threshold value to use to suppress the printing of z-scores 
under <code>+</code>/<code>-</code> this value for <code>method = "logit"</code>. If set to 
<code>NA</code> all z-scores are printed.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_print.zscores">print.zscores</code></td>
<td>
<p>logical value as to whether z-scores for coefficients of 
the logit model should be printed.</p>
</td></tr>  
<tr><td><code id="utility.gen_+3A_print.ind.results">print.ind.results</code></td>
<td>
<p>logical value as to whether utility score results 
from individual syntheses should be printed.</p>
</td></tr>
<tr><td><code id="utility.gen_+3A_print.variable.importance">print.variable.importance</code></td>
<td>
<p>logical value as to whether the variable 
importance measure should be printed when <code>tree.method = "rpart"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function follows the method for evaluating the utility of masked data 
as given in Snoke et al. (2018) and originally proposed by Woo et al. 
(2009). The original and synthetic data are combined into one dataset and 
propensity scores, as detailed in Rosenbaum and Rubin (1983), are calculated 
to estimate the probability of membership in the synthetic data set.
The utility measure is based on the mean squared difference between these 
probabilities and the probability expected if the data did not distinguish 
the synthetic data from the original. 
</p>
<p>If <code>k.syn = FALSE</code> the expected probability is just the proportion of 
synthetic data in the combined data set, <code>0.5</code> when the original and 
synthetic data have the same number of records. Setting <code>k.syn = TRUE</code> 
indicates that the numbers of observations in the synthetic data was 
synthesised and not fixed by the synthesiser. In this case the expected 
probability will be <code>0.5</code> in all cases and the model to discriminate
between observed and synthetic will include an intercept term. This will 
usually only apply when the standalone version of this function 
<code>utility.gen.sa()</code> is used.
</p>
<p>Propensity scores can be modeled by logistic regression <code>method = "logit"</code> 
or by two different implementations of classification and regression trees as 
method <code>"cart"</code>. For logistic regression the predictors are all variables 
in the data and their interactions up to order <code>maxorder</code>. The default of 
<code>1</code> gives all main effects and first order interactions. For logistic 
regression the null distribution of the propensity score is derived and is 
used to calculate ratios and standardised values.
</p>
<p>For <code>method = "cart"</code> the expectation and variance of the null 
distribution is calculated from a permutation test. Our recent work
indicates that this method can sometimes give misleading results.
</p>
<p>If missing values exist, indicator variables are added and included in the 
model as recommended by Rosenbaum and Rubin (1984). For categorical variables, 
<code>NA</code> is treated as a new category.</p>


<h3>Value</h3>

<p>An object of class <code>utility.gen</code> which is a list including the utility 
measures their expected null values for each synthetic set with the following 
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced the result.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of synthetic data sets in object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>method used to fit propensity score.</p>
</td></tr>
<tr><td><code>tree.method</code></td>
<td>
<p>cart function used to fit propensity score when 
<code>method = "cart"</code>.</p>
</td></tr>
<tr><td><code>resamp.method</code></td>
<td>
<p>type of resampling used to get <code>pMSEExp</code> and 
<code>pval</code>.</p>
</td></tr> 
<tr><td><code>maxorder</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>nfix</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>aggregate</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>maxit</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>ngroups</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom for the chi-squared test for logit models
derived from the number of non-aliased coefficients in the logistic model, 
minus <code>1</code> for <code>k.syn = FALSE</code>.</p>
</td></tr>
<tr><td><code>mincriterion</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>nperms</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>incomplete</code></td>
<td>
<p>TRUE/FALSE indicator if any of the variables being compared 
are not synthesised.</p>
</td></tr>
<tr><td><code>pMSE</code></td>
<td>
<p>propensity score mean square error from the utility model or a  
vector of these values if <code>object$m &gt; 1</code>.</p>
</td></tr>
<tr><td><code>S_pMSE</code></td>
<td>
<p>ratio(s) of <code>pMSE</code> to its Null expectation.</p>
</td></tr>
<tr><td><code>PO50</code></td>
<td>
<p>percentage  over 50% of each synthetic data set where the model 
used correctly predicts whether real or synthetic.</p>
</td></tr>
<tr><td><code>S_PO50</code></td>
<td>
<p>ratio(s) of <code>PO50</code> to its Null expectation.</p>
</td></tr>
<tr><td><code>SPECKS</code></td>
<td>
<p>Kolmogorov-Smirnov statistic to compare the propensity scores  
for the original and synthetic records.</p>
</td></tr>
<tr><td><code>S_SPECKS</code></td>
<td>
<p>ratio(s) of <code>SPECKS</code> to its Null expectation.</p>
</td></tr>
<tr><td><code>print.stats</code></td>
<td>
<p>see above.</p>
</td></tr>  
<tr><td><code>fit</code></td>
<td>
<p>the fitted model for the propensity score or a list of fitted 
models of length <code>m</code> if <code>m &gt; 0</code>.</p>
</td></tr>
<tr><td><code>nosplits</code></td>
<td>
<p>for resampling methods and cart models, a list of the number
of times from the total each resampled cart model failed to select any 
splits to classify the indicator. Indicates that this method is not working 
correctly and results should not be used but a logit model selected instead.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>print.ind.results</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>print.zscores</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>zthresh</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>print.variable.importance</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Woo, M-J., Reiter, J.P., Oganian, A. and Karr, A.F. (2009). Global measures 
of data utility for microdata masked for disclosure limitation. 
<em>Journal of Privacy and Confidentiality</em>, <b>1</b>(1), 111-124.
</p>
<p>Rosenbaum, P.R. and Rubin, D.B. (1984). Reducing bias in observational 
studies using subclassification on the propensity score.
<em>Journal of the American Statistical Association</em>,
<b>79</b>(387), 516-524.
</p>
<p>Snoke, J., Raab, G.M., Nowok, B., Dibben, C. and Slavkovic, A. (2018). 
General and specific utility measures for synthetic data. 
<em>Journal of the Royal Statistical Society: Series A</em>, <b>181</b>, 
Part 3, 663-688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.tab">utility.tab</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ods &lt;- SD2011[1:1000, c("age", "bmi", "depress", "alcabuse", "nofriend")]
  s1 &lt;- syn(ods, m = 5, method = "parametric", 
            cont.na = list(nofriend = -8))
    
  ### synthetic data provided as a 'synds' object   
  u1 &lt;- utility.gen(s1, ods)
  print(u1, print.zscores = TRUE, zthresh = 1, digits = 6)
  u2 &lt;- utility.gen(s1, ods, ngroups = 3, print.flag = FALSE)
  print(u2, print.zscores = TRUE)
  u3 &lt;- utility.gen(s1, ods, method = "cart", nperms = 20)
  print(u3, print.variable.importance = TRUE)
    
  ### synthetic data provided as 'list'
  utility.gen(s1$syn, ods, cont.na = list(nofriend = -8))  
  
## End(Not run)
</code></pre>

<hr>
<h2 id='utility.tab'>Tabular utility</h2><span id='topic+utility.tab'></span><span id='topic+utility.tab.synds'></span><span id='topic+utility.tab.data.frame'></span><span id='topic+utility.tab.list'></span><span id='topic+print.utility.tab'></span>

<h3>Description</h3>

<p>Produces tables from observed and synthesised data and calculates
utility measures to compare them with their expectation if the
synthesising model is correct.
</p>
<p>It can be also used with synthetic data NOT created by <code>syn()</code>,
but then an additional parameter <code>cont.na</code> might need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'synds'
utility.tab(object, data, vars = NULL, ngroups = 5,
            useNA = TRUE, max.table = 1e6,
            print.tables = length(vars) &lt; 4,
            print.stats = c("pMSE", "S_pMSE", "df"),
            print.zdiff = FALSE, print.flag = TRUE,
            digits = 4, k.syn = FALSE, ...)

## S3 method for class 'data.frame'
utility.tab(object, data, vars = NULL, cont.na = NULL,
            ngroups = 5, useNA = TRUE, max.table = 1e6,
            print.tables = length(vars) &lt; 4,
            print.stats = c("pMSE", "S_pMSE", "df"),
            print.zdiff = FALSE, print.flag = TRUE,
            digits = 4, k.syn = FALSE, ...)

## S3 method for class 'list'
utility.tab(object, data, vars = NULL, cont.na = NULL,
            ngroups = 5, useNA = TRUE, max.table = 1e6,
            print.tables = length(vars) &lt; 4,
            print.stats = c("pMSE", "S_pMSE", "df"),
            print.zdiff = FALSE, print.flag = TRUE,
            digits = 4, k.syn = FALSE, ...)


## S3 method for class 'utility.tab'
print(x, print.tables = NULL,
      print.zdiff = NULL, print.stats = NULL,
      digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.tab_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands for 'synthesised
data set'. It is typically created by function <code>syn()</code> or
<code>syn.strata()</code> and it includes <code>object$m</code> number of synthesised
data set(s), as well as <code>object$syn</code> the synthesised data set,
if <code>m = 1</code>, or a list of <code>m</code> such data sets. Alternatively,
when data are synthesised not using <code>syn()</code>, it can be a data frame
with a synthetic data set or a list of data frames with synthetic data sets,
all created from the same original data with the same variables and the same
method.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_data">data</code></td>
<td>
<p>the original (observed) data set.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_vars">vars</code></td>
<td>
<p>a single string or a vector of strings with the names of
variables to be used to form the table.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list of codes for missing values for continuous
variables if different from the <code>R</code> missing data code <code>NA</code>.
The names of the list elements must correspond to the variables names for
which the missing data codes need to be specified.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_max.table">max.table</code></td>
<td>
<p>a maximum table size. You could try increasing the default 
value, but memory problems are likely.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_ngroups">ngroups</code></td>
<td>
<p>if numerical (non-factor) variables are included they will be
classified into this number of groups to form tables. Classification is
performed using <code>classIntervals()</code> function for <code>n = ngroups</code>.
By default, <code>style = "quantile"</code> to get appropriate groups for skewed
data. Problems for variables with a small number of unique values are handled
by selecting only unique values of breaks. Arguments of <code>classIntervals()</code>
may be, however, specified in the call to <code>utility.tab()</code>.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_usena">useNA</code></td>
<td>
<p>determines if NA values are to be included in tables.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_print.tables">print.tables</code></td>
<td>
<p>a logical value that determines if tables of observed and
synthesised data are to be printed. By default tables are printed if they 
have up to three dimensions.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_print.stats">print.stats</code></td>
<td>
<p>a single string or a vector of strings that determines
which utility measures to print. Must be a selection from:  
<code>"VW"</code>, <code>"FT"</code>,<code>"JSD"</code>, <code>"SPECKS"</code>, <code>"WMabsDD"</code>, 
<code>"U"</code>, <code>"G"</code>, <code>"pMSE"</code>, <code>"PO50"</code>, <code>"MabsDD"</code>, 
<code>"dBhatt"</code>,  <code>"S_VW"</code>, <code>"S_FT"</code>, <code>"S_JSD"</code>, 
<code>"S_WMabsDD"</code>, <code>"S_G"</code>, <code>"S_pMSE"</code>, <code>"df"</code>, <code>dfG</code>. 
If <code>print.stats = "all"</code>, all of these will be printed. For more 
information see the details section below.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_print.zdiff">print.zdiff</code></td>
<td>
<p>a logical value that determines if tables of Z scores for
differences between observed and expected are to be printed.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_print.flag">print.flag</code></td>
<td>
<p>a logical value that determines if messages are to be printed 
during computation.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_digits">digits</code></td>
<td>
<p>an integer indicating the number of decimal places for printing
statistics, <code>tab.zdiff</code> and mean results for <code>m &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_k.syn">k.syn</code></td>
<td>
<p>a logical indicator as to whether the sample size itself has
been synthesised. The default value is <code>FALSE</code>, which will apply
to synthetic data created by synthpop.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_...">...</code></td>
<td>
<p>additional parameters; can be passed to classIntervals() function.</p>
</td></tr>
<tr><td><code id="utility.tab_+3A_x">x</code></td>
<td>
<p>an object of class <code>utility.tab</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forms tables of observed and synthesised values for the variables
specified in <code>vars</code>. Several utility measures are calculated from the cells
of the tables, as described below. Details of all of these measures can be found 
in Raab et al. (2021). If the synthesising model is correct the measures
<code>VW</code>, <code>FT</code>, <code>G</code> and <code>JSD</code> should have chi-square distributions 
with <code>df</code> degrees of freedom for large samples. Standardised versions of each 
measure are available (e.g. <code>S_VW</code> for <code>VW</code>, where <code>S_VW = VW/df</code>) 
that will have an expected value of <code>1</code> if the synthesising model is correct. 
Four other measures are calculated by considering the table as a prediction model. 
The propensity score mean-squared error <code>pMSE</code>, and from a comparison of 
propensity scores for the synthetic and original data the Kolmogorov-Smirnov 
statistic <code>SPECKS</code> and the Wilcoxon rank-sum statistic <code>U</code> and also 
the percentage of the observations correctly predicted in the combined tables over 
50%(<code>PO50</code>) where the majority of observations in each grouping are in 
agreement with category (real or synthetic) of the observation. The first of these 
<code>pMSE</code> is identical except for a constant to <code>VW</code>. No expected values are 
computed for the last three of these measures, but they can be obtained by replication 
from <code>utility.gen()</code>. 
Three further measures are calulated from the tables. The mean absolute difference 
in distributions: firstly <code>MabsDD</code>, the avarage absolute difference in the 
proportions of original and synthetic data from all the cells in the table. 
Secondly a weighted version of this measure <code>WMabsDD</code> where the weights are 
proportional to the inverse of the variance of the absolute differences so that 
this measure can be standardised by its expected value, <code>df</code>. Finally the 
Bhattacharyya distances <code>BhattD</code> derived from the overlap of the histograms 
of the original and synthetic data sets. 
</p>


<h3>Value</h3>

<p>An object of class <code>utility.tab</code> which is a list with the following
components:
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>number of synthetic data sets in object, i.e. <code>object$m</code>.</p>
</td></tr>
<tr><td><code>VW</code></td>
<td>
<p>a vector with <code>object$m</code> values for the Voas Williamson
utility measure.; linearly related to <code>pMSE</code>.</p>
</td></tr>
<tr><td><code>FT</code></td>
<td>
<p>a vector with <code>object$m</code> values for the Freeman-Tukey
utility measure.</p>
</td></tr>
<tr><td><code>JSD</code></td>
<td>
<p>a vector with <code>object$m</code> values for the Jensen-Shannaon 
divergence for comparing the tables.</p>
</td></tr>
<tr><td><code>SPECKS</code></td>
<td>
<p>a vector with <code>object$m</code> values for the Kolmogorov-Smirnov 
statistic for comparing the propensity scores for the original and synthetic 
data.</p>
</td></tr>
<tr><td><code>WMabsDD</code></td>
<td>
<p>a vector with <code>object$m</code> values of the weighted mean 
absolute difference in distributions for original and synthetic data.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>a vector with <code>object$m</code> values of the Wilcoxon statistic 
comparing the propensity scores for the original and synthetic data.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>a vector with <code>object$m</code> values for the adjusted likelihood 
ratio utility measure.</p>
</td></tr>
<tr><td><code>pMSE</code></td>
<td>
<p>a vector with <code>object$m</code> values of the propensity score 
mean-squared error; linearly related to <code>VW</code>.</p>
</td></tr> 
<tr><td><code>PO50</code></td>
<td>
<p>a vector with <code>object$m</code> values of the percentage over 
50% of observations correctly predicted from the propensity scores 
linearly related to <code>SPECKS</code> and <code>MabsDD</code>.</p>
</td></tr> 
<tr><td><code>MabsDD</code></td>
<td>
<p>a vector with <code>object$m</code> values of the mean absolute 
difference in distributions for original and synthetic data linearly 
related to <code>SPECKS</code> and <code>PO50</code>.</p>
</td></tr>
<tr><td><code>dBhatt</code></td>
<td>
<p>a vector with <code>object$m</code> values of the Bhattacharyya 
distances between the synthetic and original data, linearly related to 
the square root of <code>FT</code>.</p>
</td></tr>
<tr><td><code>S_VW</code></td>
<td>
<p><code>VW/df</code>.</p>
</td></tr>
<tr><td><code>S_FT</code></td>
<td>
<p><code>FT/df</code>.</p>
</td></tr>
<tr><td><code>S_JSD</code></td>
<td>
 <p><code>JSD</code>/df.</p>
</td></tr>
<tr><td><code>S_WMabsDD</code></td>
<td>
<p>WMabsDD/df.</p>
</td></tr>
<tr><td><code>S_G</code></td>
<td>
<p><code>G/df</code>.</p>
</td></tr>
<tr><td><code>S_pMSE</code></td>
<td>
<p>standardised measure from <code>pMSE</code>, identical to <code>S_VW</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a vector of degrees of freedom for the chi-square tests which equal
to the number of cells in the tables with any observed or
synthesised counts minus one when <code>k.syn == FALSE</code> or equal to the
the number of cells when <code>k.syn == TRUE</code>.</p>
</td></tr>
<tr><td><code>dfG</code></td>
<td>
<p>degrees of freedom used in standardising <code>G</code>.</p>
</td></tr>  
<tr><td><code>nempty</code></td>
<td>
<p>a vector of length <code>object$m</code> with number of cells
not contributing to the statistics.</p>
</td></tr>
<tr><td><code>tab.obs</code></td>
<td>
<p>a table from the observed data.</p>
</td></tr>
<tr><td><code>tab.syn</code></td>
<td>
<p>a table or a list of <code>m</code> tables from the synthetic data.</p>
</td></tr>
<tr><td><code>tab.zdiff</code></td>
<td>
<p>a table or a list of <code>m</code> tables of Z statistics for
differences between observed and synthesised cells of the tables. Large
absolute values indicate a large contribution to lack-of-fit.</p>
</td></tr>
<tr><td><code>digits</code></td>
<td>
<p>an integer indicating the number of decimal places
for printing statistics, <code>tab.zdiff</code> and mean results for <code>m &gt; 1</code>.</p>
</td></tr>
<tr><td><code>print.tables</code></td>
<td>
<p>a logical value that determines if tables of observed and
synthesised are to be printed.</p>
</td></tr>
<tr><td><code>print.stats</code></td>
<td>
<p>a single string or a vector of strings with utility measures
to be printed out.</p>
</td></tr>
<tr><td><code>print.zdiff</code></td>
<td>
<p>a logical value that determines if tables of  Z scores for
differences between observed and expected are to be printed.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observation in the original dataset.</p>
</td></tr>
<tr><td><code>k.syn</code></td>
<td>
<p>a logical indicator as to whether the sample size itself has
been synthesised.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nowok, B., Raab, G.M and Dibben, C. (2016). synthpop: Bespoke
creation of synthetic data in R. <em>Journal of Statistical Software</em>,
<b>74</b>(11), 1-26. <a href="https://doi.org/10.18637/jss.v074.i11">doi:10.18637/jss.v074.i11</a>.
</p>
<p>Raab, G.M., Nowok, B. and Dibben, C. (2021). Assessing, visualizing and 
improving the utility of synthetic data. Available from 
<a href="https://arxiv.org/abs/2109.12717">https://arxiv.org/abs/2109.12717</a>.
</p>
<p>Read, T.R.C. and Cressie, N.A.C. (1988) <em>Goodness&ndash;of&ndash;Fit Statistics for
Discrete Multivariate Data</em>, Springer&ndash;Verlag, New York.
</p>
<p>Voas, D. and Williamson, P. (2001) Evaluating goodness-of-fit measures for
synthetic microdata. <em>Geographical and Environmental Modelling</em>,
<b>5</b>(2), 177-200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.gen">utility.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000, c("sex", "age", "marital", "nofriend")]

s1 &lt;- syn(ods, m = 10, cont.na = list(nofriend = -8))
utility.tab(s1, ods, vars = c("marital", "sex"), print.stats = "all")

s2 &lt;- syn(ods, m = 1, cont.na = list(nofriend = -8))
u2 &lt;- utility.tab(s2, ods, vars = c("marital", "age", "sex"), ngroups = 3)
print(u2, print.tables = TRUE, print.zdiff = TRUE)

### synthetic data provided as 'data.frame'
utility.tab(s2$syn, ods, vars = c("marital", "nofriend"), ngroups = 3,
            print.tables = TRUE, cont.na = list(nofriend = -8), digits = 4)
</code></pre>

<hr>
<h2 id='utility.tables'>Tables and plots of utility measures</h2><span id='topic+utility.tables'></span><span id='topic+utility.tables.synds'></span><span id='topic+utility.tables.data.frame'></span><span id='topic+utility.tables.list'></span><span id='topic+print.utility.tables'></span>

<h3>Description</h3>

<p>Calculates and plots tables of utility measures. The calculations of 
utility measures are done by the function <code><a href="#topic+utility.tab">utility.tab</a></code>.
Options are all one-way tables, all two-way tables or three-way tables 
for a specified third variable along with pairs of all other variables.
</p>
<p>This function can be also used with synthetic data NOT created by 
<code>syn()</code>, but then an additional parameters <code>not.synthesised</code> 
and <code>cont.na</code> might need to be provided.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'synds'
utility.tables(object, data,
               tables = "twoway", maxtables = 5e4,
               vars = NULL, third.var = NULL,
               useNA = TRUE, ngroups = 5,
               tab.stats = c("pMSE", "S_pMSE", "df"), 
               plot.stat = "S_pMSE", plot = TRUE, 
               print.tabs = FALSE, digits.tabs = 4,
               max.scale = NULL, min.scale = 0, plot.title = NULL,
               nworst = 5, ntabstoprint = 0, k.syn = FALSE, 
               low = "grey92", high = "#E41A1C",
               n.breaks = NULL, breaks = NULL, ...)
               
## S3 method for class 'data.frame'
utility.tables(object, data, 
               cont.na = NULL, not.synthesised = NULL, 
               tables = "twoway", maxtables = 5e4,
               vars = NULL, third.var = NULL, 
               useNA = TRUE, ngroups = 5, 
               tab.stats = c("pMSE", "S_pMSE", "df"), 
               plot.stat = "S_pMSE", plot = TRUE,  
               print.tabs = FALSE, digits.tabs = 4,
               max.scale = NULL, min.scale = 0, plot.title = NULL,  
               nworst = 5, ntabstoprint = 0, k.syn = FALSE,
               low = "grey92", high = "#E41A1C",
               n.breaks = NULL, breaks = NULL, ...)

## S3 method for class 'list'
utility.tables(object, data,
               cont.na = NULL, not.synthesised = NULL, 
               tables = "twoway", maxtables = 5e4, 
               vars = NULL, third.var = NULL, 
               useNA = TRUE, ngroups = 5, 
               tab.stats = c("pMSE", "S_pMSE", "df"), 
               plot.stat = "S_pMSE", plot = TRUE, 
               print.tabs = FALSE, digits.tabs = 4,
               max.scale = NULL, min.scale = 0, plot.title = NULL,  
               nworst = 5, ntabstoprint = 0, k.syn = FALSE,
               low = "grey92", high = "#E41A1C",
               n.breaks = NULL, breaks = NULL, ...)

## S3 method for class 'utility.tables'
print(x, print.tabs = NULL, digits.tabs = NULL, 
      plot = NULL, plot.title = NULL, max.scale = NULL, min.scale = NULL, 
      nworst = NULL, ntabstoprint = NULL, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.tables_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands for 'synthesised 
data set'. It is typically created by function <code>syn()</code> and it includes 
<code>object$m</code> synthesised data set(s) as <code>object$syn</code>. This a single 
data set when <code>object$m = 1</code> or a list of length <code>object$m</code> when 
<code>object$m &gt; 1</code>. Alternatively, when data are synthesised not using 
<code>syn()</code>, it can be a data frame with a synthetic data set or a list 
of data frames with synthetic data sets, all created from the same original 
data with the same variables and the same method.</p>
</td></tr>  
<tr><td><code id="utility.tables_+3A_data">data</code></td>
<td>
<p>the original (observed) data set.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_cont.na">cont.na</code></td>
<td>
<p>a named list of codes for missing values for continuous
variables if different from the <code>R</code> missing data code <code>NA</code>.
The names of the list elements must correspond to the variables names for 
which the missing data codes need to be specified.</p>
</td></tr> 
<tr><td><code id="utility.tables_+3A_not.synthesised">not.synthesised</code></td>
<td>
<p>a vector of variable names for any variables that has 
been left unchanged in the synthetic data.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_tables">tables</code></td>
<td>
<p>defines the type of tables to produce. Options are 
<code>"oneway"</code>, <code>"twoway"</code> (default) or <code>"threeway"</code>. 
If set to <code>"oneway"</code> or <code>"twoway"</code> all possible tables from 
<code>vars</code> are produced. For <code>"threeway"</code>, <code>third.var</code> may be 
specified and all three-way tables between this variable and other pairs of 
variables are produced. If a third variable is not specified the function
chooses the variable with the largest median utility measure for all three-way
tables it contributes to.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_maxtables">maxtables</code></td>
<td>
<p>maximum number of tables that will be produced. If number of 
tables is larger, then utility is only measured for a sample of size 
<code>maxtables</code>. You cannot produce plots of twoway or three way tables from 
sampled tables</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="utility.tables_+3A_vars">vars</code></td>
<td>
<p>a vector of strings with the names of variables to be used to form 
the table, or a vector of variable numbers in the original data. Defaults to 
all variables in both original and synthetic data.</p>
</td></tr>    
<tr><td><code id="utility.tables_+3A_third.var">third.var</code></td>
<td>
<p>when <code>tables</code> is <code>"threeway"</code> a variable 
to make the third variable with all other pairs</p>
</td></tr>    
<tr><td><code id="utility.tables_+3A_usena">useNA</code></td>
<td>
<p>determines if <code>NA</code> values are to be included in tables. Only 
applies for method <code>"tab"</code>.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_ngroups">ngroups</code></td>
<td>
<p>if numerical (non-factor) variables included with 
<code>method = "tab"</code> will be classified into this number of groups to form
tables. Classification is performed using <code>classIntervals()</code> function 
for <code>n = ngroups</code>. By default, <code>style = "quantile"</code>, to get 
appropriate groups for skewed data. Problems for variables with a small 
number of unique  values are handled by selecting only unique values of 
breaks. Arguments of <code>classIntervals()</code> may be, however, specified 
in the call to <code>utility.tables()</code>.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_tab.stats">tab.stats</code></td>
<td>
<p>statistics to include in the table of results. Must be 
a selection from: <code>"VW"</code>, <code>"FT"</code>,<code>"JSD"</code>, <code>"SPECKS"</code>, 
<code>"WMabsDD"</code>, <code>"U"</code>, <code>"G"</code>, <code>"pMSE"</code>, <code>"PO50"</code>, 
<code>"MabsDD"</code>, <code>"dBhatt"</code>,  <code>"S_VW"</code>, <code>"S_FT"</code>, 
<code>"S_JSD"</code>, <code>"S_WMabsDD"</code>, <code>"S_G"</code>, <code>"S_pMSE"</code>, 
<code>"df"</code>, <code>dfG</code>. If <code>tab.stats = "all"</code>, all of these will 
be included. See <code><a href="#topic+utility.tab">utility.tab</a></code> for explanations of measures.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_plot.stat">plot.stat</code></td>
<td>
<p>statistics to plot. Choice  is <code>"VW"</code>, <code>"FT"</code>,
<code>"JSD"</code>, <code>"SPECKS"</code>,  <code>"WMabsDD"</code>, <code>"U"</code>, <code>"G"</code>, 
<code>"pMSE"</code>, <code>"PO50"</code>, <code>"MabsDD"</code>, <code>"dBhatt"</code>, 
<code>"S_VW"</code>, <code>"S_FT"</code>, <code>"S_JSD"</code>, <code>"S_WMabsDD"</code>, 
<code>"S_G"</code>, <code>"S_pMSE"</code>. See <code><a href="#topic+utility.tab">utility.tab</a></code> for 
explanations of measures.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_plot">plot</code></td>
<td>
<p>determines if plot will be produced when the result is printed.</p>
</td></tr> 
<tr><td><code id="utility.tables_+3A_print.tabs">print.tabs</code></td>
<td>
<p>logical value that determines if table of results is 
to be printed.</p>
</td></tr>  
<tr><td><code id="utility.tables_+3A_digits.tabs">digits.tabs</code></td>
<td>
<p>number of digits to print for table, except for 
p-values that are always printed to 4 places.</p>
</td></tr>  
<tr><td><code id="utility.tables_+3A_max.scale">max.scale</code></td>
<td>
<p>a numeric value for the maximum value used in calculating 
the shading of the plots. If it is <code>NULL</code> then the maximum value  
will be replaced by the maximum value in the data.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_min.scale">min.scale</code></td>
<td>
<p>a numeric value for the minimum value used in calculating 
the shading of the plots. If it is <code>NULL</code> then the minimum value  
will be replaced by zero.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_plot.title">plot.title</code></td>
<td>
<p>title for the plot.</p>
</td></tr> 
<tr><td><code id="utility.tables_+3A_nworst">nworst</code></td>
<td>
<p>a number of variable combinations with worst utility scores 
to be printed.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_ntabstoprint">ntabstoprint</code></td>
<td>
<p>a number of tables to print for observed and synthetic 
data with the worst utility.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_k.syn">k.syn</code></td>
<td>
<p>a logical indicator as to whether the sample size itself has 
been synthesised.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_low">low</code></td>
<td>
<p>colour for low end of the gradient.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_high">high</code></td>
<td>
<p>colour for high end of the gradient.</p>
</td></tr> 
<tr><td><code id="utility.tables_+3A_n.breaks">n.breaks</code></td>
<td>
<p>a number of break points to create if breaks are not given 
directly.</p>
</td></tr>
<tr><td><code id="utility.tables_+3A_breaks">breaks</code></td>
<td>
<p>breaks for a two colour binned gradient.</p>
</td></tr>    
<tr><td><code id="utility.tables_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>   
<tr><td><code id="utility.tables_+3A_x">x</code></td>
<td>
<p>an object of class <code>utility.tables</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates tables of observed and synthesised values for the variables 
specified in <code>vars</code> with the function <code><a href="#topic+utility.tab">utility.tab</a></code> and produces  
tables and plots of one-way, two-way or 
three-way utility measures formed from <code>vars</code>. Several options for utility 
measures can be selected for printing or plotting. Details are in help file 
for <code><a href="#topic+utility.tab">utility.tab</a></code>. 
</p>
<p>The tables and variables with the worst utility scores are identified. 
Visualisations of the matrices of utility scores are plotted. For threeway
tables a third variable can be defined to select all tables involving that 
variable for plotting. If it is not specified the variable with tables 
giving the worst utility is selected as the third variable.
</p>


<h3>Value</h3>

<p>An object of class <code>utility.tab</code> which is a list with the following 
components: 
</p>
<table>
<tr><td><code>tabs</code></td>
<td>
<p>a table with all the selected measures for all combinations of 
variables defined by <code>tables</code>, <code>third.var</code>, and <code>vars</code>.</p>
</td></tr>
<tr><td><code>plot.stat</code></td>
<td>
<p>measure used in <code>mat</code> and <code>toplot</code>.</p>
</td></tr> 
<tr><td><code>tables</code></td>
<td>
<p>see above.</p>
</td></tr> 
<tr><td><code>third.var</code></td>
<td>
<p>see above.</p>
</td></tr> 
<tr><td><code>utility.plot</code></td>
<td>
<p>plot of the selected utility measure.</p>
</td></tr>
<tr><td><code>var.scores</code></td>
<td>
<p>an average of utility scores for all combinations with other
variables.</p>
</td></tr> 
<tr><td><code>plot</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>print.tabs</code></td>
<td>
<p>see above.</p>
</td></tr>  
<tr><td><code>digits.tabs</code></td>
<td>
<p>see above.</p>
</td></tr> 
<tr><td><code>plot.title</code></td>
<td>
<p>see above.</p>
</td></tr> 
<tr><td><code>max.scale</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>min.scale</code></td>
<td>
<p>see above.</p>
</td></tr>  
<tr><td><code>ntabstoprint</code></td>
<td>
<p>see above.</p>
</td></tr>  
<tr><td><code>nworst</code></td>
<td>
<p>see above.</p>
</td></tr>  
<tr><td><code>worstn</code></td>
<td>
<p>variable combinations with <code>nworst</code> worst utility scores.</p>
</td></tr>   
<tr><td><code>worsttabs</code></td>
<td>
<p>observed and synthetic cross-tabulations for <code>worstn</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Read, T.R.C. and Cressie, N.A.C. (1988) <em>Goodness&ndash;of&ndash;Fit Statistics 
for Discrete Multivariate Data</em>, Springer&ndash;Verlag, New York.  
</p>
<p>Voas, D. and Williamson, P. (2001) Evaluating goodness-of-fit measures for 
synthetic microdata. <em>Geographical and Environmental Modelling</em>,
<b>5</b>(2), 177-200.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.tab">utility.tab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ods &lt;- SD2011[1:1000, c("sex", "age", "edu", "marital", "region", "income")]
s1 &lt;- syn(ods)

### synthetic data provided as a 'synds' object  
(t1 &lt;- utility.tables(s1, ods, tab.stats = "all", print.tabs = TRUE))
### synthetic data provided as a 'data.frame' object
(t1 &lt;- utility.tables(s1$syn, ods, tab.stats = "all", print.tabs = TRUE))

t2 &lt;- utility.tables(s1, ods, tables = "twoway")
print(t2, max.scale = 3)

(t3 &lt;- utility.tables(s1, ods, tab.stats = "all", tables = "threeway", 
                      third.var = "sex", print.tabs = TRUE))

(t4 &lt;- utility.tables(s1, ods, tab.stats = "all", tables = "threeway", 
                      third.var = "sex", useNA = FALSE, print.tabs = TRUE))

(t5 &lt;- utility.tables(s1, ods,  tab.stats = "all", 
                      print.tabs = TRUE))
</code></pre>

<hr>
<h2 id='write.syn'>Exporting synthetic data sets to external files</h2><span id='topic+write.syn'></span>

<h3>Description</h3>

<p>Exports synthetic data set(s) from synthesised data set 
(<code>synds</code>) object to external files of selected format. 
Currently supported file formats include: SPSS, Stata, SAS, csv, tab,
rda, RData and txt. For SPSS, Stata and SAS it uses functions from 
the <code>foreign</code> package with some adjustments where necessary.
Information about the synthesis is written into a separate text file.  
</p>
<p>NOTE: Currently numeric codes and labels can be preserved correctly only 
for SPSS files imported into R using <code><a href="#topic+read.obs">read.obs</a></code> function.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.syn(object, filename, 
filetype = c("SPSS", "Stata", "SAS", "csv", "tab", "rda", "RData", "txt"), 
convert.factors = "numeric", data.labels = NULL, save.complete = TRUE, 
extended.info = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.syn_+3A_object">object</code></td>
<td>
<p>an object of class <code>synds</code>, which stands
for 'synthesised data set'. It is typically created by
function <code><a href="#topic+syn">syn</a></code> and it includes <code>object$m</code> 
synthesised data set(s).</p>
</td></tr>
<tr><td><code id="write.syn_+3A_filename">filename</code></td>
<td>
<p>the name of the file (excluding extension) which the 
synthetic data are to be written into. For multiple synthetic data sets
it will be used as a prefix folowed respectively by <code>_1</code>, <code>_...</code>,
<code>_m</code>.</p>
</td></tr>
<tr><td><code id="write.syn_+3A_filetype">filetype</code></td>
<td>
<p>a desired format of the output files.</p>
</td></tr>
<tr><td><code id="write.syn_+3A_convert.factors">convert.factors</code></td>
<td>
<p>a single string indicating how to handle factors in 
Stata output files. The default value is set to <code>"numeric"</code> in order 
to preserve the numeric codes from the original data. 
See <code><a href="foreign.html#topic+write.dta">write.dta</a></code> for other possible values.</p>
</td></tr>
<tr><td><code id="write.syn_+3A_data.labels">data.labels</code></td>
<td>
<p>a list with variable labels and value labels.</p>
</td></tr>  
<tr><td><code id="write.syn_+3A_save.complete">save.complete</code></td>
<td>
<p>a logical value indicating whether a complete 
'synthesised data set' (<code>synds</code>) object should be saved into a file
(<code>synobject_filename.RData</code>).</p>
</td></tr>
<tr><td><code id="write.syn_+3A_extended.info">extended.info</code></td>
<td>
<p>a logical value indicating whether extended information
should be saved into an information file.</p>
</td></tr>
<tr><td><code id="write.syn_+3A_...">...</code></td>
<td>
<p>additional parameters passed to write functions.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>File(s) with synthesised data set(s) and a text file with information 
about synthesis are produced. Optionally a complete synthesised data set
object is saved into <code>synobject_filename.RData</code> file.</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.obs">read.obs</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
