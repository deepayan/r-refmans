<!DOCTYPE html><html lang="en"><head><title>Help for package EMC2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EMC2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EMC2-package'><p>EMC2: Bayesian Hierarchical Analysis of Cognitive Models of Choice</p></a></li>
<li><a href='#auto_thin.emc'><p>Automatically Thin an emc Object</p></a></li>
<li><a href='#chain_n'><p>MCMC Chain Iterations</p></a></li>
<li><a href='#check.emc'><p>Convergence Checks for an emc Object</p></a></li>
<li><a href='#compare'><p>Information Criteria and Marginal Likelihoods</p></a></li>
<li><a href='#compare_subject'><p>Information Criteria For Each Participant</p></a></li>
<li><a href='#contr.anova'><p>Anova Style Contrast Matrix</p></a></li>
<li><a href='#contr.bayes'><p>Contrast Enforcing Equal Prior Variance on each Level</p></a></li>
<li><a href='#contr.decreasing'><p>Contrast Enforcing Decreasing Estimates</p></a></li>
<li><a href='#contr.increasing'><p>Contrast Enforcing Increasing Estimates</p></a></li>
<li><a href='#credible.emc'><p>Posterior Credible Interval Tests</p></a></li>
<li><a href='#credint.emc.prior'><p>Posterior Quantiles</p></a></li>
<li><a href='#DDM'><p>The Diffusion Decision Model</p></a></li>
<li><a href='#design'><p>Specify a Design and Model</p></a></li>
<li><a href='#ess_summary.emc'><p>Effective Sample Size</p></a></li>
<li><a href='#fit.emc'><p>Model Estimation in EMC2</p></a></li>
<li><a href='#forstmann'><p>Forstmann et al.'s Data</p></a></li>
<li><a href='#gd_summary.emc'><p>Gelman-Rubin Statistic</p></a></li>
<li><a href='#get_BayesFactor'><p>Bayes Factors</p></a></li>
<li><a href='#get_data.emc'><p>Get Data</p></a></li>
<li><a href='#get_design.emc.prior'><p>Get Design</p></a></li>
<li><a href='#get_pars'><p>Filter/Manipulate Parameters from emc Object</p></a></li>
<li><a href='#get_prior.emc'><p>Get Prior</p></a></li>
<li><a href='#hypothesis.emc'><p>Within-Model Hypothesis Testing</p></a></li>
<li><a href='#init_chains'><p>Initialize Chains</p></a></li>
<li><a href='#LBA'><p>The Linear Ballistic Accumulator model</p></a></li>
<li><a href='#LNR'><p>The Log-Normal Race Model</p></a></li>
<li><a href='#make_data'><p>Simulate Data</p></a></li>
<li><a href='#make_emc'><p>Make an emc Object</p></a></li>
<li><a href='#make_random_effects'><p>Generate Subject-Level Parameters</p></a></li>
<li><a href='#mapped_pars'><p>Parameter Mapping Back to the Design Factors</p></a></li>
<li><a href='#merge_chains'><p>Merge Samples</p></a></li>
<li><a href='#model_averaging'><p>Model Averaging</p></a></li>
<li><a href='#pairs_posterior'><p>Plot Within-Chain Correlations</p></a></li>
<li><a href='#parameters.emc.prior'><p>Return Data Frame of Parameters</p></a></li>
<li><a href='#plot_cdf'><p>Plot Defective Cumulative Distribution Functions</p></a></li>
<li><a href='#plot_density'><p>Plot Defective Densities</p></a></li>
<li><a href='#plot_design.emc.design'><p>Plot Design</p></a></li>
<li><a href='#plot_pars'><p>Plots Density for Parameters</p></a></li>
<li><a href='#plot_relations'><p>Plot Group-Level Relations</p></a></li>
<li><a href='#plot_sbc_ecdf'><p>Plot the ECDF Difference in SBC Ranks</p></a></li>
<li><a href='#plot_sbc_hist'><p>Plot the Histogram of the Observed Rank Statistics of SBC</p></a></li>
<li><a href='#plot_stat'><p>Plot Statistics on Data</p></a></li>
<li><a href='#plot.emc'><p>Plot Function for emc Objects</p></a></li>
<li><a href='#plot.emc.design'><p>Plot method for emc.design objects</p></a></li>
<li><a href='#plot.emc.prior'><p>Plot a prior</p></a></li>
<li><a href='#predict.emc.prior'><p>Generate Posterior/Prior Predictives</p></a></li>
<li><a href='#prior'><p>Specify Priors for the Chosen Model</p></a></li>
<li><a href='#prior_help'><p>Prior Specification Information</p></a></li>
<li><a href='#profile_plot'><p>Likelihood Profile Plots</p></a></li>
<li><a href='#RDM'><p>The Racing Diffusion Model</p></a></li>
<li><a href='#recovery.emc'><p>Recovery Plots</p></a></li>
<li><a href='#run_bridge_sampling'><p>Estimating Marginal Likelihoods Using WARP-III Bridge Sampling</p></a></li>
<li><a href='#run_emc'><p>Custom Function for More Controlled Model Estimation</p></a></li>
<li><a href='#run_sbc'><p>Simulation-Based Calibration</p></a></li>
<li><a href='#sampled_pars'><p>Get Model Parameters from a Design</p></a></li>
<li><a href='#samples_LNR'><p>LNR Model of Forstmann Data (First 3 Subjects)</p></a></li>
<li><a href='#subset.emc'><p>Shorten an emc Object</p></a></li>
<li><a href='#summary.emc'><p>Summary Statistics for emc Objects</p></a></li>
<li><a href='#summary.emc.design'><p>Summary method for emc.design objects</p></a></li>
<li><a href='#summary.emc.prior'><p>Summary method for emc.prior objects</p></a></li>
<li><a href='#update2version'><p>Update EMC Objects to the Current Version</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Hierarchical Analysis of Cognitive Models of Choice</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian (hierarchical) cognitive models
    using a linear modeling language interface using particle Metropolis Markov
    chain Monte Carlo sampling with Gibbs steps. The diffusion decision model (DDM), 
    linear ballistic accumulator model (LBA), racing diffusion model (RDM), and the lognormal
    race model (LNR) are supported. Additionally, users can specify their own likelihood
    function and/or choose for non-hierarchical
    estimation, as well as for a diagonal, blocked or full multivariate normal
    group-level distribution to test individual differences. Prior specification 
    is facilitated through methods that visualize the (implied) prior. 
    A wide range of plotting functions assist in assessing model convergence and
    posterior inference. Models can be easily evaluated using functions
    that plot posterior predictions or using relative model comparison metrics 
    such as information criteria or Bayes factors.    
    References: Stevenson et al. (2024) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2F2e4dq">doi:10.31234/osf.io/2e4dq</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ampl-psych.github.io/EMC2/">https://ampl-psych.github.io/EMC2/</a>,
<a href="https://github.com/ampl-psych/EMC2">https://github.com/ampl-psych/EMC2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ampl-psych/EMC2/issues">https://github.com/ampl-psych/EMC2/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), vdiffr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, coda, corpcor, graphics, grDevices, magic, MASS,
matrixcalc, methods, msm, mvtnorm, parallel, stats, Matrix,
Rcpp, Brobdingnag, corrplot, colorspace, psych, utils, lpSolve,
WienR</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 03:56:53 UTC; niek</td>
</tr>
<tr>
<td>Author:</td>
<td>Niek Stevenson <a href="https://orcid.org/0000-0003-3206-7544"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michelle Donzallaz [aut],
  Andrew Heathcote [aut],
  Steven Miletić [ctb],
  Raphael Hartmann [ctb],
  Karl C. Klauer [ctb],
  Steven G. Johnson [ctb],
  Jean M. Linhart [ctb],
  Brian Gough [ctb],
  Gerard Jungman [ctb],
  Rudolf Schuerer [ctb],
  Przemyslaw Sliwa [ctb],
  Jason H. Stover [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Niek Stevenson &lt;niek.stevenson@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 08:50:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='EMC2-package'>EMC2: Bayesian Hierarchical Analysis of Cognitive Models of Choice</h2><span id='topic+EMC2'></span><span id='topic+EMC2-package'></span>

<h3>Description</h3>

<p>Fit Bayesian (hierarchical) cognitive models using a linear modeling language interface using particle Metropolis Markov chain Monte Carlo sampling with Gibbs steps. The diffusion decision model (DDM), linear ballistic accumulator model (LBA), racing diffusion model (RDM), and the lognormal race model (LNR) are supported. Additionally, users can specify their own likelihood function and/or choose for non-hierarchical estimation, as well as for a diagonal, blocked or full multivariate normal group-level distribution to test individual differences. Prior specification is facilitated through methods that visualize the (implied) prior. A wide range of plotting functions assist in assessing model convergence and posterior inference. Models can be easily evaluated using functions that plot posterior predictions or using relative model comparison metrics such as information criteria or Bayes factors. References: Stevenson et al. (2024) <a href="https://doi.org/10.31234/osf.io/2e4dq">doi:10.31234/osf.io/2e4dq</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Niek Stevenson <a href="mailto:niek.stevenson@gmail.com">niek.stevenson@gmail.com</a> (<a href="https://orcid.org/0000-0003-3206-7544">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Michelle Donzallaz
</p>
</li>
<li><p> Andrew Heathcote
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Steven Miletić [contributor]
</p>
</li>
<li><p> Raphael Hartmann [contributor]
</p>
</li>
<li><p> Karl C. Klauer [contributor]
</p>
</li>
<li><p> Steven G. Johnson [contributor]
</p>
</li>
<li><p> Jean M. Linhart [contributor]
</p>
</li>
<li><p> Brian Gough [contributor]
</p>
</li>
<li><p> Gerard Jungman [contributor]
</p>
</li>
<li><p> Rudolf Schuerer [contributor]
</p>
</li>
<li><p> Przemyslaw Sliwa [contributor]
</p>
</li>
<li><p> Jason H. Stover [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ampl-psych.github.io/EMC2/">https://ampl-psych.github.io/EMC2/</a>
</p>
</li>
<li> <p><a href="https://github.com/ampl-psych/EMC2">https://github.com/ampl-psych/EMC2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ampl-psych/EMC2/issues">https://github.com/ampl-psych/EMC2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='auto_thin.emc'>Automatically Thin an emc Object</h2><span id='topic+auto_thin.emc'></span><span id='topic+auto_thin'></span>

<h3>Description</h3>

<p>Uses the effective sample size of <code>selection</code> to determine how much to optimally thin an emc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
auto_thin(emc, stage = "sample", selection = c("alpha", "mu"), ...)

auto_thin(emc, stage = "sample", selection = c("alpha", "mu"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_thin.emc_+3A_emc">emc</code></td>
<td>
<p>an emc object.</p>
</td></tr>
<tr><td><code id="auto_thin.emc_+3A_stage">stage</code></td>
<td>
<p>A character string. Indicates from which sampling stage(s) to take the samples from (i.e. <code>preburn</code>, <code>burn</code>, <code>adapt</code>, <code>sample</code>)</p>
</td></tr>
<tr><td><code id="auto_thin.emc_+3A_selection">selection</code></td>
<td>
<p>Which parameter types (i.e. 'alpha' or 'mu' to consider when determining the effective sample size)</p>
</td></tr>
<tr><td><code id="auto_thin.emc_+3A_...">...</code></td>
<td>
<p>additional optional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='chain_n'>MCMC Chain Iterations</h2><span id='topic+chain_n'></span>

<h3>Description</h3>

<p>Returns a matrix with the number of samples per chain for each stage that is present
in the emc object (i.e., <code>preburn</code>, <code>burn</code>, <code>adapt</code>,
<code>sample</code>). The number of rows of the matrix reflects the number of chains
and the number of columns the number of sampling stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain_n(emc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chain_n_+3A_emc">emc</code></td>
<td>
<p>A list, the output of <code>fit()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chain_n(samples_LNR)

</code></pre>

<hr>
<h2 id='check.emc'>Convergence Checks for an emc Object</h2><span id='topic+check.emc'></span><span id='topic+check'></span>

<h3>Description</h3>

<p>Runs a series of convergence checks, prints statistics to the console, and
makes traceplots of the worst converged parameter per selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
check(
  emc,
  selection = c("mu", "sigma2", "alpha"),
  digits = 3,
  plot_worst = TRUE,
  ...
)

check(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="check.emc_+3A_selection">selection</code></td>
<td>
<p>A Character vector. Indicates which parameter types to check (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="check.emc_+3A_digits">digits</code></td>
<td>
<p>Integer. How many digits to round the ESS and Rhat to in the plots</p>
</td></tr>
<tr><td><code id="check.emc_+3A_plot_worst">plot_worst</code></td>
<td>
<p>Boolean. If <code>TRUE</code> also plots the chain plots for the worst parameter</p>
</td></tr>
<tr><td><code id="check.emc_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code> or <code>plot.default</code> (see <code>par()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>Rhat</code> is calculated by doubling the number of chains by
first splitting chains into first and second half, so it also a test of
stationarity.
</p>
<p>Efficiency of sampling is indicated by the effective
sample size (ESS) (from the <code>coda</code> R package).
Full range of possible samples manipulations described in <code>get_pars</code>.
</p>


<h3>Value</h3>

<p>a list with the statistics for the worst converged parameter per selection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check(samples_LNR)
</code></pre>

<hr>
<h2 id='compare'>Information Criteria and Marginal Likelihoods</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Returns the BPIC/DIC or marginal deviance (-2*marginal likelihood) for a list of samples objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(
  sList,
  stage = "sample",
  filter = NULL,
  use_best_fit = TRUE,
  BayesFactor = TRUE,
  cores_for_props = 4,
  cores_per_prop = 1,
  print_summary = TRUE,
  digits = 0,
  digits_p = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_+3A_slist">sList</code></td>
<td>
<p>List of samples objects</p>
</td></tr>
<tr><td><code id="compare_+3A_stage">stage</code></td>
<td>
<p>A string. Specifies which stage the samples are to be taken from <code>"preburn"</code>, <code>"burn"</code>, <code>"adapt"</code>, or <code>"sample"</code></p>
</td></tr>
<tr><td><code id="compare_+3A_filter">filter</code></td>
<td>
<p>An integer or vector. If it's an integer, iterations up until the value set by <code>filter</code> will be excluded.
If a vector is supplied, only the iterations in the vector will be considered.</p>
</td></tr>
<tr><td><code id="compare_+3A_use_best_fit">use_best_fit</code></td>
<td>
<p>Boolean, defaults to <code>TRUE</code>, uses the minimal or mean likelihood (whichever is better) in the
calculation, otherwise always uses the mean likelihood.</p>
</td></tr>
<tr><td><code id="compare_+3A_bayesfactor">BayesFactor</code></td>
<td>
<p>Boolean, defaults to <code>TRUE</code>. Include marginal likelihoods as estimated using WARP-III bridge sampling.
Usually takes a minute per model added to calculate</p>
</td></tr>
<tr><td><code id="compare_+3A_cores_for_props">cores_for_props</code></td>
<td>
<p>Integer, how many cores to use for the Bayes factor calculation, here 4 is the default for the 4 different proposal densities to evaluate, only 1, 2 and 4 are sensible.</p>
</td></tr>
<tr><td><code id="compare_+3A_cores_per_prop">cores_per_prop</code></td>
<td>
<p>Integer, how many cores to use for the Bayes factor calculation if you have more than 4 cores available. Cores used will be cores_for_props * cores_per_prop. Best to prioritize cores_for_props being 4 or 2</p>
</td></tr>
<tr><td><code id="compare_+3A_print_summary">print_summary</code></td>
<td>
<p>Boolean (default <code>TRUE</code>), print table of results</p>
</td></tr>
<tr><td><code id="compare_+3A_digits">digits</code></td>
<td>
<p>Integer, significant digits in printed table for information criteria</p>
</td></tr>
<tr><td><code id="compare_+3A_digits_p">digits_p</code></td>
<td>
<p>Integer, significant digits in printed table for model weights</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>Additional, optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of effective number of parameters, mean deviance, deviance of
mean, DIC, BPIC, Marginal Deviance (if <code>BayesFactor=TRUE</code>) and associated weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
compare(list(samples_LNR), cores_for_props = 1)
# Typically we would define a list of two (or more) different models:
# # Here the full model is an emc object with the hypothesized effect
# # The null model is an emc object without the hypothesized effect
# design_full &lt;- design(data = forstmann,model=DDM,
#                            formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
#                            constants=c(s=log(1)))
# # Now without a ~ E
# design_null &lt;- design(data = forstmann,model=DDM,
#                            formula =list(v~0+S,a~1, t0~1, s~1, Z~1, sv~1, SZ~1),
#                            constants=c(s=log(1)))
#
# full_model &lt;- make_emc(forstmann, design_full)
# full_model &lt;- fit(full_model)
#
# null_model &lt;- make_emc(forstmann, design_null)
# null_model &lt;- fit(null_model)
# sList &lt;- list(full_model, null_model)
# # By default emc uses 4 cores to parallelize marginal likelihood estimation across proposals
# # So cores_per_prop = 3 results in 12 cores used.
# compare(sList, cores_per_prop = 3)

</code></pre>

<hr>
<h2 id='compare_subject'>Information Criteria For Each Participant</h2><span id='topic+compare_subject'></span>

<h3>Description</h3>

<p>Returns the BPIC/DIC based model weights for each participant in a list of samples objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_subject(
  sList,
  stage = "sample",
  filter = 0,
  use_best_fit = TRUE,
  print_summary = TRUE,
  digits = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_subject_+3A_slist">sList</code></td>
<td>
<p>List of samples objects</p>
</td></tr>
<tr><td><code id="compare_subject_+3A_stage">stage</code></td>
<td>
<p>A string. Specifies which stage the samples are to be taken from <code>"preburn"</code>, <code>"burn"</code>, <code>"adapt"</code>, or <code>"sample"</code></p>
</td></tr>
<tr><td><code id="compare_subject_+3A_filter">filter</code></td>
<td>
<p>An integer or vector. If it's an integer, iterations up until the value set by <code>filter</code> will be excluded.
If a vector is supplied, only the iterations in the vector will be considered.</p>
</td></tr>
<tr><td><code id="compare_subject_+3A_use_best_fit">use_best_fit</code></td>
<td>
<p>Boolean, defaults to <code>TRUE</code>, use minimal likelihood or mean likelihood
(whichever is better) in the calculation, otherwise always uses the mean likelihood.</p>
</td></tr>
<tr><td><code id="compare_subject_+3A_print_summary">print_summary</code></td>
<td>
<p>Boolean (defaults to <code>TRUE</code>) print table of results</p>
</td></tr>
<tr><td><code id="compare_subject_+3A_digits">digits</code></td>
<td>
<p>Integer, significant digits in printed table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of matrices for each subject of effective number of parameters,
mean deviance, deviance of mean, DIC, BPIC and associated weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a broader illustration see `compare`.
# Here we just take two times the same model, but normally one would compare
# different models
compare_subject(list(m0 = samples_LNR, m1 = samples_LNR))
</code></pre>

<hr>
<h2 id='contr.anova'>Anova Style Contrast Matrix</h2><span id='topic+contr.anova'></span>

<h3>Description</h3>

<p>Similar to <code>contr.helmert</code>, but then scaled to estimate differences between conditions. Use in <code>design()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.anova(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.anova_+3A_n">n</code></td>
<td>
<p>An integer. The number of items for which to create the contrast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
design_DDMaE &lt;- design(data = forstmann,model=DDM, contrasts = list(E = contr.anova),
formula =list(v~S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
constants=c(s=log(1)))
}
</code></pre>

<hr>
<h2 id='contr.bayes'>Contrast Enforcing Equal Prior Variance on each Level</h2><span id='topic+contr.bayes'></span>

<h3>Description</h3>

<p>Typical contrasts impose different levels of marginal prior variance for the different levels.
This contrast can be used to ensure that each level has equal marginal priors (Rouder, Morey, Speckman, &amp; Province; 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.bayes(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.bayes_+3A_n">n</code></td>
<td>
<p>An integer. The number of items for which to create the contrast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contrast matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
design_DDMaE &lt;- design(data = forstmann,model=DDM, contrasts = list(E = contr.bayes),
formula =list(v~S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
constants=c(s=log(1)))
}
</code></pre>

<hr>
<h2 id='contr.decreasing'>Contrast Enforcing Decreasing Estimates</h2><span id='topic+contr.decreasing'></span>

<h3>Description</h3>

<p>Each level will be estimated as a reduction from the previous level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.decreasing(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.decreasing_+3A_n">n</code></td>
<td>
<p>an integer. The number of items for which to create the contrast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a contrast matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
design_DDMaE &lt;- design(data = forstmann,model=DDM, contrasts = list(E = contr.decreasing),
formula =list(v~S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
constants=c(s=log(1)))
}
</code></pre>

<hr>
<h2 id='contr.increasing'>Contrast Enforcing Increasing Estimates</h2><span id='topic+contr.increasing'></span>

<h3>Description</h3>

<p>Each level will be estimated additively from the previous level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.increasing(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.increasing_+3A_n">n</code></td>
<td>
<p>an integer. The number of items for which to create the contrast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a contrast matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
design_DDMaE &lt;- design(data = forstmann,model=DDM, contrasts = list(E = contr.increasing),
formula =list(v~S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
constants=c(s=log(1)))
}
</code></pre>

<hr>
<h2 id='credible.emc'>Posterior Credible Interval Tests</h2><span id='topic+credible.emc'></span><span id='topic+credible'></span>

<h3>Description</h3>

<p>Modeled after <code>t.test</code>, returns the credible interval of the parameter or test
and what proportion of the posterior distribution (or the difference in posterior distributions
in case of a two sample test) overlaps with mu.
For a one sample test provide <code>x</code> and for two sample also provide <code>y</code>.
Note that for comparisons within one model, we recommend using <code>hypothesis()</code> if the priors
were well chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
credible(
  x,
  x_name = NULL,
  x_fun = NULL,
  x_fun_name = "fun",
  selection = "mu",
  y = NULL,
  y_name = NULL,
  y_fun = NULL,
  y_fun_name = "fun",
  x_subject = NULL,
  y_subject = NULL,
  mu = 0,
  alternative = c("less", "greater")[1],
  probs = c(0.025, 0.5, 0.975),
  digits = 2,
  p_digits = 3,
  print_table = TRUE,
  ...
)

credible(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credible.emc_+3A_x">x</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_x_name">x_name</code></td>
<td>
<p>A character string. Name of the parameter to be tested for <code>x</code></p>
</td></tr>
<tr><td><code id="credible.emc_+3A_x_fun">x_fun</code></td>
<td>
<p>Function applied to the MCMC chains to create
variable to be tested.</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_x_fun_name">x_fun_name</code></td>
<td>
<p>Name to give to quantity calculated by <code>x_fun</code></p>
</td></tr>
<tr><td><code id="credible.emc_+3A_selection">selection</code></td>
<td>
<p>A character string designating parameter type (e.g. <code>alpha</code> or <code>covariance</code>)</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_y">y</code></td>
<td>
<p>A second emc object</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_y_name">y_name</code></td>
<td>
<p>A character string. Name of the parameter to be tested for <code>y</code></p>
</td></tr>
<tr><td><code id="credible.emc_+3A_y_fun">y_fun</code></td>
<td>
<p>Function applied to the MCMC chains to create
variable to be tested.</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_y_fun_name">y_fun_name</code></td>
<td>
<p>Name to give to quantity calculated by <code>y_fun</code></p>
</td></tr>
<tr><td><code id="credible.emc_+3A_x_subject">x_subject</code></td>
<td>
<p>Integer or name selecting a subject</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_y_subject">y_subject</code></td>
<td>
<p>Integer or name selecting a subject</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_mu">mu</code></td>
<td>
<p>Numeric. <code>NULL</code> value for single sample test if <code>y</code> is not supplied (default 0)</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_alternative">alternative</code></td>
<td>
<p><code>less</code> or <code>greater</code> determining direction of test probability</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_probs">probs</code></td>
<td>
<p>Vector defining quantiles to return.</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_digits">digits</code></td>
<td>
<p>Integer, significant digits for estimates in printed results</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_p_digits">p_digits</code></td>
<td>
<p>Integer, significant digits for probability in printed results</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_print_table">print_table</code></td>
<td>
<p>Boolean (defaults to <code>TRUE</code>) for printing results table</p>
</td></tr>
<tr><td><code id="credible.emc_+3A_...">...</code></td>
<td>
<p>Additional optional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible results table with no rounding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# Run a credible interval test (Bayesian ''t-test'')
credible(samples_LNR, x_name = "m")
# We can also compare between two sets of emc objects

# # Now without a ~ E
# design_null &lt;- design(data = forstmann,model=DDM,
#                            formula =list(v~0+S,a~1, t0~1, s~1, Z~1, sv~1, SZ~1),
#                            constants=c(s=log(1)))
#
# null_model &lt;- make_emc(forstmann, design_null)
# null_model &lt;- fit(null_model)
# credible(x = null_model, x_name = "a", y = full_model, y_name = "a")
#
# # Or provide custom functions:
# credible(x = full_model, x_fun = function(d) d["a_Eaccuracy"] - d["a_Eneutral"])
}
</code></pre>

<hr>
<h2 id='credint.emc.prior'>Posterior Quantiles</h2><span id='topic+credint.emc.prior'></span><span id='topic+credint.emc'></span><span id='topic+credint'></span>

<h3>Description</h3>

<p>Returns the quantiles of the selected parameter type.
Full range of possible samples manipulations described in <code>get_pars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
credint(
  x,
  selection = "mu",
  probs = c(0.025, 0.5, 0.975),
  digits = 3,
  N = 1000,
  covariates = NULL,
  ...
)

## S3 method for class 'emc'
credint(x, selection = "mu", probs = c(0.025, 0.5, 0.975), digits = 3, ...)

credint(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credint.emc.prior_+3A_x">x</code></td>
<td>
<p>An emc or emc.prior object</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_selection">selection</code></td>
<td>
<p>A Character vector. Indicates which parameter types to check (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_probs">probs</code></td>
<td>
<p>A vector. Indicates which quantiles to return from the posterior.</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_digits">digits</code></td>
<td>
<p>Integer. How many digits to round the output to</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_n">N</code></td>
<td>
<p>An integer. Number of samples to use for the quantile calculation (only for prior.emc objects)</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_covariates">covariates</code></td>
<td>
<p>A list of covariates to use for the quantile calculation (only for prior.emc objects)</p>
</td></tr>
<tr><td><code id="credint.emc.prior_+3A_...">...</code></td>
<td>
<p>Optional additional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of posterior quantiles for each parameter group in the selected parameter type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>credint(samples_LNR)
</code></pre>

<hr>
<h2 id='DDM'>The Diffusion Decision Model</h2><span id='topic+DDM'></span>

<h3>Description</h3>

<p>Model file to estimate the Diffusion Decision Model (DDM) in EMC2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DDM()
</code></pre>


<h3>Details</h3>

<p>Model files are almost exclusively used in <code>design()</code>.
</p>
<p>Default values are used for all parameters that are not explicitly listed in the <code>formula</code>
argument of <code>design()</code>.They can also be accessed with <code>DDM()$p_types</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Parameter</strong> </td><td style="text-align: left;"> <strong>Transform</strong> </td><td style="text-align: left;"> <strong>Natural scale</strong> </td><td style="text-align: left;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Mapping</strong> </td><td style="text-align: left;"> <strong>Interpretation</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>v</em> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> [-Inf, Inf] </td><td style="text-align: left;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: left;"> Mean evidence-accumulation rate (drift rate) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>a</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Boundary separation </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>t0</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Non-decision time </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>s</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Within-trial standard deviation of drift rate </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>Z</em> </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> [0, 1] </td><td style="text-align: left;"> qnorm(0.5) </td><td style="text-align: left;"> <em>z</em> = <em>Z</em> x <em>a</em> </td><td style="text-align: left;"> Relative start point (bias) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>SZ</em> </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> [0, 1] </td><td style="text-align: left;"> qnorm(0) </td><td style="text-align: left;"> <em>sz</em> = 2 x <em>SZ</em> x min(<em>a</em> x <em>Z</em>, <em>a</em> x (1-<em>Z</em>)) </td><td style="text-align: left;"> Relative between-trial variation in start point </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>sv</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Between-trial standard deviation of drift rate </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>st0</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Between-trial variation (range) in non-decision time </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>a</code>, <code>t0</code>, <code>sv</code>, <code>st0</code>, <code>s</code> are sampled on the log scale because these parameters are strictly positive,
<code>Z</code>, <code>SZ</code> and <code>DP</code> are sampled on the probit scale because they should be strictly between 0 and 1.
</p>
<p><code>Z</code> is estimated as the ratio of bias to one boundary where 0.5 means no bias.
<code>DP</code> comprises the difference in non-decision time for each response option.
</p>
<p>Conventionally, <code>s</code> is fixed to 1 to satisfy scaling constraints.
</p>
<p>See Ratcliff, R., &amp; McKoon, G. (2008).
The diffusion decision model: theory and data for two-choice decision tasks.
<em>Neural computation, 20</em>(4), 873-922. doi:10.1162/neco.2008.12-06-420.
</p>


<h3>Value</h3>

<p>A model list with all the necessary functions for EMC2 to sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# For all parameters that are not defined in the formula, default values are assumed
# (see Table above).

</code></pre>

<hr>
<h2 id='design'>Specify a Design and Model</h2><span id='topic+design'></span>

<h3>Description</h3>

<p>This function combines information regarding the data, type of model, and
the model specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(
  formula = NULL,
  factors = NULL,
  Rlevels = NULL,
  model,
  data = NULL,
  contrasts = NULL,
  matchfun = NULL,
  constants = NULL,
  covariates = NULL,
  functions = NULL,
  report_p_vector = TRUE,
  custom_p_vector = NULL,
  transform = NULL,
  bound = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_+3A_formula">formula</code></td>
<td>
<p>A list. Contains the design formulae in the
format <code>list(y ~ x, a ~ z)</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_factors">factors</code></td>
<td>
<p>A named list containing all the factor variables that span
the design cells and that should be taken into account by the model.
The name <code>subjects</code> must be used to indicate the participant factor variable,
also in the data.
</p>
<p>Example: <code>list(subjects=levels(dat$subjects), condition=levels(dat$condition))</code></p>
</td></tr>
<tr><td><code id="design_+3A_rlevels">Rlevels</code></td>
<td>
<p>A character vector. Contains the response factor levels.
Example: <code>c("right", "left")</code></p>
</td></tr>
<tr><td><code id="design_+3A_model">model</code></td>
<td>
<p>A function, specifies the model type.
Choose from the drift diffusion model (<code>DDM()</code>, <code>DDMt0natural()</code>),
the log-normal race model (<code>LNR()</code>), the linear ballistic model (<code>LBA()</code>),
the racing diffusion model (<code>RDM()</code>, <code>RDMt0natural()</code>), or define your own
model functions.</p>
</td></tr>
<tr><td><code id="design_+3A_data">data</code></td>
<td>
<p>A data frame. <code>data</code> can be used to automatically detect
<code>factors</code>, <code>Rlevels</code> and <code>covariates</code> in a dataset. The variable <code>R</code> needs
to be a factor variable indicating the response variable. Any numeric column
except <code>trials</code> and <code>rt</code> are treated as covariates, and all remaining factor
variables are internally used in <code>factors</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_contrasts">contrasts</code></td>
<td>
<p>Optional. A named list specifying a design matrix.
Example for supplying a customized design matrix:
<code style="white-space: pre;">&#8288;list(lM = matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))))&#8288;</code></p>
</td></tr>
<tr><td><code id="design_+3A_matchfun">matchfun</code></td>
<td>
<p>A function. Only needed for race models. Specifies whether a
response was correct or not. Example: <code>function(d)d$S==d$lR</code> where lR refers
to the latent response factor.</p>
</td></tr>
<tr><td><code id="design_+3A_constants">constants</code></td>
<td>
<p>A named vector that sets constants. Any parameter in
<code>sampled_pars</code> can be set constant.</p>
</td></tr>
<tr><td><code id="design_+3A_covariates">covariates</code></td>
<td>
<p>Names of numeric covariates.</p>
</td></tr>
<tr><td><code id="design_+3A_functions">functions</code></td>
<td>
<p>List of functions to create new factors based on those in
the factors argument. These new factors can then be used in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_report_p_vector">report_p_vector</code></td>
<td>
<p>Boolean. If TRUE (default), it returns the vector of
parameters to be estimated.</p>
</td></tr>
<tr><td><code id="design_+3A_custom_p_vector">custom_p_vector</code></td>
<td>
<p>A character vector. If specified, a custom likelihood
function can be supplied.</p>
</td></tr>
<tr><td><code id="design_+3A_transform">transform</code></td>
<td>
<p>A list with custom transformations to be applied to the parameters of the model,
if the conventional transformations aren't desired.
See <code>DDM()</code> for an example of such transformations</p>
</td></tr>
<tr><td><code id="design_+3A_bound">bound</code></td>
<td>
<p>A list with custom bounds to be applied to the parameters of the model,
if the conventional bound aren't desired.
see <code>DDM()</code> for an example of such bounds. Bounds are used to set limits to
the likelihood landscape that cannot reasonable be achieved with <code>transform</code></p>
</td></tr>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>Additional, optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example dataset
dat &lt;- forstmann

# create a function that takes the latent response (lR) factor (d) and returns a logical
# defining the correct response for each stimulus. Here the match is simply
# such that the S factor equals the latent response factor
matchfun &lt;- function(d)d$S==d$lR

# When working with lM and lR, it can be useful to design  an
# "average and difference" contrast matrix. For binary responses, it has a
# simple canonical form
ADmat &lt;- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))

# Create a design for a linear ballistic accumulator model (LBA) that allows
# thresholds to be a function of E and lR. The final result is a 9 parameter model.
design_LBABE &lt;- design(data = dat,model=LBA,matchfun=matchfun,
                            formula=list(v~lM,sv~lM,B~E+lR,A~1,t0~1),
                            contrasts=list(v=list(lM=ADmat)),
                            constants=c(sv=log(1)))
</code></pre>

<hr>
<h2 id='ess_summary.emc'>Effective Sample Size</h2><span id='topic+ess_summary.emc'></span><span id='topic+ess_summary'></span>

<h3>Description</h3>

<p>Returns the effective sample size (ESS) of the selected parameter type.
Full range of possible samples manipulations described in <code>get_pars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
ess_summary(
  emc,
  selection = "mu",
  stat = "min",
  stat_only = FALSE,
  digits = 1,
  ...
)

ess_summary(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ess_summary.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="ess_summary.emc_+3A_selection">selection</code></td>
<td>
<p>A Character vector. Indicates which parameter types to check (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="ess_summary.emc_+3A_stat">stat</code></td>
<td>
<p>A string. Should correspond to a function that can be applied to a vector,
which will be performed on the vector/rows or columns of the matrix of the parameters</p>
</td></tr>
<tr><td><code id="ess_summary.emc_+3A_stat_only">stat_only</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will only return the result of the applied stat function,
otherwise returns both the stat result and the result of the function on all parameters.</p>
</td></tr>
<tr><td><code id="ess_summary.emc_+3A_digits">digits</code></td>
<td>
<p>Integer. How many digits to round the output to</p>
</td></tr>
<tr><td><code id="ess_summary.emc_+3A_...">...</code></td>
<td>
<p>Optional additional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector of ESS values for the selected parameter type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ess_summary(samples_LNR, selection = "alpha")
</code></pre>

<hr>
<h2 id='fit.emc'>Model Estimation in EMC2</h2><span id='topic+fit.emc'></span><span id='topic+fit'></span>

<h3>Description</h3>

<p>General purpose function to estimate models specified in EMC2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
fit(
  emc,
  stage = NULL,
  iter = 1000,
  stop_criteria = NULL,
  report_time = TRUE,
  search_width = 1,
  step_size = 100,
  verbose = TRUE,
  verboseProgress = FALSE,
  fileName = NULL,
  particles = NULL,
  particle_factor = 50,
  cores_per_chain = 1,
  cores_for_chains = length(emc),
  max_tries = 20,
  thin_auto = FALSE,
  n_blocks = 1,
  ...
)

fit(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object created with <code>make_emc</code>,
or a path to where the emc object is stored.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_stage">stage</code></td>
<td>
<p>A string. Indicates which stage to start the run from, either <code>preburn</code>, <code>burn</code>, <code>adapt</code> or <code>sample</code>.
If unspecified, it will run the subsequent stage (if there is one).</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_iter">iter</code></td>
<td>
<p>An integer. Indicates how many iterations to run in the sampling stage.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_stop_criteria">stop_criteria</code></td>
<td>
<p>A list. Defines the stopping criteria and for which types
of parameters these should hold. See the details and examples section.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_report_time">report_time</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the time taken to run the MCMC chains till completion of the <code>stop_criteria</code> will be printed.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_search_width">search_width</code></td>
<td>
<p>A double. Tunes target acceptance probability of the MCMC process.
This fine-tunes the width of the search space to obtain the desired acceptance probability.
1 is the default width, increases lead to broader search.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_step_size">step_size</code></td>
<td>
<p>An integer. After each step, the stopping requirements as specified
by <code>stop_criteria</code> are checked and proposal distributions are updated. Defaults to 100.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to print messages between each step with the current status regarding the <code>stop_criteria</code>.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_verboseprogress">verboseProgress</code></td>
<td>
<p>Logical. Whether to print a progress bar within each step or not.
Will print one progress bar for each chain and only if <code>cores_for_chains = 1</code>.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_filename">fileName</code></td>
<td>
<p>A string. If specified, will auto-save emc object at this location on every iteration.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_particles">particles</code></td>
<td>
<p>An integer. How many particles to use, default is <code>NULL</code> and
<code>particle_factor</code> is used instead. If specified, <code>particle_factor</code> is overwritten.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_particle_factor">particle_factor</code></td>
<td>
<p>An integer. <code>particle_factor</code> multiplied by the square
root of the number of sampled parameters determines the number of particles used.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_cores_per_chain">cores_per_chain</code></td>
<td>
<p>An integer. How many cores to use per chain. Parallelizes across
participant calculations. Only available on Linux or Mac OS. For Windows, only
parallelization across chains (<code>cores_for_chains</code>) is available.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_cores_for_chains">cores_for_chains</code></td>
<td>
<p>An integer. How many cores to use across chains.
Defaults to the number of chains. The total number of cores used is equal to <code>cores_per_chain</code> * <code>cores_for_chains</code>.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_max_tries">max_tries</code></td>
<td>
<p>An integer. How many times should it try to meet the finish
conditions as specified by <code>stop_criteria</code>? Defaults to 20. <code>max_tries</code> is
ignored if the required number of iterations has not been reached yet.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_thin_auto">thin_auto</code></td>
<td>
<p>A boolean. If <code>TRUE</code> will automatically thin the MCMC samples, closely matched to the ESS.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_n_blocks">n_blocks</code></td>
<td>
<p>An integer. Number of blocks. Will block the parameter chains such that they are
updated in blocks. This can be helpful in extremely tough models with a large number of parameters.</p>
</td></tr>
<tr><td><code id="fit.emc_+3A_...">...</code></td>
<td>
<p>Additional optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stop_criteria</code> is either a list of lists with names of the stages,
or a single list in which case its assumed to be for the sample <code>stage</code> (see examples).
The potential stop criteria to be set are:
</p>
<p><code>selection</code> (character vector): For which parameters the <code>stop_criteria</code> should hold
</p>
<p><code>mean_gd</code> (numeric): The mean Gelman-Rubin diagnostic across all parameters in the selection
</p>
<p><code>max_gd</code> (numeric): The max Gelman-Rubin diagnostic across all parameters in the selection
</p>
<p><code>min_unique</code> (integer): The minimum number of unique samples in the MCMC chains across all parameters in the selection
</p>
<p><code>min_es</code> (integer): The minimum number of effective samples across all parameters in the selection
</p>
<p><code>omit_mpsrf</code> (Boolean): Whether to include the multivariate point-scale reduction factor in the Gelman-Rubin diagnostic. Default is <code>FALSE</code>.
</p>
<p><code>iter</code> (integer): The number of MCMC samples to collect.
</p>
<p>The estimation is performed using particle-metropolis within-Gibbs sampling.
For sampling details see:
</p>
<p>Gunawan, D., Hawkins, G. E., Tran, M.-N., Kohn, R., &amp; Brown, S. (2020).
New estimation approaches for the hierarchical linear ballistic accumulator model.
<em>Journal of Mathematical Psychology</em> ,96, 102368. doi.org/10.1016/j.jmp.2020.102368
</p>
<p>Stevenson, N., Donzallaz, M. C., Innes, R. J., Forstmann, B., Matzke, D., &amp; Heathcote, A. (2024).
EMC2: An R Package for cognitive models of choice. doi.org/10.31234/osf.io/2e4dq
</p>


<h3>Value</h3>

<p>An emc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First define a design
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# Then make the emc object, we've omitted a prior here for brevity so default priors will be used.
emc_forstmann &lt;- make_emc(forstmann, design_DDMaE)

# With the emc object we can start sampling by simply calling fit
emc_forstmann &lt;- fit(emc_forstmann, fileName = "intermediate_save_location.RData")

# For particularly hard models it pays off to increase the ``particle_factor``
# and, although to a lesser extent, increase ``search_width``.
emc_forstmann &lt;- fit(emc_forstmann, particle_factor = 100, search_width = 1.5)

# Example of how to use the stop_criteria:
emc_forstmann &lt;- fit(emc_forstmann, stop_criteria = list(mean_gd = 1.1, max_gd = 1.5,
            selection = c('alpha', 'sigma2'), omit_mpsrf = TRUE, min_es = 1000))
# In this case the stop_criteria are set for the sample stage, which will be
# run until the mean_gd &lt; 1.1, the max_gd &lt; 1.5 (omitting the multivariate psrf)
# and the effective sample size &gt; 1000,
# for both the individual-subject parameters ("alpha")
# and the group-level variance parameters.

# For the unspecified stages in the ``stop_criteria`` the default values
# are assumed which are found in Stevenson et al. 2024 &lt;doi.org/10.31234/osf.io/2e4dq&gt;

# Alternatively, you can also specify the stop_criteria for specific stages by creating a
# nested list
emc_forstmann &lt;- fit(emc_forstmann, stop_criteria = list("burn" = list(mean_gd = 1.1, max_gd = 1.5,
            selection = c('alpha')), "adapt" = list(min_unique = 100)))

## End(Not run)
</code></pre>

<hr>
<h2 id='forstmann'>Forstmann et al.'s Data</h2><span id='topic+forstmann'></span>

<h3>Description</h3>

<p>A dataset containing the speed or accuracy manipulation for a Random Dot
Motion experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forstmann
</code></pre>


<h3>Format</h3>

<p>A data frame with 15818 rows and 5 variables:
</p>

<dl>
<dt>E</dt><dd><p>Factor with 3 levels for Speed, Accuracy and
Neutral</p>
</dd>
<dt>R</dt><dd><p>Factor with 2 levels for Left and Right responses</p>
</dd>
<dt>S</dt><dd><p>Factor with 2 levels for Left and Right trials</p>
</dd>
<dt>rt</dt><dd><p>reaction time for each trial as a double</p>
</dd>
<dt>subjects</dt><dd><p>integer ID for each subject</p>
</dd>
</dl>



<h3>Details</h3>

<p>Details on the dataset can be found in the following paper:
</p>
<p><strong>Striatum and pre-SMA facilitate decision-making under time pressure</strong>
</p>
<p>Birte U. Forstmann, Gilles Dutilh, Scott Brown, Jane Neumann,
D. Yves von Cramon, K. Richard Ridderinkhof, Eric-Jan Wagenmakers.
</p>
<p><em>Proceedings of the National Academy of Sciences Nov 2008, 105 (45)
17538-17542; DOI: 10.1073/pnas.0805903105</em>
</p>


<h3>Source</h3>

<p><a href="https://www.pnas.org/doi/10.1073/pnas.0805903105">https://www.pnas.org/doi/10.1073/pnas.0805903105</a>
</p>

<hr>
<h2 id='gd_summary.emc'>Gelman-Rubin Statistic</h2><span id='topic+gd_summary.emc'></span><span id='topic+gd_summary'></span>

<h3>Description</h3>

<p>Returns the Gelman-Rubin diagnostics (otherwise known as the R-hat) of the selected parameter type;
i.e. the ratio of between to within MCMC chain variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
gd_summary(
  emc,
  selection = "mu",
  omit_mpsrf = TRUE,
  stat = "max",
  stat_only = FALSE,
  digits = 3,
  ...
)

gd_summary(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gd_summary.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_selection">selection</code></td>
<td>
<p>A Character vector. Indicates which parameter types to check (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_omit_mpsrf">omit_mpsrf</code></td>
<td>
<p>Boolean. If <code>TRUE</code> also returns the multivariate point scale reduction factor (see <code>?coda::gelman.diag</code>).</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_stat">stat</code></td>
<td>
<p>A string. Should correspond to a function that can be applied to a vector,
which will be performed on the vector/rows or columns of the matrix of the parameters</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_stat_only">stat_only</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will only return the result of the applied stat function,
otherwise returns both the stat result and the result of the function on all parameters.</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_digits">digits</code></td>
<td>
<p>Integer. How many digits to round the output to</p>
</td></tr>
<tr><td><code id="gd_summary.emc_+3A_...">...</code></td>
<td>
<p>Optional additional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See: Gelman, A and Rubin, DB (1992)
Inference from iterative simulation using multiple sequences, <em>Statistical Science</em>, 7, 457-511.
</p>
<p>Full range of possible samples manipulations described in <code>get_pars</code>.
</p>


<h3>Value</h3>

<p>A matrix or vector of R-hat values for the selected parameter type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gd_summary(samples_LNR, selection = "correlation", stat = "mean", flatten = TRUE)
</code></pre>

<hr>
<h2 id='get_BayesFactor'>Bayes Factors</h2><span id='topic+get_BayesFactor'></span>

<h3>Description</h3>

<p>returns the Bayes Factor for two models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_BayesFactor(MLL1, MLL2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_BayesFactor_+3A_mll1">MLL1</code></td>
<td>
<p>Numeric. Marginal likelihood of model 1. Obtained with <code>run_bridge_sampling()</code></p>
</td></tr>
<tr><td><code id="get_BayesFactor_+3A_mll2">MLL2</code></td>
<td>
<p>Numeric. Marginal likelihood of model 2. Obtained with <code>run_bridge_sampling()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The BayesFactor for model 1 over model 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Normally one would compare two different models
# Here we use two times the same model:
M1 &lt;- M0 &lt;- run_bridge_sampling(samples_LNR, both_splits = FALSE, cores_for_props = 1)
get_BayesFactor(M1, M0)

</code></pre>

<hr>
<h2 id='get_data.emc'>Get Data</h2><span id='topic+get_data.emc'></span><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Extracts data from an emc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
get_data(emc)

get_data(emc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data.emc_+3A_emc">emc</code></td>
<td>
<p>an emc object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>emc adds columns and rows to a dataframe in order to facilitate efficient likelihood calculations.
This function will return the data as provided originally.
</p>


<h3>Value</h3>

<p>A dataframe of the original data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_data(samples_LNR)
</code></pre>

<hr>
<h2 id='get_design.emc.prior'>Get Design</h2><span id='topic+get_design.emc.prior'></span><span id='topic+get_design.emc'></span><span id='topic+get_design'></span>

<h3>Description</h3>

<p>Extracts design from an emc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
get_design(x)

## S3 method for class 'emc'
get_design(x)

get_design(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_design.emc.prior_+3A_x">x</code></td>
<td>
<p>an <code>emc</code> or <code>emc.prior</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design with class emc.design
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_design(samples_LNR)
</code></pre>

<hr>
<h2 id='get_pars'>Filter/Manipulate Parameters from emc Object</h2><span id='topic+get_pars'></span>

<h3>Description</h3>

<p>Underlying function used in most plotting and object handling functions in
EMC2. Can for example be used to filter/thin a parameter type
(i.e, group-level means <code>mu</code>) and convert to an mcmc.list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pars(
  emc,
  selection = "mu",
  stage = get_last_stage(emc),
  thin = 1,
  filter = 0,
  map = FALSE,
  add_recalculated = FALSE,
  length.out = NULL,
  by_subject = FALSE,
  return_mcmc = TRUE,
  merge_chains = FALSE,
  subject = NULL,
  flatten = FALSE,
  remove_dup = FALSE,
  remove_constants = TRUE,
  use_par = NULL,
  type = NULL,
  true_pars = NULL,
  chain = NULL,
  covariates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pars_+3A_emc">emc</code></td>
<td>
<p>an emc object.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_selection">selection</code></td>
<td>
<p>A Character string. Indicates which parameter type to select (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="get_pars_+3A_stage">stage</code></td>
<td>
<p>A character string. Indicates from which sampling stage(s) to take the samples from (i.e. <code>preburn</code>, <code>burn</code>, <code>adapt</code>, <code>sample</code>)</p>
</td></tr>
<tr><td><code id="get_pars_+3A_thin">thin</code></td>
<td>
<p>An integer. By how much to thin the chains</p>
</td></tr>
<tr><td><code id="get_pars_+3A_filter">filter</code></td>
<td>
<p>Integer or numeric vector. If an integer is supplied, iterations
up until that integer are removed. If a vector is supplied, the iterations
within the range are kept.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_map">map</code></td>
<td>
<p>Boolean. If <code>TRUE</code> parameters will be mapped back to the cells of
the experimental design using the design matrices.
Otherwise the sampled parameters are returned.
Only works for <code>selection = mu</code> or <code>selection = alpha</code>.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_add_recalculated">add_recalculated</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will also add recalculated parameters,
such as b in the LBA (b = B + A; see <code>?LBA</code>), or z in the DDM z = Z*A (see <code>?DDM</code>)
only works when <code>map = TRUE</code></p>
</td></tr>
<tr><td><code id="get_pars_+3A_length.out">length.out</code></td>
<td>
<p>Integer. Alternatively to thinning, you can also select a
desired length of the MCMC chains, which will be thinned appropriately.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_by_subject">by_subject</code></td>
<td>
<p>Boolean. If <code>TRUE</code> for selections that include subject parameters (e.g. <code>alpha</code>),
plot/stats are organized by subject, otherwise by parameter.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_return_mcmc">return_mcmc</code></td>
<td>
<p>Boolean. If <code>TRUE</code> returns an mcmc.list object, otherwise a matrix/array with the parameter type.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_merge_chains">merge_chains</code></td>
<td>
<p>Boolean. If <code>TRUE</code> returns parameter type merged across chains.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_subject">subject</code></td>
<td>
<p>Integer (vector) or character (vector). If an integer will select the 'x'th subject(s),
if a character it should match subject names in the data which will be selected.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_flatten">flatten</code></td>
<td>
<p>Boolean. If <code>FALSE</code> for 3-dimensional samples (e.g., correlations: n-pars x n-pars x iterations).
organizes by the dimension containing parameter names, otherwise collapses names across the first and second dimension.
Does not apply for <code>selection = "alpha"</code></p>
</td></tr>
<tr><td><code id="get_pars_+3A_remove_dup">remove_dup</code></td>
<td>
<p>Boolean. If <code>TRUE</code> removes duplicate values from the samples. Automatically set to <code>TRUE</code> if <code>flatten = TRUE</code></p>
</td></tr>
<tr><td><code id="get_pars_+3A_remove_constants">remove_constants</code></td>
<td>
<p>Boolean. If <code>TRUE</code> removes constant values from the samples (e.g. 0s in the covariance matrix).</p>
</td></tr>
<tr><td><code id="get_pars_+3A_use_par">use_par</code></td>
<td>
<p>Character (vector). If specified, only these parameters are returned. Should match the parameter names
(i.e. these are collapsed when <code>flatten = TRUE</code> and use_par should also be collapsed names).</p>
</td></tr>
<tr><td><code id="get_pars_+3A_type">type</code></td>
<td>
<p>Character indicating the group-level model selected. Only necessary if sampler isn't specified.</p>
</td></tr>
<tr><td><code id="get_pars_+3A_true_pars">true_pars</code></td>
<td>
<p>Set of <code>true_parameters</code> can be specified to apply flatten or use_par on a set of true parameters</p>
</td></tr>
<tr><td><code id="get_pars_+3A_chain">chain</code></td>
<td>
<p>Integer. Which of the chain(s) to return</p>
</td></tr>
<tr><td><code id="get_pars_+3A_covariates">covariates</code></td>
<td>
<p>Only needed with <code>plot</code> for priors and covariates in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An mcmc.list object of the selected parameter types with the specified manipulations
</p>


<h3>Examples</h3>

<pre><code class='language-R'># E.g. get the group-level mean parameters mapped back to the design
get_pars(samples_LNR, stage = "sample", map = TRUE, selection = "mu")

# Or return the flattened correlation, with 10 iterations per chain
get_pars(samples_LNR, stage = "sample", selection = "correlation", flatten = TRUE, length.out = 10)
</code></pre>

<hr>
<h2 id='get_prior.emc'>Get Prior</h2><span id='topic+get_prior.emc'></span><span id='topic+get_prior'></span>

<h3>Description</h3>

<p>Extracts prior from an emc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
get_prior(emc)

get_prior(emc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_prior.emc_+3A_emc">emc</code></td>
<td>
<p>an emc object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prior with class emc.prior
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_prior(samples_LNR)
</code></pre>

<hr>
<h2 id='hypothesis.emc'>Within-Model Hypothesis Testing</h2><span id='topic+hypothesis.emc'></span><span id='topic+hypothesis'></span>

<h3>Description</h3>

<p>Approximates the Bayes factor for parameter effects using the savage-dickey ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
hypothesis(
  emc,
  parameter = NULL,
  H0 = 0,
  fun = NULL,
  selection = "mu",
  do_plot = TRUE,
  use_prior_lim = TRUE,
  N = 10000,
  prior_args = list(),
  ...
)

hypothesis(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hypothesis.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_parameter">parameter</code></td>
<td>
<p>A string. A parameter which you want to compare to H0. Will not be used if a FUN is specified.</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_h0">H0</code></td>
<td>
<p>An integer. The H0 value which you want to compare to</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_fun">fun</code></td>
<td>
<p>A function. Specifies an operation to be performed on the sampled or mapped parameters.</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_selection">selection</code></td>
<td>
<p>A Character string. Indicates which parameter type to use (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_do_plot">do_plot</code></td>
<td>
<p>Boolean. If <code>FALSE</code> will omit the prior-posterior plot and only return the savage-dickey ratio.</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_use_prior_lim">use_prior_lim</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will use xlimits based on prior density, otherwise based on posterior density.</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_n">N</code></td>
<td>
<p>Integer. How many prior samples to draw</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_prior_args">prior_args</code></td>
<td>
<p>A list. Optional additional arguments to be passed to plot.default for the plotting of the prior density (see <code>par()</code>)</p>
</td></tr>
<tr><td><code id="hypothesis.emc_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code>, <code>density</code>, or <code>plot.default</code> (see <code>par()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note this is different to the computation of the marginal deviance in <code>compare</code>
since it only considers the group level effect and not the whole model (i.e. subject-level parameters).
For details see: Wagenmakers, Lodewyckx, Kuriyal, &amp; Grasman (2010).
</p>


<h3>Value</h3>

<p>The Bayes factor for the hypothesis against H0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here the emc object has an effect parameter (e.g. m),
# that maps onto a certain hypothesis.
# The hypothesis here is that m is different from zero.
# We can test whether there's a group-level effect on m:
hypothesis(samples_LNR, parameter = "m")
# Alternatively we can also test whether two parameters differ from each other
mdiff &lt;- function(p)diff(p[c("m","m_lMd")])
hypothesis(samples_LNR,fun=mdiff)
</code></pre>

<hr>
<h2 id='init_chains'>Initialize Chains</h2><span id='topic+init_chains'></span>

<h3>Description</h3>

<p>Adds a set of start points to each chain. These start points are sampled from a user-defined multivariate
normal across subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_chains(
  emc,
  start_mu = NULL,
  start_var = NULL,
  particles = 1000,
  cores_per_chain = 1,
  cores_for_chains = length(emc)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_chains_+3A_emc">emc</code></td>
<td>
<p>An emc object made by <code>make_emc()</code></p>
</td></tr>
<tr><td><code id="init_chains_+3A_start_mu">start_mu</code></td>
<td>
<p>A vector. Mean of multivariate normal used in proposal distribution</p>
</td></tr>
<tr><td><code id="init_chains_+3A_start_var">start_var</code></td>
<td>
<p>A matrix. Variance covariance matrix of multivariate normal used in proposal distribution.
Smaller values will lead to less deviation around the mean.</p>
</td></tr>
<tr><td><code id="init_chains_+3A_particles">particles</code></td>
<td>
<p>An integer. Number of starting values</p>
</td></tr>
<tr><td><code id="init_chains_+3A_cores_per_chain">cores_per_chain</code></td>
<td>
<p>An integer. How many cores to use per chain. Parallelizes across participant calculations.</p>
</td></tr>
<tr><td><code id="init_chains_+3A_cores_for_chains">cores_for_chains</code></td>
<td>
<p>An integer. How many cores to use to parallelize across chains. Default is the number of chains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An emc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make a design and an emc object
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1),
                           constants=c(s=log(1)))

DDMaE &lt;- make_emc(forstmann, design_DDMaE)
# set up our mean starting points (same used across subjects).
mu &lt;- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
       t0=log(.2))
# Small variances to simulate start points from a tight range
var &lt;- diag(0.05, length(mu))
# Initialize chains, 4 cores per chain, and parallelizing across our 3 chains as well
# so 4*3 cores used.
DDMaE &lt;- init_chains(DDMaE, start_mu = mu, start_var = var,
                     cores_per_chain = 1, cores_for_chains = 1)
# Afterwards we can just use fit
# DDMaE &lt;- fit(DDMaE, cores_per_chain = 4)

</code></pre>

<hr>
<h2 id='LBA'>The Linear Ballistic Accumulator model</h2><span id='topic+LBA'></span>

<h3>Description</h3>

<p>Model file to estimate the Linear Ballistic Accumulator (LBA) in EMC2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LBA()
</code></pre>


<h3>Details</h3>

<p>Model files are almost exclusively used in <code>design()</code>.
</p>
<p>Default values are used for all parameters that are not explicitly listed in the <code>formula</code>
argument of <code>design()</code>.They can also be accessed with <code>LBA()$p_types</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Parameter</strong> </td><td style="text-align: left;"> <strong>Transform</strong> </td><td style="text-align: left;"> <strong>Natural scale</strong> </td><td style="text-align: left;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Mapping</strong> </td><td style="text-align: left;"> <strong>Interpretation</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>v</em> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> [-Inf, Inf] </td><td style="text-align: left;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: left;"> Mean evidence-accumulation rate </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>A</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Between-trial variation (range) in start point </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>B</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;"> <em>b</em> = <em>B</em>+<em>A</em> </td><td style="text-align: left;"> Distance from <em>A</em> to <em>b</em> (response threshold) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>t0</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Non-decision time </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>sv</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Between-trial variation in evidence-accumulation rate </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>All parameters are estimated on the log scale, except for the drift rate which is estimated on the real line.
</p>
<p>Conventionally, <code>sv</code> is fixed to 1 to satisfy scaling constraints.
</p>
<p>The <em>b</em> = <em>B</em> + <em>A</em> parameterization ensures that the response threshold is always higher than the between trial variation in start point of the drift rate.
</p>
<p>Because the LBA is a race model, it has one accumulator per response option.
EMC2 automatically constructs a factor representing the accumulators <code>lR</code> (i.e., the
latent response) with level names taken from the <code>R</code> column in the data.
</p>
<p>The <code>lR</code> factor is mainly used to allow for response bias, analogous to <code>Z</code> in the
DDM. For example, in the LBA, response thresholds are determined by the <em>B</em>
parameters, so <code>B~lR</code> allows for different thresholds for the accumulator
corresponding to left and right stimuli (e.g., a bias to respond left occurs
if the left threshold is less than the right threshold).
For race models, the <code>design()</code> argument <code>matchfun</code> can be provided, a
function that takes the <code>lR</code> factor (defined in the augmented data (d)
in the following function) and returns a logical defining the correct response.
In the example below, the match is simply such that the <code>S</code> factor equals the
latent response factor: <code>matchfun=function(d)d$S==d$lR</code>. Then <code>matchfun</code> is
used to automatically create a latent match (<code>lM</code>) factor with
levels <code>FALSE</code> (i.e., the stimulus does not match the accumulator) and <code>TRUE</code>
(i.e., the stimulus does match the accumulator). This is added internally
and can also be used in model formula, typically for parameters related to
the rate of accumulation.
</p>
<p>Brown, S. D., &amp; Heathcote, A. (2008). The simplest complete model of choice response time: Linear ballistic accumulation.
<em>Cognitive Psychology, 57</em>(3), 153-178. https://doi.org/10.1016/j.cogpsych.2007.12.002
</p>


<h3>Value</h3>

<p>A model list with all the necessary functions for EMC2 to sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat &lt;- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# We now construct our design, with v ~ lM and the contrast for lM the ADmat.
design_LBABE &lt;- design(data = forstmann,model=LBA,matchfun=matchfun,
                       formula=list(v~lM,sv~lM,B~E+lR,A~1,t0~1),
                       contrasts=list(v=list(lM=ADmat)),constants=c(sv=log(1)))
# For all parameters that are not defined in the formula, default values are assumed
# (see Table above).
</code></pre>

<hr>
<h2 id='LNR'>The Log-Normal Race Model</h2><span id='topic+LNR'></span>

<h3>Description</h3>

<p>Model file to estimate the Log-Normal Race Model (LNR) in EMC2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LNR()
</code></pre>


<h3>Details</h3>

<p>Model files are almost exclusively used in <code>design()</code>.
</p>
<p>Default values are used for all parameters that are not explicitly listed in the <code>formula</code>
argument of <code>design()</code>.They can also be accessed with <code>LNR()$p_types</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Parameter</strong> </td><td style="text-align: left;"> <strong>Transform</strong> </td><td style="text-align: left;"> <strong>Natural scale</strong> </td><td style="text-align: left;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Mapping</strong> </td><td style="text-align: left;"> <strong>Interpretation</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>m</em> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> [-Inf, Inf] </td><td style="text-align: left;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: left;"> Scale parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>s</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Shape parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>t0</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Non-decision time </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Because the LNR is a race model, it has one accumulator per response option.
EMC2 automatically constructs a factor representing the accumulators <code>lR</code> (i.e., the
latent response) with level names taken from the <code>R</code> column in the data.
</p>
<p>In <code>design()</code>, <code>matchfun</code> can be used to automatically create a latent match
(<code>lM</code>) factor with levels <code>FALSE</code> (i.e., the stimulus does not match the accumulator)
and <code>TRUE</code> (i.e., the stimulus does match the accumulator). This is added internally
and can also be used in the model formula, typically for parameters related to
the rate of accumulation (see the example below).
</p>
<p>Rouder, J. N., Province, J. M., Morey, R. D., Gomez, P., &amp; Heathcote, A. (2015).
The lognormal race: A cognitive-process model of choice and latency with
desirable psychometric properties. <em>Psychometrika, 80</em>, 491-513.
https://doi.org/10.1007/s11336-013-9396-3
</p>


<h3>Value</h3>

<p>A model list with all the necessary functions for EMC2 to sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat &lt;- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# We now construct our design, with v ~ lM and the contrast for lM the ADmat.
design_LNRmE &lt;- design(data = forstmann,model=LNR,matchfun=matchfun,
                       formula=list(m~lM + E,s~1,t0~1),
                       contrasts=list(m=list(lM=ADmat)))
# For all parameters that are not defined in the formula, default values are assumed
# (see Table above).
</code></pre>

<hr>
<h2 id='make_data'>Simulate Data</h2><span id='topic+make_data'></span>

<h3>Description</h3>

<p>Simulates data based on a model design and a parameter vector (<code>p_vector</code>) by one of two methods:
</p>

<ol>
<li><p> Creating a fully crossed and balanced design specified by the design,
with number of trials per cell specified by the <code>n_trials</code> argument
</p>
</li>
<li><p> Using the design of a data frame supplied, which allows creation
of unbalanced and other irregular designs, and replacing previous data with
simulated data
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>make_data(
  parameters,
  design = NULL,
  n_trials = NULL,
  data = NULL,
  expand = 1,
  mapped_p = FALSE,
  hyper = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_data_+3A_parameters">parameters</code></td>
<td>
<p>parameter vector used to simulate data.
Can also be a matrix with one row per subject (with corresponding row names)
or an emc object with sampled parameters
(in which case posterior medians of <code>alpha</code> are used to simulate data)</p>
</td></tr>
<tr><td><code id="make_data_+3A_design">design</code></td>
<td>
<p>Design list created by <code>design()</code></p>
</td></tr>
<tr><td><code id="make_data_+3A_n_trials">n_trials</code></td>
<td>
<p>Integer. If <code>data</code> is not supplied, number of trials to create per design cell</p>
</td></tr>
<tr><td><code id="make_data_+3A_data">data</code></td>
<td>
<p>Data frame. If supplied, the factors are taken from the data. Determines the number of trials per level of the design factors and can thus allow for unbalanced designs</p>
</td></tr>
<tr><td><code id="make_data_+3A_expand">expand</code></td>
<td>
<p>Integer. Replicates the <code>data</code> (if supplied) expand times to increase number of trials per cell.</p>
</td></tr>
<tr><td><code id="make_data_+3A_mapped_p">mapped_p</code></td>
<td>
<p>If <code>TRUE</code> instead returns a data frame with one row per design
cell and columns for each parameter specifying how they are mapped to the design cells.</p>
</td></tr>
<tr><td><code id="make_data_+3A_hyper">hyper</code></td>
<td>
<p>If <code>TRUE</code> the supplied parameters must be a set of samples, from which the group-level will be used to generate subject level parameters.
See also <code>make_random_effects</code> to generate subject-level parameters from a hyper distribution.</p>
</td></tr>
<tr><td><code id="make_data_+3A_...">...</code></td>
<td>
<p>Additional optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create data for multiple subjects see <code>?make_random_effects()</code>.
</p>


<h3>Value</h3>

<p>A data frame with simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create a design
design_DDMaE &lt;- design(factors = list(S = c("left", "right"),
                                           E = c("SPD", "ACC"),
                                           subjects = 1:30),
                            Rlevels = c("left", "right"), model = DDM,
                            formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                            constants=c(s=log(1)))
# Then create a p_vector:
parameters &lt;- c(v_Sleft=-2,v_Sright=2,a=log(1),a_EACC=log(2), t0=log(.2),
              Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))

# Now we can simulate data
data &lt;- make_data(parameters, design_DDMaE, n_trials = 30)

# We can also simulate data based on a specific dataset
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                            formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                            constants=c(s=log(1)))
parameters &lt;- c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
              t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))

data &lt;- make_data(parameters, design_DDMaE, data = forstmann)
</code></pre>

<hr>
<h2 id='make_emc'>Make an emc Object</h2><span id='topic+make_emc'></span>

<h3>Description</h3>

<p>Creates an emc object by combining the data, prior,
and model specification into a <code>emc</code> object that is needed in <code>fit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_emc(
  data,
  design,
  model = NULL,
  type = "standard",
  n_chains = 3,
  compress = TRUE,
  rt_resolution = 0.02,
  prior_list = NULL,
  par_groups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_emc_+3A_data">data</code></td>
<td>
<p>A data frame, or a list of data frames. Needs to have the variable <code>subjects</code> as participant identifier.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_design">design</code></td>
<td>
<p>A list with a pre-specified design, the output of <code>design()</code>.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_model">model</code></td>
<td>
<p>A model list. If none is supplied, the model specified in <code>design()</code> is used.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_type">type</code></td>
<td>
<p>A string indicating whether to run a <code>standard</code> group-level, <code>blocked</code>, <code>diagonal</code>, <code>factor</code>, or <code>single</code> (i.e., non-hierarchical) model.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_n_chains">n_chains</code></td>
<td>
<p>An integer. Specifies the number of mcmc chains to be run (has to be more than 1 to compute <code>rhat</code>).</p>
</td></tr>
<tr><td><code id="make_emc_+3A_compress">compress</code></td>
<td>
<p>A Boolean, if <code>TRUE</code> (i.e., the default), the data is compressed to speed up likelihood calculations.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_rt_resolution">rt_resolution</code></td>
<td>
<p>A double. Used for compression, response times will be binned based on this resolution.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_prior_list">prior_list</code></td>
<td>
<p>A named list containing the prior. Default prior created if <code>NULL</code>. For the default priors, see <code style="white-space: pre;">&#8288;?get_prior_{type}&#8288;</code>.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_par_groups">par_groups</code></td>
<td>
<p>A vector. Only to be specified with type <code>blocked</code>, e.g., <code>c(1,1,1,2,2)</code> means the covariances
of the first three and of the last two parameters are estimated as two separate blocks.</p>
</td></tr>
<tr><td><code id="make_emc_+3A_...">...</code></td>
<td>
<p>Additional, optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An uninitialized emc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- forstmann

# function that takes the lR factor (named diff in the following function) and
# returns a logical defining the correct response for each stimulus. In this
# case the match is simply such that the S factor equals the latent response factor.
matchfun &lt;- function(d)d$S==d$lR

# design an "average and difference" contrast matrix
ADmat &lt;- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))

# specify design
design_LBABE &lt;- design(data = dat,model=LBA,matchfun=matchfun,
formula=list(v~lM,sv~lM,B~E+lR,A~1,t0~1),
contrasts=list(v=list(lM=ADmat)),constants=c(sv=log(1)))

# specify priors
pmean &lt;- c(v=1,v_lMdiff=1,sv_lMTRUE=log(.5), B=log(.5),B_Eneutral=log(1.5),
           B_Eaccuracy=log(2),B_lRright=0, A=log(0.25),t0=log(.2))
psd &lt;- c(v=1,v_lMdiff=0.5,sv_lMTRUE=.5,
         B=0.3,B_Eneutral=0.3,B_Eaccuracy=0.3,B_lRright=0.3,A=0.4,t0=.5)
prior_LBABE &lt;- prior(design_LBABE, type = 'standard',pmean=pmean,psd=psd)

# create emc object
LBABE &lt;- make_emc(dat,design_LBABE,type="standard",  prior=prior_LBABE)

</code></pre>

<hr>
<h2 id='make_random_effects'>Generate Subject-Level Parameters</h2><span id='topic+make_random_effects'></span>

<h3>Description</h3>

<p>Simulates subject-level parameters in the format required by <code>make_data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_random_effects(
  design,
  group_means,
  n_subj = NULL,
  variance_proportion = 0.2,
  covariances = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_random_effects_+3A_design">design</code></td>
<td>
<p>A design list. The design as specified by <code>design()</code></p>
</td></tr>
<tr><td><code id="make_random_effects_+3A_group_means">group_means</code></td>
<td>
<p>A numeric vector. The group level means for each parameter, in the same order as <code>sampled_pars(design)</code></p>
</td></tr>
<tr><td><code id="make_random_effects_+3A_n_subj">n_subj</code></td>
<td>
<p>An integer. The number of subjects to generate parameters for. If <code>NULL</code> will be inferred from design</p>
</td></tr>
<tr><td><code id="make_random_effects_+3A_variance_proportion">variance_proportion</code></td>
<td>
<p>A double. Optional. If <code>covariances</code> are not specified, the variances will be created by multiplying the means by this number. The covariances will be 0.</p>
</td></tr>
<tr><td><code id="make_random_effects_+3A_covariances">covariances</code></td>
<td>
<p>A covariance matrix. Optional. Specify the intended covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of subject-level parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First create a design
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                            formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                            constants=c(s=log(1)))
# Then create a group-level means vector:
group_means =c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
               t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
# Now we can create subject-level parameters
subj_pars &lt;- make_random_effects(design_DDMaE, group_means, n_subj = 19)

# We can also define a covariance matrix to simulate from
subj_pars &lt;- make_random_effects(design_DDMaE, group_means, n_subj = 19,
             covariances = diag(.1, length(group_means)))

# The subject level parameters can be used to generate data
make_data(subj_pars, design_DDMaE, n_trials = 10)
</code></pre>

<hr>
<h2 id='mapped_pars'>Parameter Mapping Back to the Design Factors</h2><span id='topic+mapped_pars'></span><span id='topic+mapped_pars.emc.design'></span><span id='topic+mapped_pars.emc.prior'></span><span id='topic+mapped_pars.emc'></span>

<h3>Description</h3>

<p>Maps parameters of the cognitive model back to the experimental design. If p_vector
is left unspecified will print a textual description of the mapping.
Otherwise the p_vector can be created using <code>sampled_pars()</code>.
The returned matrix shows whether/how parameters
differ across the experimental factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapped_pars(
  x,
  p_vector = NULL,
  model = NULL,
  digits = 3,
  remove_subjects = TRUE,
  covariates = NULL,
  ...
)

## S3 method for class 'emc.design'
mapped_pars(
  x,
  p_vector = NULL,
  model = NULL,
  digits = 3,
  remove_subjects = TRUE,
  covariates = NULL,
  ...
)

## S3 method for class 'emc.prior'
mapped_pars(
  x,
  p_vector = NULL,
  model = NULL,
  digits = 3,
  remove_subjects = TRUE,
  covariates = NULL,
  ...
)

## S3 method for class 'emc'
mapped_pars(
  x,
  p_vector = NULL,
  model = NULL,
  digits = 3,
  remove_subjects = TRUE,
  covariates = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapped_pars_+3A_x">x</code></td>
<td>
<p>an <code>emc</code>, <code>emc.prior</code> or <code>emc.design</code> object</p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_p_vector">p_vector</code></td>
<td>
<p>Optional. Specify parameter vector to get numeric mappings.
Must be in the form of <code>sampled_pars(design)</code></p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_model">model</code></td>
<td>
<p>Optional model type (if not already specified in <code>design</code>)</p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_digits">digits</code></td>
<td>
<p>Integer. Will round the output parameter values to this many decimals</p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_remove_subjects">remove_subjects</code></td>
<td>
<p>Boolean. Whether to include subjects as a factor in the design</p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_covariates">covariates</code></td>
<td>
<p>Covariates specified in the design can be included here.</p>
</td></tr>
<tr><td><code id="mapped_pars_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with a column for each factor in the design and for   each model parameter type (<code>p_type</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First define a design:
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
mapped_pars(design_DDMaE)
# Then create a p_vector:
p_vector=c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
          t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
# This will map the parameters of the p_vector back to the design
mapped_pars(design_DDMaE, p_vector)

</code></pre>

<hr>
<h2 id='merge_chains'>Merge Samples</h2><span id='topic+merge_chains'></span>

<h3>Description</h3>

<p>Merges samples from all chains as one unlisted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_chains(emc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_chains_+3A_emc">emc</code></td>
<td>
<p>An emc object, commonly the output of <code>fit()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all sampling stages are included in the merged output,
including iterations from the <code>preburn</code>, <code>burn</code>, and <code>adapt</code> stages.
<code>merge_chains(emc)$samples$stage</code> shows the corresponding sampling stages.
</p>


<h3>Value</h3>

<p>An unlisted emc object with all chains merged
</p>

<hr>
<h2 id='model_averaging'>Model Averaging</h2><span id='topic+model_averaging'></span>

<h3>Description</h3>

<p>Computes model weights and a Bayes factor by comparing two groups of models based on their
Information Criterion (IC) values. The function works with either numeric vectors or data
frames containing multiple IC measures (e.g., MD, BPIC, DIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_averaging(IC_for, IC_against)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_averaging_+3A_ic_for">IC_for</code></td>
<td>
<p>A numeric vector or the output of <code>compare</code></p>
</td></tr>
<tr><td><code id="model_averaging_+3A_ic_against">IC_against</code></td>
<td>
<p>A numeric vector or the output of <code>compare</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When provided with numeric vectors, it computes the weights for the two groups by first
converting the IC values into relative weights and then normalizing them. When provided with
a data frame, it assumes that the data frame is the output of a call to <code>compare</code>
and applies averaging to each IC metric
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns:
</p>

<dl>
<dt><code>wFor</code></dt><dd><p>The aggregated weight of the models in favor.</p>
</dd>
<dt><code>wAgainst</code></dt><dd><p>The aggregated weight of the models against.</p>
</dd>
<dt><code>Factor</code></dt><dd><p>The Bayes factor (ratio of <code>wFor</code> to <code>wAgainst</code>).</p>
</dd>
</dl>

<p>If <code>IC_for</code> is a data frame, a matrix with rows corresponding to each IC measure is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First set up some example models (normally these would be alternative models)
samples_LNR2 &lt;- subset(samples_LNR, length.out = 45)
samples_LNR3 &lt;- subset(samples_LNR, length.out = 40)
samples_LNR4 &lt;- subset(samples_LNR, length.out = 35)

# Run compare on them, BayesFactor = F is set for speed.
ICs &lt;- compare(list(S1 = samples_LNR, S2 = samples_LNR2,
                    S3 = samples_LNR3, S4 = samples_LNR4), BayesFactor = FALSE)

# Model averaging can either be done with a vector of ICs:
model_averaging(ICs$BPIC[1:2], ICs$BPIC[2:4])

# Or the output of compare:
model_averaging(ICs[1:2,], ICs[3:4,])

</code></pre>

<hr>
<h2 id='pairs_posterior'>Plot Within-Chain Correlations</h2><span id='topic+pairs_posterior'></span>

<h3>Description</h3>

<p>Plots within-chain parameter correlations (upper triangle) and corresponding
scatterplots (lower triangle) to visualize parameter sloppiness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_posterior(
  emc,
  selection = "alpha",
  scale_subjects = TRUE,
  do_plot = TRUE,
  N = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs_posterior_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="pairs_posterior_+3A_selection">selection</code></td>
<td>
<p>A Character string. Indicates which parameter type to
plot (<code>alpha</code>, <code>mu</code>, <code>variance</code>, <code>covariance</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="pairs_posterior_+3A_scale_subjects">scale_subjects</code></td>
<td>
<p>Boolean. To standardize each participant with <code>selection = "alpha"</code>,
by subtracting the mean and divding by the standard deviation. This ensures the plot has every participant on the same scale.</p>
</td></tr>
<tr><td><code id="pairs_posterior_+3A_do_plot">do_plot</code></td>
<td>
<p>Boolean. Whether to plot the pairs plot, if <code>FALSE</code>, only the correlations
are returned.</p>
</td></tr>
<tr><td><code id="pairs_posterior_+3A_n">N</code></td>
<td>
<p>Integer for maximum number of iterations used (defaults to 500).
If number of samples in stage or selection exceeds N, a random subset will be taken of size N</p>
</td></tr>
<tr><td><code id="pairs_posterior_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>selection = alpha</code> the parameter chains are concatenated across participants,
(after standardizing if <code>scale_subjects = TRUE</code>) and then correlated.
</p>


<h3>Value</h3>

<p>Invisibly returns a matrix with the correlations between the parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot the sloppiness for the individual-level subjects
pairs_posterior(samples_LNR, selection = "alpha")

# We can also choose group-level parameters and subsets of the parameter space 
pairs_posterior(samples_LNR, use_par = c("m", "t0"), selection = "sigma2")

</code></pre>

<hr>
<h2 id='parameters.emc.prior'>Return Data Frame of Parameters</h2><span id='topic+parameters.emc.prior'></span><span id='topic+parameters.emc'></span><span id='topic+parameters'></span>

<h3>Description</h3>

<p>Return Data Frame of Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
parameters(x, selection = "mu", N = 1000, covariates = NULL, ...)

## S3 method for class 'emc'
parameters(x, selection = "mu", N = NULL, resample = FALSE, ...)

parameters(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameters.emc.prior_+3A_x">x</code></td>
<td>
<p>An emc or emc.prior object</p>
</td></tr>
<tr><td><code id="parameters.emc.prior_+3A_selection">selection</code></td>
<td>
<p>String designating parameter type (e.g. mu, sigma2, correlation, alpha)</p>
</td></tr>
<tr><td><code id="parameters.emc.prior_+3A_n">N</code></td>
<td>
<p>Integer. How many samples to take from the posterior/prior. If <code>NULL</code> will return the full posterior</p>
</td></tr>
<tr><td><code id="parameters.emc.prior_+3A_covariates">covariates</code></td>
<td>
<p>For priors, possible covariates in the design</p>
</td></tr>
<tr><td><code id="parameters.emc.prior_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
<tr><td><code id="parameters.emc.prior_+3A_resample">resample</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will sample N samples from the posterior with replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each sample
(with a subjects column if selection = &quot;alpha&quot; and using draws from the posterior)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For prior inference:
# First set up a prior
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                       formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                       constants=c(s=log(1)))
# Then set up a prior using make_prior
p_vector=c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
           t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
psd &lt;- c(v_Sleft=1,v_Sright=1,a=.3,a_Eneutral=.3,a_Eaccuracy=.3,
         t0=.4,Z=1,sv=.4,SZ=1)
# Here we left the variance prior at default
prior_DDMaE &lt;- prior(design_DDMaE,mu_mean=p_vector,mu_sd=psd)
# Get our prior samples
parameters(prior_DDMaE, N = 100)
# For posterior inference:
# Get 100 samples of the group-level mean (the default)
parameters(samples_LNR, N = 100)
# or from the individual-level parameters and mapped
parameters(samples_LNR, selection = "alpha", map = TRUE)
</code></pre>

<hr>
<h2 id='plot_cdf'>Plot Defective Cumulative Distribution Functions</h2><span id='topic+plot_cdf'></span>

<h3>Description</h3>

<p>Plots panels of cumulative distribution functions (CDFs) for each level of the specified
defective factor in the data. The CDFs are <em>defective</em>; each factor level's CDF
scales only up to that level's proportion. Summed across levels, the maximum is 1.
Optionally, posterior and/or prior predictive CDFs can be overlaid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cdf(
  input,
  post_predict = NULL,
  prior_predict = NULL,
  subject = NULL,
  quants = c(0.025, 0.975),
  functions = NULL,
  factors = NULL,
  defective_factor = "R",
  n_cores = 1,
  n_post = 50,
  layout = NA,
  to_plot = c("data", "posterior", "prior")[1:2],
  use_lim = c("data", "posterior", "prior")[1:2],
  legendpos = c("top", "topright"),
  posterior_args = list(),
  prior_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cdf_+3A_input">input</code></td>
<td>
<p>Either an <code>emc</code> object or a data frame, or a <em>list</em> of such objects.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_post_predict">post_predict</code></td>
<td>
<p>Optional posterior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_prior_predict">prior_predict</code></td>
<td>
<p>Optional prior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_subject">subject</code></td>
<td>
<p>Subset the data to a single subject (by index or name).</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_quants">quants</code></td>
<td>
<p>Numeric vector of credible interval bounds (e.g. <code>c(0.025, 0.975)</code>).</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_functions">functions</code></td>
<td>
<p>A function (or list of functions) that create new columns in the datasets or predictives</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_factors">factors</code></td>
<td>
<p>Character vector of factor names to aggregate over;
defaults to plotting full data set ungrouped by factors if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_defective_factor">defective_factor</code></td>
<td>
<p>Name of the factor used for the defective CDF (default &quot;R&quot;).</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of CPU cores to use if generating predictives from an <code>emc</code> object.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_n_post">n_post</code></td>
<td>
<p>Number of posterior draws to simulate if needed for predictives.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_layout">layout</code></td>
<td>
<p>Numeric vector used in <code>par(mfrow=...)</code>; use <code>NA</code> for auto-layout.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_to_plot">to_plot</code></td>
<td>
<p>Character vector: any of <code>"data"</code>, <code>"posterior"</code>, <code>"prior"</code>.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_use_lim">use_lim</code></td>
<td>
<p>Character vector controlling which source(s) define <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_legendpos">legendpos</code></td>
<td>
<p>Character vector controlling the positions of the legends</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_posterior_args">posterior_args</code></td>
<td>
<p>Optional list of graphical parameters for posterior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_prior_args">prior_args</code></td>
<td>
<p>Optional list of graphical parameters for prior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_cdf_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for the real data lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot defective CDF for data only
# plot_cdf(forstmann, to_plot = "data")
#
# Plot with posterior predictions
# plot_cdf(samples_LNR, to_plot = c("data","posterior"), n_post=10)
#
# Or a list of multiple emc objects ...
</code></pre>

<hr>
<h2 id='plot_density'>Plot Defective Densities</h2><span id='topic+plot_density'></span>

<h3>Description</h3>

<p>Plots panels that contain a set of densities for each level of the specified defective factor in the data.
These densities are defective; their areas are relative to the respective
proportions of the defective factor levels. Across all levels, the area sums to 1.
Optionally, posterior/prior predictive densities can be overlaid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_density(
  input,
  post_predict = NULL,
  prior_predict = NULL,
  subject = NULL,
  quants = c(0.025, 0.975),
  functions = NULL,
  factors = NULL,
  defective_factor = "R",
  n_cores = 1,
  n_post = 50,
  layout = NA,
  to_plot = c("data", "posterior", "prior")[1:2],
  use_lim = c("data", "posterior", "prior")[1:2],
  legendpos = c("topright", "top"),
  posterior_args = list(),
  prior_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_density_+3A_input">input</code></td>
<td>
<p>Either an <code>emc</code> object or a data frame, or a <em>list</em> of such objects.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_post_predict">post_predict</code></td>
<td>
<p>Optional posterior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_prior_predict">prior_predict</code></td>
<td>
<p>Optional prior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_subject">subject</code></td>
<td>
<p>Subset the data to a single subject (by index or name).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_quants">quants</code></td>
<td>
<p>Numeric vector of credible interval bounds (e.g. <code>c(0.025, 0.975)</code>).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_functions">functions</code></td>
<td>
<p>A function (or list of functions) that create new columns in the datasets or predictives</p>
</td></tr>
<tr><td><code id="plot_density_+3A_factors">factors</code></td>
<td>
<p>Character vector of factor names to aggregate over;
defaults to plotting full data set ungrouped by factors if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_defective_factor">defective_factor</code></td>
<td>
<p>Name of the factor used for the defective CDF (default &quot;R&quot;).</p>
</td></tr>
<tr><td><code id="plot_density_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of CPU cores to use if generating predictives from an <code>emc</code> object.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_n_post">n_post</code></td>
<td>
<p>Number of posterior draws to simulate if needed for predictives.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_layout">layout</code></td>
<td>
<p>Numeric vector used in <code>par(mfrow=...)</code>; use <code>NA</code> for auto-layout.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_to_plot">to_plot</code></td>
<td>
<p>Character vector: any of <code>"data"</code>, <code>"posterior"</code>, <code>"prior"</code>.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_use_lim">use_lim</code></td>
<td>
<p>Character vector controlling which source(s) define <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_legendpos">legendpos</code></td>
<td>
<p>Character vector controlling the positions of the legends</p>
</td></tr>
<tr><td><code id="plot_density_+3A_posterior_args">posterior_args</code></td>
<td>
<p>Optional list of graphical parameters for posterior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_prior_args">prior_args</code></td>
<td>
<p>Optional list of graphical parameters for prior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_density_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for the real data lines.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plot defective densities for each subject and the factor combination in the design:
plot_density(forstmann)
# or for one subject:
plot_density(forstmann, subject = 1)
# Now collapsing across subjects and using a different defective factor:
plot_density(forstmann, factors = "S", defective_factor = "E")
# Or plot posterior predictives
plot_density(samples_LNR, n_post = 10)
</code></pre>

<hr>
<h2 id='plot_design.emc.design'>Plot Design</h2><span id='topic+plot_design.emc.design'></span><span id='topic+plot_design.emc.prior'></span><span id='topic+plot_design'></span><span id='topic+plot_design.emc'></span>

<h3>Description</h3>

<p>Makes design illustration by plotting simulated data based on the design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.design'
plot_design(
  x,
  data = NULL,
  factors = NULL,
  plot_factor = NULL,
  n_data_sim = 10,
  p_vector = NULL,
  functions = NULL,
  ...
)

## S3 method for class 'emc.prior'
plot_design(
  x,
  data = NULL,
  factors = NULL,
  plot_factor = NULL,
  n_data_sim = 10,
  p_vector = NULL,
  functions = NULL,
  ...
)

plot_design(
  x,
  data = NULL,
  factors = NULL,
  plot_factor = NULL,
  n_data_sim = 10,
  p_vector = NULL,
  functions = NULL,
  ...
)

## S3 method for class 'emc'
plot_design(
  x,
  data = NULL,
  factors = NULL,
  plot_factor = NULL,
  n_data_sim = 10,
  p_vector = NULL,
  functions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_design.emc.design_+3A_x">x</code></td>
<td>
<p>An <code>emc</code> or <code>emc.prior</code> object containing the design to plot</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_data">data</code></td>
<td>
<p>Optional data to overlay on the design plot</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_factors">factors</code></td>
<td>
<p>Factors to use for varying parameters</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_plot_factor">plot_factor</code></td>
<td>
<p>Optional. Make separate plots for each level of this factor</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_n_data_sim">n_data_sim</code></td>
<td>
<p>If data is provided, number of simulated datasets to generate for the plot. Default is 10.</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_p_vector">p_vector</code></td>
<td>
<p>Only needed when x is an <code>emc.design</code> object, which parameters to use for data generation.</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_functions">functions</code></td>
<td>
<p>A named list of functions that create additional columns in the data.</p>
</td></tr>
<tr><td><code id="plot_design.emc.design_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>make_design_plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Just plots the design
</p>

<hr>
<h2 id='plot_pars'>Plots Density for Parameters</h2><span id='topic+plot_pars'></span>

<h3>Description</h3>

<p>Plots the posterior and prior density for selected parameters of a model.
Full range of samples manipulations described in <code>get_pars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pars(
  emc,
  layout = NA,
  selection = "mu",
  show_chains = FALSE,
  plot_prior = TRUE,
  N = 10000,
  use_prior_lim = !all_subjects,
  lpos = "topright",
  true_pars = NULL,
  all_subjects = FALSE,
  prior_args = list(),
  true_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pars_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_layout">layout</code></td>
<td>
<p>A vector indicating which layout to use as in par(mfrow = layout). If NA, will automatically generate an appropriate layout.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_selection">selection</code></td>
<td>
<p>A Character string. Indicates which parameter type to use (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_show_chains">show_chains</code></td>
<td>
<p>Boolean (defaults to <code>FALSE</code>) plots a separate density for each chain.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_plot_prior">plot_prior</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will overlay prior density in the plot (default in red)</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_n">N</code></td>
<td>
<p>Integer. How many prior samples to draw</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_use_prior_lim">use_prior_lim</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will use xlimits based on prior density, otherwise based on posterior density.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_lpos">lpos</code></td>
<td>
<p>Character. Where to plot the contraction statistic.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_true_pars">true_pars</code></td>
<td>
<p>A vector or emc object. Can be used to visualize recovery.
If a vector will plot a vertical line for each parameter at the appropriate place.
If an emc object will plot the densities of the object as well, assumed to be the data-generating posteriors.</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_all_subjects">all_subjects</code></td>
<td>
<p>Boolean. Will plot the densities of all (selected) subjects overlaid with the group-level distribution</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_prior_args">prior_args</code></td>
<td>
<p>A list. Optional additional arguments to be passed to plot.default for the plotting of the prior density (see <code>par()</code>)</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_true_args">true_args</code></td>
<td>
<p>A list. Optional additional arguments to be passed to plot.default for the plotting of the true parameters (see <code>par()</code>)</p>
</td></tr>
<tr><td><code id="plot_pars_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code>, <code>density</code>, or <code>plot.default</code> (see <code>par()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible return of the contraction statistics for the selected parameter type
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Full range of possibilities described in get_pars
plot_pars(samples_LNR)
# Or plot all subjects
plot_pars(samples_LNR, all_subjects = TRUE, col = 'purple')
# Or plot recovery
true_emc &lt;- samples_LNR # This would normally be the data-generating samples
plot_pars(samples_LNR, true_pars = true_emc, true_args = list(col = 'blue'), adjust = 2)
</code></pre>

<hr>
<h2 id='plot_relations'>Plot Group-Level Relations</h2><span id='topic+plot_relations'></span>

<h3>Description</h3>

<p>An adjusted version of the <code>corrplot</code> package function <code>corrplot()</code> tailored
to <code>EMC2</code> and the plotting of estimated correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_relations(
  emc = NULL,
  stage = "sample",
  plot_cred = TRUE,
  plot_means = TRUE,
  only_cred = FALSE,
  nice_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_relations_+3A_emc">emc</code></td>
<td>
<p>An EMC2 object, commonly the output of <code>run_emc()</code>.</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_stage">stage</code></td>
<td>
<p>Character. The stage from which to take the samples, defaults to
the sampling stage <code>sample</code>.</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_plot_cred">plot_cred</code></td>
<td>
<p>Boolean. Whether to plot the 95 percent credible intervals or not</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_plot_means">plot_means</code></td>
<td>
<p>Boolean. Whether to plot the means or not</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_only_cred">only_cred</code></td>
<td>
<p>Boolean. Whether to only plot credible values</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_nice_names">nice_names</code></td>
<td>
<p>Character string. Alternative names to give the parameters</p>
</td></tr>
<tr><td><code id="plot_relations_+3A_...">...</code></td>
<td>
<p>Optional additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, creates a plot of group-level relations
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a given set of hierarchical model samples we can make a
# correlation matrix plot.
plot_relations(samples_LNR, only_cred = TRUE, plot_cred = TRUE)
# We can also only plot the correlations where the credible interval does not include zero
plot_relations(samples_LNR, plot_means = TRUE, only_cred = TRUE)

</code></pre>

<hr>
<h2 id='plot_sbc_ecdf'>Plot the ECDF Difference in SBC Ranks</h2><span id='topic+plot_sbc_ecdf'></span>

<h3>Description</h3>

<p>Plots the difference in observed cumulative rank statistics and the
expected cumulative distribution of a uniform distribution. The blue
shaded areas indicate the 95% credible interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sbc_ecdf(ranks, layout = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sbc_ecdf_+3A_ranks">ranks</code></td>
<td>
<p>A list of named dataframes of the rank statistic</p>
</td></tr>
<tr><td><code id="plot_sbc_ecdf_+3A_layout">layout</code></td>
<td>
<p>Optional. A numeric vector specifying the layout using <code>par(mfrow = layout)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returns
</p>

<hr>
<h2 id='plot_sbc_hist'>Plot the Histogram of the Observed Rank Statistics of SBC</h2><span id='topic+plot_sbc_hist'></span>

<h3>Description</h3>

<p>Note that this plot is dependent on the number of bins, and a more general
visualization is to use <code>plot_sbc_ecdf</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sbc_hist(ranks, bins = 10, layout = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sbc_hist_+3A_ranks">ranks</code></td>
<td>
<p>A list of named dataframes of the rank statistic</p>
</td></tr>
<tr><td><code id="plot_sbc_hist_+3A_bins">bins</code></td>
<td>
<p>An integer specifying the number of bins to use when plotting the histogram</p>
</td></tr>
<tr><td><code id="plot_sbc_hist_+3A_layout">layout</code></td>
<td>
<p>Optional. A numeric vector specifying the layout using <code>par(mfrow = layout)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returns
</p>

<hr>
<h2 id='plot_stat'>Plot Statistics on Data</h2><span id='topic+plot_stat'></span>

<h3>Description</h3>

<p>Plots panels that contain a set of densities for each level of the specified <code>factor</code>
The densities represent the predicted data across the posterior, the vertical lines represent the real data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_stat(
  input,
  post_predict = NULL,
  prior_predict = NULL,
  stat_fun,
  stat_name = NULL,
  subject = NULL,
  factors = NULL,
  n_cores = 1,
  n_post = 50,
  quants = c(0.025, 0.5, 0.975),
  functions = NULL,
  layout = NA,
  to_plot = c("data", "posterior", "prior")[1:2],
  use_lim = c("data", "posterior", "prior")[1:2],
  legendpos = c("topleft", "top"),
  posterior_args = list(),
  prior_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_stat_+3A_input">input</code></td>
<td>
<p>Either an <code>emc</code> object or a data frame, or a <em>list</em> of such objects.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_post_predict">post_predict</code></td>
<td>
<p>Optional posterior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_prior_predict">prior_predict</code></td>
<td>
<p>Optional prior predictive data (matching columns) or <em>list</em> thereof.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_stat_fun">stat_fun</code></td>
<td>
<p>A function that can be applied to the data and returns a single value or a vector of values.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_stat_name">stat_name</code></td>
<td>
<p>The name of the calculated quantity</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_subject">subject</code></td>
<td>
<p>Subset the data to a single subject (by index or name).</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_factors">factors</code></td>
<td>
<p>Character vector of factor names to aggregate over;
defaults to plotting full data set ungrouped by factors if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of CPU cores to use if generating predictives from an <code>emc</code> object.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_n_post">n_post</code></td>
<td>
<p>Number of posterior draws to simulate if needed for predictives.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_quants">quants</code></td>
<td>
<p>Numeric vector of credible interval bounds (e.g. <code>c(0.025, 0.975)</code>).</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_functions">functions</code></td>
<td>
<p>A function (or list of functions) that create new columns in the datasets or predictives</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_layout">layout</code></td>
<td>
<p>Numeric vector used in <code>par(mfrow=...)</code>; use <code>NA</code> for auto-layout.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_to_plot">to_plot</code></td>
<td>
<p>Character vector: any of <code>"data"</code>, <code>"posterior"</code>, <code>"prior"</code>.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_use_lim">use_lim</code></td>
<td>
<p>Character vector controlling which source(s) define <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_legendpos">legendpos</code></td>
<td>
<p>Character vector controlling the positions of the legends</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_posterior_args">posterior_args</code></td>
<td>
<p>Optional list of graphical parameters for posterior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_prior_args">prior_args</code></td>
<td>
<p>Optional list of graphical parameters for prior lines/ribbons.</p>
</td></tr>
<tr><td><code id="plot_stat_+3A_...">...</code></td>
<td>
<p>Other graphical parameters for the real data lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible data frame with the stat applied to the real data, posterior predictives and/or prior predictives
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example plot the observed and predicted response accuracy
# Can also apply more sophisticated statistics
drt &lt;- function(data) diff(tapply(data$rt,data[,c("E")],mean))
plot_stat(samples_LNR, stat_fun = drt, n_post = 10, stat_name = "RT diff Speed - A/N")

</code></pre>

<hr>
<h2 id='plot.emc'>Plot Function for emc Objects</h2><span id='topic+plot.emc'></span>

<h3>Description</h3>

<p>Makes trace plots for model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
plot(
  x,
  stage = "sample",
  selection = c("mu", "sigma2", "alpha"),
  layout = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.emc_+3A_x">x</code></td>
<td>
<p>An object of class <code>emc</code></p>
</td></tr>
<tr><td><code id="plot.emc_+3A_stage">stage</code></td>
<td>
<p>A character string indicating the sampling stage to be summarized.
Can be <code>preburn</code>, <code>burn</code>, <code>adapt</code>, or <code>sample</code>.</p>
</td></tr>
<tr><td><code id="plot.emc_+3A_selection">selection</code></td>
<td>
<p>A character vector indicating the parameter group(s).
Defaults to <code>mu</code>, <code>sigma2</code>, and <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="plot.emc_+3A_layout">layout</code></td>
<td>
<p>A vector indicating which layout to use as in par(mfrow = layout). If NA, will automatically generate an appropriate layout.</p>
</td></tr>
<tr><td><code id="plot.emc_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code> or <code>plot.default</code> (see <code>par()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trace/acf plot of the selected MCMC chains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(samples_LNR)
# Or trace autocorrelation for the second subject:
plot(samples_LNR, subject = 2, selection = "alpha")

# Can also plot the trace of for example the group-level correlation:
plot(samples_LNR, selection = "correlation", col = c("green", "purple", "orange"), lwd = 2)
</code></pre>

<hr>
<h2 id='plot.emc.design'>Plot method for emc.design objects</h2><span id='topic+plot.emc.design'></span>

<h3>Description</h3>

<p>Makes design illustration by plotting simulated data based on the design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.design'
plot(
  x,
  p_vector,
  data = NULL,
  factors = NULL,
  plot_factor = NULL,
  n_data_sim = 10,
  functions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.emc.design_+3A_x">x</code></td>
<td>
<p>An object of class <code>emc.design</code> containing the design to plot</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_p_vector">p_vector</code></td>
<td>
<p>A named vector of parameter values to use for data generation</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_data">data</code></td>
<td>
<p>Optional data frame to overlay on the design plot. If NULL, data will be simulated.</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_factors">factors</code></td>
<td>
<p>Character vector. Factors to use for varying parameters in the plot</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_plot_factor">plot_factor</code></td>
<td>
<p>Optional character. Make separate plots for each level of this factor</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_n_data_sim">n_data_sim</code></td>
<td>
<p>Integer. If data is NULL, number of simulated datasets to generate for the plot. Default is 10.</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_functions">functions</code></td>
<td>
<p>Optional named list of functions that create additional columns in the data</p>
</td></tr>
<tr><td><code id="plot.emc.design_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>make_design_plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effect of plotting
</p>

<hr>
<h2 id='plot.emc.prior'>Plot a prior</h2><span id='topic+plot.emc.prior'></span>

<h3>Description</h3>

<p>Takes a prior object and plots the selected implied prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
plot(
  x,
  selection = "mu",
  do_plot = TRUE,
  covariates = NULL,
  layout = NA,
  N = 50000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.emc.prior_+3A_x">x</code></td>
<td>
<p>An <code>emc_prior</code> element</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_selection">selection</code></td>
<td>
<p>A Character string. Indicates which parameter type to use (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_do_plot">do_plot</code></td>
<td>
<p>Boolean. If <code>FALSE</code> will only return prior samples and omit plotting.</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_covariates">covariates</code></td>
<td>
<p>dataframe/functions as specified by the design</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_layout">layout</code></td>
<td>
<p>A vector indicating which layout to use as in par(mfrow = layout). If NA, will automatically generate an appropriate layout.</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_n">N</code></td>
<td>
<p>Integer. How many prior samples to draw</p>
</td></tr>
<tr><td><code id="plot.emc.prior_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to get_pars, histogram, plot.default (see par()),
or arguments required for the types of models e.g. n_factors for type = &quot;factor&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible mcmc.list object with prior samples of the selected type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First define a design for the model
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# Then set up a prior using make_prior
p_vector=c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
          t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
psd &lt;- c(v_Sleft=1,v_Sright=1,a=.3,a_Eneutral=.3,a_Eaccuracy=.3,
          t0=.4,Z=1,sv=.4,SZ=1)
# Here we left the variance prior at default
prior_DDMaE &lt;- prior(design_DDMaE,mu_mean=p_vector,mu_sd=psd)
# Now we can plot all sorts of (implied) priors
plot(prior_DDMaE, selection = "mu", N = 1e3)
plot(prior_DDMaE, selection = "mu", mapped = FALSE, N=1e3)
# We can also plot the implied prior on the participant level effects.
plot(prior_DDMaE, selection = "alpha", col = "green", N = 1e3)

</code></pre>

<hr>
<h2 id='predict.emc.prior'>Generate Posterior/Prior Predictives</h2><span id='topic+predict.emc.prior'></span><span id='topic+predict.emc'></span>

<h3>Description</h3>

<p>Simulate <code>n_post</code> data sets using the posterior/prior parameter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
predict(object, data = NULL, n_post = 50, n_cores = 1, n_trials = NULL, ...)

## S3 method for class 'emc'
predict(
  object,
  hyper = FALSE,
  n_post = 50,
  n_cores = 1,
  stat = c("random", "mean", "median")[1],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.emc.prior_+3A_object">object</code></td>
<td>
<p>An emc or emc.prior object from which to generate predictives</p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_data">data</code></td>
<td>
<p>A data frame needed to exactly match the original design</p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_n_post">n_post</code></td>
<td>
<p>Integer. Number of generated datasets</p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_n_cores">n_cores</code></td>
<td>
<p>Integer. Number of cores across which there should be parallellized</p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_n_trials">n_trials</code></td>
<td>
<p>An integer. If <code>data</code> isn't provided (although preferred),
can generate data based on <code>n_trials</code> per cell of <code>design</code></p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_...">...</code></td>
<td>
<p>Optional additional arguments passed to <code>get_pars</code> or <code>make_data</code></p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_hyper">hyper</code></td>
<td>
<p>Boolean. Defaults to <code>FALSE</code>. If <code>TRUE</code>, simulates from the group-level (<code>hyper</code>)
parameters instead of the subject-level parameters.</p>
</td></tr>
<tr><td><code id="predict.emc.prior_+3A_stat">stat</code></td>
<td>
<p>Character. Can be <code>mean</code>, <code>median</code> or <code>random</code> (i.e., the default).
Will take either random samples from the chain(s) or use the mean or median of the parameter estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of simulated data sets of length <code>n_post</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# based on an emc object ran by fit() we can generate posterior predictives
predict(samples_LNR, n_cores = 1, n_post = 10)

</code></pre>

<hr>
<h2 id='prior'>Specify Priors for the Chosen Model</h2><span id='topic+prior'></span>

<h3>Description</h3>

<p>These values are entered manually by default but can be recycled from another prior (given in the <code>update</code> argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior(
  design,
  type = NULL,
  update = NULL,
  do_ask = NULL,
  fill_default = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_+3A_design">design</code></td>
<td>
<p>Design list for which a prior is constructed, typically the output of <code>design()</code></p>
</td></tr>
<tr><td><code id="prior_+3A_type">type</code></td>
<td>
<p>Character. What type of group-level model you plan on using i.e. <code>diagonal</code></p>
</td></tr>
<tr><td><code id="prior_+3A_update">update</code></td>
<td>
<p>Prior list from which to copy values</p>
</td></tr>
<tr><td><code id="prior_+3A_do_ask">do_ask</code></td>
<td>
<p>Character. For which parameter types or hyperparameters to ask for prior specification,
i.e. <code>Sigma</code>, <code>mu</code> or <code>loadings</code> for factor models, but <code>theta_mu_mean</code> or <code>A</code> also works.</p>
</td></tr>
<tr><td><code id="prior_+3A_fill_default">fill_default</code></td>
<td>
<p>Boolean, If <code>TRUE</code> will fill all non-specified parameters, and parameters outside of <code>do_ask</code>, to default values</p>
</td></tr>
<tr><td><code id="prior_+3A_...">...</code></td>
<td>
<p>Either values to prefill, i.e. <code>theta_mu_mean = c(1:6)</code>, or additional arguments such as <code>n_factors = 2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Where a value is not supplied, the user is prompted to enter numeric values (or functions that evaluate to numbers).
</p>
<p>To get the prior help use <code>prior_help(type)</code>. With <code>type</code> e.g. 'diagonal'.
</p>


<h3>Value</h3>

<p>A prior list object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First define a design for the model
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# Then set up a prior using prior
p_vector=c(v_Sleft=-2,v_Sright=2,a=log(1),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
                     t0=log(.2),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
psd &lt;- c(v_Sleft=1,v_Sright=1,a=.3,a_Eneutral=.3,a_Eaccuracy=.3,
                     t0=.4,Z=1,sv=.4,SZ=1)
# Here we left the variance prior at default
prior_DDMaE &lt;- prior(design_DDMaE,mu_mean=p_vector,mu_sd=psd)
# Also add a group-level variance prior:
pscale &lt;- c(v_Sleft=.6,v_Sright=.6,a=.3,a_Eneutral=.3,a_Eaccuracy=.3,
                             t0=.2,Z=.5,sv=.4,SZ=.3)
df &lt;- .4
prior_DDMaE &lt;- prior(design_DDMaE,mu_mean=p_vector,mu_sd=psd, A = pscale, df = df)
# If we specify a new design
design_DDMat0E &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~E, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# We can easily update the prior
prior_DDMat0E &lt;- prior(design_DDMat0E, update = prior_DDMaE)
</code></pre>

<hr>
<h2 id='prior_help'>Prior Specification Information</h2><span id='topic+prior_help'></span>

<h3>Description</h3>

<p>Prints information associated with the prior for certain 'type'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prior_help(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_help_+3A_type">type</code></td>
<td>
<p>A character string indicating which 'type' of model to run (e.g. 'standard' or 'single')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible return with a list of all the information that is also printed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior_help('diagonal')
</code></pre>

<hr>
<h2 id='profile_plot'>Likelihood Profile Plots</h2><span id='topic+profile_plot'></span>

<h3>Description</h3>

<p>Creates likelihood profile plots from a design and the experimental data by
varying one model parameter while holding all others constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_plot(
  data,
  design,
  p_vector,
  range = 0.5,
  layout = NA,
  p_min = NULL,
  p_max = NULL,
  use_par = NULL,
  n_point = 100,
  n_cores = 1,
  round = 3,
  true_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile_plot_+3A_data">data</code></td>
<td>
<p>A dataframe. Experimental data used, needed for the design mapping</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_design">design</code></td>
<td>
<p>A design list. Created using <code>design</code>.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_p_vector">p_vector</code></td>
<td>
<p>Named vector of parameter values (typically created with <code>sampled_pars(design)</code>)</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_range">range</code></td>
<td>
<p>Numeric. The max and min will be p_vector + range/2 and p_vector - range/2, unless specified in p_min or p_max.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_layout">layout</code></td>
<td>
<p>A vector indicating which layout to use as in par(mfrow = layout). If NA, will automatically generate an appropriate layout.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_p_min">p_min</code></td>
<td>
<p>Named vector. If specified will instead use these values for minimum range of the selected parameters.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_p_max">p_max</code></td>
<td>
<p>Named vector. If specified will instead use these values for maximum range of the selected parameters.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_use_par">use_par</code></td>
<td>
<p>Character vector. If specified will only plot the profiles for the specified parameters.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_n_point">n_point</code></td>
<td>
<p>Integer. Number of evenly spaced points at which to calculate likelihood</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of likelihood points evenly spaced between the minimum and maximum likelihood range.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_round">round</code></td>
<td>
<p>Integer. To how many digits will the output be rounded.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_true_args">true_args</code></td>
<td>
<p>A list. Optional additional arguments that can be passed to plot.default for the plotting of the true vertical line.</p>
</td></tr>
<tr><td><code id="profile_plot_+3A_...">...</code></td>
<td>
<p>Optional additional arguments that can be passed to plot.default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with highest likelihood point, input and mismatch between true and highest point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First create a design
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                      formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                      constants=c(s=log(1)))
# Then create a p_vector:
p_vector=c(v_Sleft=-2,v_Sright=2,a=log(.95),a_Eneutral=log(1.5),a_Eaccuracy=log(2),
          t0=log(.25),Z=qnorm(.5),sv=log(.5),SZ=qnorm(.5))
# Make a profile plot for some parameters. Specifying a custom range for t0.
profile_plot(p_vector = p_vector, p_min = c(t0 = -1.35),
             p_max = c(t0 = -1.45), use_par = c("a", "t0", "SZ"),
             data = forstmann, design = design_DDMaE, n_point = 10)

</code></pre>

<hr>
<h2 id='RDM'>The Racing Diffusion Model</h2><span id='topic+RDM'></span>

<h3>Description</h3>

<p>Model file to estimate the Racing Diffusion Model (RDM), also known as the Racing Wald Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDM()
</code></pre>


<h3>Details</h3>

<p>Model files are almost exclusively used in <code>design()</code>.
</p>
<p>Default values are used for all parameters that are not explicitly listed in the <code>formula</code>
argument of <code>design()</code>.They can also be accessed with <code>RDM()$p_types</code>.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Parameter</strong> </td><td style="text-align: left;"> <strong>Transform</strong> </td><td style="text-align: left;"> <strong>Natural scale</strong> </td><td style="text-align: left;"> <strong>Default</strong> </td><td style="text-align: left;"> <strong>Mapping</strong> </td><td style="text-align: left;"> <strong>Interpretation</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>v</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Evidence-accumulation rate (drift rate) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>A</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Between-trial variation (range) in start point </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>B</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;"> <em>b</em> = <em>B</em> + <em>A</em> </td><td style="text-align: left;"> Distance from <em>A</em> to <em>b</em> (response threshold) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>t0</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(0) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Non-decision time </td>
</tr>
<tr>
 <td style="text-align: left;">
   <em>sv</em> </td><td style="text-align: left;"> log </td><td style="text-align: left;"> [0, Inf] </td><td style="text-align: left;"> log(1) </td><td style="text-align: left;">  </td><td style="text-align: left;"> Within-trial standard deviation of drift rate </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>All parameters are estimated on the log scale.
</p>
<p>The parameterization <em>b</em> = <em>B</em> + <em>A</em> ensures that the response threshold is
always higher than the between trial variation in start point.
</p>
<p>Conventionally, <code>s</code> is fixed to 1 to satisfy scaling constraints.
</p>
<p>Because the RDM is a race model, it has one accumulator per response option.
EMC2 automatically constructs a factor representing the accumulators <code>lR</code> (i.e., the
latent response) with level names taken from the <code>R</code> column in the data.
</p>
<p>The <code>lR</code> factor is mainly used to allow for response bias, analogous to <em>Z</em> in the
DDM. For example, in the RDM, response thresholds are determined by the <em>B</em>
parameters, so <code>B~lR</code> allows for different thresholds for the accumulator
corresponding to &quot;left&quot; and &quot;right&quot; stimuli, for example, (e.g., a bias to respond left occurs
if the left threshold is less than the right threshold).
</p>
<p>For race models in general, the argument <code>matchfun</code> can be provided in <code>design()</code>.
One needs to supply a function that takes the <code>lR</code> factor (defined in the augmented data (d)
in the following function) and returns a logical defining the correct
response. In the example below, this is simply whether the <code>S</code> factor equals the
latent response factor: <code>matchfun=function(d)d$S==d$lR</code>. Using <code>matchfun</code> a latent match factor (<code>lM</code>) with
levels <code>FALSE</code> (i.e., the stimulus does not match the accumulator) and <code>TRUE</code>
(i.e., the stimulus does match the accumulator). This is added internally
and can also be used in model formula, typically for parameters related to
the rate of accumulation.
</p>
<p>Tillman, G., Van Zandt, T., &amp; Logan, G. D. (2020). Sequential sampling models
without random between-trial variability: The racing diffusion model of speeded
decision making. <em>Psychonomic Bulletin &amp; Review, 27</em>(5), 911-936.
https://doi.org/10.3758/s13423-020-01719-6
</p>


<h3>Value</h3>

<p>A list defining the cognitive model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># When working with lM it is useful to design  an "average and difference"
# contrast matrix, which for binary responses has a simple canonical from:
ADmat &lt;- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"d"))
# We also define a match function for lM
matchfun=function(d)d$S==d$lR
# We now construct our design, with v ~ lM and the contrast for lM the ADmat.
design_RDMBE &lt;- design(data = forstmann,model=RDM,matchfun=matchfun,
                       formula=list(v~lM,s~lM,B~E+lR,A~1,t0~1),
                       contrasts=list(v=list(lM=ADmat)),constants=c(s=log(1)))
# For all parameters that are not defined in the formula, default values are assumed
# (see Table above).
</code></pre>

<hr>
<h2 id='recovery.emc'>Recovery Plots</h2><span id='topic+recovery.emc'></span><span id='topic+recovery'></span>

<h3>Description</h3>

<p>Plots recovery of data generating parameters/samples.
Full range of samples manipulations described in <code>get_pars</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
recovery(
  emc,
  true_pars,
  selection = "mu",
  layout = NA,
  do_CI = TRUE,
  correlation = "pearson",
  stat = "rmse",
  digits = 3,
  CI = 0.95,
  ci_plot_args = list(),
  ...
)

recovery(emc, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recovery.emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_true_pars">true_pars</code></td>
<td>
<p>A vector of data-generating parameters or an emc object with data-generating samples</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_selection">selection</code></td>
<td>
<p>A Character vector. Indicates which parameter types to plot (e.g., <code>alpha</code>, <code>mu</code>, <code>sigma2</code>, <code>correlation</code>).</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_layout">layout</code></td>
<td>
<p>A vector indicating which layout to use as in par(mfrow = layout). If NA, will automatically generate an appropriate layout.</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_do_ci">do_CI</code></td>
<td>
<p>Boolean. If <code>TRUE</code> will also include bars representing the credible intervals</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_correlation">correlation</code></td>
<td>
<p>Character. Which correlation to include in the plot. Options are either <code>pearson</code> or <code>spearman</code></p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_stat">stat</code></td>
<td>
<p>Character. Which statistic to include in the plot. Options are either <code>rmse</code> or <code>coverage</code></p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_digits">digits</code></td>
<td>
<p>Integer. How many digits to round the statistic and correlation in the plot to</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_ci">CI</code></td>
<td>
<p>Numeric. The size of the credible intervals. Default is .95 (95%).</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_ci_plot_args">ci_plot_args</code></td>
<td>
<p>A list. Optional additional arguments to be passed to plot.default for the plotting of the credible intervals (see <code>par()</code>)</p>
</td></tr>
<tr><td><code id="recovery.emc_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code> or <code>plot.default</code> (see <code>par()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible list with RMSE, coverage, and Pearson and Spearman correlations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make up some values that resemble posterior samples
# Normally this would be true values that were used to simulate the data
# Make up some values that resemble posterior samples
# Normally this would be true values that were used to simulate the data
pmat &lt;- matrix(rnorm(12, mean = c(-1, -.6, -.4, -1.5), sd = .01), ncol = 4, byrow = TRUE)
# Conventionally this would be created before one makes data with true values
recovery(samples_LNR, pmat, correlation = "pearson", stat = "rmse", selection = "alpha")
# Similarly we can plot recovery of other parameters with a set of true samples
true_samples &lt;- samples_LNR # Normally this would be data-generating samples
recovery(samples_LNR, true_samples, correlation = "pearson", stat = "rmse",
         selection = "correlation", cex = 1.5,
         ci_plot_args = list(lty = 3, length = .2, lwd = 2, col = "brown"))
</code></pre>

<hr>
<h2 id='run_bridge_sampling'>Estimating Marginal Likelihoods Using WARP-III Bridge Sampling</h2><span id='topic+run_bridge_sampling'></span>

<h3>Description</h3>

<p>Uses bridge sampling that matches a proposal distribution to the first three moments
of the posterior distribution to get an accurate estimate of the marginal likelihood.
The marginal likelihood can be used for computing Bayes factors and posterior model probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_bridge_sampling(
  emc,
  stage = "sample",
  filter = NULL,
  repetitions = 1,
  cores_for_props = 4,
  cores_per_prop = 1,
  both_splits = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_bridge_sampling_+3A_emc">emc</code></td>
<td>
<p>An emc object with a set of converged samples</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_stage">stage</code></td>
<td>
<p>A character indicating which stage to use, defaults to <code>sample</code></p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_filter">filter</code></td>
<td>
<p>An integer or vector. If integer, it will exclude up until
that integer. If vector it will include everything in that range.</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_repetitions">repetitions</code></td>
<td>
<p>An integer. How many times to repeat the bridge sampling scheme. Can help get an estimate of stability of the estimate.</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_cores_for_props">cores_for_props</code></td>
<td>
<p>Integer. Warp-III evaluates the posterior over 4 different proposal densities. If you have the CPU, 4 cores will do this in parallel, 2 is also already helpful.</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_cores_per_prop">cores_per_prop</code></td>
<td>
<p>Integer. Per density we can also parallelize across subjects. Eventual cores will be <code>cores_for_props</code> * <code>cores_per_prop</code>. For efficiency users should prioritize cores_for_props being 4.</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_both_splits">both_splits</code></td>
<td>
<p>Boolean. Bridge sampling uses a proposal density and a target density. We can estimate the stability of our samples and therefore MLL estimate, by running 2 bridge sampling iterations
The first one uses the first half of the samples as the proposal and the second half as the target, the second run uses the opposite. If this is is set to <code>FALSE</code>, it will only run bridge sampling once and
it will instead do an odd-even iterations split to get a more reasonable estimate for just one run.</p>
</td></tr>
<tr><td><code id="run_bridge_sampling_+3A_...">...</code></td>
<td>
<p>Additional, optional more in-depth hyperparameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not enough posterior samples were collected using <code>fit()</code>,
bridge sampling can be unstable. It is recommended to run
<code>run_bridge_sampling()</code> several times with the <code>repetitions</code> argument
and to examine how stable the results are.
</p>
<p>It can be difficult to converge bridge sampling for exceptionally large models,
because of a large number of subjects (&gt; 100) and/or cognitive model parameters.
</p>
<p>For a practical introduction:
</p>
<p>Gronau, Q. F., Heathcote, A., &amp; Matzke, D. (2020). Computing Bayes factors
for evidence-accumulation models using Warp-III bridge sampling.
<em>Behavior research methods</em>, 52(2), 918-937. doi.org/10.3758/s13428-019-01290-6
</p>
<p>For mathematical background:
</p>
<p>Meng, X.-L., &amp; Wong, W. H. (1996). Simulating ratios of normalizing
constants via a simple identity: A theoretical exploration. <em>Statistica Sinica</em>,
6, 831-860. http://www3.stat.sinica.edu.tw/statistica/j6n4/j6n43/j6n43.htm
</p>
<p>Meng, X.-L., &amp; Schilling, S. (2002). Warp bridge sampling.
<em>Journal of Computational and Graphical Statistics</em>,
11(3), 552-586. doi.org/10.1198/106186002457
</p>


<h3>Value</h3>

<p>A vector of length repetitions which contains the marginal log likelihood estimates per repetition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# After `fit` has converged on a specific model
# We can take those samples and calculate the marginal log-likelihood for them
MLL &lt;- run_bridge_sampling(samples_LNR, cores_for_props = 1, both_splits = FALSE)
# This will run on 2*4 cores (since 4 is the default for ``cores_for_props``)

</code></pre>

<hr>
<h2 id='run_emc'>Custom Function for More Controlled Model Estimation</h2><span id='topic+run_emc'></span>

<h3>Description</h3>

<p>Although typically users will rely on <code>fit</code>, this function can be used for more fine-tuned specification of estimation needs.
The function will throw an error if a stage is skipped,
the stages have to be run in order (&quot;preburn&quot;, &quot;burn&quot;, &quot;adapt&quot;, &quot;sample&quot;).
More details can be found in the <code>fit</code> help files (<code>?fit</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_emc(
  emc,
  stage,
  stop_criteria,
  search_width = 1,
  step_size = 100,
  verbose = FALSE,
  verboseProgress = FALSE,
  fileName = NULL,
  particles = NULL,
  particle_factor = 50,
  cores_per_chain = 1,
  cores_for_chains = length(emc),
  max_tries = 20,
  n_blocks = 1,
  thin_auto = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_emc_+3A_emc">emc</code></td>
<td>
<p>An emc object</p>
</td></tr>
<tr><td><code id="run_emc_+3A_stage">stage</code></td>
<td>
<p>A string. Indicates which stage is to be run, either <code>preburn</code>, <code>burn</code>, <code>adapt</code> or <code>sample</code></p>
</td></tr>
<tr><td><code id="run_emc_+3A_stop_criteria">stop_criteria</code></td>
<td>
<p>A list. Defines the stopping criteria and for which types of parameters these should hold. See <code>?fit</code>.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_search_width">search_width</code></td>
<td>
<p>A double. Tunes target acceptance probability of the MCMC process.
This fine-tunes the width of the search space to obtain the desired acceptance probability.
1 is the default width, increases lead to broader search.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_step_size">step_size</code></td>
<td>
<p>An integer. After each step, the stopping requirements as
specified by <code>stop_criteria</code> are checked and proposal distributions are updated. Defaults to 100.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to print messages between each step with the current status regarding the stop_criteria.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_verboseprogress">verboseProgress</code></td>
<td>
<p>Logical. Whether to print a progress bar within each step or not. Will print one progress bar for each chain and only if cores_for_chains = 1.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_filename">fileName</code></td>
<td>
<p>A string. If specified will autosave emc at this location on every iteration.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_particles">particles</code></td>
<td>
<p>An integer. How many particles to use, default is <code>NULL</code> and <code>particle_factor</code> is used instead.
If specified will override <code>particle_factor</code>.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_particle_factor">particle_factor</code></td>
<td>
<p>An integer. <code>particle_factor</code> multiplied by the square root of the number of sampled parameters determines the number of particles used.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_cores_per_chain">cores_per_chain</code></td>
<td>
<p>An integer. How many cores to use per chain.
Parallelizes across participant calculations. Only available on Linux or Mac OS.
For Windows, only parallelization across chains (<code>cores_for_chains</code>) is available.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_cores_for_chains">cores_for_chains</code></td>
<td>
<p>An integer. How many cores to use across chains.
Defaults to the number of chains. the total number of cores used is equal to <code>cores_per_chain</code> * <code>cores_for_chains</code>.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_max_tries">max_tries</code></td>
<td>
<p>An integer. How many times should it try to meet the finish
conditions as specified by stop_criteria? Defaults to 20. max_tries is ignored if the required number of iterations has not been reached yet.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_n_blocks">n_blocks</code></td>
<td>
<p>An integer. Number of blocks. Will block the parameter chains such that they are updated in blocks. This can be helpful in extremely tough models with a large number of parameters.</p>
</td></tr>
<tr><td><code id="run_emc_+3A_thin_auto">thin_auto</code></td>
<td>
<p>A boolean. If <code>TRUE</code> will automatically thin the MCMC samples, closely matched to the ESS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An emc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First define a design
design_in &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# Then make the emc, we've omitted a prior here for brevity so default priors will be used.
emc &lt;- make_emc(forstmann, design_in)

# Now for example we can specify that we only want to run the "preburn" phase
# for MCMC 10 iterations
emc &lt;- run_emc(emc, stage = "preburn", stop_criteria = list(iter = 10), cores_for_chains = 1)

</code></pre>

<hr>
<h2 id='run_sbc'>Simulation-Based Calibration</h2><span id='topic+run_sbc'></span>

<h3>Description</h3>

<p>Runs SBC for an EMC2 model and associated design. Returns
normalized rank (between 0 and 1) and prior samples. For hierarchical models the group-level mean and
the (implied) group-level (co-)variance are returned.
For non-hierarchical models only the subject-level parameters rank is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_sbc(
  design_in,
  prior_in,
  replicates = 250,
  trials = 100,
  n_subjects = 30,
  plot_data = FALSE,
  verbose = TRUE,
  fileName = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_sbc_+3A_design_in">design_in</code></td>
<td>
<p>An emc design list. The design of the model to be used in SBC</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_prior_in">prior_in</code></td>
<td>
<p>An emc prior list. The prior for the design to be used in SBC</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_replicates">replicates</code></td>
<td>
<p>Integer. The number of samples to draw from the prior</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_trials">trials</code></td>
<td>
<p>Integer. The number of trials of the simulated data (per subject)</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_n_subjects">n_subjects</code></td>
<td>
<p>Integer. Only used for hierarchical models. The number of subjects to be used in data generation of each replicate</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_plot_data">plot_data</code></td>
<td>
<p>Boolean. Whether to plot the data simulated (aggregated across subjects)</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_verbose">verbose</code></td>
<td>
<p>Verbose. Whether to print progress related messages</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_filename">fileName</code></td>
<td>
<p>Character. Highly recommended, saves temporary results to the fileName</p>
</td></tr>
<tr><td><code id="run_sbc_+3A_...">...</code></td>
<td>
<p>A list of optional additional arguments that can be passed to <code>fit</code> and <code>make_emc</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ranks and prior samples. For hierarchical models also the prior-generated subject-level parameters.
</p>

<hr>
<h2 id='sampled_pars'>Get Model Parameters from a Design</h2><span id='topic+sampled_pars'></span><span id='topic+sampled_pars.emc.design'></span><span id='topic+sampled_pars.emc.prior'></span><span id='topic+sampled_pars.emc'></span>

<h3>Description</h3>

<p>Makes a vector with zeroes, with names and length corresponding to the
model parameters of the design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampled_pars(
  x,
  model = NULL,
  doMap = TRUE,
  add_da = FALSE,
  all_cells_dm = FALSE
)

## S3 method for class 'emc.design'
sampled_pars(
  x,
  model = NULL,
  doMap = TRUE,
  add_da = FALSE,
  all_cells_dm = FALSE
)

## S3 method for class 'emc.prior'
sampled_pars(
  x,
  model = NULL,
  doMap = TRUE,
  add_da = FALSE,
  all_cells_dm = FALSE
)

## S3 method for class 'emc'
sampled_pars(
  x,
  model = NULL,
  doMap = TRUE,
  add_da = FALSE,
  all_cells_dm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampled_pars_+3A_x">x</code></td>
<td>
<p>an <code>emc.design</code> object made with <code>design()</code> or an <code>emc</code> object.</p>
</td></tr>
<tr><td><code id="sampled_pars_+3A_model">model</code></td>
<td>
<p>a model list. Defaults to the model specified in the design list.</p>
</td></tr>
<tr><td><code id="sampled_pars_+3A_domap">doMap</code></td>
<td>
<p>logical. If <code>TRUE</code> will also include an attribute <code>map</code>
with the design matrices that perform the mapping back to the design</p>
</td></tr>
<tr><td><code id="sampled_pars_+3A_add_da">add_da</code></td>
<td>
<p>Boolean. Whether to include the relevant data columns in the map attribute</p>
</td></tr>
<tr><td><code id="sampled_pars_+3A_all_cells_dm">all_cells_dm</code></td>
<td>
<p>Boolean. Whether to include all levels of a factor in the mapping attribute,
even when one is dropped in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># First define a design
design_DDMaE &lt;- design(data = forstmann,model=DDM,
                           formula =list(v~0+S,a~E, t0~1, s~1, Z~1, sv~1, SZ~1),
                           constants=c(s=log(1)))
# Then for this design get which cognitive model parameters are sampled:
sampled_pars(design_DDMaE)

</code></pre>

<hr>
<h2 id='samples_LNR'>LNR Model of Forstmann Data (First 3 Subjects)</h2><span id='topic+samples_LNR'></span>

<h3>Description</h3>

<p>An emc object with a limited number of samples and subjects of the Forstmann dataset.
The object is a nested list of lenght three, each list containing the MCMC samples
of the respective chain. The MCMC samples are stored in the samples element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples_LNR
</code></pre>


<h3>Format</h3>

<p>An emc object. An emc object is a list with a
specific structure and elements, as outlined below.
</p>

<dl>
<dt>data</dt><dd><p>A list of dataframes, one for each subject included</p>
</dd>
<dt>par_names</dt><dd><p>A character vector containing the model parameter names</p>
</dd>
<dt>n_pars</dt><dd><p>The number of parameters in the model</p>
</dd>
<dt>n_subjects</dt><dd><p>The number of unique subject ID's in the data</p>
</dd>
<dt>model</dt><dd><p>A list containing the model functions</p>
</dd>
<dt>nuisance</dt><dd><p>A logical vector indicating which parameters are nuisance parameters</p>
</dd>
<dt>subjects</dt><dd><p>A vector containing the unique subject ID's</p>
</dd>
<dt>type</dt><dd><p>The type of model e.g., &quot;standard&quot; or &quot;diagonal&quot;</p>
</dd>
<dt>prior</dt><dd><p>A list that holds the prior for <code>theta_mu</code> (the model
parameters). Contains the mean (<code>theta_mu_mean</code>), covariance matrix
(<code>theta_mu_var</code>), degrees of freedom (<code>v</code>), and scale (<code>A</code>)
and inverse covariance matrix (<code>theta_mu_invar</code>)</p>
</dd>
<dt>samples</dt><dd><p>A list with defined structure containing the samples, see
the Samples Element section for more detail</p>
</dd>
<dt>sampler_nuis</dt><dd><p>A sampler list for nuisance parameters (in this case there are none),
similarly structured to the overall samples list of one of the MCMC chains.</p>
</dd>
</dl>



<h3>Samples Element</h3>

<p>The samples element of a emc object contains the different types of samples
estimated by EMC2. These include the three main types of samples
<code>theta_mu</code>, <code>theta_var</code> and <code>alpha</code> as well as a number of
other items which are detailed here.
</p>

<dl>
<dt>theta_mu</dt><dd><p>samples used for estimating the model parameters (group
level), an array of size (n_pars x n_samples)</p>
</dd>
<dt>theta_var</dt><dd><p>samples used for estimating the parameter covariance
matrix, an array of size (n_pars x n_pars x n_samples)</p>
</dd>
<dt>alpha</dt><dd><p>samples used for estimating the subject random effects, an
array of size (n_pars x n_subjects x n_samples)</p>
</dd>
<dt>stage</dt><dd><p>A vector containing what PMwG stage each sample was drawn in</p>
</dd>
<dt>subj_ll</dt><dd><p>The winning particles log-likelihood for each subject and
sample</p>
</dd>
<dt>a_half</dt><dd><p>Mixing weights used during the Gibbs step when creating a
new sample for the covariance matrix</p>
</dd>
<dt>last_theta_var_inv</dt><dd><p>The inverse of the last samples covariance
matrix</p>
</dd>
<dt>idx</dt><dd><p>The index of the last sample drawn</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.pnas.org/doi/10.1073/pnas.0805903105">https://www.pnas.org/doi/10.1073/pnas.0805903105</a>
</p>

<hr>
<h2 id='subset.emc'>Shorten an emc Object</h2><span id='topic+subset.emc'></span>

<h3>Description</h3>

<p>Shorten an emc Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
subset(
  x,
  stage = "sample",
  filter = NULL,
  thin = 1,
  keep_stages = FALSE,
  length.out = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.emc_+3A_x">x</code></td>
<td>
<p>an emc object</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_stage">stage</code></td>
<td>
<p>A character string. Indicates from which sampling stage(s) to take the samples from (i.e. <code>preburn</code>, <code>burn</code>, <code>adapt</code>, <code>sample</code>)</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_filter">filter</code></td>
<td>
<p>Integer or numeric vector. If an integer is supplied, iterations
up until that integer are removed. If a vector is supplied, the iterations
within the range are kept.</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_thin">thin</code></td>
<td>
<p>An integer. By how much to thin the chains</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_keep_stages">keep_stages</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, will not remove samples from unselected stages.</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_length.out">length.out</code></td>
<td>
<p>Integer. Alternatively to thinning, you can also select a
desired length of the MCMC chains, which will be thinned appropriately.</p>
</td></tr>
<tr><td><code id="subset.emc_+3A_...">...</code></td>
<td>
<p>additional optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A shortened emc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subset(samples_LNR, length.out = 10)
</code></pre>

<hr>
<h2 id='summary.emc'>Summary Statistics for emc Objects</h2><span id='topic+summary.emc'></span>

<h3>Description</h3>

<p>Computes quantiles, <code>Rhat</code> and <code>ESS</code> for selected model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc'
summary(
  object,
  selection = c("mu", "sigma2", "alpha"),
  probs = c(0.025, 0.5, 0.975),
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.emc_+3A_object">object</code></td>
<td>
<p>An object of class <code>emc</code></p>
</td></tr>
<tr><td><code id="summary.emc_+3A_selection">selection</code></td>
<td>
<p>A character string indicating the parameter type
Defaults to <code>mu</code>, <code>sigma2</code>, and <code>alpha</code>. See below for more information.</p>
</td></tr>
<tr><td><code id="summary.emc_+3A_probs">probs</code></td>
<td>
<p>The quantiles to be computed. Defaults to the the 2.5%, 50% and 97.5% quantiles.</p>
</td></tr>
<tr><td><code id="summary.emc_+3A_digits">digits</code></td>
<td>
<p>An integer specifying rounding of output.</p>
</td></tr>
<tr><td><code id="summary.emc_+3A_...">...</code></td>
<td>
<p>Optional arguments that can be passed to <code>get_pars</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>selection = alpha</code> and <code>by_subject = TRUE</code> (default)
is used, summary statistics are computed at the individual level.
to the console but summary statistics for all subjects are returned by the
function.
</p>


<h3>Value</h3>

<p>A list of summary output.
</p>

<hr>
<h2 id='summary.emc.design'>Summary method for emc.design objects</h2><span id='topic+summary.emc.design'></span>

<h3>Description</h3>

<p>Prints a summary of the design object, including sampled parameters and design matrices.
For continuous covariates just prints one row, instead of all covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.design'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.emc.design_+3A_object">object</code></td>
<td>
<p>An object of class <code>emc.design</code> containing the design to summarize</p>
</td></tr>
<tr><td><code id="summary.emc.design_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the design matrices
</p>

<hr>
<h2 id='summary.emc.prior'>Summary method for emc.prior objects</h2><span id='topic+summary.emc.prior'></span>

<h3>Description</h3>

<p>Prints a summary of the prior specification, including descriptions of the prior types
and their associated hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emc.prior'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.emc.prior_+3A_object">object</code></td>
<td>
<p>An object of class 'emc.prior' containing prior specifications</p>
</td></tr>
<tr><td><code id="summary.emc.prior_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns NULL. Called for its side effect of printing the summary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prior">prior</a></code> for creating prior objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Take a prior object
prior &lt;- get_prior(samples_LNR)
summary(prior)

</code></pre>

<hr>
<h2 id='update2version'>Update EMC Objects to the Current Version</h2><span id='topic+update2version'></span>

<h3>Description</h3>

<p>This function updates EMC objects created with older versions of the package to be compatible with the current version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update2version(emc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update2version_+3A_emc">emc</code></td>
<td>
<p>An EMC object to update</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated EMC object compatible with the current version
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Update the model to current version
updated_model &lt;- update2version(samples_LNR)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
