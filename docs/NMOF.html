<!DOCTYPE html><html lang="en"><head><title>Help for package NMOF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMOF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NMOF-package'><p>Numerical Methods and Optimization in Finance</p></a></li>
<li><a href='#approxBondReturn'>
<p>Approximate Total Return of Bond</p></a></li>
<li><a href='#bracketing'>
<p>Zero-Bracketing</p></a></li>
<li><a href='#bundData'>
<p>German Government Bond Data</p></a></li>
<li><a href='#bundFuture'>
<p>Theoretical Valuation of Euro Bund Future</p></a></li>
<li><a href='#callCF'><p>Price a Plain-Vanilla Call with the Characteristic Function</p></a></li>
<li><a href='#callHestoncf'>
<p>Price of a European Call under the Heston Model</p></a></li>
<li><a href='#callMerton'>
<p>Price of a European Call under Merton's Jump&ndash;Diffusion Model</p></a></li>
<li><a href='#colSubset'>
<p>Full-rank Column Subset</p></a></li>
<li><a href='#CPPI'>
<p>Constant-Proportion Portfolio Insurance</p></a></li>
<li><a href='#DEopt'>
<p>Optimisation with Differential Evolution</p></a></li>
<li><a href='#divRatio'>
<p>Diversification Ratio</p></a></li>
<li><a href='#drawdown'>
<p>Drawdown</p></a></li>
<li><a href='#EuropeanCall'>
<p>Computing Prices of European Calls with a Binomial Tree</p></a></li>
<li><a href='#French'>
<p>Download Datasets from Kenneth French's Data Library</p></a></li>
<li><a href='#fundData'>
<p>Mutual Fund Returns</p></a></li>
<li><a href='#GAopt'>
<p>Optimisation with a Genetic Algorithm</p></a></li>
<li><a href='#greedySearch'>
<p>Greedy Search</p></a></li>
<li><a href='#gridSearch'>
<p>Grid Search</p></a></li>
<li><a href='#LS.info'>
<p>Local-Search Information</p></a></li>
<li><a href='#LSopt'>
<p>Stochastic Local Search</p></a></li>
<li><a href='#MA'>
<p>Simple Moving Average</p></a></li>
<li><a href='#maxSharpe'>
<p>Maximum-Sharpe-Ratio/Tangency Portfolio</p></a></li>
<li><a href='#mc'>
<p>Option Pricing via Monte-Carlo Simulation</p></a></li>
<li><a href='#minCVaR'>
<p>Minimum Conditional-Value-at-Risk (CVaR) Portfolios</p></a></li>
<li><a href='#minMAD'>
<p>Compute Minimum Mean&ndash;Absolute-Deviation Portfolios</p></a></li>
<li><a href='#minvar'>
<p>Minimum-Variance Portfolios</p></a></li>
<li><a href='#mvFrontier'>
<p>Computing Mean&ndash;Variance Efficient Portfolios</p></a></li>
<li><a href='#NMOF-internal'><p>Internal NMOF functions</p></a></li>
<li><a href='#NS'>
<p>Zero Rates for Nelson&ndash;Siegel&ndash;Svensson Model</p></a></li>
<li><a href='#NSf'>
<p>Factor Loadings for Nelson&ndash;Siegel and Nelson&ndash;Siegel&ndash;Svensson</p></a></li>
<li><a href='#optionData'>
<p>Option Data</p></a></li>
<li><a href='#pm'>
<p>Partial Moments</p></a></li>
<li><a href='#PSopt'>
<p>Particle Swarm Optimisation</p></a></li>
<li><a href='#putCallParity'>
<p>Put-Call Parity</p></a></li>
<li><a href='#qTable'>
<p>Prepare LaTeX Table with Quartile Plots</p></a></li>
<li><a href='#randomReturns'>
<p>Create a Random Returns</p></a></li>
<li><a href='#repairMatrix'>
<p>Repair an Indefinite Correlation Matrix</p></a></li>
<li><a href='#resampleC'>
<p>Resample with Specified Rank Correlation</p></a></li>
<li><a href='#restartOpt'>
<p>Restart an Optimisation Algorithm</p></a></li>
<li><a href='#Ritter'>
<p>Download Jay Ritter's IPO Data</p></a></li>
<li><a href='#SA.info'>
<p>Simulated-Annealing Information</p></a></li>
<li><a href='#SAopt'>
<p>Optimisation with Simulated Annealing</p></a></li>
<li><a href='#Shiller'>
<p>Download Robert Shiller's Data</p></a></li>
<li><a href='#showExample'>
<p>Display Code Examples</p></a></li>
<li><a href='#TA.info'>
<p>Threshold-Accepting Information</p></a></li>
<li><a href='#TAopt'>
<p>Optimisation with Threshold Accepting</p></a></li>
<li><a href='#testFunctions'>
<p>Classical Test Functions for Unconstrained Optimisation</p></a></li>
<li><a href='#trackingPortfolio'>
<p>Compute a Tracking Portfolio</p></a></li>
<li><a href='#vanillaBond'>
<p>Pricing Plain-Vanilla Bonds</p></a></li>
<li><a href='#vanillaOptionEuropean'>
<p>Pricing Plain-Vanilla (European and American) and</p>
Barrier Options (European)</a></li>
<li><a href='#xtContractValue'>
<p>Contract Value of Australian Government Bond Future</p></a></li>
<li><a href='#xwGauss'>
<p>Integration of Gauss-type</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Numerical Methods and Optimization in Finance</td>
</tr>
<tr>
<td>Version:</td>
<td>2.10-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Enrico Schumann &lt;es@enricoschumann.net&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, parallel, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, PMwR, RUnit, Rglpk, datetimeutils, openxlsx, quadprog,
readxl, tinytest, zoo</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions, examples and data from the first and
  the second edition of "Numerical Methods and Optimization in
  Finance" by M. Gilli, D. Maringer and E. Schumann (2019,
  ISBN:978-0128150658).  The package provides implementations
  of optimisation heuristics (Differential Evolution, Genetic
  Algorithms, Particle Swarm Optimisation, Simulated Annealing
  and Threshold Accepting), and other optimisation tools, such
  as grid search and greedy search.  There are also functions
  for the valuation of financial instruments such as bonds and
  options, for portfolio selection and functions that help
  with stochastic simulations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://enricoschumann.net/NMOF.htm">https://enricoschumann.net/NMOF.htm</a> , <a href="https://gitlab.com/NMOF">https://gitlab.com/NMOF</a> ,
<a href="https://git.sr.ht/~enricoschumann/NMOF">https://git.sr.ht/~enricoschumann/NMOF</a> ,
<a href="https://github.com/enricoschumann/NMOF">https://github.com/enricoschumann/NMOF</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Classification/JEL:</td>
<td>C61, C63</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-03 18:11:04 UTC; es19</td>
</tr>
<tr>
<td>Author:</td>
<td>Enrico Schumann <a href="https://orcid.org/0000-0001-7601-6576"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-03 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='NMOF-package'>Numerical Methods and Optimization in Finance</h2><span id='topic+NMOF-package'></span><span id='topic+NMOF'></span>

<h3>Description</h3>

<p>Functions, data and other <span class="rlang"><b>R</b></span> code from the book &lsquo;Numerical
Methods and Optimization in Finance&rsquo;.
Comments/corrections/remarks/suggestions are very welcome (please
contact the maintainer directly).
</p>


<h3>Details</h3>

<p>The package contains implementations of several optimisation
heuristics: Differential Evolution (<code><a href="#topic+DEopt">DEopt</a></code>), Genetic
Algorithms (<code><a href="#topic+GAopt">GAopt</a></code>), (Stochastic) Local Search
(<code><a href="#topic+LSopt">LSopt</a></code>), Particle Swarm (<code><a href="#topic+PSopt">PSopt</a></code>),
Simuleated Annealing (<code><a href="#topic+SAopt">SAopt</a></code>) and
Threshold Accepting (<code><a href="#topic+TAopt">TAopt</a></code>). The term heuristic is meant
in the sense of general-purpose optimisation method.
</p>
<p>Dependencies: The package is completely written in <span class="rlang"><b>R</b></span>. A
number of packages are <em>suggested</em>, but they are not
strictly required when using the <span class="pkg">NMOF</span> package, and
most of the package's functionality is available without
them.  Specifically, package <span class="pkg">MASS</span> is needed to run
the complete example for <code><a href="#topic+PSopt">PSopt</a></code> and also in
one of the vignettes (<code>PSlms</code>).  Package
<span class="pkg">parallel</span> is optional for functions
<code><a href="#topic+bracketing">bracketing</a></code>, <code><a href="#topic+GAopt">GAopt</a></code>,
<code><a href="#topic+gridSearch">gridSearch</a></code> and <code><a href="#topic+restartOpt">restartOpt</a></code>, and
may become an option for other functions.  Package
<span class="pkg">quadprog</span> is needed for a vignette
(<code>TAportfolio</code>), some tests, and it may be used for
computing mean-variance efficient portfolios.
Package <span class="pkg">Rglpk</span> is needed for function <code><a href="#topic+minCVaR">minCVaR</a></code>.
Package <span class="pkg">readxl</span> is needed to process the raw data in function
<code><a href="#topic+Shiller">Shiller</a></code>; package <span class="pkg">datetimeutils</span> is
used by <code><a href="#topic+French">French</a></code> and <code><a href="#topic+Shiller">Shiller</a></code>.
<span class="pkg">PMwR</span> would be needed to run the examples
of the backtesting examples in the NMOF book.
Finally, packages <span class="pkg">RUnit</span> and <span class="pkg">tinytest</span> are needed to
run the tests in subdirectory &lsquo;<code>unitTests</code>&rsquo;.
</p>
<p>Version numbering: package versions are numbered in the
form <code>major-minor-patch</code>.  The <em>patch</em> level is
incremented with any published change in a version.
<em>Minor</em> version numbers are incremented when a
feature is added or an existing feature is substantially
revised. (Such changes will be reported in the NEWS file.)
The <em>major</em> version number will only be increased if
there were a new edition of the book.
</p>
<p>The source code of the <span class="pkg">NMOF</span> package is also hosted at
<a href="https://github.com/enricoschumann/NMOF/">https://github.com/enricoschumann/NMOF/</a>.
Updates to the package and new features are described at
<a href="https://enricoschumann.net/notes/NMOF/">https://enricoschumann.net/notes/NMOF/</a>.
</p>


<h4>Optimisation</h4>

<p>There are functions for
Differential Evolution (<code><a href="#topic+DEopt">DEopt</a></code>),
Genetic Algorithms (<code><a href="#topic+GAopt">GAopt</a></code>),
(Stochastic) Local Search (<code><a href="#topic+LSopt">LSopt</a></code>),
Simuleated Annealing (<code><a href="#topic+SAopt">SAopt</a></code>),
Particle Swarm (<code><a href="#topic+SAopt">SAopt</a></code>),
and Threshold Accepting (<code><a href="#topic+TAopt">TAopt</a></code>).
The function <code><a href="#topic+restartOpt">restartOpt</a></code> helps with
running restarts of these methods;
also available are functions for
grid search (<code><a href="#topic+gridSearch">gridSearch</a></code>) and
greedy search (<code><a href="#topic+greedySearch">greedySearch</a></code>).
</p>



<h4>Pricing Financial Instruments</h4>

<p>For options: See <code><a href="#topic+vanillaOptionEuropean">vanillaOptionEuropean</a></code>,
<code><a href="#topic+vanillaOptionAmerican">vanillaOptionAmerican</a></code>, <code><a href="#topic+putCallParity">putCallParity</a></code>.
For pricing methods that use the characteristic function, see
<code><a href="#topic+callCF">callCF</a></code>.
</p>
<p>For bonds and bond futures: See <code><a href="#topic+vanillaBond">vanillaBond</a></code>,
<code><a href="#topic+bundFuture">bundFuture</a></code> and <code><a href="#topic+xtContractValue">xtContractValue</a></code>.
</p>



<h4>Simulation</h4>

<p>See <code><a href="#topic+resampleC">resampleC</a></code> and <code><a href="#topic+mc">mc</a></code>.
</p>



<h4>Data</h4>

<p>See <code><a href="#topic+bundData">bundData</a></code>, <code><a href="#topic+fundData">fundData</a></code> and
<code><a href="#topic+optionData">optionData</a></code>.
</p>



<h3>Author(s)</h3>

<p>Enrico Schumann
</p>
<p>Maintainer: Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("NMOF")

## overview
packageDescription("NMOF")
help(package = "NMOF")

## code from book
showExample("equations.R", edition = 1)
showExample("Heur")

## show NEWS file
news(Version &gt;= "2.0-0", package = "NMOF")

## vignettes
vignette(package = "NMOF")
nss &lt;- vignette("DEnss", package = "NMOF")
print(nss)
edit(nss)

## _book_ websites
browseURL("https://nmof.net")
browseURL("https://enricoschumann.net/NMOF/")

## _package_ websites
browseURL("https://enricoschumann.net/R/packages/NMOF/")
browseURL("https://cran.r-project.org/package=NMOF")
browseURL("https://git.sr.ht/~enricoschumann/NMOF")
browseURL("https://github.com/enricoschumann/NMOF")

## unit tests
file.show(system.file("unitTests/test_results.txt", package = "NMOF"))

## End(Not run)

test.rep &lt;- readLines(system.file("unitTests/test_results.txt",
                                  package = "NMOF"))
nt &lt;- gsub(".*\\(([0-9]+) checks?\\).*", "\\1",
           test.rep[grep("\\(\\d+ checks?\\)", test.rep)])
message("Number of unit tests: ", sum(as.numeric(nt)))
</code></pre>

<hr>
<h2 id='approxBondReturn'>
Approximate Total Return of Bond
</h2><span id='topic+approxBondReturn'></span>

<h3>Description</h3>

<p>Approximate the total return of a bond by its current yield,
duration and convexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxBondReturn(yield, tm, n = 2, scale = 1/250, pad = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxBondReturn_+3A_yield">yield</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="approxBondReturn_+3A_tm">tm</code></td>
<td>

<p>a numeric vector: time-to-maturity
</p>
</td></tr>
<tr><td><code id="approxBondReturn_+3A_n">n</code></td>
<td>

<p>number of coupon payments per period
</p>
</td></tr>
<tr><td><code id="approxBondReturn_+3A_scale">scale</code></td>
<td>

<p>how to scale yield; see Details
</p>
</td></tr>
<tr><td><code id="approxBondReturn_+3A_pad">pad</code></td>
<td>

<p>how to pad the first observation: <code>NULL</code> (default) means to
drop it; useful alternatives are <code><a href="base.html#topic+NA">NA</a></code> or <code>0</code>
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function approximates the total return of a bond investor,
based on changes in yield.  The computation is based on a
Taylor-series expansion.
See the references, in particular concerning the shortcomings
of the approximation:
</p>

<ol>
<li><p> approximation is based on par yield
</p>
</li>
<li><p> it relies on yield alone, so does not take into
account defaults; so for indices, the approximation should
only used for issuers without defaults
</p>
</li></ol>



<h3>Value</h3>

<p>a numeric vector, with attributes <code>duration</code> and <code>convexity</code>
</p>


<h3>Note</h3>

<p>Package <span class="pkg">treasuryTR</span> implements the method as well.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Swinkels, L. (2019). Treasury Bond Return Data Starting in 1962.
Data. <strong>4</strong> (3).
</p>
<p>Tuckman, B. and Serrat, A. (2012).
<em>Fixed Income Securities &ndash; Tools for Today's Markets</em>.
3rd edition. Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yield0 &lt;- 0.05
tm &lt;- 20
cf &lt;- c(rep(5, tm-1), 105)
duration(cf, 1:tm, yield0)

approxBondReturn(yield = c(yield0, 0.05), tm = tm, n = 1)
## ==&gt; no price change, current yield is earned

approxBondReturn(yield = c(yield0, 0.04), tm = tm, n = 1)
## ==&gt; current yield + price changed is earned
</code></pre>

<hr>
<h2 id='bracketing'>
Zero-Bracketing
</h2><span id='topic+bracketing'></span>

<h3>Description</h3>

<p>Bracket the zeros (roots) of a univariate function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bracketing(fun, interval, ...,
           lower = min(interval), upper = max(interval),
           n = 20L,
           method = c("loop", "vectorised", "multicore", "snow"),
           mc.control = list(), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bracketing_+3A_fun">fun</code></td>
<td>

<p>a univariate function; it will be called as <code>fun(x, ...)</code> with
<code>x</code> being a numeric vector</p>
</td></tr>
<tr><td><code id="bracketing_+3A_interval">interval</code></td>
<td>

<p>a numeric vector, containing the end-points of the interval to be searched
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>fun</code>
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_lower">lower</code></td>
<td>

<p>lower end-point. Ignored if <code>interval</code> is specified.
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_upper">upper</code></td>
<td>

<p>upper end-point. Ignored if <code>interval</code> is specified.
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_n">n</code></td>
<td>

<p>the number of function evaluations. Must be at least 2 (in which
case <code>fun</code> is evaluated only at the end-points); defaults to 20.
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_method">method</code></td>
<td>

<p>can be <code>loop</code> (the default), <code>vectorised</code>, <code>multicore</code>
or <code>snow</code>. See Details.
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_mc.control">mc.control</code></td>
<td>

<p>a list containing settings that will be passed to <code>mclapply</code> if
<code>method</code> is <code>multicore</code>. Must be a list of named
elements. See the documentation of <code>mclapply</code> in package <span class="pkg">parallel</span>.
</p>
</td></tr>
<tr><td><code id="bracketing_+3A_cl">cl</code></td>
<td>
<p>default is <code>NULL</code>. If <code>method</code> is <code>snow</code>, this must be a
cluster object or an integer (the number of cores to be used). See the
documentation of packages <span class="pkg">parallel</span> and <span class="pkg">snow</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bracketing</code> evaluates <code>fun</code> at equal-spaced
values of <code>x</code> between (and including) <code>lower</code> and
<code>upper</code>. If the sign of <code>fun</code> changes between two
consecutive <code>x</code>-values, <code>bracketing</code> reports these
two <code>x</code>-values as containing (&lsquo;bracketing&rsquo;) a
root. There is no guarantee that there is only one root
within a reported interval. <code>bracketing</code> will not
narrow the chosen intervals.
</p>
<p>The argument <code>method</code> determines how <code>fun</code> is
evaluated. Default is <code>loop</code>. If <code>method</code> is
<code>"vectorised"</code>, <code>fun</code> must be written such that it
can be evaluated for a vector <code>x</code> (see Examples). If
<code>method</code> is <code>multicore</code>, function <code>mclapply</code>
from package <span class="pkg">parallel</span> is used. Further settings for
<code>mclapply</code> can be passed through the list
<code>mc.control</code>. If <code>multicore</code> is chosen but the
functionality is not available (eg, currently on Windows),
then <code>method</code> will be set to <code>loop</code> and a warning
is issued. If <code>method</code> is <code>snow</code>, function
<code>clusterApply</code> from package <span class="pkg">parallel</span> is used. In
this case, the argument <code>cl</code> must either be a cluster
object (see the documentation of <code>clusterApply</code>) or an
integer. If an integer, a cluster will be set up via
<code>makeCluster(c(rep("localhost", cl)), type = "SOCK")</code>,
and <code>stopCluster</code> is called when the function is
exited. If <code>snow</code> is chosen but the package is not
available or <code>cl</code> is not specified, then <code>method</code>
will be set to <code>loop</code> and a warning is issued. In case
that <code>cl</code> is a cluster object, <code>stopCluster</code> will
not be called automatically.
</p>


<h3>Value</h3>


<p>A numeric matrix with two columns, named <em>lower</em> and
<em>upper</em>. Each row contains one interval that contains
at least one root. If no roots were found, the matrix has
zero rows.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> (in package <span class="pkg">stats</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gilli/Maringer/Schumann (2011), p. 290
testFun &lt;- function(x)
    cos(1/x^2)

bracketing(testFun, interval = c(0.3, 0.9), n = 26L)
bracketing(testFun, interval = c(0.3, 0.9), n = 26L, method = "vectorised")
</code></pre>

<hr>
<h2 id='bundData'>
German Government Bond Data
</h2><span id='topic+bundData'></span>

<h3>Description</h3>

<p>A sample of data on 44 German government bonds. Contains
<abbr><span class="acronym">ISIN</span></abbr>, coupon, maturity and dirty price as of 2010-05-31.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bundData</code></pre>


<h3>Format</h3>

<p><code>bundData</code> is a list with three components: <code>cfList</code>,
<code>tmList</code> and <code>bM</code>.
<code>cfList</code> is list of 44 numeric vectors (the cash
flows). <code>tmList</code> is a list of 44 character vectors (the payment dates)
formatted as <abbr><span class="acronym">YYYY</span></abbr>-<abbr><span class="acronym">MM</span></abbr>-<abbr><span class="acronym">DD</span></abbr>. <code>bM</code> is a
numeric vector with 44 elements (the dirty prices of the bonds).
</p>


<h3>Details</h3>

<p>All prices are as of 31 May 2010. See chapter 14 in Gilli et al. (2011).
</p>


<h3>Source</h3>

<p>The data was obtained from <a href="https://www.deutsche-finanzagentur.de/en/">https://www.deutsche-finanzagentur.de/en/</a>
. The data is also freely available from the website of the Bundesbank
<a href="https://www.bundesbank.de/en/">https://www.bundesbank.de/en/</a> .
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bundData
str(bundData)

## get ISINs of bonds
names(bundData$cfList)

## get a specific bond
thisBond &lt;- "DE0001135358"
data.frame(dates = as.Date(bundData$tmList[[thisBond]]),
           payments = bundData$cfList[[thisBond]])
</code></pre>

<hr>
<h2 id='bundFuture'>
Theoretical Valuation of Euro Bund Future
</h2><span id='topic+bundFuture'></span><span id='topic+bundFutureImpliedRate'></span>

<h3>Description</h3>

<p>Compute theoretical prices of bund future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bundFuture(clean, coupon, trade.date,
           expiry.date, last.coupon.date,
           r, cf)

bundFutureImpliedRate(future, clean, coupon,
                      trade.date, expiry.date,
                      last.coupon.date, cf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bundFuture_+3A_clean">clean</code></td>
<td>

<p>numeric: clean prices of CTD
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_future">future</code></td>
<td>

<p>numeric: price of future
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_coupon">coupon</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_trade.date">trade.date</code></td>
<td>

<p><code><a href="base.html#topic+Date">Date</a></code> or character in format <code>YYYY-MM-DD</code>
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_expiry.date">expiry.date</code></td>
<td>

<p><code><a href="base.html#topic+Date">Date</a></code> or character in format <code>YYYY-MM-DD</code>
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_last.coupon.date">last.coupon.date</code></td>
<td>

<p><code><a href="base.html#topic+Date">Date</a></code> or character in format <code>YYYY-MM-DD</code>
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_r">r</code></td>
<td>

<p>numeric: 0.01
</p>
</td></tr>
<tr><td><code id="bundFuture_+3A_cf">cf</code></td>
<td>

<p>numeric: conversion factor of CTD
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bundFuture</code> computes the theoretical prices of the Bund Future,
given the prices of the cheapest-to-deliver eligible government bond.
</p>
<p><code>bundFutureImpliedRate</code> computes the implied refinancing rate.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Bund-Future with expiry Sep 2017
## CTD: DE0001102408 -- 0%, 15 Aug 2026
##
## On 21 August 2017, the CTD traded (clean) at 97.769
## the FGBL Sep 2017 closed at 164.44.

bundFuture(clean = 97.769,                   ## DE0001102408
           coupon = 0,
           trade.date = "2017-8-21",
           expiry.date = "2017-09-07",       ## Bund expiry
           last.coupon.date = "2017-08-15",  ## last co
           r = -0.0037,
           cf = 0.594455)   ## conversion factor (from Eurex website)

bundFutureImpliedRate(future = 164.44,
                      clean = 97.769,
                      coupon = 0,
                      trade.date = "2017-8-21",
                      expiry.date = "2017-09-07",
                      last.coupon.date = "2017-08-15",
                      cf = 0.594455)
</code></pre>

<hr>
<h2 id='callCF'>Price a Plain-Vanilla Call with the Characteristic Function</h2><span id='topic+callCF'></span><span id='topic+cfBSM'></span><span id='topic+cfHeston'></span><span id='topic+cfBates'></span><span id='topic+cfMerton'></span><span id='topic+cfVG'></span>

<h3>Description</h3>

<p>Price a European plain-vanilla call with the characteric function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callCF(cf, S, X, tau, r, q = 0, ...,
       implVol = FALSE, uniroot.control = list(), uniroot.info = FALSE)
cfBSM(om, S, tau, r, q, v)
cfMerton(om, S, tau, r, q, v, lambda, muJ, vJ)
cfBates(om, S, tau, r, q, v0, vT, rho, k, sigma, lambda, muJ, vJ)
cfHeston(om, S, tau, r, q, v0, vT, rho, k, sigma)
cfVG(om, S, tau, r, q, nu, theta, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callCF_+3A_cf">cf</code></td>
<td>
<p>characteristic function</p>
</td></tr>
<tr><td><code id="callCF_+3A_s">S</code></td>
<td>
<p>spot</p>
</td></tr>
<tr><td><code id="callCF_+3A_x">X</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="callCF_+3A_tau">tau</code></td>
<td>
<p>time to maturity</p>
</td></tr>
<tr><td><code id="callCF_+3A_r">r</code></td>
<td>
<p>the interest rate</p>
</td></tr>
<tr><td><code id="callCF_+3A_q">q</code></td>
<td>
<p>the dividend rate</p>
</td></tr>
<tr><td><code id="callCF_+3A_...">...</code></td>
<td>
<p>arguments passed to the characteristic function</p>
</td></tr>
<tr><td><code id="callCF_+3A_implvol">implVol</code></td>
<td>
<p>logical: compute implied vol?</p>
</td></tr>
<tr><td><code id="callCF_+3A_uniroot.control">uniroot.control</code></td>
<td>
<p>A list. If there are elements named
<code>interval</code>, <code>tol</code> or <code>maxiter</code>, these are passed to
<code>uniroot</code>. Any other elements of the list are ignored.</p>
</td></tr>
<tr><td><code id="callCF_+3A_uniroot.info">uniroot.info</code></td>
<td>
<p>logical; default is <code>FALSE</code>. If <code>TRUE</code>,
the function will return the information returned by
<code>uniroot</code>. See paragraph Value below.</p>
</td></tr>
<tr><td><code id="callCF_+3A_om">om</code></td>
<td>
<p>a (usually complex) argument</p>
</td></tr>
<tr><td><code id="callCF_+3A_v0">v0</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_vt">vT</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_v">v</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_rho">rho</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_k">k</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_sigma">sigma</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_muj">muJ</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_vj">vJ</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_nu">nu</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
<tr><td><code id="callCF_+3A_theta">theta</code></td>
<td>
<p>a numeric vector of length one</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the value of a plain vanilla European call under
different models, using the representation of Bakshi/Madan. Put values
can be computed through put&ndash;call parity (see
<code><a href="#topic+putCallParity">putCallParity</a></code>).
</p>
<p>If <code>implVol</code> is <code>TRUE</code>, the function will compute the
implied volatility necessary to obtain the same value under
Black&ndash;Scholes&ndash;Merton. The implied volatility is computed with
<code><a href="stats.html#topic+uniroot">uniroot</a></code> from the <span class="pkg">stats</span> package. The default search
interval is <code>c(0.00001, 2)</code>; it can be changed through
<code>uniroot.control</code>.
</p>
<p>The function uses variances as inputs (not volatilities).
</p>
<p>The function is not vectorised (but see the NMOF Manual for examples
of how to efficiently price more than one option at once).
</p>


<h3>Value</h3>

<p>Returns the value of the call (numeric) under the respective model or,
if <code>implVol</code> is <code>TRUE</code>, a list of the value and the implied
volatility. (If, in addition, <code>uniroot.info</code> is <code>TRUE</code>, the
information provided by <code><a href="stats.html#topic+uniroot">uniroot</a></code> is also returned.)
</p>


<h3>Note</h3>

<p>If <code>implVol</code> is <code>TRUE</code>, the function will return a list with
elements named <code>value</code> and <code>impliedVol</code>. Prior to version
0.26-3, the first element was named <code>callPrice</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Bates, David S. (1996) Jumps and Stochastic Volatility: Exchange Rate
Processes Implicit in Deutsche Mark Options. <em>Review of
Financial Studies</em> <strong>9</strong> (1), 69&ndash;107.
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Heston, S.L. (1993) A Closed-Form Solution for Options with Stochastic
Volatility with Applications to Bonds and Currency options.
<em>Review of Financial Studies</em> <strong>6</strong> (2), 327&ndash;343.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callHestoncf">callHestoncf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- 100; X &lt;- 100; tau &lt;- 1
r &lt;- 0.02; q &lt;- 0.08
v0 &lt;- 0.2^2  ## variance, not volatility
vT &lt;- 0.2^2  ## variance, not volatility
v &lt;- vT
rho &lt;- -0.3; k &lt;- .2
sigma &lt;- 0.3

## jump parameters (Merton and Bates)
lambda &lt;- 0.1
muJ &lt;- -0.2
vJ &lt;- 0.1^2

## get Heston price and BSM implied volatility
callHestoncf(S, X, tau, r, q, v0, vT, rho, k, sigma, implVol = FALSE)
callCF(cf = cfHeston, S=S, X=X, tau=tau, r=r, q = q,
       v0 = v0, vT = vT, rho = rho, k = k, sigma = sigma, implVol = FALSE)

## Black-Scholes-Merton
callCF(cf = cfBSM, S=S, X=X, tau = tau, r = r, q = q,
       v = v, implVol = TRUE)

## Bates
callCF(cf = cfBates, S = S, X = X, tau = tau, r = r, q = q,
       v0 = v0, vT = vT, rho = rho, k = k, sigma = sigma,
       lambda = lambda, muJ = muJ, vJ = vJ, implVol = FALSE)

## Merton
callCF(cf = cfMerton, S = S, X = X, tau = tau, r = r, q = q,
       v = v, lambda = lambda, muJ = muJ, vJ = vJ, implVol = FALSE)

## variance gamma
nu &lt;- 0.1; theta &lt;- -0.1; sigma &lt;- 0.15
callCF(cf = cfVG, S = S, X = X, tau = tau, r = r, q = q,
       nu = nu, theta = theta, sigma = sigma, implVol = FALSE)
</code></pre>

<hr>
<h2 id='callHestoncf'>
Price of a European Call under the Heston Model
</h2><span id='topic+callHestoncf'></span>

<h3>Description</h3>

<p>Computes the price of a European Call under the Heston model (and the
equivalent Black&ndash;Scholes&ndash;Merton volatility)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callHestoncf(S, X, tau, r, q, v0, vT, rho, k, sigma, implVol = FALSE,
             ...,
             uniroot.control = list(), uniroot.info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callHestoncf_+3A_s">S</code></td>
<td>
<p>current stock price</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_x">X</code></td>
<td>
<p>strike price</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_tau">tau</code></td>
<td>
<p>time to maturity</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_r">r</code></td>
<td>
<p>risk-free rate</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_q">q</code></td>
<td>
<p>dividend rate</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_v0">v0</code></td>
<td>
<p>current variance</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_vt">vT</code></td>
<td>
<p>long-run variance (theta in Heston's paper)</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_rho">rho</code></td>
<td>
<p>correlation between spot and variance</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_k">k</code></td>
<td>
<p>speed of mean-reversion (kappa in Heston's paper)</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_sigma">sigma</code></td>
<td>
<p>volatility of variance. A value smaller
than 0.01 is replaced with 0.01.</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_implvol">implVol</code></td>
<td>
<p>compute equivalent Black&ndash;Scholes&ndash;Merton
volatility? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_...">...</code></td>
<td>
<p>named arguments, passed to <code><a href="stats.html#topic+integrate">integrate</a></code></p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_uniroot.control">uniroot.control</code></td>
<td>
<p>A list. If there are elements named
<code>interval</code>, <code>tol</code> or <code>maxiter</code>, these are passed to
<code>uniroot</code>. Other elements of the list are ignored.</p>
</td></tr>
<tr><td><code id="callHestoncf_+3A_uniroot.info">uniroot.info</code></td>
<td>
<p>logical; default is <code>FALSE</code>.
If <code>TRUE</code>, the function will return the information
returned by <code>uniroot</code>. See section Value below.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function computes the value of a plain vanilla
European call under the Heston model. Put values can be
computed through put&ndash;call-parity.
</p>
<p>If <code>implVol</code> is <code>TRUE</code>, the function will
compute the implied volatility necessary to obtain the
same price under Black&ndash;Scholes&ndash;Merton. The implied
volatility is computed with <code><a href="stats.html#topic+uniroot">uniroot</a></code> from
the <span class="pkg">stats</span> package (the default search interval is
<code>c(0.00001, 2)</code>; it can be changed through
<code>uniroot.control</code>).
</p>
<p>Note that the function takes variances as inputs (not
volatilities).
</p>


<h3>Value</h3>


<p>Returns the value of the call (numeric) under the Heston
model or, if <code>implVol</code> is <code>TRUE</code>, a list of the
value and the implied volatility. If <code>uniroot.info</code>
is <code>TRUE</code>, then instead of only the computed
volatility, the complete output of <code><a href="stats.html#topic+uniroot">uniroot</a></code>
is included in the result.
</p>


<h3>Note</h3>


<p>If <code>implVol</code> is <code>TRUE</code>, the function will
return a list with elements named <code>value</code> and
<code>impliedVol</code>. Prior to version 0.26-3, the first
element was named <code>callPrice</code>.
</p>


<h3>Author(s)</h3>


<p>Enrico Schumann
</p>


<h3>References</h3>


<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Heston, S.L. (1993) A Closed-Form Solution for Options
with Stochastic Volatility with Applications to Bonds
and Currency options. <em>Review of Financial Studies</em>
<strong>6</strong>(2), 327&ndash;343.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callCF">callCF</a></code>, <code><a href="#topic+EuropeanCall">EuropeanCall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- 100; X &lt;- 100; tau &lt;- 1; r &lt;- 0.02; q &lt;- 0.01
v0  &lt;- 0.2^2  ## variance, not volatility
vT  &lt;- 0.2^2  ## variance, not volatility
rho &lt;- -0.7; k &lt;- 0.2; sigma &lt;- 0.5

## get Heston price and BSM implied volatility
result &lt;- callHestoncf(S = S, X = X, tau = tau, r = r, q = q,
                       v0 = v0, vT = vT, rho = rho, k = k,
                       sigma = sigma, implVol = TRUE)

## Heston price
result[[1L]]

## price BSM with implied volatility
vol &lt;- result[[2L]]
d1 &lt;- (log(S/X) + (r - q + vol^2 / 2)*tau) / (vol*sqrt(tau))
d2 &lt;- d1 - vol*sqrt(tau)
callBSM &lt;- S * exp(-q * tau) * pnorm(d1) -
           X * exp(-r * tau) * pnorm(d2)
callBSM  ## should be (about) the same as result[[1L]]
</code></pre>

<hr>
<h2 id='callMerton'>
Price of a European Call under Merton's Jump&ndash;Diffusion Model
</h2><span id='topic+callMerton'></span>

<h3>Description</h3>

<p>Computes the price of a European Call under Merton's jump&ndash;diffusion
model (and the equivalent Black&ndash;Scholes&ndash;Merton volatility)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callMerton(S, X, tau, r, q, v, lambda, muJ, vJ, N, implVol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callMerton_+3A_s">S</code></td>
<td>
<p>current stock price</p>
</td></tr>
<tr><td><code id="callMerton_+3A_x">X</code></td>
<td>
<p>strike price</p>
</td></tr>
<tr><td><code id="callMerton_+3A_tau">tau</code></td>
<td>
<p>time to maturity</p>
</td></tr>
<tr><td><code id="callMerton_+3A_r">r</code></td>
<td>
<p>risk-free rate</p>
</td></tr>
<tr><td><code id="callMerton_+3A_q">q</code></td>
<td>
<p>dividend rate</p>
</td></tr>
<tr><td><code id="callMerton_+3A_v">v</code></td>
<td>
<p>variance</p>
</td></tr>
<tr><td><code id="callMerton_+3A_lambda">lambda</code></td>
<td>
<p>jump intensity</p>
</td></tr>
<tr><td><code id="callMerton_+3A_muj">muJ</code></td>
<td>
<p>mean jump-size</p>
</td></tr>
<tr><td><code id="callMerton_+3A_vj">vJ</code></td>
<td>
<p>variance of log jump-size</p>
</td></tr>
<tr><td><code id="callMerton_+3A_n">N</code></td>
<td>
<p>The number of jumps.  See Details.</p>
</td></tr>
<tr><td><code id="callMerton_+3A_implvol">implVol</code></td>
<td>
<p>compute equivalent Black&ndash;Scholes&ndash;Merton volatility?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the value of a plain-vanilla European call under
Merton's jump&ndash;diffusion model.  Put values can be computed through
put&ndash;call-parity (see <code><a href="#topic+putCallParity">putCallParity</a></code>).  If <code>implVol</code>
is <code>TRUE</code>, the function also computes the implied volatility
necessary to obtain the same price under Black&ndash;Scholes&ndash;Merton.  The
implied volatility is computed with <code><a href="stats.html#topic+uniroot">uniroot</a></code> from the
<span class="pkg">stats</span> package.
</p>
<p>Note that the function takes variances as inputs (not volatilities).
</p>
<p>The number of jumps <code>N</code> typically can be set 10 or 20. (Just try to
increase <code>N</code> and see how the results change.)
</p>


<h3>Value</h3>

<p>Returns the value of the call (numeric) or, if <code>implVol</code> is
<code>TRUE</code>, a list of the value and the implied volatility.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Merton, R.C. (1976) Option Pricing when Underlying Stock Returns are
Discontinuous. <em>Journal of Financial Economics</em> <strong>3</strong>(1&ndash;2),
125&ndash;144.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callCF">callCF</a></code>, <code><a href="#topic+EuropeanCall">EuropeanCall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- 100; X &lt;- 100; tau &lt;- 1
r &lt;- 0.0075; q &lt;- 0.00
v &lt;- 0.2^2
lambda &lt;- 1; muJ &lt;- -0.2; vJ &lt;- 0.6^2
N &lt;- 20

## jumps can make a difference
callMerton(S, X, tau, r, q, v, lambda, muJ, vJ, N, implVol = TRUE)
callCF(cf = cfMerton, S = S, X = X, tau = tau, r = r, q = q,
       v = v, lambda = lambda, muJ = muJ, vJ = vJ, implVol = TRUE)
vanillaOptionEuropean(S,X,tau,r,q,v, greeks = FALSE)

lambda &lt;- 0 ## no jumps
callMerton(S, X, tau, r, q, v, lambda, muJ, vJ, N, implVol = FALSE)
vanillaOptionEuropean(S,X,tau,r,q,v, greeks = FALSE)

lambda &lt;- 1; muJ &lt;- 0; vJ &lt;- 0.0^2  ## no jumps, either
callMerton(S, X, tau, r, q, v, lambda, muJ, vJ, N, implVol = FALSE)
vanillaOptionEuropean(S,X,tau,r,q,v, greeks = FALSE)

</code></pre>

<hr>
<h2 id='colSubset'>
Full-rank Column Subset
</h2><span id='topic+colSubset'></span>

<h3>Description</h3>

<p>Select a full-rank subset of columns of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colSubset(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colSubset_+3A_x">x</code></td>
<td>

<p>a numeric matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="base.html#topic+qr">qr</a></code>.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>columns</code></td>
<td>
<p>indices of columns</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repairMatrix">repairMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc &lt;- 3   ## columns
nr &lt;- 10  ## rows
M &lt;- array(rnorm(nr * nc), dim = c(nr, nc))

C &lt;- array(0.5, dim = c(nc, nc))
diag(C) &lt;- 1
M &lt;- M %*% chol(C)
M &lt;- M[ ,c(1,1,1,2,3)]
M

(tmp &lt;- colSubset(M))

C &lt;- cor(M[ ,tmp$columns])
nc &lt;- ncol(C)
nr &lt;- 100
X &lt;- array(rnorm(nr*nc), dim = c(nr, nc))
X &lt;- X %*% chol(C)
X &lt;- X %*% tmp$multiplier
head(X)
cor(X)
</code></pre>

<hr>
<h2 id='CPPI'>
Constant-Proportion Portfolio Insurance
</h2><span id='topic+CPPI'></span>

<h3>Description</h3>

<p>Simulate constant-proportion portfolio insurance
(CPPI) for a given price path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPPI(S, multiplier, floor, r, tau = 1, gap = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPPI_+3A_s">S</code></td>
<td>

<p>numeric: price path of risky asset
</p>
</td></tr>
<tr><td><code id="CPPI_+3A_multiplier">multiplier</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="CPPI_+3A_floor">floor</code></td>
<td>

<p>numeric: a percentage, should be smaller than 1
</p>
</td></tr>
<tr><td><code id="CPPI_+3A_r">r</code></td>
<td>

<p>numeric: interest rate (per time period tau)
</p>
</td></tr>
<tr><td><code id="CPPI_+3A_tau">tau</code></td>
<td>

<p>numeric: time periods
</p>
</td></tr>
<tr><td><code id="CPPI_+3A_gap">gap</code></td>
<td>

<p>numeric: how often to rebalance. 1 means every
timestep, 2 means every second timestep, and so on.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Dietmar Maringer's MATLAB code (function
CPPIgap, Listing 9.1).
</p>
<p>See Gilli, Maringer and Schumann, 2011, chapter 9.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>V</code></td>
<td>
<p>normalised value (always starts at 1)</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>cushion</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>bond investment</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>floor</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>exposure</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>units of risky asset</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>price path</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Original MATLAB code: Dietmar Maringer. <span class="rlang"><b>R</b></span>
implementation: Enrico Schumann.
</p>


<h3>References</h3>

<p>Chapter 9 of Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau &lt;- 2
S &lt;- gbm(npaths = 1, timesteps = tau*256,
         r = 0.02, v = 0.2^2, tau = tau, S0 = 100)

## rebalancing every day
sol &lt;- CPPI(S, multiplier = 5, floor = 0.9, r = 0.01,
            tau = tau, gap = 1)
par(mfrow = c(3,1), mar = c(3,3,1,1))
plot(0:(length(S)-1), S,     type = "s", main = "stock price")
plot(0:(length(S)-1), sol$V, type = "s", main = "value")
plot(0:(length(S)-1), 100*sol$E/sol$V, type = "s",
     main = "% invested in risky asset")

## rebalancing every 5th day
sol &lt;- CPPI(S, multiplier = 5, floor = 0.9, r = 0.01,
            tau = tau, gap = 5)
par(mfrow = c(3,1), mar = c(3,3,1,1))
plot(0:(length(S)-1), S,     type = "s", main = "stock price")
plot(0:(length(S)-1), sol$V, type = "s", main = "value")
plot(0:(length(S)-1), 100*sol$E/sol$V, type = "s",
     main = "% invested in risky asset")
</code></pre>

<hr>
<h2 id='DEopt'>
Optimisation with Differential Evolution
</h2><span id='topic+DEopt'></span>

<h3>Description</h3>

<p>The function implements the standard Differential Evolution algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEopt(OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DEopt_+3A_of">OF</code></td>
<td>
<p>The objective function, to be minimised. See Details.
</p>
</td></tr>
<tr><td><code id="DEopt_+3A_algo">algo</code></td>
<td>
<p>A list with the settings for algorithm. See Details and Examples.
</p>
</td></tr>
<tr><td><code id="DEopt_+3A_...">...</code></td>
<td>
<p>Other pieces of data required to evaluate the objective function. See Details and Examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the standard Differential Evolution (no
jittering or other features). Differential Evolution (<abbr><span class="acronym">DE</span></abbr>) is
a population-based optimisation heuristic proposed by Storn and Price
(1997). <abbr><span class="acronym">DE</span></abbr> evolves several solutions (collected in the
&lsquo;population&rsquo;) over a number of iterations
(&lsquo;generations&rsquo;). In a given generation, new solutions are
created and evaluated; better solutions replace inferior ones in the
population. Finally, the best solution of the population is
returned. See the references for more details on the mechanisms.
</p>
<p>To allow for constraints, the evaluation works as follows: after a new
solution is created, it is (i) repaired, (ii) evaluated through the
objective function, (iii) penalised. Step (ii) is done by a call to
<code>OF</code>; steps (i) and (iii) by calls to <code>algo$repair</code> and
<code>algo$pen</code>. Step (i) and (iii) are optional, so the respective
functions default to <code>NULL</code>. A penalty is a positive number added
to the &lsquo;clean&rsquo; objective function value, so it can also be
directly written in the <code>OF</code>. Writing a separate penalty function
is often clearer; it can be more efficient if either only the objective
function or only the penalty function can be vectorised.  (Constraints
can also be added without these mechanisms. Solutions that violate
constraints can, for instance, be mapped to feasible solutions, but
without actually changing them. See Maringer and Oyewumi, 2007, for an
example.)
</p>
<p>Conceptually, <abbr><span class="acronym">DE</span></abbr> consists of two loops: one loop across the
generations and, in any given generation, one loop across the solutions.
<code>DEopt</code> indeed uses, as the default, two loops. But it does not
matter in what order the solutions are evaluated (or repaired or
penalised), so the second loop can be vectorised. This is controlled by
the variables <code>algo$loopOF</code>, <code>algo$loopRepair</code> and
<code>algo$loopPen</code>, which all default to <code>TRUE</code>. Examples are
given in the vignettes and in the book. The respective
<code>algo$loopFun</code> must then be set to <code>FALSE</code>.
</p>
<p>All objects that are passed through <code>...</code> will be passed to the
objective function, to the repair function and to the penalty function.
</p>
<p>The list <code>algo</code> collects the the settings for the
algorithm. Strictly necessary are only <code>min</code> and <code>max</code> (to
initialise the population). Here are all possible arguments:
</p>

<dl>
<dt><code>CR</code></dt><dd><p>probability for crossover. Defaults to 0.9. Using
default settings may not be a good idea.</p>
</dd>
<dt><code>F</code></dt><dd><p>The step size. Typically a numeric vector of length
one; default is 0.5. Using default settings may not be a good
idea. (<code>F</code> can also be a vector with different values for
each decision variable.)</p>
</dd>
<dt><code>nP</code></dt><dd><p>population size. Defaults to 50. Using default
settings may not be a good idea.</p>
</dd>
<dt><code>nG</code></dt><dd><p>number of generations. Defaults to 300. Using
default settings may not be a good idea.</p>
</dd>
<dt><code>min</code>, <code>max</code></dt><dd><p>vectors of minimum and maximum
parameter values. The vectors <code>min</code> and <code>max</code> are used
to determine the dimension of the problem and to randomly
initialise the population. Per default, they are no constraints: a
solution may well be outside these limits. Only if
<code>algo$minmaxConstr</code> is <code>TRUE</code> will the algorithm repair
solutions outside the <code>min</code> and <code>max</code> range.</p>
</dd>
<dt><code>minmaxConstr</code></dt><dd><p>if <code>TRUE</code>, <code>algo$min</code> and
<code>algo$max</code> are considered constraints. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>pen</code></dt><dd><p>a penalty function. Default is <code>NULL</code> (no penalty).</p>
</dd>
<dt><code>initP</code></dt><dd><p>optional: the initial population. A matrix of size
<code>length(algo$min)</code> times <code>algo$nP</code>, or a function that
creates such a matrix. If a function, it should take no arguments.</p>
</dd>
<dt><code>repair</code></dt><dd><p>a repair function. Default is <code>NULL</code> (no
repairing).</p>
</dd>
<dt><code>loopOF</code></dt><dd><p>logical. Should the <code>OF</code> be evaluated
through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopPen</code></dt><dd><p>logical. Should the penalty function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopRepair</code></dt><dd><p>logical. Should the repair function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information
is printed. If an integer <code>i</code> greater then one, information
is printed at very <code>i</code>th generation.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (the default), a
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> is printed.</p>
</dd>
<dt><code>storeF</code></dt><dd><p>if <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>default is <code>FALSE</code>. If
<code>TRUE</code>, the solutions (ie, decision variables) in every
generation are stored and returned as a list <code>P</code> in list
<code>xlist</code> (see Value section below). To check, for instance,
the solutions at the end of the <code>i</code>th generation, retrieve
<code>xlist[[c(1L, i)]]</code>. This will be a matrix of size
<code>length(algo$min)</code> times <code>algo$nP</code>.  (To be consistent
with other functions, <code>xlist</code> is itself a list. In the case
of <code>DEopt</code>, it contains just one element.)</p>
</dd>
<dt><code>classify</code></dt><dd><p>Logical; default is <code>FALSE</code>. If
<code>TRUE</code>, the result will have a class attribute <code>TAopt</code>
attached. This feature is <strong>experimental</strong>: the supported
methods may change without warning.</p>
</dd>
<dt><code>drop</code></dt><dd>
<p>If <code>FALSE</code> (the default), the dimension is
not dropped from a single solution when it is
passed to a function. (That is, the function will
receive a single-column matrix.)
</p>
</dd>
</dl>
 


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>the solution (the best member of the population), which is
a numeric vector</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value of best solution</p>
</td></tr>
<tr><td><code>popF</code></td>
<td>
<p>a vector. The objective function values in the final population.</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>if <code>algo$storeF</code> is <code>TRUE</code>, a matrix of size
<code>algo$nG</code> times <code>algo$nP</code> containing the objective function
values of all solutions over the generations; else <code>NA</code>.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a list that
contains a list <code>P</code> of matrices and a matrix <code>initP</code> (the
initial solution); else <code>NA</code>.</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when the function was called.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Maringer, D. and Oyewumi, O. (2007). Index Tracking with Constrained
Portfolios. <em>Intelligent Systems in Accounting, Finance and Management</em>,
<b>15</b>(1), pp. 57&ndash;71.
</p>
<p>Schumann, E. (2012) Remarks on 'A comparison of some
heuristic optimization methods'.
<a href="https://enricoschumann.net/R/remarks.htm">https://enricoschumann.net/R/remarks.htm</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Storn, R., and Price, K. (1997) Differential Evolution &ndash; a Simple and
Efficient Heuristic for Global Optimization over Continuous Spaces.
<em>Journal of Global Optimization</em>, <b>11</b>(4), pp. 341&ndash;359.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GAopt">GAopt</a></code>, <code><a href="#topic+PSopt">PSopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Trefethen's 100-digit challenge (problem 4)
## https://people.maths.ox.ac.uk/trefethen/hundred.html

OF &lt;- tfTrefethen               ### see ?testFunctions
algo &lt;- list(nP = 50L,          ### population size
             nG = 300L,         ### number of generations
              F = 0.6,          ### step size
             CR = 0.9,          ### prob of crossover
            min = c(-10, -10),  ### range for initial population
            max = c( 10,  10))

sol &lt;- DEopt(OF = OF, algo = algo)
## correct answer: -3.30686864747523
format(sol$OFvalue, digits = 12)
## check convergence of population
sd(sol$popF)
ts.plot(sol$Fmat, xlab = "generations", ylab = "OF")


## Example 2: vectorising the evaluation of the population
OF &lt;- tfRosenbrock     ### see ?testFunctions
size &lt;- 3L             ### define dimension
x &lt;- rep.int(1, size)  ### the known solution ...
OF(x)                  ### ... should give zero

algo &lt;- list(printBar = FALSE,
                   nP = 30L,
                   nG = 300L,
                    F = 0.6,
                   CR = 0.9,
                  min = rep(-100, size),
                  max = rep( 100, size))

## run DEopt
(t1 &lt;- system.time(sol &lt;- DEopt(OF = OF, algo = algo)))
sol$xbest
sol$OFvalue  ### should be zero (with luck)

## a vectorised Rosenbrock function: works only with a *matrix* x
OF2 &lt;- function(x) {
    n &lt;- dim(x)[1L]
    xi &lt;- x[seq_len(n - 1L), ]
    colSums(100 * (x[2L:n, ] - xi * xi)^2 + (1 - xi)^2)
}

## random solutions (every column of 'x' is one solution)
x &lt;- matrix(rnorm(size * algo$nP), size, algo$nP)
all.equal(OF2(x)[1:3],
          c(OF(x[ ,1L]), OF(x[ ,2L]), OF(x[ ,3L])))

## run DEopt and compare computing time
algo$loopOF &lt;- FALSE
(t2 &lt;- system.time(sol2 &lt;- DEopt(OF = OF2, algo = algo)))
sol2$xbest
sol2$OFvalue       ### should be zero (with luck)
t1[[3L]]/t2[[3L]]  ### speedup
</code></pre>

<hr>
<h2 id='divRatio'>
Diversification Ratio
</h2><span id='topic+divRatio'></span>

<h3>Description</h3>

<p>Compute the diversification ratio of a portfolio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divRatio(w, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divRatio_+3A_w">w</code></td>
<td>

<p>numeric: a vector of weights
</p>
</td></tr>
<tr><td><code id="divRatio_+3A_var">var</code></td>
<td>

<p>numeric matrix: the variance&ndash;covariance matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides an efficient implementation of
the diversification ratio, suitable for optimisation.
</p>


<h3>Value</h3>

<p>a numeric vector of length one
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Yves Choueifaty and Yves Coignard (2008) Toward Maximum
Diversification.
<em>Journal of Portfolio Management</em> <strong>35</strong>(1), 40&ndash;51.
</p>


<h3>See Also</h3>

<p><code>pm</code>, <code>drawdown</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na  &lt;- 10     ## number of assets
rho &lt;- 0.5    ## correlation
v_min &lt;- 0.2  ## minimum vol
v_max &lt;- 0.4  ## maximum vol

## set up a covariance matrix S
C &lt;- array(rho, dim = c(na,na))
diag(C) &lt;- 1
vols &lt;- seq(v_min, v_max, length.out = na)
S &lt;- outer(vols, vols) * C

w &lt;- rep(1/na, na)  ## weights
divRatio(w, S)

</code></pre>

<hr>
<h2 id='drawdown'>
Drawdown
</h2><span id='topic+drawdown'></span>

<h3>Description</h3>

<p>Compute the drawdown of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  drawdown(v, relative = TRUE, summary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawdown_+3A_v">v</code></td>
<td>

<p>a price series (a numeric vector)
</p>
</td></tr>
<tr><td><code id="drawdown_+3A_relative">relative</code></td>
<td>

<p>if <code>TRUE</code>, maximum drawdown is chosen according to percentage
losses; else in units of <code>v</code>
</p>
</td></tr>
<tr><td><code id="drawdown_+3A_summary">summary</code></td>
<td>

<p>if <code>TRUE</code>, provide maximum drawdown and time when it occured;
else return drawdown vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The drawdown at position <em>t</em> of a time series <em>v</em> is the
difference between the highest peak that was reached before <em>t</em>
and the current value.  If the current value represents a new high,
the drawdown is zero.
</p>


<h3>Value</h3>

<p>If <code>summary</code> is <code>FALSE</code>, a vector of the same length as
<code>v</code>.  If <code>summary</code> is <code>TRUE</code>, a list
</p>
<table role = "presentation">
<tr><td><code>maximum</code></td>
<td>
<p>maximum drawdown</p>
</td></tr>
<tr><td><code>high</code></td>
<td>
<p>the max of <code>v</code></p>
</td></tr>
<tr><td><code>high.position</code></td>
<td>
<p>position of <code>high</code></p>
</td></tr>
<tr><td><code>low</code></td>
<td>
<p>the min of <code>v</code></p>
</td></tr>
<tr><td><code>low.position</code></td>
<td>
<p>position of <code>low</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="PMwR.html#topic+drawdowns">drawdowns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- cumprod(1 + rnorm(20) * 0.02)
drawdown(v)
</code></pre>

<hr>
<h2 id='EuropeanCall'>
Computing Prices of European Calls with a Binomial Tree
</h2><span id='topic+EuropeanCall'></span><span id='topic+EuropeanCallBE'></span>

<h3>Description</h3>

<p>Computes the fair value of a European Call with the binomial tree of
Cox, Ross and Rubinstein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EuropeanCall(S0, X, r, tau, sigma, M = 101)
EuropeanCallBE(S0, X, r, tau, sigma, M = 101)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EuropeanCall_+3A_s0">S0</code></td>
<td>
<p>current stock price</p>
</td></tr>
<tr><td><code id="EuropeanCall_+3A_x">X</code></td>
<td>
<p>strike price</p>
</td></tr>
<tr><td><code id="EuropeanCall_+3A_r">r</code></td>
<td>
<p>risk-free rate</p>
</td></tr>
<tr><td><code id="EuropeanCall_+3A_tau">tau</code></td>
<td>
<p>time to maturity</p>
</td></tr>
<tr><td><code id="EuropeanCall_+3A_sigma">sigma</code></td>
<td>
<p>volatility</p>
</td></tr>
<tr><td><code id="EuropeanCall_+3A_m">M</code></td>
<td>
<p>number of time steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prices a European Call with the tree approach of Cox, Ross, Rubinstein.
</p>
<p>The algorithm in <code>EuropeanCallBE</code> does not construct and traverse a
tree, but computes the terminal prices via a binomial expansion (see
Higham, 2002, and Chapter 5 in Gilli/Maringer/Schumann, 2011).
</p>


<h3>Value</h3>

<p>Returns the value of the call (<code>numeric</code>).
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>M. Gilli and Schumann, E. (2009) Implementing Binomial
Trees. <abbr><span class="acronym">COMISEF</span></abbr> Working Paper Series No. 008.
<a href="https://enricoschumann.net/COMISEF/wps008.pdf">https://enricoschumann.net/COMISEF/wps008.pdf</a>
</p>
<p>Higham, D. (2002) Nine Ways to Implement the Binomial Method for Option
Valuation in MATLAB. <em>SIAM Review</em>, <b>44</b>(4), pp. 661&ndash;677.
<a href="https://doi.org/10.1137/S0036144501393266">doi:10.1137/S0036144501393266</a> .
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callHestoncf">callHestoncf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## price
EuropeanCall(  S0 = 100, X = 100, r = 0.02, tau = 1, sigma = 0.20, M = 50)
EuropeanCallBE(S0 = 100, X = 100, r = 0.02, tau = 1, sigma = 0.20, M = 50)

## a Greek: delta
h &lt;- 1e-8
C1 &lt;- EuropeanCall(S0 = 100 + h, X = 100, r = 0.02, tau = 1,
                   sigma = 0.20, M = 50)
C2 &lt;- EuropeanCall(S0 = 100    , X = 100, r = 0.02, tau = 1,
                   sigma = 0.20, M = 50)
(C1 - C2) / h
</code></pre>

<hr>
<h2 id='French'>
Download Datasets from Kenneth French's Data Library
</h2><span id='topic+French'></span>

<h3>Description</h3>

<p>Download datasets from Kenneth French's Data Library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>French(dest.dir,
       dataset = "F-F_Research_Data_Factors_CSV.zip",
       weighting = "value", frequency = "monthly",
       price.series = FALSE, na.rm = FALSE,
       adjust.frequency = TRUE,
       return.class = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="French_+3A_dest.dir">dest.dir</code></td>
<td>

<p>string: a path to a directory
</p>
</td></tr>
<tr><td><code id="French_+3A_dataset">dataset</code></td>
<td>

<p>a character string: the CSV file name. Also supported
are the keywords &lsquo;<code>market</code>&rsquo; and
&lsquo;<code>rf</code>&rsquo;.
</p>
</td></tr>
<tr><td><code id="French_+3A_weighting">weighting</code></td>
<td>

<p>a character string: <code>"equal"</code> or <code>"value"</code>
</p>
</td></tr>
<tr><td><code id="French_+3A_frequency">frequency</code></td>
<td>

<p>a character string: <code>daily</code>, <code>monthly</code> or
<code>annual</code>. Whether it is used or ignored depends
on the particular dataset.
</p>
</td></tr>
<tr><td><code id="French_+3A_price.series">price.series</code></td>
<td>

<p>logical: convert the returns series into prices
series?
</p>
</td></tr>
<tr><td><code id="French_+3A_na.rm">na.rm</code></td>
<td>

<p>logical: remove missing values in the calculation
of price series?
</p>
</td></tr>
<tr><td><code id="French_+3A_adjust.frequency">adjust.frequency</code></td>
<td>

<p>logical: if <code>TRUE</code>, frequency is switched to
&lsquo;<code>"daily"</code>&rsquo; when the word
&lsquo;<code>"daily"</code>&rsquo; appears in the dataset's name
</p>
</td></tr>
<tr><td><code id="French_+3A_return.class">return.class</code></td>
<td>

<p>a string: &lsquo;<code>data.frame</code>&rsquo; (the default) or
&lsquo;<code>zoo</code>&rsquo;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function downloads data provided by Kenneth French at
<a href="https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>.
The download file gets a date prefix (current date in
format <code>YYYYMMDD</code>) and is stored in directory
<code>dest.dir</code>. Before any download is attempted, the
function checks whether a file with today's prefix exist
in <code>dest.dir</code>; if yes, the file is used.
</p>
<p>In the original data files, missing values are coded as
<code>-99</code> or similar. These numeric values are replaced
by <code><a href="base.html#topic+NA">NA</a></code>.
</p>
<p>Calling the function without any arguments will print the
names of the supported datasets (and return them
insivibly).
</p>
<p>For dataset &lsquo;<code>market</code>&rsquo;, the function downloads
the three-factor dataset, and adds excess return and
risk-free rate.  For dataset &lsquo;<code>rf</code>&rsquo;, only the
risk-free rate is returned.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>, with contents depending on
the particular dataset, or an object as specified by
<code>return.class</code>.
</p>
<p>If the download fails, the function evaluates to
<code><a href="base.html#topic+NULL">NULL</a></code>, typically with warnings.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Shiller">Shiller</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## list all supported files
French()


  ## fetch names of files from Kenneth French's website
  try({
      txt &lt;- readLines(paste0("https://mba.tuck.dartmouth.edu/pages/",
                              "faculty/ken.french/data_library.html"))
      csv &lt;- txt[grep("ftp/.*CSV.zip", txt, ignore.case = TRUE)]
      gsub(".*ftp/(.*?CSV.zip).*", "\1", csv, ignore.case = TRUE)
    })


## Not run: 
archive.dir &lt;- "~/Downloads/French"
if (!dir.exists(archive.dir))
    dir.create(archive.dir)
French(archive.dir, "F-F_Research_Data_Factors_CSV.zip")

## End(Not run)
</code></pre>

<hr>
<h2 id='fundData'>
Mutual Fund Returns
</h2><span id='topic+fundData'></span>

<h3>Description</h3>

<p>A matrix of 500 rows (return scenarios) and 200 columns (mutual
funds). The elements in the matrix are weekly returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fundData</code></pre>


<h3>Format</h3>

<p>A plain numeric matrix.</p>


<h3>Details</h3>

<p>The scenarios were created with a bootstrapping technique. The data set
is only meant to provide example data on which to test algorithms.
</p>


<h3>Source</h3>

<p>Schumann, E. (2010) <em>Essays on Practical Financial Optimisation</em>,
(chapter 4), PhD thesis, University of Geneva.
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>apply(fundData, 2, summary)
</code></pre>

<hr>
<h2 id='GAopt'>
Optimisation with a Genetic Algorithm
</h2><span id='topic+GAopt'></span>

<h3>Description</h3>

<p>A simple Genetic Algorithm for minimising a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAopt (OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GAopt_+3A_of">OF</code></td>
<td>
<p>The objective function, to be minimised. See Details.
</p>
</td></tr>
<tr><td><code id="GAopt_+3A_algo">algo</code></td>
<td>
<p>A list with the settings for algorithm. See Details and Examples.
</p>
</td></tr>
<tr><td><code id="GAopt_+3A_...">...</code></td>
<td>
<p>Other pieces of data required to evaluate the objective function. See Details and Examples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a simple Genetic Algorithm (<abbr><span class="acronym">GA</span></abbr>). A
<abbr><span class="acronym">GA</span></abbr> evolves a collection of solutions (the so-called
population), all of which are coded as vectors containing only zeros
and ones. (In <code>GAopt</code>, solutions are of mode <code>logical</code>.)
The algorithm starts with randomly-chosen or user-supplied population
and aims to iteratively improve this population by mixing solutions
and by switching single bits in solutions, both at random. In each
iteration, such randomly-changed solutions are compared with the
original population and better solutions replace inferior
ones. In <code>GAopt</code>, the population size is kept constant.
</p>
<p><abbr><span class="acronym">GA</span></abbr> language: iterations are called generations; new solutions
are called offspring or children (and the existing solutions, from which
the children are created, are parents); the objective function is called
a fitness function; mixing solutions is a crossover; and randomly
changing solutions is called mutation. The choice which solutions remain in
the population and which ones are discarded is called selection. In
<code>GAopt</code>, selection is pairwise: a given child is compared with a
given parent; the better of the two is kept.  In this way, the best
solution is automatically retained in the population.
</p>
<p>To allow for constraints, the evaluation works as follows: after new
solutions are created, they are (i) repaired, (ii) evaluated through the
objective function, (iii) penalised. Step (ii) is done by a call to
<code>OF</code>; steps (i) and (iii) by calls to <code>algo$repair</code> and
<code>algo$pen</code>. Step (i) and (iii) are optional, so the respective
functions default to <code>NULL</code>. A penalty can also be directly written
in the <code>OF</code>, since it amounts to a positive number added to the
&lsquo;clean&rsquo; objective function value; but a separate function is
often clearer. A separate penalty function is advantagous if either only
the objective function or only the penalty function can be vectorised.
</p>
<p>Conceptually a <abbr><span class="acronym">GA</span></abbr> consists of two loops: one loop across the
generations and, in any given generation, one loop across the solutions.
This is the default, controlled by the variables <code>algo$loopOF</code>,
<code>algo$loopRepair</code> and <code>algo$loopPen</code>, which all default to
<code>TRUE</code>. But it does not matter in what order the solutions are
evaluated (or repaired or penalised), so the second loop can be
vectorised. The respective <code>algo$loopFun</code> must then be set to
<code>FALSE</code>. (See also the examples for <code><a href="#topic+DEopt">DEopt</a></code> and
<code><a href="#topic+PSopt">PSopt</a></code>.)
</p>
<p>The evaluation of the objective function in a given generation can even
be distributed. For this, an argument <code>algo$methodOF</code> needs to be
set; see below for details (and Schumann, 2011, for examples).
</p>
<p>All objects that are passed through <code>...</code> will be passed to the
objective function, to the repair function and to the penalty function.
</p>
<p>The list <code>algo</code> contains the following items:
</p>

<dl>
<dt><code>nB</code></dt><dd><p>number of bits per solution. Must be specified.</p>
</dd>
<dt><code>nP</code></dt><dd><p>population size. Defaults to 50. Using default
settings may not be a good idea.</p>
</dd>
<dt><code>nG</code></dt><dd><p>number of iterations (&lsquo;generations&rsquo;).
Defaults to 300. Using default settings may not be a good idea.</p>
</dd>
<dt><code>crossover</code></dt><dd><p>The crossover method. Default is
<code>"onePoint"</code>; also possible is &ldquo;uniform&rdquo;.</p>
</dd>
<dt><code>prob</code></dt><dd><p>The probability for switching a single
bit. Defaults to 0.01; typically a small number.</p>
</dd>
<dt><code>pen</code></dt><dd><p>a penalty function. Default is <code>NULL</code> (no
penalty).</p>
</dd>
<dt><code>repair</code></dt><dd><p>a repair function. Default is <code>NULL</code> (no
repairing).</p>
</dd>
<dt><code>initP</code></dt><dd><p>optional: the initial population. A logical
matrix of size <code>length(algo$nB)</code> times <code>algo$nP</code>, or a
function that creates such a matrix. If a function, it must take
no arguments. If <code>mode(mP)</code> is not <code>logical</code>, then
<code>storage.mode(mP)</code> will be tried (and a warning will be
issued).</p>
</dd>
<dt><code>loopOF</code></dt><dd><p>logical. Should the <code>OF</code> be evaluated
through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopPen</code></dt><dd><p>logical. Should the penalty function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopRepair</code></dt><dd><p>logical. Should the repair function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>methodOF</code></dt><dd><p><code>loop</code> (the default), <code>vectorised</code>,
<code>snow</code> or <code>multicore</code>. Setting <code>vectorised</code> is
equivalent to having <code>algo$loopOF</code> set to <code>FALSE</code> (and
<code>methodOF</code> overrides <code>loopOF</code>). <code>snow</code> and
<code>multicore</code> use functions <code>clusterApply</code> and
<code>mclapply</code>, respectively. For <code>snow</code>, an object
<code>algo$cl</code> needs to be specified (see below). For
<code>multicore</code>, optional arguments can be passed through
<code>algo$mc.control</code> (see below).</p>
</dd>
<dt><code>cl</code></dt><dd><p>a cluster object or the number of cores. See
documentation of package <code>parallel</code>.</p>
</dd>
<dt><code>mc.control</code></dt><dd><p>a list of named elements; optional settings
for <code>mclapply</code> (for instance,
</p>
<p><code>list(mc.set.seed = FALSE)</code>)</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information
is printed.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (the default), a
<code>txtProgressBar</code> is printed.</p>
</dd>
<dt><code>storeF</code></dt><dd><p>If <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>If <code>TRUE</code>, the solutions (ie,
binary strings) in every generation are stored and returned as a
list <code>P</code> in list <code>xlist</code> (see Value section below). To
check, for instance, the solutions at the end of the <code>i</code>th
generation, retrieve <code>xlist[[c(1L, i)]]</code>. This will be a
matrix of size <code>algo$nB</code> times <code>algo$nP</code>.</p>
</dd>
<dt><code>classify</code></dt><dd><p>Logical; default is
<code>FALSE</code>. If <code>TRUE</code>, the result will
have a class attribute <code>TAopt</code>
attached. This feature is <strong>experimental</strong>:
the supported methods may change without
warning.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>the solution (the best member of the population)</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value of best solution</p>
</td></tr>
<tr><td><code>popF</code></td>
<td>
<p>a vector. The objective function values in the final population.</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>if <code>algo$storeF</code> is <code>TRUE</code>, a matrix of size
<code>algo$nG</code> times <code>algo$nP</code> containing
the objective function values of all solutions over the generations;
else <code>NA</code></p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a list that
contains a list <code>P</code> of matrices and a matrix <code>initP</code> (the
initial solution); else <code>NA</code>.</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when the function was called.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEopt">DEopt</a></code>, <code><a href="#topic+PSopt">PSopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a *very* simple problem (why?):
## match a binary (logical) string y

size &lt;- 20L  ### the length of the string
OF &lt;- function(x, y) sum(x != y)
y &lt;- runif(size) &gt; 0.5
x &lt;- runif(size) &gt; 0.5
OF(y, y)     ### the optimum value is zero
OF(x, y)
algo &lt;- list(nB = size, nP = 20L, nG = 100L, prob = 0.002)
sol &lt;- GAopt(OF, algo = algo, y = y)

## show differences (if any: marked by a '^')
cat(as.integer(y), "\n", as.integer(sol$xbest), "\n",
    ifelse(y == sol$xbest , " ", "^"), "\n", sep = "")

algo$nP &lt;- 3L  ### that shouldn't work so well
sol2 &lt;- GAopt(OF, algo = algo, y = y)

## show differences (if any: marked by a '^')
cat(as.integer(y), "\n", as.integer(sol2$xbest), "\n",
    ifelse(y == sol2$xbest , " ", "^"), "\n", sep = "")
</code></pre>

<hr>
<h2 id='greedySearch'>
Greedy Search
</h2><span id='topic+greedySearch'></span>

<h3>Description</h3>

<p>Greedy Search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedySearch(OF, algo, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greedySearch_+3A_of">OF</code></td>
<td>

<p>The objective function, to be minimised. Its first
argument needs to be a solution; <code>...</code>
arguments are also passed.
</p>
</td></tr>
<tr><td><code id="greedySearch_+3A_algo">algo</code></td>
<td>

<p>List of settings. See Details.
</p>
</td></tr>
<tr><td><code id="greedySearch_+3A_...">...</code></td>
<td>

<p>Other variables to be passed to the objective
function and to the neighbourhood function. See
Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A greedy search works starts at a provided initial
solution (called the current solution) and searches a
defined neighbourhood for the best possible
solution. If this best neighbour is not better than
the current solution, the search stops.  Otherwise,
the best neighbour becomes the current solution, and
the search is repeated.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>best solution found.</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value
associated with best solution.</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>a matrix with two
columns. <code>Fmat[ ,1L]</code> contains the proposed
solution over all iterations; <code>Fmat[ ,2L]</code>
contains the accepted solutions.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of
<code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> when the function was
called.</p>
</td></tr>
<tr><td><code>x0</code></td>
<td>
<p>the initial solution</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations
after which the search stopped</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code>LSopt</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na &lt;- 100
inc &lt;- 5
R &lt;- randomReturns(na = na,
                   ns = 1000,
                   sd = seq(0.01, 0.02, length.out = 100),
                   rho = 0.5)
S &lt;- cov(R)
OF &lt;- function(x, S, ...) {
    w &lt;- 1/sum(x)
    sum(w * w * S[x, x])
}

x &lt;- logical(na)
x[1:inc] &lt;- TRUE


all.neighbours &lt;- function(x, ...) {
    true  &lt;- which( x)
    false &lt;- which(!x)
    ans &lt;- list()
    for (i in true) {
        for (j in false) {
            ans1 &lt;- x
            ans1[i] &lt;- !x[i]
            ans1[j] &lt;- !x[j]
            ans &lt;- c(ans, list(ans1))
        }
    }
    ans
}

algo &lt;- list(loopOF = TRUE,
             maxit = 1000,
             all.neighbours = all.neighbours,
             x0 = x)

system.time(sol.gs &lt;- greedySearch(OF, algo = algo, S = S))
sqrt(sol.gs$OFvalue)
</code></pre>

<hr>
<h2 id='gridSearch'>
Grid Search
</h2><span id='topic+gridSearch'></span>

<h3>Description</h3>

<p>Evaluate a function for a given list of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridSearch(fun, levels, ..., lower, upper, npar = 1L, n = 5L,
           printDetail = TRUE,
           method = NULL,
           mc.control = list(), cl = NULL,
           keepNames = FALSE, asList = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridSearch_+3A_fun">fun</code></td>
<td>

<p>a function of the form <code>fun(x, ...)</code>, with <code>x</code> being a
numeric vector or a list
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_levels">levels</code></td>
<td>

<p>a list of levels for the arguments (see Examples)
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_...">...</code></td>
<td>

<p>objects passed to <code>fun</code>
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_lower">lower</code></td>
<td>

<p>a numeric vector. Ignored if levels are explicitly specified.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_upper">upper</code></td>
<td>

<p>a numeric vector. Ignored if levels are explicitly specified.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_npar">npar</code></td>
<td>

<p>the number of parameters. Must be supplied if <code>lower</code> and
<code>upper</code> are to be expanded; see Details. Ignored when <code>levels</code> are
explicitly specified, or when <code>lower</code>/<code>upper</code> are used and
at least one has length greater than one. See Examples.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_n">n</code></td>
<td>

<p>the number of levels. Default is 5. Ignored if levels are explicitly specified.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_printdetail">printDetail</code></td>
<td>

<p>print information on the number of objective function evaluations
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_method">method</code></td>
<td>

<p>can be <code>loop</code> (the default), <code>multicore</code>
or <code>snow</code>. See Details.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_mc.control">mc.control</code></td>
<td>

<p>a list containing settings that will be passed to <code>mclapply</code> if
<code>method</code> is <code>multicore</code>. Must be a list of named
elements; see the documentation of <code>mclapply</code> in <span class="pkg">parallel</span>.
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_cl">cl</code></td>
<td>
<p>default is <code>NULL</code>. If method <code>snow</code> is used, this must be a
cluster object or an integer (the number of cores).</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_keepnames">keepNames</code></td>
<td>

<p><code>logical</code>: should the names of <code>levels</code> be kept?
</p>
</td></tr>
<tr><td><code id="gridSearch_+3A_aslist">asList</code></td>
<td>

<p>does <code>fun</code> expect a list? Default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grid search can be used to find &lsquo;good&rsquo; parameter values for a
function. In principle, a grid search has an obvious deficiency: as
the length of <code>x</code> (the first argument to <code>fun</code>) increases,
the number of necessary function evaluations grows exponentially. Note
that <code>gridSearch</code> will not warn about an unreasonable number of
function evaluations, but if <code>printDetail</code> is <code>TRUE</code> it will
print the required number of function evaluations.
</p>
<p>In practice, grid search is often better than its reputation. If a
function takes only a few parameters, it is often a reasonable approach
to find &lsquo;good&rsquo; parameter values.
</p>
<p>The function uses the mechanism of <code><a href="base.html#topic+expand.grid">expand.grid</a></code> to create
the list of parameter combinations for which <code>fun</code> is evaluated; it
calls <code><a href="base.html#topic+lapply">lapply</a></code> to evaluate <code>fun</code> if
<code>method == "loop"</code> (the default).
</p>
<p>If <code>method</code> is <code>multicore</code>, then function <code>mclapply</code>
from package <span class="pkg">parallel</span> is used. Further settings for
<code>mclapply</code> can be passed through the list <code>mc.control</code>. If
<code>multicore</code> is chosen but the functionality is not available,
then <code>method</code> will be set to <code>loop</code> and a warning is
issued. If <code>method == "snow"</code>, the function <code>clusterApply</code>
from package <span class="pkg">parallel</span> is used. In this case, the argument <code>cl</code>
must either be a cluster object (see the documentation of
<code>clusterApply</code>) or an integer. If an integer, a cluster will be
set up via <code>makeCluster(c(rep("localhost", cl)), type = "SOCK")</code>
(and <code>stopCluster</code> is called when the function is exited). If
<code>snow</code> is chosen but not available or <code>cl</code> is not specified,
then <code>method</code> will be set to <code>loop</code> and a warning is issued.
</p>


<h3>Value</h3>

<p>A list.
</p>
<table role = "presentation">
<tr><td><code>minfun</code></td>
<td>
<p>the minimum of <code>fun</code>.</p>
</td></tr>
<tr><td><code>minlevels</code></td>
<td>
<p>the levels that give this minimum.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a list. All the function values of <code>fun</code>.</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a list. All the levels for which <code>fun</code> was evaluated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testFun &lt;- function(x)
    x[1L] + x[2L]^2

sol &lt;- gridSearch(fun = testFun, levels = list(1:2, c(2, 3, 5)))
sol$minfun
sol$minlevels

## specify all levels
levels &lt;- list(a = 1:2, b = 1:3)
res &lt;- gridSearch(testFun, levels)
res$minfun
sol$minlevels

## specify lower, upper and npar
lower &lt;- 1; upper &lt;- 3; npar &lt;- 2
res &lt;- gridSearch(testFun, lower = lower, upper = upper, npar = npar)
res$minfun
sol$minlevels

## specify lower, upper, npar and n
lower &lt;- 1; upper &lt;- 3; npar &lt;- 2; n &lt;- 4
res &lt;- gridSearch(testFun, lower = lower, upper = upper, npar = npar, n = n)
res$minfun
sol$minlevels

## specify lower, upper and n
lower &lt;- c(1,1); upper &lt;- c(3,3); n &lt;- 4
res &lt;- gridSearch(testFun, lower = lower, upper = upper, n = n)
res$minfun
sol$minlevels

## specify lower, upper (auto-expanded) and n
lower &lt;- c(1,1); upper &lt;- 3; n &lt;- 4
res &lt;- gridSearch(testFun, lower = lower, upper = upper, n = n)
res$minfun
sol$minlevels



## non-numeric inputs
test_fun &lt;- function(x) {
    -(length(x$S) + x$N1 + x$N2)
}

ans &lt;- gridSearch(test_fun,
                  levels = list(S  = list("a", c("a", "b"), c("a", "b", "c")),
                                N1 = 1:5,
                                N2 = 101:105),
                  asList = TRUE, keepNames = TRUE)
ans$minlevels
## $S
## [1] "a" "b" "c"
##
## $N1
## [1] 5
##
## $N2
## [1] 105

</code></pre>

<hr>
<h2 id='LS.info'>
Local-Search Information
</h2><span id='topic+LS.info'></span>

<h3>Description</h3>

<p>The function can be called from the objective and neighbourhood
function during a run of <code><a href="#topic+LSopt">LSopt</a></code>; it provides information
such as the current iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LS.info(n = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.info_+3A_n">n</code></td>
<td>

<p>generational offset; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>This function is still experimental.</b>
</p>
<p>The function can be called in the neighbourhood function or the
objective function during a run of <code><a href="#topic+LSopt">LSopt</a></code>.  It evaluates
to a list with the state of the optimisation run, such as the current
iteration.
</p>
<p><code>LS.info</code> relies on <code><a href="base.html#topic+parent.frame">parent.frame</a></code> to retrieve its
information.  If the function is called within another function in the
neighbourhood or objective function, the argument <code>n</code> needs to be
increased.
</p>


<h3>Value</h3>

<p>A list
</p>
<table role = "presentation">
<tr><td><code>iteration</code></td>
<td>
<p>current iteration</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>same as &lsquo;iteration&rsquo;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSopt">LSopt</a></code>, <code><a href="#topic+TA.info">TA.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## MINIMAL EXAMPLE for LSopt

## objective function evaluates to a constant
fun &lt;- function(x)
    0

## neighbourhood function does not even change the solution,
## but it reports information
nb &lt;- function(x) {
    tmp &lt;- LS.info()
    cat("current iteration ", tmp$iteration, "\n")
    x
}

## run LS
algo &lt;- list(nS = 5,
             x0 = rep(0, 5),
             neighbour = nb,
             printBar = FALSE)
ignore &lt;- LSopt(fun, algo)

</code></pre>

<hr>
<h2 id='LSopt'>
Stochastic Local Search
</h2><span id='topic+LSopt'></span>

<h3>Description</h3>

<p>Performs a simple stochastic Local Search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LSopt(OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSopt_+3A_of">OF</code></td>
<td>

<p>The objective function, to be minimised. Its first argument needs to
be a solution; <code>...</code> arguments are also passed.
</p>
</td></tr>
<tr><td><code id="LSopt_+3A_algo">algo</code></td>
<td>

<p>List of settings. See Details.
</p>
</td></tr>
<tr><td><code id="LSopt_+3A_...">...</code></td>
<td>

<p>Other variables to be passed to the objective function and to the
neighbourhood function. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local Search (<abbr><span class="acronym">LS</span></abbr>) changes an initial solution for a number
of times, accepting only such changes that lead to an improvement in
solution quality (as measured by the objective function <code>OF</code>).
More specifically, in each iteration, a current solution <code>xc</code> is
changed through a function <code>algo$neighbour</code>. This function takes
<code>xc</code> as an argument and returns a new solution <code>xn</code>. If
<code>xn</code> is not worse than <code>xc</code>, ie, if
<code>OF(xn,...)&lt;=OF(xc,...)</code>, then <code>xn</code> replaces <code>xc</code>.
</p>
<p>The list <code>algo</code> contains the following items:
</p>

<dl>
<dt><code>nS</code></dt><dd><p>The number of steps. The default is 1000; but this
setting depends very much on the problem.</p>
</dd>
<dt><code>nI</code></dt><dd>
<p>Total number of iterations, with default
<code>NULL</code>. If specified, it will override
<code>nS</code>. The option is provided to makes it
easier to compare and switch between functions
<code><a href="#topic+LSopt">LSopt</a></code>, <code><a href="#topic+TAopt">TAopt</a></code> and
<code><a href="#topic+SAopt">SAopt</a></code>.
</p>
</dd>
<dt><code>x0</code></dt><dd><p>The initial solution. This can be a function; it
will then be called once without arguments to compute an initial
solution, ie, <code>x0 &lt;- algo$x0()</code>. This can be useful when
<code>LSopt</code> is called in a loop of restarts and each restart is
to have its own starting value.</p>
</dd>
<dt><code>neighbour</code></dt><dd><p>The neighbourhood function, called as
<code>neighbour(x, ...)</code>. Its first argument must be a solution
<code>x</code>; it must return a changed solution.</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information
is printed. If an integer <code>i</code> greater then one, information
is printed at very <code>i</code>th step.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (the
default), a <code>txtProgressBar</code> (from package
<span class="pkg">utils</span>) is printed).  The progress bar is
not shown if <code>printDetail</code> is an integer
greater than 1.</p>
</dd>
<dt><code>storeF</code></dt><dd><p>if <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>default is <code>FALSE</code>. If
<code>TRUE</code>, the solutions (ie, decision variables) in every
generation are stored and returned in list
<code>xlist</code> (see Value section below). To check, for instance,
the current solution at the end of the <code>i</code>th generation, retrieve
<code>xlist[[c(2L, i)]]</code>.</p>
</dd>
<dt><code>OF.target</code></dt><dd><p>Numeric; when specified, the algorithm will
stop when an objective-function value as low as <code>OF.target</code> (or
lower) is achieved. This is useful when an optimal
objective-function value is known: the algorithm will then stop and
not waste time searching for a better solution.</p>
</dd>
</dl>

<p>At the minimum, <code>algo</code> needs to contain an initial solution
<code>x0</code> and a <code>neighbour</code> function.
</p>
<p><abbr><span class="acronym">LS</span></abbr> works on solutions through the functions <code>neighbour</code>
and <code>OF</code>, which are specified by the user. Thus, a solution need
not be a numeric vector, but can be any other data structure as well
(eg, a list or a matrix).
</p>
<p>To run silently (except for warnings and errors),
<code>algo$printDetail</code> and <code>algo$printBar</code> must be <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>best solution found.</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value associated with best
solution.</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>a matrix with two columns. <code>Fmat[ ,1L]</code>
contains the proposed solution over all iterations; <code>Fmat[
    ,2L]</code> contains the accepted solutions.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a
list; else <code>NA</code>. Contains the neighbour solutions at a given
iteration (<code>xn</code>) and the current solutions
(<code>xc</code>). Example: <code>Fmat[i, 2L]</code> is the objective function
value associated with <code>xlist[[c(2L, i)]]</code>.</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when the function was called.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TAopt">TAopt</a></code>, <code><a href="#topic+restartOpt">restartOpt</a></code>.
Package <span class="pkg">neighbours</span> (also on CRAN) offers helpers
for creating neighbourhood functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Aim: find the columns of X that, when summed, give y

## random data set
nc &lt;- 25L          ## number of columns in data set
nr &lt;- 5L           ## number of rows in data set
howManyCols &lt;- 5L  ## length of true solution
X &lt;- array(runif(nr*nc), dim = c(nr, nc))
xTRUE &lt;- sample(1L:nc, howManyCols)
Xt &lt;- X[ , xTRUE, drop = FALSE]
y &lt;- rowSums(Xt)

## a random solution x0 ...
makeRandomSol &lt;- function(nc) {
    ii &lt;- sample.int(nc, sample.int(nc, 1L))
    x0 &lt;- logical(nc); x0[ii] &lt;- TRUE
    x0
}
x0 &lt;- makeRandomSol(nc)

## ... but probably not a good one
sum(y - rowSums(X[ , xTRUE, drop = FALSE])) ## should be 0
sum(y - rowSums(X[ , x0, drop = FALSE]))

## a neighbourhood function: switch n elements in solution
neighbour &lt;- function(xc, Data) {
    xn &lt;- xc
    p &lt;- sample.int(Data$nc, Data$n)
    xn[p] &lt;- !xn[p]
    if (sum(xn) &lt; 1L)
        xn &lt;- xc
    xn
}

## a greedy neighbourhood function
neighbourG &lt;- function(xc, Data) {
    of &lt;- function(x)
        abs(sum(Data$y - rowSums(Data$X[ ,x, drop = FALSE])))
    xbest &lt;- xc
    Fxbest &lt;- of(xbest)
    for (i in 1L:Data$nc) {
        xn &lt;- xc; p &lt;- i
        xn[p] &lt;- !xn[p]
        if (sum(xn) &gt;= 1L) {
            Fxn &lt;- of(xn)
            if (Fxn &lt; Fxbest) {
                xbest &lt;- xn
                Fxbest &lt;- Fxn
            }
        }
    }
    xbest
}

## an objective function
OF &lt;- function(xn, Data)
    abs(sum(Data$y - rowSums(Data$X[ ,xn, drop = FALSE])))


## (1) GREEDY SEARCH
## note: this could be done in a simpler fashion, but the
##       redundancies/overhead here are small, and the example is to
##       show how LSopt can be used for such a search
Data &lt;- list(X = X, y = y, nc = nc, nr = nr, n = 1L)
algo &lt;- list(nS = 500L, neighbour = neighbourG, x0 = x0,
             printBar = FALSE, printDetail = FALSE)
solG &lt;- LSopt(OF, algo = algo, Data = Data)

## after how many iterations did we stop?
iterG &lt;- min(which(solG$Fmat[ ,2L] == solG$OFvalue))
solG$OFvalue  ## the true solution has OF-value 0

## (2) LOCAL SEARCH
algo$neighbour &lt;- neighbour
solLS &lt;- LSopt(OF, algo = algo, Data = Data)
iterLS &lt;- min(which(solLS$Fmat[ ,2L] == solLS$OFvalue))
solLS$OFvalue  ## the true solution has OF-value 0

## (3) *Threshold Accepting*
algo$nT &lt;- 10L
algo$nS &lt;- ceiling(algo$nS/algo$nT)
algo$q &lt;- 0.99
solTA &lt;- TAopt(OF, algo = algo, Data = Data)
iterTA &lt;- min(which(solTA$Fmat[ ,2L] == solTA$OFvalue))
solTA$OFvalue  ## the true solution has OF-value 0

## look at the solution
all &lt;- sort(unique(c(which(solTA$xbest),
                     which(solLS$xbest),
                     which(solG$xbest),
                     xTRUE)))
ta &lt;- ls &lt;- greedy &lt;- true &lt;- character(length(all))
true[  match(xTRUE, all)] &lt;- "o"
greedy[match(which(solG$xbest),  all)] &lt;- "o"
ls[    match(which(solLS$xbest), all)] &lt;- "o"
ta[    match(which(solTA$xbest), all)] &lt;- "o"
data.frame(true = true, greedy = greedy, LS = ls , TA = ta,
           row.names=all)

## plot results
par(ylog = TRUE, mar = c(5,5,1,6), las = 1)
plot(solTA$Fmat[seq_len(iterTA) ,2L],type = "l", log = "y",
     ylim = c(1e-4,
              max(pretty(c(solG$Fmat,solLS$Fmat,solTA$Fmat)))),
     xlab = "iterations", ylab = "OF value", col = grey(0.5))
lines(cummin(solTA$Fmat[seq_len(iterTA), 2L]), type = "l")
lines(solG$Fmat[ seq_len(iterG),  2L], type = "p", col = "blue")
lines(solLS$Fmat[seq_len(iterLS), 2L], type = "l", col = "goldenrod3")
legend(x = "bottomleft",
       legend = c("TA best solution", "TA current solution",
                  "Greedy", "LS current/best solution"),
       lty = c(1,1,0,1),
       col = c("black",grey(0.5),"blue","goldenrod2"),
       pch = c(NA,NA,21,NA))
axis(4, at = c(solG$OFvalue, solLS$OFvalue, solTA$OFvalue),
        labels = NULL, las = 1)
lines(x = c(iterG, par()$usr[2L]), y = rep(solG$OFvalue,2),
      col = "blue", lty = 3)
lines(x = c(iterTA, par()$usr[2L]), y = rep(solTA$OFvalue,2),
      col = "black", lty = 3)
lines(x = c(iterLS, par()$usr[2L]), y = rep(solLS$OFvalue,2),
      col = "goldenrod3", lty = 3)
</code></pre>

<hr>
<h2 id='MA'>
Simple Moving Average
</h2><span id='topic+MA'></span>

<h3>Description</h3>

<p>The function computes a moving average of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MA(y, order, pad = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MA_+3A_y">y</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="MA_+3A_order">order</code></td>
<td>

<p>An integer. The order of the moving average. The function is defined
such that order one returns <code>y</code> (see Examples).</p>
</td></tr>
<tr><td><code id="MA_+3A_pad">pad</code></td>
<td>

<p>Defaults to <code>NULL</code>. If not <code>NULL</code>, all elements of the
returned moving average with position smaller than <code>order</code> are
replaced by the value of <code>pad</code>. Sensible values may be
<code>NA</code> or 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length <code>length(y)</code>.</p>


<h3>Author(s)</h3>

<p> Enrico Schumann </p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MA(1:10, 3)
MA(1:10, 3, pad = NA)

y &lt;- seq(1, 4, by = 0.3)
z &lt;- MA(y, 1)
all(y == z)      ### (typically) FALSE
all.equal(y, z)  ### should be TRUE

## 'Relative strength index'
rsi &lt;- function(y, t) {
    y &lt;- diff(y)
    ups   &lt;- y + abs(y)
    downs &lt;- y - abs(y)
    RS &lt;- -MA(ups, t) / MA(downs, t)
    RS/(1 + RS)
}
x &lt;- cumprod(c(100, 1 + rnorm(100, sd = 0.01)))
par(mfrow = c(2,1))
plot(x, type = "l")
plot(rsi(x, 14), ylim = c(0,1), type = "l")
</code></pre>

<hr>
<h2 id='maxSharpe'>
Maximum-Sharpe-Ratio/Tangency Portfolio
</h2><span id='topic+maxSharpe'></span>

<h3>Description</h3>

<p>Compute maximum Sharpe-ratio portfolios, subject to lower and upper bounds
on weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxSharpe(m, var, min.return,
          wmin = -Inf, wmax = Inf, method = "qp",
          groups = NULL, groups.wmin = NULL, groups.wmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxSharpe_+3A_m">m</code></td>
<td>
<p>vector of expected (excess) returns.</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_var">var</code></td>
<td>

<p>the covariance matrix: a numeric (real), symmetric matrix
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_min.return">min.return</code></td>
<td>
<p>minimumm required return. This is a technical
parameter, used only for QP.</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_wmin">wmin</code></td>
<td>

<p>numeric: a lower bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_wmax">wmax</code></td>
<td>

<p>numeric: an upper bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_method">method</code></td>
<td>

<p>character. Currently, only <code>"qp"</code> is supported.
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_groups">groups</code></td>
<td>

<p>a list of group definitions
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_groups.wmin">groups.wmin</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="maxSharpe_+3A_groups.wmax">groups.wmax</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> from package
<span class="pkg">quadprog</span>. Because of the algorithm that
<code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> uses, <code>var</code> has to be positive
definit (i.e. must be of full rank).
</p>


<h3>Value</h3>

<p>a numeric vector (the portfolio weights) with an attribute
<code>variance</code> (the portfolio's variance)
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Schumann, E. (2012) Computing the global minimum-variance
portfolio. <a href="https://enricoschumann.net/R/minvar.htm">https://enricoschumann.net/R/minvar.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minvar">minvar</a></code>,
<code><a href="#topic+mvPortfolio">mvPortfolio</a></code>,
<code><a href="#topic+mvFrontier">mvFrontier</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- var(R &lt;- NMOF::randomReturns(3, 10, 0.03))
x &lt;- solve(S, colMeans(R))
x/sum(x)
x &lt;- coef(lm(rep(1, 10) ~ -1 + R))
unname(x/sum(x))

maxSharpe(m = colMeans(R), var = S)
maxSharpe(m = colMeans(R), var = S, wmin = 0, wmax = 1)
</code></pre>

<hr>
<h2 id='mc'>
Option Pricing via Monte-Carlo Simulation
</h2><span id='topic+mc'></span><span id='topic+gbm'></span><span id='topic+gbb'></span>

<h3>Description</h3>

<p>Functions to calculate the theoretical prices of options through
simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm(npaths, timesteps, r, v, tau, S0,
    exp.result = TRUE, antithetic = FALSE)
gbb(npaths, timesteps, S0, ST, v, tau,
    log = FALSE, exp.result = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc_+3A_npaths">npaths</code></td>
<td>

<p>the number of paths
</p>
</td></tr>
<tr><td><code id="mc_+3A_timesteps">timesteps</code></td>
<td>

<p>timesteps per path
</p>
</td></tr>
<tr><td><code id="mc_+3A_r">r</code></td>
<td>
<p>the mean per unit of time
</p>
</td></tr>
<tr><td><code id="mc_+3A_v">v</code></td>
<td>
<p>the variance per unit of time
</p>
</td></tr>
<tr><td><code id="mc_+3A_tau">tau</code></td>
<td>
<p>time
</p>
</td></tr>
<tr><td><code id="mc_+3A_s0">S0</code></td>
<td>
<p>initial value
</p>
</td></tr>
<tr><td><code id="mc_+3A_st">ST</code></td>
<td>
<p>final value of Brownian bridge
</p>
</td></tr>
<tr><td><code id="mc_+3A_log">log</code></td>
<td>
<p>logical: construct bridge from log series?
</p>
</td></tr>
<tr><td><code id="mc_+3A_exp.result">exp.result</code></td>
<td>
<p>logical: compute <code><a href="base.html#topic+exp">exp</a></code> of the final
path, or return log values?</p>
</td></tr>
<tr><td><code id="mc_+3A_antithetic">antithetic</code></td>
<td>

<p>logical: if <code>TRUE</code>, random numbers for only
<code>npaths/2</code> are drawn, and the random numbers
are mirrored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gbm</code> generates sample paths of geometric Brownian motion.
</p>
<p><code>gbb</code> generates sample paths of a Brownian bridge by first creating
paths of Brownian motion <code>W</code> from time <code>0</code> to time <code>T</code>,
with <code>W_0</code> equal to zero.  Then, at each <code>t</code>, it subtracts <code>t/T
* W_T</code> and adds <code>S0*(1-t/T)+ST*(t/T)</code>.
</p>


<h3>Value</h3>

<p>A matrix of sample paths; each column contains the price path of an
asset. Even with only a single time-step, the matrix will have two
rows (the first row is <code>S0</code>).
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vanillaOptionEuropean">vanillaOptionEuropean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## price a European option
## ... parameters
npaths &lt;- 5000   ## increase number to get more precise results
timesteps &lt;- 1
S0   &lt;- 100
ST   &lt;- 100
tau  &lt;- 1
r &lt;- 0.01
v   &lt;- 0.25^2

## ... create paths
paths &lt;- gbm(npaths, timesteps, r, v, tau, S0 = S0)

## ... a helper function
mc &lt;- function(paths, payoff, ...)
    payoff(paths, ...)

## ... a payoff function (European call)
payoff &lt;- function(paths, X, r, tau)
    exp(-r * tau) * mean(pmax(paths[NROW(paths), ] - X, 0))

## ... compute and check
mc(paths, payoff, X = 100, r = r, tau = tau)
vanillaOptionEuropean(S0, X = 100, tau = tau, r = r, v = v)$value


## compute delta via forward difference
## (see Gilli/Maringer/Schumann, ch. 9)
h &lt;- 1e-6                 ## a small number
rnorm(1)                  ## make sure RNG is initialised
rnd.seed &lt;- .Random.seed  ## store current seed
paths1 &lt;- gbm(npaths, timesteps, r, v, tau, S0 = S0)
.Random.seed &lt;- rnd.seed
paths2 &lt;- gbm(npaths, timesteps, r, v, tau, S0 = S0 + h)

delta.mc &lt;- (mc(paths2, payoff, X = 100, r = r, tau = tau)-
             mc(paths1, payoff, X = 100, r = r, tau = tau))/h
delta &lt;- vanillaOptionEuropean(S0, X = 100, tau = tau,
                               r = r, v = v)$delta
delta.mc - delta




## a fanplot
steps &lt;- 100
paths &lt;- results &lt;- gbm(1000, steps, r = 0, v = 0.2^2,
                        tau = 1, S0 = 100)

levels &lt;- seq(0.01, 0.49, length.out = 20)
greys  &lt;- seq(0.9,  0.50, length.out = length(levels))

## start with an empty plot ...
plot(0:steps, rep(100, steps+1), ylim = range(paths),
     xlab = "", ylab = "", lty = 0, type = "l")

## ... and add polygons
for (level in levels) {

    l &lt;- apply(paths, 1, quantile, level)
    u &lt;- apply(paths, 1, quantile, 1 - level)
    col &lt;- grey(greys[level == levels])
    polygon(c(0:steps, steps:0), c(l, rev(u)),
            col = col, border = NA)

    ## add border lines
    ## lines(0:steps, l, col = grey(0.4))
    ## lines(0:steps, u, col = grey(0.4))
}

</code></pre>

<hr>
<h2 id='minCVaR'>
Minimum Conditional-Value-at-Risk (CVaR) Portfolios
</h2><span id='topic+minCVaR'></span>

<h3>Description</h3>

<p>Compute minimum-CVaR portfolios, subject to lower and upper bounds
on weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minCVaR(R, q = 0.1, wmin = 0, wmax = 1,
        min.return = NULL, m = NULL,
        method = "Rglpk",
        groups = NULL, groups.wmin = NULL, groups.wmax = NULL,
        Rglpk.control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minCVaR_+3A_r">R</code></td>
<td>
<p>the scenario matrix: a numeric (real) matrix</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_q">q</code></td>
<td>
<p>the Value-at-Risk level: a number between 0 and 0.5</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_wmin">wmin</code></td>
<td>

<p>numeric: a lower bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_wmax">wmax</code></td>
<td>

<p>numeric: an upper bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_m">m</code></td>
<td>
<p>vector of expected returns. Only used if <code>min.return</code> is
specified.</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_min.return">min.return</code></td>
<td>

<p>minimal required return. If <code>m</code> is not specified, the column
means of <code>R</code> are used.
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_method">method</code></td>
<td>

<p>character. Currently, only <code>"Rglpk"</code> is supported.
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_groups">groups</code></td>
<td>

<p>a list of group definitions
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_groups.wmin">groups.wmin</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_groups.wmax">groups.wmax</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="minCVaR_+3A_rglpk.control">Rglpk.control</code></td>
<td>

<p>a list: settings passed to <code><a href="Rglpk.html#topic+Rglpk_solve_LP">Rglpk_solve_LP</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Compute the minimum CVaR portfolio for a given scenario set.
The default method uses the formulation as a Linear Programme,
as described in Rockafellar/Uryasev (2000).
</p>
<p>The function uses <code><a href="Rglpk.html#topic+Rglpk_solve_LP">Rglpk_solve_LP</a></code> from package
<span class="pkg">Rglpk</span>.
</p>


<h3>Value</h3>

<p>a numeric vector (the portfolio weights); attached is an
attribute whose name matches the <code>method</code> name
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Rockafellar, R. T. and Uryasev, S. (2000).
Optimization of Conditional Value-at-Risk.
Journal of Risk.
<strong>2</strong> (3), 21&ndash;41.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Schumann, E. (2020) Minimising Conditional Value-at-Risk (CVaR).
<a href="https://enricoschumann.net/notes/minimising-conditional-var.html">https://enricoschumann.net/notes/minimising-conditional-var.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minvar">minvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("Rglpk")) {

  ns &lt;- 5000  ## number of scenarios
  na &lt;- 20    ## nunber of assets
  R &lt;- randomReturns(na, ns, sd = 0.01, rho = 0.5)

  res &lt;- minCVaR(R, 0.25)
  c(res)  ## portfolio weights
}
</code></pre>

<hr>
<h2 id='minMAD'>
Compute Minimum Mean&ndash;Absolute-Deviation Portfolios
</h2><span id='topic+minMAD'></span>

<h3>Description</h3>

<p>Compute minimum mean&ndash;absolute-deviation portfolios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minMAD(R, wmin = 0, wmax = 1,
       min.return = NULL, m = NULL, demean = TRUE,
       method = "lp",
       groups = NULL, groups.wmin = NULL, groups.wmax = NULL,
       Rglpk.control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minMAD_+3A_r">R</code></td>
<td>

<p>a matrix of return scenarios: each column represents one asset;
each row represents one scenario
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_wmin">wmin</code></td>
<td>

<p>minimum weight
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_wmax">wmax</code></td>
<td>

<p>maximum weight
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_min.return">min.return</code></td>
<td>

<p>a minimum required return; ignored if <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_m">m</code></td>
<td>

<p>a vector of expected returns. If NULL, but  <code>min.return</code>
is not <code>NULL</code>, then column means are used as expected
returns.
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_demean">demean</code></td>
<td>

<p>logical. If <code>TRUE</code>, the columns of <code>R</code> are demeaned,
corresponding to an objective function xxxx
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_method">method</code></td>
<td>

<p>string. Supported are <code>lp</code> and <code>ls</code>.
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_groups">groups</code></td>
<td>

<p>group definitions
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_groups.wmin">groups.wmin</code></td>
<td>

<p>list of vectors
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_groups.wmax">groups.wmax</code></td>
<td>

<p>list of vectors
</p>
</td></tr>
<tr><td><code id="minMAD_+3A_rglpk.control">Rglpk.control</code></td>
<td>

<p>a list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the minimum mean&ndash;absolute-deviation portfolio for a
given scenario set.
</p>
<p>The function uses <code><a href="Rglpk.html#topic+Rglpk_solve_LP">Rglpk_solve_LP</a></code> from package
<span class="pkg">Rglpk</span>.
</p>


<h3>Value</h3>

<p>a vector of portfolio weights
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Konno, H. and Yamazaki, H. (1991) Mean-Absolute Deviation
Portfolio Optimization Model and Its Applications to Tokyo
Stock Market. <em>Management Science</em>. <strong>37</strong> (5),
519&ndash;531.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minvar">minvar</a></code>, <code><a href="#topic+minCVaR">minCVaR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na &lt;- 10
ns &lt;- 1000
R &lt;- randomReturns(na = na, ns = ns,
                   sd = 0.01, rho = 0.8, mean = 0.0005)

minMAD(R = R)
minvar(var(R))
</code></pre>

<hr>
<h2 id='minvar'>
Minimum-Variance Portfolios
</h2><span id='topic+minvar'></span>

<h3>Description</h3>

<p>Compute minimum-variance portfolios, subject to lower and upper bounds
on weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minvar(var, wmin = 0, wmax = 1, method = "qp",
       groups = NULL, groups.wmin = NULL, groups.wmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minvar_+3A_var">var</code></td>
<td>

<p>the covariance matrix: a numeric (real), symmetric matrix
</p>
</td></tr>
<tr><td><code id="minvar_+3A_wmin">wmin</code></td>
<td>

<p>numeric: a lower bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="minvar_+3A_wmax">wmax</code></td>
<td>

<p>numeric: an upper bound on weights. May also be a vector that holds
specific bounds for each asset.
</p>
</td></tr>
<tr><td><code id="minvar_+3A_method">method</code></td>
<td>

<p>character. Currently, only <code>"qp"</code> is supported.
</p>
</td></tr>
<tr><td><code id="minvar_+3A_groups">groups</code></td>
<td>

<p>a list of group definitions
</p>
</td></tr>
<tr><td><code id="minvar_+3A_groups.wmin">groups.wmin</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="minvar_+3A_groups.wmax">groups.wmax</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method <code>"qp"</code>, the function uses
<code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> from package
<span class="pkg">quadprog</span>. Because of the algorithm that
<code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> uses, <code>var</code> has to be positive
definite (i.e. must be of full rank).
</p>


<h3>Value</h3>

<p>a numeric vector (the portfolio weights) with an attribute
<code>variance</code> (the portfolio's variance)
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Schumann, E. (2012) Computing the global minimum-variance
portfolio. <a href="https://enricoschumann.net/R/minvar.htm">https://enricoschumann.net/R/minvar.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TAopt">TAopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## variance-covariance matrix from daily returns, 1 Jan 2014 -- 31 Dec 2013, of
## cleaned data set at https://enricoschumann.net/data/gilli_accuracy.html

if (requireNamespace("quadprog")) {

    var &lt;- structure(c(0.000988087100677907, -0.0000179669410403153, 0.000368923882626859,
                       0.000208303611101873, 0.000262742052359594, -0.0000179669410403153,
                       0.00171852167358765, 0.0000857467457561209, 0.0000215059246610556,
                       0.0000283532159921211, 0.000368923882626859, 0.0000857467457561209,
                       0.00075871953281751, 0.000194002299424151, 0.000188824454515841,
                       0.000208303611101873, 0.0000215059246610556, 0.000194002299424151,
                       0.000265780633005374, 0.000132611196599808, 0.000262742052359594,
                       0.0000283532159921211, 0.000188824454515841, 0.000132611196599808,
                       0.00025948420130626),
                     .Dim = c(5L, 5L),
                     .Dimnames = list(c("CBK.DE", "VOW.DE", "CON.DE", "LIN.DE", "MUV2.DE"),
                                      c("CBK.DE", "VOW.DE", "CON.DE", "LIN.DE", "MUV2.DE")))

    ##            CBK.DE     VOW.DE    CON.DE    LIN.DE   MUV2.DE
    ## CBK.DE   0.000988 -0.0000180 0.0003689 0.0002083 0.0002627
    ## VOW.DE  -0.000018  0.0017185 0.0000857 0.0000215 0.0000284
    ## CON.DE   0.000369  0.0000857 0.0007587 0.0001940 0.0001888
    ## LIN.DE   0.000208  0.0000215 0.0001940 0.0002658 0.0001326
    ## MUV2.DE  0.000263  0.0000284 0.0001888 0.0001326 0.0002595
    ##

    minvar(var, wmin = 0, wmax = 0.5)

    minvar(var,
           wmin = c(0.1,0,0,0,0), ## enforce at least 10% weight in CBK.DE
           wmax = 0.5)

    minvar(var, wmin = -Inf, wmax = Inf)   ## no bounds
    ## [1] -0.0467  0.0900  0.0117  0.4534  0.4916

    minvar(var, wmin = -Inf, wmax = 0.45)  ## no lower bounds
    ## [1] -0.0284  0.0977  0.0307  0.4500  0.4500

    minvar(var, wmin =  0.1, wmax = Inf)   ## no upper bounds
    ## [1] 0.100 0.100 0.100 0.363 0.337

    ## group constraints:
    ##   group 1 consists of asset 1 only,   and must have weight [0.25,0.30]
    ##   group 2 consists of assets 4 and 5, and must have weight [0.10,0.20]

    ##   =&gt; unconstrained
    minvar(var, wmin = 0, wmax = 0.40)
    ## [1] 0.0097 0.1149 0.0754 0.4000 0.4000

    ##   =&gt; with group constraints
    minvar(var, wmin = 0, wmax = 0.40,
           groups = list(1, 4:5),
           groups.wmin = c(0.25, 0.1),
           groups.wmax = c(0.30, 0.2))
    ## [1] 0.250 0.217 0.333 0.149 0.051
}
</code></pre>

<hr>
<h2 id='mvFrontier'>
Computing Mean&ndash;Variance Efficient Portfolios
</h2><span id='topic+mvFrontier'></span><span id='topic+mvPortfolio'></span>

<h3>Description</h3>

<p>Compute mean&ndash;variance efficient portfolios and efficient frontiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvFrontier(m, var, wmin = 0, wmax = 1, n = 50, rf = NA,
           groups = NULL, groups.wmin = NULL, groups.wmax = NULL)
mvPortfolio(m, var, min.return, wmin = 0, wmax = 1, lambda = NULL,
            groups = NULL, groups.wmin = NULL, groups.wmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvFrontier_+3A_m">m</code></td>
<td>

<p>vector of expected returns
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_var">var</code></td>
<td>

<p>expected variance&ndash;covariance matrix
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_wmin">wmin</code></td>
<td>

<p>numeric: minimum weights
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_wmax">wmax</code></td>
<td>

<p>numeric: maximum weights
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_n">n</code></td>
<td>

<p>number of points on the efficient frontier
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_min.return">min.return</code></td>
<td>

<p>minimal required return
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_rf">rf</code></td>
<td>

<p>risk-free rate
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_lambda">lambda</code></td>
<td>

<p>risk&ndash;reward trade-off
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_groups">groups</code></td>
<td>

<p>a list of group definitions
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_groups.wmin">groups.wmin</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="mvFrontier_+3A_groups.wmax">groups.wmax</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvPortfolio</code> computes a single mean&ndash;variance
efficient portfolio, using package <span class="pkg">quadprog</span>.
It does so by minimising portfolio variance, subject
to constraints on minimum return and budget (weights
need to sum to one), and min/max constraints on the
weights.
</p>
<p>If <code class="reqn">\lambda</code>
is specified, the function ignores the <code>min.return</code>
constraint and instead solves the model
</p>
<p style="text-align: center;"><code class="reqn">\min_w\ \ -\lambda \mbox{\code{m}}'w + (1-\lambda)
     w'\mbox{\code{var}\,}w</code>
</p>

<p>in which <code class="reqn">w</code> are the weights. If
<code class="reqn">\lambda</code>
is a vector of length 2, then the model becomes
</p>
<p style="text-align: center;"><code class="reqn">\min_w\ \ -\lambda_1 \mbox{\code{m}\,}'w + \lambda_2
     w'\mbox{\code{var}\,}w</code>
</p>

<p>which may be more convenient
(e.g. for setting <code class="reqn">\lambda_1</code> to 1).
</p>
<p><code>mvFrontier</code> computes returns, volatilities and
compositions for portfolios along an efficient frontier.
If <code>rf</code> is not <code>NA</code>, cash is included as an asset.
</p>


<h3>Value</h3>

<p>For <code>mvPortfolio</code>, a numeric vector of weights.
</p>
<p>For <code>mvFrontier</code>, a list of three components:
</p>
<table role = "presentation">
<tr><td><code>return</code></td>
<td>
<p>returns of portfolios</p>
</td></tr>
<tr><td><code>volatility</code></td>
<td>
<p>volatilities of portfolios</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A matrix of portfolio weights.
Each column holds the weights for one portfolio on the
frontier. If <code>rf</code> is specified, an additional row
is added, providing the cash weight.</p>
</td></tr>
</table>
<p>The <em>i</em>-th portfolio on the frontier corresponds
to the <em>i</em>-th elements of <code>return</code> and
<code>volatility</code>, and the <em>i</em>-th column of
<code>portfolio</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minvar">minvar</a></code> for computing the minimum-variance portfolio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>na &lt;- 4
vols &lt;- c(0.10, 0.15, 0.20,0.22)
m &lt;- c(0.06, 0.12, 0.09, 0.07)
const_cor &lt;- function(rho, na) {
    C &lt;- array(rho, dim = c(na, na))
    diag(C) &lt;- 1
    C
}
var &lt;- diag(vols) %*% const_cor(0.5, na) %*% diag(vols)

wmax &lt;- 1          # maximum holding size
wmin &lt;- 0.0          # minimum holding size
rf &lt;- 0.02

if (requireNamespace("quadprog")) {
  p1 &lt;- mvFrontier(m, var, wmin = wmin, wmax = wmax, n = 50)
  p2 &lt;- mvFrontier(m, var, wmin = wmin, wmax = wmax, n = 50, rf = rf)
  plot(p1$volatility, p1$return, pch = 19, cex = 0.5, type = "o",
       xlab = "Expected volatility",
       ylab = "Expected return")
  lines(p2$volatility, p2$return, col = grey(0.5))
  abline(v = 0, h = rf)
} else
  message("Package 'quadprog' is required")
</code></pre>

<hr>
<h2 id='NMOF-internal'>Internal NMOF functions</h2><span id='topic+NMOF-internal'></span><span id='topic+makeInteger'></span><span id='topic+anyNA'></span><span id='topic+checkList'></span><span id='topic+Chapters1'></span><span id='topic+Chapters2'></span><span id='topic+due'></span><span id='topic+mRN'></span><span id='topic+mRU'></span><span id='topic+mcList'></span><span id='topic+repair1c'></span>

<h3>Description</h3>

<p>Several internal functions, not exported from the <span class="pkg">NMOF</span> name space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeInteger(x, label, min = 1L)
anyNA(x)
checkList(passedList, defaultList, label = "'algo'")
mRU(m,n)
mRN(m,n)
mcList(mc.control)
repair1c(x, up, lo)
Chapters1
Chapters2
due(D, tauD, tau, q)
</code></pre>


<h3>Details</h3>

<p><code>makeInteger</code> coerces the scalar <code>x</code> to
integer. If the result is <code>NA</code> or smaller than
<code>min</code>, an error is issued.
</p>
<p><code>anyNA</code> gives <code>TRUE</code> if <code>any(is.na(x))</code>, else
<code>FALSE</code>. If <code>x</code> is a function or <code>NULL</code>, it
also gives <code>FALSE</code>.
</p>
<p><code>checkList</code> will issue an error if <code>passedList</code>
contains any <code>NA</code> elements. It will give a warning if
any elements in <code>passedList</code> are unnamed, or if an
element in <code>names(passedList)</code> is not found in
<code>names(defaultList)</code>.
</p>
<p><code>mRU</code> and <code>mRN</code> create matrices (of size <code>m</code>
times <code>n</code>) of uniform/Gaussian variates.
</p>
<p><code>mcList</code> takes a list of named elements and
&lsquo;merges&rsquo; them with the default settings of
<code>mclapply</code> from package <span class="pkg">parallel</span>.
</p>
<p><code>repair1c</code> is described in the vignette on
&lsquo;Repairing Solutions&rsquo;.
</p>
<p><code>Chapters[12]</code> is a vector of length 15, giving the
chapter names as printed in the book. (Can be accessed with
<code><a href="#topic+showChapterNames">showChapterNames</a></code>.)
</p>
<p><code>due</code> (dividends until expiry) returns a list with
named components <code>tauD</code> and <code>D</code>: all dividends for
which time-to-payment is greater than zero, but less than or
equal to time-to-expiry.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>

<hr>
<h2 id='NS'>
Zero Rates for Nelson&ndash;Siegel&ndash;Svensson Model
</h2><span id='topic+NS'></span><span id='topic+NSS'></span>

<h3>Description</h3>

<p>Compute zero yields for Nelson&ndash;Siegel (<abbr><span class="acronym">NS</span></abbr>)/Nelson&ndash;Siegel&ndash;Svensson (<abbr><span class="acronym">NSS</span></abbr>) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NS(param, tm)
NSS(param, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NS_+3A_param">param</code></td>
<td>

<p>a vector. For <abbr><span class="acronym">NS</span></abbr>: <code class="reqn">\beta_1</code>, <code class="reqn">\beta_2</code>, <code class="reqn">\beta_3</code>, <code class="reqn">\lambda</code>.
For <abbr><span class="acronym">NSS</span></abbr>: a vector: <code class="reqn">\beta_1</code>, <code class="reqn">\beta_2</code>, <code class="reqn">\beta_3</code>,
<code class="reqn">\beta_4</code>, <code class="reqn">\lambda_1</code>, <code class="reqn">\lambda_2</code>.
</p>
</td></tr>
<tr><td><code id="NS_+3A_tm">tm</code></td>
<td>

<p>a vector of maturities
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Chapter 14 in Gilli/Maringer/Schumann (2011).
</p>
<p>Maturities (<code>tm</code>) need to be given in time (not dates).
</p>


<h3>Value</h3>

<p>The function returns a vector of length <code>length(tm)</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M. and Grosse, S. and Schumann, E. (2010)
Calibrating the Nelson-Siegel-Svensson model,
<abbr><span class="acronym">COMISEF</span></abbr> Working Paper Series No. 031.
<a href="https://enricoschumann.net/COMISEF/wps031.pdf">https://enricoschumann.net/COMISEF/wps031.pdf</a>
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Gilli, M. and Schumann, E. (2010) A Note on
&lsquo;Good&rsquo; Starting Values in Numerical Optimisation,
<abbr><span class="acronym">COMISEF</span></abbr> Working Paper Series No. 044.
<a href="https://enricoschumann.net/COMISEF/wps044.pdf">https://enricoschumann.net/COMISEF/wps044.pdf</a>
</p>
<p>Nelson, C.R. and Siegel, A.F. (1987) Parsimonious
Modeling of Yield Curves. <em>Journal of Business</em>,
<strong>60</strong>(4), pp. 473&ndash;489.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Svensson, L.E. (1994) Estimating and Interpreting
Forward Interest Rates: Sweden 1992&ndash;1994.
<abbr><span class="acronym">IMF</span></abbr> Working Paper 94/114.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NSf">NSf</a></code>, <code><a href="#topic+NSSf">NSSf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm &lt;- c(c(1, 3, 6, 9) / 12, 1:10)  ## in years
param &lt;- c(6, 3, 8, 1)
yM &lt;- NS(param, tm)
plot(tm, yM, xlab = "maturity in years",
             ylab = "yield in percent")

param &lt;- c(6, 3, 5, -5, 1, 3)
yM &lt;- NSS(param, tm)
plot(tm, yM, xlab = "maturity in years",
             ylab = "yield in percent")
</code></pre>

<hr>
<h2 id='NSf'>
Factor Loadings for Nelson&ndash;Siegel and Nelson&ndash;Siegel&ndash;Svensson
</h2><span id='topic+NSf'></span><span id='topic+NSSf'></span>

<h3>Description</h3>

<p>Computes the factor loadings for Nelson&ndash;Siegel (<abbr><span class="acronym">NS</span></abbr>) and Nelson&ndash;Siegel&ndash;Svensson (<abbr><span class="acronym">NSS</span></abbr>) model for given <code>lambda</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSf(lambda, tm)
NSSf(lambda1, lambda2, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NSf_+3A_lambda">lambda</code></td>
<td>
<p>the <code class="reqn">\lambda</code> parameter of the <abbr><span class="acronym">NS</span></abbr> model (a scalar)
</p>
</td></tr>
<tr><td><code id="NSf_+3A_lambda1">lambda1</code></td>
<td>
<p>the <code class="reqn">\lambda_1</code> parameter of the <abbr><span class="acronym">NSS</span></abbr> model (a scalar)
</p>
</td></tr>
<tr><td><code id="NSf_+3A_lambda2">lambda2</code></td>
<td>
<p>the <code class="reqn">\lambda_2</code> parameter of the <abbr><span class="acronym">NSS</span></abbr> model (a scalar)
</p>
</td></tr>
<tr><td><code id="NSf_+3A_tm">tm</code></td>
<td>
<p>a numeric vector with times-to-payment/maturity
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the factor loadings for given <code class="reqn">\lambda</code> parameters. Checking the correlation between these
factor loadings can help to set reasonable <code class="reqn">\lambda</code> values for the <abbr><span class="acronym">NS</span></abbr>/<abbr><span class="acronym">NSS</span></abbr> models.
</p>


<h3>Value</h3>

<p>For <abbr><span class="acronym">NS</span></abbr>, a matrix with <code>length(tm)</code> rows and three columns.
For <abbr><span class="acronym">NSS</span></abbr>, a matrix with <code>length(tm)</code> rows and four columns.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M. and Grosse, S. and Schumann, E. (2010) Calibrating the Nelson-Siegel-Svensson model, <abbr><span class="acronym">COMISEF</span></abbr> Working Paper Series No. 031.
<a href="https://enricoschumann.net/COMISEF/wps031.pdf">https://enricoschumann.net/COMISEF/wps031.pdf</a>
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Gilli, M. and Schumann, E. (2010) A Note on &lsquo;Good&rsquo; Starting Values in Numerical Optimisation,
<abbr><span class="acronym">COMISEF</span></abbr> Working Paper Series No. 044.
<a href="https://enricoschumann.net/COMISEF/wps044.pdf">https://enricoschumann.net/COMISEF/wps044.pdf</a>
</p>
<p>Nelson, C.R. and Siegel, A.F. (1987) Parsimonious Modeling of Yield Curves. <em>Journal of Business</em>, <strong>60</strong>(4), pp. 473&ndash;489.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Svensson, L.E. (1994) Estimating and Interpreting Forward Interest Rates: Sweden 1992&ndash;1994. <abbr><span class="acronym">IMF</span></abbr> Working Paper 94/114.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NS">NS</a></code>, <code><a href="#topic+NSS">NSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Nelson-Siegel
cor(NSf(lambda = 6, tm = 1:10)[-1L, -1L])

## Nelson-Siegel-Svensson
cor(NSSf(lambda1 = 1, lambda2 = 5, tm = 1:10)[-1L, -1L])
cor(NSSf(lambda1 = 4, lambda2 = 9, tm = 1:10)[-1L, -1L])
</code></pre>

<hr>
<h2 id='optionData'>
Option Data
</h2><span id='topic+optionData'></span>

<h3>Description</h3>

<p>Closing prices of DAX index options as of 2012-02-10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionData</code></pre>


<h3>Format</h3>

<p><code>optionData</code> is a list with six components:
</p>

<dl>
<dt><code>pricesCall</code></dt><dd><p>a matrix of size 124 times 10. The rows
are the strikes; each column belongs to one expiry date.</p>
</dd>
<dt><code>pricesPut</code></dt><dd><p>a matrix of size 124 times 10</p>
</dd>
<dt><code>index</code></dt><dd><p>The DAX index (spot).</p>
</dd>
<dt><code>future</code></dt><dd><p>The available future settlement prices.</p>
</dd>
<dt><code>Euribor</code></dt><dd><p>Euribor rates.</p>
</dd>
<dt><code>NSSpar</code></dt><dd><p>Paramaters for German government bond yields,
as estimated by the Bundesbank.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Settlement prices for EUREX options are computed at 17:30, Frankfurt
Time, even though trading continues until 22:00.
</p>


<h3>Source</h3>

<p>The data was obtained from several websites: close prices of EUREX
products were collected from <a href="https://www.eurex.com/ex-en/">https://www.eurex.com/ex-en/</a> ; Euribor rates
and the parameters of the Nelson-Siegel-Svensson can be found at
<a href="https://www.bundesbank.de/en/">https://www.bundesbank.de/en/</a> .
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(optionData)
NSS(optionData$NSSpar, 1:10)
</code></pre>

<hr>
<h2 id='pm'>
Partial Moments
</h2><span id='topic+pm'></span>

<h3>Description</h3>

<p>Compute partial moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pm(x, xp = 2, threshold = 0, lower = TRUE,
     normalise = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm_+3A_x">x</code></td>
<td>

<p>a numeric vector or a matrix
</p>
</td></tr>
<tr><td><code id="pm_+3A_xp">xp</code></td>
<td>

<p>exponent
</p>
</td></tr>
<tr><td><code id="pm_+3A_threshold">threshold</code></td>
<td>

<p>a numeric vector of length one
</p>
</td></tr>
<tr><td><code id="pm_+3A_lower">lower</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="pm_+3A_normalise">normalise</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="pm_+3A_na.rm">na.rm</code></td>
<td>

<p>logical
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code class="reqn">x</code> of length <code class="reqn">n</code>, partial
moments are computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{upper\ partial\ moment} = \frac{1}{n} \sum_{x &gt;
      t}\left(x - t \right)^e</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{lower\ partial\ moment} = \frac{1}{n} \sum_{x &lt;
      t}\left(t - x \right)^e</code>
</p>

<p>The <code>threshold</code> is denoted <code class="reqn">t</code>, the exponent
<code>xp</code> is labelled <code class="reqn">e</code>.
</p>
<p>If <code>normalise</code> is <code>TRUE</code>, the result is raised to
<code>1/xp</code>.  If <code>x</code> is a matrix, the function will compute the
partial moments column-wise.
</p>
<p>See Gilli, Maringer and Schumann (2019), chapter 14.
</p>


<h3>Value</h3>

<p>numeric
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm(x &lt;- rnorm(100), 2)
var(x)/2

pm(x, 2, normalise = TRUE)
sqrt(var(x)/2)
</code></pre>

<hr>
<h2 id='PSopt'>
Particle Swarm Optimisation
</h2><span id='topic+PSopt'></span>

<h3>Description</h3>

<p>The function implements Particle Swarm Optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSopt(OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSopt_+3A_of">OF</code></td>
<td>

<p>the objective function to be minimised. See Details.
</p>
</td></tr>
<tr><td><code id="PSopt_+3A_algo">algo</code></td>
<td>

<p>a list with the settings for algorithm. See Details and Examples.
</p>
</td></tr>
<tr><td><code id="PSopt_+3A_...">...</code></td>
<td>

<p>pieces of data required to evaluate the objective function. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements Particle Swarm Optimisation (<abbr><span class="acronym">PS</span></abbr>);
see the references for details on the implementation. <abbr><span class="acronym">PS</span></abbr> is
a population-based optimisation heuristic. It develops several
solutions (a &lsquo;population&rsquo;) over a number of
iterations. <abbr><span class="acronym">PS</span></abbr> is directly applicable to continuous problems
since the population is stored in real-valued vectors. In each
iteration, a solution is updated by adding another vector called
velocity. Think of a solution as a position in the search space, and
of velocity as the direction into which this solution moves. Velocity
changes over the course of the optimization: it is biased towards the
best solution found by the particular solution and the best overall
solution. The algorithm stops after a fixed number of iterations.
</p>
<p>To allow for constraints, the evaluation works as follows: after a new
solution is created, it is (i) repaired, (ii) evaluated through the
objective function, (iii) penalised. Step (ii) is done by a call to
<code>OF</code>; steps (i) and (iii) by calls to <code>algo$repair</code> and
<code>algo$pen</code>. Step (i) and (iii) are optional, so the respective
functions default to <code>NULL</code>. A penalty can also be directly
written in the <code>OF</code>, since it amounts to a positive number added
to the &lsquo;clean&rsquo; objective function value.  It can be
advantageous to write a separate penalty function if either only the
objective function or only the penalty function can be vectorised.
(Constraints can also be added without these mechanisms. Solutions
that violate constraints can, for instance, be mapped to feasible
solutions, but without actually changing them. See Maringer and
Oyewumi, 2007, for an example with Differential Evolution.)
</p>
<p>Conceptually, <abbr><span class="acronym">PS</span></abbr> consists of two loops: one loop across the
iterations and, in any given generation, one loop across the
solutions.  This is the default, controlled by the variables
<code>algo$loopOF</code>, <code>algo$loopRepair</code>, <code>algo$loopPen</code> and
<code>loopChangeV</code> which all default to <code>TRUE</code>. But it does not
matter in what order the solutions are evaluated (or repaired or
penalised), so the second loop can be vectorised. Examples are given
in the vignettes and in the book. The respective <code>algo$loopFun</code>
must then be set to <code>FALSE</code>.
</p>
<p>The objective function, the repair function and and the penalty
function will be called as <code>fun(solution, ...)</code>.
</p>
<p>The list <code>algo</code> contains the following items:
</p>

<dl>
<dt><code>nP</code></dt><dd><p>population size. Defaults to 100. Using default
settings may not be a good idea.</p>
</dd>
<dt><code>nG</code></dt><dd><p>number of iterations. Defaults to 500. Using
default settings may not be a good idea.</p>
</dd>
<dt><code>c1</code></dt><dd><p>the weight towards the individual's best
solution. Typically between 0 and 2; defaults to 1.  Using default
settings may not be a good idea. In some cases, even negative
values work well: the solution is then driven off its past best
position. For &lsquo;simple&rsquo; problems, setting <code>c1</code> to zero
may work well: the population moves then towards the best overall
solution.</p>
</dd>
<dt><code>c2</code></dt><dd><p>the weight towards the populations's best
solution. Typically between 0 and 2; defaults to 1.  Using default
settings may not be a good idea. In some cases, even negative
values work well: the solution is then driven off the population's
past best position.</p>
</dd>
<dt><code>iner</code></dt><dd><p>the inertia weight (a scalar), which reduces
velocity. Typically between 0 and 1. Default is 0.9.</p>
</dd>
<dt><code>initV</code></dt><dd><p>the standard deviation of the initial
velocities. Defaults to 1.</p>
</dd>
<dt><code>maxV</code></dt><dd><p>the maximum (absolute) velocity. Setting limits
to velocity is sometimes called velocity clamping. Velocity is the
change in a given solution in a given iteration. A maximum
velocity can be set so to prevent unreasonable velocities
(&lsquo;overshooting&rsquo;): for instance, if a decision variable may
lie between 0 and 1, then an absolute velocity much greater than 1
makes rarely sense.</p>
</dd>
<dt><code>min</code>, <code>max</code></dt><dd><p>vectors of minimum and maximum parameter
values. The vectors <code>min</code> and <code>max</code> are used to determine the
dimension of the problem and to randomly initialise the
population. Per default, they are no constraints: a solution may well be outside
these limits. Only if <code>algo$minmaxConstr</code> is <code>TRUE</code> will the
algorithm repair solutions outside the <code>min</code> and <code>max</code> range.</p>
</dd>
<dt><code>minmaxConstr</code></dt><dd><p>if <code>TRUE</code>, <code>algo$min</code> and
<code>algo$max</code> are considered constraints. Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>pen</code></dt><dd><p>a penalty function. Default is <code>NULL</code> (no
penalty).</p>
</dd>
<dt><code>repair</code></dt><dd><p>a repair function. Default is <code>NULL</code> (no
repairing).</p>
</dd>
<dt><code>changeV</code></dt><dd><p>a function to change velocity. Default is
<code>NULL</code> (no change). This function is called before the
velocity is added to the current solutions; it can be used to
impose restrictions like changing only a number of decision
variables.</p>
</dd>
<dt><code>initP</code></dt><dd><p>optional: the initial population. A matrix of
size <code>length(algo$min)</code> times <code>algo$nP</code>, or a function
that creates such a matrix. If a function, it should take no
arguments.</p>
</dd>
<dt><code>loopOF</code></dt><dd><p>logical. Should the <code>OF</code> be evaluated
through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopPen</code></dt><dd><p>logical. Should the penalty function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopRepair</code></dt><dd><p>logical. Should the repair function (if
specified) be evaluated through a loop? Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>loopChangeV</code></dt><dd><p>logical. Should the <code>changeV</code>
function (if specified) be evaluated through a loop? Defaults to
<code>TRUE</code>.</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information
is printed. If an integer <code>i</code> greater then one, information
is printed at very <code>i</code>th iteration.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (the default), a
<code>txtProgressBar</code> (from package <span class="pkg">utils</span>) is printed).</p>
</dd>
<dt><code>storeF</code></dt><dd><p>If <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>default is <code>FALSE</code>. If
<code>TRUE</code>, the solutions (ie, decision variables) in every
generation are stored as lists <code>P</code> and <code>Pbest</code>, both
stored in the list <code>xlist</code> which the function returns. To
check, for instance, the solutions at the end of the <code>i</code>th
iteration, retrieve <code>xlist[[c(1L, i)]]</code>; the best solutions
at the end of this iteration are in <code>xlist[[c(2L,
      i)]]</code>. <code>P[[i]]</code> and <code>Pbest[[i]]</code> will be matrices of size
<code>length(algo$min)</code> times <code>algo$nP</code>.</p>
</dd>
<dt><code>classify</code></dt><dd><p>Logical; default is <code>FALSE</code>. If
<code>TRUE</code>, the result will have a class attribute <code>TAopt</code>
attached. This feature is <strong>experimental</strong>: the supported
methods may change without warning.</p>
</dd>
<dt><code>drop</code></dt><dd>
<p>Default is <code>TRUE</code>. If <code>FALSE</code>, the dimension is
not dropped from a single solution when it is
passed to a function. (That is, the function will
receive a single-column matrix.)
</p>
</dd>
</dl>
 


<h3>Value</h3>

<p>Returns a list:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>the solution</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value of best solution</p>
</td></tr>
<tr><td><code>popF</code></td>
<td>
<p>a vector: the objective function values in the final population</p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>if <code>algo$storeF</code> is <code>TRUE</code>, a matrix of size <code>algo$nG</code>
times <code>algo$nP</code>. Each column contains the best objective function value found by the particular solution.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a list that contains two
lists <code>P</code> and <code>Pbest</code> of matrices, and a matrix <code>initP</code> (the
initial solution); else <code>NA</code>.
</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when <code>PSopt</code> was called.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Eberhart, R.C. and Kennedy, J. (1995) A New Optimizer using Particle
Swarm theory.  <em>Proceedings of the Sixth International Symposium
on Micromachine and Human Science</em>, pp. 39&ndash;43.
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEopt">DEopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Least Median of Squares (LMS) estimation
genData &lt;- function(nP, nO, ol, dy) {
    ## create dataset as in Salibian-Barrera &amp; Yohai 2006
    ## nP = regressors, nO  = number of obs
    ## ol = number of outliers, dy  = outlier size
    mRN &lt;- function(m, n) array(rnorm(m * n), dim = c(m, n))
    y &lt;- mRN(nO, 1)
    X &lt;- cbind(as.matrix(numeric(nO) + 1), mRN(nO, nP - 1L))
    zz &lt;- sample(nO)
    z  &lt;- cbind(1, 100, array(0, dim = c(1L, nP - 2L)))
    for (i in seq_len(ol)) {
        X[zz[i], ] &lt;- z
        y[zz[i]] &lt;- dy
    }
    list(X = X, y = y)
}

OF &lt;- function(param, data) {
    X &lt;- data$X
    y &lt;- data$y
    aux &lt;- as.vector(y) - X %*% param
    ## as.vector(y) for recycling (param is a matrix)
    aux &lt;- aux * aux
    aux &lt;- apply(aux, 2, sort, partial = data$h)
    aux[h, ]
}

nP &lt;- 2L; nO &lt;- 100L; ol &lt;- 10L; dy &lt;- 150
aux &lt;- genData(nP,nO,ol,dy); X &lt;- aux$X; y &lt;- aux$y

h &lt;- (nO + nP + 1L) %/% 2
data &lt;- list(y = y, X = X, h = h)

algo &lt;- list(min = rep(-10, nP), max = rep( 10, nP),
    c1 = 1.0, c2 = 2.0,
    iner = 0.7, initV = 1, maxV = 3,
    nP = 100L, nG = 300L, loopOF = FALSE)

system.time(sol &lt;- PSopt(OF = OF, algo = algo, data = data))
if (require("MASS", quietly = TRUE)) {
    ## for nsamp = "best", in this case, complete enumeration
    ## will be tried. See ?lqs
    system.time(test1 &lt;- lqs(data$y ~ data$X[, -1L],
            adjust = TRUE,
            nsamp = "best",
            method = "lqs",
            quantile = data$h))
}
## check
x1 &lt;- sort((y - X %*% as.matrix(sol$xbest))^2)[h]
cat("Particle Swarm\n",x1,"\n\n")

if (require("MASS", quietly = TRUE)) {
    x2 &lt;- sort((y - X %*% as.matrix(coef(test1)))^2)[h]
    cat("lqs\n", x2, "\n\n")
}
</code></pre>

<hr>
<h2 id='putCallParity'>
Put-Call Parity
</h2><span id='topic+putCallParity'></span>

<h3>Description</h3>

<p>Put&ndash;call parity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  putCallParity(what, call, put, S, X, tau, r, q = 0, tauD = 0, D = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="putCallParity_+3A_what">what</code></td>
<td>
<p>character: what to compute. Currently only <code>call</code> or <code>put</code> are supported.</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_call">call</code></td>
<td>
<p>call price</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_put">put</code></td>
<td>
<p>put price</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_s">S</code></td>
<td>
<p>underlier</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_x">X</code></td>
<td>
<p>strike</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_tau">tau</code></td>
<td>
<p>time to expiry</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_r">r</code></td>
<td>
<p>interest rate</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_q">q</code></td>
<td>
<p>dividend rate</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_taud">tauD</code></td>
<td>
<p>numeric vector: time to dividend</p>
</td></tr>
<tr><td><code id="putCallParity_+3A_d">D</code></td>
<td>
<p>numeric vector: dividends</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Put&ndash;call parity only works for European options. The function is
vectorised (like <code><a href="#topic+vanillaOptionEuropean">vanillaOptionEuropean</a></code>), except for
dividends.
</p>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- 100; X &lt;- 100; tau &lt;- 1; r &lt;- 0.02; q &lt;- 0.0;
vol &lt;- 0.3; D &lt;- 20; tauD &lt;- 0.5
call &lt;- vanillaOptionEuropean(S, X, tau, r, q, vol^2,
                              tauD = tauD, D = D, type = "call")$value
put  &lt;- vanillaOptionEuropean(S, X, tau, r, q, vol^2,
                              tauD = tauD, D = D, type = "put")$value

## recover the call from the put (et vice versa)
all.equal(call, putCallParity("call", put = put,  S=S, X=X, tau=tau,
                              r=r, q=q, tauD=tauD, D=D))
all.equal(put, putCallParity("put",  call = call, S=S, X=X, tau=tau,
                             r=r, q=q, tauD=tauD, D=D))


## Black--Scholes--Merton with with 'callCF'
S &lt;- 100; X &lt;- 90; tau &lt;- 1; r &lt;- 0.02; q &lt;- 0.08
v &lt;- 0.2^2  ## variance, not volatility

(ccf &lt;- callCF(cf = cfBSM, S = S, X = X, tau = tau, r = r, q = q,
                 v = v, implVol = TRUE))
all.equal(ccf$value,
          vanillaOptionEuropean(S, X, tau, r, q, v, type = "call")$value)
all.equal(
  putCallParity("put", call=ccf$value, S=S, X=X, tau=tau, r=r, q=q),
  vanillaOptionEuropean(S, X, tau, r, q, v, type = "put")$value)
</code></pre>

<hr>
<h2 id='qTable'>
Prepare LaTeX Table with Quartile Plots
</h2><span id='topic+qTable'></span>

<h3>Description</h3>

<p>The function returns the skeleton of a LaTeX tabular that contains the
median, minimum and maximum of the columns of a matrix <code>X</code>. For
each column, a quartile plot is added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qTable(X, xmin = NULL, xmax = NULL, labels = NULL, at = NULL,
       unitlength = "5cm", linethickness = NULL,
       cnames = colnames(X), circlesize = 0.01,
       xoffset = 0, yoffset = 0, dec = 2, filename = NULL,
       funs = list(median = median, min = min, max = max),
       tabular.format, skip = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qTable_+3A_x">X</code></td>
<td>

<p>a numeric matrix (or an object that can be coerced to a numeric
matrix with <code>as.matrix</code>)
</p>
</td></tr>
<tr><td><code id="qTable_+3A_xmin">xmin</code></td>
<td>

<p>optional: the minimum for the x-axis. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_xmax">xmax</code></td>
<td>

<p>optional: the maximum for the x-axis. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_labels">labels</code></td>
<td>

<p>optional: labels for the x-axis.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_at">at</code></td>
<td>

<p>optional: where to put labels.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_unitlength">unitlength</code></td>
<td>

<p>the unitlength for LaTeX's <code>picture</code> environment. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_linethickness">linethickness</code></td>
<td>

<p>the linethickness for LaTeX's <code>picture</code> environment. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_cnames">cnames</code></td>
<td>

<p>the column names of <code>X</code>
</p>
</td></tr>
<tr><td><code id="qTable_+3A_circlesize">circlesize</code></td>
<td>

<p>the size of the circle in LaTeX's <code>picture</code> environment
</p>
</td></tr>
<tr><td><code id="qTable_+3A_xoffset">xoffset</code></td>
<td>

<p>defaults to 0. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_yoffset">yoffset</code></td>
<td>

<p>defaults to 0. See Details.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_dec">dec</code></td>
<td>

<p>the number of decimals
</p>
</td></tr>
<tr><td><code id="qTable_+3A_filename">filename</code></td>
<td>

<p>if provided, output is <code>cat</code> into a file
</p>
</td></tr>
<tr><td><code id="qTable_+3A_funs">funs</code></td>
<td>

<p>A <code><a href="base.html#topic+list">list</a></code> of functions; the functions should be
named. Default is
</p>
<p><code>list(median = median, min = min, max = max)</code>
</p>
</td></tr>
<tr><td><code id="qTable_+3A_tabular.format">tabular.format</code></td>
<td>
<p>optional: character string like <code>"rrrrr"</code>
that defines the format of the tabular.
</p>
</td></tr>
<tr><td><code id="qTable_+3A_skip">skip</code></td>
<td>
<p>Adds a newline at the end of the tabular. Default is
<code>TRUE</code>. (The behaviour prior to  package version 0.27-0
corresponded to <code>FALSE</code>.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a one-column character matrix that can be put into
a LaTeX file (the matrix holds a tabular). It relies on LaTeX's
<code>picture</code> environment and should work for LaTeX and pdfLaTeX. Note
that the tabular needs generally be refined, depending on the settings
and the data.
</p>
<p>The tabular has one row for every column of <code>X</code> (and header and
footer rows). A given row contains (per default) the median, the minimum
and the maximum of the column; it also includes a <code>picture</code>
environment the shows a quartile plot of the distribution of the
elements in that column. Other functions can be specified via argument
<code>funs</code>.
</p>
<p>A number of parameters can be passed to LaTeX's <code>picture</code>
environment: <code>unitlength</code>, <code>xoffset</code>, <code>yoffset</code>,
<code>linethickness</code>. Sizes and lengths are functions of
<code>unitlength</code> (<code>linethickness</code> is an exception; and while
<code>circlesize</code> is a multiple of unitlength, it will not translate
into an actual diameter of more than 14mm).
</p>
<p>The whole tabular environment is put into curly brackets so that the
settings do not change settings elsewhere in the LaTeX document.
</p>
<p>If <code>xmin</code>, <code>xmax</code>, <code>labels</code> and <code>at</code> are not
specified, they are computed through a call to <code><a href="base.html#topic+pretty">pretty</a></code> from
the <span class="pkg">base</span> package. If limits are specified, then both <code>xmin</code>
and <code>xmax</code> must be set; if labels are used, then both <code>labels</code>
and <code>at</code> must be specified.
</p>
<p>To use the function in a vignette, use <code><a href="base.html#topic+cat">cat</a>(tTable(X))</code> (and
<code>results=tex</code> in the code chunk options).  The vignette
<code>qTableEx</code> shows some examples.
</p>


<h3>Value</h3>

<p>A matrix of mode character. If <code>filename</code> is specified then
<code>qTable</code> will have the side effect of writing a textfile with a
LaTeX tabular.
</p>


<h3>Note</h3>

<p><code>qTable</code> returns a raw draft of a table for LaTeX. Please, spend
some time on making it pretty.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Tufte, E. (2001) <em>The Visual Display of Quantitative
Information</em>. 2nd edition, Graphics Press.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, mean = 0, sd = 2)
y &lt;- rnorm(100, mean = 1, sd = 2)
z &lt;- rnorm(100, mean = 1, sd = 0.5)
X &lt;- cbind(x, y, z)
res &lt;- qTable(X)
print(res)
cat(res)

## Not run: 
## show vignette with examples
qt &lt;- vignette("qTableEx", package = "NMOF")
print(qt)
edit(qt)


## create a simple LaTeX file 'test.tex':
## ---
##  \documentclass{article}
##  \begin{document}
##    \input{res.tex}
##  \end{document}
## ---

res &lt;- qTable(X, filename = "res.tex", yoffset = -0.025, unitlength = "5cm",
              circlesize = 0.0125, xmin = -10, xmax = 10, dec = 2)
## End(Not run)
</code></pre>

<hr>
<h2 id='randomReturns'>
Create a Random Returns
</h2><span id='topic+randomReturns'></span>

<h3>Description</h3>

<p>Create a matrix of random returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomReturns(na, ns, sd, mean = 0, rho = 0, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomReturns_+3A_na">na</code></td>
<td>

<p>number of assets
</p>
</td></tr>
<tr><td><code id="randomReturns_+3A_ns">ns</code></td>
<td>

<p>number of return scenarios
</p>
</td></tr>
<tr><td><code id="randomReturns_+3A_sd">sd</code></td>
<td>

<p>the standard deviation: either a single number or a vector
of length <code>na</code>
</p>
</td></tr>
<tr><td><code id="randomReturns_+3A_mean">mean</code></td>
<td>

<p>the mean return: either a single number or a vector
of length <code>na</code>
</p>
</td></tr>
<tr><td><code id="randomReturns_+3A_rho">rho</code></td>
<td>

<p>correlation: either a scalar (i.e. a constant pairwise correlation)
or a correlation matrix
</p>
</td></tr>
<tr><td><code id="randomReturns_+3A_exact">exact</code></td>
<td>

<p>logical: if <code>TRUE</code>, return a random matrix whose
column means, standard deviations and correlations match the
specified values exactly (up to numerical precision)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function corresponds to the function <code>random_returns</code>,
described in the second edition of <abbr><span class="acronym">NMOF</span></abbr> (the book).
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+numeric">numeric</a></code> <code><a href="base.html#topic+matrix">matrix</a></code> of size <code>na</code> times
<code>ns</code>
</p>


<h3>Note</h3>

<p>The function corresponds to the function <code>random_returns</code>,
described in the second edition of <abbr><span class="acronym">NMOF</span></abbr> (the book).
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc">mc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("quadprog")) {
    ## a small experiment: when computing minimum-variance portfolios
    ## for correlated assets, how many large positions are in the portfolio?

    na &lt;- 100  ## number of assets
    inc &lt;-  5  ## minimum of assets to include

    n &lt;- numeric(10)
    for (i in seq_along(n)) {
        R &lt;- randomReturns(na = na,
                           ns = 500,
                           sd = seq(.2/.16, .5/.16, length.out = 100),
                           rho = 0.5)
        n[i] &lt;- sum(minvar(cov(R), wmax = 1/inc)&gt; 0.01)
    }
    summary(n)
}
</code></pre>

<hr>
<h2 id='repairMatrix'>
Repair an Indefinite Correlation Matrix
</h2><span id='topic+repairMatrix'></span>

<h3>Description</h3>

<p>The function &lsquo;repairs&rsquo; an indefinite correlation
matrix by replacing its negative eigenvalues by zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairMatrix(C, eps = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repairMatrix_+3A_c">C</code></td>
<td>
<p>a correlation matrix</p>
</td></tr>
<tr><td><code id="repairMatrix_+3A_eps">eps</code></td>
<td>
<p>a small number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function &lsquo;repairs&rsquo; a correlation matrix: it
replaces negative eigenvalues with <code>eps</code> and rescales
the matrix such that all elements on the main diagonal
become unity again.
</p>


<h3>Value</h3>

<p>Returns a numeric matrix.
</p>


<h3>Note</h3>

<p>This function may help to cure a numerical problem, but it will rarely
help to cure an empirical problem. (Garbage in, garbage out.)
</p>
<p>See also the function <code>nearPD</code> in the <span class="pkg">Matrix</span> package.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Rebonato, R. and Jaeckel, P. (1999) The most general methodology to
create a valid correlation matrix for risk management and option
pricing purposes.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example: build a portfolio of three assets
C &lt;- c(1,.9,.9,.9,1,.2,.9,.2,1)
dim(C) &lt;- c(3L, 3L)
eigen(C, only.values = TRUE)

vols &lt;- c(.3, .3, .3)      ## volatilities
S &lt;- C * outer(vols,vols)  ## covariance matrix
w &lt;- c(-1, 1, 1)           ## a portfolio
w %*% S %*% w          ## variance of portfolio is negative!
sqrt(as.complex(w %*% S %*% w))

S &lt;- repairMatrix(C) * outer(vols,vols)
w %*% S %*% w          ## more reasonable
sqrt(w %*% S %*% w)
</code></pre>

<hr>
<h2 id='resampleC'>
Resample with Specified Rank Correlation
</h2><span id='topic+resampleC'></span>

<h3>Description</h3>

<p>Resample with replacement from a number of vectors; the sample will
have a specified rank correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resampleC(..., size, cormat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resampleC_+3A_...">...</code></td>
<td>

<p>numeric vectors; they need not have the same length.
</p>
</td></tr>
<tr><td><code id="resampleC_+3A_size">size</code></td>
<td>

<p>an integer: the number of samples to draw
</p>
</td></tr>
<tr><td><code id="resampleC_+3A_cormat">cormat</code></td>
<td>

<p>the rank correlation matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Gilli, Maringer and Schumann (2011), Section 7.1.2. The function
samples with replacement from the vectors passed through
<code>...</code>. The resulting samples will have an (approximate) rank
correlation as specified in <code>cormat</code>.
</p>
<p>The function uses the eigenvalue decomposition to generate the
correlation; it will not break down in case of a semidefinite
matrix. If an eigenvalue of <code>cormat</code> is smaller than zero, a
warning is issued (but the function proceeds).
</p>


<h3>Value</h3>

<p>a numeric matrix with <code>size</code> rows. The columns contain the
samples; hence, there will be as many columns as vectors passed
through <code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repairMatrix">repairMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a sample
v1 &lt;- rnorm(20)
v2 &lt;- runif(50)
v3 &lt;- rbinom(100, size = 50, prob = 0.4)

## a correlation matrix
cormat &lt;- array(0.5, dim = c(3, 3))
diag(cormat) &lt;- 1

cor(resampleC(a = v1, b = v2, v3, size = 100, cormat = cormat),
    method = "spearman")
</code></pre>

<hr>
<h2 id='restartOpt'>
Restart an Optimisation Algorithm
</h2><span id='topic+restartOpt'></span>

<h3>Description</h3>

<p>The function provides a simple wrapper for the optimisation algorithms in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restartOpt(fun, n, OF, algo, ...,
           method = c("loop", "multicore", "snow"),
           mc.control = list(), cl = NULL,
           best.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restartOpt_+3A_fun">fun</code></td>
<td>

<p>the optimisation function: <code>DEopt</code>, <code>GAopt</code>, <code>LSopt</code>,
<code>TAopt</code> or <code>PSopt</code>
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_n">n</code></td>
<td>

<p>the number of restarts
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_of">OF</code></td>
<td>

<p>the objective function
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_algo">algo</code></td>
<td>

<p>the list <code>algo</code> that is passed to the particular optimisation function
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_...">...</code></td>
<td>

<p>additional data that is passed to the particular optimisation function
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_method">method</code></td>
<td>

<p>can be <code>loop</code> (the default), <code>multicore</code>
or <code>snow</code>. See Details.
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_mc.control">mc.control</code></td>
<td>

<p>a list containing settings that will be passed to <code>mclapply</code> if
<code>method</code> is <code>multicore</code>. Must be a list of named
elements. See the documentation of <code>mclapply</code>.
</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_cl">cl</code></td>
<td>

<p>default is <code>NULL</code>. If method <code>snow</code> is used, this must be
a cluster object or an integer (the number of cores).</p>
</td></tr>
<tr><td><code id="restartOpt_+3A_best.only">best.only</code></td>
<td>
<p>if <code>TRUE</code>, only the best run is
reported. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list of lists. If a specific starting solution
is passed, all runs will start from this solution. If this is not
desired, initial solutions can be created randomly. This is done per
default in <code><a href="#topic+DEopt">DEopt</a></code>, <code><a href="#topic+GAopt">GAopt</a></code> and
<code><a href="#topic+PSopt">PSopt</a></code>, but <code><a href="#topic+LSopt">LSopt</a></code> and <code><a href="#topic+TAopt">TAopt</a></code>
require to specify a starting solution.
</p>
<p>In case of <code><a href="#topic+LSopt">LSopt</a></code> and <code><a href="#topic+TAopt">TAopt</a></code>, the passed
initial solution <code>algo$x0</code> is checked with <code>is.function</code>: if
<code>TRUE</code>, the function is evaluated in each single run. For
<code><a href="#topic+DEopt">DEopt</a></code>, <code><a href="#topic+GAopt">GAopt</a></code> and <code><a href="#topic+PSopt">PSopt</a></code>, the
initial solution (which also can be a function) is specified with
<code>algo$initP</code>.
</p>
<p>The argument <code>method</code> determines how <code>fun</code> is
evaluated. Default is <code>loop</code>. If <code>method</code> is &quot;multicore&quot;,
function <code>mclapply</code> from package <span class="pkg">parallel</span> is used. Further
settings for <code>mclapply</code> can be passed through the list
<code>mc.control</code>. If <code>multicore</code> is chosen but the functionality
is not available, then <code>method</code> will be set to <code>loop</code> and a
warning is issued. If <code>method == "snow"</code>, function
<code>clusterApply</code> from package <span class="pkg">parallel</span> is used. In this case,
the argument <code>cl</code> must either be a cluster object (see the
documentation of <code>clusterApply</code>) or an integer. If an integer, a
cluster will be set up via <code>makeCluster(c(rep("localhost", cl)),
  type = "SOCK")</code>, and <code>stopCluster</code> is called when the function is
exited. If <code>snow</code> is chosen but <span class="pkg">parallel</span> is not available
or <code>cl</code> is not specified, then <code>method</code> will be set to
<code>loop</code> and a warning is issued. In case that <code>cl</code> is an
cluster object, <code>stopCluster</code> will not be called automatically.
</p>


<h3>Value</h3>

<p>If <code>best.only</code> is <code>FALSE</code> (the default), the function
returns a list of <code>n</code> lists. Each of the <code>n</code> lists stores
the output of one of the runs.
</p>
<p>If <code>best.only</code> is <code>TRUE</code>, only the best restart is
reported. The returned list has the structure specific to the used
method.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEopt">DEopt</a></code>, <code><a href="#topic+GAopt">GAopt</a></code>, <code><a href="#topic+LSopt">LSopt</a></code>,
<code><a href="#topic+PSopt">PSopt</a></code>, <code><a href="#topic+TAopt">TAopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see example(DEopt)
algo &lt;- list(nP = 50L,
              F = 0.5,
             CR = 0.9,
            min = c(-10, -10),
            max = c( 10,  10),
    printDetail = FALSE,
       printBar = FALSE)

## choose a larger 'n' when you can afford it
algo$nG &lt;- 100L
res100 &lt;- restartOpt(DEopt, n = 5L, OF = tfTrefethen, algo = algo)
res100F &lt;- sapply(res100, `[[`, "OFvalue")

algo$nG &lt;- 200L
res200 &lt;- restartOpt(DEopt, n = 5L, OF = tfTrefethen, algo = algo)
res200F &lt;- sapply(res200, `[[`, "OFvalue")

xx &lt;- pretty(c(res100F, res200F, -3.31))
plot(ecdf(res100F), main = "optimum is -3.306",
     xlim = c(xx[1L], tail(xx, 1L)))
abline(v = -3.3069, col = "red")  ## optimum
lines(ecdf(res200F), col = "blue")
legend(x = "right", box.lty = 0, , lty = 1,
      legend = c("optimum", "100 generations", "200 generations"),
      pch = c(NA, 19, 19), col = c("red", "black", "blue"))

## a 'best-of-N' strategy: given a sample x of objective
## function values, compute the probability that, after N draws,
## we have at least one realisation not worse than X
x &lt;- c(0.1,.3,.5,.5,.6)
bestofN &lt;- function(x, N) {
    nx &lt;- length(x)
    function(X)
        1 - (sum(x &gt; X)/nx)^N
}
bestof2 &lt;- bestofN(x, 2)
bestof5 &lt;- bestofN(x, 5)
bestof2(0.15)
bestof5(0.15)


## Not run: 
## with R &gt;= 2.13.0 and the compiler package
algo$nG &lt;- 100L
system.time(res100 &lt;- restartOpt(DEopt, n = 10L, OF = tfTrefethen, algo = algo))

require("compiler")
enableJIT(3)
system.time(res100 &lt;- restartOpt(DEopt, n = 10L, OF = tfTrefethen, algo = algo))

## End(Not run)
</code></pre>

<hr>
<h2 id='Ritter'>
Download Jay Ritter's IPO Data
</h2><span id='topic+Ritter'></span>

<h3>Description</h3>

<p>Download IPO data provided by Jay Ritter
and transform them into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ritter(dest.dir,
        url = "https://site.warrington.ufl.edu/ritter/files/IPO-age.xlsx")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ritter_+3A_dest.dir">dest.dir</code></td>
<td>

<p>character: a path to a directory
</p>
</td></tr>
<tr><td><code id="Ritter_+3A_url">url</code></td>
<td>

<p>the data URL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function downloads <abbr><span class="acronym">IPO</span></abbr> data provided by Jay
R. Ritter <a href="https://site.warrington.ufl.edu/ritter/">https://site.warrington.ufl.edu/ritter/</a>.
Since the data are provided in Excel format, package
<span class="pkg">openxlsx</span> is required.
</p>
<p>The downloaded Excel gets a date prefix (today in
format <code>YYYYMMDD</code>) and is stored in directory
<code>dest.dir</code>. Before any download is attempted,
the function checks whether a file with today's
prefix exist in <code>dest.dir</code>; if yes, this file is
used.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>:
</p>
<table role = "presentation">
<tr><td><code>CUSIP</code></td>
<td>
<p>CUSIP</p>
</td></tr>
<tr><td><code>Offer date</code></td>
<td>
<p>a <code><a href="base.html#topic+Date">Date</a></code></p>
</td></tr>
<tr><td><code>Company name</code></td>
<td>
<p>character: Company name</p>
</td></tr>
<tr><td><code>Ticker</code></td>
<td>
<p>character: Ticker</p>
</td></tr>
<tr><td><code>Founding</code></td>
<td>
<p>Founding year</p>
</td></tr>
<tr><td><code>PERM</code></td>
<td>
<p>PERM</p>
</td></tr>
<tr><td><code>VC dummy</code></td>
<td>
<p>VC Dummy</p>
</td></tr>
<tr><td><code>Rollup</code></td>
<td>
<p>Rollup</p>
</td></tr>
<tr><td><code>Dual</code></td>
<td>
<p>Dual</p>
</td></tr>
<tr><td><code>Post-issue shares</code></td>
<td>
<p>Post-issue shares</p>
</td></tr>
<tr><td><code>Internet</code></td>
<td>
<p>Internet</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p><a href="https://site.warrington.ufl.edu/ritter/ipo-data/">https://site.warrington.ufl.edu/ritter/ipo-data/</a>
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+French">French</a></code>, <code><a href="#topic+Shiller">Shiller</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
archive.dir &lt;- "~/Downloads/Ritter"
if (!dir.exists(archive.dir))
    dir.create(archive.dir)
Ritter(archive.dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='SA.info'>
Simulated-Annealing Information
</h2><span id='topic+SA.info'></span>

<h3>Description</h3>

<p>The function can be called from the objective and neighbourhood
function during a run of <code><a href="#topic+SAopt">SAopt</a></code>; it provides information
such as the current iteration, the current solution, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SA.info(n = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SA.info_+3A_n">n</code></td>
<td>

<p>generational offset; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>This function is still experimental.</b>
</p>
<p>The function can be called in the neighbourhood function or the
objective function during a run of <code><a href="#topic+SAopt">SAopt</a></code>.  It evaluates
to a list with information about the state of the optimisation run,
such as the current iteration or the currently best solution.
</p>
<p><code>SA.info</code> relies on <code><a href="base.html#topic+parent.frame">parent.frame</a></code> to retrieve its
information.  If the function is called within another function within
the neighbourhood or objective function, the argument <code>n</code> needs
to be increased.
</p>


<h3>Value</h3>

<p>A list
</p>
<table role = "presentation">
<tr><td><code>calibration</code></td>
<td>
<p>logical: whether the algorithm is calibrating the
acceptance probability</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>current iteration</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>current step for the given temperature level</p>
</td></tr>
<tr><td><code>temperature</code></td>
<td>
<p>current temperature (the number, not the value)</p>
</td></tr>
<tr><td><code>xbest</code></td>
<td>
<p>the best solution found so far</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SAopt">SAopt</a></code>, <code><a href="#topic+TA.info">TA.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### MINIMAL EXAMPLE for SAopt

## the objective function evaluates to a constant
fun &lt;- function(x)
    0

## the neighbourhood function does not even change
## the solution; it only reports information
nb &lt;- function(x) {
    info &lt;- SA.info()
    cat("current step ",        info$step,
        "| current iteration ", info$iteration, "\n")
    x
}

## run SA
algo &lt;- list(nS = 5, nT = 2, nD = 10,
             initT = 1,
             x0 = rep(0, 5),
             neighbour = nb,
             printBar = FALSE)
ignore &lt;- SAopt(fun, algo)
</code></pre>

<hr>
<h2 id='SAopt'>
Optimisation with Simulated Annealing
</h2><span id='topic+SAopt'></span>

<h3>Description</h3>

<p>The function implements a Simulated-Annealing algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAopt(OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SAopt_+3A_of">OF</code></td>
<td>
<p>The objective function, to be minimised. Its first argument
needs to be a solution <code>x</code>; it will be called as <code>OF(x,
      ...)</code>.</p>
</td></tr>
<tr><td><code id="SAopt_+3A_algo">algo</code></td>
<td>
<p>A list of settings for the algorithm. See
Details.</p>
</td></tr>
<tr><td><code id="SAopt_+3A_...">...</code></td>
<td>
<p>other variables passed to <code>OF</code> and
<code>algo$neighbour</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulated Annealing (<abbr><span class="acronym">SA</span></abbr>) changes an initial solution
iteratively; the algorithm stops after a fixed number of
iterations. Conceptually, <abbr><span class="acronym">SA</span></abbr> consists of a loop than runs
for a number of iterations. In each iteration, a current solution
<code>xc</code> is changed through a function <code>algo$neighbour</code>. If this
new (or neighbour) solution <code>xn</code> is not worse than <code>xc</code>, ie,
if <code>OF(xn,...) &lt;= OF(xc,...)</code>, then <code>xn</code> replaces
<code>xc</code>. If <code>xn</code> is worse, it still replaces <code>xc</code>, but
only with a certain probability. This probability is a function of the
degree of the deterioration (the greater, the less likely the new
solution is accepted) and the current iteration (the longer the
algorithm has already run, the less likely the new
solution is accepted).
</p>
<p>The list <code>algo</code> contains the following items.
</p>

<dl>
<dt><code>nS</code></dt><dd><p>The number of steps per temperature. The default is
1000; but this setting depends very much on the problem.</p>
</dd>
<dt><code>nT</code></dt><dd><p>The number of temperatures. Default is 10.</p>
</dd>
<dt><code>nI</code></dt><dd>
<p>Total number of iterations, with default
<code>NULL</code>. If specified, it will override
<code>nS</code> with <code>ceiling(nI/nT)</code>. Using this
option makes it easier to compare and switch
between functions <code><a href="#topic+LSopt">LSopt</a></code>,
<code><a href="#topic+TAopt">TAopt</a></code> and <code><a href="#topic+SAopt">SAopt</a></code>.
</p>
</dd>
<dt><code>nD</code></dt><dd><p>The number of random steps to calibrate the
temperature. Defaults to 2000.</p>
</dd>
<dt><code>initT</code></dt><dd><p>Initial temperature. Defaults to <code>NULL</code>, in
which case it is automatically chosen so that <code>initProb</code> is
achieved.</p>
</dd>
<dt><code>finalT</code></dt><dd><p>Final temperature. Defaults to 0.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The cooling constant. The current temperature is
multiplied by this value. Default is 0.9.</p>
</dd>
<dt><code>mStep</code></dt><dd><p>Step multiplier. The default is 1, which implies
constant number of steps per temperature. If greater than 1, the step
number <code>nS</code> is increased to <code>m*nS</code> (and rounded).</p>
</dd>
<dt><code>x0</code></dt><dd><p>The initial solution. If this is a function, it will
be called once without arguments to compute an initial solution, ie,
<code>x0 &lt;- algo$x0()</code>. This can be useful when the routine is
called in a loop of restarts, and each restart is to have its own
starting value.</p>
</dd>
<dt><code>neighbour</code></dt><dd><p>The neighbourhood function, called as
<code>neighbour(x, ...)</code>. Its first argument must be a solution
<code>x</code>; it must return a changed solution.</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information
is printed. If an integer <code>i</code> greater then one, information
is printed at very <code>i</code>th iteration.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (default is <code>FALSE</code>), a
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (from package <span class="pkg">utils</span>) is
printed. The progress bar is not shown if <code>printDetail</code> is an
integer greater than 1.</p>
</dd>
<dt><code>storeF</code></dt><dd><p>if <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>Default is <code>FALSE</code>. If
<code>TRUE</code>, the solutions (ie, decision variables) in every
generation are stored and returned in list <code>xlist</code> (see Value
section below). To check, for instance, the current solution at
the end of the <code>i</code>th generation, retrieve <code>xlist[[c(2L,
      i)]]</code>.</p>
</dd>
<dt><code>classify</code></dt><dd><p>Logical; default is <code>FALSE</code>. If
<code>TRUE</code>, the result will have a class attribute <code>SAopt</code>
attached.</p>
</dd>
<dt><code>OF.target</code></dt><dd><p>Numeric; when specified, the algorithm will
stop when an objective-function value as low as <code>OF.target</code> (or
lower) is achieved. This is useful when an optimal
objective-function value is known: the algorithm will then stop and
not waste time searching for a better solution.</p>
</dd>
</dl>
 
<p>At the minimum, <code>algo</code> needs to contain an initial solution
<code>x0</code> and a <code>neighbour</code> function.
</p>
<p>The total number of iterations equals <code>algo$nT</code> times
<code>algo$nS</code> (plus possibly <code>algo$nD</code>).
</p>


<h3>Value</h3>

<p><code>SAopt</code> returns a list with five components:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>the solution</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value of the solution, ie,
<code>OF(xbest, ...)</code></p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>if <code>algo$storeF</code> is <code>TRUE</code>, a matrix with
one row for each iteration (excluding the initial <code>algo$nD</code>
steps) and two columns. The first column contains the objective
function values of the neighbour solution at a given iteration; the
second column contains the value of the current solution. Since
<abbr><span class="acronym">SA</span></abbr> can walk away from locally-optimal solutions, the best
solution can be monitored through <code>cummin(Fmat[ ,2L])</code>.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a
list; else <code>NA</code>. Contains the neighbour solutions at a given
iteration (<code>xn</code>) and the current solutions
(<code>xc</code>). Example: <code>Fmat[i, 2L]</code> is the objective function
value associated with <code>xlist[[c(2L, i)]]</code>.</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when the function was called.</p>
</td></tr>
</table>
<p>If <code>algo$classify</code> was set to <code>TRUE</code>, the resulting list
will have a class attribute <code>TAopt</code>.
</p>


<h3>Note</h3>

<p>If the <code>...</code> argument is used, then all the objects passed
with <code>...</code> need to go into the objective function and the
neighbourhood function. It is recommended to collect all information
in a list <code>myList</code> and then write <code>OF</code> and <code>neighbour</code>
so that they are called as <code>OF(x, myList)</code> and <code>neighbour(x,
      myList)</code>. Note that <code>x</code> need not be a vector but can be any data
structure (eg, a <code>matrix</code> or a <code>list</code>).
</p>
<p>Using an initial and final temperature of zero means that
<abbr><span class="acronym">SA</span></abbr> will be equivalent to a Local Search. The function
<code><a href="#topic+LSopt">LSopt</a></code> may be preferred then because of smaller
overhead.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Kirkpatrick, S., Gelatt, C.D. and Vecchi, M.P. (1983). Optimization
with Simulated Annealing. Science. <strong>220</strong> (4598), 671&ndash;680.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSopt">LSopt</a></code>, <code><a href="#topic+TAopt">TAopt</a></code>, <code><a href="#topic+restartOpt">restartOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Aim: given a matrix x with n rows and 2 columns,
##      divide the rows of x into two subsets such that
##      in one subset the columns are highly correlated,
##      and in the other lowly (negatively) correlated.
##      constraint: a single subset should have at least 40 rows

## create data with specified correlation
n &lt;- 100L
rho &lt;- 0.7
C &lt;- matrix(rho, 2L, 2L); diag(C) &lt;- 1
x &lt;- matrix(rnorm(n * 2L), n, 2L) %*% chol(C)

## collect data
data &lt;- list(x = x, n = n, nmin = 40L)

## a random initial solution
x0 &lt;- runif(n) &gt; 0.5

## a neighbourhood function
neighbour &lt;- function(xc, data) {
    xn &lt;- xc
    p &lt;- sample.int(data$n, size = 1L)
    xn[p] &lt;- abs(xn[p] - 1L)
    # reject infeasible solution
    c1 &lt;- sum(xn) &gt;= data$nmin
    c2 &lt;- sum(xn) &lt;= (data$n - data$nmin)
    if (c1 &amp;&amp; c2) res &lt;- xn else res &lt;- xc
    as.logical(res)
}

## check (should be 1 FALSE and n-1 TRUE)
x0 == neighbour(x0, data)

## objective function
OF &lt;- function(xc, data)
    -abs(cor(data$x[xc, ])[1L, 2L] - cor(data$x[!xc, ])[1L, 2L])

## check
OF(x0, data)
## check
OF(neighbour(x0, data), data)

## plot data
par(mfrow = c(1,3), bty = "n")
plot(data$x,
     xlim = c(-3,3), ylim = c(-3,3),
     main = "all data", col = "darkgreen")

## *Local Search*
algo &lt;- list(nS = 3000L,
             neighbour = neighbour,
             x0 = x0,
             printBar = FALSE)
sol1 &lt;- LSopt(OF, algo = algo, data=data)
sol1$OFvalue

## *Simulated Annealing*
algo$nT &lt;- 10L
algo$nS &lt;- ceiling(algo$nS/algo$nT)
sol &lt;- SAopt(OF, algo = algo, data = data)
sol$OFvalue

c1 &lt;- cor(data$x[ sol$xbest, ])[1L, 2L]
c2 &lt;- cor(data$x[!sol$xbest, ])[1L, 2L]

lines(data$x[ sol$xbest, ], type = "p", col = "blue")

plot(data$x[ sol$xbest, ], col = "blue",
     xlim = c(-3, 3), ylim = c(-3, 3),
     main = paste("subset 1, corr.", format(c1, digits = 3)))

plot(data$x[!sol$xbest, ], col = "darkgreen",
     xlim = c(-3,3), ylim = c(-3,3),
     main = paste("subset 2, corr.", format(c2, digits = 3)))

## compare LS/SA
par(mfrow = c(1, 1), bty = "n")
plot(sol1$Fmat[ , 2L],type = "l", ylim=c(-1.5, 0.5),
     ylab = "OF", xlab = "Iterations")
lines(sol$Fmat[ , 2L],type = "l", col = "blue")
legend(x = "topright", legend = c("LS", "SA"),
       lty = 1, lwd = 2, col = c("black", "blue"))
</code></pre>

<hr>
<h2 id='Shiller'>
Download Robert Shiller's Data
</h2><span id='topic+Shiller'></span>

<h3>Description</h3>

<p>Download the data provided by Robert Shiller
and transform them into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shiller(dest.dir,
        url = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shiller_+3A_dest.dir">dest.dir</code></td>
<td>

<p>character: a path to a directory
</p>
</td></tr>
<tr><td><code id="Shiller_+3A_url">url</code></td>
<td>

<p>the data URL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function downloads US stock-market data provided
by Robert Shiller which he used in his book
&lsquo;Irrational Exhuberance&rsquo;.  Since the data are
provided in Excel format, package <span class="pkg">readxl</span> is
required.
</p>
<p>The downloaded Excel gets a date prefix (today in
format <code>YYYYMMDD</code>) and is stored in directory
<code>dest.dir</code>. Before any download is attempted,
the function checks whether a file with today's
prefix exist in <code>dest.dir</code>; if yes, the file is
used.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>:
</p>
<table role = "presentation">
<tr><td><code>Date</code></td>
<td>
<p>end of month</p>
</td></tr>
<tr><td><code>Price</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Dividend</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Earnings</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>CPI</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Long Rate</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Real Price</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Real Dividend</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Real Earnings</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>CAPE</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Shiller, R.J. (2015) <em>Irrational Exhuberance</em>.
Princeton University Press. 3rd edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+French">French</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
archive.dir &lt;- "~/Downloads/Shiller"
if (!dir.exists(archive.dir))
    dir.create(archive.dir)
Shiller(archive.dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='showExample'>
Display Code Examples
</h2><span id='topic+showExample'></span><span id='topic+showChapterNames'></span>

<h3>Description</h3>

<p>Display the code examples from
&lsquo;Numerical Methods and Optimization and Finance&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showExample(file = "", chapter = NULL, showfile = TRUE,
            includepaths = FALSE, edition = 2, search,
            ..., ignore.case = TRUE)
showChapterNames(edition = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showExample_+3A_file">file</code></td>
<td>

<p>a character vector of length one. See Details.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_chapter">chapter</code></td>
<td>

<p>optional: a character vector of length one, giving the chapter name
(see Details), or an integer, indicating a chapter number. Default
is <code>NULL</code>: look in all chapters.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_showfile">showfile</code></td>
<td>

<p>Should the file be displayed with <code><a href="base.html#topic+file.show">file.show</a></code>? Defaults
to <code>TRUE</code>. A file will be displayed only if one single file
only is identified by <code>file</code> and <code>chapter</code>.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_includepaths">includepaths</code></td>
<td>

<p>Should the file paths be displayed? Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+grepl">grepl</a></code>; see Details.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_edition">edition</code></td>
<td>

<p>an integer: <code>1</code> and <code>2</code> are supported
</p>
</td></tr>
<tr><td><code id="showExample_+3A_search">search</code></td>
<td>

<p>a regular expression: search in the code files. Not supported yet.
</p>
</td></tr>
<tr><td><code id="showExample_+3A_ignore.case">ignore.case</code></td>
<td>

<p>passed to <code>grepl</code>; see Examples. Default is <code>TRUE</code> (which
is much more helpful than the default <code>FALSE</code> before package
version 2)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>showExample</code> matches the specified file
argument against the available file names via
<code>grepl(file, all.filenames, ignore.case =
  ignore.case, ...)</code>. If <code>chapter</code> is specified, a
second match is performed, <code>grepl(chapter,
  all.chapternames, ignore.case = ignore.case, ...)</code>. The
<code>chapternames</code> are those in the book (e.g.,
&lsquo;Modeling dependencies&rsquo;). The selected files
are then those for which file name and chapter name
could be matched.
</p>


<h3>Value</h3>

<p><code>showExample</code> returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> of at least two
character vectors, Chapter and File. If <code>includepaths</code> is
<code>TRUE</code>, Paths are included. If no file is found, the
<code><a href="base.html#topic+data.frame">data.frame</a></code> has zero rows. If a single file is identified
and <code>showfile</code> is <code>TRUE</code>, the function has the side effect
of displaying that file.
</p>
<p><code>showChapterNames</code> returns a character vector: the
names of the book's chapters.
</p>


<h3>Note</h3>

<p>The behaviour of the function changed slightly with
version 2.0 to accommodate the code examples of the
second edition of the book. Specifically, the
function gained an argument <code>edition</code>, which
defaults to <code>2</code>. Also, the default for
<code>ignore.case</code> was changed to <code>TRUE</code>.  To
get back the old behaviour of the function, set
<code>edition</code> to <code>1</code> and <code>ignore.case</code> to
<code>FALSE</code>.
</p>
<p>The code files can also be downloaded from
<a href="https://gitlab.com/NMOF">https://gitlab.com/NMOF</a> .
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2011)
<em>Numerical Methods and Optimization in Finance</em>.
Elsevier. <a href="https://doi.org/10.1016/C2009-0-30569-3">doi:10.1016/C2009-0-30569-3</a>
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## list all files
showExample()  ## 2nd edition is default
showExample(edition = 1)

## list specific files
showExample("Appendix")
showExample("Backtesting")
showExample("Heuristics")

showExample("tutorial") ## matches against filename
showExample(chapter = 13)
showExample(chapter = "tutorial")

## show where a file is installed
showExample(chapter = "portfolio", includepaths = TRUE)



## first edition
showExample("equations.R", edition = 1)
showExample("example", chapter = "portfolio", edition = 1)

showExample("example", chapter = 13, edition = 1)
showExample("example", chapter = showChapterNames(1)[13L], edition = 1)
</code></pre>

<hr>
<h2 id='TA.info'>
Threshold-Accepting Information
</h2><span id='topic+TA.info'></span>

<h3>Description</h3>

<p>The function can be called from the objective and neighbourhood
function during a run of <code><a href="#topic+TAopt">TAopt</a></code>; it provides information
such as the current iteration, the current solution, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  TA.info(n = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TA.info_+3A_n">n</code></td>
<td>

<p>generational offset; see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>This function is still experimental.</b>
</p>
<p>The function can be called in the neighbourhood function or the
objective function during a run of <code><a href="#topic+TAopt">TAopt</a></code>.  It evaluates
to a list with the state of the optimisation run, such as the current
iteration.
</p>
<p><code>TA.info</code> relies on <code><a href="base.html#topic+parent.frame">parent.frame</a></code> to retrieve its
information.  If the function is called within another function in the
neighbourhood or objective function, the argument <code>n</code> needs to be
increased.
</p>


<h3>Value</h3>

<p>A list
</p>
<table role = "presentation">
<tr><td><code>OF.sampling</code></td>
<td>
<p>logical: if <code>TRUE</code>, is the algorithm sampling the objective
function to compute thresholds; otherwise (i.e. during the actual
optimisation) <code>FALSE</code></p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>current iteration</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>current step (i.e. for a given threshold)</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>current threshold (the number, not the value)</p>
</td></tr>
<tr><td><code>xbest</code></td>
<td>
<p>the best solution found so far</p>
</td></tr>
<tr><td><code>OF.xbest</code></td>
<td>
<p>objective function value of best solution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TAopt">TAopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### MINIMAL EXAMPLE for TAopt

## objective function evaluates to a constant
fun &lt;- function(x)
    0

## neighbourhood function does not even change the solution,
## but it reports information
nb &lt;- function(x) {
    tmp &lt;- TA.info()
    cat("current threshold ",   tmp$threshold,
        "| current step ",      tmp$step,
        "| current iteration ", tmp$iteration, "\n")
    x
}

## run TA
algo &lt;- list(nS = 5,
             nT = 2,
             nD = 3,
             x0 = rep(0, 5),
             neighbour = nb,
             printBar = FALSE,
             printDetail = FALSE)
ignore &lt;- TAopt(fun, algo)

## printed output:
##    current threshold  NA | current step  1 | current iteration  NA
##    current threshold  NA | current step  2 | current iteration  NA
##    current threshold  NA | current step  3 | current iteration  NA
##    current threshold   1 | current step  1 | current iteration  1
##    current threshold   1 | current step  2 | current iteration  2
##    current threshold   1 | current step  3 | current iteration  3
##    current threshold   1 | current step  4 | current iteration  4
##    current threshold   1 | current step  5 | current iteration  5
##    current threshold   2 | current step  1 | current iteration  6
##    current threshold   2 | current step  2 | current iteration  7
##    current threshold   2 | current step  3 | current iteration  8
##    current threshold   2 | current step  4 | current iteration  9
##    current threshold   2 | current step  5 | current iteration  10

</code></pre>

<hr>
<h2 id='TAopt'>
Optimisation with Threshold Accepting
</h2><span id='topic+TAopt'></span>

<h3>Description</h3>

<p>The function implements the Threshold Accepting algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TAopt(OF, algo = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TAopt_+3A_of">OF</code></td>
<td>
<p>The objective function, to be minimised. Its first argument
needs to be a solution <code>x</code>; it will be called as <code>OF(x,
  ...)</code>.</p>
</td></tr> <tr><td><code id="TAopt_+3A_algo">algo</code></td>
<td>
<p>A list of settings for the algorithm. See
Details.</p>
</td></tr> <tr><td><code id="TAopt_+3A_...">...</code></td>
<td>
<p>other variables passed to <code>OF</code> and
<code>algo$neighbour</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Threshold Accepting (<abbr><span class="acronym">TA</span></abbr>) changes an initial solution
iteratively; the algorithm stops after a fixed number of
iterations. Conceptually, <abbr><span class="acronym">TA</span></abbr> consists of a loop than runs
for a number of iterations. In each iteration, a current solution
<code>xc</code> is changed through a function <code>algo$neighbour</code>. If this
new (or neighbour) solution <code>xn</code> is not worse than <code>xc</code>, ie,
if <code>OF(xn,...) &lt;= OF(xc,...)</code>, then <code>xn</code> replaces
<code>xc</code>. If <code>xn</code> is worse, it still replaces <code>xc</code> as long
as the difference in &lsquo;quality&rsquo; between the two solutions is
less than a threshold <code>tau</code>; more precisely, as long as
<code>OF(xn,...) - tau &lt;= OF(xc,...)</code>. Thus, we also accept a new
solution that is worse than its predecessor; just not too much
worse. The threshold is typically decreased over the course of the
optimisation. For zero thresholds TA becomes a stochastic local
search.
</p>
<p>The thresholds can be passed through the list <code>algo</code> (see
below). Otherwise, they are automatically computed through the
procedure described in Gilli et al. (2006). When the thresholds are
created automatically, the final threshold is always zero.
</p>
<p>The list <code>algo</code> contains the following items.
</p>

<dl>
<dt><code>nS</code></dt><dd><p>The number of steps per threshold. The default is
1000; but this setting depends very much on the problem.</p>
</dd>
<dt><code>nT</code></dt><dd><p>The number of thresholds. Default is 10; ignored if
<code>algo$vT</code> is specified.</p>
</dd>
<dt><code>nI</code></dt><dd>
<p>Total number of iterations, with default
<code>NULL</code>. If specified, it will override
<code>nS</code> with <code>ceiling(nI/nT)</code>. Using this
option makes it easier to compare and switch
between functions <code><a href="#topic+LSopt">LSopt</a></code>,
<code><a href="#topic+TAopt">TAopt</a></code> and <code><a href="#topic+SAopt">SAopt</a></code>.
</p>
</dd>
<dt><code>nD</code></dt><dd><p>The number of random steps to compute the threshold
sequence. Defaults to 2000. Only used if <code>algo$vT</code> is <code>NULL</code>.</p>
</dd>
<dt><code>q</code></dt><dd><p>The highest quantile for the threshold
sequence. Defaults to 0.5. Only used if <code>algo$vT</code> is
<code>NULL</code>. If <code>q</code> is zero, <code>TAopt</code> will run with
<code>algo$nT</code> zero-thresholds (ie, like a Local Search).</p>
</dd>
<dt><code>x0</code></dt><dd><p>The initial solution. If this is a function, it will
be called once without arguments to compute an initial solution, ie,
<code>x0 &lt;- algo$x0()</code>. This can be useful when the routine is
called in a loop of restarts, and each restart is to have its own
starting value.</p>
</dd>
<dt><code>vT</code></dt><dd><p>The thresholds. A numeric vector. If <code>NULL</code> (the
default), <code>TAopt</code> will compute <code>algo$nT</code> thresholds.
Passing threshold can be useful when similar problems are
handled. Then the time to sample the objective function to compute
the thresholds can be saved (ie, we save <code>algo$nD</code> function
evaluations). If the thresholds are computed and
<code>algo$printDetail</code> is <code>TRUE</code>, the time required to
evaluate the objective function will be measured and an estimate for
the remaining computing time is issued. This estimate is often
very crude.</p>
</dd>
<dt><code>neighbour</code></dt><dd><p>The neighbourhood function, called as
<code>neighbour(x, ...)</code>. Its first argument must be a solution
<code>x</code>; it must return a changed
solution.</p>
</dd>
<dt><code>printDetail</code></dt><dd><p>If <code>TRUE</code> (the default), information is
printed. If an integer <code>i</code> greater then one, information is
printed at very <code>i</code>th iteration.</p>
</dd>
<dt><code>printBar</code></dt><dd><p>If <code>TRUE</code> (default is <code>FALSE</code>), a
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code> (from package <span class="pkg">utils</span>) is
printed. The progress bar is not shown if <code>printDetail</code> is
an integer greater than 1.</p>
</dd>
<dt><code>scale</code></dt><dd><p>The thresholds are multiplied by
<code>scale</code>. Default is 1.</p>
</dd>
<dt><code>drop0</code></dt><dd><p>When thresholds are computed, should zero values
be dropped from the sample of objective-function values?  Default is
<code>FALSE</code>.</p>
</dd>
<dt><code>stepUp</code></dt><dd><p>Defaults to <code>0</code>. If an integer greater
than zero, then the thresholds are recycled, ie, <code>vT</code> is
replaced by <code>rep(vT, algo$stepUp + 1)</code> (and the number of
thresholds will be increased by <code>algo$nT</code> times
<code>algo$stepUp</code>). This option works for supplied as well as
computed thresholds. Practically, this will have the same effect
as restarting from a returned solution. (In Simulated Annealing,
this strategy goes by the name of &lsquo;reheating&rsquo;.)</p>
</dd>
<dt><code>thresholds.only</code></dt><dd><p>Defaults to
<code>FALSE</code>. If <code>TRUE</code>, compute only
threshold sequence, but do not actually run
<abbr><span class="acronym">TA</span></abbr>.</p>
</dd>
<dt><code>storeF</code></dt><dd><p>if <code>TRUE</code> (the default), the objective
function values for every solution in every generation are stored
and returned as matrix <code>Fmat</code>.</p>
</dd>
<dt><code>storeSolutions</code></dt><dd><p>Default is <code>FALSE</code>. If
<code>TRUE</code>, the solutions (ie, decision variables) in every
generation are stored and returned in list
<code>xlist</code> (see Value section below). To check, for instance,
the current solution at the end of the <code>i</code>th generation, retrieve
<code>xlist[[c(2L, i)]]</code>.</p>
</dd>
<dt><code>classify</code></dt><dd><p>Logical; default is <code>FALSE</code>. If
<code>TRUE</code>, the result will have a class attribute <code>TAopt</code>
attached. This feature is <strong>experimental</strong>: the supported
methods (plot, summary) may change without warning.</p>
</dd>
<dt><code>OF.target</code></dt><dd><p>Numeric; when specified, the algorithm will
stop when an objective-function value as low as <code>OF.target</code> (or
lower) is achieved. This is useful when an optimal
objective-function value is known: the algorithm will then stop and
not waste time searching for a better solution.</p>
</dd>
</dl>
 
<p>At the minimum, <code>algo</code> needs to contain an initial solution
<code>x0</code> and a <code>neighbour</code> function.
</p>
<p>The total number of iterations equals <code>algo$nT</code> times
<code>(algo$stepUp + 1)</code> times <code>algo$nS</code> (plus possibly
<code>algo$nD</code>).
</p>


<h3>Value</h3>

<p><code>TAopt</code> returns a list with four components:
</p>
<table role = "presentation">
<tr><td><code>xbest</code></td>
<td>
<p>the solution</p>
</td></tr>
<tr><td><code>OFvalue</code></td>
<td>
<p>objective function value of the solution, ie,
<code>OF(xbest, ...)</code></p>
</td></tr>
<tr><td><code>Fmat</code></td>
<td>
<p>if <code>algo$storeF</code> is <code>TRUE</code>, a matrix with
one row for each iteration (excluding the initial <code>algo$nD</code>
steps) and two columns. The first column contains the objective
function values of the neighbour solution at a given iteration; the
second column contains the value of the current solution. Since
<abbr><span class="acronym">TA</span></abbr> can walk away from locally-optimal solutions, the best
solution can be monitored through <code>cummin(Fmat[ ,2L])</code>.</p>
</td></tr>
<tr><td><code>xlist</code></td>
<td>
<p>if <code>algo$storeSolutions</code> is <code>TRUE</code>, a
list; else <code>NA</code>. Contains the neighbour solutions at a given
iteration (<code>xn</code>) and the current solutions
(<code>xc</code>). Example: <code>Fmat[i, 2L]</code> is the objective function
value associated with <code>xlist[[c(2L, i)]]</code>.</p>
</td></tr>
<tr><td><code>initial.state</code></td>
<td>
<p>the value of <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code>
when the function was called.</p>
</td></tr>
</table>
<p>If <code>algo$classify</code> was set to <code>TRUE</code>, the resulting list
will have a class attribute <code>TAopt</code>.
</p>


<h3>Note</h3>

<p>If the <code>...</code> argument is used, then all the objects passed
with <code>...</code> need to go into the objective function and the
neighbourhood function. It is recommended to collect all information
in a list <code>myList</code> and then write <code>OF</code> and <code>neighbour</code>
so that they are called as <code>OF(x, myList)</code> and <code>neighbour(x,
      myList)</code>. Note that <code>x</code> need not be a vector but can be any data
structure (eg, a <code>matrix</code> or a <code>list</code>).
</p>
<p>Using thresholds of size 0 makes <abbr><span class="acronym">TA</span></abbr> run as a Local Search. The
function <code><a href="#topic+LSopt">LSopt</a></code> may be preferred then because of smaller
overhead.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Dueck, G. and Scheuer, T. (1990) Threshold Accepting. A General
Purpose Optimization Algorithm Superior to Simulated Annealing.
<em>Journal of Computational Physics</em>. <strong>90</strong> (1), 161&ndash;175.
</p>
<p>Dueck, G. and Winker, P. (1992) New Concepts and Algorithms for
Portfolio Choice. <em>Applied Stochastic Models and Data
Analysis</em>. <strong>8</strong> (3), 159&ndash;178.
</p>
<p>Gilli, M., Këllezi, E. and Hysi, H. (2006) A Data-Driven
Optimization Heuristic for Downside Risk Minimization. <em>Journal
of Risk</em>. <strong>8</strong> (3), 1&ndash;18.
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Moscato, P. and Fontanari, J.F. (1990). Stochastic Versus
Deterministic Update in Simulated Annealing. Physics Letters A.
<strong>146</strong> (4), 204&ndash;208.
</p>
<p>Schumann, E. (2012) Remarks on 'A comparison of some
heuristic optimization methods'.
<a href="https://enricoschumann.net/R/remarks.htm">https://enricoschumann.net/R/remarks.htm</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Winker, P. (2001). <em>Optimization Heuristics in Econometrics:
Applications of Threshold Accepting</em>. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSopt">LSopt</a></code>, <code><a href="#topic+restartOpt">restartOpt</a></code>.  Simulated Annealing
is implemented in function <code><a href="#topic+SAopt">SAopt</a></code>.
Package <span class="pkg">neighbours</span> (also on CRAN) offers helpers
for creating neighbourhood functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Aim: given a matrix x with n rows and 2 columns,
##      divide the rows of x into two subsets such that
##      in one subset the columns are highly correlated,
##      and in the other lowly (negatively) correlated.
##      constraint: a single subset should have at least 40 rows

## create data with specified correlation
n &lt;- 100L
rho &lt;- 0.7
C &lt;- matrix(rho, 2L, 2L); diag(C) &lt;- 1
x &lt;- matrix(rnorm(n * 2L), n, 2L) %*% chol(C)

## collect data
data &lt;- list(x = x, n = n, nmin = 40L)

## a random initial solution
x0 &lt;- runif(n) &gt; 0.5

## a neighbourhood function
neighbour &lt;- function(xc, data) {
    xn &lt;- xc
    p &lt;- sample.int(data$n, size = 1L)
    xn[p] &lt;- abs(xn[p] - 1L)
    # reject infeasible solution
    c1 &lt;- sum(xn) &gt;= data$nmin
    c2 &lt;- sum(xn) &lt;= (data$n - data$nmin)
    if (c1 &amp;&amp; c2) res &lt;- xn else res &lt;- xc
    as.logical(res)
}

## check (should be 1 FALSE and n-1 TRUE)
x0 == neighbour(x0, data)

## objective function
OF &lt;- function(xc, data)
    -abs(cor(data$x[xc, ])[1L, 2L] - cor(data$x[!xc, ])[1L, 2L])

## check
OF(x0, data)
## check
OF(neighbour(x0, data), data)

## plot data
par(mfrow = c(1,3), bty = "n")
plot(data$x,
     xlim = c(-3,3), ylim = c(-3,3),
     main = "all data", col = "darkgreen")

## *Local Search*
algo &lt;- list(nS = 3000L,
             neighbour = neighbour,
             x0 = x0,
             printBar = FALSE)
sol1 &lt;- LSopt(OF, algo = algo, data=data)
sol1$OFvalue

## *Threshold Accepting*
algo$nT &lt;- 10L
algo$nS &lt;- ceiling(algo$nS/algo$nT)
sol &lt;- TAopt(OF, algo = algo, data = data)
sol$OFvalue

c1 &lt;- cor(data$x[ sol$xbest, ])[1L, 2L]
c2 &lt;- cor(data$x[!sol$xbest, ])[1L, 2L]

lines(data$x[ sol$xbest, ], type = "p", col = "blue")

plot(data$x[ sol$xbest, ], col = "blue",
     xlim = c(-3,3), ylim = c(-3,3),
     main = paste("subset 1, corr.", format(c1, digits = 3)))

plot(data$x[!sol$xbest, ], col = "darkgreen",
     xlim = c(-3,3), ylim = c(-3,3),
     main = paste("subset 2, corr.", format(c2, digits = 3)))

## compare LS/TA
par(mfrow = c(1,1), bty = "n")
plot(sol1$Fmat[ ,2L],type="l", ylim=c(-1.5,0.5),
     ylab = "OF", xlab = "iterations")
lines(sol$Fmat[ ,2L],type = "l", col = "blue")
legend(x = "topright",legend = c("LS", "TA"),
       lty = 1, lwd = 2,col = c("black", "blue"))
</code></pre>

<hr>
<h2 id='testFunctions'>
Classical Test Functions for Unconstrained Optimisation
</h2><span id='topic+testFunctions'></span><span id='topic+tfAckley'></span><span id='topic+tfEggholder'></span><span id='topic+tfGriewank'></span><span id='topic+tfRastrigin'></span><span id='topic+tfRosenbrock'></span><span id='topic+tfSchwefel'></span><span id='topic+tfTrefethen'></span>

<h3>Description</h3>

<p>A number of functions that have been suggested in the literature as
benchmarks for unconstrained optimisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfAckley(x)
tfEggholder(x)
tfGriewank(x)
tfRastrigin(x)
tfRosenbrock(x)
tfSchwefel(x)
tfTrefethen(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testFunctions_+3A_x">x</code></td>
<td>

<p>a numeric vector of arguments. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions take as argument only one variable, a
numeric vector <code>x</code> whose length determines the
dimensionality of the problem.
</p>
<p>The <em>Ackley</em> function is implemented as
</p>
<p style="text-align: center;"><code class="reqn">\exp(1) + 20 -20 \exp{\left(-0.2 \sqrt{\frac{1}{n}\sum_{i=1}^n x_i^2}\right)} - \exp{\left(\frac{1}{n}\sum_{i=1}^n  \cos(2 \pi x_i)\right)}\,.</code>
</p>

<p>The minimum function value is zero; reached at <code class="reqn">x=0</code>.
</p>
<p>The <em>Eggholder</em> takes a two-dimensional <code>x</code>,
here written as <code class="reqn">x</code> and <code class="reqn">y</code>. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">-(y + 47) \sin\left(\sqrt{|y + \frac{x}{2} + 47|}\right) -
    x \sin\left(\sqrt{|x - (y + 47)|}\right)\,.</code>
</p>

<p>The minimum function value is -959.6407; reached at <code>c(512, 404.2319)</code>.
</p>
<p>The <em>Griewank</em> function is given by
</p>
<p style="text-align: center;"><code class="reqn">1+\frac{1}{4000} \sum^n_{i=1} x_i^2 - \prod_{i=1}^n \cos \left(\frac{x_i}{\sqrt{i}}\right)\,.</code>
</p>

<p>The function is minimised at <code class="reqn">x=0</code>; its minimum value is zero.
</p>
<p>The <em>Rastrigin</em> function: </p>
<p style="text-align: center;"><code class="reqn">10n + \sum_{i=1}^n \left(x_i^2 -10\cos(2\pi x_i)\right)\,.</code>
</p>

<p>The minimum function value is zero; reached at <code class="reqn">x=0</code>.
</p>
<p>The <em>Rosenbrock</em> (or banana) function: </p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^{n-1}\left(100 (x_{i+1}-x_i^2)^2 + (1-x_i)^2\right)\,.</code>
</p>

<p>The minimum function value is zero; reached at <code class="reqn">x=1</code>.
</p>
<p>The <em>Schwefel</em> function: </p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n \left(-x_i \sin\left(\sqrt{|x_i|}\right)\right)\,.</code>
</p>

<p>The minimum function value (to about 8 digits) is <code class="reqn">-418.9829n</code>; reached at <code class="reqn">x = 420.9687</code>.
</p>
<p><em>Trefethen</em>'s function takes a two-dimensional <code>x</code> (here written as <code class="reqn">x</code> and <code class="reqn">y</code>); it is defined as
</p>
<p style="text-align: center;"><code class="reqn">\exp(\sin(50x)) + \sin(60 e^y) + \sin(70 \sin(x)) + \sin(\sin(80y)) - \sin(10(x+y)) + \frac{1}{4}(x^2+y^2)\,.</code>
</p>

<p>The minimum function value is -3.3069; reached at <code>c(-0.0244, 0.2106)</code>.
</p>


<h3>Value</h3>

<p>The objective function evaluated at <code>x</code> (a numeric vector of
length one).
</p>


<h3>Warning</h3>

<p>These test functions represent <em>artificial</em> problems.  It is
practically not too helpful to fine-tune a method on such
functions. (That would be like memorising all the answers to a
particular multiple-choice test.)  The functions' main purpose is
checking the numerical implementation of algorithms.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEopt">DEopt</a></code>, <code><a href="#topic+PSopt">PSopt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## persp for two-dimensional x

## Ackley
n &lt;- 100L; surf &lt;- matrix(NA, n, n)
x1 &lt;- seq(from = -2, to = 2, length.out = n)
for (i in 1:n)
    for (j in 1:n)
        surf[i, j] &lt;- tfAckley(c(x1[i], x1[j]))
persp(x1, x1, -surf, phi = 30, theta = 30, expand = 0.5,
      col = "goldenrod1", shade = 0.2, ticktype = "detailed",
      xlab = "x1", ylab = "x2", zlab = "-f", main = "Ackley (-f)",
      border = NA)

## Trefethen
n &lt;- 100L; surf &lt;- matrix(NA, n, n)
x1 &lt;- seq(from = -10, to = 10, length.out = n)
for (i in 1:n)
    for (j in 1:n)
        surf[i, j] &lt;- tfTrefethen(c(x1[i], x1[j]))
persp(x1, x1, -surf, phi = 30, theta = 30, expand = 0.5,
      col = "goldenrod1", shade = 0.2, ticktype = "detailed",
      xlab = "x1", ylab = "x2", zlab = "-f", main = "Trefethen (-f)",
      border = NA)
</code></pre>

<hr>
<h2 id='trackingPortfolio'>
Compute a Tracking Portfolio
</h2><span id='topic+trackingPortfolio'></span>

<h3>Description</h3>

<p>Computes a portfolio similar to a benchmark, e.g. for tracking the
benchmark's performance or identifying factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackingPortfolio(var, wmin = 0, wmax = 1,
                  method = "qp", objective = "variance", R,
                  ls.algo = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trackingPortfolio_+3A_var">var</code></td>
<td>
<p>the covariance matrix: a numeric (real),
symmetric matrix. The first asset is the benchmark.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_r">R</code></td>
<td>
<p>a matrix of returns: each colums holds the
returns of one asset; each rows holds the returns for
one observation. The first asset is the benchmark.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_wmin">wmin</code></td>
<td>
<p>numeric: a lower bound on weights. May also
be a vector that holds specific bounds for each asset.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_wmax">wmax</code></td>
<td>
<p>numeric: an upper bound on weights. May also
be a vector that holds specific bounds for each asset.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_method">method</code></td>
<td>
<p>character. Currently, <code>"qp"</code> and
<code>"ls"</code> are supported.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_objective">objective</code></td>
<td>
<p>character. Currently, <code>"variance"</code>
and <code>"sum.of.squares"</code> are supported.</p>
</td></tr>
<tr><td><code id="trackingPortfolio_+3A_ls.algo">ls.algo</code></td>
<td>
<p>a list of named elements, for settings for
method &lsquo;<code>ls</code>&rsquo;; see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With method <code>"qp"</code>, the function uses
<code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> from package
<span class="pkg">quadprog</span>. Because of the algorithm that
<code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> uses, <code>var</code> has to
be positive definite (i.e. must be of full rank).
</p>
<p>With method <code>"ls"</code>, the function uses
<code><a href="#topic+LSopt">LSopt</a></code>. Settings can be passed via
<code>ls.algo</code>, which corresponds to
<code><a href="#topic+LSopt">LSopt</a></code>'s argument <code>algo</code>. Default
settings are 2000 iterations and <code>printBar</code>,
<code>printDetail</code> set to <code>FALSE</code>.
</p>
<p><code>R</code> is needed only when <code>objective</code> is
<code>"sum.of.squares"</code> or <code>method</code> is
&lsquo;<code>ls</code>&rsquo;. (See Examples.)
</p>


<h3>Value</h3>

<p>a numeric vector (the portfolio weights)
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>
<p>Schumann, E. (2020) Return-based tracking portfolios.
<a href="https://enricoschumann.net/notes/return-based-tracking-portfolios.html">https://enricoschumann.net/notes/return-based-tracking-portfolios.html</a>
</p>
<p>Sharpe, W. F. (1992) Asset Allocation: Management Style and
Performance Measurement. Journal of Portfolio Management.
<strong>18</strong> (2), 7&ndash;19.
<a href="https://web.stanford.edu/~wfsharpe/art/sa/sa.htm">https://web.stanford.edu/~wfsharpe/art/sa/sa.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minvar">minvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("quadprog")) {
    ns &lt;- 120
    R &lt;- randomReturns(na = 1 + 20,
                       ns = ns,
                       sd = 0.03,
                       mean = 0.005,
                       rho = 0.7)

    var &lt;- cov(R)

    sol.qp &lt;- trackingPortfolio(var, wmax = 0.4)
    sol.ls &lt;- trackingPortfolio(var = var, R = R, wmax = 0.4, method = "ls")
    data.frame(QP = round(100*sol.qp, 1),
               LS = round(100*sol.ls, 1))

    sol.qp &lt;- trackingPortfolio(var, R = R, wmax = 0.4,
                                objective = "sum.of.squares")
    sol.ls &lt;- trackingPortfolio(var = var, R = R, wmax = 0.4, method = "ls",
                                objective = "sum.of.squares")
    data.frame(QP = round(100*sol.qp, 1),
               LS = round(100*sol.ls, 1))


    ## same as 'sol.qp' above
    sol.qp.R   &lt;- trackingPortfolio(R = R,
                                    wmax = 0.4,
                                    objective = "sum.of.squares")
    sol.qp.var &lt;- trackingPortfolio(var = crossprod(R),
                                    wmax = 0.4,
                                    objective = "variance")
    ## ==&gt; should be the same
    all.equal(sol.qp.R, sol.qp.var)
}
</code></pre>

<hr>
<h2 id='vanillaBond'>
Pricing Plain-Vanilla Bonds
</h2><span id='topic+vanillaBond'></span><span id='topic+duration'></span><span id='topic+convexity'></span><span id='topic+ytm'></span>

<h3>Description</h3>

<p>Calculate the theoretical price and yield-to-maturity of a list of
cashflows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanillaBond(cf, times, df, yields)
ytm(cf, times, y0 = 0.05, tol = 1e-05, maxit = 1000L, offset = 0)

duration(cf, times, yield, modified = TRUE, raw = FALSE)
convexity(cf, times, yield, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vanillaBond_+3A_cf">cf</code></td>
<td>

<p>Cashflows; a numeric vector or a matrix. If a matrix, cashflows
should be arranged in rows; times-to-payment correspond to columns.
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_times">times</code></td>
<td>

<p>times-to-payment; a numeric vector
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_df">df</code></td>
<td>

<p>discount factors; a numeric vector
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_yields">yields</code></td>
<td>

<p>optional (instead of discount factors); zero yields to compute
discount factor; if of length one, a flat zero curve is assumed
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_yield">yield</code></td>
<td>

<p>numeric vector of length one (both duration and
convexity assume a flat yield curve)
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_y0">y0</code></td>
<td>

<p>starting value
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_tol">tol</code></td>
<td>

<p>tolerance
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_maxit">maxit</code></td>
<td>

<p>maximum number of iterations
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_offset">offset</code></td>
<td>

<p>numeric: a &lsquo;base&rsquo; rate over which to compute the yield to
maturity.  See Details and Examples.
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_modified">modified</code></td>
<td>

<p>logical: return modified duration? (default <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="vanillaBond_+3A_raw">raw</code></td>
<td>

<p>logical: default <code>FALSE</code>. Compute
duration/convexity as derivative of cashflows'
present value? Use this if you want to approximate
the change in the bond price by a Taylor series
(see Examples).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vanillaBond</code> computes the present value of a vector of
cashflows; it may thus be used to evaluate not just bonds but any
instrument that can be reduced to a deterministic set of cashflows.
</p>
<p><code>ytm</code> uses Newton's method to compute the yield-to-maturity of a
bond (a.k.a. internal interest rate). When used with a bond, the initial
outlay (i.e. the bonds dirty price) needs be included in the vector of
cashflows.  For a coupon bond, a good starting value <code>y0</code> is
the coupon divided by the dirty price of the bond.
</p>
<p>An <code>offset</code> can be specified either as a single number or as a
vector of zero rates.  See Examples.
</p>





<h3>Value</h3>

<p>numeric
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NS">NS</a></code>, <code><a href="#topic+NSS">NSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ytm
cf &lt;- c(5, 5, 5, 5, 5, 105)   ## cashflows
times &lt;- 1:6                  ## maturities
y &lt;- 0.0127                   ## the "true" yield
b0 &lt;- vanillaBond(cf, times, yields = y)
cf &lt;- c(-b0, cf); times &lt;- c(0, times)
ytm(cf, times)

## ... with offset
cf &lt;- c(5, 5, 5, 5, 5, 105)   ## cashflows
times &lt;- 1:6                  ## maturities
y &lt;- 0.02 + 0.01              ## risk-free 2% + risk-premium 1%
b0 &lt;- vanillaBond(cf, times, yields = y)
cf &lt;- c(-b0, cf); times &lt;- c(0, times)
ytm(cf, times, offset = 0.02) ## ... only the risk-premium

cf &lt;- c(5, 5, 5, 5, 5, 105)   ## cashflows
times &lt;- 1:6                  ## maturities
y &lt;- NS(c(6,9,10,5)/100, times) ## risk-premium 1%
b0 &lt;- vanillaBond(cf, times, yields = y + 0.01)
cf &lt;- c(-b0, cf); times &lt;- c(0, times)
ytm(cf, times, offset = c(0,y)) ## ... only the risk-premium

## bonds
cf &lt;- c(5, 5, 5, 5, 5, 105)   ## cashflows
times &lt;- 1:6                  ## maturities
df &lt;- 1/(1+y)^times           ## discount factors
all.equal(vanillaBond(cf, times, df),
          vanillaBond(cf, times, yields = y))

## ... using Nelson--Siegel
vanillaBond(cf, times, yields = NS(c(0.03,0,0,1), times))

## several bonds
##   cashflows are numeric vectors in a list 'cf',
##   times-to-payment are are numeric vectors in a
##   list 'times'

times &lt;- list(1:3,
              1:4,
              0.5 + 0:5)
cf &lt;- list(c(6, 6,          106),
           c(4, 4, 4,       104),
           c(2, 2, 2, 2, 2, 102))

alltimes &lt;- sort(unique(unlist(times)))
M &lt;- array(0, dim = c(length(cf), length(alltimes)))
for (i in seq_along(times))
    M[i, match(times[[i]], alltimes)] &lt;- cf[[i]]
rownames(M) &lt;- paste("bond.", 1:3, sep = "")
colnames(M) &lt;- format(alltimes, nsmall = 1)

vanillaBond(cf = M, times = alltimes, yields = 0.02)

## duration/convexity
cf &lt;- c(5, 5, 5, 5, 5, 105)   ## cashflows
times &lt;- 1:6                  ## maturities
y &lt;- 0.0527                   ## yield to maturity

d &lt;- 0.001                   ## change in yield (+10 bp)
vanillaBond(cf, times, yields = y + d) - vanillaBond(cf, times, yields = y)

duration(cf, times, yield = y, raw = TRUE) * d

duration(cf, times, yield = y, raw = TRUE) * d +
    convexity(cf, times, yield = y, raw = TRUE)/2 * d^2

</code></pre>

<hr>
<h2 id='vanillaOptionEuropean'>
Pricing Plain-Vanilla (European and American) and
Barrier Options (European)
</h2><span id='topic+vanillaOptionEuropean'></span><span id='topic+vanillaOptionAmerican'></span><span id='topic+vanillaOptionImpliedVol'></span><span id='topic+barrierOptionEuropean'></span>

<h3>Description</h3>

<p>Functions to calculate the theoretical prices and (some)
Greeks for plain-vanilla and barrier options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanillaOptionEuropean(S, X, tau, r, q, v, tauD = 0, D = 0,
                      type = "call", greeks = TRUE,
                      model = NULL, ...)
vanillaOptionAmerican(S, X, tau, r, q, v, tauD = 0, D = 0,
                      type = "call", greeks = TRUE, M = 101)

vanillaOptionImpliedVol(exercise = "european", price,
                        S, X, tau, r, q = 0,
                        tauD = 0, D = 0,
                        type = "call",
                        M = 101,
                        uniroot.control = list(),
                        uniroot.info = FALSE)

barrierOptionEuropean(S, X, H, tau, r, q = 0, v, tauD = 0, D = 0,
                      type = "call",
                      barrier.type = "downin",
                      rebate = 0,
                      greeks = FALSE,
                      model = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vanillaOptionEuropean_+3A_s">S</code></td>
<td>

<p>spot
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_x">X</code></td>
<td>

<p>strike
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_h">H</code></td>
<td>

<p>barrier
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_tau">tau</code></td>
<td>

<p>time-to-maturity in years
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_r">r</code></td>
<td>

<p>risk-free rate
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_q">q</code></td>
<td>

<p>continuous dividend yield, see Details.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_v">v</code></td>
<td>

<p>variance (volatility squared)
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_taud">tauD</code></td>
<td>

<p>vector of times-to-dividends in years. Only dividends with
<code>tauD</code> greater than zero and not greater than <code>tau</code> are kept.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_d">D</code></td>
<td>

<p>vector of dividends (in currency units); default is no dividends.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_type">type</code></td>
<td>

<p>call or put; default is call.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_barrier.type">barrier.type</code></td>
<td>
<p>string: combination of <code>up</code>/<code>down</code> and
<code>in</code>/<code>out</code>, such as <code>downin</code>
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_rebate">rebate</code></td>
<td>

<p>currently not implemented
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_greeks">greeks</code></td>
<td>

<p>compute Greeks? Defaults to <code>TRUE</code>. But see Details for
American options.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_model">model</code></td>
<td>

<p>what model to use to value the option. Default is <code>NULL</code> which
is equivalent to <code>bsm</code>.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_...">...</code></td>
<td>

<p>parameters passed to pricing model
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_m">M</code></td>
<td>

<p>number of time steps in the tree
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_exercise">exercise</code></td>
<td>

<p><code>european</code> (default) or <code>american</code>
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_price">price</code></td>
<td>

<p>numeric; the observed price to be recovered through choice of volatility.
</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_uniroot.control">uniroot.control</code></td>
<td>
<p>A list. If there are elements named
<code>interval</code>, <code>tol</code> or <code>maxiter</code>, these are passed to
<code>uniroot</code>. Any other elements of the list are ignored.</p>
</td></tr>
<tr><td><code id="vanillaOptionEuropean_+3A_uniroot.info">uniroot.info</code></td>
<td>
<p>logical; default is <code>FALSE</code>. If <code>TRUE</code>,
the function will return the information returned by
<code>uniroot</code>. See paragraph Value below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For European options the formula of Messrs Black, Scholes and
Merton is used. It can be used for equities (set <code>q</code> equal
to the dividend yield), futures (Black, 1976; set <code>q</code> equal
to <code>r</code>), currencies (Garman and Kohlhagen, 1983; set
<code>q</code> equal to the foreign risk-free rate). For future-style
options (e.g. options on the German Bund future), set <code>q</code>
and <code>r</code> equal to zero.
</p>
<p>The Greeks are provided in their raw (&lsquo;textbook&rsquo;) form
with only one exception: Theta is made negative. For practical
use, the other Greeks are also typically adjusted: Theta is
often divided by 365 (or some other yearly day count); Vega and
Rho are divided by 100 to give the sensitivity for one
percentage-point move in volatility/the interest rate. Raw Gamma
is not much use if not adjusted for the actual move in the
underlier.
</p>
<p>For European options the Greeks are computed through the
respective analytic expressions. For American options only
Delta, Gamma and Theta are computed because they can be directly
obtained from the binomial tree; other Greeks need to be
computed through a finite difference (see Examples).
</p>
<p>For the European-type options, the function understands vectors
of inputs, except for dividends. American options are priced via
a Cox-Ross-Rubinstein tree; no vectorisation is implemented
here.
</p>
<p>The implied volatility is computed with <code><a href="stats.html#topic+uniroot">uniroot</a></code>
from the <span class="pkg">stats</span> package (the default search interval is
<code>c(0.00001, 2)</code>; it can be changed through
<code>uniroot.control</code>).
</p>
<p>Dividends (<code>D</code>) are modelled via the escrowed-dividend
model.
</p>


<h3>Value</h3>

<p>Returns the price (a numeric vector of length one) if <code>greeks</code> is
<code>FALSE</code>, else returns a list.
</p>


<h3>Note</h3>

<p>If <code>greeks</code> is <code>TRUE</code>, the function will return a list with
named elements (<code>value</code>, <code>delta</code> and so on). Prior to version
0.26-3, the first element of this list was named <code>price</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Haug, E. (2007) <em>The Complete Guide to Option Pricing Formulas</em>.
2nd edition. McGraw-Hill.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EuropeanCall">EuropeanCall</a></code>, <code><a href="#topic+callCF">callCF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- 100; X &lt;- 100; tau &lt;- 1; r &lt;- 0.02; q &lt;- 0.06; vol &lt;- 0.3
unlist(vanillaOptionEuropean(S, X, tau, r, q, vol^2, type = "put"))

S &lt;- 100; X &lt;- 110; tau &lt;- 1; r &lt;- 0.1; q &lt;- 0.06; vol &lt;- 0.3; type &lt;- "put"
unlist(vanillaOptionAmerican(S, X, tau, r, q, vol^2, type = type,
                             greeks = TRUE))

## compute rho for 1% move
h &lt;- 0.01
(vanillaOptionAmerican(S, X, tau, r + h, q, vol^2,
    type = type, greeks = FALSE) -
 vanillaOptionAmerican(S, X, tau, r, q, vol^2,
    type = type, greeks = FALSE)) / (h*100)

## compute vega for 1% move
h &lt;- 0.01
(vanillaOptionAmerican(S, X, tau, r, q,(vol + h)^2,
    type = type, greeks = FALSE) -
 vanillaOptionAmerican(S, X, tau, r, q, vol^2,
    type = type, greeks = FALSE)) / (h*100)



S &lt;- 100; X &lt;- 100
tau &lt;- 1; r &lt;- 0.05; q &lt;- 0.00
D &lt;- c(1,2); tauD &lt;- c(0.3,.6)
type &lt;- "put"
v &lt;- 0.245^2  ## variance, not volatility

p &lt;- vanillaOptionEuropean(S = S, X = X, tau, r, q, v = v,
                           tauD = tauD, D = D, type = type, greeks = FALSE)
vanillaOptionImpliedVol(exercise = "european", price = p,
     S = S, X = X, tau = tau, r = r, q = q, tauD = tauD, D = D, type = type)

p &lt;- vanillaOptionAmerican(S = S, X = X, tau, r, q, v = v,
     tauD = tauD, D = D, type = type, greeks = FALSE)
vanillaOptionImpliedVol(exercise = "american", price = p,
     S = S, X = X, tau = tau, r = r, q = q, tauD = tauD, D = D, type =
     type, uniroot.control = list(interval = c(0.01, 0.5)))


## compute implied q
S &lt;- 100; X &lt;- 100
tau &lt;- 1; r &lt;- 0.05; q &lt;- 0.072
v &lt;- 0.22^2  ## variance, not volatility

call &lt;- vanillaOptionEuropean(S=S, X = X, tau=tau, r=r, q=q, v=v,
         type = "call", greeks = FALSE)
put  &lt;- vanillaOptionEuropean(S=S, X = X, tau=tau, r=r, q=q, v=v,
         type = "put", greeks = FALSE)

# ... the simple way
-(log(call + X * exp(-tau*r) - put) - log(S)) / tau

# ... the complicated way :-)
volDiffCreate &lt;- function(exercise, call, put, S, X, tau, r) {
    f &lt;- function(q) {
        cc &lt;- vanillaOptionImpliedVol(exercise = exercise, price = call,
            S = S, X = X, tau = tau, r = r, q = q, type = "call")
        pp &lt;- vanillaOptionImpliedVol(exercise = exercise, price = put,
            S = S, X = X, tau = tau, r = r, q = q, type = "put")
        abs(cc - pp)
    }
    f
}
f &lt;- volDiffCreate(exercise = "european",
                   call = call, put = put, S = S, X = X, tau = tau, r)
optimise(f,interval = c(0, 0.2))$minimum

##
S &lt;- 100; X &lt;- 100
tau &lt;- 1; r &lt;- 0.05; q &lt;- 0.072
v &lt;- 0.22^2  ## variance, not volatility
vol &lt;- 0.22

vanillaOptionEuropean(S=S, X = X, tau=tau, r=r, q=q, v=v,     ## with variance
                      type = "call", greeks = FALSE)
vanillaOptionEuropean(S=S, X = X, tau=tau, r=r, q=q, vol=vol, ## with vol
                      type = "call", greeks = FALSE)
vanillaOptionEuropean(S=S, X = X, tau=tau, r=r, q=q, vol=vol, ## with vol
                      type = "call", greeks = FALSE, v = 0.2^2)

</code></pre>

<hr>
<h2 id='xtContractValue'>
Contract Value of Australian Government Bond Future
</h2><span id='topic+xtContractValue'></span><span id='topic+xtTickValue'></span>

<h3>Description</h3>

<p>Compute the contract value of an Australian
government-bond future from its quoted price.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtContractValue(quoted.price, coupon, do.round = TRUE)
xtTickValue(quoted.price, coupon, do.round = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xtContractValue_+3A_quoted.price">quoted.price</code></td>
<td>

<p>The price, as in <code>99.02</code>.
</p>
</td></tr>
<tr><td><code id="xtContractValue_+3A_coupon">coupon</code></td>
<td>

<p>numeric; should be 6, not 0.06
</p>
</td></tr>
<tr><td><code id="xtContractValue_+3A_do.round">do.round</code></td>
<td>

<p>If <code>TRUE</code>, round as done by ASX clearing house.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Australian government-bond futures, traded at the
Australian Securities Exchange (<abbr><span class="acronym">asx</span></abbr>), are
quoted as <code>100 - yield</code>. The function computes
the actual contract value from the quoted price.
</p>
<p><code>xtTickValue</code> computes the tick value via a
central difference.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p><a href="https://www.rba.gov.au/mkt-operations/resources/tech-notes/pricing-formulae.html">https://www.rba.gov.au/mkt-operations/resources/tech-notes/pricing-formulae.html</a>
</p>
<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quoted.price &lt;- 99
coupon &lt;- 6
xtContractValue(quoted.price, coupon)
xtTickValue(quoted.price, coupon)
## convexity
quoted.price &lt;- seq(90, 100, by = 0.1)
plot(100 - quoted.price,
     xtContractValue(quoted.price, coupon),
     xlab = "Yield", ylab = "Contract value")
</code></pre>

<hr>
<h2 id='xwGauss'>
Integration of Gauss-type
</h2><span id='topic+xwGauss'></span><span id='topic+changeInterval'></span>

<h3>Description</h3>

<p>Compute nodes and weights for Gauss integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xwGauss(n, method = "legendre")
changeInterval(nodes, weights, oldmin, oldmax, newmin, newmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xwGauss_+3A_n">n</code></td>
<td>

<p>number of nodes
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_method">method</code></td>
<td>

<p>character. default is <code>"legendre"</code>; also possible are
<code>"laguerre"</code> and <code>"hermite"</code>
</p>
</td></tr>

<tr><td><code id="xwGauss_+3A_nodes">nodes</code></td>
<td>

<p>the nodes (a numeric vector)
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_weights">weights</code></td>
<td>

<p>the weights (a numeric vector)
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_oldmin">oldmin</code></td>
<td>

<p>the minimum of the interval (typically as tabulated)
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_oldmax">oldmax</code></td>
<td>

<p>the maximum of the interval (typically as tabulated)
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_newmin">newmin</code></td>
<td>

<p>the desired minimum of the interval
</p>
</td></tr>
<tr><td><code id="xwGauss_+3A_newmax">newmax</code></td>
<td>

<p>the desired maximum of the interval
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xwGauss</code> computes nodes and weights for integration for the
interval -1 to 1. It uses the method of Golub and Welsch (1969).
</p>
<p><code>changeInterval</code> is a utility that transforms nodes and weights
to an arbitrary interval.
</p>


<h3>Value</h3>

<p>a list with two elements
</p>
<table role = "presentation">
<tr><td><code>weights</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Golub, G.H. and Welsch, J.H. (1969). Calculation of Gauss Quadrature Rules. <em>Mathematics of Computation</em>,
<b>23</b>(106), pp. 221&ndash;230+s1&ndash;s10.
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+callHestoncf">callHestoncf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples from Gilli/Maringer/Schumann (2019), ch. 17

## a test function
f1 &lt;- function(x) exp(-x)
m &lt;- 5; a &lt;- 0; b &lt;- 5
h &lt;- (b - a)/m

## rectangular rule -- left
w &lt;- h; k &lt;- 0:(m-1); x &lt;- a + k * h
sum(w * f1(x))

## rectangular rule -- right
w &lt;- h; k &lt;- 1:m ; x &lt;- a + k * h
sum(w * f1(x))

## midpoint rule
w &lt;- h; k &lt;- 0:(m-1); x &lt;- a + (k + 0.5)*h
sum(w * f1(x))

## trapezoidal rule
w &lt;- h
k &lt;- 1:(m-1)
x &lt;- c(a, a + k*h, b)
aux &lt;- w * f1(x)
sum(aux) - (aux[1] + aux[length(aux)])/2

## R's integrate (from package stats)
integrate(f1, lower = a,upper = b)

## Gauss--Legendre
temp &lt;- xwGauss(m)
temp &lt;- changeInterval(temp$nodes, temp$weights,
                       oldmin = -1, oldmax = 1, newmin =  a, newmax = b)
x &lt;- temp$nodes; w &lt;- temp$weights
sum(w * f1(x))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
