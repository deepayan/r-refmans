<!DOCTYPE html><html lang="en"><head><title>Help for package eRTG3D</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eRTG3D}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chiMaps'><p>Chi maps of two variables</p></a></li>
<li><a href='#dem'><p>Example digital elevation model (DEM)</p></a></li>
<li><a href='#dem2track.extent'><p>Crops the DEM to the extent of the track with a buffer</p></a></li>
<li><a href='#dist2point.3d'><p>Distance of each track point to a given point</p></a></li>
<li><a href='#dist2target.3d'><p>Distance to target</p></a></li>
<li><a href='#eRTG3D'><p>eRTG3D: Empirically Informed Random Trajectory Generator in 3-D</p></a></li>
<li><a href='#filter.dead.ends'><p>Remove dead ends</p></a></li>
<li><a href='#get.densities.3d'><p>Extract tldCube and autodifference approximation functions</p></a></li>
<li><a href='#get.glideRatio.3d'><p>Calculate glide ratio</p></a></li>
<li><a href='#get.section.densities.3d'><p>Extract tldCube and autodifferences functions from track sections</p></a></li>
<li><a href='#get.track.densities.3d'><p>Extract tldCube and autodifferences functions from a consistent track</p></a></li>
<li><a href='#is.sf.3d'><p>Tests if the object is a simple feature collection (class: <code>'sf, data.frame'</code>)</p></a></li>
<li><a href='#lift2target.3d'><p>Lift angle to target</p></a></li>
<li><a href='#logRasterStack'><p>Converts a rasterStack to logarithmic scale</p></a></li>
<li><a href='#movingMedian'><p>Moving median in one dimension</p></a></li>
<li><a href='#n.sim.cond.3d'><p>Conditional Empirical Random Walks (CERW) in 3-D</p></a></li>
<li><a href='#n.sim.glidingSoaring.3d'><p>Simulates multiple 'gliding &amp; soaring' tracks with a given number of gliding steps</p></a></li>
<li><a href='#niclas'><p>Example track data.frame</p></a></li>
<li><a href='#parpbapply'><p>Parallel apply with progressbar</p></a></li>
<li><a href='#parpblapply'><p>Parallel lapply with progressbar</p></a></li>
<li><a href='#parpbsapply'><p>Parallel sapply with progressbar</p></a></li>
<li><a href='#plot2d'><p>Plot function to plot the 3-D tracks in 2-D plane</p></a></li>
<li><a href='#plot3d'><p>Plot track(s) with a surface of a digital elevation model in three dimensions</p></a></li>
<li><a href='#plot3d.densities'><p>Density plots of turn angle, lift angle and step length</p></a></li>
<li><a href='#plot3d.multiplot'><p>Multiple plot function for ggplot objects</p></a></li>
<li><a href='#plot3d.tldCube'><p>Visualize turn-lift-step histogram</p></a></li>
<li><a href='#plotRaster'><p>Plots a rasterLayer or rasterStack</p></a></li>
<li><a href='#qProb.3d'><p>Q probabilities for n steps</p></a></li>
<li><a href='#reproduce.track.3d'><p>Reproduce a track with the eRTG3D</p></a></li>
<li><a href='#saveImageSlices'><p>Export a dataCube as image slice sequence</p></a></li>
<li><a href='#sf2df.3d'><p>Converts a sf data.frame to a normal dataframe</p></a></li>
<li><a href='#sim.cond.3d'><p>Conditional Empirical Random Walk (CERW) in 3-D</p></a></li>
<li><a href='#sim.crw.3d'><p>Simulation of a three dimensional Correlated Random Walk</p></a></li>
<li><a href='#sim.glidingSoaring.3d'><p>Simulates 'gliding &amp; soaring' track with a given number of gliding steps</p></a></li>
<li><a href='#sim.uncond.3d'><p>Unconditional Empirical Random Walk (UERW) in 3-D</p></a></li>
<li><a href='#test.eRTG.3d'><p>Test the functionality of the eRTG3D</p></a></li>
<li><a href='#test.verification.3d'><p>Statistical Verification of the simulated track</p></a></li>
<li><a href='#track.extent'><p>Extent of track(s)</p></a></li>
<li><a href='#track.properties.3d'><p>Track properties of a 3-D track</p></a></li>
<li><a href='#track.split.3d'><p>This function splits the by outliers in the time lag.</p></a></li>
<li><a href='#track2sf.3d'><p>Converts a track to a <code>'sf, data.frame'</code></p></a></li>
<li><a href='#transformCRS.3d'><p>Transform coordinates reference system (CRS) of a 3-D track</p></a></li>
<li><a href='#turn2target.3d'><p>Turn angle to target</p></a></li>
<li><a href='#turnLiftStepHist'><p>Three dimensional histogram</p></a></li>
<li><a href='#voxelCount'><p>Apply voxel counting on a point cloud</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Empirically Informed Random Trajectory Generation in 3-D</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Merlin Unterfinger &lt;info@munterfinger.ch&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://munterfi.github.io/eRTG3D/">https://munterfi.github.io/eRTG3D/</a>,
<a href="https://github.com/munterfi/eRTG3D/">https://github.com/munterfi/eRTG3D/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/munterfi/eRTG3D/issues/">https://github.com/munterfi/eRTG3D/issues/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Creates realistic random trajectories in a 3-D space between two given fix points, so-called conditional empirical random walks (CERWs). The trajectory generation is based on empirical distribution functions extracted from observed trajectories (training data) and thus reflects the geometrical movement characteristics of the mover. A digital elevation model (DEM), representing the Earth's surface, and a background layer of probabilities (e.g. food sources, uplift potential, waterbodies, etc.) can be used to influence the trajectories.
    Unterfinger M (2018). "3-D Trajectory Simulation in Movement Ecology: Conditional Empirical Random Walk". Master's thesis, University of Zurich. <a href="https://www.geo.uzh.ch/dam/jcr:6194e41e-055c-4635-9807-53c5a54a3be7/MasterThesis_Unterfinger_2018.pdf">https://www.geo.uzh.ch/dam/jcr:6194e41e-055c-4635-9807-53c5a54a3be7/MasterThesis_Unterfinger_2018.pdf</a>.
    Technitis G, Weibel R, Kranstauber B, Safi K (2016). "An algorithm for empirically informed random trajectory generation between two endpoints". GIScience 2016: Ninth International Conference on Geographic Information Science, 9, online. &lt;<a href="https://doi.org/10.5167%2Fuzh-130652">doi:10.5167/uzh-130652</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>CircStats (&ge; 0.2-6), ggplot2 (&ge; 3.1.1), pbapply (&ge; 1.4-1),
plotly (&ge; 4.9.0), raster (&ge; 2.9-5), rasterVis (&ge; 0.45), tiff
(&ge; 0.1-5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.23), pander (&ge; 0.6.3), gridExtra (&ge; 2.3), plyr
(&ge; 1.8.4), rmarkdown (&ge; 1.13), sf (&ge; 0.7-4), sp (&ge; 1.3-1),
testthat (&ge; 2.1.0), covr (&ge; 3.2.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-23 14:43:28 UTC; munterfi</td>
</tr>
<tr>
<td>Author:</td>
<td>Merlin Unterfinger
    <a href="https://orcid.org/0000-0003-2020-2366"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Kamran Safi [ctb, ths],
  George Technitis [ctb, ths],
  Robert Weibel [ths]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-25 12:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='chiMaps'>Chi maps of two variables</h2><span id='topic+chiMaps'></span>

<h3>Description</h3>

<p>Calculates the chi maps for one <code>rasterStack</code> or all raster all the raster pairs stored in two <code>rasterStack</code>s.
As observed values, the first stack is used. The expected value is either set to the mean of the first stack, or if given
to be the values of the second stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiMaps(stack1, stack2 = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiMaps_+3A_stack1">stack1</code></td>
<td>
<p><code>rasterStack</code></p>
</td></tr>
<tr><td><code id="chiMaps_+3A_stack2">stack2</code></td>
<td>
<p><code>rasterStack</code>  <code>NULL</code> or containing the same number of <code>rasterLayer</code>s and has euqal extent and resolution.</p>
</td></tr>
<tr><td><code id="chiMaps_+3A_verbose">verbose</code></td>
<td>
<p>logical: print currently processed height band in raster stack?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>rasterStack</code> containing the chi maps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("tbd.")
</code></pre>

<hr>
<h2 id='dem'>Example digital elevation model (DEM)</h2><span id='topic+dem'></span>

<h3>Description</h3>

<p>This is data to be included in the package and can be used to test its functionality.
The <code>dem</code> data is a <code>RasterLayer</code> and has a resolution of 90 meters. It is the topography
of the Swiss midlands. The complete dataset can be downloaded directly from http://srtm.csi.cgiar.org/srtmdata/.
</p>


<h3>References</h3>

<p><a href="https://srtm.csi.cgiar.org/srtmdata/">https://srtm.csi.cgiar.org/srtmdata/</a>
</p>

<hr>
<h2 id='dem2track.extent'>Crops the DEM to the extent of the track with a buffer</h2><span id='topic+dem2track.extent'></span>

<h3>Description</h3>

<p>Crops the DEM to the extent of the track with a buffer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dem2track.extent(DEM, track, buffer = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dem2track.extent_+3A_dem">DEM</code></td>
<td>
<p>a raster containing a digital elevation model, covering the extent as the track</p>
</td></tr>
<tr><td><code id="dem2track.extent_+3A_track">track</code></td>
<td>
<p>data.frame with x,y,z coordinates of the original track</p>
</td></tr>
<tr><td><code id="dem2track.extent_+3A_buffer">buffer</code></td>
<td>
<p>buffer with, by default set to 100</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A the cropped digital elevation model as a raster layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dem2track.extent(dem, niclas)
</code></pre>

<hr>
<h2 id='dist2point.3d'>Distance of each track point to a given point</h2><span id='topic+dist2point.3d'></span>

<h3>Description</h3>

<p>Distance of each track point to a given point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2point.3d(track, point, groundDistance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist2point.3d_+3A_track">track</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="dist2point.3d_+3A_point">point</code></td>
<td>
<p>a vector with x, y or x, y, z coordinates</p>
</td></tr>
<tr><td><code id="dist2point.3d_+3A_grounddistance">groundDistance</code></td>
<td>
<p>logical: calculate only ground distance in x-y plane?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the distance of each track point to the point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist2point.3d(niclas, c(0, 0, 0))
</code></pre>

<hr>
<h2 id='dist2target.3d'>Distance to target</h2><span id='topic+dist2target.3d'></span>

<h3>Description</h3>

<p>Calculates the distance between every point in the track and the last point (target).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2target.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist2target.3d_+3A_track">track</code></td>
<td>
<p>a track data.frame containing x, y and z coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the distances to target
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist2target.3d(niclas)
</code></pre>

<hr>
<h2 id='eRTG3D'>eRTG3D: Empirically Informed Random Trajectory Generator in 3-D</h2><span id='topic+eRTG3D'></span>

<h3>Description</h3>

<p>The empirically informed random trajectory generator in three dimensions (eRTG3D)
is an algorithm to generate realistic random trajectories in a 3-D space
between two given fix points in space, so-called Conditional Empirical Random Walks.
The trajectory generation is based on empirical distribution functions extracted from
observed trajectories (training data) and thus reflects the geometrical movement
characteristics of the mover. A digital elevation model (DEM),
representing the Earth's surface, and a background layer of probabilities
(e.g. food sources, uplift potential, waterbodies, etc.) can be used to
influence the trajectories.
</p>


<h3>Details</h3>

<p>See the packages site on <a href="https://munterfi.github.io/eRTG3D/">GitHub</a>,
detailed information about the algorithm in this <a href="https://www.geo.uzh.ch/dam/jcr:6194e41e-055c-4635-9807-53c5a54a3be7/MasterThesis_Unterfinger_2018.pdf">Master’s Thesis</a>,
or test the algorithm online in the <a href="https://mufi.shinyapps.io/ertg3d-simulator">eRTG3D Simulator</a>.
</p>

<hr>
<h2 id='filter.dead.ends'>Remove dead ends</h2><span id='topic+filter.dead.ends'></span>

<h3>Description</h3>

<p>Function to filter out tracks that have found a dead end
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.dead.ends(cerwList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter.dead.ends_+3A_cerwlist">cerwList</code></td>
<td>
<p>list of data.frames and NULL entries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that is only containing valid tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter.dead.ends(list(niclas, niclas))
</code></pre>

<hr>
<h2 id='get.densities.3d'>Extract tldCube and autodifference approximation functions</h2><span id='topic+get.densities.3d'></span>

<h3>Description</h3>

<p>Creates a list consisting of the three dimensional
probability distribution cube for turning angle, lift angle and step length (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)
as well as the uni-dimensional distributions of the differences
of the turn angles, lift angles and step lengths with a lag of 1 to maintain
minimal level of autocorrelation in each of the terms.
Additionally also the distribution of the flight height over the ellipsoid (absolute)
and the distribution of flight height over the topography (relative) can be included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.densities.3d(
  turnAngle,
  liftAngle,
  stepLength,
  deltaLift,
  deltaTurn,
  deltaStep,
  gradientAngle = NULL,
  heightEllipsoid = NULL,
  heightTopo = NULL,
  maxBin = 25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.densities.3d_+3A_turnangle">turnAngle</code></td>
<td>
<p>turn angles of the track (t)</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_liftangle">liftAngle</code></td>
<td>
<p>lift angles of the track (l)</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_steplength">stepLength</code></td>
<td>
<p>stepLength of the track (d)</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_deltalift">deltaLift</code></td>
<td>
<p>auto differences of the turn angles (diff(t))</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_deltaturn">deltaTurn</code></td>
<td>
<p>auto differences of the lift angles (diff(l))</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_deltastep">deltaStep</code></td>
<td>
<p>auto differences of the step length (diff(d))</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_gradientangle">gradientAngle</code></td>
<td>
<p><code>NULL</code> or the gardient angles of the track</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_heightellipsoid">heightEllipsoid</code></td>
<td>
<p>flight height over the ellipsoid (absolute) or <code>NULL</code> to exclude this distribution</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_heighttopo">heightTopo</code></td>
<td>
<p>flight height over the topography (relative) or <code>NULL</code> to exclude this distribution</p>
</td></tr>
<tr><td><code id="get.densities.3d_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the tldCube and the autodifferences functions (and additionally the flight height distribution functions)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>niclas &lt;- track.properties.3d(niclas)[2:nrow(niclas), ]
P &lt;- get.densities.3d(
  turnAngle = niclas$t, liftAngle = niclas$l, stepLength = niclas$d,
  deltaLift = diff(niclas$t), deltaTurn = diff(niclas$l), deltaStep = diff(niclas$d),
  gradientAngle = NULL, heightEllipsoid = NULL, heightTopo = NULL, maxBin = 25
)
</code></pre>

<hr>
<h2 id='get.glideRatio.3d'>Calculate glide ratio</h2><span id='topic+get.glideRatio.3d'></span>

<h3>Description</h3>

<p>Calculates the ratio between horizontal movement and vertical movement.
The value expresses the distance covered forward movement per distance movement in sinking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.glideRatio.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.glideRatio.3d_+3A_track">track</code></td>
<td>
<p>a track data.frame containing x, y and z coordinates of a gliding section</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ratio between horizontal and vertical movement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.glideRatio.3d(niclas)
</code></pre>

<hr>
<h2 id='get.section.densities.3d'>Extract tldCube and autodifferences functions from track sections</h2><span id='topic+get.section.densities.3d'></span>

<h3>Description</h3>

<p>Creates a list consisting of the 3 dimensional
probability distribution cube for turning angle, lift angle and step length (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)
as well as the uni-dimensional distributions of the differences
of the turning angles, lift angles and step lengths with a lag of 1 to maintain
minimal level of autocorrelation in each of the terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.section.densities.3d(
  trackSections,
  gradientDensity = TRUE,
  heightDistEllipsoid = TRUE,
  DEM = NULL,
  maxBin = 25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.section.densities.3d_+3A_tracksections">trackSections</code></td>
<td>
<p>list of track sections got by the <a href="#topic+track.split.3d">track.split.3d</a> function</p>
</td></tr>
<tr><td><code id="get.section.densities.3d_+3A_gradientdensity">gradientDensity</code></td>
<td>
<p>logical: Should a distribution of the gradient angle be extracted and later used in the simulations?</p>
</td></tr>
<tr><td><code id="get.section.densities.3d_+3A_heightdistellipsoid">heightDistEllipsoid</code></td>
<td>
<p>logical: Should a distribution of the flight height over ellipsoid be extracted and later used in the sim.cond.3d()?</p>
</td></tr>
<tr><td><code id="get.section.densities.3d_+3A_dem">DEM</code></td>
<td>
<p>a raster containing a digital elevation model, covering the same extent as the track sections</p>
</td></tr>
<tr><td><code id="get.section.densities.3d_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the tldCube and the autodifferences functions (and additionally the height distribution function)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.section.densities.3d(list(niclas[1:10, ], niclas[11:nrow(niclas), ]))
</code></pre>

<hr>
<h2 id='get.track.densities.3d'>Extract tldCube and autodifferences functions from a consistent track</h2><span id='topic+get.track.densities.3d'></span>

<h3>Description</h3>

<p>Get densities creates a list consisting of the 3 dimensional
probability distribution cube for turning angle, lift angle and step length (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)
as well as the uni-dimensional distributions of the differences
of the turning angles, lift angles and step lengths with a lag of 1 to maintain
minimal level of autocorrelation in each of the terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.track.densities.3d(
  track,
  gradientDensity = TRUE,
  heightDistEllipsoid = TRUE,
  DEM = NULL,
  maxBin = 25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.track.densities.3d_+3A_track">track</code></td>
<td>
<p>a data.frame with 3 columns containing the x,y,z coordinates</p>
</td></tr>
<tr><td><code id="get.track.densities.3d_+3A_gradientdensity">gradientDensity</code></td>
<td>
<p>logical: Should a distribution of the gradient angle be extracted and later used in the simulations?</p>
</td></tr>
<tr><td><code id="get.track.densities.3d_+3A_heightdistellipsoid">heightDistEllipsoid</code></td>
<td>
<p>logical: Should a distribution of the flight height over ellipsoid be extracted and later used in the sim.cond.3d()?</p>
</td></tr>
<tr><td><code id="get.track.densities.3d_+3A_dem">DEM</code></td>
<td>
<p>a raster containing a digital elevation model, covering the same extent as the track</p>
</td></tr>
<tr><td><code id="get.track.densities.3d_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the tldCube and the autodifferences functions (and additionally the height distribution function)
</p>


<h3>Note</h3>

<p>The time between the acquisition of fix points  of the track must be constant,
otherwise this leads to distorted statistic distributions,
which increases the probability of dead ends. In this case please check
<a href="#topic+track.split.3d">track.split.3d</a> and <a href="#topic+get.section.densities.3d">get.section.densities.3d</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.track.densities.3d(niclas, heightDist = TRUE)
</code></pre>

<hr>
<h2 id='is.sf.3d'>Tests if the object is a simple feature collection (class: <code>'sf, data.frame'</code>)</h2><span id='topic+is.sf.3d'></span>

<h3>Description</h3>

<p>Tests if the object is a simple feature collection (class: <code>'sf, data.frame'</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sf.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.sf.3d_+3A_track">track</code></td>
<td>
<p>any object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical: <code>TRUE</code> if is a simple feature collection (class: <code>'sf, data.frame'</code>) of the sf package, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.sf.3d(niclas)
is.sf.3d(track2sf.3d(track = niclas, CRS = 2056))
</code></pre>

<hr>
<h2 id='lift2target.3d'>Lift angle to target</h2><span id='topic+lift2target.3d'></span>

<h3>Description</h3>

<p>Calculates the lift angle between every point in the track and the last point (target).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lift2target.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lift2target.3d_+3A_track">track</code></td>
<td>
<p>a track data.frame containing x, y and z coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the lift angles to target
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lift2target.3d(niclas)
</code></pre>

<hr>
<h2 id='logRasterStack'>Converts a rasterStack to logarithmic scale</h2><span id='topic+logRasterStack'></span>

<h3>Description</h3>

<p>Avoids the problem of -Inf occuring for log(0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logRasterStack(rStack, standartize = FALSE, InfVal = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logRasterStack_+3A_rstack">rStack</code></td>
<td>
<p>rasterStack to convert to logarithmic scale</p>
</td></tr>
<tr><td><code id="logRasterStack_+3A_standartize">standartize</code></td>
<td>
<p>logical: standartize cube between 0 and 1</p>
</td></tr>
<tr><td><code id="logRasterStack_+3A_infval">InfVal</code></td>
<td>
<p>the value that <code>Inf</code> and <code>-Inf</code> should be rpeplaced with</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rasterStack in logarithmic scale
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logRasterStack(raster::stack(dem))
</code></pre>

<hr>
<h2 id='movingMedian'>Moving median in one dimension</h2><span id='topic+movingMedian'></span>

<h3>Description</h3>

<p>Applies a twosided moving median window on a vector,
where the window paramter is the total size of the window.
The value in the window middle is the index where the median of the window is written.
Therefore the window size has to be an uneven number.
The border region of the vetor is filled with a one-sided median.
There might be border effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingMedian(data, window)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="movingMedian_+3A_data">data</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="movingMedian_+3A_window">window</code></td>
<td>
<p>uneven number for the size of the moving window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>movingMedian(sequence(1:10), window = 5)
</code></pre>

<hr>
<h2 id='n.sim.cond.3d'>Conditional Empirical Random Walks (CERW) in 3-D</h2><span id='topic+n.sim.cond.3d'></span>

<h3>Description</h3>

<p>Creates multiple conditional empirical random walks, with a specific starting and ending point,
geometrically similar to the initial trajectory by applying <a href="#topic+sim.cond.3d">sim.cond.3d</a> multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.sim.cond.3d(
  n.sim,
  n.locs,
  start = c(0, 0, 0),
  end = start,
  a0,
  g0,
  densities,
  qProbs,
  error = FALSE,
  parallel = FALSE,
  DEM = NULL,
  BG = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n.sim.cond.3d_+3A_n.sim">n.sim</code></td>
<td>
<p>number of CERWs to simulate</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_n.locs">n.locs</code></td>
<td>
<p>length of the trajectory in locations</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_start">start</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the start point</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_end">end</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the end point</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_a0">a0</code></td>
<td>
<p>initial incoming heading in radian</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_g0">g0</code></td>
<td>
<p>initial incoming gradient/polar angle in radian</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_densities">densities</code></td>
<td>
<p>list object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_qprobs">qProbs</code></td>
<td>
<p>list object returned by the <a href="#topic+qProb.3d">qProb.3d</a> function</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_error">error</code></td>
<td>
<p>logical: add random noise to the turn angle, lift angle and step length to account for errors measurements?</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_parallel">parallel</code></td>
<td>
<p>logical: run computations in parallel (n-1 cores)? Or numeric: the number of nodes (maximum: n - 1 cores)</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_dem">DEM</code></td>
<td>
<p>raster layer containing a digital elevation model, covering the area between start and end point</p>
</td></tr>
<tr><td><code id="n.sim.cond.3d_+3A_bg">BG</code></td>
<td>
<p>a background raster layer that can be used to inform the choice of steps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the CERWs or <code>NULL</code>s if dead ends have been encountered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>niclas &lt;- track.properties.3d(niclas)
n.locs &lt;- 3
P &lt;- get.track.densities.3d(niclas)
f &lt;- 1500
start &lt;- Reduce(c, niclas[1, 1:3])
end &lt;- Reduce(c, niclas[n.locs, 1:3])
a0 &lt;- niclas$a[1]
g0 &lt;- niclas$g[1]
uerw &lt;- sim.uncond.3d(
  n.locs * f, start = start, a0 = a0, g0 = g0, densities = P
)
Q &lt;- qProb.3d(uerw, n.locs)
n.sim.cond.3d(
  n.sim = 2, n.locs = n.locs,
  start = start, end = end,
  a0 = a0, g0 = g0,
  densities = P, qProbs = Q
)
</code></pre>

<hr>
<h2 id='n.sim.glidingSoaring.3d'>Simulates multiple 'gliding &amp; soaring' tracks with a given number of gliding steps</h2><span id='topic+n.sim.glidingSoaring.3d'></span>

<h3>Description</h3>

<p>Creates conditional empirical random walks in gliding mode, between a start and end point.
The walk is performed on a MODE layer and, if provided, additionally on a background and digital elevation layer.
The gliding is simulated with <a href="#topic+sim.cond.3d">sim.cond.3d</a> and soaring with <a href="#topic+sim.uncond.3d">sim.uncond.3d</a>,
therefore soaring is not restricted towards the target and can happen completly free as long as there are good thermal conditions.
It is important to extract for every mode in the MODE raster layer a corresponding densities object with <a href="#topic+get.densities.3d">get.densities.3d</a>
and pass them to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.sim.glidingSoaring.3d(
  n.sim = 1,
  parallel = FALSE,
  MODE,
  dGliding,
  dSoaring,
  qGliding,
  start = c(0, 0, 0),
  end = start,
  a0,
  g0,
  error = TRUE,
  smoothTransition = TRUE,
  glideRatio = 20,
  DEM = NULL,
  BG = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations to produce</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_parallel">parallel</code></td>
<td>
<p>logical: run computations in parallel (n-1 cores)? Or numeric: the number of nodes (maximum: n - 1 cores)</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_mode">MODE</code></td>
<td>
<p>raster layer containing the number/index of the mode, which should be used at each location</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_dgliding">dGliding</code></td>
<td>
<p>density object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function for gliding mode</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_dsoaring">dSoaring</code></td>
<td>
<p>density object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function for soaring mode</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_qgliding">qGliding</code></td>
<td>
<p>the Q probabilites for the steps in gliding mode (<a href="#topic+qProb.3d">qProb.3d</a>)</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_start">start</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the start point</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_end">end</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the end point</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_a0">a0</code></td>
<td>
<p>initial incoming heading in radian</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_g0">g0</code></td>
<td>
<p>initial incoming gradient/polar angle in radian</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_error">error</code></td>
<td>
<p>logical: add random noise to the turn angle, lift angle and step length to account for errors measurements?</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_smoothtransition">smoothTransition</code></td>
<td>
<p>logical: should the transitions between soaring and the following gliding sections be smoothed? Recommended to avoid dead ends</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_glideratio">glideRatio</code></td>
<td>
<p>ratio between vertical and horizontal movement, by default set to 15 meters forward movement per meter vertical movement</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_dem">DEM</code></td>
<td>
<p>raster layer containing a digital elevation model, covering the area between start and end point</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_bg">BG</code></td>
<td>
<p>a background raster layer that can be used to inform the choice of steps</p>
</td></tr>
<tr><td><code id="n.sim.glidingSoaring.3d_+3A_verbose">verbose</code></td>
<td>
<p>logical: print current mode used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 'soaring-gliding' trajectories or <code>NULL</code>s if dead ends have been encountered.
</p>


<h3>Note</h3>

<p>The MODE raster layer must be in the following structure: Gliding pixels have the value 1 and soaring pixel the values 2. <code>NA</code>'s are not allowed in the raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("tbd.")
</code></pre>

<hr>
<h2 id='niclas'>Example track data.frame</h2><span id='topic+niclas'></span>

<h3>Description</h3>

<p>This is data to be included in the package and can be used to test its functionality.
The track consists of x, y and z coordinates and represents the movement of a stork
called <code>niclas</code> in the Swiss midlands.
</p>


<h3>References</h3>

<p><a href="https://www.movebank.org">https://www.movebank.org</a>
</p>

<hr>
<h2 id='parpbapply'>Parallel apply with progressbar</h2><span id='topic+parpbapply'></span>

<h3>Description</h3>

<p>Function detects the operating system and chooses the approximate kind of process for parallelizing the task:
Windows: PSOCKCluster, Unix: Forking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parpbapply(
  X,
  FUN,
  MARGIN,
  packages = NULL,
  export = NULL,
  envir = environment(),
  nNodes = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parpbapply_+3A_x">X</code></td>
<td>
<p>an array, including a matrix.</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_fun">FUN</code></td>
<td>
<p>function, the function to be applied to each element of X</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_margin">MARGIN</code></td>
<td>
<p>a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_packages">packages</code></td>
<td>
<p>character vector, Only relevant for Windows: the packages needed in the function provided, eg. c(&quot;MASS&quot;, &quot;data.table&quot;)</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_export">export</code></td>
<td>
<p>character vector, Only relevant for Windows: the varibales needed in the function provided, eg. c(&quot;df&quot;, &quot;vec&quot;)</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_envir">envir</code></td>
<td>
<p>environment, Only relevant for Windows: Environment from which the variables should be exported from</p>
</td></tr>
<tr><td><code id="parpbapply_+3A_nnodes">nNodes</code></td>
<td>
<p>numeric, Number of processes to start (unix: best to fit with the available Cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or array or list of values obtained by applying a function to margins of an array or matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
df &lt;- data.frame(
  x = seq(1, n, 1),
  y = -seq(1, n, 1)
)
a &lt;- parpbapply(X = df, FUN = sum, MARGIN = 1, nNodes = 2)
</code></pre>

<hr>
<h2 id='parpblapply'>Parallel lapply with progressbar</h2><span id='topic+parpblapply'></span>

<h3>Description</h3>

<p>Function detects the operating system and chooses the approximate kind of process for parallelizing the task:
Windows: PSOCKCluster, Unix: Forking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parpblapply(
  X,
  FUN,
  packages = NULL,
  export = NULL,
  envir = environment(),
  nNodes = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parpblapply_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an expression object. Other objects (including classed objects) will be coerced by base::as.list</p>
</td></tr>
<tr><td><code id="parpblapply_+3A_fun">FUN</code></td>
<td>
<p>function, the function to be applied to each element of X</p>
</td></tr>
<tr><td><code id="parpblapply_+3A_packages">packages</code></td>
<td>
<p>character vector, Only relevant for Windows: the packages needed in the function provided, eg. c(&quot;MASS&quot;, &quot;data.table&quot;)</p>
</td></tr>
<tr><td><code id="parpblapply_+3A_export">export</code></td>
<td>
<p>character vector, Only relevant for Windows: the varibales needed in the function provided, eg. c(&quot;df&quot;, &quot;vec&quot;)</p>
</td></tr>
<tr><td><code id="parpblapply_+3A_envir">envir</code></td>
<td>
<p>environment, Only relevant for Windows: Environment from which the variables should be exported from</p>
</td></tr>
<tr><td><code id="parpblapply_+3A_nnodes">nNodes</code></td>
<td>
<p>numeric, Number of processes to start (unix: best to fit with the available Cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>square &lt;- function(x) {
  x * x
}
l &lt;- parpblapply(X = 1:1000, FUN = square, export = c("square"), nNodes = 2)
</code></pre>

<hr>
<h2 id='parpbsapply'>Parallel sapply with progressbar</h2><span id='topic+parpbsapply'></span>

<h3>Description</h3>

<p>Function detects the operating system and chooses the approximate kind of process for parallelizing the task:
Windows: PSOCKCluster, Unix: Forking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parpbsapply(
  X,
  FUN,
  packages = NULL,
  export = NULL,
  envir = environment(),
  nNodes = parallel::detectCores() - 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parpbsapply_+3A_x">X</code></td>
<td>
<p>a vector (atomic or list) or an expression object. Other objects (including classed objects) will be coerced by base::as.list.</p>
</td></tr>
<tr><td><code id="parpbsapply_+3A_fun">FUN</code></td>
<td>
<p>function, the function to be applied to each element of X</p>
</td></tr>
<tr><td><code id="parpbsapply_+3A_packages">packages</code></td>
<td>
<p>character vector, Only relevant for Windows: the packages needed in the function provided, eg. c(&quot;MASS&quot;, &quot;data.table&quot;)</p>
</td></tr>
<tr><td><code id="parpbsapply_+3A_export">export</code></td>
<td>
<p>character vector, Only relevant for Windows: the varibales needed in the function provided, eg. c(&quot;df&quot;, &quot;vec&quot;)</p>
</td></tr>
<tr><td><code id="parpbsapply_+3A_envir">envir</code></td>
<td>
<p>environment, Only relevant for Windows: Environment from which the variables should be exported from</p>
</td></tr>
<tr><td><code id="parpbsapply_+3A_nnodes">nNodes</code></td>
<td>
<p>numeric, Number of processes to start (unix: best to fit with the available Cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>square &lt;- function(x) {
  x * x
}
s &lt;- parpbsapply(X = 1:1000, FUN = square, export = c("square"), nNodes = 2)
</code></pre>

<hr>
<h2 id='plot2d'>Plot function to plot the 3-D tracks in 2-D plane</h2><span id='topic+plot2d'></span>

<h3>Description</h3>

<p>Plot function to plot the 3-D tracks in 2-D plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2d(
  origTrack,
  simTrack = NULL,
  titleText = character(1),
  DEM = NULL,
  BG = NULL,
  padding = 0.1,
  alpha = 0.7,
  resolution = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot2d_+3A_origtrack">origTrack</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot2d_+3A_simtrack">simTrack</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot2d_+3A_titletext">titleText</code></td>
<td>
<p>string with title of the plot</p>
</td></tr>
<tr><td><code id="plot2d_+3A_dem">DEM</code></td>
<td>
<p>an object of type <code>RasterLayer</code>, needs overlapping extent with the line(s)</p>
</td></tr>
<tr><td><code id="plot2d_+3A_bg">BG</code></td>
<td>
<p>an object of type <code>RasterLayer</code>, needs overlapping extent with the line(s)</p>
</td></tr>
<tr><td><code id="plot2d_+3A_padding">padding</code></td>
<td>
<p>adds a pad to the 2-D space in percentage (by default set to 0.1)</p>
</td></tr>
<tr><td><code id="plot2d_+3A_alpha">alpha</code></td>
<td>
<p>a number between 0 and 1, to specify the transparency of the simulated line(s)</p>
</td></tr>
<tr><td><code id="plot2d_+3A_resolution">resolution</code></td>
<td>
<p>number of pixels the rasters are downsampled to (by default set to 500 pixels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot2d(niclas)
</code></pre>

<hr>
<h2 id='plot3d'>Plot track(s) with a surface of a digital elevation model in three dimensions</h2><span id='topic+plot3d'></span>

<h3>Description</h3>

<p>Plot track(s) with a surface of a digital elevation model in three dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(
  origTrack,
  simTrack = NULL,
  titleText = character(1),
  DEM = NULL,
  padding = 0.1,
  timesHeight = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3d_+3A_origtrack">origTrack</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot3d_+3A_simtrack">simTrack</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot3d_+3A_titletext">titleText</code></td>
<td>
<p>string with title of the plot</p>
</td></tr>
<tr><td><code id="plot3d_+3A_dem">DEM</code></td>
<td>
<p>an object of type <code>RasterLayer</code>, needs overlapping extent with the line(s)</p>
</td></tr>
<tr><td><code id="plot3d_+3A_padding">padding</code></td>
<td>
<p>adds a pad to the 2-D space in percentage (by default set to 0.1)</p>
</td></tr>
<tr><td><code id="plot3d_+3A_timesheight">timesHeight</code></td>
<td>
<p>multiply the height scale by a scalar (by default set to 10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a plotly object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot3d(niclas)
</code></pre>

<hr>
<h2 id='plot3d.densities'>Density plots of turn angle, lift angle and step length</h2><span id='topic+plot3d.densities'></span>

<h3>Description</h3>

<p>The function takes either one track or two tracks.
The second track can be a list of tracks (eg. the output of <a href="#topic+n.sim.cond.3d">n.sim.cond.3d</a>),
Then the densities of turn angle, lift angle and step length of all the simulations is taken.
Additionally the autodifferences parameter can be set to true, then the densities of the autodifferences
in turn angle, lift angle and step length are visualized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d.densities(
  track1,
  track2 = NULL,
  autodifferences = FALSE,
  scaleDensities = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3d.densities_+3A_track1">track1</code></td>
<td>
<p>a list containing a data.frame with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot3d.densities_+3A_track2">track2</code></td>
<td>
<p>a list containing a data.frame with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="plot3d.densities_+3A_autodifferences">autodifferences</code></td>
<td>
<p>logical: should the densities of the autodifferences in turn angle, lift angle and step length are visualized.</p>
</td></tr>
<tr><td><code id="plot3d.densities_+3A_scaledensities">scaleDensities</code></td>
<td>
<p>logical: should densities be scaled between 0 and 1, then sum of the area under the curve is not 1 anymore!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot3d.densities(niclas)
</code></pre>

<hr>
<h2 id='plot3d.multiplot'>Multiple plot function for ggplot objects</h2><span id='topic+plot3d.multiplot'></span>

<h3>Description</h3>

<p>If the layout is something like <code>matrix(c(1,2,3,3), nrow=2, byrow=TRUE)</code>,
then plot 1 will go in the upper left, 2 will go in the upper right, and
3 will go all the way across the bottom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d.multiplot(..., plotlist = NULL, cols = 1, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3d.multiplot_+3A_...">...</code></td>
<td>
<p>ggplot objects</p>
</td></tr>
<tr><td><code id="plot3d.multiplot_+3A_plotlist">plotlist</code></td>
<td>
<p>a list of ggplot objects</p>
</td></tr>
<tr><td><code id="plot3d.multiplot_+3A_cols">cols</code></td>
<td>
<p>number of columns in layout</p>
</td></tr>
<tr><td><code id="plot3d.multiplot_+3A_layout">layout</code></td>
<td>
<p>a matrix specifying the layout. If present, <code>cols</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, plots the ggplot2 objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot3d.multiplot(plot2d(niclas), plot2d(niclas), plot2d(niclas))
</code></pre>

<hr>
<h2 id='plot3d.tldCube'>Visualize turn-lift-step histogram</h2><span id='topic+plot3d.tldCube'></span>

<h3>Description</h3>

<p>Creates a three dimensional scatterplot of the possibles next steps,
based on the tldCube, which was extracted from a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d.tldCube(tldCube)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3d.tldCube_+3A_tldcube">tldCube</code></td>
<td>
<p>tldCube; the ouptut from <a href="#topic+turnLiftStepHist">turnLiftStepHist</a> or <a href="#topic+get.densities.3d">get.densities.3d</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a plotly object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- get.track.densities.3d(niclas)
suppressWarnings(plot3d.tldCube(P$tldCube))
</code></pre>

<hr>
<h2 id='plotRaster'>Plots a rasterLayer or rasterStack</h2><span id='topic+plotRaster'></span>

<h3>Description</h3>

<p>Plots a rasterLayer or rasterStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRaster(r, title = character(0), centerColorBar = FALSE, ncol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotRaster_+3A_r">r</code></td>
<td>
<p><code>rasterLayer</code> or <code>rasterStack</code></p>
</td></tr>
<tr><td><code id="plotRaster_+3A_title">title</code></td>
<td>
<p>title text of plot(s)</p>
</td></tr>
<tr><td><code id="plotRaster_+3A_centercolorbar">centerColorBar</code></td>
<td>
<p>logical: center colobar around 0 and use <code>RdBuTheme()</code>?</p>
</td></tr>
<tr><td><code id="plotRaster_+3A_ncol">ncol</code></td>
<td>
<p>number of columns to plot a stack, by default estimated by the square root</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the rasters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotRaster(dem)
</code></pre>

<hr>
<h2 id='qProb.3d'>Q probabilities for n steps</h2><span id='topic+qProb.3d'></span>

<h3>Description</h3>

<p>Calculates the Q probability, representing the pull to
the target. The number of steps on which the Q prob will be
quantified is number of total segments less than one
(the last step is defined by the target itself).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qProb.3d(sim, n.locs, parallel = FALSE, maxBin = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qProb.3d_+3A_sim">sim</code></td>
<td>
<p>the result of <a href="#topic+sim.uncond.3d">sim.uncond.3d</a>, or a data frame with at least
x,y,z-coordinates, the arrival azimuth and the arrival gradient.</p>
</td></tr>
<tr><td><code id="qProb.3d_+3A_n.locs">n.locs</code></td>
<td>
<p>number of total segments to be modeled,
the length of the desired conditional empirical random walk</p>
</td></tr>
<tr><td><code id="qProb.3d_+3A_parallel">parallel</code></td>
<td>
<p>logical: run computations in parallel (n-1 cores)? Or numeric: the number of nodes (maximum: n - 1 cores)</p>
</td></tr>
<tr><td><code id="qProb.3d_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the Q - tldCubes for every step
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qProb.3d(niclas, 3)
</code></pre>

<hr>
<h2 id='reproduce.track.3d'>Reproduce a track with the eRTG3D</h2><span id='topic+reproduce.track.3d'></span>

<h3>Description</h3>

<p>Simulates n tracks with the geometrical properties of the original track,
between the same start and end point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproduce.track.3d(
  track,
  n.sim = 1,
  parallel = FALSE,
  error = TRUE,
  DEM = NULL,
  BG = NULL,
  filterDeadEnds = TRUE,
  plot2d = FALSE,
  plot3d = FALSE,
  maxBin = 25,
  gradientDensity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reproduce.track.3d_+3A_track">track</code></td>
<td>
<p>data.frame with x,y,z coordinates of the original track</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations that should be done</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_parallel">parallel</code></td>
<td>
<p>logical: run computations in parallel (n-1 cores)? Or numeric: the number of nodes (maximum: n - 1 cores)</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_error">error</code></td>
<td>
<p>logical: add error term to movement in simulation?</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_dem">DEM</code></td>
<td>
<p>a raster containing a digital elevation model, covering the same extent as the track</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_bg">BG</code></td>
<td>
<p>a raster influencing the probabilities.</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_filterdeadends">filterDeadEnds</code></td>
<td>
<p>logical: Remove tracks that ended in a dead end?</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_plot2d">plot2d</code></td>
<td>
<p>logical: plot tracks on 2-D plane?</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_plot3d">plot3d</code></td>
<td>
<p>logical: plot tracks in 3-D?</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube (<a href="#topic+turnLiftStepHist">turnLiftStepHist</a>)</p>
</td></tr>
<tr><td><code id="reproduce.track.3d_+3A_gradientdensity">gradientDensity</code></td>
<td>
<p>logical: Should a distribution of the gradient angle be extracted and used in the simulations (<a href="#topic+get.densities.3d">get.densities.3d</a>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or data.frame containing the simulated track(s) (CERW).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reproduce.track.3d(niclas[1:10, ])
</code></pre>

<hr>
<h2 id='saveImageSlices'>Export a dataCube as image slice sequence</h2><span id='topic+saveImageSlices'></span>

<h3>Description</h3>

<p>Exports a dataCube of type <code>rasterStack</code> as Tiff image sequence.
Image sequences are a common structure to represent voxel data and
most of the specific software to visualize voxel data is able to read it (e.g. blender)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveImageSlices(rStack, filename, dir, NaVal = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveImageSlices_+3A_rstack">rStack</code></td>
<td>
<p>rasterStack to be saved to Tiff image slices</p>
</td></tr>
<tr><td><code id="saveImageSlices_+3A_filename">filename</code></td>
<td>
<p>name of the image slices</p>
</td></tr>
<tr><td><code id="saveImageSlices_+3A_dir">dir</code></td>
<td>
<p>directory, where the slices should be stored</p>
</td></tr>
<tr><td><code id="saveImageSlices_+3A_naval">NaVal</code></td>
<td>
<p>numeric value that should represent NA values in the Tiff image, default is <code>NaVal = 0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Saves the Tiff image files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crws &lt;- lapply(X = seq(1:100), FUN = function(X) {
  sim.crw.3d(nStep = 100, rTurn = 0.99, rLift = 0.99, meanStep = 0.1)
})
points &lt;- do.call("rbind", crws)
extent &lt;- raster::extent(c(-10, 10, -10, 10))
ud &lt;- voxelCount(points, extent,
  xyRes = 5,
  zMin = -10, zMax = 10, standartize = TRUE
)
saveImageSlices(ud, filename = "saveImageSlices_test", dir = tempdir())
</code></pre>

<hr>
<h2 id='sf2df.3d'>Converts a sf data.frame to a normal dataframe</h2><span id='topic+sf2df.3d'></span>

<h3>Description</h3>

<p>Converts a sf data.frame to a normal dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf2df.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf2df.3d_+3A_track">track</code></td>
<td>
<p>An object of type <code>'sf, data.frame'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sf2df.3d(track2sf.3d(niclas, CRS = 4326))
</code></pre>

<hr>
<h2 id='sim.cond.3d'>Conditional Empirical Random Walk (CERW) in 3-D</h2><span id='topic+sim.cond.3d'></span>

<h3>Description</h3>

<p>Creates a conditional empirical random walk, with a specific starting and ending point,
geometrically similar to the initial trajectory
(extractMethod: raster overlay method can take &quot;simple&quot; or &quot;bilinear&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cond.3d(
  n.locs,
  start = c(0, 0, 0),
  end = start,
  a0,
  g0,
  densities,
  qProbs,
  error = FALSE,
  DEM = NULL,
  BG = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cond.3d_+3A_n.locs">n.locs</code></td>
<td>
<p>length of the trajectory in locations</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_start">start</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the start point</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_end">end</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the end point</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_a0">a0</code></td>
<td>
<p>initial incoming heading in radian</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_g0">g0</code></td>
<td>
<p>initial incoming gradient/polar angle in radian</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_densities">densities</code></td>
<td>
<p>list object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_qprobs">qProbs</code></td>
<td>
<p>list object returned by the <a href="#topic+qProb.3d">qProb.3d</a> function</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_error">error</code></td>
<td>
<p>logical: add random noise to the turn angle, lift angle and step length to account for errors measurements?</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_dem">DEM</code></td>
<td>
<p>raster layer containing a digital elevation model, covering the area between start and end point</p>
</td></tr>
<tr><td><code id="sim.cond.3d_+3A_bg">BG</code></td>
<td>
<p>a background raster layer that can be used to inform the choice of steps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trajectory in the form of data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>niclas &lt;- track.properties.3d(niclas)
n.locs &lt;- 3
P &lt;- get.track.densities.3d(niclas)
f &lt;- 1500
start &lt;- Reduce(c, niclas[1, 1:3])
end &lt;- Reduce(c, niclas[n.locs, 1:3])
a0 &lt;- niclas$a[1]
g0 &lt;- niclas$g[1]
uerw &lt;- sim.uncond.3d(
  n.locs * f, start = start, a0 = a0, g0 = g0, densities = P
)
Q &lt;- qProb.3d(uerw, n.locs)
sim.cond.3d(
  n.locs = n.locs, start = start, end = end,
  a0 = a0, g0 = g0, densities = P, qProbs = Q
)
</code></pre>

<hr>
<h2 id='sim.crw.3d'>Simulation of a three dimensional Correlated Random Walk</h2><span id='topic+sim.crw.3d'></span>

<h3>Description</h3>

<p>Simulation of a three dimensional Correlated Random Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.crw.3d(nStep, rTurn, rLift, meanStep, start = c(0, 0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.crw.3d_+3A_nstep">nStep</code></td>
<td>
<p>the number of steps of the simulated trajectory</p>
</td></tr>
<tr><td><code id="sim.crw.3d_+3A_rturn">rTurn</code></td>
<td>
<p>the correlation on the turn angle</p>
</td></tr>
<tr><td><code id="sim.crw.3d_+3A_rlift">rLift</code></td>
<td>
<p>the correlation of the lift angle</p>
</td></tr>
<tr><td><code id="sim.crw.3d_+3A_meanstep">meanStep</code></td>
<td>
<p>the mean step length</p>
</td></tr>
<tr><td><code id="sim.crw.3d_+3A_start">start</code></td>
<td>
<p>a vector of length 3 containing the coordinates of the start point of the trajectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trajectory in the form of data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.crw.3d(nStep = 10, rTurn = 0.9, rLift = 0.9, meanStep = 1, start = c(0, 0, 0))
</code></pre>

<hr>
<h2 id='sim.glidingSoaring.3d'>Simulates 'gliding &amp; soaring' track with a given number of gliding steps</h2><span id='topic+sim.glidingSoaring.3d'></span>

<h3>Description</h3>

<p>Creates a conditional empirical random walk in gliding mode, between a start and end point.
The walk is performed on a MODE layer and, if provided, additionally on a background and digital elevation layer.
The gliding is simulated with <a href="#topic+sim.cond.3d">sim.cond.3d</a> and soaring with <a href="#topic+sim.uncond.3d">sim.uncond.3d</a>,
therefore soaring is not restricted towards the target and can happen completly free as long as there are good thermal conditions.
It is important to extract for every mode in the MODE raster layer a corresponding densities object with <a href="#topic+get.densities.3d">get.densities.3d</a>
and pass them to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.glidingSoaring.3d(
  MODE,
  dGliding,
  dSoaring,
  qGliding,
  start = c(0, 0, 0),
  end = start,
  a0,
  g0,
  error = TRUE,
  smoothTransition = TRUE,
  glideRatio = 15,
  DEM = NULL,
  BG = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.glidingSoaring.3d_+3A_mode">MODE</code></td>
<td>
<p>raster layer containing the number/index of the mode, which should be used at each location</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_dgliding">dGliding</code></td>
<td>
<p>density object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function for gliding mode</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_dsoaring">dSoaring</code></td>
<td>
<p>density object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function for soaring mode</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_qgliding">qGliding</code></td>
<td>
<p>the Q probabilites for the steps in gliding mode (<a href="#topic+qProb.3d">qProb.3d</a>)</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_start">start</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the start point</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_end">end</code></td>
<td>
<p>numeric vector of length 3 with the coordinates of the end point</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_a0">a0</code></td>
<td>
<p>initial incoming heading in radian</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_g0">g0</code></td>
<td>
<p>initial incoming gradient/polar angle in radian</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_error">error</code></td>
<td>
<p>logical: add random noise to the turn angle, lift angle and step length to account for errors measurements?</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_smoothtransition">smoothTransition</code></td>
<td>
<p>logical: should the transitions between soaring and the following gliding sections be smoothed? Recommended to avoid dead ends</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_glideratio">glideRatio</code></td>
<td>
<p>ratio between vertical and horizontal movement, by default set to 15 meters forward movement per meter vertical movement</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_dem">DEM</code></td>
<td>
<p>raster layer containing a digital elevation model, covering the area between start and end point</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_bg">BG</code></td>
<td>
<p>a background raster layer that can be used to inform the choice of steps</p>
</td></tr>
<tr><td><code id="sim.glidingSoaring.3d_+3A_verbose">verbose</code></td>
<td>
<p>logical: print current mode used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'soaring-gliding' trajectory in the form of data.frame
</p>


<h3>Note</h3>

<p>The MODE raster layer must be in the following structure: Gliding pixels have the value 1 and soaring pixel the values 2. <code>NA</code>'s are not allowed in the raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("tbd.")
</code></pre>

<hr>
<h2 id='sim.uncond.3d'>Unconditional Empirical Random Walk (UERW) in 3-D</h2><span id='topic+sim.uncond.3d'></span>

<h3>Description</h3>

<p>This function creates unconditional walks with prescribed
empirical properties (turning angle, lift angle and step length
and the auto-differences of them. It can be used for uncon-
ditional walks or to seed the conditional walks with
comparably long simulations.
The conditional walk connecting a given start
with a certain end point by a given number of
steps needs an attraction term (the Q probability, see <a href="#topic+qProb.3d">qProb.3d</a>)
to ensure that the target is approached and hit.
In order to calculate the Q probability for each step
the distribution of turns and lifts to target and
the distribution of distance to target has to be known.
They can be derived from the empirical data (ideally),
or estimated from an unconditional process with the same properties.
Creates a unconditional empirical random walk, with a specific starting point,
geometrically similar to the initial trajectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.uncond.3d(n.locs, start = c(0, 0, 0), a0, g0, densities, error = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.uncond.3d_+3A_n.locs">n.locs</code></td>
<td>
<p>the number of locations for the simulated track</p>
</td></tr>
<tr><td><code id="sim.uncond.3d_+3A_start">start</code></td>
<td>
<p>vector indicating the start point <code>c(x,y,z)</code></p>
</td></tr>
<tr><td><code id="sim.uncond.3d_+3A_a0">a0</code></td>
<td>
<p>initial heading in radian</p>
</td></tr>
<tr><td><code id="sim.uncond.3d_+3A_g0">g0</code></td>
<td>
<p>initial gradient/polar angle in radian</p>
</td></tr>
<tr><td><code id="sim.uncond.3d_+3A_densities">densities</code></td>
<td>
<p>list object returned by the <a href="#topic+get.densities.3d">get.densities.3d</a> function</p>
</td></tr>
<tr><td><code id="sim.uncond.3d_+3A_error">error</code></td>
<td>
<p>logical: add random noise to the turn angle, lift angle and step length to account for errors measurements?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3 dimensional trajectory in the form of a data.frame
</p>


<h3>Note</h3>

<p>Simulations connecting start and end points
with more steps than 1/10th or more of the number of steps
of the empirical data should rather rely on simulated
unconditional walks with the same properties than on
the empirical data (<code>factor = 1500</code>).
</p>


<h3>Random initial heading</h3>

<p>For a random initial heading a0 use:
<code>sample(atan2(diff(coordinates(track)[,2]), diff(coordinates(track)[,1])),1)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.uncond.3d(
  10, start = c(0, 0, 0), a0 = pi / 2, g0 = pi / 2,
  densities = get.track.densities.3d(niclas)
)
</code></pre>

<hr>
<h2 id='test.eRTG.3d'>Test the functionality of the eRTG3D</h2><span id='topic+test.eRTG.3d'></span>

<h3>Description</h3>

<p>The test simulates a CRW with given parameters and reconstructs it by using the eRTG3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.eRTG.3d(
  parallel = FALSE,
  returnResult = FALSE,
  plot2d = FALSE,
  plot3d = TRUE,
  plotDensities = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.eRTG.3d_+3A_parallel">parallel</code></td>
<td>
<p>logical: test running parallel?</p>
</td></tr>
<tr><td><code id="test.eRTG.3d_+3A_returnresult">returnResult</code></td>
<td>
<p>logical: return tracks generated?</p>
</td></tr>
<tr><td><code id="test.eRTG.3d_+3A_plot2d">plot2d</code></td>
<td>
<p>logical: plot tracks on 2-D plane?</p>
</td></tr>
<tr><td><code id="test.eRTG.3d_+3A_plot3d">plot3d</code></td>
<td>
<p>logical: plot tracks in 3-D?</p>
</td></tr>
<tr><td><code id="test.eRTG.3d_+3A_plotdensities">plotDensities</code></td>
<td>
<p>logical: plot densities of turning angle, lift angle and step length?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the original CRW and the simulated track (CERW).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test.eRTG.3d()

</code></pre>

<hr>
<h2 id='test.verification.3d'>Statistical Verification of the simulated track</h2><span id='topic+test.verification.3d'></span>

<h3>Description</h3>

<p>Uses two-sample Kolmogorov-Smirnov test or the one-sample t-test to compare the geometric characteristics of the original track
with the characteristics of the simulated track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.verification.3d(track1, track2, alpha = 0.05, plot = FALSE, test = "ks")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.verification.3d_+3A_track1">track1</code></td>
<td>
<p>data.frame or list of data.frames with x,y,z coordinates of the original track</p>
</td></tr>
<tr><td><code id="test.verification.3d_+3A_track2">track2</code></td>
<td>
<p>data.frame or list of data.frames with x,y,z coordinates of the simulated track</p>
</td></tr>
<tr><td><code id="test.verification.3d_+3A_alpha">alpha</code></td>
<td>
<p>scalar: significance level, default <code>alpha = 0.05</code></p>
</td></tr>
<tr><td><code id="test.verification.3d_+3A_plot">plot</code></td>
<td>
<p>logical: plot the densities or differences of turn angle, lift angle and step length of the two tracks?</p>
</td></tr>
<tr><td><code id="test.verification.3d_+3A_test">test</code></td>
<td>
<p>character: either <code>"ks"</code> or <code>"ttest"</code> to choose the kind of test procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test objects of the 6 two-sample Kolmogorov-Smirnov test conducted.
</p>


<h3>Note</h3>

<p>By choosing <code>test = "ttest"</code> a random sample, without replacement is taken from the longer track,
to shorten it to the length of the longer track. The order of the shorter track is also sampled randomly.
Then the two randomly ordered vectors of turn angles, lift angles and step lengths are substracted from each other.
If the both tracks stem from the same distributions the the mean deviatio should tend to towards zero, therefore the
difference is tested two-sided against <code>mu = 0</code> with a one-sample t-test.
</p>
<p>By setting <code>test = "ks"</code> a two-sample Kolmogorov-Smirnov test is carried out on the distributions of turn angles,
lift angles and step lengths of the two tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.verification.3d(niclas, niclas)
</code></pre>

<hr>
<h2 id='track.extent'>Extent of track(s)</h2><span id='topic+track.extent'></span>

<h3>Description</h3>

<p>Extent of track(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.extent(track, zAxis = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track.extent_+3A_track">track</code></td>
<td>
<p>a list containing data.frames with x,y,z coordinates or a data.frame</p>
</td></tr>
<tr><td><code id="track.extent_+3A_zaxis">zAxis</code></td>
<td>
<p>logical: return also the extent of the Z axis?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an extent object of the raster package in the 2–D case and a vector in the 3–D case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track.extent(niclas, zAxis = TRUE)
</code></pre>

<hr>
<h2 id='track.properties.3d'>Track properties of a 3-D track</h2><span id='topic+track.properties.3d'></span>

<h3>Description</h3>

<p>Returns the properties (distances, azimuth, polar angle,
turn angle &amp; lift angle) of a track in three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.properties.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track.properties.3d_+3A_track">track</code></td>
<td>
<p>data.frame with x,y,z coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data.frame with track properties
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track.properties.3d(niclas)
</code></pre>

<hr>
<h2 id='track.split.3d'>This function splits the by outliers in the time lag.</h2><span id='topic+track.split.3d'></span>

<h3>Description</h3>

<p>The length of timeLag must be the the track's length minus 1 and represents
the time passed between the fix point acquisition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track.split.3d(track, timeLag, lag = NULL, tolerance = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track.split.3d_+3A_track">track</code></td>
<td>
<p>track data.frame with x, y and z coordinates</p>
</td></tr>
<tr><td><code id="track.split.3d_+3A_timelag">timeLag</code></td>
<td>
<p>a numeric vector with the time passed between the fix point acquisition</p>
</td></tr>
<tr><td><code id="track.split.3d_+3A_lag">lag</code></td>
<td>
<p>NULL or a manually chosen lag</p>
</td></tr>
<tr><td><code id="track.split.3d_+3A_tolerance">tolerance</code></td>
<td>
<p>NULL or a manually chosen tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the splitted tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track.split.3d(
  niclas,
  timeLag = rep(1, nrow(niclas) - 1) + rnorm(nrow(niclas) - 1,
  mean = 0,
  sd = 0.25)
)
</code></pre>

<hr>
<h2 id='track2sf.3d'>Converts a track to a <code>'sf, data.frame'</code></h2><span id='topic+track2sf.3d'></span>

<h3>Description</h3>

<p>Converts a track to a <code>'sf, data.frame'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track2sf.3d(track, CRS = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="track2sf.3d_+3A_track">track</code></td>
<td>
<p>eRTG3D track data.frame or a matrix</p>
</td></tr>
<tr><td><code id="track2sf.3d_+3A_crs">CRS</code></td>
<td>
<p>numeric, EPSG code of the CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A track of type <code>'sf, data.frame'</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>track2sf.3d(niclas, 4326)
</code></pre>

<hr>
<h2 id='transformCRS.3d'>Transform coordinates reference system (CRS) of a 3-D track</h2><span id='topic+transformCRS.3d'></span>

<h3>Description</h3>

<p>Attention: Please use this function for CRS transformations,
since it is based on the <a href="sf.html#topic+st_transform">st_transform</a> from the sf package and therefore
supports CRS transformations in 3-D. Note: <code>spTransform</code> from the <code>sp</code> package
only supports transformations in the 2D plane, which will cause distortions
in the third dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformCRS.3d(track, fromCRS, toCRS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformCRS.3d_+3A_track">track</code></td>
<td>
<p>data.frame with x,y,z coordinates</p>
</td></tr>
<tr><td><code id="transformCRS.3d_+3A_fromcrs">fromCRS</code></td>
<td>
<p>numeric, EPSG code of the current CRS</p>
</td></tr>
<tr><td><code id="transformCRS.3d_+3A_tocrs">toCRS</code></td>
<td>
<p>numeric, EPSG code of the CRS to be converted in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing x,y,z and variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transformCRS.3d(niclas, fromCRS = 2056, toCRS = 4326)
</code></pre>

<hr>
<h2 id='turn2target.3d'>Turn angle to target</h2><span id='topic+turn2target.3d'></span>

<h3>Description</h3>

<p>Calculates the turn angle between every point in the track and the last point (target).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turn2target.3d(track)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turn2target.3d_+3A_track">track</code></td>
<td>
<p>a track data.frame containing x, y and z coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the turn angles to target
</p>


<h3>Examples</h3>

<pre><code class='language-R'>turn2target.3d(niclas)
</code></pre>

<hr>
<h2 id='turnLiftStepHist'>Three dimensional histogram</h2><span id='topic+turnLiftStepHist'></span>

<h3>Description</h3>

<p>Derives a three dimensional distribution of a turn angle,
lift angle and step length, using the Freedman–Diaconis rule for
estimating the number of bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnLiftStepHist(
  turn,
  lift,
  step,
  printDims = TRUE,
  rm.zeros = TRUE,
  maxBin = 25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turnLiftStepHist_+3A_turn">turn</code></td>
<td>
<p>numeric vector of turn angles</p>
</td></tr>
<tr><td><code id="turnLiftStepHist_+3A_lift">lift</code></td>
<td>
<p>numeric vector of lift angles</p>
</td></tr>
<tr><td><code id="turnLiftStepHist_+3A_step">step</code></td>
<td>
<p>numeric vector of step lengths</p>
</td></tr>
<tr><td><code id="turnLiftStepHist_+3A_printdims">printDims</code></td>
<td>
<p>logical: should dimensions of tld-Cube be messaged?</p>
</td></tr>
<tr><td><code id="turnLiftStepHist_+3A_rm.zeros">rm.zeros</code></td>
<td>
<p>logical: should combinations with zero probability be removed?</p>
</td></tr>
<tr><td><code id="turnLiftStepHist_+3A_maxbin">maxBin</code></td>
<td>
<p>numeric scalar, maximum number of bins per dimension of the tld-cube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three dimensional histogram as data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>niclas &lt;- track.properties.3d(niclas)[2:nrow(niclas), ]
turnLiftStepHist(niclas$t, niclas$l, niclas$d)
</code></pre>

<hr>
<h2 id='voxelCount'>Apply voxel counting on a point cloud</h2><span id='topic+voxelCount'></span>

<h3>Description</h3>

<p>A <code>rasterStack</code> object is created, representing the 3–D voxel cube.
The z axis is sliced into regular sections between the maximum and minimum value.
For every height slice a raster with points per cell counts is created. Additionally
the voxels can be standartized between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voxelCount(
  points,
  extent,
  xyRes,
  zRes = xyRes,
  zMin,
  zMax,
  standartize = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voxelCount_+3A_points">points</code></td>
<td>
<p>a x, y, z data.frame</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_extent">extent</code></td>
<td>
<p>a raster extent object of the extent to create the rasters</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_xyres">xyRes</code></td>
<td>
<p>resolution in the ground plane of the created rasters</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_zres">zRes</code></td>
<td>
<p>resolution in the z axis (by default <code>zRes = xyRes</code>)</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_zmin">zMin</code></td>
<td>
<p>minimum z value</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_zmax">zMax</code></td>
<td>
<p>maximum height value</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_standartize">standartize</code></td>
<td>
<p>logical: standartize the values?</p>
</td></tr>
<tr><td><code id="voxelCount_+3A_verbose">verbose</code></td>
<td>
<p>logical: print currently processed height band in raster stack?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>rasterStack</code> object, representing the 3–D voxel cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>voxelCount(niclas, raster::extent(dem), 100, 100, 1000, 1400, standartize = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
