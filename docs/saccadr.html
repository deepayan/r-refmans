<!DOCTYPE html><html lang="en-US"><head><title>Help for package saccadr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {saccadr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#saccadr-package'><p>saccadr: Extract Saccades via an Ensemble of Methods Approach</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#compute_velocity_ek'><p>Compute velocity via Engbert &amp; Kliegl (2003) algorithm.</p></a></li>
<li><a href='#diff_ek'><p>Differentiate x and y and compute change amplitude via an algorithm proposed by Engbert &amp; Kliegl (2003)</p></a></li>
<li><a href='#diff_nh'><p>Differentiate x and y and compute change amplitude via an algorithm proposed by Nyström and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a></p></a></li>
<li><a href='#extract_saccades'><p>Extract saccades from samples using votes from selected methods.</p></a></li>
<li><a href='#filter_via_savitzky_golay'><p>Smooths signal using Savitzky-Golay and then shifts the filtered signal back</p></a></li>
<li><a href='#input_to_matrix'><p>Converts inputs to matrix</p></a></li>
<li><a href='#method_ek'><p>Extract saccades using an algorithm proposed by Engbert and Kliegl (2003) <a href="https://doi.org/10.1016/S0042-6989%2803%2900084-1">doi:10.1016/S0042-6989(03)00084-1</a></p></a></li>
<li><a href='#method_nh'><p>Extract saccades using an algorithm proposed by Nyström and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a>.</p></a></li>
<li><a href='#method_om'><p>Extract saccades using an algorithm proposed by Otero-Millan et al. (2014) <a href="https://doi.org/10.1167/14.2.18">doi:10.1167/14.2.18</a></p></a></li>
<li><a href='#monocular_ten_trials'><p>A monocular multi-trial recording</p></a></li>
<li><a href='#option_or_default'><p>Extract value for a named list or use default if key is missing</p></a></li>
<li><a href='#sd_via_median_estimator'><p>Compute standard deviation via median estimator.</p></a></li>
<li><a href='#single_trial'><p>A single trial monocular samples recorded at 500 Hz.</p></a></li>
<li><a href='#single_trial_binocular'><p>A single trial binocular recording.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extract Saccades via an Ensemble of Methods Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Description:</td>
<td>A modular and extendable approach to extract (micro)saccades from gaze samples via an ensemble of methods.
  Although there is an agreement about a general definition of a saccade, the more specific details are harder to agree upon.
  Therefore, there are numerous algorithms that extract saccades based on various heuristics, which differ in the assumptions about velocity,
  acceleration, etc. The package uses three methods (Engbert and Kliegl (2003) &lt;<a href="https://doi.org/10.1016%2FS0042-6989%2803%2900084-1">doi:10.1016/S0042-6989(03)00084-1</a>&gt;,
  Otero-Millan et al. (2014)&lt;<a href="https://doi.org/10.1167%2F14.2.18">doi:10.1167/14.2.18</a>&gt;, and Nyström and Holmqvist (2010) &lt;<a href="https://doi.org/10.3758%2FBRM.42.1.188">doi:10.3758/BRM.42.1.188</a>&gt;)
  to label individual samples and then applies a majority vote approach to identify saccades. The package includes three
  methods but can be extended via custom functions. It also uses a modular approach to compute velocity and
  acceleration from noisy samples. Finally, you can obtain methods votes per gaze sample instead of saccades.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexander-pastukhov/saccadr/">https://github.com/alexander-pastukhov/saccadr/</a>,
<a href="https://alexander-pastukhov.github.io/saccadr/">https://alexander-pastukhov.github.io/saccadr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexander-pastukhov/saccadr/issues/">https://github.com/alexander-pastukhov/saccadr/issues/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, Rcpp (&ge; 1.0.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), dplyr, rlang, cluster, signal, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, ggplot2, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 14:13:09 UTC; ba7dr4</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Pastukhov
    <a href="https://orcid.org/0000-0002-8738-8591"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Pastukhov &lt;pastukhov.alexander@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='saccadr-package'>saccadr: Extract Saccades via an Ensemble of Methods Approach</h2><span id='topic+saccadr'></span><span id='topic+saccadr-package'></span>

<h3>Description</h3>

<p>Extract (Micro)Saccades From Gaze Samples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander Pastukhov <a href="mailto:pastukhov.alexander@gmail.com">pastukhov.alexander@gmail.com</a> (<a href="https://orcid.org/0000-0002-8738-8591">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/alexander-pastukhov/saccadr/">https://github.com/alexander-pastukhov/saccadr/</a>
</p>
</li>
<li> <p><a href="https://alexander-pastukhov.github.io/saccadr/">https://alexander-pastukhov.github.io/saccadr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/alexander-pastukhov/saccadr/issues/">https://github.com/alexander-pastukhov/saccadr/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='compute_velocity_ek'>Compute velocity via Engbert &amp; Kliegl (2003) algorithm.</h2><span id='topic+compute_velocity_ek'></span>

<h3>Description</h3>

<p>Compute velocity via Engbert &amp; Kliegl (2003) algorithm.
See formula #1 in the manuscript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_velocity_ek(x, trial, time_window_in_samples, delta_t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_velocity_ek_+3A_x">x</code></td>
<td>
<p>Vector of coordinates</p>
</td></tr>
<tr><td><code id="compute_velocity_ek_+3A_trial">trial</code></td>
<td>
<p>Vector with trial labels, so that velocity is computed only within trials.</p>
</td></tr>
<tr><td><code id="compute_velocity_ek_+3A_time_window_in_samples">time_window_in_samples</code></td>
<td>
<p>Width of window for velocity computation in samples.</p>
</td></tr>
<tr><td><code id="compute_velocity_ek_+3A_delta_t">delta_t</code></td>
<td>
<p>Duration of a single frame (1 / sampling rate).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Velocity vector
</p>

<hr>
<h2 id='diff_ek'>Differentiate x and y and compute change amplitude via an algorithm proposed by Engbert &amp; Kliegl (2003)</h2><span id='topic+diff_ek'></span>

<h3>Description</h3>

<p>Differentiate x and y and compute change amplitude via an algorithm proposed by Engbert &amp; Kliegl (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_ek(x, y, trial, sample_rate, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_ek_+3A_x">x</code></td>
<td>
<p>vector with x coordinates in <em>degrees of visual angle</em></p>
</td></tr>
<tr><td><code id="diff_ek_+3A_y">y</code></td>
<td>
<p>vector with y coordinates in <em>degrees of visual angle</em></p>
</td></tr>
<tr><td><code id="diff_ek_+3A_trial">trial</code></td>
<td>
<p>vector with trial index</p>
</td></tr>
<tr><td><code id="diff_ek_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate in Hz</p>
</td></tr>
<tr><td><code id="diff_ek_+3A_options">options</code></td>
<td>
<p>List with method specific options, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method options, please refer to Engbert &amp; Kliegl (2003) for details on parameters and the rationale for default values.
</p>

<ul>
<li><p><code>ek_velocity_time_window</code> Time window for velocity computation in milliseconds. Defaults to <code>20</code> ms.
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> with columns <code>x</code>, <code>y</code>, and <code>amp</code>
</p>


<h3>See Also</h3>

<p>compute_velocity_ek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff_ek(rnorm(1000), rnorm(1000), rep(1, 1000), 250, list("ek_velocity_time_window" = 20))
</code></pre>

<hr>
<h2 id='diff_nh'>Differentiate x and y and compute change amplitude via an algorithm proposed by Nyström and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a></h2><span id='topic+diff_nh'></span>

<h3>Description</h3>

<p>Differentiate x and y and compute change amplitude via an algorithm proposed by Nyström 
and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a>. Note that both components and the amplitude are smoothed
<em>independently</em> via a Savitzky-Golay filter, so the components may not (probably won't) add up to
the amplitude. Note that filtering is sensitive to the presence of <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_nh(x, y, trial, sample_rate, options = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_nh_+3A_x">x</code></td>
<td>
<p>vector with x coordinates in <em>degrees of visual angle</em></p>
</td></tr>
<tr><td><code id="diff_nh_+3A_y">y</code></td>
<td>
<p>vector with y coordinates in <em>degrees of visual angle</em></p>
</td></tr>
<tr><td><code id="diff_nh_+3A_trial">trial</code></td>
<td>
<p>vector with trial index</p>
</td></tr>
<tr><td><code id="diff_nh_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate in Hz</p>
</td></tr>
<tr><td><code id="diff_nh_+3A_options">options</code></td>
<td>
<p>List with method specific options, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method options, please refer to Nyström and Holmqvist (2010) for details on parameters and the rationale for default values.
</p>

<ul>
<li><p><code>nh_sg_filter_order</code> Order of Savitzky-Golay filter. Defaults to <code>2</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> with columns <code>x</code>, <code>y</code>, and <code>amp</code>
</p>


<h3>See Also</h3>

<p>filter_via_savitzky_golay
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff_nh(rnorm(1000), rnorm(1000), rep(1, 1000), 250, list("nh_sg_filter_order" = 2))
</code></pre>

<hr>
<h2 id='extract_saccades'>Extract saccades from samples using votes from selected methods.</h2><span id='topic+extract_saccades'></span>

<h3>Description</h3>

<p>Extract saccades from samples using votes from selected methods. Each method votes whether
a given sample belongs to a saccade. Next, saccades are identified via a majority vote using the 
<code>vote_threshold</code> parameter, as well as a minimum duration and minimal temporal separation criteria.
Please note that units of the gaze samples must be in  <strong>degrees of visual angle</strong>. The units are important
as some methods use specific (e.g., physiologically plausible) velocity and acceleration thresholds.
</p>
<p>By default, ensemble includes methods proposed by Engbert &amp; Kliegl (2003) (<code>"ek"</code>),
Otero-Millan et al. (<code>"om"</code>), and Nyström &amp; Holmqvist (2010) (<code>"nh"</code>), 
see <em>Implemented Methods</em> vignette. However, it can be extended
via custom methods, see <em>Using Custom Methods</em> vignette.
</p>
<p>By default, the function returns a table with identified saccades but can return a matrix with methods' votes
per sample instead (<code>return_votes = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_saccades(
  x,
  y,
  sample_rate,
  trial = NULL,
  methods = list(method_ek, method_om, method_nh),
  velocity_function = saccadr::diff_ek,
  options = NULL,
  binocular = "merge",
  vote_threshold = ifelse(length(methods) == 1, 1, (length(methods) - 1)),
  minimal_duration_ms = 12,
  minimal_separation_ms = 12,
  return_votes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_saccades_+3A_x">x</code></td>
<td>
<p>Horizontal coordinate, either a vector for monocular data or a two-column matrix for binocular data.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_y">y</code></td>
<td>
<p>Vertical coordinate, either a vector for monocular data or a two-column matrix for binocular data.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Sampling rate in Hz. It is assumed to be common for the entire time series.
If the time series contains chunks (trials) that were recorded using different acquisition rate
(e.g., SR Research Eyelink allows to set different acquisition rate for each recording / trial),
you would need to split the time series and analyze them separately.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_trial">trial</code></td>
<td>
<p>Optional vector with trial ID. If omitted, all samples are assumed to belong to a single trial.
Velocity, acceleration, and saccades themselves are computed respecting trial borders.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_methods">methods</code></td>
<td>
<p>A list with saccade detection methods, can include external functions that
implement sample classification (see <em>Using Custom Methods</em> vignette). Package methods include
Engbert &amp; Kliegl (2003) (<code>method_ek</code>), Otero-Millan et al. (2014) (<code>method_om</code>), 
Nyström and Holmqvist (2010) (<code>method_nh</code>). Defaults to the list of all internally implemented
methods: <code>list(method_ek, method_om, method_nh)</code>.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_velocity_function">velocity_function</code></td>
<td>
<p>A handle to a function to compute velocity and acceleration. Defaults to a method
suggested by Engbert &amp; Kliegl (2003) <code><a href="#topic+diff_ek">diff_ek</a></code>. The package also implements the method proposed
by Nyström and Holmqvist (2010) <code><a href="#topic+diff_nh">diff_nh</a></code>. See vignette &quot;Velocity computation&quot; for details and
information on how to implement a custom method.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_options">options</code></td>
<td>
<p>A named list with options for saccade detection (see <code><a href="#topic+method_ek">method_ek</a></code>, <code><a href="#topic+method_om">method_om</a></code>,
<code><a href="#topic+method_nh">method_nh</a></code>) and velocity (<code><a href="#topic+diff_ek">diff_ek</a></code>, <code><a href="#topic+diff_nh">diff_nh</a></code>) computation.
See documentation on specific method for details.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_binocular">binocular</code></td>
<td>
<p>Specifies how a binocular data is treated. Options are <code>"cyclopean"</code> (binocular data is
converted to an average cyclopean image before saccades are extracted), <code>"monocular"</code> (saccades
are extracted independently for each eye), <code>"merge"</code> (default, sample votes are obtained from both eyes and
for all methods and then averaged. This way only binocular saccades, i.e., eye movements with a sufficient temporal
overlap between eyes, are detected.).</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_vote_threshold">vote_threshold</code></td>
<td>
<p>Value between 1 and N (where N is number of used methods) defining a vote threshold for a
saccade. By default, all but one method <code class="reqn">threshold = N-1</code> must agree for a sample to be considered for a saccade.
Threshold of 1 is applied if a single method is used.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_minimal_duration_ms">minimal_duration_ms</code></td>
<td>
<p>Minimal duration of a saccade in milliseconds. Shorter candidate saccades are discarded,</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_minimal_separation_ms">minimal_separation_ms</code></td>
<td>
<p>Minimal time separation between saccades in milliseconds. Saccades that are
separated by a shorter interval of &quot;not a saccade&quot; votes, will be merged including that period.</p>
</td></tr>
<tr><td><code id="extract_saccades_+3A_return_votes">return_votes</code></td>
<td>
<p>Logical. Whether function should return extracted microsaccades (<code>FALSE</code>, default)
or votes per sample (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables that describe saccade
</p>

<ul>
<li><p><code>Trial</code> Trial index.
</p>
</li>
<li><p><code>Eye</code> <code>"Monocular"</code> for monocular inputs. <code>"Cyclopean"</code> for binocular data that
was averaged <em>before</em> applying algorithms. <code>"Binocular"</code> for binocular data with votes
averaged <em>after</em> applying algorithms. <code>"Left"</code> or <code>"Right"</code> for binocular data
when eyes are processed independently.
</p>
</li>
<li><p><code>OnsetSample</code> Index of the first sample.
</p>
</li>
<li><p><code>OffsetSample</code> Index of the last sample.
</p>
</li>
<li><p><code>Onset</code> Onset time relative to the trial start in milliseconds.
</p>
</li>
<li><p><code>Offset</code> Offset time relative to the trial start in milliseconds.
</p>
</li>
<li><p><code>Duration</code> Duration in milliseconds.
</p>
</li>
<li><p><code>DisplacementX</code> Horizontal displacement measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li><p><code>DisplacementY</code> Vertical displacement measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li><p><code>Displacement</code> Displacement magnitude measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li><p><code>DisplacementPhi</code> Displacement direction measured from the <em>first</em> to the <em>last</em> sample.
</p>
</li>
<li><p><code>AmplitudeX</code> Horizontal displacement measured from the <em>leftmost</em> to the <em>rightmost</em> sample.
</p>
</li>
<li><p><code>AmplitudeY</code> Vertical displacement measured from the <em>lowest</em> to the <em>uppermost</em> sample.
</p>
</li>
<li><p><code>Amplitude</code> Displacement magnitude measured from the most extreme samples.
</p>
</li>
<li><p><code>AmplitudePhi</code> Displacement direction measured from the most extreme samples.
</p>
</li>
<li><p><code>VelocityPeak</code> Peak velocity.
</p>
</li>
<li><p><code>VelocityAvg</code> Average velocity.
</p>
</li>
<li><p><code>AccelerationPeak</code> Peak acceleration.
</p>
</li>
<li><p><code>AccelerationAvg</code> Average acceleration.
</p>
</li>
<li><p><code>AccelerationStart</code> Peak acceleration <em>before</em> peak velocity was reached.
</p>
</li>
<li><p><code>AccelerationStop</code> Peak acceleration <em>after</em> peak velocity was reached.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with saccade properties (see <strong>details</strong>), if <code>return_votes = FALSE</code>.
Alternatively, it returns votes per sample (<code>return_votes = TRUE</code>). For a monocular processing (monocular
input, cyclopean or merged binocular data) it is a matrix with <code>nrow(x)</code> rows and <code>length(methods)</code>
columns with 0/1 votes for each sample and method. For binocular processing, function returns a two element <code>list</code> with
the similar matrices but per eye.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+method_ek">method_ek</a></code>, <code><a href="#topic+method_om">method_om</a></code>, <code><a href="#topic+method_nh">method_nh</a></code>, <code><a href="#topic+diff_ek">diff_ek</a></code>, <code><a href="#topic+diff_nh">diff_nh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single trial
data(single_trial)
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500)

# Multiple trials
data(monocular_ten_trials)
saccades &lt;- extract_saccades(monocular_ten_trials$x,
                             monocular_ten_trials$y, 
                             500,
                             trial = monocular_ten_trials$trial)
 
 # binocular saccades                            
 data("single_trial_binocular")
 saccades_b &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                         single_trial_binocular[, c('yL', 'yR')],
                                         sample_rate = 1000)
                                         
 # cyclopean saccades from binocular data
saccades_c &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                        single_trial_binocular[, c('yL', 'yR')],
                                        sample_rate = 1000,
                                        binocular = "cyclopean")

 # monocular saccades from binocular data
saccades_m &lt;- saccadr::extract_saccades(single_trial_binocular[, c('xL', 'xR')],
                                       single_trial_binocular[, c('yL', 'yR')],
                                       sample_rate = 1000,
                                       binocular = "monocular")
                             
# Using a single method
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, methods = method_om)

# Using two methods
saccades &lt;- extract_saccades(single_trial$x,
                             single_trial$y,
                             500,
                             methods = list(method_ek, method_om))

#  Alternative velocity computation method
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, velocity_function = diff_nh)

# A strict unanimous decision threshold
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, vote_threshold = 3)

# A slacker criterion that at least one of the three methods must label sample as a saccade
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, vote_threshold = 1)

# Only longish saccades are extracted
saccades &lt;- extract_saccades(single_trial$x, single_trial$y, 500, minimal_duration_ms = 20)
</code></pre>

<hr>
<h2 id='filter_via_savitzky_golay'>Smooths signal using Savitzky-Golay and then shifts the filtered signal back</h2><span id='topic+filter_via_savitzky_golay'></span>

<h3>Description</h3>

<p>Smooths signal using Savitzky-Golay and then shifts the filtered signal back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_via_savitzky_golay(x, sg_order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_via_savitzky_golay_+3A_x">x</code></td>
<td>
<p>vector of float</p>
</td></tr>
<tr><td><code id="filter_via_savitzky_golay_+3A_sg_order">sg_order</code></td>
<td>
<p>integer, order of the filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of float
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filter_via_savitzky_golay(rnorm(1000), 2)
</code></pre>

<hr>
<h2 id='input_to_matrix'>Converts inputs to matrix</h2><span id='topic+input_to_matrix'></span>

<h3>Description</h3>

<p>Converts inputs (vector, matrix, data.frame/tibble) to 
a matrix preserving number of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_to_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="input_to_matrix_+3A_x">x</code></td>
<td>
<p>vector, matrix, data.frame/tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_to_matrix(1:5)
</code></pre>

<hr>
<h2 id='method_ek'>Extract saccades using an algorithm proposed by Engbert and Kliegl (2003) <a href="https://doi.org/10.1016/S0042-6989%2803%2900084-1">doi:10.1016/S0042-6989(03)00084-1</a></h2><span id='topic+method_ek'></span>

<h3>Description</h3>

<p>Extract saccades using an algorithm proposed by Engbert and Kliegl (2003) <a href="https://doi.org/10.1016/S0042-6989%2803%2900084-1">doi:10.1016/S0042-6989(03)00084-1</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_ek(x, y, vel, acc, sample_rate, trial, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_ek_+3A_x">x</code></td>
<td>
<p>Gaze x coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_y">y</code></td>
<td>
<p>Gaze x coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_vel">vel</code></td>
<td>
<p>Velocity <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_acc">acc</code></td>
<td>
<p>Acceleration <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Sample rate in Hz.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_trial">trial</code></td>
<td>
<p>Trial id, so that trial borders are respected when computing velocity and saccades.</p>
</td></tr>
<tr><td><code id="method_ek_+3A_options">options</code></td>
<td>
<p>Named list with method options. See <em>details</em> for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method options, please refer to Engbert and Kliegl (2003) for details on parameters and the rationale for default values.
</p>

<ul>
<li><p><code>ek_velocity_threshold</code> Velocity threshold for saccade detection in standard deviations. Defaults to <code>6</code>.
</p>
</li>
<li><p><code>ek_sd_fun</code> Function used to compute standard deviation for velocities. Defaults to <code><a href="#topic+sd_via_median_estimator">sd_via_median_estimator</a></code>, as per formula #2 in Engbert and Kliegl (2003). Can be replaced with <code>mad</code>, <code>sd</code>, etc.
</p>
</li>
<li><p><code>ek_minimal_duration_ms</code> Minimal duration of a saccade in milliseconds. Defaults to <code>12</code>.
</p>
</li>
<li><p><code>ek_minimal_separation_ms</code> A minimal required time gap between saccades. Defaults to <code>12</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>logical vector marking samples that belong to saccades
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_saccades">extract_saccades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do not run this function directly, use extract_saccades() instead
</code></pre>

<hr>
<h2 id='method_nh'>Extract saccades using an algorithm proposed by Nyström and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a>.</h2><span id='topic+method_nh'></span>

<h3>Description</h3>

<p>Extract saccades using an algorithm proposed by Nyström and Holmqvist (2010) <a href="https://doi.org/10.3758/BRM.42.1.188">doi:10.3758/BRM.42.1.188</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_nh(x, y, vel, acc, sample_rate, trial, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_nh_+3A_x">x</code></td>
<td>
<p>Gaze x coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_y">y</code></td>
<td>
<p>Gaze y coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_vel">vel</code></td>
<td>
<p>Velocity <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_acc">acc</code></td>
<td>
<p>Acceleration <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Sample rate in Hz.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_trial">trial</code></td>
<td>
<p>Trial id, so that trial borders are respected when computing velocity and saccades.</p>
</td></tr>
<tr><td><code id="method_nh_+3A_options">options</code></td>
<td>
<p>Named list with method options. See <em>details</em> for  further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method options, please refer to Nyström and Holmqvist (2010) for details on parameters and the rationale for default values.
</p>

<ul>
<li><p><code>nh_sg_filter_order</code> Order of Savitzky-Golay filter. Defaults to <code>2</code>.
</p>
</li>
<li><p><code>nh_max_velocity</code> Maximal physiologically plausible velocity in °/s. Defaults to <code>1000</code>.
</p>
</li>
<li><p><code>nh_max_acceleration</code> Maximal physiologically plausible acceleration in °/s². Defaults to <code>100000</code>.
</p>
</li>
<li><p><code>nh_initial_velocity_threshold</code> Initial velocity threshold in °/s. Defaults to <code>100</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>logical vector marking samples that belong to saccades
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_saccades">extract_saccades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do not run this function directly, use extract_saccades() instead
</code></pre>

<hr>
<h2 id='method_om'>Extract saccades using an algorithm proposed by Otero-Millan et al. (2014) <a href="https://doi.org/10.1167/14.2.18">doi:10.1167/14.2.18</a></h2><span id='topic+method_om'></span>

<h3>Description</h3>

<p>Extract saccades using an algorithm proposed by Otero-Millan et al. (2014) <a href="https://doi.org/10.1167/14.2.18">doi:10.1167/14.2.18</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_om(x, y, vel, acc, sample_rate, trial, options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_om_+3A_x">x</code></td>
<td>
<p>Gaze x coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_om_+3A_y">y</code></td>
<td>
<p>Gaze x coordinate, _arbitrary units_ as threshold velocity is computed in units of standard deviation.</p>
</td></tr>
<tr><td><code id="method_om_+3A_vel">vel</code></td>
<td>
<p>Velocity <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_om_+3A_acc">acc</code></td>
<td>
<p>Acceleration <code>data.frame</code> with columns <code>x</code>, <code>y</code>, <code>amp</code>.</p>
</td></tr>
<tr><td><code id="method_om_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Sample rate in Hz.</p>
</td></tr>
<tr><td><code id="method_om_+3A_trial">trial</code></td>
<td>
<p>Trial id, so that trial borders are respected when computing velocity and saccades.</p>
</td></tr>
<tr><td><code id="method_om_+3A_options">options</code></td>
<td>
<p>Named list with method options. See <em>details</em> for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method options, please refer to Otero-Millan et al. (2014) for details on parameters and the rationale for default values.
</p>

<ul>
<li><p><code>om_minimal_inter_peak_time_ms</code> Minimal inter-peak interval in milliseconds. Defaults to <code>30</code>.
</p>
</li>
<li><p><code>om_maximal_peaks_per_second</code> Maximal allowed number of peaks per second. Defaults to <code>5</code>.
</p>
</li>
<li><p><code>om_velocity_threshold_deg_per_sec</code> Threshold saccade velocity in °/s.  Defaults to <code>3</code>.
</p>
</li>
<li><p><code>om_pca_variance_threshold</code> Minimal variance explained by retained rotated components. Defaults to <code>0.05</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>logical vector marking samples that belong to saccades
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_saccades">extract_saccades</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Do not run this function directly, use extract_saccades() instead
</code></pre>

<hr>
<h2 id='monocular_ten_trials'>A monocular multi-trial recording</h2><span id='topic+monocular_ten_trials'></span>

<h3>Description</h3>

<p>A monocular recording, 10 trials, sampling rate 500 Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monocular_ten_trials
</code></pre>


<h3>Format</h3>

<p>A data frame with 14353 rows and 4 variables:
</p>

<dl>
<dt>trial</dt><dd><p>Trial index.</p>
</dd>
<dt>x</dt><dd><p>X coordinate in degrees of visual angle.</p>
</dd>
<dt>y</dt><dd><p>Y coordinate in degrees of visual angle.</p>
</dd>
<dt>time</dt><dd><p>Sample time in milliseconds.</p>
</dd>
</dl>


<hr>
<h2 id='option_or_default'>Extract value for a named list or use default if key is missing</h2><span id='topic+option_or_default'></span>

<h3>Description</h3>

<p>Extract value for a named list or use default if key is missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>option_or_default(options, key, default)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="option_or_default_+3A_options">options</code></td>
<td>
<p>Named list</p>
</td></tr>
<tr><td><code id="option_or_default_+3A_key">key</code></td>
<td>
<p>String key</p>
</td></tr>
<tr><td><code id="option_or_default_+3A_default">default</code></td>
<td>
<p>Default value to be returned, if key is missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value from a list or default value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>option_or_default(list("A" = 25), "A", 20)
option_or_default(list("A" = 25), "B", 20)
</code></pre>

<hr>
<h2 id='sd_via_median_estimator'>Compute standard deviation via median estimator.</h2><span id='topic+sd_via_median_estimator'></span>

<h3>Description</h3>

<p>Compute standard deviation via median estimator.
Please refer to formula #2 in Engbert &amp; Kliegl (2003).
Falls back on mean estimator, if computed standard deviation
is smaller than <code>.Machine$double.eps</code>. Raises an error
if the results using the mean estimator is still smaller than
<code>.Machine$double.eps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_via_median_estimator(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd_via_median_estimator_+3A_x">x</code></td>
<td>
<p>Numeric values</p>
</td></tr>
<tr><td><code id="sd_via_median_estimator_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to exclude NA values, defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>float
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sd_via_median_estimator(rnorm(100))
</code></pre>

<hr>
<h2 id='single_trial'>A single trial monocular samples recorded at 500 Hz.</h2><span id='topic+single_trial'></span>

<h3>Description</h3>

<p>A single trial monocular samples recorded at 500 Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_trial
</code></pre>


<h3>Format</h3>

<p>A data frame with 1006 rows and 2 variables:
</p>

<dl>
<dt>x</dt><dd><p>X coordinate in degrees of visual angle.</p>
</dd>
<dt>y</dt><dd><p>Y coordinate in degrees of visual angle.</p>
</dd>
</dl>


<hr>
<h2 id='single_trial_binocular'>A single trial binocular recording.</h2><span id='topic+single_trial_binocular'></span>

<h3>Description</h3>

<p>A single trial binocular recording sampled at 1000 Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_trial_binocular
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 6 variables:
</p>

<dl>
<dt>trial</dt><dd><p>Trial index.</p>
</dd>
<dt>time_rel</dt><dd><p>Sample time in milliseconds relative to the trial start.</p>
</dd>
<dt>xL</dt><dd><p>X coordinate for the left eye in degrees of visual angle.</p>
</dd>
<dt>xR</dt><dd><p>X coordinate for the right eye in degrees of visual angle.</p>
</dd>
<dt>yL</dt><dd><p>Y coordinate for the left eye in degrees of visual angle.</p>
</dd>
<dt>yR</dt><dd><p>Y coordinate for the right eye in degrees of visual angle.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
