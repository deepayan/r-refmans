<!DOCTYPE html><html lang="en"><head><title>Help for package rsolr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsolr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Context-class'><p>Evaluation Contexts</p></a></li>
<li><a href='#DocCollection-class'><p>DocCollection</p></a></li>
<li><a href='#DocDataFrame-class'><p>DocDataFrame</p></a></li>
<li><a href='#DocList-class'><p>DocList</p></a></li>
<li><a href='#Expression-class'><p>Expressions and Translation</p></a></li>
<li><a href='#Facets-class'><p>Facets</p></a></li>
<li><a href='#FieldInfo-class'><p>FieldInfo</p></a></li>
<li><a href='#FieldType-class'><p>FieldType</p></a></li>
<li><a href='#GroupedSolrFrame-class'><p>GroupedSolrFrame</p></a></li>
<li><a href='#Grouping-class'><p>Grouping</p></a></li>
<li><a href='#ListSolrResult-class'><p>ListSolrResult</p></a></li>
<li><a href='#Promise-class'><p>Promises</p></a></li>
<li><a href='#SolrCore-class'><p>SolrCore</p></a></li>
<li><a href='#SolrExpression-class'><p>SolrExpression</p></a></li>
<li><a href='#SolrFrame-class'><p>SolrFrame</p></a></li>
<li><a href='#SolrList-class'><p>SolrList</p></a></li>
<li><a href='#SolrPromise-class'><p>SolrPromise</p></a></li>
<li><a href='#SolrQuery-class'><p>SolrQuery</p></a></li>
<li><a href='#SolrSchema-class'><p>SolrSchema</p></a></li>
<li><a href='#TestSolr'><p>Testing Solr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R to Solr Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.13</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Lawrence, Gabe Becker, Jan Vogel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Lawrence &lt;michafla@gene.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive R API for querying Apache Solr databases.
             A Solr core is represented as a data frame or list that
             supports Solr-side filtering, sorting,
             transformation and aggregation, all through the familiar
             base R API. Queries are processed
             lazily, i.e., a query is only sent to the database when
             the data are required. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>restfulr (&ge; 0.0.2), graph, S4Vectors (&ge; 0.14.3), rjson, XML,
RCurl</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), BiocGenerics (&ge; 0.15.1), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nycflights13, RUnit, MASS, knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>utils.R pminmax.R Context-class.R DocCollection-class.R
Expression-class.R Facets-class.R FieldInfo-class.R
FieldType-class.R Promise-class.R SolrExpression-class.R
SolrQuery-class.R SolrSchema-class.R SolrCore-class.R
SolrResult-class.R SolrSummary-class.R Solr-class.R
SolrList-class.R SolrFrame-class.R SolrPromise-class.R
GroupedSolrFrame-class.R test.R zzz.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-17 23:32:52 UTC; michafla</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-18 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Context-class'>Evaluation Contexts</h2><span id='topic+class+3AContext'></span><span id='topic+Context-class'></span><span id='topic+symbolFactory'></span><span id='topic+symbolFactory+2CDelegateContext-method'></span><span id='topic+symbolFactory+3C-'></span><span id='topic+symbolFactory+3C-+2CDelegateContext-method'></span>

<h3>Description</h3>

<p>The <code>Context</code> class is for representing contexts in which
expressions are evaluated. This might be an R environment, a database,
or some other external system.
</p>


<h3>Translation</h3>

<p>Contexts play an important role in translation. When extracting an
object by name, the context can delegate to a
<code><a href="#topic+SymbolFactory-class">SymbolFactory</a></code> to create a
<code><a href="#topic+Symbol-class">Symbol</a></code> object that is a lazy reference to the
object. The reference is expressed in the target language. If there is
no <code>SymbolFactory</code>, i.e., it has been set to <code>NULL</code>, then
evaluation is eager.
</p>
<p>The intent is to decouple the type of the context from a particular
language, since a context could support the evaluation of multiple
languages. The accessors below effectively allow one to specify the
desired target language.
</p>

<ul>
<li>
<p><code>symbolFactory(x)</code>, <code>symbolFactory(x) &lt;- value</code>: Get or
set the current <code>SymbolFactory</code> (may be NULL).

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='DocCollection-class'>DocCollection</h2><span id='topic+class+3ADocCollection'></span><span id='topic+DocCollection-class'></span><span id='topic++5B+2CDocCollection-method'></span><span id='topic+fieldNames+2CDocCollection-method'></span><span id='topic+ids'></span><span id='topic+ids+2CDocCollection-method'></span><span id='topic+ids+3C-'></span><span id='topic+ids+3C-+2CDocCollection-method'></span><span id='topic+meta'></span><span id='topic+meta+2CANY-method'></span><span id='topic+unmeta'></span><span id='topic+ndoc'></span><span id='topic+ndoc+2CDocCollection-method'></span><span id='topic+nfield'></span><span id='topic+docs+2CDocCollection-method'></span><span id='topic+nfield+2CANY-method'></span><span id='topic+show+2CDocCollection-method'></span>

<h3>Description</h3>

<p><code>DocCollection</code> is a virtual class for all representations of
document collections. It is made concrete by
<code><a href="#topic+DocList-class">DocList</a></code> and
<code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code>. This is mostly to achieve an
abstraction around tabular and list representations of documents.
</p>


<h3>Accessors</h3>

<p>These are the accessors that should apply equivalently to any
derivative of <code>DocCollection</code>, which provides reasonable default
implementations for most of them.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents

</p>
</li>
<li>
<p><code>nfield(x)</code>: Gets the number of fields

</p>
</li>
<li>
<p><code>ids(x), ids(x) &lt;- value</code>: Gets or sets the document unique
identifiers (may be <code>NULL</code>)

</p>
</li>
<li>
<p><code>fieldNames(x, includeStatic=TRUE, ...)</code>: Gets the field names

</p>
</li>
<li>
<p><code>docs(x)</code>: Just returns <code>x</code>, as <code>x</code> already
represents a set of documents

</p>
</li>
<li>
<p><code>meta(x)</code>: Gets an auxillary collection of &ldquo;meta&rdquo;
fields that hold fields that describe, rather than compose, the
documents. This feature should be considered unstable. Stay away
for now.

</p>
</li>
<li>
<p><code>unmeta(x)</code>: Clears the metadata.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+DocList-class">DocList</a></code> and <code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code> for
concrete implementations
</p>

<hr>
<h2 id='DocDataFrame-class'>DocDataFrame</h2><span id='topic+class+3ADocDataFrame'></span><span id='topic+DocDataFrame-class'></span><span id='topic++5B+2CDocDataFrame-method'></span><span id='topic+fieldNames+2CDocDataFrame-method'></span><span id='topic+ids+3C-+2CDocDataFrame-method'></span><span id='topic+show+2CDocDataFrame-method'></span>

<h3>Description</h3>

<p>The <code>DocDataFrame</code> object wraps a <code>data.frame</code> in a
document-oriented interface that is shared with
<code><a href="#topic+DocList-class">DocList</a></code>. This is mostly to achieve an abstraction
around tabular and list representations of
documents. <code>DocDataFrame</code> should behave just like a
<code>data.frame</code>, except it adds the accessors described below.
</p>


<h3>Accessors</h3>

<p>These are some accessors that <code>DocDataFrame</code> adds on top of the
basic data frame accessors. Using these accessors allows code to be
agnostic to whether the data are stored as a list or data.frame.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents (rows)

</p>
</li>
<li>
<p><code>nfield(x)</code>: Gets the number of fields (columns)

</p>
</li>
<li>
<p><code>ids(x), ids(x) &lt;- value</code>: Gets or sets the document unique
identifiers (may be <code>NULL</code>, treated as rownames)

</p>
</li>
<li>
<p><code>fieldNames(x, includeStatic=TRUE, ...)</code>: Gets the field
(column) names

</p>
</li>
<li>
<p><code>docs(x)</code>: Just returns <code>x</code>, as <code>x</code> already
represents a set of documents

</p>
</li>
<li>
<p><code>meta(x)</code>: Gets an auxillary data.frame of &ldquo;meta&rdquo;
columns that hold fields that describe, rather than compose, the
documents. This feature should be considered unstable. Stay away
for now.

</p>
</li>
<li>
<p><code>unmeta(x)</code>: Clears the metadata.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+DocList-class">DocList</a></code> for representing a document collection as
a list instead of a table
</p>

<hr>
<h2 id='DocList-class'>DocList</h2><span id='topic+class+3ADocList'></span><span id='topic+DocList-class'></span><span id='topic++5B+2CDocList-method'></span><span id='topic++5B+3C-+2CDocList+2CANY+2CANY+2CANY-method'></span><span id='topic+fieldNames+2CDocList-method'></span><span id='topic+ids+3C-+2CDocList-method'></span><span id='topic+names+3C-+2CDocList+2CANY-method'></span><span id='topic+meta+2CDocList-method'></span><span id='topic+nfield+2CDocList-method'></span><span id='topic+as.data.frame+2CDocList-method'></span><span id='topic+show+2CDocList-method'></span>

<h3>Description</h3>

<p>The <code>DocList</code> object wraps a <code>list</code> in a document-oriented
interface that is shared with <code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code>. This
is mostly to achieve an abstraction around tabular and list
representations of documents. <code>DocList</code> should behave just like a
<code>list</code>, except it adds the accessors described below.
</p>


<h3>Accessors</h3>

<p>These are some accessors that <code>DocList</code> adds on top of the
basic list accessors. Using these accessors allows code to be
agnostic to whether the data are stored as a list or data.frame.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents (elements)

</p>
</li>
<li>
<p><code>nfield(x)</code>: Gets the number of unique field names over all
of the documents

</p>
</li>
<li>
<p><code>ids(x), ids(x) &lt;- value</code>: Gets or sets the document unique
identifiers (may be <code>NULL</code>, treated as names)

</p>
</li>
<li>
<p><code>fieldNames(x, includeStatic=TRUE, ...)</code>: Gets the set of
unique field names

</p>
</li>
<li>
<p><code>meta(x)</code>: Gets an auxillary list of &ldquo;meta&rdquo; documents
(lists) that hold fields that describe, rather than compose, the
actual documents. This feature should be considered unstable. Stay
away for now.

</p>
</li>
<li>
<p><code>unmeta(x)</code>: Clears the metadata.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code> for representing a document collection as
a table instead of a list
</p>

<hr>
<h2 id='Expression-class'>Expressions and Translation</h2><span id='topic+class+3AExpression'></span><span id='topic+Expression-class'></span><span id='topic+class+3ASimpleExpression'></span><span id='topic+SimpleExpression-class'></span><span id='topic+class+3ASimpleSymbol'></span><span id='topic+SimpleSymbol-class'></span><span id='topic+class+3ASymbol'></span><span id='topic+Symbol-class'></span><span id='topic+class+3ASymbolFactory'></span><span id='topic+SymbolFactory-class'></span><span id='topic+class+3ATranslationRequest'></span><span id='topic+TranslationRequest-class'></span><span id='topic+translate+2CANY+2CExpression-method'></span><span id='topic+translate+2CTranslationRequest+2Cmissing-method'></span><span id='topic+eval+2CANY+2CDelegateContext-method'></span><span id='topic+translate'></span><span id='topic+SymbolFactory'></span><span id='topic+as.character+2CTranslationRequest-method'></span>

<h3>Description</h3>

<p>Underlying rsolr is a simple, general framework for representing,
manipulating and translating between expressions in arbitrary
languages. The two foundational classes are <code>Expression</code> and
<code>Symbol</code>, which are partially implemented by
<code>SimpleExpression</code> and <code>SimpleSymbol</code>, respectively.
</p>


<h3>Translation</h3>

<p>The <code>Expression</code> framework defines a translation strategy based
on evaluating source language expressions, using promises to represent
the objects, such that the result is a promise with its deferred
computation expressed in the target language.
</p>
<p>The primary entry point is the <code>translate</code> generic, which has a
default method that abstractly implements this strategy.  The first
step is to obtain a <code>SymbolFactory</code> instance for the target
expression type via a method on the <code>SymbolFactory</code> generic. The
<code>SymbolFactory</code> (a simple R function) is set on the
<code>Context</code>, which should define (perhaps through inheritance) all
symbols referenced in the source expression. The translation happens
when the source expression is <code>eval</code>uated in the context.  The
context calls the factory to construct <code>Symbol</code> objects which are
passed, along with the context, to the <code>Promise</code> generic, which
wraps them in the appropriate type of promise. Typically, R is the
source language, and the <code>eval</code> method evaluates the R expression
on the promises. Each method for the specific type of promise will
construct a new promise with an expression that encodes the
computation, building on the existing expression. When evaluation is
finished, we simply extract the expression from the returned promise.
</p>

<ul>
<li>
<p><code>translate(x, target, context, ...)</code>: Translates the source
expression <code>x</code> to the <code>target</code> <code>Expression</code>, where
the symbols in the source expression are resolved in
<code>context</code>, which is usually an R environment or some sort of
database. The ... are passed to <code>symbolFactory</code>.

</p>
</li>
<li>
<p><code>symbolFactory(x)</code>: Gets the <code>SymbolFactory</code> object
that will construct the appropriate type of symbol for the target
expression <code>x</code>.

</p>
</li></ul>



<h3>Note on Laziness</h3>

<p>In general, translation requires access to the referenced data.  There
may be certain operations that cannot be deferred, so evaluation is
allowed to be eager, in the hope that the result can be embedded
directly into the larger expression. Or, at the very least, the
translation machinery needs to know whether the data actually exist,
and whether the data are typed or have other constraints.  Since the
data and schema are not always available when translation is
requested, such as when building a database query that will be sent to
by another module to an as-yet-unspecified endpoint, translation
itself must be deferred. The <code>TranslationRequest</code> class provides
a foundation for capturing translations and evaluating them later.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='Facets-class'>Facets</h2><span id='topic+class+3AFacets'></span><span id='topic+Facets-class'></span><span id='topic+stats'></span><span id='topic++5B+2CFacets-method'></span><span id='topic++5B+5B+2CFacets-method'></span><span id='topic++5B+5B+2CFacets+2Cformula-method'></span><span id='topic+as.table.Facets'></span><span id='topic+as.table+2CFacets-method'></span><span id='topic+show+2CFacets-method'></span>

<h3>Description</h3>

<p>The <code>Facets</code> object represents the result of a Solr facet
operation and is typically obtained by calling <code><a href="#topic+facets">facets</a></code> on
a <code>SolrCore</code>. Most users should just call
<code><a href="#topic+Solr-class">aggregate</a></code> or <code>xtabs</code> instead of
directly manipulating <code>Facets</code> objects.
</p>


<h3>Details</h3>

<p><code>Facets</code> extends <code>list</code> and each node adds a grouping factor
to the set defined by its ancestors. In other words, parent-child
relationships represent interactions between factors. For example,
<code>x$a$b</code> gets the node corresponding to the interaction of
<code>a</code> and <code>b</code>.
</p>
<p>In a single request to Solr, statistics may be calculated for multiple
interactions, and they are stored as a <code>data.frame</code> at the
corresponding node in the tree. To retrieve them, call the
<code>stats</code> accessor, e.g., <code>stats(x$a$b)</code>, or <code>as.table</code>
for getting the counts as a table (Solr always computes the counts).
</p>


<h3>Accessors</h3>


<ul>
<li>
<p><code>x$name</code>, <code>x[[i]]</code>: Get the node that further groups by
the named factor. The <code>i</code> argument can be a formula, where
<code>[[</code> will recursively extract the corresponding element.

</p>
</li>
<li>
<p><code>x[i]</code>: Extract a new <code>Facets</code> object, restricted to the
named groupings.

</p>
</li>
<li>
<p><code>stats(x)</code>: Gets the statistics at the current facet level.

</p>
</li></ul>



<h3>Coercion</h3>


<ul>
<li><p><code>as.table(x)</code>: Converts the current node to a
table of conditional counts.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+Solr-class">aggregate</a></code> for a simpler interface that
computes statistics for only a single interaction  
</p>

<hr>
<h2 id='FieldInfo-class'>FieldInfo</h2><span id='topic+class+3AFieldInfo'></span><span id='topic+FieldInfo-class'></span><span id='topic+dynamic'></span><span id='topic+multiValued'></span><span id='topic+typeName'></span><span id='topic+indexed'></span><span id='topic+stored'></span><span id='topic+required'></span><span id='topic+docValues'></span><span id='topic+length+2CFieldInfo-method'></span><span id='topic+names+2CFieldInfo-method'></span><span id='topic+names+3C-+2CFieldInfo+2CANY-method'></span><span id='topic++25in+25+2Ccharacter+2CFieldInfo-method'></span><span id='topic++5B+2CFieldInfo-method'></span><span id='topic++5B+3C-+2CFieldInfo+2CANY+2CANY+2CFieldInfo-method'></span><span id='topic+append+2CFieldInfo+2CFieldInfo-method'></span><span id='topic+as.data.frame.FieldInfo'></span><span id='topic+as.data.frame+2CFieldInfo-method'></span><span id='topic+coerce+2Cdata.frame+2CFieldInfo-method'></span><span id='topic+as.list.FieldInfo'></span><span id='topic+as.list+2CFieldInfo-method'></span><span id='topic+show+2CFieldInfo-method'></span>

<h3>Description</h3>

<p>The <code>FieldInfo</code> object is a vector of field entries from the Solr
schema. Typically, one retrieves an instance with <code><a href="#topic+fields">fields</a></code>
and shows it on the console to get an overview of the schema. The
vector-like nature means that functions like <code>[</code>  and
<code>length</code> behave as expected.
</p>


<h3>Accessors</h3>

<p>These functions get the &ldquo;columns&rdquo; from the field information
&ldquo;table&rdquo;:
</p>

<ul>
<li>
<p><code>name(x)</code>: Gets the name of the field.

</p>
</li>
<li>
<p><code>typeName(x)</code>: Gets the name of the field type, see
<code><a href="#topic+fieldTypes">fieldTypes</a></code>.

</p>
</li>
<li>
<p><code>dynamic(x)</code>: Gets whether the field is dynamic, i.e.,
whether its name is treated as a wildcard glob. If a document
field does not match a static field name, it takes its
properties from the first dynamic field (in schema order) that it
matches.

</p>
</li>
<li>
<p><code>multiValued(x)</code>: Gets whether the field accepts multiple
values. A multi-valued field is manifested in R as a list.

</p>
</li>
<li>
<p><code>required(x)</code>: Gets whether the field must have a value in
every document. A non-required field will sometimes have NAs. This
is useful for both ensuring data integrity and optimizations.

</p>
</li>
<li>
<p><code>indexed(x)</code>: Gets whether the field has been indexed. A
field must be indexed for us to filter by it. Faceting requires a
field to be indexed or have doc values.

</p>
</li>
<li>
<p><code>stored(x)</code>: Gets whether the data for a field have been
stored in the database. We can search on any (indexed) field, but
we can only retrieve data from stored fields.

</p>
</li>
<li>
<p><code>docValues(x)</code>: Gets whether the data have been additionally
stored in a columnar format that accelerates Solr function calls
(<code>transform</code>) and faceting (<code>aggregate</code>).

</p>
</li></ul>



<h3>Utilities</h3>


<ul>
<li>
<p><code>x %in% table</code>: Returns whether each field name in <code>x</code>
matches a field defined in <code>table</code>, a <code>FieldInfo</code>
object. This convenience is particularly needed when the schema
contains dynamic fields.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrSchema-class">SolrSchema</a></code> that holds an instance of this object
</p>

<hr>
<h2 id='FieldType-class'>FieldType</h2><span id='topic+class+3AFieldType'></span><span id='topic+FieldType-class'></span><span id='topic+class+3AFieldTypeList'></span><span id='topic+FieldTypeList-class'></span><span id='topic++5B+2CFieldTypeList-method'></span><span id='topic+names+3C-+2CFieldTypeList+2CANY-method'></span><span id='topic+as.data.frame+2CFieldTypeList-method'></span><span id='topic+show+2CFieldType-method'></span><span id='topic+show+2CFieldTypeList-method'></span>

<h3>Description</h3>

<p>The <code>FieldType</code> object represents the type of a document field. A
list of these objects is formally represented as <code>FieldTypeList</code>
object, an instance of which is provided by
<code><a href="#topic+SolrSchema-class">SolrSchema</a></code>. Internally, <code>FieldType</code> objects
are central to the conversion between <span class="rlang"><b>R</b></span> and Solr types. At the user
level, they are mostly useful for displaying the schema.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrSchema-class">SolrSchema</a></code>, which communicates information on
field types using these classes
</p>

<hr>
<h2 id='GroupedSolrFrame-class'>GroupedSolrFrame</h2><span id='topic+class+3AGroupedSolrFrame'></span><span id='topic+GroupedSolrFrame-class'></span><span id='topic+grouping'></span><span id='topic+grouping+2CGroupedSolrFrame-method'></span><span id='topic+ndoc+2CGroupedSolrFrame-method'></span><span id='topic+rownames+2CGroupedSolrFrame-method'></span><span id='topic+nrow+2CGroupedSolrFrame-method'></span><span id='topic++5B+3C-+2CGroupedSolrFrame+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGroupedSolrFrame-method'></span><span id='topic+ngroup'></span><span id='topic+ngroup+2CGroupedSolrFrame-method'></span><span id='topic+group+2CGroupedSolrFrame+2CANY-method'></span><span id='topic+ungroup'></span><span id='topic+ungroup+2CGroupedSolrFrame-method'></span><span id='topic+ungroup+2Cdata.frame-method'></span><span id='topic+ungroup+2CANY-method'></span><span id='topic+window+2CGroupedSolrFrame-method'></span><span id='topic+head+2CGroupedSolrFrame-method'></span><span id='topic+tail+2CGroupedSolrFrame-method'></span><span id='topic+windows'></span><span id='topic+windows+2CGroupedSolrFrame-method'></span><span id='topic+heads'></span><span id='topic+heads+2CANY-method'></span><span id='topic+tails'></span><span id='topic+tails+2CANY-method'></span><span id='topic+unique+2CGroupedSolrFrame-method'></span><span id='topic+as.data.frame+2CGroupedSolrFrame-method'></span><span id='topic+coerce+2CGroupedSolrFrame+2Cdata.frame-method'></span><span id='topic+show+2CGroupedSolrFrame-method'></span>

<h3>Description</h3>

<p>The <code>GroupedSolrFrame</code> is a <em>highly experimental</em> extension
of <code><a href="#topic+SolrFrame-class">SolrFrame</a></code> that models each column as a list,
formed by splitting the original vector by a common set of grouping
factors.
</p>


<h3>Details</h3>

<p>A <code>GroupedSolrFrame</code> should more or less behave analogously to a
data frame where every column is split by a common grouping. Unlike
<code>SolrFrame</code>, columns are <em>always</em> extracted lazily. Typical
usage is to construct a <code>GroupedSolrFrame</code> by calling
<code>group</code> on a <code>SolrFrame</code>, and then to extract columns (as
promises) and aggregate them (by e.g. calling <code>mean</code>).
</p>
<p>Functions that group the data, such as <code>group</code> and
<code>aggregate</code>, simply add to the existing grouping. To clear the
grouping, call <code>ungroup</code> or just coerce to a <code>SolrFrame</code> or
<code>SolrList</code>.
</p>


<h3>Accessors</h3>

<p>As <code>GroupedSolrFrame</code> inherits much of its functionality from
<code>SolrFrame</code>; here we only outline concerns specific to grouped
data.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents per group

</p>
</li>
<li>
<p><code>rownames(x)</code>: Forms unique group identifiers by
concatenating the grouping factor values.

</p>
</li>
<li>
<p><code>x[i, j] &lt;- value</code>: Inserts <code>value</code> into the Solr
core, where <code>value</code> is a data.frame of lists, or just a list
(representing a single column). Preferably, <code>i</code> is a promise,
because we need to the IDs of the selected documents in order to
perform the atomic update, and the promise lets us avoid
downloading <em>all</em> of the IDs. But otherwise, if <code>i</code> is
atomic, then it indexes into the groups. If <code>i</code> is a list,
then its names are matched to the group names, and its elements
index into the matching group. The list does not need to be named
if the elements are character vectors (and thus represent document
IDs).

</p>
</li>
<li>
<p><code>x[i, j, drop=FALSE]</code>: Extracts data from <code>x</code>, as usual,
but see the entry immediate above this one for the expectations of
<code>i</code>. Try to make it a promise, so that we do not need to
download IDs and then try to serialize them into a query, which
has length limitations.

</p>
</li></ul>



<h3>Extended API</h3>

<p>Most of the typical data frame accessors and data manipulation
functions will work analogously on <code>GroupedSolrFrame</code> (see
Details). Below, we list some of the non-standard methods that might
be seen as an extension of the data frame API.
</p>

<ul>
<li><p><code>heads(x, n)</code>, <code>tails(x, n)</code>, <code>windows(x,
      start, end)</code>: Perform <code>head</code>, <code>tail</code> or <code>window</code> on
each group separately, returning a data.frame with grouped (list)
columns.

</p>
</li>
<li><p><code>ngroup(x)</code>: The number of groups, i.e., the number of
rows.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='Grouping-class'>Grouping</h2><span id='topic+class+3AGrouping'></span><span id='topic+Grouping-class'></span><span id='topic+ngroup+2CGrouping-method'></span><span id='topic+schema+2CGrouping-method'></span><span id='topic+coerce+2CGrouping+2Clist-method'></span><span id='topic+coerce+2CGrouping+2Cdata.frame-method'></span><span id='topic+show+2CGrouping-method'></span>

<h3>Description</h3>

<p>The <code>Grouping</code> object represents a collection of documents split
by some interaction of factors. It is extremely low-level, and its
only use is to be coerced to something else, either a <code>list</code> or
<code>data.frame</code>, via <code>as</code>.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+ListSolrResult-class">ListSolrResult</a></code>, which provides this object via
its <code>groupings</code> method.
</p>

<hr>
<h2 id='ListSolrResult-class'>ListSolrResult</h2><span id='topic+class+3ASolrResult'></span><span id='topic+SolrResult-class'></span><span id='topic+class+3AListSolrResult'></span><span id='topic+ListSolrResult-class'></span><span id='topic+docs+2CListSolrResult-method'></span><span id='topic+ndoc+2CListSolrResult-method'></span><span id='topic+facets+2CListSolrResult-method'></span><span id='topic+ngroup+2CListSolrResult-method'></span><span id='topic+groupings+2CListSolrResult-method'></span>

<h3>Description</h3>

<p>The <code>SolrResult</code> object represents the result of a Solr query and
usually contains a collection of documents and/or facets. The default
implementation, <code>ListSolrResult</code>, directly stores the canonical
JSON response from Solr. It is usually obtained by
<code><a href="#topic+eval+2CSolrQuery+2CSolrCore-method">eval</a></code>uating a
<code>SolrQuery</code> on a <code>SolrCore</code>, which most users will never do.
</p>


<h3>Accessors</h3>

<p>Since <code>ListSolrResult</code> inherits from <code>list</code>, one can access
the raw JSON fields directly through the ordinary list accessors. One
should only directly manipulate the Solr response when extending
rsolr/Solr at a deep level. Higher-level accessors are described below.
</p>

<ul>
<li>
<p><code>docs(x)</code>: Returns the found documents as
a <code><a href="#topic+DocList-class">DocList</a></code>

</p>
</li>
<li>
<p><code>ndoc(x)</code>: Returns the number of documents found

</p>
</li>
<li>
<p><code>facets(x)</code>: Returns any computed <code><a href="#topic+Facets-class">Facets</a></code>

</p>
</li>
<li>
<p><code>groupings(x)</code>: If Solr was asked to group the documents in
the response, this returns each <code><a href="#topic+Grouping-class">Grouping</a></code>
(there can be more than one) in a list

</p>
</li>
<li>
<p><code>ngroup(x)</code>: Returns the number of groups in each grouping

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+docs+2CSolrCore-method">docs</a></code> and
<code><a href="#topic+facets+2CSolrCore-method">facets</a></code> on <code>SolrCore</code> are
more convenient and usually sufficient
</p>

<hr>
<h2 id='Promise-class'>Promises</h2><span id='topic+class+3APromise'></span><span id='topic+Promise-class'></span><span id='topic+class+3ASimplePromise'></span><span id='topic+SimplePromise-class'></span><span id='topic+as.character+2CPromise-method'></span><span id='topic+as.integer+2CPromise-method'></span><span id='topic+as.logical+2CPromise-method'></span><span id='topic+as.numeric+2CPromise-method'></span><span id='topic+fulfill'></span><span id='topic+fulfill+2CPromise-method'></span><span id='topic+fulfill+2CANY-method'></span><span id='topic+cbind2+2CANY+2CPromise-method'></span><span id='topic+cbind2+2CPromise+2CANY-method'></span><span id='topic+cbind2+2CPromise+2CPromise-method'></span><span id='topic+rbind2+2CANY+2CPromise-method'></span><span id='topic+rbind2+2CPromise+2CANY-method'></span><span id='topic+rbind2+2CPromise+2CPromise-method'></span><span id='topic+Promise'></span>

<h3>Description</h3>

<p>The <code>Promise</code> class formally and abstractly represents the
potential result of a deferred computation. 
</p>


<h3>Details</h3>

<p>Lazy programming is useful in a number of contexts, including
interaction with external/remote systems like databases, where we want
the computation to occur within the external system, despite
appearances to the contrary. Typically, the user constructs one or
more promises referring to pre-existing objects. Operations on those
objects produce new promises that encode the additional
computations. Eventually, usually after some sort of restriction
and/or aggregation, the promise is &ldquo;fulfilled&rdquo; to yield a
materialized, eager object, such as an R vector.
</p>
<p><code>Promise</code> and its partial implementation <code>SimplePromise</code>
provide a foundation for implementations that mostly helps with
creating and fulfilling promises, while the implementation is
responsible for deferring particular computations, which is
language-dependent.
</p>


<h3>Construction</h3>


<ul>
<li>
<p><code>Promise(expr, context, ...)</code>: A generic constructor that
dispatches on <code>expr</code> to construct a <code>Promise</code> object,
the specific type of which corresponds to the language of
<code>expr</code>. The <code>context</code> argument should be a
<code>Context</code> object, in which <code>expr</code> will be evaluated when
the promise is fulfilled. The <code>...</code> are passed to methods.

</p>
</li></ul>



<h3>Fulfillment</h3>


<ul>
<li>
<p><code>fulfill(x)</code>: Fulfills the promise by evaluating the deferred
computation and returning a materialized object.

</p>
</li></ul>

<p>The basic coercion functions in R, like <code>as.vector</code> and
<code>as.data.frame</code>, have methods for <code>Promise</code> that simply call
<code>fulfill</code> on the promise, and then perform the coercion. Coercion
is preferred to calling <code>fulfill</code> directly.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='SolrCore-class'>SolrCore</h2><span id='topic+class+3ASolrCore'></span><span id='topic+SolrCore-class'></span><span id='topic+name+2CSolrCore-method'></span><span id='topic+ndoc+2CSolrCore-method'></span><span id='topic+schema'></span><span id='topic+schema+2CSolrCore-method'></span><span id='topic+fieldNames+2CSolrCore-method'></span><span id='topic+version'></span><span id='topic+version+2CSolrCore-method'></span><span id='topic+SolrCore'></span><span id='topic+docs'></span><span id='topic+docs+2CSolrCore-method'></span><span id='topic+read+2CSolrCore-method'></span><span id='topic+eval+2CSolrQuery+2CSolrCore-method'></span><span id='topic+eval+2CTranslationRequest+2CSolrCore-method'></span><span id='topic+facets'></span><span id='topic+facets+2CSolrCore-method'></span><span id='topic+groupings'></span><span id='topic+groupings+2CSolrCore-method'></span><span id='topic+ngroup+2CSolrCore-method'></span><span id='topic+update+2CSolrCore-method'></span><span id='topic+delete+2CSolrCore-method'></span><span id='topic+commit'></span><span id='topic+commit+2CSolrCore-method'></span><span id='topic+purgeCache+2CSolrCore-method'></span><span id='topic+show+2CSolrCore-method'></span>

<h3>Description</h3>

<p>The <code>SolrCore</code> object represents a core hosted by a Solr
instance. A core is essentially a queryable collection of documents
that share the same schema. It is usually not necessary to interact
with a <code>SolrCore</code> directly.
</p>


<h3>Details</h3>

<p>The typical usage (by advanced users) would be to construct a custom
<code><a href="#topic+SolrQuery-class">SolrQuery</a></code> and execute it via the <code>docs</code>,
<code>facets</code> or (the very low-level) <code>eval</code> methods.
</p>


<h3>Accessor methods</h3>

<p>In the code snippets below, <code>x</code> is a <code>SolrCore</code> object.
</p>

<ul>
<li><p><code>name(x)</code>: Gets the name of the core (specified by the
schema).

</p>
</li>
<li><p><code>ndoc(x, query = SolrQuery())</code>: Gets the number of
documents in the core, given the <code>query</code> restriction.

</p>
</li>
<li><p><code>schema(x)</code>: Gets the <code><a href="#topic+SolrSchema-class">SolrSchema</a></code>
satisfied by all documents in the core.

</p>
</li>
<li><p><code>fieldNames(x, query = NULL, onlyStored = FALSE,
        onlyIndexed = FALSE, includeStatic = FALSE)</code>: Gets the field
names, given any restriction and/or transformation in
<code>query</code>, which is a <code>SolrQuery</code> or a character vector of
field patterns. The <code>onlyIndexed</code> and <code>onlyStored</code>
arguments restrict the fields to those indexed and stored,
respectively (see <code><a href="#topic+FieldInfo-class">FieldInfo</a></code> for more
details). Setting <code>includeStatic</code> to <code>TRUE</code> ensures
that all of the static fields in the schema are returned.

</p>
</li>
<li><p><code>version(x)</code>: Gets the version of the Solr instance
hosting the core.

</p>
</li></ul>



<h3>Constructor</h3>


<ul>
<li>
<p><code>SolrCore(uri, ...)</code>:
Constructs a new <code>SolrCore</code> instance, representing a Solr
core located at <code>uri</code>, which should be a string or a
<code><a href="restfulr.html#topic+RestUri">RestUri</a></code> object. If a string, then the
... are passed to the <code>RestUri</code> constructor.

</p>
</li></ul>



<h3>Reading</h3>


<ul>
<li>
<p><code>docs(x, query = SolrQuery(), as=c("list", "data.frame"))</code>:
Get the documents selected by <code>query</code>, in the form indicated
by <code>as</code>, i.e., either a list or a data frame.

</p>
</li>
<li>
<p><code>read(x, ...)</code>: Just an alias for <code>docs</code>.

</p>
</li></ul>



<h3>Summarizing</h3>


<ul>
<li>
<p><code>facets(x, by, ...)</code>:
Gets the <code><a href="#topic+Facets-class">Facets</a></code> results as requested by
<code>by</code>, a <code><a href="#topic+SolrQuery-class">SolrQuery</a></code>. The ... are passed
down to <code>facets</code> on <code><a href="#topic+ListSolrResult-class">ListSolrResult</a></code>.

</p>
</li>
<li>
<p><code>groupings(x, by, ...)</code>:
Gets the list of <code><a href="#topic+Grouping-class">Grouping</a></code> objects as requested by
the grouped query <code>by</code>. The ... are passed
down to <code>groupings</code> on <code><a href="#topic+ListSolrResult-class">ListSolrResult</a></code>.

</p>
</li>
<li>
<p><code>ngroup(x)</code>: Gets the number of groupings that would be
returned by <code>groupings</code>.

</p>
</li></ul>



<h3>Updating</h3>


<ul>
<li>
<p><code>update(object, value, commit = TRUE, atomic = FALSE, ...)</code>:
Load the documents in <code>value</code> (typically a list or data
frame) into the SolrCore given by <code>object</code>. If <code>commit</code>
is <code>TRUE</code>, we request that Solr commit the changes to its
index on disk, with arguments in <code>...</code> fine-tuning the commit
(see <code>commit</code>). If <code>atomic</code> is <code>TRUE</code>, then the
existing documents are modified, rather than replaced, by the
documents in <code>value</code>.

</p>
</li>
<li>
<p><code>delete(x, which = SolrQuery(), ...)</code>:
Deletes the documents specified by <code>which</code> (all by default),
where the ... are passed down to <code>update</code>.

</p>
</li>
<li>
<p><code>commit(x, waitSearcher=TRUE, softCommit=FALSE,
        expungeDeletes=FALSE, optimize=TRUE, maxSegments=if (optimize) 1L)</code>:
Commits the changes to the Solr index; see the Solr documentation
for the meaning of the parameters.

</p>
</li>
<li>
<p><code>purgeCache(x)</code>: Purges the client-side HTTP cache, which is
useful if the Solr instance is using expiration-based HTTP caching
and one needs to see the result of an update immediately.

</p>
</li></ul>



<h3>Evaluation</h3>


<ul>
<li>
<p><code>eval(expr, envir, enclos)</code>:
Evaluates the query <code>expr</code> in the core <code>envir</code>,
ignoring <code>enclos</code>. Unless otherwise requested by the query
response type, the result should be returned as a
<code><a href="#topic+ListSolrResult-class">ListSolrResult</a></code>. 

</p>
</li></ul>



<h3>Coercion</h3>


<ul>
<li>
<p><code>as.data.frame(x, row.names=NULL, optional=FALSE, ...)</code>:

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrFrame-class">SolrFrame</a></code>, the typical way to interact with a
Solr core.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     solr &lt;- TestSolr()
     sc &lt;- SolrCore(solr$uri)
     name(sc)
     ndoc(sc)

     delete(sc)
     
     docs &lt;- list(
        list(id="2", inStock=TRUE, price=2, timestamp_dt=Sys.time()),
        list(id="3", inStock=FALSE, price=3, timestamp_dt=Sys.time()),
        list(id="4", price=4, timestamp_dt=Sys.time()),
        list(id="5", inStock=FALSE, price=5, timestamp_dt=Sys.time())
     )
     update(sc, docs)

     q &lt;- SolrQuery(id %in% as.character(2:4))
     read(sc, q)

     solr$kill()

</code></pre>

<hr>
<h2 id='SolrExpression-class'>SolrExpression</h2><span id='topic+class+3ASolrExpression'></span><span id='topic+SolrExpression-class'></span><span id='topic+as.character+2CAbstractSolrFunctionCall-method'></span><span id='topic+as.character+2CFRangeQParserExpression-method'></span><span id='topic+as.character+2CJoinQParserExpression-method'></span><span id='topic+as.character+2CLuceneRange-method'></span><span id='topic+as.character+2CSimpleExpression-method'></span><span id='topic+as.character+2CSolrFunctionCall-method'></span><span id='topic+as.character+2CSolrFunctionExpression-method'></span><span id='topic+as.character+2CSolrLuceneAND-method'></span><span id='topic+as.character+2CSolrLuceneOR-method'></span><span id='topic+as.character+2CSolrLuceneProhibit-method'></span><span id='topic+as.character+2CSolrLuceneTerm-method'></span><span id='topic+as.character+2CSolrQParserExpression-method'></span><span id='topic+as.character+2CSolrSortExpression-method'></span><span id='topic+translate+2CSolrExpression+2CSolrExpression-method'></span><span id='topic+SymbolFactory+2CSolrExpression-method'></span><span id='topic+SymbolFactory+2CSolrQParserExpression-method'></span><span id='topic+Promise+2CSolrLuceneSymbol+2CSolr-method'></span><span id='topic+Promise+2CSolrSymbol+2CSolr-method'></span>

<h3>Description</h3>

<p>There is a formal framework for constructing and manipulating the Solr
languages that is not yet exposed. Please inform the authors if
exposing the framework would be helpful. Perhaps it would be helpful
in support of implementing new functionality on top of
<code>SolrPromise</code>.
</p>


<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='SolrFrame-class'>SolrFrame</h2><span id='topic+class+3ASolrFrame'></span><span id='topic+SolrFrame-class'></span><span id='topic+class+3ASolr'></span><span id='topic+Solr-class'></span><span id='topic+dimnames+2CSolrFrame-method'></span><span id='topic+colnames+2CSolrFrame-method'></span><span id='topic+rownames+2CSolrFrame-method'></span><span id='topic+ROWNAMES+2CSolrFrame-method'></span><span id='topic+dim+2CSolrFrame-method'></span><span id='topic+nrow+2CSolrFrame-method'></span><span id='topic+NROW+2CSolrFrame-method'></span><span id='topic+ncol+2CSolrFrame-method'></span><span id='topic+NCOL+2CSolrFrame-method'></span><span id='topic+length+2CSolrFrame-method'></span><span id='topic+names+2CSolrFrame-method'></span><span id='topic+fieldNames'></span><span id='topic+fieldNames+2CSolrFrame-method'></span><span id='topic+fieldNames+2CSolr-method'></span><span id='topic++5B+3C-+2CSolrFrame+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+3C-+2CSolrFrame-method'></span><span id='topic++5B+2CSolrFrame-method'></span><span id='topic++5B+5B+2CSolrFrame+2CANY-method'></span><span id='topic++24+2CSolr-method'></span><span id='topic++24+3C-+2CSolr-method'></span><span id='topic+ndoc+2CSolr-method'></span><span id='topic+nfield+2CSolr-method'></span><span id='topic+core'></span><span id='topic+query'></span><span id='topic+schema+2CSolr-method'></span><span id='topic+facets+2CSolrSummary-method'></span><span id='topic+grouping+2CSolr-method'></span><span id='topic+ids+2CSolr-method'></span><span id='topic+SolrFrame'></span><span id='topic+rename'></span><span id='topic+rename+2CSolr-class'></span><span id='topic+subset+2CSolr-method'></span><span id='topic+transform+2CSolr-method'></span><span id='topic+sort+2CSolr-method'></span><span id='topic+xtabs+2CSolr-method'></span><span id='topic+aggregate+2Cformula-method'></span><span id='topic+unique+2CSolrFrame-method'></span><span id='topic+aggregate+2CSolr-method'></span><span id='topic+summary+2CSolrFrame-method'></span><span id='topic+unique+2CSolr-method'></span><span id='topic+head+2CSolr-method'></span><span id='topic+tail+2CSolr-method'></span><span id='topic+window+2CSolr-method'></span><span id='topic+group'></span><span id='topic+group+2CSolrFrame+2CNULL-method'></span><span id='topic+group+2CSolrFrame+2Cformula-method'></span><span id='topic+ungroup+2CSolrFrame-method'></span><span id='topic+rename+2CSolr-method'></span><span id='topic+eval+2CSolrExpression+2CSolrFrame-method'></span><span id='topic+eval+2CSolrAggregateCall+2CSolrFrame-method'></span><span id='topic+eval+2Clanguage+2CSolr-method'></span><span id='topic+with+2CSolr-method'></span><span id='topic+within+2CSolr-method'></span><span id='topic+defer'></span><span id='topic+defer+2CSolr-method'></span><span id='topic+symbolFactory+2CSolr-method'></span><span id='topic+symbolFactory+3C-+2CSolr-method'></span><span id='topic+as.data.frame.Solr'></span><span id='topic+as.data.frame+2CSolr-method'></span><span id='topic+coerce+2CSolr+2Cdata.frame-method'></span><span id='topic+as.list+2CSolr-method'></span><span id='topic+as.list.Solr'></span><span id='topic+coerce+2CSolr+2Cenvironment-method'></span><span id='topic+as.data.frame+2CSolrFrame-method'></span><span id='topic+as.list+2CSolrFrame-method'></span><span id='topic+as.table+2CSolrSummary-method'></span><span id='topic+searchDocs+2CSolr-method'></span><span id='topic+show+2CSolrFrame-method'></span>

<h3>Description</h3>

<p>The <code>SolrFrame</code> object makes Solr data accessible through a
data.frame-like interface. This is the typical way an R user accesses
data from a Solr core. Much of its methods are shared with
<code>SolrList</code>, which has very similar behavior.
</p>


<h3>Details</h3>

<p>A <code>SolrFrame</code> should more or less behave analogously to a data
frame. It provides the same basic accessors (<code><a href="base.html#topic+nrow">nrow</a></code>,
<code><a href="base.html#topic+ncol">ncol</a></code>, <code><a href="base.html#topic+length">length</a></code>, <code><a href="base.html#topic+rownames">rownames</a></code>,
<code><a href="base.html#topic+colnames">colnames</a></code>, <code><a href="base.html#topic++5B">[</a></code>, <code><a href="base.html#topic++5B+3C-">[&lt;-</a></code>,
<code><a href="base.html#topic++5B+5B">[[</a></code>, <code><a href="base.html#topic++5B+5B+3C-">[[&lt;-</a></code>, <code><a href="base.html#topic++24">$</a></code>,
<code><a href="base.html#topic++24+3C-">$&lt;-</a></code>, <code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code>, etc) and
can be coerced to an actual data frame via
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>. Supported types of data manipulations
include <code><a href="base.html#topic+subset">subset</a></code>, <code><a href="base.html#topic+transform">transform</a></code>,
<code><a href="base.html#topic+sort">sort</a></code>, <code><a href="stats.html#topic+xtabs">xtabs</a></code>, <code><a href="stats.html#topic+aggregate">aggregate</a></code>,
<code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, etc.
</p>
<p>Mapping a collection of documents to a tablular data structure is not
quite natural, as the document collection is ragged: a given document
can have any arbitrary set of fields, out of a set that is essentially
infinite. Unlike some other document stores, however, Solr constrains
the type of every field through a schema. The schema achieves
flexibility through &ldquo;dynamic&rdquo; fields. The name of a dynamic
field is a wildcard pattern, and any document field that matches the
pattern is expected to obey the declared type and other
constraints.
</p>
<p>When determining its set of columns, <code>SolrFrame</code> takes every
actual field present in the collection, and (by default) adds all
non-dynamic (static) fields, in the order specified by the
schema. Note that is very likely that many columns will consist
entirely or almost entirely of NAs.
</p>
<p>If a collection is extremly ragged, where few fields are shared
between documents, it may make more sense to treat the data as a list,
through <code><a href="#topic+SolrList-class">SolrList</a></code>, which shares almost all of the
functionality of <code>SolrFrame</code> but in a different shape.
</p>
<p>The rownames are taken from the field declared in the schema to
represent the unique document key. Schemas are not strictly required
to declare such a field, so if there is no unique key, the rownames
are <code>NULL</code>.
</p>
<p>Field restrictions passed to e.g. <code>[</code> or <code>subset(fields=)</code>
may be specified by name, or wildcard pattern (glob). Similarly, a row
index passed to <code>[</code> must be either a character vector of
identifiers (of length &lt;= 1024, NAs are not supported, and this
requires a unique key in the schema) or a
<code><a href="#topic+SolrPromise-class">SolrPromise</a></code>/<code><a href="#topic+SolrExpression-class">SolrExpression</a></code>,
but note that if it evaluates to NAs, the corresponding rows are
excluded from the result, as with <code>subset</code>. Using a
<code>SolrPromise</code> or <code>SolrExpression</code> is recommended, as
filtering happens at the database.
</p>
<p>A special feature of <code>SolrFrame</code>, vs. an ordinary data frame, is
that it can be <code>group</code>ed into a
<code><a href="#topic+GroupedSolrFrame-class">GroupedSolrFrame</a></code>, where every column is modeled
as a list, split by some combination of grouping factors. This is
useful for aggregation and supports the implementation of the
<code>aggregate</code> method, which is the recommended high-level
interface.
</p>
<p>Another interesting feature is laziness. One can <code>defer</code> a
<code>SolrFrame</code>, so that all column retrieval, e.g., via <code>$</code> or
<code>eval</code>, returns a <code><a href="#topic+SolrPromise-class">SolrPromise</a></code> object. Many
operations on promises are deferred, until they are finally
<code>fulfill</code>ed by being shown or through explicit coercion to an R
vector.
</p>
<p>A note for developers: <code>SolrList</code> and <code>SolrFrame</code> share
common functionality through the base <code>Solr</code> class. Much of the
functionality mentioned here is actually implemented as methods on the
<code>Solr</code> class.
</p>


<h3>Accessors</h3>

<p>These are some accessors that <code>SolrFrame</code> adds on top of the
basic data frame accessors. Most of these are for advanced use only.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents (rows); serves as an
abstraction over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>nfield(x)</code>: Gets the number of fields (columns); serves as an
abstraction over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>ids(x)</code>: Gets the document unique identifiers (may
be <code>NULL</code>, treated as rownames); serves as an abstraction
over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>fieldNames(x, includeStatic=TRUE, ...)</code>: Gets the name of
each field represented by any document in the Solr core, with
... being passed down to <code>fieldNames</code> on
<code><a href="#topic+SolrCore-class">SolrCore</a></code>. Fields must be indexed to be
reported, with the exception that when <code>includeStatic</code> is
<code>TRUE</code>, we ensure all static (non-dynamic) fields are present
in the return value. Names are returned in an order consistent
with the order in the schema. Note that two different
&ldquo;instances&rdquo; of the same dynamic field do not have a
specified order in the schema, so we use the index order
(lexicographical) for those cases.

</p>
</li>
<li>
<p><code>core(x)</code>: Gets the <code>SolrCore</code> wrapped by <code>x</code>

</p>
</li>
<li>
<p><code>query(x)</code>: Gets the query that is being constructed by
<code>x</code>

</p>
</li></ul>



<h3>Extended API</h3>

<p>Most of the typical data frame accessors and data manipulation
functions will work analogously on <code>SolrFrame</code> (see
Details). Below, we list some of the non-standard methods that might
be seen as an extension of the data frame API.
</p>

<ul>
<li><p><code>aggregate(x, data, FUN, ..., subset, na.action,
        simplify = TRUE, count = FALSE)</code>: If <code>x</code> is a formula,
aggregates <code>data</code>, grouping by <code>x</code>, by either applying
<code>FUN</code>, or evaluating an aggregating expression in ..., on
each group. If <code>count</code> is <code>TRUE</code>, a &ldquo;count&rdquo;
column is added with the number of elements in each group. The
rest of the arguments behave like those for the base
<code><a href="stats.html#topic+aggregate">aggregate</a></code>.
</p>
<p>There are two main modes: aggregating with <code>FUN</code>, or, as an
extension to the base <code>aggregate</code>, aggregating with
expressions in <code>...</code>, similar to the interface for
<code>transform</code>. If <code>FUN</code> is specified, then behavior is
much like the original, except one can omit the LHS on the
formula, in which case the entire frame is passed to
<code>FUN</code>. In the second mode, there is a column in the result
for each argument in ..., and there must not be an LHS on the
formula.
</p>
<p>See the documentation for the underlying <code><a href="#topic+facet">facet</a></code>
function for details on what is supported on the formula RHS.
</p>
<p>For global aggregation, simply pass the <code>SolrFrame</code> as
<code>x</code>, in which case the <code>data</code> argument does not exist.
</p>
<p>Note that the function or expressions are only
<em>conceptually</em> evaluated on each group. In reality, the
computations occur on grouped columns/promises, which are
modeled as lists. Thus, there is potential for conflict, in
particular with <code>length</code>, which return the number of
groups, instead of operating group-wise. One should use the
abstraction <code>ndoc</code> instead of <code>length</code>, since
<code>ndoc</code> always returns document counts, and thus will return
the size of each group.

</p>
</li>
<li><p><code>rename(x, ...)</code>: Renames the columns of <code>x</code>,
where the names and character values of ... indicates the
mapping (<code>newname = oldname</code>). 

</p>
</li>
<li><p><code>group(x, by)</code>: Returns a
<code><a href="#topic+GroupedSolrFrame-class">GroupedSolrFrame</a></code> that is grouped by the
factors in <code>by</code>, typically a formula. To get back to
<code>x</code>, call <code>ungroup(x)</code>.

</p>
</li>
<li><p><code>grouping(x)</code>: Just returns <code>NULL</code>, since a
<code>SolrFrame</code> is not grouped (unless extended to be groupable).

</p>
</li>
<li><p><code>defer(x)</code>: Returns a <code>SolrFrame</code> that yields
<code><a href="#topic+SolrPromise-class">SolrPromise</a></code> objects instead of vectors
whenever a field is retrieved

</p>
</li>
<li><p><code>searchDocs(x, q)</code>: Performs a conventional document
search using the query string <code>q</code>. The main difference to
filtering is that (by default) Solr will order the result by
score, i.e., how well each document matches the query.

</p>
</li></ul>



<h3>Constructor</h3>


<ul>
<li>
<p><code>SolrFrame(uri)</code>: Constructs a new <code>SolrFrame</code> instance,
representing a Solr core located at <code>uri</code>, which should be a
string or a <code><a href="restfulr.html#topic+RestUri">RestUri</a></code> object. The ... are
passed to the <code>SolrQuery</code> constructor.

</p>
</li></ul>



<h3>Evaluation</h3>


<ul>
<li>
<p><code>eval(expr, envir, enclos)</code>: Evaluates <code>expr</code> in the
<code>SolrFrame</code> <code>envir</code>, using <code>enclos</code> as the
enclosing environment. The <code>expr</code> can be an R language object
or a <code>SolrExpression</code>, either of which are lazily evaluated
if <code>defer</code> has been called on <code>envir</code>.

</p>
</li></ul>



<h3>Coercion</h3>


<ul>
<li>
<p><code>as.data.frame(x, row.names=NULL, optional=FALSE, fill=TRUE)</code>:
Downloads the data into an actual data.frame, specifically an
instance of <code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code>. If <code>fill</code> is
FALSE, only the fields represented in at least one document are
added as columns. 

</p>
</li>
<li>
<p><code>as.list(x)</code>: Essentially <code>as.list(as.data.frame(x))</code>,
except returns a list of promises if <code>x</code> is deferred.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrList-class">SolrList</a></code> for representing a Solr collection as a
list instead of a table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     schema &lt;- deriveSolrSchema(mtcars)
     solr &lt;- TestSolr(schema)
     sr &lt;- SolrFrame(solr$uri)
     sr[] &lt;- mtcars
     dim(sr)
     head(sr)
     subset(sr, mpg &gt; 20 &amp; cyl == 4)
     solr$kill()
     ## see the vignette for more

</code></pre>

<hr>
<h2 id='SolrList-class'>SolrList</h2><span id='topic+class+3ASolrList'></span><span id='topic+SolrList-class'></span><span id='topic+length+2CSolrList-method'></span><span id='topic+names+2CSolrList-method'></span><span id='topic++5B+3C-+2CSolrList+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CSolrList+2CANY-method'></span><span id='topic++5B+2CSolrList-method'></span><span id='topic++5B+5B+2CSolrList-method'></span><span id='topic++5B+5B+3C-+2CSolrList-method'></span><span id='topic+unique+2CSolrList-method'></span><span id='topic+searchDocs'></span><span id='topic+searchDocs+2CSolr'></span><span id='topic+SolrList'></span><span id='topic+coerce+2CSolr+2CSolrList-method'></span><span id='topic+coerce+2CSolrList+2CDocCollection-method'></span><span id='topic+show+2CSolrList-method'></span>

<h3>Description</h3>

<p>The <code>SolrList</code> object makes Solr data accessible through a
list-like interface. This interface is appropriate when the data are
highly ragged.
</p>


<h3>Details</h3>

<p>A <code>SolrList</code> should more or less behave analogously to a list. It
provides the same basic accessors (<code><a href="base.html#topic+length">length</a></code>,
<code><a href="base.html#topic+names">names</a></code>, <code><a href="base.html#topic++5B">[</a></code>, <code><a href="base.html#topic++5B+3C-">[&lt;-</a></code>,
<code><a href="base.html#topic++5B+5B">[[</a></code>, <code><a href="base.html#topic++5B+5B+3C-">[[&lt;-</a></code>, <code><a href="base.html#topic++24">$</a></code>,
<code><a href="base.html#topic++24+3C-">$&lt;-</a></code>, <code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code>, etc) and
can be coerced to a list via <code><a href="base.html#topic+as.list">as.list</a></code>. Supported types of
data manipulations include <code><a href="base.html#topic+subset">subset</a></code>,
<code><a href="base.html#topic+transform">transform</a></code>, <code><a href="base.html#topic+sort">sort</a></code>, <code><a href="stats.html#topic+xtabs">xtabs</a></code>,
<code><a href="stats.html#topic+aggregate">aggregate</a></code>, <code><a href="base.html#topic+unique">unique</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
etc.
</p>
<p>An obvious difference between a <code>SolrList</code> and an ordinary list
is that we know the <code>SolrList</code> contains only documents, which are
themselves represented as named lists of fields, usually vectors of
length one. This constraint enables us to provide the convenience of
accessing fields by slicing across every document. We can pass a field
selection to the second argument of <code>[</code>. Like data frame,
selecting a single column with e.g. <code>x[,"foo"]</code> will return the
field as a vector, filling NAs whereever a document lacks a
value for the field.
</p>
<p>The names are taken from the field declared in the schema to
represent the unique document key. Schemas are not strictly required
to declare such a field, so if there is no unique key, the names
are <code>NULL</code>.
</p>
<p>Field restrictions passed to e.g. <code>[</code> or <code>subset(fields=)</code>
may be specified by name, or wildcard pattern (glob). Similarly, a row
index passed to <code>[</code> must be either a character vector of
identifiers (of length &lt;= 1024, NAs are not supported, and this
requires a unique key in the schema) or a
<code><a href="#topic+SolrPromise-class">SolrPromise</a></code>/<code><a href="#topic+SolrExpression-class">SolrExpression</a></code>,
but note that if it evaluates to NAs, the corresponding rows are
excluded from the result, as with <code>subset</code>. Using a
<code>SolrPromise</code> or <code>SolrExpression</code> is recommended, as
filtering happens at the database.
</p>
<p>A <code>SolrList</code> can be made lazy by calling <code>defer</code> on a
<code>SolrList</code>, so that all column retrieval, e.g., via <code>[</code>,
returns a <code><a href="#topic+SolrPromise-class">SolrPromise</a></code> object. Many operations on
promises are deferred, until they are finally <code>fulfill</code>ed by
being shown or through explicit coercion to an R vector.
</p>
<p>A note for developers: <code>SolrFrame</code> and <code>SolrList</code> share
common functionality through the base <code>Solr</code> class. Much of the
functionality mentioned here is actually implemented as methods on the
<code>Solr</code> class.
</p>


<h3>Accessors</h3>

<p>These are some accessors that <code>SolrList</code> adds on top of the
basic data frame accessors. Most of these are for advanced use only.
</p>

<ul>
<li>
<p><code>ndoc(x)</code>: Gets the number of documents (rows); serves as an
abstraction over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>nfield(x)</code>: Gets the number of fields (columns); serves as an
abstraction over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>ids(x)</code>: Gets the document unique identifiers (may
be <code>NULL</code>, treated as rownames); serves as an abstraction
over <code>SolrFrame</code> and <code>SolrList</code>

</p>
</li>
<li>
<p><code>fieldNames(x, ...)</code>: Gets the name of each field represented by
any document in the Solr core, with ... being passed down to
<code>fieldNames</code> on <code><a href="#topic+SolrCore-class">SolrCore</a></code>.

</p>
</li>
<li>
<p><code>core(x)</code>: Gets the <code>SolrCore</code> wrapped by <code>x</code>

</p>
</li>
<li>
<p><code>query(x)</code>: Gets the query that is being constructed by
<code>x</code>

</p>
</li></ul>



<h3>Extended API</h3>

<p>Most of the typical data frame accessors and data manipulation
functions will work analogously on <code>SolrList</code> (see
Details). Below, we list some of the non-standard methods that might
be seen as an extension of the data frame API.
</p>

<ul>
<li><p><code>rename(x, ...)</code>: Renames the columns of <code>x</code>,
where the names and character values of ... indicates the
mapping (<code>newname = oldname</code>). 

</p>
</li>
<li><p><code>defer(x)</code>: Returns a <code>SolrList</code> that yields
<code><a href="#topic+SolrPromise-class">SolrPromise</a></code> objects instead of vectors
whenever a field is retrieved

</p>
</li>
<li><p><code>searchDocs(x, q)</code>: Performs a conventional document
search using the query string <code>q</code>. The main difference to
filtering is that (by default) Solr will order the result by
score, i.e., how well each document matches the query.

</p>
</li></ul>



<h3>Constructor</h3>


<ul>
<li>
<p><code>SolrList(uri, ...)</code>:
Constructs a new <code>SolrList</code> instance, representing a Solr
core located at <code>uri</code>, which should be a string or a
<code><a href="restfulr.html#topic+RestUri">RestUri</a></code> object. The
... are passed to the <code>SolrQuery</code> constructor.

</p>
</li></ul>



<h3>Evaluation</h3>


<ul>
<li>
<p><code>eval(expr, envir, enclos)</code>: Evaluates R language <code>expr</code>
in the <code>SolrList</code> <code>envir</code>, using <code>enclos</code> as the
enclosing environment.

</p>
</li></ul>



<h3>Coercion</h3>


<ul>
<li>
<p><code>as.data.frame(x, row.names=NULL, optional=FALSE, fill=FALSE)</code>:
Downloads the data into an actual data.frame, specifically an
instance of <code><a href="#topic+DocDataFrame-class">DocDataFrame</a></code>. If <code>fill</code> is
FALSE, only the fields represented in at least one document are
added as columns. 

</p>
</li>
<li>
<p><code>as.list(x), as(x, "DocCollection")</code>: Coerces <code>x</code> into
the corresponding list, specifically an instance of
<code><a href="#topic+DocList-class">DocList</a></code>.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrFrame-class">SolrFrame</a></code> for representing a Solr collection as a
table instead of a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     solr &lt;- TestSolr()
     sr &lt;- SolrList(solr$uri)
     length(sr)
     head(sr)
     sr[["GB18030TEST"]]
     # Solr tends to crash for some reason running this inside R CMD check
     ## Not run:  
     as.list(subset(sr, price &gt; 100))[,"price"]
     
## End(Not run)
     solr$kill()

</code></pre>

<hr>
<h2 id='SolrPromise-class'>SolrPromise</h2><span id='topic+class+3ASolrPromise'></span><span id='topic+SolrPromise-class'></span><span id='topic+class+3ASolrLucenePromise'></span><span id='topic+SolrLucenePromise-class'></span><span id='topic+class+3ASolrFunctionPromise'></span><span id='topic+SolrFunctionPromise-class'></span><span id='topic+class+3ASolrReducePromise'></span><span id='topic+SolrReducePromise-class'></span><span id='topic+class+3ASolrAggregatePromise'></span><span id='topic+SolrAggregatePromise-class'></span><span id='topic+class+3ASolrSymbolPromise'></span><span id='topic+SolrSymbolPromise-class'></span><span id='topic+class+3ASolrLuceneSymbolPromise'></span><span id='topic+SolrLuceneSymbolPromise-class'></span><span id='topic+class+3APredicatedSolrSymbolPromise'></span><span id='topic+PredicatedSolrSymbolPromise-class'></span><span id='topic+length+2CSolrPromise-method'></span><span id='topic+lengths+2CSolrSymbolPromise-method'></span><span id='topic+lengths+2CSolrPromise-method'></span><span id='topic++25in+25+2CSolrSymbolPromise+2CPredicatedSolrSymbolPromise-method'></span><span id='topic++25in+25+2CSolrSymbolPromise+2CSolrSymbolPromise-method'></span><span id='topic++25in+25+2CSolrSymbolPromise+2Cvector-method'></span><span id='topic++21+2CSolrAggregatePromise-method'></span><span id='topic++21+2CSolrFunctionPromise-method'></span><span id='topic++21+2CSolrLuceneSymbolPromise-method'></span><span id='topic++21+2CSolrPromise-method'></span><span id='topic+-+2CSolrPromise+2Cmissing-method'></span><span id='topic+Arith+2CSolrAggregatePromise+2CSolrAggregatePromise-method'></span><span id='topic+Arith+2CSolrAggregatePromise+2Cnumeric-method'></span><span id='topic+Arith+2CSolrPromise+2CSolrPromise-method'></span><span id='topic+Arith+2CSolrPromise+2Clogical-method'></span><span id='topic+Arith+2CSolrPromise+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CSolrPromise-method'></span><span id='topic+Arith+2Cnumeric+2CSolrAggregatePromise-method'></span><span id='topic+Arith+2Cnumeric+2CSolrPromise-method'></span><span id='topic+Compare+2CAsIs+2CSolrSymbolPromise-method'></span><span id='topic+Compare+2CSolrAggregatePromise+2CSolrAggregatePromise-method'></span><span id='topic+Compare+2CSolrAggregatePromise+2Cnumeric-method'></span><span id='topic+Compare+2CSolrPromise+2CSolrPromise-method'></span><span id='topic+Compare+2CSolrPromise+2Cnumeric-method'></span><span id='topic+Compare+2CSolrSymbolPromise+2CAsIs-method'></span><span id='topic+Compare+2CSolrSymbolPromise+2Cnumeric-method'></span><span id='topic+Compare+2CSolrSymbolPromise+2Cvector-method'></span><span id='topic+Compare+2Cnumeric+2CSolrAggregatePromise-method'></span><span id='topic+Compare+2Cnumeric+2CSolrPromise-method'></span><span id='topic+Compare+2Cnumeric+2CSolrSymbolPromise-method'></span><span id='topic+Compare+2Cvector+2CSolrSymbolPromise-method'></span><span id='topic+IQR+2CSolrPromise-method'></span><span id='topic+Logic+2CSolrAggregatePromise+2CSolrAggregatePromise-method'></span><span id='topic+Logic+2CSolrAggregatePromise+2Clogical-method'></span><span id='topic+Logic+2CSolrFunctionPromise+2CSolrFunctionPromise-method'></span><span id='topic+Logic+2CSolrLucenePromise+2CSolrLucenePromise-method'></span><span id='topic+Logic+2CSolrLucenePromise+2CSolrPromise-method'></span><span id='topic+Logic+2CSolrLucenePromise+2CSolrSymbolPromise-method'></span><span id='topic+Logic+2CSolrPromise+2CSolrLucenePromise-method'></span><span id='topic+Logic+2CSolrPromise+2CSolrSymbolPromise-method'></span><span id='topic+Logic+2CSolrPromise+2Clogical-method'></span><span id='topic+Logic+2CSolrSymbolPromise+2CSolrLucenePromise-method'></span><span id='topic+Logic+2CSolrSymbolPromise+2CSolrPromise-method'></span><span id='topic+Logic+2CSolrSymbolPromise+2CSolrSymbolPromise-method'></span><span id='topic+Logic+2Clogical+2CSolrAggregatePromise-method'></span><span id='topic+Logic+2Clogical+2CSolrPromise-method'></span><span id='topic+Math+2CSolrAggregatePromise-method'></span><span id='topic+Math+2CSolrPromise-method'></span><span id='topic+Summary+2CSolrPromise-method'></span><span id='topic++5B+2CSolrPromise-method'></span><span id='topic++5B+2CSolrSymbolPromise-method'></span><span id='topic++5B+3C-+2CPromise+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CSolrPromise+2CSolrPromise+2CANY+2CANY-method'></span><span id='topic+anyNA+2CSolrPromise-method'></span><span id='topic+complete.cases+2CSolrFunctionPromise-method'></span><span id='topic+complete.cases+2CSolrLuceneSymbolPromise-method'></span><span id='topic+ftable+2CSolrSymbolPromise-method'></span><span id='topic+grep+2CANY+2CSolrSymbolPromise-method'></span><span id='topic+grepl+2Ccharacter+2CSolrSymbolPromise-method'></span><span id='topic+head+2CSolrPromise-method'></span><span id='topic+ifelse+2CSolrAggregatePromise-method'></span><span id='topic+ifelse+2CSolrPromise-method'></span><span id='topic+intersect+2CSolrSymbolPromise+2CSolrSymbolPromise-method'></span><span id='topic+is.na+2CSolrAggregatePromise-method'></span><span id='topic+is.na+2CSolrFunctionPromise-method'></span><span id='topic+is.na+2CSolrLuceneSymbolPromise-method'></span><span id='topic+mad+2CSolrPromise-method'></span><span id='topic+mean+2CSolrPromise-method'></span><span id='topic+median+2CSolrPromise-method'></span><span id='topic+ndoc+2CSolrPromise-method'></span><span id='topic+nunique'></span><span id='topic+nunique+2CANY-method'></span><span id='topic+nunique+2CSolrPromise-method'></span><span id='topic+nunique+2Cfactor-method'></span><span id='topic+pmax2+2CSolrAggregatePromise+2CSolrAggregatePromise-method'></span><span id='topic+pmax2+2CSolrAggregatePromise+2Cnumeric-method'></span><span id='topic+pmax2+2CSolrPromise+2CSolrPromise-method'></span><span id='topic+pmax2+2CSolrPromise+2Cnumeric-method'></span><span id='topic+pmax2+2Cnumeric+2CSolrAggregatePromise-method'></span><span id='topic+pmax2+2Cnumeric+2CSolrPromise-method'></span><span id='topic+pmax2+2CANY+2CANY-method'></span><span id='topic+pmin2+2CANY+2CANY-method'></span><span id='topic+pmin2+2CSolrAggregatePromise+2CSolrAggregatePromise-method'></span><span id='topic+pmin2+2CSolrAggregatePromise+2Cnumeric-method'></span><span id='topic+pmin2+2CSolrPromise+2CSolrPromise-method'></span><span id='topic+pmin2+2CSolrPromise+2Cnumeric-method'></span><span id='topic+pmin2+2Cnumeric+2CSolrAggregatePromise-method'></span><span id='topic+pmin2+2Cnumeric+2CSolrPromise-method'></span><span id='topic+quantile+2CSolrPromise-method'></span><span id='topic+rescale'></span><span id='topic+rescale+2CSolrPromise-method'></span><span id='topic+round+2CSolrAggregatePromise-method'></span><span id='topic+round+2CSolrPromise-method'></span><span id='topic+sd+2CSolrPromise-method'></span><span id='topic+setdiff+2CSolrSymbolPromise+2CSolrSymbolPromise-method'></span><span id='topic+signif+2CSolrPromise-method'></span><span id='topic+summary+2CSolrPromise-method'></span><span id='topic+summary.SolrPromise'></span><span id='topic+table+2CSolrSymbolPromise-method'></span><span id='topic+tail+2CSolrPromise-method'></span><span id='topic+union+2CSolrSymbolPromise+2CSolrSymbolPromise-method'></span><span id='topic+unique+2CPredicatedSolrSymbolPromise-method'></span><span id='topic+unique+2CSolrSymbolPromise-method'></span><span id='topic+var+2CSolrPromise+2CANY-method'></span><span id='topic+weighted.mean+2CSolrPromise+2CSolrPromise-method'></span><span id='topic+window+2CSolrPromise-method'></span><span id='topic+windows+2CSolrPromise-method'></span><span id='topic+as.data.frame+2CSolrPromise-method'></span><span id='topic+fulfill+2CPredicatedSolrSymbolPromise-method'></span><span id='topic+ftable'></span><span id='topic+mad'></span><span id='topic+pmax'></span><span id='topic+pmax2'></span><span id='topic+pmin'></span><span id='topic+pmin2'></span>

<h3>Description</h3>

<p><code>SolrPromise</code> is a vector-like representation of a deferred
computation within Solr. It may promise to simply return a field, to
perform arithmetic on a combination of fields, to aggregate a field,
etc. Methods on <code>SolrPromise</code> allow the R user to
manipulate Solr data with the ordinary R API. The typical way to
fulfill a promise is to explicitly coerce the promise to a
materialized data type, such as an R vector.
</p>


<h3>Details</h3>

<p>In general, <code>SolrPromise</code> acts just like an R vector. It supports
all of the basic vector manipulations, including the
<code><a href="base.html#topic+Logic">Logic</a></code>, <code><a href="methods.html#topic+Compare">Compare</a></code>, <code><a href="methods.html#topic+Arith">Arith</a></code>,
<code><a href="base.html#topic+Math">Math</a></code>, and <code><a href="base.html#topic+Summary">Summary</a></code> group generics, as well
as <code>length</code>, <code>lengths</code>, <code>%in%</code>,
<code>complete.cases</code>, <code>is.na</code>, <code>[</code>, <code>grepl</code>,
<code>grep</code>, <code>round</code>, <code>signif</code>, <code>ifelse</code>,
<code>pmax</code>, <code>pmin</code>,
<code>cut</code>, <code>mean</code>, <code>quantile</code>, <code>median</code>,
<code>weighted.mean</code>, <code>IQR</code>, <code>mad</code>, <code>anyNA</code>. All of
these functions are lazy, in that they return another promise.
</p>
<p>The promise is really only known to rsolr, as all actual Solr queries
are eager. <code>SolrPromise</code> does its best to defer computations, but
the computations will be forced if one performs an operation that is
not supported by Solr.
</p>
<p>These functions are also supported, but they are eager: <code>cbind</code>,
<code>rbind</code>, <code>summary</code>, <code>window</code>,
<code>head</code>, <code>tail</code>, <code>unique</code>, <code>intersect</code>,
<code>setdiff</code>, <code>union</code>, <code>table</code> and <code>ftable</code>. These
functions from the <code>Math</code> group generic are eager: <code>cummax</code>,
<code>cummin</code>, <code>cumprod</code>, <code>cumsum</code>, <code>log2</code>, and
<code>*gamma</code>.
</p>
<p>The <code>[&lt;-</code> function will be lazy as long as both <code>x</code> and
<code>i</code> are promises. <code>i</code> is assumed to represent a logical
subscript. Otherwise, <code>[&lt;-</code> is eager.
</p>
<p><code>SolrPromise</code> also extends the R API with some new operations:
<code>nunique</code> (number of unique elements), <code>rescale</code> (rescale
to within a min/max), <code><a href="#topic+ndoc">ndoc</a></code>, <code><a href="#topic+windows">windows</a></code>,
<code><a href="#topic+heads">heads</a></code>, <code><a href="#topic+tails">tails</a></code>.
</p>


<h3>Limitations</h3>

<p>This section outlines some limitations of <code>SolrPromise</code> methods,
compared to the base vector implementation. The primary limitation is
that binary operations generally only work between two promises that
derive from the same data source, including all pending manipulations
(filters, ordering, etc). Operations between a promise and an ordinary
vector usually only work if the vector is of length one (a scalar).
</p>
<p>Some specific notes:
</p>

<ul>
<li><p><code>x[i]</code>: The index <code>i</code> is ideally a promise. The
return value will be restricted such that it will only combine
with promises with the same restriction.

</p>
</li>
<li><p><code>x %in% table</code>: The <code>x</code> argument must always
refer to a simple field, and the <code>table</code> argument should be
either a field, potentially predicated via <code>table[i]</code> (where
the index <code>i</code> is a promise), or a &ldquo;short&rdquo; vector.

</p>
</li>
<li><p><code>grepl(pattern, x, fixed = FALSE)</code>: Applies when
<code>x</code> is a promise. Besides <code>pattern</code>, only the
<code>fixed</code> argument is supported from the base function.

</p>
</li>
<li><p><code>grep(pattern, x, value = FALSE, fixed = FALSE, invert
      = FALSE)</code>: One must always set <code>value=TRUE</code>. Beyond that,
only <code>fixed</code> and <code>invert</code> are supported from the base
function.

</p>
</li>
<li><p><code>cut(x, breaks, include.lowest = FALSE, right = TRUE)</code>:
Only supports uniform (constant separation) breaks.

</p>
</li>
<li><p><code>mad(x, center = median(x, na.rm=na.rm), constant =
        1.4826, na.rm = FALSE, low = FALSE, high = FALSE)</code>: The
<code>low</code> and <code>high</code> parameters must be <code>FALSE</code>. If
there any NAs, then <code>na.rm</code> must be <code>TRUE</code>. Does not
work when the context is grouped.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrFrame-class">SolrFrame</a></code>, which yields promises when it is
<code>defer</code>red.
</p>

<hr>
<h2 id='SolrQuery-class'>SolrQuery</h2><span id='topic+class+3ASolrQuery'></span><span id='topic+SolrQuery-class'></span><span id='topic+params'></span><span id='topic+params+3C-'></span><span id='topic+SolrQuery'></span><span id='topic+rename+2CSolrQuery-method'></span><span id='topic+subset+2CSolrQuery-method'></span><span id='topic+transform+2CSolrQuery-method'></span><span id='topic+sort+2CSolrQuery-method'></span><span id='topic+xtabs+2CSolrQuery-method'></span><span id='topic+facet+2CSolrQuery+2CNULL-method'></span><span id='topic+facet+2CSolrQuery+2Cformula-method'></span><span id='topic+facet+2CSolrQuery+2Ccharacter-method'></span><span id='topic+head.SolrQuery'></span><span id='topic+tail.SolrQuery'></span><span id='topic+head+2CSolrQuery-method'></span><span id='topic+tail+2CSolrQuery-method'></span><span id='topic+window.SolrQuery'></span><span id='topic+window+2CSolrQuery-method'></span><span id='topic+rev+2CSolrQuery-method'></span><span id='topic+facet'></span><span id='topic+group+2CSolrQuery+2Clanguage-method'></span><span id='topic+group+2CSolrQuery+2Cname-method'></span><span id='topic+group+2CSolrQuery+2Ccharacter-method'></span><span id='topic+group+2CSolrQuery+2Cformula-method'></span><span id='topic+searchDocs+2CSolrQuery-method'></span><span id='topic+as.character.SolrQuery'></span><span id='topic+as.character+2CSolrQuery-method'></span><span id='topic+translate+2CSolrQueryTranslationSource+2CExpression-method'></span><span id='topic+translate+2CSolrQueryTranslationSource+2CSolrQParserExpression-method'></span><span id='topic+translate+2CSolrQueryTranslationSource+2CSolrSortExpression-method'></span><span id='topic+translate+2CSolrQuery+2Cmissing-method'></span><span id='topic+as.character+2CSolrQueryTranslationSource-method'></span><span id='topic+show+2CSolrQuery-method'></span>

<h3>Description</h3>

<p>The <code>SolrQuery</code> object represents a query to be sent to a
<code><a href="#topic+SolrCore-class">SolrCore</a></code>. This is a low-level interface to query
construction but will not be useful to most users. The typical reason
to directly manipulate a query would be to batch more operations than is
possible with the high-level <code>SolrFrame</code>, e.g., combining
multiple aggregations.
</p>


<h3>Details</h3>

<p>A <code>SolrQuery</code> API borrows many of the same verbs from the base R
API, including <code><a href="base.html#topic+subset">subset</a></code>, <code><a href="base.html#topic+transform">transform</a></code>,
<code><a href="base.html#topic+sort">sort</a></code>, <code><a href="stats.html#topic+xtabs">xtabs</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="base.html#topic+rev">rev</a></code>, etc.
</p>
<p>The typical workflow is to construct a query, perform various
manipulations, and finally retrieve a result by passing the query to a
<code>SolrCore</code>, typically via the <code>docs</code> or <code>facets</code>
functions.
</p>


<h3>Accessors</h3>


<ul>
<li>
<p><code>params(x), params(x) &lt;- value</code>: Gets/sets the parameters of
the query, which roughly correspond to the parameters of a Solr
&ldquo;select&rdquo; request. The only reason to manipulate the
underlying query parameters is to either initiate a headache or to
do something really tricky with Solr, which implies the former.

</p>
</li></ul>



<h3>Querying</h3>


<ul>
<li><p><code>subset(x, subset, select, fields, select.from =
        character())</code>: Behaves like the base <code><a href="base.html#topic+subset">subset</a></code>, with
some extensions. The <code>fields</code> argument is exclusive with
<code>select</code>, and should be a character vector of field names,
potentially with wildcards. The <code>select.from</code> argument
gives the names that are filtered by <code>select</code>, since
<code>SolrQuery</code> is not associated with any <code>SolrCore</code>, and
thus does not know the field set (in the future, we might use
laziness to avoid this problem).

</p>
</li>
<li><p><code>searchDocs(x, q)</code>: Performs a conventional document
search using the query string <code>q</code>. The main difference to
filtering (<code>subset</code>) is that (by default) Solr will order the
result by score, i.e., how well each document matches the query.

</p>
</li></ul>



<h3>Constructor</h3>


<ul>
<li>
<p><code>SolrQuery(expr)</code>:
Constructs a new <code>SolrQuery</code> instance. If <code>expr</code> is
non-missing, it is passed to <code>subset</code> and thus serves as an
initial restriction.

</p>
</li></ul>



<h3>Faceting</h3>

<p>The Solr facet component counts documents and calculates statistics on
a group-wise basis.
</p>

<ul>
<li><p><code>facet(x, by, ..., useNA=FALSE, sort=NULL,
        decreasing=FALSE, limit=NA_integer_)</code>: Returns a query that will
compute the number of documents in each group, where the
grouping is given as <code>by</code>, typically a formula, or
<code>NULL</code> for global aggregation. Arguments in ... are
quoted and should be expressions that summarize fields, or
mathematical combinations of fields. The names of the statistics
are taken from the argument names; if a name is omitted, a best
guess is made from the expression. If <code>useNA</code> is
<code>TRUE</code>, statistics and counts are computed for the bin
where documents have a missing value for one the grouping
variables. If <code>sort</code> is non-NULL, it should name a
statistic by which the results should be sorted. This is mostly
useful in conjunction if a <code>limit</code> is specified, so that
only the top-N statistics are returned.
</p>
<p>The formula should consist of Solr field names, or calls that
evaluate to logical and refer to one or more Solr fields. If the
latter, the results are grouped by <code>TRUE</code>, <code>FALSE</code> and
(optionally) <code>NA</code> for that term. As a special case, a term
can be a call to <code>cut</code> on any numeric or date field, which
will group by bin.

</p>
</li></ul>



<h3>Grouping</h3>

<p>The Solr grouping component causes results to be returned nested into
groups. The main use case would be to restrict to the first or last N
documents in each group. This functionality is <em>not</em> related to
aggregation; see <code>facet</code>.
</p>

<ul>
<li><p><code>group(x, by, limit = .Machine$integer.max, offset =
        0L, env = emptyenv())</code>: Returns the grouping of <code>x</code>
according to <code>by</code>, which might be a formula, or an
expression that evaluates (within <code>env</code>) to a factor. The
current sort specification applies within the groups, and any
subsequent sorting applies to the groups themselves, by using
the maximum value within the each group. Only the top
<code>limit</code> documents, starting after the first <code>offset</code>,
are returned from each group. Restricting that limit is probably
the main reason to use this functionality.

</p>
</li></ul>



<h3>Coercion</h3>

<p>These two functions are very low-level; users should almost never need
to call these.
</p>

<ul>
<li>
<p><code>translate(x, target, core)</code>: Translates the query <code>x</code>
into the language of Solr, where <code>core</code> specifies the
destination <code>SolrCore</code>. The <code>target</code> argument should be
missing.

</p>
</li>
<li>
<p><code>as.character(x)</code>:
Converts the query into a string to be sent to Solr. Remember to
translate first, if necessary.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>


<h3>See Also</h3>

<p><code><a href="#topic+SolrFrame-class">SolrFrame</a></code>, the recommended high-level interface
for interacting with Solr
</p>
<p><code><a href="#topic+SolrCore-class">SolrCore</a></code>, which gives an example of constructing
and evaluating a query
</p>

<hr>
<h2 id='SolrSchema-class'>SolrSchema</h2><span id='topic+class+3ASolrSchema'></span><span id='topic+SolrSchema-class'></span><span id='topic+uniqueKey'></span><span id='topic+fields'></span><span id='topic+fields+2CSolrSchema-method'></span><span id='topic+fieldTypes'></span><span id='topic+fieldTypes+2CSolrSchema-method'></span><span id='topic+copyFields'></span><span id='topic+name'></span><span id='topic+name+2CANY-method'></span><span id='topic+deriveSolrSchema'></span><span id='topic+deriveSolrSchema+2CANY-method'></span><span id='topic+deriveSolrSchema+2Cdata.frame-method'></span><span id='topic+saveXML+2CSolrSchema-method'></span><span id='topic+show+2CSolrSchema-method'></span>

<h3>Description</h3>

<p>The <code>SolrSchema</code> object represents the schema of a Solr core.
Not all of the information in the schema is represented; only the
relevant elements are included. The user should not need to interact
with this class very often.
</p>
<p>One can infer a <code>SolrSchema</code> from a data.frame with
<code>deriveSolrSchema</code> and then write it out to a file for use with
Solr.
</p>


<h3>Accessors</h3>


<ul>
<li>
<p><code>name(x)</code>: Gets the name of the schema/dataset.

</p>
</li>
<li>
<p><code>uniqueKey(x)</code>: Gets the field that serves as the unique key,
i.e., the document identifier.

</p>
</li>
<li>
<p><code>fields(x, which)</code>: Gets a <code><a href="#topic+FieldInfo-class">FieldInfo</a></code>
object, restricted to the fields indicated by <code>which</code>.

</p>
</li>
<li>
<p><code>fieldTypes(x, fields)</code>: Gets a
<code><a href="#topic+FieldTypeList-class">FieldTypeList</a></code> object, containing the type
definition for each field named in <code>fields</code>.

</p>
</li>
<li>
<p><code>copyFields(x)</code>: Gets the copy field relationships as
a <a href="graph.html#topic+graph-class">graph</a>.

</p>
</li></ul>



<h3>Generation and Export</h3>

<p>It may be convenient for R users to autogenerate a Solr schema from a
prototypical data frame. Note that to harness the full power of Solr,
it pays to get familiar with the details. After deriving a schema with
<code>deriveSolrSchema</code>, save it to the standard XML format with
<code>saveXML</code>. See the vignette for an example.
</p>

<ul>
<li>
<p><code>deriveSolrSchema(x, name, version="1.5", uniqueKey=NULL,
        required=colnames(Filter(Negate(anyEmpty), x)),
        indexed=colnames(x), stored=colnames(x),
        includeVersionField=TRUE)</code>: Derives a <code>SolrSchema</code> from a
data.frame (or data.frame-coercible) <code>x</code>. The <code>name</code>
is taken by quoting <code>x</code>, by default. Specify a unique key
via <code>uniqueKey</code>. The <code>required</code> fields are those that
are not allowed to contain missing/empty values. By default, we
guess that a field is required if it does not contain any NAs or
empty strings (both are the same as far as Solr is
concerned). The <code>indexed</code> and <code>stored</code> arguments name
the fields that should be indexed and stored, respectively (see
Solr docs for details). If <code>includeVersionField</code> is
<code>TRUE</code>, the magic <code>_version_</code> field is added to the
schema, and Solr will use it to track document versions, which
is needed for certain advanced features and generally recommended.

</p>
</li>
<li>
<p><code>saveXML(doc, file = NULL, compression = 0, indent = TRUE,
        prefix = "&lt;?xml version=\"1.0\"?&gt;\n", doctype = NULL, encoding =
        getEncoding(doc), ...)</code>: Writes the schema to XML. See
<code><a href="XML.html#topic+saveXML">saveXML</a></code> for more details.

</p>
</li></ul>



<h3>Author(s)</h3>

<p> Michael Lawrence </p>

<hr>
<h2 id='TestSolr'>Testing Solr</h2><span id='topic+TestSolr'></span>

<h3>Description</h3>

<p>Launches an instance of the embedded Solr and creates a core for
testing and demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestSolr(schema = NULL, start = TRUE, restart = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestSolr_+3A_schema">schema</code></td>
<td>

<p>The <code><a href="#topic+SolrSchema-class">SolrSchema</a></code> object describing the schema for
the new Solr core
</p>
</td></tr>
<tr><td><code id="TestSolr_+3A_start">start</code></td>
<td>

<p>Whether to actually start the server (it can be started later by
interacting with the returned object). If there is already a server
running, the return value points to that instance.
</p>
</td></tr>
<tr><td><code id="TestSolr_+3A_restart">restart</code></td>
<td>

<p>Force the Solr server to restart.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of <code>ExampleSolr</code>, a reference class. Typically, one
just accesses the <code>uri</code> field, and passes it to a constructor of
<code>SolrFrame</code> or <code>SolrCore</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Lawrence
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
