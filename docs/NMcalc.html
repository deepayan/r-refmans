<!DOCTYPE html><html lang="en-US"><head><title>Help for package NMcalc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMcalc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CV'><p>Calculate coefficient of variation of data</p></a></li>
<li><a href='#CVlnorm'><p>CV of log-normal dist baed on omega parameters</p>
CV based variance like provided in Nonmem's <code>OMEGA</code> metrix.</a></li>
<li><a href='#invlogit'><p>Inverse logit function</p></a></li>
<li><a href='#logit'><p>Logit function</p></a></li>
<li><a href='#means'><p>calculate arithmetic or geometric mean and confidence intervals</p></a></li>
<li><a href='#quantbin'><p>Bin observations by quantiles. Label by bin number or by interval.</p></a></li>
<li><a href='#seqlog'><p>Log-scale equidistant sequences</p></a></li>
<li><a href='#signif2'><p>round to fixed number of significant digits</p></a></li>
<li><a href='#trapez'><p>trapezoidal area under the curve on linear scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Basic Calculations for PK/PD Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Delff &lt;philip@delff.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Essentials for PK/PD (pharmacokinetics/pharmacodynamics) such as area under the curve, (geometric) coefficient of variation, and other calculations that are not part of base R. This is not a noncompartmental analysis (NCA) package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, ggplot2</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/philipdelff/NMdata/issues">https://github.com/philipdelff/NMdata/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-26 17:07:33 UTC; philipde</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Delff [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-26 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CV'>Calculate coefficient of variation of data</h2><span id='topic+CV'></span>

<h3>Description</h3>

<p>Calculate coefficient of variation of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV(x, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CV_+3A_x">x</code></td>
<td>
<p>The data</p>
</td></tr>
<tr><td><code id="CV_+3A_log">log</code></td>
<td>
<p>If TRUE, the geometric coefficient of variation is
calculated. This is sqrt(exp(var(log(x))-1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used on data. For a
log-normal THETA1*EXP(ETA(1)) 'Nonmem' parameter, do
CV=sqrt(exp(OMEGA[1,1])-1).
</p>


<h3>Value</h3>

<p>A numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(139)
x1 &lt;- rnorm(1000,mean=5)
CV(x1)
CV(x1,log=TRUE)
x2 &lt;- exp(x1)
CV(x2)
CV(x2,log=TRUE)
</code></pre>

<hr>
<h2 id='CVlnorm'>CV of log-normal dist baed on omega parameters
CV based variance like provided in Nonmem's <code>OMEGA</code> metrix.</h2><span id='topic+CVlnorm'></span>

<h3>Description</h3>

<p>CV of log-normal dist baed on omega parameters
CV based variance like provided in Nonmem's <code>OMEGA</code> metrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CVlnorm(omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CVlnorm_+3A_omega">omega</code></td>
<td>
<p>A variance as provided in diagonal om the Nonmem OMEGA matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a very simple function. All it does is
<code>sqrt(exp(omega)-1)</code>.
</p>


<h3>Value</h3>

<p>CV of the distribution (numeric)
</p>

<hr>
<h2 id='invlogit'>Inverse logit function</h2><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Inverse logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invlogit_+3A_x">x</code></td>
<td>
<p>a number to transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric
</p>


<h3>See Also</h3>

<p>logit
</p>

<hr>
<h2 id='logit'>Logit function</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>a number to transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric
</p>


<h3>See Also</h3>

<p>invlogit
</p>

<hr>
<h2 id='means'>calculate arithmetic or geometric mean and confidence intervals</h2><span id='topic+means'></span>

<h3>Description</h3>

<p>calculate arithmetic or geometric mean and confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means(
  x,
  type = "arithmetic",
  na.rm = FALSE,
  z.rm = FALSE,
  ci = FALSE,
  dist.ci = "t",
  p.ci = 0.95,
  colnames = c("est", "ll", "ul"),
  format = "df"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="means_+3A_x">x</code></td>
<td>
<p>vector to calculate the geometric mean of</p>
</td></tr>
<tr><td><code id="means_+3A_type">type</code></td>
<td>
<p>type of mean or median. Default is arithmetic,
geometric and median are available as well. Only first letters
needed, so say &quot;geo&quot; or even &quot;g&quot; is enough.</p>
</td></tr>
<tr><td><code id="means_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA's before doing calculations?</p>
</td></tr>
<tr><td><code id="means_+3A_z.rm">z.rm</code></td>
<td>
<p>removes zeros before calculation? Default is
FALSE. Can only be TRUE if type=&quot;geometric&quot;.</p>
</td></tr>
<tr><td><code id="means_+3A_ci">ci</code></td>
<td>
<p>if TRUE, a data.frame including point estimate and
confidence interval returned. If FALSE, a numeric representing
the mean value returned.</p>
</td></tr>
<tr><td><code id="means_+3A_dist.ci">dist.ci</code></td>
<td>
<p>The distribution to use for the confidence
interval. Default and only supported is &quot;t&quot;. If
type=geometric, this is applied after transformation to
gaussian.</p>
</td></tr>
<tr><td><code id="means_+3A_p.ci">p.ci</code></td>
<td>
<p>probability covered by confidence interval. Default is
0.95</p>
</td></tr>
<tr><td><code id="means_+3A_colnames">colnames</code></td>
<td>
<p>If ci, this defines the column names of the
resulting data frame. Default is c(&quot;est&quot;,&quot;ll&quot;,&quot;ul&quot;).</p>
</td></tr>
<tr><td><code id="means_+3A_format">format</code></td>
<td>
<p>The format of the result. Possible values are df and
num.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If ci=FALSE, a numeric. If ci=TRUE, a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
means(x, type="arithmetic", ci=TRUE)
means(x, type="geometric", ci=TRUE)
means(x, type="median", ci=TRUE)
library(data.table)
## CRAN requires examples to run on a single thread
data.table::setDTthreads(1)
data.table(x=x)[,append(means(x,ci=TRUE),list(N=.N))]
</code></pre>

<hr>
<h2 id='quantbin'>Bin observations by quantiles. Label by bin number or by interval.</h2><span id='topic+quantbin'></span>

<h3>Description</h3>

<p>This is simple stuff, but I can never remember the exact quantile
and findInterval/cut commands to use. quantbin finds quantiles
using quantile and then assigns bins using either findInterval or
cut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantbin(x, nbins, probs, label = "num", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantbin_+3A_x">x</code></td>
<td>
<p>The observations</p>
</td></tr>
<tr><td><code id="quantbin_+3A_nbins">nbins</code></td>
<td>
<p>Number of bins to use</p>
</td></tr>
<tr><td><code id="quantbin_+3A_probs">probs</code></td>
<td>
<p>Quantiles for construvtion of bins (optional). The
default is to spread <code>nbins</code> quantiles equi-distantly across
the observed values.</p>
</td></tr>
<tr><td><code id="quantbin_+3A_label">label</code></td>
<td>
<p>label=&quot;num&quot; gives a numeric bin number
(findInterval). label=&quot;interval&quot; gives a character
representation of the interval (cut).</p>
</td></tr>
<tr><td><code id="quantbin_+3A_...">...</code></td>
<td>
<p>additional arguments passed to quantile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>quantbin uses stats::quantile for quantile
estimation. Except for x and probs, all parameters can be
controlled using na.rm and ... arguments. See ?stats::quantile
for details.
</p>
<p>na.rm na.rm=TRUE is needed for quantile to be able to estimate the
distribution if x contains NA's. Notice, if na.rm=T, an NA element
in x will still result in an NA element in return. If na.rm=F and
there are NA's in x, all elements will be NA in result (quantiles
cannot be determined, nor can the binning of x by those
quantiles).
</p>
<p>If data is not continuous, this method may not lead to balanced
distributions.
</p>


<h3>Value</h3>

<p>If label=&quot;num&quot;, integers. If label=&quot;interval&quot;, factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(134)
library(data.table)
## CRAN requires examples to run on a single thread
data.table::setDTthreads(1)
dt1 &lt;- data.table(x=rnorm(n=1000))
dt1[,bin:=quantbin(x,nbins=4,label="num")]
dt1[,int:=quantbin(x,nbins=4,label="interval")]
## perfect - flat distribution
dt1[,.N,keyby=.(bin,int)]

dt2 &lt;- data.table(x=c(rnorm(n=100000),NA))
dt2[,bin:=quantbin(x,nbins=4,label="num",na.rm=TRUE)]
dt2[,int:=quantbin(x,nbins=4,label="interval",na.rm=TRUE)]
## perfect - flat distribution
dt2[,.N,keyby=.(bin,int)]
unique(dt2[,.(bin,int)])[order(bin)]


## we may not get a flat distribution in case of discrete observations
dt3 &lt;- data.table(x=c(sample(1:3,100,replace=TRUE)))
dt3[,bin:=quantbin(x,nbins=2,label="num",na.rm=TRUE)]
dt3[,int:=quantbin(x,nbins=2,label="interval",na.rm=TRUE)]
## Not a flat distribution
dt3[,.N,keyby=.(x,bin,int)]
</code></pre>

<hr>
<h2 id='seqlog'>Log-scale equidistant sequences</h2><span id='topic+seqlog'></span>

<h3>Description</h3>

<p>Useful for generating sequences to be plotted on log scale. This
is really simple - seq is run on from and to after log
transformation, then the exponential is reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqlog(from, to, length.out)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqlog_+3A_from">from</code></td>
<td>
<p>start of sequence</p>
</td></tr>
<tr><td><code id="seqlog_+3A_to">to</code></td>
<td>
<p>end of sequence</p>
</td></tr>
<tr><td><code id="seqlog_+3A_length.out">length.out</code></td>
<td>
<p>length of sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x=seqlog(1,100,100))
df &lt;- transform(df, y=x/(10+x))
## Not run: 
library(ggplot2)
## the points are equidistant on the log x scale
ggplot(df,aes(x,y))+geom_point()+scale_x_log10()

## End(Not run)
</code></pre>

<hr>
<h2 id='signif2'>round to fixed number of significant digits</h2><span id='topic+signif2'></span>

<h3>Description</h3>

<p>Even if theoretically correct, the built-in 'R' functions 'round'
and 'signif' can be confusing (see examples). 'signif2' is a
simple solution that can be used for reporting results
consistently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signif2(x, digits = 1, add, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signif2_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="signif2_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to round to. Must be an
integer larger than 0.</p>
</td></tr>
<tr><td><code id="signif2_+3A_add">add</code></td>
<td>
<p>pad with zeros where digits&gt;nchar(x[i]). Currently
not used.</p>
</td></tr>
<tr><td><code id="signif2_+3A_...">...</code></td>
<td>
<p>additional arguments passed to formatC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1.24e-4,1.1334e6,1.1,22.00000,10.00,1)
data.frame(x,s.3=signif(x,3),sc.3=as.character(signif(x,3)),s2.3=signif2(x,3))
signif2(c(.2,11.84),2)
## digits has no effect when x==0
signif2(0,1)
signif2(0,3)
</code></pre>

<hr>
<h2 id='trapez'>trapezoidal area under the curve on linear scale</h2><span id='topic+trapez'></span>

<h3>Description</h3>

<p>This is a numerical integration of y with respect to
x by the trapezoidal method on linear scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapez(x, y, cum = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trapez_+3A_x">x</code></td>
<td>
<p>The vector to integrate y with respect to (typically TIME
to get area under the curve).</p>
</td></tr>
<tr><td><code id="trapez_+3A_y">y</code></td>
<td>
<p>The variable to integrate.</p>
</td></tr>
<tr><td><code id="trapez_+3A_cum">cum</code></td>
<td>
<p>Return the cumulative trapezoidal area under the curve?
If false (default) a single number is returned. If true, a
vector is returned. Notice, the vector is one element shorter
than x and y.</p>
</td></tr>
<tr><td><code id="trapez_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove indexes in x and y wherever x or y are NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
