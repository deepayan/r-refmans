<!DOCTYPE html><html lang="en"><head><title>Help for package Rivivc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rivivc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rivivc-package'>
<p>IVIVC LEVEL A</p></a></li>
<li><a href='#impulse'><p>PK profile after drug intravenous administration</p></a></li>
<li><a href='#input'><p>In vivo absorption of the drug</p></a></li>
<li><a href='#NumConv'>
<p>Numerical convolution</p></a></li>
<li><a href='#NumDeconv'>
<p>Numerical deconvolution method</p></a></li>
<li><a href='#resp'><p>PK profile after drug oral administration</p></a></li>
<li><a href='#RivivcA'>
<p>Level A linear correlation for a single formulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>In Vitro in Vivo Correlation Linear Level "A"</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Aleksander Mendyk &lt;mfmendyk@cyf-kr.edu.pl&gt;, with contributions from Sebastian Polak &lt;mfpolak@@cyf-kr.edu.pl&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aleksander Mendyk &lt;mfmendyk@cyf-kr.edu.pl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>signal, compiler</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>It is devoted to the IVIVC linear level A with numerical deconvolution method. The latter is working for inequal and incompatible timepoints between impulse and response curves. A numerical convolution method is also available. Application domains include pharamaceutical industry QA/QC and R&amp;D together with academic research.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-23 23:01:17 UTC; olo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-23 23:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rivivc-package'>
IVIVC LEVEL A
</h2><span id='topic+Rivivc-package'></span><span id='topic+Rivivc'></span>

<h3>Description</h3>

<p>This package performs linear iv vitro in vivo correlation of linear level A. It provides numerical convolution/deconvolution procedures with unequal time steps and no assumptions about the function shapes. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Rivivc</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2012-10-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPLv3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Aleksander Mendyk and Sebastian Polak
</p>
<p>Maintainer: Aleksander Mendyk &lt;mfmendyk@cyf-kr.edu.pl&gt;
</p>


<h3>References</h3>

<p>Langenbucher (2003) F. Handling of computational in vitro/in vivo correlation problems by Microsoft Excel: III. Convolution and deconvolution. <em>Eur J Pharm Biopharm.</em> <b>56</b>, 429-37.
</p>

<hr>
<h2 id='impulse'>PK profile after drug intravenous administration</h2><span id='topic+impulse'></span>

<h3>Description</h3>

<p>This data set gives the time and concentration of the hypothetical drug after its intravenous administration. This is the simulated data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(impulse)</code></pre>


<h3>Format</h3>

<p>matrix</p>

<hr>
<h2 id='input'>In vivo absorption of the drug</h2><span id='topic+input'></span>

<h3>Description</h3>

<p>This data set gives the time and cumulative amount of the hypothetical drug absorbed. It is also used as in vitro dissolution for Rivivc example of IVIVC level A. This is the simulated data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(input)</code></pre>


<h3>Format</h3>

<p>matrix</p>

<hr>
<h2 id='NumConv'>
Numerical convolution
</h2><span id='topic+NumConv'></span>

<h3>Description</h3>

<p>Performs numerical convolution independent of the sampling points but requiring the same timescale of the input and impulse profiles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumConv(impulse.matrix,input.matrix,conv.timescale = NULL,
    explicit.interpolation = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NumConv_+3A_impulse.matrix">impulse.matrix</code></td>
<td>

<p>matrix of the PK profile after the drug intravenous (i.v.) administration 
</p>
</td></tr>
<tr><td><code id="NumConv_+3A_input.matrix">input.matrix</code></td>
<td>

<p>cumulative in vivo absorption profile
</p>
</td></tr>
<tr><td><code id="NumConv_+3A_conv.timescale">conv.timescale</code></td>
<td>

<p>a timescale of convolution defined either as a whole vector with specific timepoints <code>c(t1,t2,...tN)</code> or two-element vector containing only lower and upper boundery of the required prediction timescale <code>c(lower,upper)</code>; in the latter case system creates the time vector based on the parameter <code>explicit.interpolation</code>; if omitted it computes convolution timescale based on the input matrix
</p>
</td></tr>
<tr><td><code id="NumConv_+3A_explicit.interpolation">explicit.interpolation</code></td>
<td>

<p>sampling accuracy used by the interpolation method to find the same timepoints for input and impulse profiles
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output values are:
</p>
<table role = "presentation">
<tr><td><code>$par</code></td>
<td>
<p> convolved time profile based on the original timescale</p>
</td></tr>
<tr><td><code>$par_explicit</code></td>
<td>
<p>provides convolution with the explicit interpolation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksander Mendyk and Sebastian Polak
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NumDeconv">NumDeconv</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(Rivivc)
require(graphics)

#i.v. data
data("impulse")
#p.o. PK profile
data("resp")
#in vitro dissolution for correlation purposes
data("input")

#preparing data matrices
input_mtx&lt;-as.matrix(input)
impulse_mtx&lt;-as.matrix(impulse)
resp_mtx&lt;-as.matrix(resp)

#setting interpolation accuracy
accur_explic&lt;-1000

#run convolution
result&lt;-NumConv(impulse_mtx,input_mtx,explicit.interp=accur_explic)

print("Raw results")
print(result$par)

print("Raw results explicit")
print(result$par_explicit)

dev.new()
plot(resp_mtx)
lines(result$par, type="l", col="blue")

dev.new()
plot(resp_mtx)
lines(result$par_explicit, type="l", col="blue")

</code></pre>

<hr>
<h2 id='NumDeconv'>
Numerical deconvolution method
</h2><span id='topic+NumDeconv'></span>

<h3>Description</h3>

<p>Numerical deconvolution method based on the convolution and the <code>optim()</code> BFGS method to find in vivo absorption profile through the convolution approach. The function works iteratively with the cumulative in vivo absorption profile optimization performed by the BFGS method in regard to the convolved PK profile and its proximity to the real known p.o. profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumDeconv(impulse.matrix,resp.matrix,dose_iv=NULL,dose_po=NULL, 
	    deconv.timescale = NULL, explicit.interpolation = 20, 
	    implicit.interpolation = 10, optim.maxit = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NumDeconv_+3A_impulse.matrix">impulse.matrix</code></td>
<td>

<p>matrix of the PK profile after the drug intravenous (i.v.) administration 
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_resp.matrix">resp.matrix</code></td>
<td>

<p>PK profile after oral (p.o.) administration of the drug
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_dose_iv">dose_iv</code></td>
<td>

<p>drug dose after i.v. administration; not obligatory but if provided must be in the same units like the dose p.o.
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_dose_po">dose_po</code></td>
<td>

<p>drug dose after p.o. administration; not obligatory but if provided must be in the same units like the dose i.v.
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_deconv.timescale">deconv.timescale</code></td>
<td>

<p>a timescale of deconvolution defined either as a whole vector with specific timepoints <code>c(t1,t2,...tN)</code> or two-element vector containing only lower and upper boundery of the required prediction timescale <code>c(lower,upper)</code>; in the latter case system creates the time vector based on the parameter <code>explicit.interpolation</code>; if omitted it computes deconvolution timescale based on the impulse matrix
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_explicit.interpolation">explicit.interpolation</code></td>
<td>

<p>deconvolution explicit interpolation parameter, namely number of the curve interpolation points used directly by the <code>optim()</code> method
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_implicit.interpolation">implicit.interpolation</code></td>
<td>

<p>implicit interpolation  - a factor multiplying <code>explicit.interpolation</code> for better accuracy
</p>
</td></tr>
<tr><td><code id="NumDeconv_+3A_optim.maxit">optim.maxit</code></td>
<td>

<p>maximum number of iterations used by <code>optim()</code> method
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is an empirical approach to the deconvolution method with minimum mechanistic assumptions. Yet the latter involve kinetics linearity when the doses of i.v. and p.o. are different, thus the i.v. profile is scaled by multiplication with the factor of <code>dose_po/dose_iv</code>. It is also important to know that large values of explicit and/or implicit accuracy lead to the long execution times. The recommended values are <code>explicit = 20</code> and <code>implicit = 10</code>, however this is only a rule of thumb used here. When looking for higher accuracy it is advisable to increase implicit interpolation prior to the explicit.
</p>


<h3>Value</h3>

<p>Three matrices are returned at the output of the function:
</p>
<table role = "presentation">
<tr><td><code>$par</code></td>
<td>
<p>represents original timescale provided at the input</p>
</td></tr>
<tr><td><code>$par_explicit</code></td>
<td>
<p>provides deconvolution with the explicit interpolation</p>
</td></tr>
<tr><td><code>$par_implicit</code></td>
<td>
<p>provides deconvolution with the implicit interpolation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksander Mendyk and Sebastian Polak
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RivivcA">RivivcA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(Rivivc)
require(graphics)

#i.v. data
data("impulse")
#p.o. PK profile
data("resp")
#in vitro dissolution for correlation purposes
data("input")

#preparing data matrices
input_mtx&lt;-as.matrix(input)
impulse_mtx&lt;-as.matrix(impulse)
resp_mtx&lt;-as.matrix(resp)

#setting accuracy for both interpolation modes
accur_explic&lt;-10
accur_implic&lt;-5


#for deconvolution
result&lt;-NumDeconv(impulse_mtx,resp_mtx,explicit.interp=accur_explic,implicit.interp=accur_implic)


print("Raw results")
print(result$par)

print("Explicit interpolation")
print(result$par_explicit)


print("Implicit interpolation")
print(result$par_implicit)

#let's compare the deconvolved curve with known input
dev.new()
plot(input_mtx)
lines(result$par, type="l", col="blue")


</code></pre>

<hr>
<h2 id='resp'>PK profile after drug oral administration</h2><span id='topic+resp'></span>

<h3>Description</h3>

<p>This data set gives the time and concentration of the hypothetical drug after its oral administration. This is the simulated data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(resp)</code></pre>


<h3>Format</h3>

<p>matrix</p>

<hr>
<h2 id='RivivcA'>
Level A linear correlation for a single formulation
</h2><span id='topic+RivivcA'></span>

<h3>Description</h3>

<p>This is the major function to be called where numerical convolution ad/or deconvolution might be used for a linear in vitro in vivo correlation level A. It performes either numerical convolution via /codeNumConv() or deconvolution via /codeNumDeconv() and correlates their results with the known.data object via linear regression <code>lm()</code>. If you just want raw results of convolution/deconvolution then call explicitely <code><a href="#topic+NumConv">NumConv</a></code> or <code>link{NumDeconv}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RivivcA(known.data, impulse.data, second.profile.data,dose_iv=NULL,dose_po=NULL, 
	mode = "deconv", explicit.interp = 20, implicit.interp = 10, 
	optimization.maxit = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RivivcA_+3A_known.data">known.data</code></td>
<td>

<p>the data matrix to be correlated with; depending on the state of the <code>mode</code> variable it represents either in vitro dissolution profile (<code>mode = "deconv"</code>) or PK profile after oral administration of the drug (<code>mode="conv"</code>)
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_impulse.data">impulse.data</code></td>
<td>

<p>matrix of the PK profile after the drug i.v. administration 
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_second.profile.data">second.profile.data</code></td>
<td>

<p>matrix of the second PK profile; depending on the <code>mode</code> variable it represents either PK profile after oral administration of the drug (<code>mode = "deconv"</code>) or a drug cumulative absorption profile (<code>mode="conv"</code>), sometimes substituted directly by the in vitro dissolution profile
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_dose_iv">dose_iv</code></td>
<td>

<p>drug dose after i.v. administration; not obligatory but if provided must be in the same units like the dose p.o.
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_dose_po">dose_po</code></td>
<td>

<p>drug dose after p.o. administration; not obligatory but if provided must be in the same units like the dose i.v.
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_mode">mode</code></td>
<td>

<p>represents the method used here; two states are allowed: <code>mode="conv"</code> for numerical convolution method or <code>mode="deconv"</code> for numerical deconvolution (default)
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_explicit.interp">explicit.interp</code></td>
<td>

<p>convolution and deconvolution explicit interpolation parameter, namely number of the curve interpolation points
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_implicit.interp">implicit.interp</code></td>
<td>

<p>implicit interpolation  - a factor multiplying <code>explicit.interp</code> for better accuracy; applies to the deconvolution procedure only
</p>
</td></tr>
<tr><td><code id="RivivcA_+3A_optimization.maxit">optimization.maxit</code></td>
<td>

<p>maximum number of iterations used by <code>optim()</code> method; applies to the deconvolution procedure only
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function represents either convolution or deconvolution data together with linear regression of the above functions outputs and known data supplied as a parameter. Please bear in mind that NumDeconv() procedure is iterative and therefore depending on the parameters might require substantial amount of time to converge. Please refer to the <code><a href="#topic+NumDeconv">NumDeconv</a></code> description.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>$regression</code></td>
<td>
<p>returns a whole object of the linear regression - a result from the <code>lm()</code> procedure</p>
</td></tr>
<tr><td><code>$numeric</code></td>
<td>
<p>returns results from <code>NumConv()</code> or <code>NumDeconv()</code> functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aleksander Mendyk and Sebastian Polak
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NumConv">NumConv</a></code>, <code><a href="#topic+NumDeconv">NumDeconv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(Rivivc)
require(graphics)

#i.v. data
data("impulse")
#p.o. PK profile
data("resp")
#in vitro dissolution for correlation purposes
data("input")

#preparing data matrices
input_mtx&lt;-as.matrix(input)
impulse_mtx&lt;-as.matrix(impulse)
resp_mtx&lt;-as.matrix(resp)

#setting accuracy
accur_explic&lt;-20
accur_implic&lt;-5

#run deconvolution
result&lt;-RivivcA(input_mtx,impulse_mtx,resp_mtx,
    explicit.interp=accur_explic,implicit.interp=accur_implic)

summary(result$regression)

print("Raw results of deconvolution")
print(result$numeric$par)

predicted&lt;-predict(result$regression)
deconvolved_data&lt;-unname(predicted)
orig_data&lt;-input_mtx[,2]

dev.new()
plot(orig_data,result$numeric$par[,2])
lines(orig_data,deconvolved_data, type="l", col="blue")
dev.new()
plot(input_mtx)
lines(result$numeric$par, type="l", col="blue")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
