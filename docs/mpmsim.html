<!DOCTYPE html><html><head><title>Help for package mpmsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mpmsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_mpm_error'><p>Add sampling error to matrix population models (MPMs) based on expected</p>
values of transition rates and sample sizes</a></li>
<li><a href='#calculate_errors'><p>Calculate error (standard error or 95%CI) in elements of a matrix population</p>
model.</a></li>
<li><a href='#compute_ci'><p>Compute 95% confidence intervals for derived estimates from a matrix</p>
population model</a></li>
<li><a href='#driven_vital_rate'><p>Calculate driven vital rates</p></a></li>
<li><a href='#generate_mpm_set'><p>Generate lists of Lefkovitch matrix population models (MPMs) based on life</p>
history archetypes</a></li>
<li><a href='#make_leslie_mpm'><p>Create a Leslie matrix population model</p></a></li>
<li><a href='#model_fertility'><p>Model fertility with age using set functional forms</p></a></li>
<li><a href='#model_survival'><p>Model mortality hazard, survivorship and age-specific survival probability</p>
using a mortality model</a></li>
<li><a href='#mpmsim-package'><p>mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics</p></a></li>
<li><a href='#plot_matrix'><p>Plot a matrix as a heatmap</p></a></li>
<li><a href='#random_mpm'><p>Generate random Lefkovitch matrix population models (MPMs) based on life</p>
history archetypes</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Simulation of Matrix Population Models with Defined Life History
Characteristics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows users to simulate matrix population models with
    particular characteristics based on aspects of life history such as
    mortality trajectories and fertility trajectories. Also allows the
    exploration of sampling error due to small sample size.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jonesor/mpmsim">https://github.com/jonesor/mpmsim</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jonesor/mpmsim/issues">https://github.com/jonesor/mpmsim/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, grDevices, popbio, popdemo, reshape,
Rcompadre, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggfortify, knitr, Rage, rmarkdown, testthat (&ge; 3.0.0),
viridis</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 20:44:58 UTC; jones</td>
</tr>
<tr>
<td>Author:</td>
<td>Owen Jones <a href="https://orcid.org/0000-0001-5720-4686"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Owen Jones &lt;jones@biology.sdu.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 21:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_mpm_error'>Add sampling error to matrix population models (MPMs) based on expected
values of transition rates and sample sizes</h2><span id='topic+add_mpm_error'></span>

<h3>Description</h3>

<p>Produces a list of matrix population models based on expected values in the
transition matrix and sample size. The expected values are provided in lists
of two submatrices: <code>mat_U</code> for the growth/development and survival
transitions and <code>mat_F</code> for the fecundity transitions. The output <code>mat_U</code>
values are simulated based on expected probabilities, assuming a binomial
process with a sample size defined by <code>sample_size</code>. The output <code>mat_F</code>
values are simulated using a Poisson process with a sample size defined by
<code>sample_size</code>.Thus users can expect that large sample sizes will result in
simulated matrices that match closely with the expectations, while simulated
matrices with small sample sizes will be more variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mpm_error(mat_U, mat_F, sample_size, split = TRUE, by_type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_mpm_error_+3A_mat_u">mat_U</code></td>
<td>
<p>A list of U submatrices, or a single U submatrix.</p>
</td></tr>
<tr><td><code id="add_mpm_error_+3A_mat_f">mat_F</code></td>
<td>
<p>A list of F submatrices, or a single F submatrix.</p>
</td></tr>
<tr><td><code id="add_mpm_error_+3A_sample_size">sample_size</code></td>
<td>
<p>either (1) a single matrix of sample sizes for each
element of every MPM, (2) a list of two named matrices (&quot;<code>mat_F_ss</code>&quot;,
&quot;<code>mat_U_ss</code>&quot;) containing sample sizes for the survival and fertility
submatrices of every MPM or (3) a single value applied to the every element
of every matrix.</p>
</td></tr>
<tr><td><code id="add_mpm_error_+3A_split">split</code></td>
<td>
<p>logical, whether to split the output into survival and fecundity
matrices or not. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_mpm_error_+3A_by_type">by_type</code></td>
<td>
<p>A logical indicating whether the matrices should be returned
in a list by type (A, U, F, C). If split is <code>FALSE</code>, then <code>by_type</code> must
also be <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if any <code>sample_size</code> input is 0, it is assumed that the estimate for
the element(s) concerned is known without error.
</p>


<h3>Value</h3>

<p>list of matrices of survival and fecundity if <code>split = TRUE</code>,
otherwise a single matrix of the sum of survival and fecundity.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>See Also</h3>

<p>Other errors: 
<code><a href="#topic+calculate_errors">calculate_errors</a>()</code>,
<code><a href="#topic+compute_ci">compute_ci</a>()</code>
</p>
<p>Other errors: 
<code><a href="#topic+calculate_errors">calculate_errors</a>()</code>,
<code><a href="#topic+compute_ci">compute_ci</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) # set seed for repeatability

# First generate a set of MPMs
mpm_set &lt;- generate_mpm_set(n = 5, n_stages = 5, fecundity = c(
  0, 0, 4, 8, 10
), archetype = 4, split = TRUE, by_type = TRUE, as_compadre = FALSE)

# Now apply sampling error to this set
add_mpm_error(
  mat_U = mpm_set$U_list, mat_F = mpm_set$F_list, sample_size =
    50
)

# Also works with a single matrix.
mats &lt;- make_leslie_mpm(
  survival = c(0.1, 0.2, 0.5),
  fertility = c(0, 1.2, 2.4),
  n_stages = 3, split = TRUE
)

# Sample size is a single value
add_mpm_error(mat_U = mats$mat_U, mat_F = mats$mat_F, sample_size = 20)

# Sample size is a list of two matrices
# here with a sample size of 20 for reproduction and 10 for growth/survival.
mpm_set &lt;- generate_mpm_set(
  n = 5, n_stages = 3, fecundity = c(0, 2, 4),
  archetype = 4, split = TRUE, by_type = TRUE,
  as_compadre = FALSE
)

ssMats &lt;- list(
  "mat_F_ss" = matrix(20, nrow = 3, ncol = 3),
  "mat_U_ss" = matrix(10, nrow = 3, ncol = 3)
)

# Add sampling error to the matrix models
output &lt;- add_mpm_error(
  mat_U = mpm_set$U_list, mat_F = mpm_set$F_list,
  sample_size = ssMats
)

# Examine the outputs
names(output)
output

</code></pre>

<hr>
<h2 id='calculate_errors'>Calculate error (standard error or 95%CI) in elements of a matrix population
model.</h2><span id='topic+calculate_errors'></span>

<h3>Description</h3>

<p>Given two submatrices of a matrix population model (<code>mat_U</code> and <code>mat_F</code>, the
growth/survival matrix and the reproduction matrix respectively) and a sample
size, or matrix/matrices of sample sizes, this function calculates the
standard error or 95% confidence interval (95%CI) for each element of the
matrix. These calculations assume that <code>mat_U</code> is the result of binomial
processes (i.e., the survival (0/1) of a sample of n individuals), while
<code>mat_F</code> is the result of Poisson processes (i.e., counts of offspring from n
individuals), where n is the sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_errors(mat_U, mat_F, sample_size, type = "sem", calculate_A = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_errors_+3A_mat_u">mat_U</code></td>
<td>
<p>matrix of mean survival probabilities</p>
</td></tr>
<tr><td><code id="calculate_errors_+3A_mat_f">mat_F</code></td>
<td>
<p>matrix of mean fecundity values</p>
</td></tr>
<tr><td><code id="calculate_errors_+3A_sample_size">sample_size</code></td>
<td>
<p>either (1) a single matrix of sample sizes for each
element of the MPM, (2) a list of two named matrices (&quot;<code>mat_F_ss</code>&quot;,
&quot;<code>mat_U_ss</code>&quot;) containing sample sizes for the survival and fertility
submatrices of the MPM or (3) a single value applied to the whole matrix</p>
</td></tr>
<tr><td><code id="calculate_errors_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of error to calculate.
Must be one of &quot;<code>sem</code>&quot; (standard error), or &quot;<code>CI95</code>&quot; (95% confidence
interval).</p>
</td></tr>
<tr><td><code id="calculate_errors_+3A_calculate_a">calculate_A</code></td>
<td>
<p>A logical argument indicating whether the returned error
information should include the A matrix and its error. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a list containing the original matrices and matrices showing
error estimates or confidence intervals.
</p>


<h3>Value</h3>

<p>A list containing the original matrices and the error estimates (or
upper and lower confidence intervals) for the U, F and (optionally) A
matrices.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_mpm_error">add_mpm_error()</a></code> which simulates matrices with known values and
sample sizes.
</p>
<p>Other errors: 
<code><a href="#topic+add_mpm_error">add_mpm_error</a>()</code>,
<code><a href="#topic+compute_ci">compute_ci</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set up two submatrices
matU &lt;- matrix(c(
  0.1, 0,
  0.2, 0.4
), byrow = TRUE, nrow = 2)
matF &lt;- matrix(c(
  0, 4,
  0., 0.
), byrow = TRUE, nrow = 2)

# errors as 95% CI, with a sample size of 20 for all elements
calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = "CI95")

# errors as sem, with a sample size of 20 for all elements
calculate_errors(mat_U = matU, mat_F = matF, sample_size = 20, type = "sem")

# Sample size is a single matrix applied to both F and U matrices
ssMat &lt;- matrix(10, nrow = 2, ncol = 2)

calculate_errors(
  mat_U = matU, mat_F = matF, sample_size = ssMat, type =
    "sem"
)

# Sample size is a list of two matrices, one for F and one for U.
ssMats &lt;- list(
  "mat_F_ss" = matrix(10, nrow = 2, ncol = 2),
  "mat_U_ss" = matrix(10, nrow = 2, ncol = 2)
)
calculate_errors(
  mat_U = matU, mat_F = matF, sample_size = ssMats, type =
    "sem"
)

</code></pre>

<hr>
<h2 id='compute_ci'>Compute 95% confidence intervals for derived estimates from a matrix
population model</h2><span id='topic+compute_ci'></span>

<h3>Description</h3>

<p>This function computes the 95% confidence interval for measures derived from
a matrix population model using parametric bootstrapping. In this approach a
sampling distribution of the matrix population model (MPM) is generated by
taking a large number of random independent draws using the sampling
distribution of each underlying transition rate. The approach rests on our
assumption that survival-related processes are binomial, while reproduction
is a Poisson process (see the function <code>add_mpm_error()</code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_ci(mat_U, mat_F, sample_size, FUN, ..., n_sim = 1000, dist.out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_ci_+3A_mat_u">mat_U</code></td>
<td>
<p>A matrix that describes the growth and survival process.</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_mat_f">mat_F</code></td>
<td>
<p>A matrix that describes reproduction.</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_sample_size">sample_size</code></td>
<td>
<p>either (1) a single matrix of sample sizes for each
element of the MPM, (2) a list of two named matrices (&quot;<code>mat_F_ss</code>&quot;,
&quot;<code>mat_U_ss</code>&quot;) containing sample sizes for the survival and fertility
submatrices of the MPM or (3) a single value applied to the whole matrix</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_fun">FUN</code></td>
<td>
<p>A function to apply to each simulated matrix population model.
This function must take, as input, a single matrix population model (i.e.,
the A matrix).</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_n_sim">n_sim</code></td>
<td>
<p>An integer indicating the number of simulations to run. Default
is 1000.</p>
</td></tr>
<tr><td><code id="compute_ci_+3A_dist.out">dist.out</code></td>
<td>
<p>Logical. If TRUE, returns a list with both the quantiles and
the simulated estimates. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs are the U matrix, which describes the survival-related processes,
and the F matrix which describes reproduction. The underlying assumption is
that the U matrix is the average of a binomial process while the F matrix is
the average of a Poisson process . The confidence interval will depend
largely on the sample size used.
</p>


<h3>Value</h3>

<p>If dist.out is FALSE, a numeric vector of the 2.5th and 97.5th
quantiles of the estimated measures. If <code>dist.out = TRUE</code>, a list with two
elements: <code>quantiles</code> and <code>estimates</code>. <code>quantiles</code> is a numeric vector of
the 2.5th and 97.5th quantiles of the estimated measures, and <code>estimates</code>
is a numeric vector of the estimated measures.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Chapter 12 in Caswell, H. (2001). Matrix Population Models.
Sinauer Associates Incorporated.
</p>


<h3>See Also</h3>

<p>Other errors: 
<code><a href="#topic+add_mpm_error">add_mpm_error</a>()</code>,
<code><a href="#topic+calculate_errors">calculate_errors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) # set seed for repeatability

# Data for use in example
matU &lt;- matrix(c(
  0.1, 0.0,
  0.2, 0.4
), byrow = TRUE, nrow = 2)

matF &lt;- matrix(c(
  0.0, 5.0,
  0.0, 0.0
), byrow = TRUE, nrow = 2)

set.seed(42)

# Example of use to calculate 95% CI of lambda
compute_ci(
  mat_U = matU, mat_F = matF, sample_size = 10, FUN =
    popbio::lambda
)

# Example of use to calculate 95% CI of generation time
compute_ci(
  mat_U = matU, mat_F = matF, sample_size = 40, FUN =
    popbio::generation.time
)

# Example of use to calculate 95% CI of generation time and show the
# distribution of those bootstrapped estimates
xx &lt;- compute_ci(
  mat_U = matU, mat_F = matF, sample_size = 100, FUN =
    popbio::generation.time, dist.out = TRUE
)
summary(xx$quantiles)
hist(xx$estimates)

</code></pre>

<hr>
<h2 id='driven_vital_rate'>Calculate driven vital rates</h2><span id='topic+driven_vital_rate'></span>

<h3>Description</h3>

<p>This function calculates new values for a vital rate, such as survival or
fecundity that is being influenced by a driver (e.g., weather). It does this
by using a driver variable and a baseline value, along with a specified slope
for the relationship between the driver variable and the vital rate. The
function works on a linearised scale, using logit for survival and log for
fecundity, and takes into account the error standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driven_vital_rate(
  driver,
  baseline_value = NULL,
  slope = NULL,
  baseline_driver = NULL,
  error_sd = 0,
  link = "logit"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="driven_vital_rate_+3A_driver">driver</code></td>
<td>
<p>A vector of driver values.</p>
</td></tr>
<tr><td><code id="driven_vital_rate_+3A_baseline_value">baseline_value</code></td>
<td>
<p>A vector or matrix of baseline values for the vital
rate (e.g., survival) that is being influenced (&quot;driven&quot;) by another
variable (e.g. a climatic variable).</p>
</td></tr>
<tr><td><code id="driven_vital_rate_+3A_slope">slope</code></td>
<td>
<p>A vector or matrix of slopes for the relationship between the
driver variable and the vital rate being driven.</p>
</td></tr>
<tr><td><code id="driven_vital_rate_+3A_baseline_driver">baseline_driver</code></td>
<td>
<p>The <code>baseline_driver</code> parameter is a single value
representing the baseline driver value. If the driver value is greater than
this value and the slope is positive, then the resulting vital rate will be
higher. Conversely, if the driver value is less than this variable and the
slope is positive, then the resulting vital rate will be less than the
baseline value.</p>
</td></tr>
<tr><td><code id="driven_vital_rate_+3A_error_sd">error_sd</code></td>
<td>
<p>A vector or matrix of error standard deviations for random
normal error to be added to the driven value of the vital rate being
modelled. If set to 0 (the default), no error is added.</p>
</td></tr>
<tr><td><code id="driven_vital_rate_+3A_link">link</code></td>
<td>
<p>A character string indicating the type of link function to use.
Valid values are &quot;<code>logit</code>&quot; (the default) and &quot;<code>log</code>&quot;, which are appropriate
for survival (U submatrix) and reproduction (F submatrix) respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relationship between the driver variable and the vital rate is assumed to
be linear:
</p>
<p>$$V = a * (d - d_b) + x + E$$
</p>
<p>Where $$V$$ is the new vital rate (on the scale of the linear predictor),
$$a$$ is the slope, $$x$$ is the baseline vital rate, $$d$$ is the driver,
$$d_b$$ is the baseline driver and $$E$$ is the error.
</p>
<p>The input vital rate(s) (<code>baseline_value</code>) can be a single-element vector
representing a single vital rate (e.g., survival probability or fecundity), a
longer vector representing a series of vital rates (e.g., several survival
probabilities or fecundity values), or a matrix of values (e.g., a U or F
submatrix of a matrix population model). The <code>slope</code>s of the relationship
between the vital rate (<code>baseline_value</code>) and the driver can be provided as a
single value, which is applied to all elements of the input vital rates, or
as a matrix of values that map onto the matrix of vital rates. This allows
users to simulate cases where different vital rates in a matrix model are
affected in different ways by the same weather driver. For example, juvenile
survival might be more affected by the driver than adult survival. The
<code>baseline_driver</code> value represents the &quot;normal&quot; state of the driver. If the
driver is greater than the <code>baseline_driver</code> and the <code>slope</code> is positive,
then the outcome vital rate will be higher. If the driver is less than the
<code>baseline_driver</code> variable and the <code>slope</code> is positive, then the outcome
vital rate will be less than the <code>baseline_value.</code> The <code>error_sd</code> represents
the error in the linear relationship between the driver and the vital rate.
</p>


<h3>Value</h3>

<p>Depending on the input types, either a single value, a vector or a
list of matrices of driven values for the vital rate(s) being modelled. The
list has a length equal to the length of the <code>driver</code> input parameter.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) # set seed for repeatability

# A single vital rate and a single driver
driven_vital_rate(
  driver = 14,
  baseline_value = 0.5,
  slope = .4,
  baseline_driver = 10,
  error_sd = 0,
  link = "logit"
)

# A single vital rate and a time series of drivers
driven_vital_rate(
  driver = runif(10, 5, 15),
  baseline_value = 0.5,
  slope = .4,
  baseline_driver = 10,
  error_sd = 0,
  link = "logit"
)

# A matrix of survival values (U submatrix of a Leslie model)
# with a series of drivers, and matrices of slopes and errors

lt1 &lt;- model_survival(params = c(b_0 = 0.4, b_1 = 0.5), model = "Gompertz")
lt1$fert &lt;- model_fertility(
  age = 0:max(lt1$x), params = c(A = 10),
  maturity = 3, model = "step"
)

mats &lt;- make_leslie_mpm(
  survival = lt1$px, fertility = lt1$fert, n_stages =
    nrow(lt1), split = TRUE
)
mats$mat_U
mat_dim &lt;- nrow(mats$mat_U)

driven_vital_rate(
  driver = runif(5, 5, 15),
  baseline_value = mats$mat_U,
  slope = matrix(.4,
    nrow = mat_dim,
    ncol = mat_dim
  ),
  baseline_driver = 10,
  error_sd = matrix(1, nrow = mat_dim, ncol = mat_dim),
  link = "logit"
)

</code></pre>

<hr>
<h2 id='generate_mpm_set'>Generate lists of Lefkovitch matrix population models (MPMs) based on life
history archetypes</h2><span id='topic+generate_mpm_set'></span>

<h3>Description</h3>

<p>This function generates a list of <code>n</code> MPMs according to the specified
criteria. Criteria include the <code>archetype</code>, and the acceptable constraining
criteria, which could include lambda, generation time or any other metric
derived from an A matrix.
The function attempts to find matrices that fulfil the criteria, discarding
unacceptable matrices. By default, if it takes more than 1000 attempts to
find a suitable matrix model, then an error is produced. However, the number
of attempts can be altered with the <code>attempts</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_mpm_set(
  n = 10,
  n_stages = 3,
  archetype = 1,
  fecundity = 1.5,
  split = TRUE,
  by_type = TRUE,
  as_compadre = TRUE,
  max_surv = 0.99,
  constraint = NULL,
  attempts = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_mpm_set_+3A_n">n</code></td>
<td>
<p>The number of MPMs to generate. Default is 10.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_n_stages">n_stages</code></td>
<td>
<p>The number of stages for the MPMs. Default is 3.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_archetype">archetype</code></td>
<td>
<p>The archetype of the MPMs. Default is 1.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_fecundity">fecundity</code></td>
<td>
<p>A vector of fecundities for the MPMs. Default is 1.5.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_split">split</code></td>
<td>
<p>A logical indicating whether to split into submatrices. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_by_type">by_type</code></td>
<td>
<p>A logical indicating whether the matrices should be returned
in a list by type (A, U, F, C). If split is <code>FALSE</code>, then <code>by_type</code> must
also be <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_as_compadre">as_compadre</code></td>
<td>
<p>A logical indicating whether the matrices should be
returned as a <code>CompadreDB</code> object. Default is <code>TRUE</code>. This requires
argument <code>by_type</code> to be <code>TRUE</code>. If <code>FALSE</code>, the function returns a list.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_max_surv">max_surv</code></td>
<td>
<p>The maximum acceptable survival value. Defaults to 0.99. This
is only used if <code>split = TRUE</code>.</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_constraint">constraint</code></td>
<td>
<p>An optional data frame with 4 columns named <code>fun</code>, <code>arg</code>,
<code>lower</code> and <code>upper</code>. These columns specify (1) a function that outputs a
metric derived from an A matrix and (2) an argument for the function (<code>NA</code>,
if no argument supplied) (3) the lower acceptable bound for the metric and
(4) upper acceptable bound for the metric. This could be used to specify</p>
</td></tr>
<tr><td><code id="generate_mpm_set_+3A_attempts">attempts</code></td>
<td>
<p>An integer indicating the number of attempts To be made when
simulating matrix model. The default is 1000. If it takes more than 1000
attempts to make a matrix that satisfies the conditions set by the other
arguments, then a warning is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of MPMs that meet the specified criteria.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random_mpm">random_mpm()</a></code> which this function is essentially a wrapper for.
</p>
<p>Other Lefkovitch matrices: 
<code><a href="#topic+random_mpm">random_mpm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) # set seed for repeatability

# Basic operation, without splitting matrices and with no constraints
generate_mpm_set(
  n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),
  archetype = 4, split = FALSE, by_type = FALSE, as_compadre = FALSE
)

# Constrain outputs to A matrices with lambda between 0.9 and 1.1
library(popbio)
constrain_df &lt;- data.frame(
  fun = "lambda", arg = NA, lower = 0.9, upper =
    1.1
)
generate_mpm_set(
  n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),
  archetype = 4, constraint = constrain_df, as_compadre = FALSE
)

# As above, but using popdemo::eigs function instead of popbio::lambda
# to illustrate use of argument
library(popdemo)
constrain_df &lt;- data.frame(
  fun = "eigs", arg = "lambda", lower = 0.9, upper =
    1.1
)
generate_mpm_set(
  n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),
  archetype = 4, constraint = constrain_df, as_compadre = FALSE
)

# Multiple constraints
# Constrain outputs to A matrices with lambda between 0.9 and 1.1, generation
# time between 3 and 5 and damping ratio between 1 and 7.
library(popbio)
constrain_df &lt;- data.frame(
  fun = c("lambda", "generation.time", "damping.ratio"),
  arg = c(NA, NA, NA),
  lower = c(0.9, 3.0, 1.0),
  upper = c(1.1, 5.0, 7.0)
)
generate_mpm_set(
  n = 10, n_stages = 5, fecundity = c(0, 0, 4, 8, 10),
  archetype = 4, constraint = constrain_df, as_compadre = FALSE
)

</code></pre>

<hr>
<h2 id='make_leslie_mpm'>Create a Leslie matrix population model</h2><span id='topic+make_leslie_mpm'></span>

<h3>Description</h3>

<p>The function creates a Leslie matrix from inputs of number of
stages, fertility (the top row of the matrix), and survival probability
(the value in the sub-diagonal).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_leslie_mpm(survival, fertility, n_stages, split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_leslie_mpm_+3A_survival">survival</code></td>
<td>
<p>a numeric value representing the survival probability of each
stage along the lower off-diagonal of the matrix, with the final value
being in the lower-right corner of the matrix. If only one value is
provided, this is applied to all survival elements.</p>
</td></tr>
<tr><td><code id="make_leslie_mpm_+3A_fertility">fertility</code></td>
<td>
<p>a numeric vector of length n_stages representing the
fertility rate of each stage. If only one value is provided, this is
applied to all fertility elements.</p>
</td></tr>
<tr><td><code id="make_leslie_mpm_+3A_n_stages">n_stages</code></td>
<td>
<p>a numeric value representing the number of stages in the
matrix</p>
</td></tr>
<tr><td><code id="make_leslie_mpm_+3A_split">split</code></td>
<td>
<p>a logical argument indicating whether the output matrix should
be split into separate A, U and F matrices (where A = U + F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size n_stages x n_stages representing the Leslie matrix
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Caswell, H. (2001). Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer.
</p>
<p>Leslie, P. H. (1945). On the use of matrices in certain population
mathematics. Biometrika, 33 (3), 183–212.
</p>
<p>Leslie, P. H. (1948). Some Further Notes on the Use of Matrices in Population
Mathematics. Biometrika, 35(3-4), 213–245.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+model_survival">model_survival()</a></code> to model age-specific survival using mortality models.
</p>
</li>
<li> <p><code><a href="#topic+model_fertility">model_fertility()</a></code> to model age-specific fertility using various
functions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>make_leslie_mpm(
  survival = 0.5, fertility = c(0.1, 0.2, 0.3),
  n_stages = 3, split = FALSE
)
make_leslie_mpm(
  survival = c(0.5, 0.6, 0.7), fertility = c(0.1, 0.2, 0.3),
  n_stages = 3
)
make_leslie_mpm(
  survival = seq(0.1, 0.7, length.out = 4), fertility = 0.1,
  n_stages = 4
)
make_leslie_mpm(
  survival = c(0.8, 0.3, 0.2, 0.1, 0.05), fertility = 0.2,
  n_stages = 5
)

</code></pre>

<hr>
<h2 id='model_fertility'>Model fertility with age using set functional forms</h2><span id='topic+model_fertility'></span>

<h3>Description</h3>

<p>This function computes fertility based on the logistic, step, von
Bertalanffy, Hadwiger, and normal models.
The logistic model assumes that fertility increases sigmoidally with age from
maturity until a maximum fertility is reached.
The step model assumes that fertility is zero before the age of maturity and
then remains constant.
The von Bertalanffy model assumes that, after maturity, fertility increases
asymptotically with age until a maximum fertility is reached. In this
formulation, the model is set up so that fertility is 0 at the 'age of
maturity - 1', and increases from that point.
The Hadwiger model is rather complex and is intended to model human fertility
with a characteristic hump-shaped fertility.
For all models, the output ensures that fertility is zero before the age at
maturity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_fertility(params, age = NULL, maturity = 0, model = "logistic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_fertility_+3A_params">params</code></td>
<td>
<p>A numeric vector of parameters for the selected model. The
number and meaning of parameters depend on the selected model.</p>
</td></tr>
<tr><td><code id="model_fertility_+3A_age">age</code></td>
<td>
<p>A numeric vector representing age.</p>
</td></tr>
<tr><td><code id="model_fertility_+3A_maturity">maturity</code></td>
<td>
<p>A non-negative numeric value indicating the age at maturity.
Whatever model is used, the fertility is forced to be 0 below the age of
maturity.</p>
</td></tr>
<tr><td><code id="model_fertility_+3A_model">model</code></td>
<td>
<p>A character string specifying the model to use. Must be one of
&quot;logistic&quot;, &quot;step&quot;, &quot;vonbertalanffy&quot;,&quot;normal&quot; or &quot;hadwiger&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The required parameters varies depending on the fertility model. The
parameters are provided as a vector and the parameters must be provided in
the order mentioned here.
</p>

<ul>
<li><p> Logistic: <code class="reqn">f(x) = A / (1 + exp(-k  (x - x_m)))</code>
</p>
</li>
<li><p> Step: <code class="reqn">f(x)=
  \begin{cases}
  A, x \geq m \\
  A, x &lt;  m
  \end{cases}</code>
</p>
</li>
<li><p> von Bertalanffy: <code class="reqn">f(x) = A  (1 - exp(-k  (x - x_0)))</code>
</p>
</li>
<li><p> Normal: <code class="reqn">f(x) = A \times \exp\left(
  -\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{\!2}\,\right)</code>
</p>
</li>
<li><p> Hadwiger: <code class="reqn">f(x) = \frac{ab}{c} \left (\frac{c}{x}  \right )
   ^\frac{3}{2} \exp \left \{ -b^2  \left ( \frac{c}{x}+\frac{x}{c}-2
   \right ) \right \}</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector representing the computed fertility values.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Bertalanffy, L. von (1938) A quantitative theory of organic growth (inquiries
on growth laws. II). Human Biology 10:181–213.
</p>
<p>Peristera, P. &amp; Kostaki, A. (2007) Modeling fertility in modern populations.
Demographic Research. 16. Article 6, 141-194 <a href="https://doi.org/10.4054/DemRes.2007.16.6">doi:10.4054/DemRes.2007.16.6</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_survival">model_survival()</a></code> to model age-specific survival using mortality
models.
</p>
<p>Other trajectories: 
<code><a href="#topic+model_survival">model_survival</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute fertility using the step model
model_fertility(age = 0:20, params = c(A = 10), maturity = 2, model = "step")

# Compute fertility using the logistic model
model_fertility(
  age = 0:20, params = c(A = 10, k = 0.5, x_m = 8), maturity =
    0, model = "logistic"
)

# Compute fertility using the von Bertalanffy model
model_fertility(
  age = 0:20, params = c(A = 10, k = .3), maturity = 2, model =
    "vonbertalanffy"
)

# Compute fertility using the normal model
model_fertility(
  age = 0:20, params = c(A = 10, mu = 4, sd = 2), maturity = 0,
  model = "normal"
)

# Compute fertility using the Hadwiger model
model_fertility(
  age = 0:50, params = c(a = 0.91, b = 3.85, c = 29.78),
  maturity = 0, model = "hadwiger"
)

</code></pre>

<hr>
<h2 id='model_survival'>Model mortality hazard, survivorship and age-specific survival probability
using a mortality model</h2><span id='topic+model_survival'></span><span id='topic+model_mortality'></span>

<h3>Description</h3>

<p>Model mortality hazard, survivorship and age-specific survival probability
using a mortality model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_survival(params, age = NULL, model, truncate = 0.01)

model_mortality(params, age = NULL, model, truncate = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_survival_+3A_params">params</code></td>
<td>
<p>Numeric vector representing the parameters of the mortality
model.</p>
</td></tr>
<tr><td><code id="model_survival_+3A_age">age</code></td>
<td>
<p>Numeric vector representing age. The default is <code>NULL</code>, whereby the
survival trajectory is modelled from age 0 to the age at which the
survivorship of the synthetic cohort declines to a threshold defined by the
<code>truncate</code> argument, which has a default of 0.01 (i.e. 1% of the cohort
remaining alive).</p>
</td></tr>
<tr><td><code id="model_survival_+3A_model">model</code></td>
<td>
<p>Mortality model: <code>Gompertz</code>, <code>GompertzMakeham</code>, <code>Exponential</code>,
<code>Siler</code>.</p>
</td></tr>
<tr><td><code id="model_survival_+3A_truncate">truncate</code></td>
<td>
<p>a value defining how the life table output should be
truncated. The default is <code>0.01</code>, indicating that the life table is
truncated so that survivorship, <code>lx</code>, &gt; 0.01 (i.e. the age at which 1% of
the cohort remains alive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The required parameters varies depending on the mortality model. The
parameters are provided as a vector. For <code>Gompertz</code>, the parameters are
<code>b0</code>, <code>b1.</code> For <code>GompertzMakeham</code> the parameters are <code>b0</code>, <code>b1</code> and <code>C</code>.
For <code>Exponential</code>, the parameter is <code>C</code>. For <code>Siler</code>, the parameters are
<code>a0</code>, <code>a1</code>, <code>C</code>, <code>b0</code> and <code>b1</code>. Note that the parameters must be provided
in the order mentioned here. <code>x</code> represents age.
</p>

<ul>
<li><p> Gompertz: <code class="reqn">h_x = b_0 \mathrm{e}^{b_1  x}</code>
</p>
</li>
<li><p> Gompertz-Makeham: <code class="reqn">h_x = b_0 \mathrm{e}^{b_1  x} + c</code>
</p>
</li>
<li><p> Exponential: <code class="reqn">h_x = c</code>
</p>
</li>
<li><p> Siler: <code class="reqn">h_x = a_0 \mathrm{e}^{-a_1  x} + c + b_0 \mathrm{e}^{b_1 x}</code>
</p>
</li></ul>

<p>In the output, the probability of survival (<code>px</code>) (and death (<code>qx</code>))
represent the probability of individuals that enter the age interval
<code class="reqn">[x,x+1]</code> survive until the end of the interval (or die before the end
of the interval). It is not possible to estimate a value for this in the
final row of the life table (because there is no <code class="reqn">x+1</code> value) and
therefore the input values of <code>age</code> (x) may need to be extended to capture this
final interval.
</p>


<h3>Value</h3>

<p>A data frame with columns for age (<code>x</code>), hazard (<code>hx</code>),
survivorship (<code>lx</code>) and mortality (<code>qx</code>) and survival probability within
interval (<code>px</code>).
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Cox, D.R. &amp; Oakes, D. (1984) Analysis of Survival Data. Chapman and Hall,
London, UK.
</p>
<p>Pinder III, J.E., Wiener, J.G. &amp; Smith, M.H. (1978) The Weibull distribution:
a method of summarizing survivorship data. Ecology, 59, 175–179.
</p>
<p>Pletcher, S. (1999) Model fitting and hypothesis testing for age-specific
mortality data. Journal of Evolutionary Biology, 12, 430–439.
</p>
<p>Siler, W. (1979) A competing-risk model for animal mortality. Ecology, 60,
750–757.
</p>
<p>Vaupel, J., Manton, K. &amp; Stallard, E. (1979) The impact of heterogeneity in
individual frailty on the dynamics of mortality. Demography, 16, 439–454.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model_fertility">model_fertility()</a></code> to model age-specific fertility using various
functions.
</p>
<p>Other trajectories: 
<code><a href="#topic+model_fertility">model_fertility</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_survival(params = c(b_0 = 0.1, b_1 = 0.2), model = "Gompertz")

model_survival(
  params = c(b_0 = 0.1, b_1 = 0.2, C = 0.1),
  model = "GompertzMakeham",
  truncate = 0.1
)

model_survival(params = c(c = 0.2), model = "Exponential", age = 0:10)

model_survival(
  params = c(a_0 = 0.1, a_1 = 0.2, C = 0.1, b_0 = 0.1, b_1 = 0.2),
  model = "Siler",
  age = 0:10
)
model_mortality(params = c(b_0 = 0.1, b_1 = 0.2), model = "Gompertz")
</code></pre>

<hr>
<h2 id='mpmsim-package'>mpmsim: Simulation of Matrix Population Models with Defined Life History Characteristics</h2><span id='topic+mpmsim'></span><span id='topic+mpmsim-package'></span>

<h3>Description</h3>

<p>Allows users to simulate matrix population models with particular characteristics based on aspects of life history such as mortality trajectories and fertility trajectories. Also allows the exploration of sampling error due to small sample size.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a> (<a href="https://orcid.org/0000-0001-5720-4686">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jonesor/mpmsim">https://github.com/jonesor/mpmsim</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jonesor/mpmsim/issues">https://github.com/jonesor/mpmsim/issues</a>
</p>
</li></ul>


<hr>
<h2 id='plot_matrix'>Plot a matrix as a heatmap</h2><span id='topic+plot_matrix'></span>

<h3>Description</h3>

<p>Visualise a matrix, such as a matrix population model (MPM), as a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(mat, zero_na = FALSE, legend = FALSE, na_colour = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matrix_+3A_mat">mat</code></td>
<td>
<p>A matrix, such as the A matrix of a matrix population model</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_zero_na">zero_na</code></td>
<td>
<p>Logical indicating whether zero values should be treated as NA</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether to include a legend</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_na_colour">na_colour</code></td>
<td>
<p>Colour for NA values</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to ggplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matDim &lt;- 10
A1 &lt;- make_leslie_mpm(
  survival = seq(0.1, 0.7, length.out = matDim),
  fertility = seq(0.1, 0.7, length.out = matDim),
  n_stages = matDim
)
plot_matrix(A1, zero_na = TRUE, na_colour = "black")
plot_matrix(A1, zero_na = TRUE, na_colour = NA)

</code></pre>

<hr>
<h2 id='random_mpm'>Generate random Lefkovitch matrix population models (MPMs) based on life
history archetypes</h2><span id='topic+random_mpm'></span>

<h3>Description</h3>

<p>Generates a random matrix population model (MPM) with element values based on
defined life history archetypes. Survival and transition/growth probabilities
from any particular stage are restricted to be less than or equal to 1 by
drawing from a Dirichlet distribution. The user can specify archetypes (from
Takada et al. 2018) to restrict the MPMs in other ways:
</p>

<ul>
<li><p> Archetype 1: all elements are positive, although they may be very small.
Therefore, transition from/to any stage is possible. This model describes a
life history where individuals can progress and retrogress rapidly.
</p>
</li>
<li><p> Archetype 2: has the same form as archetype 1 (transition from/to any stage
is possible), but the survival probability (column sums of the survival
matrix) increases monotonously as the individuals advance to later stages.
This model, as the one in the first archetype, also allows for rapid
progression and retrogression, but is more realistic in that stage-specific
survival probability increases with stage advancement.
</p>
</li>
<li><p> Archetype 3: positive non-zero elements for survival are only allowed on
the diagonal and lower sub-diagonal of the matrix This model represents the
life cycle of a species where retrogression is not allowed, and progression
can only happen to the immediately larger/more developed stage (slow
progression, e.g., trees).
</p>
</li>
<li><p> Archetype 4: This archetype has the same general form as archetype 3, but
with the further assumption that stage-specific survival increases as
individuals increase in size/developmental stage. In this respect it is
similar to archetype 2.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>random_mpm(n_stages, fecundity, archetype = 1, split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_mpm_+3A_n_stages">n_stages</code></td>
<td>
<p>An integer defining the number of stages for the MPM.</p>
</td></tr>
<tr><td><code id="random_mpm_+3A_fecundity">fecundity</code></td>
<td>
<p>Fecundity is the average number of offspring produced.
Values can be provided in 4 ways:
</p>

<ul>
<li><p> An numeric vector of length 1 to provide a fecundity measure to the top right corner of the matrix model only.
</p>
</li>
<li><p> A numeric vector of integers of length equal to <code>n_stages</code> to provide fecundity estimates for the whole top row of the matrix model. Use 0 for cases with no reproduction.
</p>
</li>
<li><p> A matrix of numeric values of the same dimension as <code>n_stages</code> to provide fecundity estimates for the entire matrix model. Use 0 for cases with no reproduction.
</p>
</li>
<li><p> A list of two matrices of numeric values, both with the same dimension as <code>n_stages</code>, to provide lower and upper estimates of mean fecundity for the entire matrix model.
In the latter case, a fecundity value will be drawn from a uniform
distribution for the defined range. If there is no reproduction in a
particular age class, use a value of 0 for both the lower and upper limit.
</p>
</li></ul>
</td></tr>
<tr><td><code id="random_mpm_+3A_archetype">archetype</code></td>
<td>
<p>Indication of which life history archetype should be used,
based on Takada et al. 2018. An integer between 1 and 4.</p>
</td></tr>
<tr><td><code id="random_mpm_+3A_split">split</code></td>
<td>
<p>TRUE/FALSE, indicating whether the matrix produced should be
split into a survival matrix and a fertility matrix. Yeah true, then the
output becomes a list with a matrix in each element. Otherwise, the output
is a single matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In all 4 of these Archetypes, fecundity is placed as a single element on the
top right of the matrix, if it is a single value. If it is a vector of length
<code>n_stages</code> then the fertility vector spans the entire top row of the matrix.
</p>
<p>The function is constrained to only output ergodic matrices.
</p>


<h3>Value</h3>

<p>Returns a random matrix population model with characteristics
determined by the archetype selected and fecundity vector. If split = TRUE,
the matrix is split into separate fertility and a growth/survival matrices,
returned as a list.
</p>


<h3>Author(s)</h3>

<p>Owen Jones <a href="mailto:jones@biology.sdu.dk">jones@biology.sdu.dk</a>
</p>


<h3>References</h3>

<p>Caswell, H. (2001). Matrix Population Models: Construction, Analysis, and
Interpretation. Sinauer.
</p>
<p>Lefkovitch, L. P. (1965). The study of population growth in organisms grouped
by stages. Biometrics, 21(1), 1.
</p>
<p>Takada, T., Kawai, Y., &amp; Salguero-Gómez, R. (2018). A cautionary note on
elasticity analyses in a ternary plot using randomly generated population
matrices. Population Ecology, 60(1), 37–47.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_mpm_set">generate_mpm_set()</a></code> which is a wrapper for this function allowing
the generation of large numbers of random matrices of this type.
</p>
<p>Other Lefkovitch matrices: 
<code><a href="#topic+generate_mpm_set">generate_mpm_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) # set seed for repeatability

random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = FALSE)
random_mpm(n_stages = 2, fecundity = 20, archetype = 2, split = TRUE)
random_mpm(n_stages = 3, fecundity = 20, archetype = 3, split = FALSE)
random_mpm(n_stages = 4, fecundity = 20, archetype = 4, split = TRUE)
random_mpm(
  n_stages = 5, fecundity = c(0, 0, 4, 8, 10), archetype = 4,
  split = TRUE
)
# Using a range of values for fecundity
random_mpm(n_stages = 2, fecundity = 20, archetype = 1, split = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
