<!DOCTYPE html><html><head><title>Help for package RStorm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RStorm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddBolt'>
<p>Function to add a <code>Bolt</code> to a <code>Topology</code> object to specify a stream.</p></a></li>
<li><a href='#AddFinalize'>
<p>Function to add a finalize function to a <code>Topology</code></p></a></li>
<li><a href='#Bolt'>
<p>Function to create a <code>Bolt</code> object to add to a stream</p></a></li>
<li><a href='#ChangeSpout'>
<p>Function to change the Spout of a Topology</p></a></li>
<li><a href='#Emit'>
<p>Function to emit a <code>Tuple</code> along the stream. The emitted data <code>x</code> should be a single row of a <code>data.frame</code>.</p></a></li>
<li><a href='#GetHash'>
<p>Function to retrieve objects stored locally during the running of the stream.</p></a></li>
<li><a href='#GetHashList'>
<p>Function to retrieve a list of locally stored object resulting from the stream.</p></a></li>
<li><a href='#GetHashNames'>
<p>Function to retrieve the names of locally stored objects in the stream.</p></a></li>
<li><a href='#GetTrack'>
<p>Function to retrieve objects stored using the <code>SetTrack</code> functionality during a stream.</p></a></li>
<li><a href='#GetTrackNames'>
<p>Function to retrieve the names of all tracked objects using <code>SetTrack</code></p></a></li>
<li><a href='#RStorm'>
<p>Main function to run a stream.</p></a></li>
<li><a href='#RStorm-package'>
<p>Simulate a Streaming Process in [R]</p></a></li>
<li><a href='#RStorm.env'>
<p>Environment used by RStorm for internal storage of objects.</p></a></li>
<li><a href='#sentences'><p>Sentences of the first section of the paper by Student Introducing the T-Test.</p></a></li>
<li><a href='#SetHash'>
<p>Function to store a <code>data.frame</code> during a stream.</p></a></li>
<li><a href='#ShowFinalize'>
<p>Function to display the name of the finalize function.</p></a></li>
<li><a href='#Topology'>
<p>Function to create a topology</p></a></li>
<li><a href='#TrackRow'>
<p>Function to store the value of some object in the stream over time.</p></a></li>
<li><a href='#Tuple'>
<p>Function to create an object of type <code>Tuple</code> to emit down a stream.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate and Develop Streaming Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Maurits Kaptein</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maurits Kaptein &lt;maurits@mauritskaptein.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>While streaming processing provides opportunities to deal with extremely large and ever growing data sets in (near) real time, the development of streaming algorithms for complex models is often cumbersome: the software packages that facilitate streaming processing in production environments do not provide statisticians with the simulation, estimation, and plotting tools they are used to. Developers of streaming algorithms would thus benefit from the flexibility of [R] to create, plot and compute data while developing streaming algorithms. Package RStorm implements a streaming architecture modeled on Storm for easy development and testing of streaming algorithms in [R]. RStorm is not intended as a production package, but rather a development tool for streaming algorithms. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>plyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-29 15:23:16 UTC; mauritskate</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-29 15:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddBolt'>
Function to add a <code>Bolt</code> to a <code>Topology</code> object to specify a stream.
</h2><span id='topic+AddBolt'></span>

<h3>Description</h3>

<p><code>AddBolt</code> is an auxiliary function for building up a <code>RStorm</code> topology. After initializing a <code>Topology</code> object the <code>AddBolt</code> function can be used to build the topology and specify the order of the Bolts. A <code>Bolt</code> receives as its first argument the <code>Tuple</code> emitted by the previous element in the Stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddBolt(topology, bolt, .verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddBolt_+3A_topology">topology</code></td>
<td>

<p>a <code>Topology</code> object to add the bolt to.
</p>
</td></tr>
<tr><td><code id="AddBolt_+3A_bolt">bolt</code></td>
<td>

<p>a <code>Bolt</code> to add to the topology. These are created using the <code>Bolt()</code> function.
</p>
</td></tr>
<tr><td><code id="AddBolt_+3A_.verbose">.verbose</code></td>
<td>

<p>a logical indicator to state whether or not verbose output should be printed. Default TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>Topology</code> which  is a list containing the following elements:
</p>
<table>
<tr><td><code>spout</code></td>
<td>
<p>the data.frame passed as a spout</p>
</td></tr>
<tr><td><code>bolts</code></td>
<td>
<p>a list of bolts, see <code>Bolt</code></p>
</td></tr>
<tr><td><code>finailze</code></td>
<td>
<p>the finalize function to be used for the stream</p>
</td></tr> 
</table>
<p>The specified <code>Bolt</code> has now been added to the list of bolts. See <code><a href="#topic+Topology">Topology</a></code> for more info.
</p>


<h3>Warning </h3>

<p>Functions which get added to a Topology using the AddBolt functionality should always use the ... argument. This argument is used to facilitate the processing of the stream. See example below for a minimal functional example of a correctly specified bolt.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+Bolt">Bolt</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a topology and add a bolt to it.
bolt1 &lt;- function(x, ...){print(x)}
topology &lt;- Topology(data.frame(x=c(1:10)))
topology &lt;- AddBolt(topology, Bolt(bolt1, listen=0))
topology

</code></pre>

<hr>
<h2 id='AddFinalize'>
Function to add a finalize function to a <code>Topology</code>
</h2><span id='topic+AddFinalize'></span>

<h3>Description</h3>

<p><code>AddFinalize</code> is an auxiliary function for building up a <code>RStorm</code> topology. After initializing a <code>Topology</code> object the <code>AddFinalize</code> function can be used to add a final function, which receives as its parameter a list of all hashMaps stored during the stream. After running the stream <code>GetHashList</code> can be used to receive an object that is the same as the object received by the finalize function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddFinalize_+3A_topology">topology</code></td>
<td>

<p>a <code>Topology</code> object to add the bolt to.
</p>
</td></tr>
<tr><td><code id="AddFinalize_+3A_bolt">bolt</code></td>
<td>

<p>a <code>Bolt</code> to add to as the finalize function. 
</p>
</td></tr>
<tr><td><code id="AddFinalize_+3A_.verbose">.verbose</code></td>
<td>

<p>a logical indicator to state whether or not verbose output should be printed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>Topology</code> which  is a list containing the following elements:
</p>
<table>
<tr><td><code>spout</code></td>
<td>
<p>the data.frame passed as a spout</p>
</td></tr>
<tr><td><code>bolts</code></td>
<td>
<p>a list of bolts, see <code>Bolt</code></p>
</td></tr>
<tr><td><code>finailze</code></td>
<td>
<p>the finalize function to be used for the stream</p>
</td></tr> 
</table>
<p>The specified <code>Bolt</code> has now been added to the finalize function. See <code><a href="#topic+Topology">Topology</a></code> for more info.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+Bolt">Bolt</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	bolt1 &lt;- function(x, ...){print(x)}
	topology &lt;- Topology(data.frame(x=c(1:10)))
	topology &lt;- AddFinalize(topology, Bolt(bolt1))
	topology
</code></pre>

<hr>
<h2 id='Bolt'>
Function to create a <code>Bolt</code> object to add to a stream
</h2><span id='topic+Bolt'></span><span id='topic+is.Bolt'></span>

<h3>Description</h3>

<p>Function to create a <code>Bolt</code> object. A <code>Bolt</code> object consists of a function which receives as its first argument the <code>Tuple</code> emitted by the element the <code>Bolt</code> listens to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bolt(FUNC, listen = 0, boltID = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bolt_+3A_func">FUNC</code></td>
<td>

<p>a <code>[R]</code> function with a first argument which receive a <code>Tuple</code> and using the ,... specification to receive arguments auxiliary to the functioning of the stream.
</p>
</td></tr>
<tr><td><code id="Bolt_+3A_listen">listen</code></td>
<td>

<p>a number indicating which element in the topology to listen too. $0$ indicates the Spout itself, while other integers refer to the Tuples emitted by other Bolts along the Stream. Default is $0$. Printing the Topology allows one to see the position number of each Bolt.
</p>
</td></tr>
<tr><td><code id="Bolt_+3A_boltid">boltID</code></td>
<td>

<p>(optional) the ID of this bolt. A given name &ndash; mostly a number &ndash; to pass the name of the bolt to the bolt itself which can be used to create (e.g.) a hashMap that is distinct for the current bolt.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>Bolt</code> which is a list containing the following elements:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the function that was passed when initializing the Bolt</p>
</td></tr>
<tr><td><code>func</code></td>
<td>
<p>the function itself</p>
</td></tr>
<tr><td><code>listen</code></td>
<td>
<p>the identifier of the element in the stream from which the Bolt receives its Tuples</p>
</td></tr> 
<tr><td><code>id</code></td>
<td>
<p>the id of the current Bolt</p>
</td></tr> 
</table>


<h3>Warning </h3>

<p>Functions used as bolt in a stream should always use the dots argument (...) to facilitate the internal working of <code>RStorm</code>.
</p>


<h3>Additional Info</h3>

<p>The <code>is.Bolt</code> function checks whether an object is of Type Bolt and is used internally.</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+AddBolt">AddBolt</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a Bolt:
bolt1 &lt;- function(x, ...){print(x)}
Bolt(bolt1, listen=0, boltID=12)

</code></pre>

<hr>
<h2 id='ChangeSpout'>
Function to change the Spout of a Topology
</h2><span id='topic+ChangeSpout'></span>

<h3>Description</h3>

<p>The <code>ChangeSpout</code> function is used to change the spout of an topology that was already defined. It can be used (e.g) for the simulation of a data stream process on multiple data-sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChangeSpout(topology, spout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChangeSpout_+3A_topology">topology</code></td>
<td>

<p>a RStorm Topology object.
</p>
</td></tr>
<tr><td><code id="ChangeSpout_+3A_spout">spout</code></td>
<td>

<p>a new spout. E.g., a new codedata.frame.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Topology</code> which is a list containing the following elements:
</p>
<table>
<tr><td><code>spout</code></td>
<td>
<p>the data.frame passed as a spout</p>
</td></tr>
<tr><td><code>bolts</code></td>
<td>
<p>a list of bolts, see <code>Bolt</code></p>
</td></tr>
<tr><td><code>finailze</code></td>
<td>
<p>the finalize function to be used for the stream</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Functions used as bolt in a stream should always use the dots argument (...) to facilitate the internal working of <code>RStorm</code>.
</p>


<h3>Additional Info</h3>

<p>The <code>is.Bolt</code> function checks whether an object is of Type Bolt and is used internally.</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+AddBolt">AddBolt</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a data set.
x &lt;- seq(1, 100)
topology &lt;- Topology(data.frame(x=x))

# Setup a simple topology to compute a sum
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
}

# Run the stream
topology &lt;- AddBolt(topology, Bolt(computeSum))
result &lt;- RStorm(topology)
print(GetHash("sum", result))

# Create an alternative dataset
x2 &lt;- seq(2, 100)

# Change the dataset in the existing topology
topology &lt;- ChangeSpout(topology, data.frame(x=x2))

# Run the new dataset
result &lt;- RStorm(topology)
print(GetHash("sum", result))

</code></pre>

<hr>
<h2 id='Emit'>
Function to emit a <code>Tuple</code> along the stream. The emitted data <code>x</code> should be a single row of a <code>data.frame</code>.
</h2><span id='topic+Emit'></span>

<h3>Description</h3>

<p>Function to emit a <code>Tuple</code> along the stream. The emitted data <code>x</code> should be a single row of a <code>data.frame</code>. Tuples are the main data format passed around in an <code>RStorm</code> stream, and each emitted object is checked by the <code>Emit</code> function to be of class <code>Tuple</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Emit(x, .name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Emit_+3A_x">x</code></td>
<td>

<p>a <code>Tuple</code>. The only arguments that needs to be provided by the user.
</p>
</td></tr>
<tr><td><code id="Emit_+3A_.name">.name</code></td>
<td>

<p>(internal) the name of the emitter. Used internally.
</p>
</td></tr>
<tr><td><code id="Emit_+3A_...">...</code></td>
<td>

<p>Additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE. The <code>Emit</code> function does not return anything but rather adds the emitted Tuple to the internal list of emitted objects to be used by Spouts listening to the <code>Spout</code> or <code>Bolt</code> from which the data is emitted. The ... argument always needs to be passed in a call to <code>Emit()</code> since it facilitates the internal working of the RStorm.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+AddBolt">AddBolt</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# This example can only be run within a Stream.
	# If run outside the Steam the Emit function will issue an error.
	## Not run: 
		x &lt;- data.frame(var1 = c("test", "test2"), var2 = c(2,5))
		Emit(Tuple(x[1,]), ...)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='GetHash'>
Function to retrieve objects stored locally during the running of the stream.
</h2><span id='topic+GetHash'></span>

<h3>Description</h3>

<p>Within bolts in used in a RStorm the <code>GetHash</code> and <code>SetHash</code> functions can be used to access a local store (or hashmap) during the stream. This corresponds to the ability of tracking parameters over the stream using a hashmap or database system as implemented in production streaming software. The function is overloaded to retrieve the state of the hashmap at the end of a stream from an RStorm result object. See the examples for the two usages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHash(name, object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHash_+3A_name">name</code></td>
<td>

<p>a string containing the name of the hashmap that is accessed from within the Stream.
</p>
</td></tr>
<tr><td><code id="GetHash_+3A_object">object</code></td>
<td>

<p>(optional) the RStorm result object. If used outside of a bolt in a stream the result object needs to be passed in which the end-state of the hashmaps created in the stream are stored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing whatever was set using the SetHash function.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHashList">GetHashList</a></code>, <code><a href="#topic+GetHashNames">GetHashNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a topology with a spout:
topology &lt;- Topology(data.frame(x=rnorm(100,0,1)))

# declare a bolt and add it to the topology
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")  # get from local store
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)  # add to local store
}
topology &lt;- AddBolt(topology, Bolt(computeSum))

# run the stream
result &lt;- RStorm(topology)

# access the local store
print(GetHash("sum", result))

</code></pre>

<hr>
<h2 id='GetHashList'>
Function to retrieve a list of locally stored object resulting from the stream.
</h2><span id='topic+GetHashList'></span>

<h3>Description</h3>

<p>Function retrieves from an RStorm result object (after running a stream) all the items stored in during the stream (using <code>SetHash</code>) as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHashList(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHashList_+3A_object">object</code></td>
<td>

<p>a <code>RStorm</code> result object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all objects stored using <code>SetHash</code> during a stream.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetHashNames">GetHashNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a topology
topology &lt;- Topology(data.frame(x=rnorm(100,0,1)))

# Create two bolts and add them to the topology
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
}
computeSumSquared &lt;- function(x, ...){
	sum2 &lt;- GetHash("sum2")
	if(is.data.frame(sum2)){
		x &lt;- sum2 + (x[1]^2)
	}
	SetHash("sum2", x)
}
topology &lt;- AddBolt(topology, Bolt(computeSum))
topology &lt;- AddBolt(topology, Bolt(computeSumSquared))

# Run the stream
result &lt;- RStorm(topology)

# Get the names of all the stored objects during the stream
names(GetHashList(result))


</code></pre>

<hr>
<h2 id='GetHashNames'>
Function to retrieve the names of locally stored objects in the stream.</h2><span id='topic+GetHashNames'></span>

<h3>Description</h3>

<p>Function retrieves from an RStorm result object (after running a stream) all the names of all items stored in during the stream (using <code>SetHash</code>) as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetHashNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetHashNames_+3A_object">object</code></td>
<td>

<p>a <code>RStorm</code> result object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all names stored using <code>SetHash</code> during a stream.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetHashNames">GetHashNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# Create a topology
	topology &lt;- Topology(data.frame(x=rnorm(100,0,1)))

	# Create two bolts and add them to the topology
	computeSum &lt;- function(x, ...){
		sum &lt;- GetHash("sum")
		if(is.data.frame(sum)){
			x &lt;- sum + (x[1])
		}
		SetHash("sum", x)
	}
	computeSumSquared &lt;- function(x, ...){
		sum2 &lt;- GetHash("sum2")
		if(is.data.frame(sum2)){
			x &lt;- sum2 + (x[1]^2)
		}
		SetHash("sum2", x)
	}
	topology &lt;- AddBolt(topology, Bolt(computeSum))
	topology &lt;- AddBolt(topology, Bolt(computeSumSquared))

	# Run the stream
	result &lt;- RStorm(topology)

	# Get the names of all the stored objects during the stream
	print(GetHashNames(result))


</code></pre>

<hr>
<h2 id='GetTrack'>
Function to retrieve objects stored using the <code>SetTrack</code> functionality during a stream.
</h2><span id='topic+GetTrack'></span>

<h3>Description</h3>

<p>Within bolts in a RStorm stream the <code>TrackRow</code> function can be used to store the state of variables at that point during the stream. The <code>TrackRow</code> function will store values incrementally during the stream. Thus, <code>TrackRow</code> enables one to store a set of parameter at each event in a Bolt. The current <code>GetTrack</code> function allows for inspection of these stored values after running the Stream by passing the RStorm result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTrack(name, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTrack_+3A_name">name</code></td>
<td>

<p>a string with the name of the tracked parameter values. Name corresponds to the name used in the call to the <code>TrackRow</code> function during the stream.
</p>
</td></tr>
<tr><td><code id="GetTrack_+3A_x">x</code></td>
<td>

<p>a RStorm result object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing the parameters that are tracked at each iteration of a bolt.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+TrackRow">TrackRow</a></code>, <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetTrackNames">GetTrackNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a topology with a spout
topology &lt;- Topology(data.frame(x=c(1:10)))

# Add a bolt to the topology
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
	# Track the current state during the stream:
	TrackRow("sum", data.frame(x=x))
}
topology &lt;- AddBolt(topology, Bolt(computeSum))

# Run the stream
result &lt;- RStorm(topology)

# Inspect the sums during the stream
GetTrack("sum", result)

</code></pre>

<hr>
<h2 id='GetTrackNames'>
Function to retrieve the names of all tracked objects using <code>SetTrack</code>
</h2><span id='topic+GetTrackNames'></span>

<h3>Description</h3>

<p>Within bolts in a RStorm stream the <code>TrackRow</code> function can be used to store the state of variables at that point during the stream. The <code>TrackRow</code> function will store values incrementally during the stream. Thus, <code>TrackRow</code> enables one to store a set of parameter at each event in a Bolt. The current <code>GetTrackNames</code> function allows to inspect all the tracked objects of a stream by passing the RStorm result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTrackNames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTrackNames_+3A_x">x</code></td>
<td>

<p>a RStorm result object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of names of the tracked objects during the stream.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+TrackRow">TrackRow</a></code>, <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetTrack">GetTrack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# Create a topology with a spout
	topology &lt;- Topology(data.frame(x=c(1:10)))

	# Add a bolt to the topology
	computeSum &lt;- function(x, ...){
		sum &lt;- GetHash("sum")
		if(is.data.frame(sum)){
			x &lt;- sum + (x[1])
		}
		SetHash("sum", x)
		# Track the current state during the stream:
		TrackRow("sum", data.frame(x=x))
	}
	topology &lt;- AddBolt(topology, Bolt(computeSum))

	# Run the stream
	result &lt;- RStorm(topology)

	# Inspect the sums during the stream
	GetTrackNames(result)

</code></pre>

<hr>
<h2 id='RStorm'>
Main function to run a stream.
</h2><span id='topic+RStorm'></span><span id='topic+is.RStorm'></span><span id='topic+print.RStorm'></span><span id='topic+plot.RStorm'></span>

<h3>Description</h3>

<p><code>RStorm</code> provides the main functionality of the RStorm package. The <code>RStorm</code> function is used to run a stream defined using a Topology. The Topology defines the spout (the data-source for the stream) and the order of processing units (bolts). See example below and in the main package description for examples of the usage of <code>RStorm</code>.
</p>
<p>More details of the package, examples of streaming algorithms, and examples of the use of RStorm can be found at http://software.mauritskaptein.com/RStorm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RStorm(topology, .verbose = TRUE, .debug = FALSE, .batches = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RStorm_+3A_topology">topology</code></td>
<td>

<p>a topology object specified using <code>Topology</code>. The topology contains all the necessary information (the definition of the spouts, the bolts, and the order of processing) for the stream to run in full.
</p>
</td></tr>
<tr><td><code id="RStorm_+3A_.verbose">.verbose</code></td>
<td>

<p>a logical indicator for verbose output. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="RStorm_+3A_.debug">.debug</code></td>
<td>

<p>a logical indicator for debug mode. If in debug mode all objects stored during the running of the stream will persist in memory and can be accessed using standard calls to <code>ls()</code>. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="RStorm_+3A_.batches">.batches</code></td>
<td>

<p>a number. Determines the size of batches processed by a stream. While RStorm simulates streaming processing, in actuality the rows of the data.frame defined in the spout are iterated through in batches to prevent memory overflow when the spout contains a large number of rows. This argument sets the size of these batches and with it limits the size of memory allocated to emitted data during the stream. Default batch size is 100.
</p>
</td></tr>
<tr><td><code id="RStorm_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to (e.g.) bolts or plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>RStorm</code> which is a list containing the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a list containing all the hashmaps stored during the stream using <code>SetHash</code>. Can be accessed by passing the result object to <code>GetHash</code>.</p>
</td></tr>
<tr><td><code>track</code></td>
<td>
<p>a list containing all the data.frames stored using the <code>TrackRow</code> functionality. Can be accessed by passing the result object of an RStorm to <code>GetTrack</code>.</p>
</td></tr>
<tr><td><code>finalize</code></td>
<td>
<p>the result of the finalize function. If a finalize function is added to the Topology this field will contain whatever was returned by the finalize function and can be accessed directly using <code>ShowFinalize</code>. If no finalize function was added to the topology or the finalize function does not return anything the value of finalize will be false</p>
</td></tr> 
</table>


<h3>Additional Info</h3>

<p>The <code>is.RStorm</code> function checks whether an object is of Type RStorm and is used internally.</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>References</h3>

<p>http://software.mauritskaptein.com/RStorm
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+Bolt">Bolt</a></code>, <code><a href="#topic+Tuple">Tuple</a></code>, <code><a href="#topic+Emit">Emit</a></code>, <code><a href="#topic+TrackRow">TrackRow</a></code>, <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetTrack">GetTrack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	# Run a simple RStorm. First, create some data:
	x &lt;- seq(1, 1000)

	# Second, we start defining the topology
	topology &lt;- Topology(data.frame(x=x))

	# Third, we define a bolt. 
	# This bolt computes the sum of a number stored 
	#   in a local Hashmap and the Tuple (x) that is received
	computeSum &lt;- function(x, boltID, ...){
		sum &lt;- GetHash(paste("sum", boltID))
		if(is.data.frame(sum)){
			x &lt;- sum + (x[1])
		}
		SetHash(paste("sum", boltID), x)
		Emit(Tuple(x=x), ...)
	}

	# Add the bolts to the topology. 
	# Here the first bolt computes the sum of the sequence
	#   and the second bolt computes the sum of summed elements
	topology &lt;- AddBolt(topology, Bolt(computeSum, listen=0, boltID=1))
	topology &lt;- AddBolt(topology, Bolt(computeSum, listen=1, boltID=2))
	result &lt;- RStorm(topology)
	print(GetHash("sum 1", result))
	print(GetHash("sum 2", result))
</code></pre>

<hr>
<h2 id='RStorm-package'>
Simulate a Streaming Process in [R]
</h2><span id='topic+RStorm-package'></span>

<h3>Description</h3>

<p>While streaming processing provides opportunities to deal with extremely large and ever growing data sets in (near) real time, the development of streaming algorithms for complex models is often cumbersome: the software packages that facilitate streaming processing in production environments do not provide statisticians with the simulation, estimation, and plotting tools they are used to. Developers of streaming algorithms would thus benefit from the flexibility of [R] to create, plot and compute data while developing streaming algorithms. RStorm implements a streaming architecture modeled on Storm for easy development and testing of streaming algorithms in [R]. Package RStorm is not intended as a production package, but rather a development tool for streaming algorithms. See the below examples for some of the usages of RStorm for the development and comparison of streaming algorithms.
</p>
<p>Details of the package, examples of streaming algorithms, and examples of the use of RStorm can be found at http://software.mauritskaptein.com/RStorm
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RStorm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2013-07-26</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>
<p>Maintainer: Maurits Kaptein &lt;maurits@mauritskaptein.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="plyr.html#topic+ddply">ddply</a></code>
<code><a href="#topic+RStorm">RStorm</a></code>
<code><a href="#topic+Topology">Topology</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############################
# a simple stream to compute a sum:
##############################

# create some data:
x &lt;- seq(1, 1000)

# start a topology
topology &lt;- Topology(data.frame(x=x))

# define a bolt and add it to the topology
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
}
topology &lt;- AddBolt(topology, Bolt(computeSum))

# Run the stream:
result &lt;- RStorm(topology)

# Inspect the result
print(GetHash("sum", result))

#plot(topology)


##############################
# Example of a stream to compare two 
# methods of streaming variance computation:
##############################

# Generate some data 
set.seed(10)
t &lt;- 100
x &lt;- rnorm(t,0,1)
# Look at the variance as computed by var():
var(x)

# Start a topology
topology &lt;- Topology(data.frame(x=x))

# Bolt for "Sum of Squares Method" with tracking over time
var.SS &lt;- function(x, ...){
	params &lt;- GetHash("params1")
	if(!is.data.frame(params)){
		params &lt;- list()
		params$n &lt;- params$sum &lt;- params$sum2 &lt;- 0
	}
	n &lt;- params$n + 1
	sum &lt;- params$sum + as.numeric(x[1])
	sum2 &lt;- params$sum2 + as.numeric(x[1]^2)
	if(n&gt;1){
		var &lt;- 1/(n*(n-1)) * (n*sum2 - sum^2)
	} else {
		var &lt;- 0
	}
	SetHash("params1", data.frame(n=n, sum=sum, sum2=sum2, var=var))
	TrackRow("var.SS", data.frame(var=var))
}


## Bolt for "Welford's" Method:

var.Welford &lt;- function(x, ...){
	x &lt;- as.numeric(x[1])
	params &lt;- GetHash("params2")
	if(!is.data.frame(params)){
		params &lt;- list()
		params$M &lt;- x
		params$S &lt;- params$n &lt;- 0
	}
	n &lt;- params$n + 1
	M &lt;- params$M + ( x - params$M) / n
	S &lt;- params$S + (x - params$M)*(x-M)

	if(n&gt;1){
		var &lt;- S / (n-1)
	} else {
		var &lt;- 0
	}
	SetHash("params2", data.frame(n=n, M=M, S=S, var=var))
	TrackRow("var.Welford", data.frame(var=var))
}

# Add both topologies to a Stream:
topology &lt;- AddBolt(topology, Bolt(var.SS))
topology &lt;- AddBolt(topology, Bolt(var.Welford))
result &lt;- RStorm(topology)

# Plot the results over the stream
plot(c(1:t), GetTrack("var.Welford", result)$var, type="l")
lines(c(1:t), GetTrack("var.SS", result)$var, col="red")


### Similar, but with a dataset
###  in which the mean is very large compared to the variance:
x2 &lt;- rnorm(t,10^8,1)
topology2 &lt;- Topology(data.frame(x=x2))
topology2 &lt;- AddBolt(topology2, Bolt(var.SS))
topology2 &lt;- AddBolt(topology2, Bolt(var.Welford))
result2 &lt;- RStorm(topology2)

# This time the standard SS methods screws up (mind the different y scale):
# (And mind the fact that the SS method gives NEGATIVE variance)
plot(c(1:t), GetTrack("var.Welford", result2)$var, type="l", ylim=c(-10, 11))
lines(c(1:t), GetTrack("var.SS", result2)$var, col="red")


</code></pre>

<hr>
<h2 id='RStorm.env'>
Environment used by RStorm for internal storage of objects.
</h2><span id='topic+RStorm.env'></span>

<h3>Description</h3>

<p>Environment used by RStorm for internal storage of objects. These objects facilitate the functioning of the Stream and store the emitted Tuples in between Bolts.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+RStorm">RStorm</a></code>
</p>

<hr>
<h2 id='sentences'>Sentences of the first section of the paper by Student Introducing the T-Test.</h2><span id='topic+sentences'></span>

<h3>Description</h3>

<p>This dataset gives a number of sentences &ndash; the first sentences from the article &ldquo;The probable error of a mean&rdquo; by Student.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rivers</code></pre>


<h3>Format</h3>

<p>A data.frame containing two columns, one with an ID (number) for each sentence, and one with the sentences itself.</p>


<h3>Source</h3>

<p>The probable error of a mean, Biometrica, 1908</p>


<h3>References</h3>

<p>Student (1908) <em>The probable error of a mean</em>. Biometrica, 6, 1, 1&ndash;25.
</p>

<hr>
<h2 id='SetHash'>
Function to store a <code>data.frame</code> during a stream.
</h2><span id='topic+SetHash'></span>

<h3>Description</h3>

<p>Within bolts in used in a RStorm the <code>GetHash</code> and <code>SetHash</code> functions can be used to access a local store (or hashmap) during the stream. This corresponds to the ability of tracking parameters over the stream using a hashmap or database system as implemented in production streaming software. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetHash(name, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetHash_+3A_name">name</code></td>
<td>

<p>a string containing the name of the stored object
</p>
</td></tr>
<tr><td><code id="SetHash_+3A_data">data</code></td>
<td>

<p>a data.frame (or scalar) to be stored 
</p>
</td></tr>
<tr><td><code id="SetHash_+3A_...">...</code></td>
<td>


</td></tr>
</table>


<h3>Value</h3>

<p>If storing the value is successful returns TRUE.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+TrackRow">TrackRow</a></code>, <code><a href="#topic+SetHash">SetHash</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, <code><a href="#topic+GetTrack">GetTrack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
topology &lt;- Topology(data.frame(x=rnorm(100,0,1)))
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
}
topology &lt;- AddBolt(topology, Bolt(computeSum))
result &lt;- RStorm(topology)
print(GetHash("sum", result))


</code></pre>

<hr>
<h2 id='ShowFinalize'>
Function to display the name of the finalize function.
</h2><span id='topic+ShowFinalize'></span>

<h3>Description</h3>

<p>Utility function to display the finalize function of a RStorm topology object or display the result of a finalize function of an RStorm result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShowFinalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShowFinalize_+3A_x">x</code></td>
<td>

<p>a topology created using <code>Topology</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the finalize function of a Topology object. 
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p>See Also: <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>, <code><a href="#topic+GetHash">GetHash</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple display of the finalize function itself
topology &lt;- Topology(data.frame(x=c(1:10), y=rep(1,10)))

bolt.1 &lt;- function(x, ...){ SetHash("finalize", data.frame(x=99)) }
topology &lt;- AddBolt(topology, Bolt(bolt.1))

comp.av &lt;- function(object, ...){ 
	return( rep(object$finalize$x, 10)) }

topology &lt;- AddFinalize(topology, Bolt(comp.av))
ShowFinalize(topology)

# and in the result object:
result &lt;- RStorm(topology)
ShowFinalize(result)


</code></pre>

<hr>
<h2 id='Topology'>
Function to create a topology
</h2><span id='topic+Topology'></span><span id='topic+is.Topology'></span><span id='topic+print.Topology'></span><span id='topic+plot.Topology'></span>

<h3>Description</h3>

<p>By passing a spout (dataframe) to this function and storing its return object you can start building a topology for a RStorm stream. See code<a href="#topic+RStorm">RStorm</a> for more detailed examples of the use of Topology. The Topology is the most important concept when defining a RStorm stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Topology(spout, name = NULL, .verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Topology_+3A_spout">spout</code></td>
<td>

<p>a data.frame containing multiple rows of data which are to be iterated through in the stream.
</p>
</td></tr>
<tr><td><code id="Topology_+3A_name">name</code></td>
<td>

<p>an optional name of this topology. 
</p>
</td></tr>
<tr><td><code id="Topology_+3A_.verbose">.verbose</code></td>
<td>

<p>an optional boolean to indicate whether you want verbose output or not. Default is TRUE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Topology</code> which is a list containing the following elements:
</p>
<table>
<tr><td><code>spout</code></td>
<td>
<p>the data.frame passed as a spout</p>
</td></tr>
<tr><td><code>bolts</code></td>
<td>
<p>a list of bolts, see <code>Bolt</code></p>
</td></tr>
<tr><td><code>finailze</code></td>
<td>
<p>the finalize function to be used for the stream</p>
</td></tr>
</table>


<h3>Additional Info</h3>

<p>The <code>is.Topology</code> function checks whether an object is of Type Topology and is used internally.</p>


<h3>Note</h3>

<p>For examples see www.mauritskaptein.com/software/RStorm
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bolt">Bolt</a></code>, <code><a href="#topic+Tuple">Tuple</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

	##############################
	# Example of a stream to compare two methods of streaming variance computation:
	##############################

	# Generate some data 
	set.seed(10)
	t &lt;- 100
	x &lt;- rnorm(t,0,1)
	# Look at the variance as computed by var():
	var(x)

	# Start a topology
	topology &lt;- Topology(data.frame(x=x))

	# Bolt for "Sum of Squares Method" with tracking over time
	var.SS &lt;- function(x, ...){
		params &lt;- GetHash("params1")
		if(!is.data.frame(params)){
			params &lt;- list()
			params$n &lt;- params$sum &lt;- params$sum2 &lt;- 0
		}
		n &lt;- params$n + 1
		sum &lt;- params$sum + as.numeric(x[1])
		sum2 &lt;- params$sum2 + as.numeric(x[1]^2)
		if(n&gt;1){
			var &lt;- 1/(n*(n-1)) * (n*sum2 - sum^2)
		} else {
			var &lt;- 0
		}
		SetHash("params1", data.frame(n=n, sum=sum, sum2=sum2, var=var))
		TrackRow("var.SS", data.frame(var=var))
	}


	## Bolt for "Welford's" Method:

	var.Welford &lt;- function(x, ...){
		x &lt;- as.numeric(x[1])
		params &lt;- GetHash("params2")
		if(!is.data.frame(params)){
			params &lt;- list()
			params$M &lt;- x
			params$S &lt;- params$n &lt;- 0
		}
		n &lt;- params$n + 1
		M &lt;- params$M + ( x - params$M) / n
		S &lt;- params$S + (x - params$M)*(x-M)

		if(n&gt;1){
			var &lt;- S / (n-1)
		} else {
			var &lt;- 0
		}
		SetHash("params2", data.frame(n=n, M=M, S=S, var=var))
		TrackRow("var.Welford", data.frame(var=var))
	}

	# Add both topologies to a Stream:
	topology &lt;- AddBolt(topology, Bolt(var.SS))
	topology &lt;- AddBolt(topology, Bolt(var.Welford))
	result &lt;- RStorm(topology)

	# Plot the results over the stream
	plot(c(1:t), GetTrack("var.Welford", result)$var, type="l")
	lines(c(1:t), GetTrack("var.SS", result)$var, col="red")


	# Now the same variance calculation, 
	#    but with a dataset in which the mean is 
	#    very large compared to the variance:
	x2 &lt;- rnorm(t,10^8,1)
	topology2 &lt;- Topology(data.frame(x=x2))
	topology2 &lt;- AddBolt(topology2, Bolt(var.SS))
	topology2 &lt;- AddBolt(topology2, Bolt(var.Welford))
	result2 &lt;- RStorm(topology2)

	# This time the standard SS methods screws up (mind the different y scale):
	# (And mind the fact that the SS method gives NEGATIVE variance)
	plot(c(1:t), GetTrack("var.Welford", result2)$var, type="l", ylim=c(-10, 11))
	lines(c(1:t), GetTrack("var.SS", result2)$var, col="red")


</code></pre>

<hr>
<h2 id='TrackRow'>
Function to store the value of some object in the stream over time.
</h2><span id='topic+TrackRow'></span>

<h3>Description</h3>

<p>Within bolts in a RStorm stream the <code>TrackRow</code> function can be used to store the state of variables at that point during the stream. The <code>TrackRow</code> function will store values incrementally during the stream. Thus, <code>TrackRow</code> enables one to store a set of parameter at each event in a Bolt. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrackRow(name, row)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TrackRow_+3A_name">name</code></td>
<td>

<p>a string with the name of the object that is stored.
</p>
</td></tr>
<tr><td><code id="TrackRow_+3A_row">row</code></td>
<td>

<p>a single row data.frame containing the parameters that are supposed to be tracked over time. See example.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the row is correctly stored.
</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+GetTrack">GetTrack</a></code>, <code><a href="#topic+GetTrackNames">GetTrackNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a topology with a simple spout
topology &lt;- Topology(data.frame(x=c(1:10)))

# Define the bolt and add it 
computeSum &lt;- function(x, ...){
	sum &lt;- GetHash("sum")
	if(is.data.frame(sum)){
		x &lt;- sum + (x[1])
	}
	SetHash("sum", x)
	TrackRow("sum", data.frame(x=x))
}
topology &lt;- AddBolt(topology, Bolt(computeSum))

# Run the stream
result &lt;- RStorm(topology)

# Insepct the result over the timepoints in the stream
GetTrack("sum", result)

</code></pre>

<hr>
<h2 id='Tuple'>
Function to create an object of type <code>Tuple</code> to emit down a stream.
</h2><span id='topic+Tuple'></span><span id='topic+is.Tuple'></span>

<h3>Description</h3>

<p>A <code>Tuple</code> is the main data object that is passed around in a stream. The spout emits Tuples to the different Bolts, and Bolts can Emit Tuples to one another depending on the Topology. The <code>Emit</code> function checks whether indeed objects of type <code>Tuple</code> are emitted. A <code>Tuple</code> object is a single row data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tuple(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tuple_+3A_x">x</code></td>
<td>

<p>a single row data.frame
</p>
</td></tr>
<tr><td><code id="Tuple_+3A_...">...</code></td>
<td>

<p>any other argument
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code>Tuple</code> to be used by an RStorm emitter function
</p>


<h3>Additional Info</h3>

<p>The <code>is.Tuple</code> function checks whether an object is of Type Tuple and is used internally.</p>


<h3>Author(s)</h3>

<p>Maurits Kaptein
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Emit">Emit</a></code>, <code><a href="#topic+Topology">Topology</a></code>, <code><a href="#topic+RStorm">RStorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of a simple object emitted down a stream
spout &lt;- data.frame(x=seq(1,4))
topology &lt;- Topology(spout)

# The Emit function will check if the emitted object is indeed a Tuple
bolt.1 &lt;- function(x, ...){
		Emit(Tuple(x), ...)
	}
	
bolt.2 &lt;- function(x, ...){
	x &lt;- as.numeric(x[1])
	print(x^2)
	}
	
topology &lt;- AddBolt(topology, Bolt(bolt.1, listen=0))
topology &lt;- AddBolt(topology, Bolt(bolt.1, listen=1))
topology &lt;- AddBolt(topology, Bolt(bolt.2, listen=2))

result &lt;- RStorm(topology)
#plot(topology)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
