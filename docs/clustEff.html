<!DOCTYPE html><html lang="en"><head><title>Help for package clustEff</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustEff}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustEff-package'>
<p>Clusters of effects curves</p></a></li>
<li><a href='#clustEff'>
<p>Cluster Effects Algorithm</p></a></li>
<li><a href='#distshape'>
<p>Dissimilarity matrix</p></a></li>
<li><a href='#extract.object'>
<p><code>extract.object</code> fits a multivariate quantile regression and extracts objects for the cluster effects algorithm.</p></a></li>
<li><a href='#fpcac'>
<p>Functional Principal Components Analysis Clustering</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#opt.fpcac'>
<p>Optimal cluster selection in Functional Principal Components Analysis Clustering</p></a></li>
<li><a href='#plot.clustEff'>
<p>Plot Clustering Effects</p></a></li>
<li><a href='#plot.fpcac'>
<p>Plot Functional Principal Component Analysis Clustering</p></a></li>
<li><a href='#summary.clustEff'>
<p>Summary clustEff algorithm</p></a></li>
<li><a href='#summary.fpcac'>
<p>Summary FPCAC algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clusters of Effects Curves in Quantile Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustering method to cluster both effects curves, through quantile regression coefficient modeling, and curves in functional data analysis. Sottile G. and Adelfio G. (2019) &lt;<a href="https://doi.org/10.1007%2Fs00180-018-0817-8">doi:10.1007/s00180-018-0817-8</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>qrcm, cluster, fda, ggpubr, ggplot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 06:01:39 UTC; gianlucasottile</td>
</tr>
<tr>
<td>Author:</td>
<td>Gianluca Sottile [aut, cre],
  Giada Adelfio [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 08:52:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustEff-package'>
Clusters of effects curves
</h2><span id='topic+clustEff-package'></span>

<h3>Description</h3>

<p>This package implements a general algorithm to cluster coefficient functions (i.e. clusters of effects) obtained from a quantile regression (qrcm; Frumento and Bottai, 2016). This algorithm is also used for clustering curves observed in time, as in functional data analysis. The objectives of this algorithm vary with the scenario in which it is used, i.e. in the case of a cluster of effects, in a univariate case the objective may be to reduce its dimensionality or in the multivariate case to group similar effects on a covariate. In the case of a functional data analysis the main objective is to cluster waves or any other function of time or space. Sottile G. and Adelfio G. (2019) &lt;https://doi.org/10.1007/s00180-018-0817-8&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> clustEff</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The function <code><a href="#topic+clustEff">clustEff</a></code> allows to specify the type of the curves to apply the proposed clustering algorithm. The function <code><a href="#topic+extract.object">extract.object</a></code>  extracts the matrices, in case of multivariate response, through the quantile regression coefficient modeling, useful to run the main algorithm.  The auxiliary functions <code><a href="#topic+summary.clustEff">summary.clustEff</a></code> and <code><a href="#topic+plot.clustEff">plot.clustEff</a></code> can be used to extract information from the main algorithm. In the new version of the package you can also find a PCA-based clustering approach called Functional Principal Components Analysis Clustering (FPCAC). Main function of this algorithm is <code><a href="#topic+fpcac">fpcac</a></code>, and some auxiliary functions are <code><a href="#topic+summary.fpcac">summary.fpcac</a></code> and <code><a href="#topic+plot.fpcac">plot.fpcac</a></code>.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile
</p>
<p>Maintainer: Gianluca Sottile &lt;gianluca.sottile@unipa.it&gt;
</p>


<h3>References</h3>

<p>Sottile, G., Adelfio, G. <em>Clusters of effects curves in quantile regression models</em>. Comput Stat 34, 551–569 (2019). https://doi.org/10.1007/s00180-018-0817-8
</p>
<p>Sottile, G and Adelfio, G (2017). <em>Clustering of effects through quantile regression</em>. Proceedings 32nd International Workshop of Statistical Modeling, Groningen (NL), vol.2 127-130, https://iwsm2017.webhosting.rug.nl/IWSM_2017_V2.pdf.
</p>
<p>Frumento, P., and Bottai, M. (2015). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, doi: 10.1111/biom.12410.
</p>
<p>Adelfio, G., Chiodi, M., D'Alessandro, A. and Luzio, D. (2011) <em>FPCA algorithm for waveform clustering</em>. Journal of Communication and Computer, 8(6), 494-502.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Main functions:
set.seed(1234)
n &lt;- 300
x &lt;- 1:n/n

Y &lt;- matrix(0, n, 30)

sigma2 &lt;- 4*pmax(x-.2, 0) - 8*pmax(x-.5, 0) + 4*pmax(x-.8, 0)

mu &lt;- sin(3*pi*x)
for(i in 1:10) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- cos(3*pi*x)
for(i in 11:23) Y[,i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2,0))

mu &lt;- sin(3*pi*x)*cos(pi*x)
for(i in 24:28) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- 0 #sin(1/3*pi*x)*cos(2*pi*x)
for(i in 29:30) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

clustEff(Y)

fpcac(Y, K = opt.fpcac(Y)$K.opt)
</code></pre>

<hr>
<h2 id='clustEff'>
Cluster Effects Algorithm
</h2><span id='topic+clustEff'></span>

<h3>Description</h3>

<p>This function implements the algorithm to cluster curves of effects obtained from a
quantile regression (qrcm; Frumento and Bottai, 2015) in which the coefficients are described by flexible parametric functions of the order of the quantile. This algorithm can be also used for clustering of curves observed in time, as in functional data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustEff(Beta, Beta.lower = NULL, Beta.upper = NULL,
         k = c(2, min(5, (ncol(Beta)-1))), ask = FALSE, diss.mat, alpha = .5,
         step = c("both", "shape", "distance"),
         cut.method = c("mindist", "length", "conf.int"),
         method = "ward.D2", approx.spline = FALSE, nbasis = 50,
         conf.level = 0.9, stand = FALSE, plot = TRUE, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustEff_+3A_beta">Beta</code></td>
<td>
<p>A matrix <kbd>n</kbd> x <kbd>q</kbd>. <kbd>q</kbd> represents the number of curves to cluster and <kbd>n</kbd> is either the length of percentiles used in the quantile regression or the length of the time vector.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_beta.lower">Beta.lower</code></td>
<td>
<p>A matrix <kbd>n</kbd> x <kbd>q</kbd>. <kbd>q</kbd> represents the number of lower interval of the   curves to cluster and <kbd>n</kbd> the length of percentiles used in quantile regression. Used only if cluster.effects=TRUE.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_beta.upper">Beta.upper</code></td>
<td>
<p>A matrix <kbd>n</kbd> x <kbd>q</kbd>. <kbd>q</kbd> represents the number of upper interval of the curves to cluster and <kbd>n</kbd> the length of percentiles used in quantile regression. Used only if cluster.effects=TRUE.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_k">k</code></td>
<td>
<p>It represents the number of clusters to look for. If it is two-length vector (k.min - k.max) an optimization is performed, if it is a unique value it is fixed.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_ask">ask</code></td>
<td>
<p>If TRUE, after plotting the dendrogram, the user make is own choice about how many cluster to use.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_diss.mat">diss.mat</code></td>
<td>
<p>a dissimilarity matrix, obtained by using distshape function.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_alpha">alpha</code></td>
<td>
<p>It is the alpha-percentile used for computing the dissimilarity matrix. The default value is alpha=.5.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_step">step</code></td>
<td>
<p>The steps used in computing the dissimilarity matrix. Default is &quot;both&quot;=(&quot;shape&quot; and  &quot;distance&quot;)</p>
</td></tr>
<tr><td><code id="clustEff_+3A_cut.method">cut.method</code></td>
<td>
<p>The method used in optimization step to look for the optimal number of clusters. Default is &quot;mindist&quot;, however if Beta.lower and Beta.upper are available the suggested method is &quot;conf.int&quot;.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_method">method</code></td>
<td>
<p>The agglomeration method to be used.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_approx.spline">approx.spline</code></td>
<td>
<p>If TRUE, Beta is approximated by a smooth spline.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_nbasis">nbasis</code></td>
<td>
<p>An integer variable specifying the number of basis functions. Only when approx.spline=TRUE</p>
</td></tr>
<tr><td><code id="clustEff_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_stand">stand</code></td>
<td>
<p>If TRUE, the argument Beta is standardized.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_plot">plot</code></td>
<td>
<p>If TRUE, dendrogram, boxplot and clusters are plotted.</p>
</td></tr>
<tr><td><code id="clustEff_+3A_trace">trace</code></td>
<td>
<p>If TRUE, some informations are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantile regression models conditional quantiles of a response variabile,
given a set of covariates. Assume that each coefficient can be expressed as a parametric function of      <code class="reqn">p</code> in the form: </p>
<p style="text-align: center;"><code class="reqn">\beta(p | \theta) = \theta_{0} + \theta_1 b_1(p) + \theta_2 b_2(p) +      \ldots</code>
</p>

<p>where <code class="reqn">b_1(p), b_2(p, \ldots)</code> are known functions of <code class="reqn">p</code>.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>clustEff</code>&rdquo;, a list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The percentiles used in quantile regression coefficient modeling or the time otherwise.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The curves matrix.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>The vector of clusters.</p>
</td></tr>
<tr><td><code>X.mean</code></td>
<td>
<p>The mean curves matrix of dimension <kbd>n</kbd> x <kbd>k</kbd>.</p>
</td></tr>
<tr><td><code>X.mean.dist</code></td>
<td>
<p>The within cluster distance from the mean curve.</p>
</td></tr>
<tr><td><code>X.lower</code></td>
<td>
<p>The lower bound matrix.</p>
</td></tr>
<tr><td><code>X.mean.lower</code></td>
<td>
<p>The mean lower bound of dimension <kbd>n</kbd> x <kbd>k</kbd>.</p>
</td></tr>
<tr><td><code>X.upper</code></td>
<td>
<p>The upper bound matrix.</p>
</td></tr>
<tr><td><code>X.mean.upper</code></td>
<td>
<p>The mean upper bound of dimension <kbd>n</kbd> x <kbd>k</kbd>.</p>
</td></tr>
<tr><td><code>Signif.interval</code></td>
<td>
<p>The matrix of dimension <kbd>n</kbd> x <kbd>k</kbd> containing the intervals in which each mean lower and upper bounds don't include the zero.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The number of selected clusters.</p>
</td></tr>
<tr><td><code>diss.matrix</code></td>
<td>
<p>The dissimilarity matrix.</p>
</td></tr>
<tr><td><code>X.mean.diss</code></td>
<td>
<p>The within cluster dissimilarity.</p>
</td></tr>
<tr><td><code>oggSilhouette</code></td>
<td>
<p>An object of class &ldquo;<code>silhouette</code>&rdquo;.</p>
</td></tr>
<tr><td><code>oggHclust</code></td>
<td>
<p>An object of class &ldquo;<code>hclust</code>&rdquo;.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>A vector of goodness measures used to select the best number of clusters.</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>The selected step.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The used agglomeration method.</p>
</td></tr>
<tr><td><code>cut.method</code></td>
<td>
<p>The used method to select the best number of clusters.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The selected alpha-percentile.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Sottile, G., Adelfio, G. Clusters of effects curves in quantile regression models. Comput Stat 34, 551–569 (2019). https://doi.org/10.1007/s00180-018-0817-8
</p>
<p>Sottile, G and Adelfio, G (2017). <em>Clustering of effects through quantile regression</em>.
Proceedings 32nd International Workshop of Statistical Modeling, Groningen (NL), vol.2 127-130, https://iwsm2017.webhosting.rug.nl/IWSM_2017_V2.pdf.
</p>
<p>Frumento, P., and Bottai, M. (2015). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, doi: 10.1111/biom.12410.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.clustEff">summary.clustEff</a></code>, <code><a href="#topic+plot.clustEff">plot.clustEff</a></code>,
for summary and plotting.
<code><a href="#topic+extract.object">extract.object</a></code> to extract useful objects for the clustering algorithm through a quantile regression coefficient modeling in a multivariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# CURVES EFFECTS CLUSTERING

set.seed(1234)
n &lt;- 300
q &lt;- 2
k &lt;- 5
x1 &lt;- runif(n, 0, 5)
x2 &lt;- runif(n, 0, 5)

X &lt;- cbind(x1, x2)
rownames(X) &lt;- 1:n
colnames(X) &lt;- paste0("X", 1:q)

theta1 &lt;- matrix(c(1, 1, 0, 0, 0, .5, 0, .5, 1, 2, .5, 0, 2, 1, .5),
                 ncol=k, byrow=TRUE)

theta2 &lt;- matrix(c(1, 1, 0, 0, 0, -.3, 0, .5, 1, .5, -1.5, 0, -1, -.5, 1),
                 ncol=k, byrow=TRUE)

theta3 &lt;- matrix(c(1, 1, 0, 0, 0, .3, 0, -.5, -1, 2, -.5, 0, 1, -.5, -1),
                 ncol=k, byrow=TRUE)

rownames(theta3) &lt;- rownames(theta2) &lt;- rownames(theta1) &lt;-
    c("(intercept)", paste("X", 1:q, sep=""))
colnames(theta3) &lt;- colnames(theta2) &lt;- colnames(theta1) &lt;-
    c("(intercept)", "qnorm(p)", "p", "p^2", "p^3")

Theta &lt;- list(theta1, theta2, theta3)

B &lt;- function(p, k){matrix(cbind(1, qnorm(p), p, p^2, p^3), nrow=k, byrow=TRUE)}
Q &lt;- function(p, theta, B, k, X){rowSums(X * t(theta %*% B(p, k)))}

Y &lt;- matrix(NA, nrow(X), 15)
for(i in 1:15){
  if(i &lt;= 5) Y[, i] &lt;- Q(runif(n), Theta[[1]], B, k, cbind(1, X))
  if(i &lt;= 10 &amp; i &gt; 5) Y[, i] &lt;- Q(runif(n), Theta[[2]], B, k, cbind(1, X))
  if(i &lt;= 15 &amp; i &gt; 10) Y[, i] &lt;- Q(runif(n), Theta[[3]], B, k, cbind(1, X))
}

XX &lt;- extract.object(Y, X, intercept=TRUE, formula.p= ~ I(p) + I(p^2) + I(p^3))

obj &lt;- clustEff(XX$X$X1, Beta.lower=XX$Xl$X1, Beta.upper=XX$Xr$X1, cut.method = "conf.int")
summary(obj)
plot(obj, xvar="clusters", col = 1:3)
plot(obj, xvar="dendrogram")
plot(obj, xvar="boxplot")

obj2 &lt;- clustEff(XX$X$X2, Beta.lower=XX$Xl$X2, Beta.upper=XX$Xr$X2, cut.method = "conf.int")
summary(obj2)
plot(obj2, xvar="clusters", col=1:3)
plot(obj2, xvar="dendrogram")
plot(obj2, xvar="boxplot")


## Not run: 
set.seed(1234)
n &lt;- 300
q &lt;- 15
k &lt;- 5
X &lt;- matrix(rnorm(n*q), n, q); X &lt;- scale(X)
rownames(X) &lt;- 1:n
colnames(X) &lt;- paste0("X", 1:q)

Theta &lt;- matrix(c(1, 1, 0, 0, 0,
                  .5, 0, .5, 1, 1,
                  .5, 0, 1, 2, .5,
                   .5, 0, 1, 1, .5,
                  .5, 0, .5, 1, 1,
                   .5, 0, .5, 1, .5,
                 -1.5, 0, -.5, 1, 1,
                  -1, 0, .5, -1, -1,
                 -.5, 0, -.5, -1, .5,
                  -1, 0, .5, -1, -.5,
                -1.5, 0, -.5, -1, -.5,
                  2, 0, 1, 1.5, 2,
                  2, 0, .5, 1.5, 2,
                  2.5, 0, 1, 1, 2,
                  1.5, 0, 1.5, 1, 2,
                  3, 0, 2, 1, .5),
                 ncol=k, byrow=TRUE)
rownames(Theta) &lt;- c("(intercept)", paste("X", 1:q, sep=""))
colnames(Theta) &lt;- c("(intercept)", "qnorm(p)", "p", "p^2", "p^3")

B &lt;- function(p, k){matrix(cbind(1, qnorm(p), p, p^2, p^3), nrow=k, byrow=TRUE)}
Q &lt;- function(p, theta, B, k, X){rowSums(X * t(theta %*% B(p, k)))}

s &lt;- matrix(1, q+1, k)
s[2:(q+1), 2] &lt;- 0
s[1, 3:k] &lt;- 0

Y &lt;- Q(runif(n), Theta, B, k, cbind(1, X))
XX &lt;- extract.object(Y, X, intercept = TRUE, formula.p= ~ I(p) + I(p^2) + I(p^3))

obj3 &lt;- clustEff(XX$X, Beta.lower=XX$Xl, Beta.upper=XX$Xr, cut.method = "conf.int")
summary(obj3)

# changing the alpha-percentile clusters are correctly identified

obj4 &lt;- clustEff(XX$X, Beta.lower=XX$Xl, Beta.upper=XX$Xr, cut.method = "conf.int",
                 alpha = 0.25)
summary(obj4)

# CURVES CLUSTERING IN FUNCTIONAL DATA ANALYSIS

set.seed(1234)
n &lt;- 300
x &lt;- 1:n/n

Y &lt;- matrix(0, n, 30)

sigma2 &lt;- 4*pmax(x-.2, 0) - 8*pmax(x-.5, 0) + 4*pmax(x-.8, 0)

mu &lt;- sin(3*pi*x)
for(i in 1:10) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- cos(3*pi*x)
for(i in 11:23) Y[,i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2,0))

mu &lt;- sin(3*pi*x)*cos(pi*x)
for(i in 24:28) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- 0 #sin(1/3*pi*x)*cos(2*pi*x)
for(i in 29:30) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

obj5 &lt;- clustEff(Y)
summary(obj5)
plot(obj5, xvar="clusters", col=1:4)
plot(obj5, xvar="dendrogram")
plot(obj5, xvar="boxplot")

## End(Not run)

</code></pre>

<hr>
<h2 id='distshape'>
Dissimilarity matrix
</h2><span id='topic+distshape'></span>

<h3>Description</h3>

<p>This function implements the dissimilarity matrix based on shape and distance of curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distshape(Beta, alpha=.5, step=c("both", "shape", "distance"), trace=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distshape_+3A_beta">Beta</code></td>
<td>

<p>A matrix <kbd>n</kbd> x <kbd>q</kbd>. <kbd>q</kbd> represents the number of curves to cluster and <kbd>n</kbd> is either the length of percentiles used in the quantile regression or the length of the time vector.
</p>
</td></tr>
<tr><td><code id="distshape_+3A_alpha">alpha</code></td>
<td>

<p>It is the alpha-percentile used for computing the dissimilarity matrix. If not fixed, the algorithm choose alpha=.25 (cluster.effects=TRUE) or alpha=.5 (cluster.effects=FALSE).
</p>
</td></tr>
<tr><td><code id="distshape_+3A_step">step</code></td>
<td>

<p>The steps used in computing the dissimilarity matrix. Default is &quot;both&quot;=(&quot;shape&quot; and  &quot;distance&quot;)
</p>
</td></tr>
<tr><td><code id="distshape_+3A_trace">trace</code></td>
<td>

<p>If TRUE, some informations are printed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The dissimilarity matrix of class &ldquo;<code>dist</code>&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Sottile, G., Adelfio, G. Clusters of effects curves in quantile regression models. Comput Stat 34, 551–569 (2019). https://doi.org/10.1007/s00180-018-0817-8
</p>
<p>Sottile, G and Adelfio, G (2017). <em>Clustering of effects through quantile regression</em>.
Proceedings 32nd International Workshop of Statistical Modeling, Groningen (NL), vol.2 127-130, https://iwsm2017.webhosting.rug.nl/IWSM_2017_V2.pdf.
</p>
<p>Frumento, P., and Bottai, M. (2015). <em>Parametric modeling of quantile regression coefficient functions</em>. Biometrics, doi: 10.1111/biom.12410.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustEff">clustEff</a></code>,<code><a href="#topic+summary.clustEff">summary.clustEff</a></code>, <code><a href="#topic+plot.clustEff">plot.clustEff</a></code>,
for summary and plotting.
<code><a href="#topic+extract.object">extract.object</a></code> to extract useful objects for the clustering algorithm through a quantile regression coefficient modeling in a multivariate case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n &lt;- 300
x &lt;- 1:n/n

Y &lt;- matrix(0, n, 30)

sigma2 &lt;- 4*pmax(x-.2, 0) - 8*pmax(x-.5, 0) + 4*pmax(x-.8, 0)

mu &lt;- sin(3*pi*x)
for(i in 1:10) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- cos(3*pi*x)
for(i in 11:23) Y[,i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2,0))

mu &lt;- sin(3*pi*x)*cos(pi*x)
for(i in 24:28) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- 0 #sin(1/3*pi*x)*cos(2*pi*x)
for(i in 29:30) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

diss &lt;- distshape(Y)
diss

</code></pre>

<hr>
<h2 id='extract.object'>
<code>extract.object</code> fits a multivariate quantile regression and extracts objects for the cluster effects algorithm.
</h2><span id='topic+extract.object'></span>

<h3>Description</h3>

<p><code>extract.object</code> fits a multivariate quantile regression and extracts objects for the cluster effects algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.object(Y, X, intercept=TRUE, formula.p=~slp(p, 3), s, object, p, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.object_+3A_y">Y</code></td>
<td>
<p>A multivariate response matrix of dimension <kbd>n</kbd> x <kbd>q1</kbd>, or a vector of length <kbd>n</kbd>.</p>
</td></tr>
<tr><td><code id="extract.object_+3A_x">X</code></td>
<td>
<p>The covariates matrix of dimension <kbd>n</kbd> x <kbd>q2</kbd>.</p>
</td></tr>
<tr><td><code id="extract.object_+3A_intercept">intercept</code></td>
<td>
<p>If TRUE, the intercept is included in the model.</p>
</td></tr>
<tr><td><code id="extract.object_+3A_formula.p">formula.p</code></td>
<td>
<p>a one-sided formula of the form <code>~ b1(p, ...) + b2(p, ...) + ...</code></p>
</td></tr>
<tr><td><code id="extract.object_+3A_s">s</code></td>
<td>
<p>An optional 0/1 matrix that allows to exclude some model coefficients (see &lsquo;Examples&rsquo;).</p>
</td></tr>
<tr><td><code id="extract.object_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;<code>iqr</code>&rdquo;. If missing, Y and X have to be supplied.</p>
</td></tr>
<tr><td><code id="extract.object_+3A_p">p</code></td>
<td>
<p>The percentiles used in quantile regression coefficient modeling. If missing a default sequence is choosen.</p>
</td></tr>
<tr><td><code id="extract.object_+3A_which">which</code></td>
<td>
<p>If fixed, only the selected covariates are extraced from the model. If missing all the covariates are extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A list of objects useful to run the cluster effect algorithm is created.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>The percentiles used in  the quantile regression.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>A list containing as many matrices as covariates, where for each matrix the number of columns corresponds to the number of the responses. Each column of a matrix corresponds to one curve effect. In the case of a univariate model it is a unique matrix.</p>
</td></tr>
<tr><td><code>Xl</code></td>
<td>
<p>A list as <kbd>X</kbd>. Each column of a matrix corresponds to the lower interval of the curve effect. In the case of a univariate model it is a unique matrix.</p>
</td></tr>
<tr><td><code>Xr</code></td>
<td>
<p>A list as <kbd>X</kbd>. Each column of a matrix corresponds to the upper interval of the curve effect. In the case of a univariate model it is a unique matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustEff">clustEff</a></code>, for clustering algorithm; <code><a href="#topic+summary.clustEff">summary.clustEff</a></code> and <code><a href="#topic+plot.clustEff">plot.clustEff</a></code>, for summarizing and plotting <code>clustEff</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

# see the documentation for 'clustEff'

</code></pre>

<hr>
<h2 id='fpcac'>
Functional Principal Components Analysis Clustering
</h2><span id='topic+fpcac'></span>

<h3>Description</h3>

<p>This function implements the algorithm FPCAC for curves clustering as a variant of a k-means algorithm based on the principal component rotation of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpcac(X, K = 2, fd = NULL, nbasis = 5, norder = 3, nharmonics = 3,
      alpha = 0, niter = 30, Ksteps = 25, conf.level = 0.9, seed, disp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpcac_+3A_x">X</code></td>
<td>
<p>Matrix of &lsquo;curves&rsquo; of dimension <kbd>n</kbd> x <kbd>q</kbd>.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_k">K</code></td>
<td>
<p>the number of  clusters.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_fd">fd</code></td>
<td>
<p>If not NULL it overrides X and must be an object of class fd.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_nbasis">nbasis</code></td>
<td>
<p>an integer variable specifying the number of basis functions. The default value is 5.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_norder">norder</code></td>
<td>
<p>an integer specifying the order of b-splines, which is one higher than their degree. The default value is 3.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_nharmonics">nharmonics</code></td>
<td>
<p>the number of harmonics or principal components to use. The default value is 3.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_alpha">alpha</code></td>
<td>
<p>trimming size, that is  the given proportion of observations to be
discarded.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_niter">niter</code></td>
<td>
<p>the number or random restarting (larger values provide more accurate solutions.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_ksteps">Ksteps</code></td>
<td>
<p>the number of k-mean steps (not too many ksteps are needed).</p>
</td></tr>
<tr><td><code id="fpcac_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_seed">seed</code></td>
<td>
<p>the seed used for reproducibility.</p>
</td></tr>
<tr><td><code id="fpcac_+3A_disp">disp</code></td>
<td>
<p>if TRUE, it is used to print some information across the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FPCAC is a functional
PCA-based clustering approach that provides a variation of the algorithm for curves
clustering proposed by Garcia-Escudero and Gordaliza (2005).
</p>
<p>The starting point of the proposed FPCAC is to find a
linear approximation of each curve by a finite $p$ dimensional
vector of coefficients defined by the FPCA scores.
</p>
<p>The number of starting clusters <kbd>k</kbd> is obtained on the basis of  the scores
volume, such that we assign events to the clusters defined by
events that have a distance less than a fixed threshold (e.g.
90-th percentile) in the space of PCA scores. Once <kbd>k</kbd> is obtained
we use a modified version of the trimmed <kbd>k</kbd>-means algorithm, that
considers the matrix of FPCA scores instead of the coefficients of
a linear fitting to B-spline bases.
</p>
<p>The trimmed <kbd>k</kbd>-means clustering algorithm looks for the <kbd>k</kbd> centers
<code class="reqn">C_1, ..., C_k</code> that are solution of the minimization problem:
</p>
<p style="text-align: center;"><code class="reqn">O_k(\alpha)=\min_Y \min_{C_1, \cdots, C_k} \frac{1}{[n(1-\alpha)]}
\sum_{X_i \in Y} \inf_{1\leq j \leq k} || X_i- C_j||^2</code>
</p>

<p>We think that the proposed
approach has the advantage of an immediate use of PCA for
functional data avoiding some objective choices related to spline
fitting as in RCC. Simulations and applications suggest also the
well behavior of the FPCAC algorithm, both in terms of stable and
easily interpretable results.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;<code>fpcac</code>&rdquo;, a list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>obj.function</code></td>
<td>
<p>The percentiles used in the quantile regression coefficient modeling or  objective function <kbd>O_k(\alpha)</kbd>.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>The curves matrix.</p>
</td></tr>
<tr><td><code>radius</code></td>
<td>
<p>The vector of clusters.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>The mean curves matrix of dimension <kbd>n</kbd> x <kbd>k</kbd>.</p>
</td></tr>
<tr><td><code>Xorig</code></td>
<td>
<p>The atrix of &lsquo;curves&rsquo; of dimension <kbd>n</kbd> x <kbd>q</kbd>.</p>
</td></tr>
<tr><td><code>fd</code></td>
<td>
<p>The object obtained by the call of FPCA of class &lsquo;fd&rsquo;</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The matrix of &lsquo;curves&rsquo; transformed through FPCA of dimension <kbd>p</kbd> x <kbd>nharmonics</kbd>.</p>
</td></tr>
<tr><td><code>X.mean</code></td>
<td>
<p>The mean curves matrix of dimension <kbd>n</kbd> x <kbd>k</kbd>.</p>
</td></tr>
<tr><td><code>diss.matrix</code></td>
<td>
<p>The Euclidean distance matrix of the transformed curves.</p>
</td></tr>
<tr><td><code>oggSilhouette</code></td>
<td>
<p>An object of class &lsquo;silhouette&rsquo;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p>Adelfio, G., Chiodi, M., D'Alessandro, A. and Luzio, D. (2011) FPCA algorithm for waveform clustering. Journal of Communication and Computer, 8(6), 494-502.
</p>
<p>Adelfio, G., Chiodi, M., D'Alessandro, A., Luzio, D., D'Anna, G., Mangano, G. (2012) Simultaneous seismic wave clustering and registration. Computers &amp; Geosciences 44, 60-69.
</p>
<p>Garcia-Escudero, L. A. and Gordaliza, A. (2005). A proposal for
robust curve clustering, Journal of classification, 22, 185-201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt.fpcac">opt.fpcac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 300
x &lt;- 1:n/n

Y &lt;- matrix(0, n, 30)

sigma2 &lt;- 4*pmax(x-.2, 0) - 8*pmax(x-.5, 0) + 4*pmax(x-.8, 0)

mu &lt;- sin(3*pi*x)
for(i in 1:10) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- cos(3*pi*x)
for(i in 11:23) Y[,i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2,0))

mu &lt;- sin(3*pi*x)*cos(pi*x)
for(i in 24:28) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- 0 #sin(1/3*pi*x)*cos(2*pi*x)
for(i in 29:30) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

obj &lt;- fpcac(Y, K = 4, disp = FALSE)
obj
</code></pre>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+internals'></span><span id='topic+.get_ave_sil_width'></span><span id='topic+.get_withinSS'></span><span id='topic+print.clustEff'></span><span id='topic+print.summary.clustEff'></span><span id='topic+print.fpcac'></span><span id='topic+print.summary.fpcac'></span>

<h3>Description</h3>

<p>Functions for internal use only, or not yet documented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_ave_sil_width(d, cluster)
.get_withinSS(d, cluster)

## S3 method for class 'clustEff'
print(x, digits=max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.clustEff'
print(x, digits=max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'fpcac'
print(x, digits=max(3L, getOption("digits") - 3L), ...)
## S3 method for class 'summary.fpcac'
print(x, digits=max(3L, getOption("digits") - 3L), ...)
</code></pre>

<hr>
<h2 id='opt.fpcac'>
Optimal cluster selection in Functional Principal Components Analysis Clustering
</h2><span id='topic+opt.fpcac'></span>

<h3>Description</h3>

<p>This function provides the optimal selection of clusters for  the algorithm FPCAC,  as a variant of a k-means algorithm based on the principal component rotation of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.fpcac(X, k.max = 5, method = c("silhouette", "wss"),
          fd = NULL, nbasis = 5, norder = 3, nharmonics = 3,
          alpha = 0, niter = 30, Ksteps = 10, seed,
          diss = NULL, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.fpcac_+3A_x">X</code></td>
<td>
<p>Matrix of &lsquo;curves&rsquo; of dimension <kbd>n</kbd> x <kbd>q</kbd>. </p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_k.max">k.max</code></td>
<td>
<p>the number of cluster used in the optimization step to select the optimal one.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_method">method</code></td>
<td>
<p>the method used to select the optimal number of clusters, &quot;silhouette&quot; or &quot;wss&quot; (whithin sum of squares.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_fd">fd</code></td>
<td>
<p>If not NULL it overrides X and must be an object of class fd.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_nbasis">nbasis</code></td>
<td>
<p>an integer variable specifying the number of basis functions. The default value is 5.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_norder">norder</code></td>
<td>
<p>an integer specifying the order of b-splines, which is one higher than their degree. The default value is 3.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_nharmonics">nharmonics</code></td>
<td>
<p>the number of harmonics or principal components to use. The default value is 3.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_alpha">alpha</code></td>
<td>
<p>trimming size, that is  the given proportion of observations to be
discarded.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_niter">niter</code></td>
<td>
<p>the number or random restarting (larger values provide more accurate solutions.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_ksteps">Ksteps</code></td>
<td>
<p>the number of k-mean steps (not too many ksteps are needed).</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_seed">seed</code></td>
<td>
<p>the seed used for reproducibility.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_diss">diss</code></td>
<td>
<p>the dissimilarity matrix used to compute measures &quot;silhouette&quot; or &quot;wss&quot;.</p>
</td></tr>
<tr><td><code id="opt.fpcac_+3A_trace">trace</code></td>
<td>
<p>if TRUE, it is used to print some information across the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Silhouette is a method for validate the consistency within clusters, providing a measure  of how similar an object is to its own cluster  compared to other clusters.
The silhouette score S belongs to the interval [-1,1].
S close to one means that the data is appropriately clustered. If S is close to negative one, datum should be clustered in its neighbouring cluster. S near zero means that the datum is on the border of two natural clusters.
</p>
<p>The wss is obtained as the classical sum of the squared deviations from each observation and the cluster centroid, providing  a measure of the variability of the observations within each cluster. Clusters with higher values exhibit greater variability of the observations within the cluster.
</p>


<h3>Value</h3>

<p>a list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>obj.function</code></td>
<td>
<p>the sequence of objective functions.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the matrix in which each columns identify clusters for each fixed K.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the sequence of K used.</p>
</td></tr>
<tr><td><code>K.opt</code></td>
<td>
<p>the optimal number of clusters</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>a ggplot object to plot the curve of silhouette or whithin sum of squares.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>References</h3>

<p> Peter J. Rousseeuw (1987). Silhouettes: a Graphical Aid to the Interpretation and Validation of Cluster Analysis. Computational and Applied Mathematics. 20, 53-65
</p>
<p>K. V. Mardia, J. T. Kent and J. M. Bibby (1979). Multivariate Analysis. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpcac">fpcac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
n &lt;- 300
x &lt;- 1:n/n

Y &lt;- matrix(0, n, 30)

sigma2 &lt;- 4*pmax(x-.2, 0) - 8*pmax(x-.5, 0) + 4*pmax(x-.8, 0)

mu &lt;- sin(3*pi*x)
for(i in 1:10) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- cos(3*pi*x)
for(i in 11:23) Y[,i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2,0))

mu &lt;- sin(3*pi*x)*cos(pi*x)
for(i in 24:28) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

mu &lt;- 0 #sin(1/3*pi*x)*cos(2*pi*x)
for(i in 29:30) Y[, i] &lt;- mu + rnorm(length(x), 0, pmax(sigma2, 0))

num.clust &lt;- opt.fpcac(Y)
obj2 &lt;- fpcac(Y, K = num.clust$K.opt, disp = FALSE)
obj2

</code></pre>

<hr>
<h2 id='plot.clustEff'>
Plot Clustering Effects
</h2><span id='topic+plot.clustEff'></span>

<h3>Description</h3>

<p>Produces a dendrogram, a cluster plot and a boxplot of average distance cluster of an object of class &ldquo;<code>clustEff</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustEff'
plot(x, xvar=c("clusters", "dendrogram", "boxplot", "numclust"), which,
        polygon=TRUE, dissimilarity=TRUE, par=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.clustEff_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;<code>clustEdd</code>&rdquo;, typically the result of a call to <code><a href="#topic+clustEff">clustEff</a></code>.</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_xvar">xvar</code></td>
<td>

<p>Clusters: plot of the k clusters;
Dendrogram: plot of the tree after computing the dissimilarity measure and applying a hierarchical       clustering algorithm;
Boxplot: plot the average distance within clusters;
Numclust: plot the curve to minimize to select the best number of clusters;
</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_which">which</code></td>
<td>
<p>If missing all curves effect are plotted.</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_polygon">polygon</code></td>
<td>
<p>If TRUE confidence intervals are represented by shaded areas via polygon. Otherwise, dashed lines are used. If NULL no confidence intervals are represented</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>If TRUE dissimilarity measure within each cluster is used to do boxplot representation.</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_par">par</code></td>
<td>
<p>If TRUE the screen is automaticcaly splitted.</p>
</td></tr>
<tr><td><code id="plot.clustEff_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd, lty</kbd>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different plot for the clustering algorithm.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.ot">gianluca.sottile@unipa.ot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustEff">clustEff</a></code> for cluster algorithm; <code><a href="#topic+extract.object">extract.object</a></code> for extracting information through a quantile regression coefficient modeling in a multivariate case; <code><a href="#topic+summary.clustEff">summary.clustEff</a></code> for clustering summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data

  # see the documentation for 'clustEff'

</code></pre>

<hr>
<h2 id='plot.fpcac'>
Plot Functional Principal Component Analysis Clustering
</h2><span id='topic+plot.fpcac'></span>

<h3>Description</h3>

<p>Produces a cluster plot of an object of class &ldquo;<code>fpcac</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcac'
plot(x, which, polygon=TRUE, conf.level, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fpcac_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;<code>clustEdd</code>&rdquo;, typically the result of a call to <code><a href="#topic+fpcac">fpcac</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fpcac_+3A_which">which</code></td>
<td>
<p>If missing all curves effect are plotted.</p>
</td></tr>
<tr><td><code id="plot.fpcac_+3A_polygon">polygon</code></td>
<td>
<p>If TRUE confidence intervals are represented by shaded areas via polygon. Otherwise, dashed lines are used. If NULL no confidence intervals are represented</p>
</td></tr>
<tr><td><code id="plot.fpcac_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="plot.fpcac_+3A_...">...</code></td>
<td>
<p>additional graphical parameters, that can include <kbd>xlim, ylim, xlab, ylab, col, lwd, lty</kbd>. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different plot for the clustering algorithm.
</p>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.ot">gianluca.sottile@unipa.ot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpcac">fpcac</a></code>, <code><a href="#topic+summary.fpcac">summary.fpcac</a></code>, <code><a href="#topic+opt.fpcac">opt.fpcac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # using simulated data

  # see the documentation for 'fpcac'

</code></pre>

<hr>
<h2 id='summary.clustEff'>
Summary clustEff algorithm
</h2><span id='topic+summary.clustEff'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>clustEff</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustEff'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.clustEff_+3A_object">object</code></td>
<td>

<p>An object of class &ldquo;<code>clustEff</code>&rdquo;, the result of a call to <code><a href="#topic+clustEff">clustEff</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.clustEff_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary of the clustering algorithm is printed.
</p>


<h3>Value</h3>

<p>The following items is returned:
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>The number of selected clusters.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The number of curves.</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>The selected step for computing the dissimilarity matrix.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The alpha-percentile used for computing the dissimilarity matrix.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The selected method to compute the hierarchical cluster analysis.</p>
</td></tr>
<tr><td><code>cut.method</code></td>
<td>
<p>The selected method to choose the best number of clusters.</p>
</td></tr>
<tr><td><code>tabClust</code></td>
<td>
<p>The table of clusters.</p>
</td></tr>
<tr><td><code>avClust</code></td>
<td>
<p>The average distance within clusters.</p>
</td></tr>
<tr><td><code>avSilhouette</code></td>
<td>
<p>Silhouette widths for clusters.</p>
</td></tr>
<tr><td><code>avDiss</code></td>
<td>
<p>The average dissimilarity measure within clusters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustEff">clustEff</a></code>, for cluster algorithm<code><a href="#topic+extract.object">extract.object</a></code> for extracting information through a quantile regression coefficient modeling in a multivariate case and plotting objects of class &ldquo;<code>clustEff</code>&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

# see the documentation for 'clustEff'

</code></pre>

<hr>
<h2 id='summary.fpcac'>
Summary FPCAC algorithm
</h2><span id='topic+summary.fpcac'></span>

<h3>Description</h3>

<p>Summary of an object of class &ldquo;<code>fpcac</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpcac'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fpcac_+3A_object">object</code></td>
<td>

<p>An object of class &ldquo;<code>fpcac</code>&rdquo;, the result of a call to <code><a href="#topic+fpcac">fpcac</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.fpcac_+3A_...">...</code></td>
<td>
<p>for future methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A summary of the clustering algorithm is printed.
</p>


<h3>Value</h3>

<p>The following items is returned:
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>The number of selected clusters.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of curves.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The number of harmonics used.</p>
</td></tr>
<tr><td><code>trimmed</code></td>
<td>
<p>The number of trimmed curves.</p>
</td></tr>
<tr><td><code>tabClust</code></td>
<td>
<p>The table of clusters.</p>
</td></tr>
<tr><td><code>avClust</code></td>
<td>
<p>The average distance within clusters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gianluca Sottile <a href="mailto:gianluca.sottile@unipa.it">gianluca.sottile@unipa.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fpcac">fpcac</a></code>, <code><a href="#topic+opt.fpcac">opt.fpcac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using simulated data

# see the documentation for 'fpcac'

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
