<!DOCTYPE html><html lang="en"><head><title>Help for package spectralGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spectralGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.blocks.gp'><p>Adds coefficient block structure to a spectral GP object</p></a></li>
<li><a href='#calc.variances.gp'><p> Calculates prior variances of coefficients in a spectral GP object</p></a></li>
<li><a href='#change.param.gp'><p> Changes correlation function parameter values of a spectral GP object</p></a></li>
<li><a href='#copy.gp'><p>Copy a spectral GP object.</p></a></li>
<li><a href='#expand.gpgrid.gp'><p>Calculate grid locations for a spectral GP object.</p></a></li>
<li><a href='#getgrid.gp'><p>Calculates the gridpoints in a spectral GP object</p></a></li>
<li><a href='#Gibbs.sample.coeff.gp'><p> Samples new coeffients via Gibbs sampling in a spectral GP object.</p></a></li>
<li><a href='#gp'><p>Create a new GP object</p></a></li>
<li><a href='#Hastings.coeff.gp'><p>Calculates Hastings value of coefficients</p></a></li>
<li><a href='#image_plot'>
<p>Draws image plot with a legend strip for the color scale.</p></a></li>
<li><a href='#is.gp'><p>Test if object is a spectral GP</p></a></li>
<li><a href='#lines.gp'><p>Add a line plot for a one-dimensional process based on a spectral GP object</p></a></li>
<li><a href='#logdensity.gp'><p>Calculates log prior density of a spectral GP object</p></a></li>
<li><a href='#lonlat2xy'><p>Projects lon/lat coordinates to x/y Euclidean coordinate system</p></a></li>
<li><a href='#matern.specdens'><p>Matern correlation spectral density function</p></a></li>
<li><a href='#names.gp'><p>The names of the elements of a GP object</p></a></li>
<li><a href='#new.mapping'><p>Map arbitrary locations to gridpoints of spectral GP object</p></a></li>
<li><a href='#plot.gp'><p>Plot a process based on a spectral GP object</p></a></li>
<li><a href='#points.gp'><p>Add points for a one-dimensional process based on a spectral GP object</p></a></li>
<li><a href='#predict.gp'><p>Prediction from a spectral GP object</p></a></li>
<li><a href='#print.gp'><p>Spectral GP default print statement</p></a></li>
<li><a href='#propose.coeff.gp'><p> Proposes new coeffients in a spectral GP object.</p></a></li>
<li><a href='#rdist.earth'>
<p>Great circle distance matrix</p></a></li>
<li><a href='#simulate.gp'><p>Simulates a process realization from a spectral GP object</p></a></li>
<li><a href='#spectralGP'>
<p>spectralGP - tools for specifying Gaussian processes using the</p>
computationally efficient Fourier basis</a></li>
<li><a href='#spectralGP-generic'>
<p>spectralGP generic functions</p></a></li>
<li><a href='#updateprocess.gp'><p>Recalculate process values in a spectral GP object</p></a></li>
<li><a href='#xy2unit'><p>Scales locations to the unit hypercube for use in spectral GP</p></a></li>
<li><a href='#zero.coeff.gp'><p>Sets coefficients to zero in a spectral GP object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-06-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Paciorek &lt;paciorek@alumni.cmu.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Paciorek &lt;paciorek@alumni.cmu.edu&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate Gaussian Processes Using the Fourier Basis</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for creating, manipulating, and performing 
 Bayesian inference about Gaussian processes in 
 one and two dimensions using the Fourier basis approximation: 
 simulation and plotting of processes, calculation of 
 coefficient variances, calculation of process density, 
 coefficient proposals (for use in MCMC).  It uses R environments to
 store GP objects as references/pointers.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, grDevices</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.jstatsoft.org/v19/a2">http://www.jstatsoft.org/v19/a2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-01 00:43:57 UTC; paciorek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-01 06:11:48</td>
</tr>
</table>
<hr>
<h2 id='add.blocks.gp'>Adds coefficient block structure to a spectral GP object</h2><span id='topic+add.blocks.gp'></span>

<h3>Description</h3>

<p>Adds block structure to a GP object,
allowing simulating and sampling (in an MCMC
setup) from blocks of coefficients, as opposed to all the coefficients
at once.  The size of the blocks will usually increase with increasing
frequency as the most important coefficients are those for the low
frequency basis functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
add.blocks(object, breaks = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.blocks.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>. </p>
</td></tr>
<tr><td><code id="add.blocks.gp_+3A_breaks">breaks</code></td>
<td>
<p>An optional vector of increasing frequency values that allow for
binning the coefficients based on the frequencies of the basis
functions with which they are associated. The maximum value of the
vector should be one half the number of gridpoints in the dimension
with the largest number of gridpoints (e.g., 64, if
gridsize=c(32,128)).  </p>
</td></tr>
<tr><td><code id="add.blocks.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function sets up a block structure with blocks with increasing
numbers of coefficients as the frequencies increase.  The frequency
in question is the highest frequency of the (<code class="reqn">omega_1,omega_2</code>) pair in
the two-dimensional situation.  E.g., the default block structure is
c(1,2,4,8,16,...), which means that the first block is the
coefficients whose maximum frequency is 1, the second with maximum
frequency is 2, the third with maximum frequency of 3 and 4, the
fourth with maximum frequency between 5 and 8, etc.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
add.blocks(gp1,c(1,3,7,15,31,64))
add.blocks(gp2)
propose.coeff(gp1,block=5)
plot(gp1)
propose.coeff(gp2,block=2,proposal.sd=0.1)
plot(gp2)
</code></pre>

<hr>
<h2 id='calc.variances.gp'> Calculates prior variances of coefficients in a spectral GP object</h2><span id='topic+calc.variances.gp'></span>

<h3>Description</h3>

<p>Calculates the prior variances of the spectral coefficients in a GP
object.  The variances are based on the spectral density function
chosen in <code>gp</code> and the 
correlation function parameters supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
calc.variances(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.variances.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="calc.variances.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is  an internal function not meant to be called by the user. 
The prior variances for each coefficient are calculated based on the
frequency of the corresponding basis function, the spectral density
function, the parameters of the spectral density/correlation
function, and the (optional) coefficient variance parameter.
The function creates <code>variances</code>, a matrix of
variances corresponding to <code>coeff</code>,  the matrix of coefficients.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+logdensity.gp">logdensity.gp</a></code>, <code><a href="#topic+change.param.gp">change.param.gp</a></code></p>

<hr>
<h2 id='change.param.gp'> Changes correlation function parameter values of a spectral GP object</h2><span id='topic+change.param.gp'></span>

<h3>Description</h3>

<p>Changes the correlation parameter values or the (optional) variance
parameter and  recalculates the prior
variances of the coefficients using <code>calc.variances.gp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
change.param(object,new.specdens.param=NULL,
  new.variance.param=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change.param.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="change.param.gp_+3A_new.specdens.param">new.specdens.param</code></td>
<td>
<p>A vector of new parameter values, matching the length
of the original parameter vector.</p>
</td></tr>
<tr><td><code id="change.param.gp_+3A_new.variance.param">new.variance.param</code></td>
<td>
<p>The new variance parameter value.</p>
</td></tr>
<tr><td><code id="change.param.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to change the parameter values of the
spectral GP object and recalculate the prior variances for the
coefficients.  This is particularly useful for implementing MCMC with
the spectral GP.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+calc.variances.gp">calc.variances.gp</a></code>, <code><a href="#topic+logdensity.gp">logdensity.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
rho=1
gp1=gp(128,matern.specdens,c(rho,4))
gp2=gp(c(64,64),matern.specdens,c(rho,4),0.5)
propose.coeff(gp1)
propose.coeff(gp2)
print(logdensity(gp1))
print(logdensity(gp2))
rho=2
sigma=2.5
change.param(gp1,c(rho,4)) # change parameter values of correlation function
change.param(gp2,c(rho,4),sigma)
print(logdensity(gp1))
print(logdensity(gp2))
</code></pre>

<hr>
<h2 id='copy.gp'>Copy a spectral GP object.</h2><span id='topic+copy.gp'></span>

<h3>Description</h3>

<p>Creates a new copy of a spectral GP object, with new memory
allocated for the object, or copies the elements of one spectral GP
object to another one that is already in existence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
copy(object, object2 = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copy.gp_+3A_object">object</code></td>
<td>
<p>Spectral GP object to be copied.</p>
</td></tr>
<tr><td><code id="copy.gp_+3A_object2">object2</code></td>
<td>
<p>Already existing spectral GP object to which the
elements of <code>object</code> should be copied.  If NULL, the function
returns a newly-created copy of <code>object</code>.</p>
</td></tr>
<tr><td><code id="copy.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function copies an object of class gp.  More details on the
spectral representation of GPs can be found in Paciorek (2006). 
</p>


<h3>Value</h3>

<p>An object of class gp.  If <code>object2</code> is specified, returns NULL.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+is.gp">is.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(128,matern.specdens,c(0.5,4))
copy(gp1,gp2)  # gp2 is now a copy of gp1, with first parameter equal to 1
gp3=copy(gp1)
</code></pre>

<hr>
<h2 id='expand.gpgrid.gp'>Calculate grid locations for a spectral GP object.</h2><span id='topic+expand.gpgrid.gp'></span>

<h3>Description</h3>

<p>This is a version of <code>expand.grid</code> that calculates the grid
locations  for a spectral GP object. Gridpoints representing the
part of the domain in which the periodicity of the GP emerges are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
expand.gpgrid(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.gpgrid.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="expand.gpgrid.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function is not named <code>expand.grid.gp</code> because
<code>expand.grid</code> is a function, and not an S3 method.
</p>


<h3>Value</h3>

<p>A matrix of grid locations with the first column the
x-dimension and the second the y-dimension, or for one dimensional
processes, a vector of grid locations.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+getgrid.gp">getgrid.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
grid1=expand.gpgrid(gp1)
grid2=expand.gpgrid(gp2)
plot(grid2)
</code></pre>

<hr>
<h2 id='getgrid.gp'>Calculates the gridpoints in a spectral GP object</h2><span id='topic+getgrid.gp'></span>

<h3>Description</h3>

<p>Calculates the sequence of gridpoints in each dimension for a spectral
GP object.  Gridpoints representing the part of the domain in which
the periodicity of the GP emerges are omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
getgrid(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getgrid.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="getgrid.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Not meant to be used directly by the user, unless the user
needs the unique gridpoints in each dimension. For the expanded grid
that corresponds to the process values, with each row containing the
two coordinates of a grid location, use <code>expand.gpgrid</code>.
</p>


<h3>Value</h3>

<p>For two dimensions, a list containing the gridpoints in each
dimension, with the first element containing the unique 
gridpoints in the first dimension and the second element the unique
gridpoints in the second dimension, or for one-dimensional
processes, a vector of gridpoints.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+getgrid.gp">getgrid.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code>, <code><a href="#topic+expand.gpgrid.gp">expand.gpgrid.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
grid1=getgrid(gp1)
grid2=getgrid(gp2)
</code></pre>

<hr>
<h2 id='Gibbs.sample.coeff.gp'> Samples new coeffients via Gibbs sampling in a spectral GP object.</h2><span id='topic+Gibbs.sample.coeff.gp'></span>

<h3>Description</h3>

<p>Samples new coefficients via Gibbs sampling in a spectral GP object
following the Gibbs sampling scheme of Wikle (2002), which involves an
extra variance component (<code>sig2e</code> and a noisy version of the
process (<code>z</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
Gibbs.sample.coeff(object, z, sig2e, meanVal=0,
sdVal=1,returnHastings=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr> 
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_z">z</code></td>
<td>
<p>Vector of values for <code>z</code>, the noisy version of the process.</p>
</td></tr>
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_sig2e">sig2e</code></td>
<td>
<p>Noise variance component that distorts <code>z</code> as a
version of the process.</p>
</td></tr>
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_meanval">meanVal</code></td>
<td>
<p>Optional mean value for <code>z</code>.</p>
</td></tr>
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_sdval">sdVal</code></td>
<td>
<p>Optional standard deviation value for <code>z</code>.</p>
</td></tr>
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_returnhastings">returnHastings</code></td>
<td>
<p>Optional argument telling whether to return the
logdensity of the proposal for use in a Metropolis-Hastings correction
calculation.</p>
</td></tr>
<tr><td><code id="Gibbs.sample.coeff.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in an MCMC context to take Gibbs samples
of the process coefficients, as part of the algorithm of Wikle
(2002). The function modifies the GP object, updating the <code>coeff</code> and
<code>process</code> components.</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned, unless <code>returnHastings=TRUE</code>.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+updateprocess.gp">updateprocess.gp</a></code></p>

<hr>
<h2 id='gp'>Create a new GP object</h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>Creates a Gaussian process (GP) object based on the spectral basis
approximation of a GP on a grid.  The advantage of this approach is that GPs
can be simulated and sampled much more efficiently than standard GP
representations.  E.g., GPs can be simulated on fine grids of 256X256
locations, many more locations than can usually be predicted with
standard computational approaches.  Currently one and two dimensional
GPs are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp(gridsize = c(64, 64), specdens = matern.specdens, 
  specdens.param = c(1, 4),variance.param=1,const.fixed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gp_+3A_gridsize">gridsize</code></td>
<td>
<p> Vector (or scalar for one dimension) of number of
gridpoints in each direction. Number of gridpoints should be a power
of two, and it is recommended that the number be the same for each dimension.</p>
</td></tr> 
<tr><td><code id="gp_+3A_specdens">specdens</code></td>
<td>
<p> Function (as a function or text string of the
function name) that calculates spectral density of
correlation function desired; function should take a vector (scalar)
of parameter values.  See matern.specdens() for an example.</p>
</td></tr>
<tr><td><code id="gp_+3A_specdens.param">specdens.param</code></td>
<td>
<p> Vector of parameters to be supplied to the
specdens.function function.</p>
</td></tr>
<tr><td><code id="gp_+3A_variance.param">variance.param</code></td>
<td>
<p> Variance parameter used to scale the variances
of all the coefficients. Note that this can also be done outside of
the GP framework by scaling the predictions as in Wikle (2002).</p>
</td></tr>
<tr><td><code id="gp_+3A_const.fixed">const.fixed</code></td>
<td>
<p>Logical indicating whether the coefficient of the
constant basis function is fixed at zero. Since this coefficient
does not have sufficient flexibility under the prior in most
situations, it is advisable to fix this coefficient and have a
separate mean value/parameter outside of the gp object. However, in
simulating realizations, one should not fix this parameter, so as to
ensure the correct approximate covariance structure induced by the
spectral density and parameter values chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces an object of class gp.  More details on the
spectral representation of GPs can be found in Paciorek (2006); see
below.
</p>


<h3>Value</h3>

<p>An object of class gp.  This includes the dimension of the space, the
spectral density information, a matrix of coefficients, the Fourier
frequencies, and prior variances.
</p>
<table role = "presentation">
<tr><td><code>gridsize</code></td>
<td>
<p>Vector (or scalar for one dimension) of number of
gridpoints in each direction. </p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Dimension of the space (1 or 2).</p>
</td></tr>
<tr><td><code>specdens</code></td>
<td>
<p>Spectral density function of the correlation function
of the GP.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>Matrix of coefficient values (a one-column matrix for
one-dimensional processes).</p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>A matrix of Fourier frequency values corresponding the
basis functions in expand.grid() format.</p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
<p>A matrix of coefficient variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+plot.gp">plot.gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+calc.variances.gp">calc.variances.gp</a></code>,
<code><a href="#topic+new.mapping">new.mapping</a></code>, <code><a href="#topic+logdensity.gp">logdensity.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code>, <code><a href="#topic+add.blocks.gp">add.blocks.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
simulate(gp1)
simulate(gp2)
plot(gp1)
plot(gp2)

n=100
locs=cbind(runif(n,0.2,1.2),runif(n,-0.2,1.4))
locs.predict=cbind(runif(n,-0.4,0.8),runif(n,-0.1,1.7))
scaled.locs=xy2unit(locs,rbind(locs,locs.predict))
scaled.locs.predict=xy2unit(locs.predict,rbind(locs,locs.predict))
train.map=new.mapping(gp2,scaled.locs)
predict.map=new.mapping(gp2,scaled.locs.predict)
vals.train=predict(gp2,mapping=train.map)
vals.predict=predict(gp2,mapping=predict.map)

</code></pre>

<hr>
<h2 id='Hastings.coeff.gp'>Calculates Hastings value of coefficients</h2><span id='topic+Hastings.coeff.gp'></span>

<h3>Description</h3>

<p>Calculates Hastings value of coefficients, the logdensity of the current
coefficients given proposal mean and variance based on a Gibbs sample
of the form in <code>Gibbs.sample.coeff.gp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
Hastings.coeff(object, z, sig2e, meanVal=0, sdVal=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hastings.coeff.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr> 
<tr><td><code id="Hastings.coeff.gp_+3A_z">z</code></td>
<td>
<p>Vector of values for <code>z</code>, the noisy version of the process.</p>
</td></tr>
<tr><td><code id="Hastings.coeff.gp_+3A_sig2e">sig2e</code></td>
<td>
<p>Noise variance component that distorts <code>z</code> as a
version of the process.</p>
</td></tr>
<tr><td><code id="Hastings.coeff.gp_+3A_meanval">meanVal</code></td>
<td>
<p>Optional mean value for <code>z</code>.</p>
</td></tr>
<tr><td><code id="Hastings.coeff.gp_+3A_sdval">sdVal</code></td>
<td>
<p>Optional standard deviation value for <code>z</code>.</p>
</td></tr>
<tr><td><code id="Hastings.coeff.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in an MCMC context to calculate the Hastings correction
that may be necessary in taking a quasi-Gibbs sample of the process
coefficients, as part of one of the algorithms of Paciorek (2006).
The function calculates and returns the logdensity.</p>


<h3>Value</h3>

<p>The function returns the logdensity.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+updateprocess.gp">updateprocess.gp</a></code></p>

<hr>
<h2 id='image_plot'>
Draws image plot with a legend strip for the color scale.  
</h2><span id='topic+image_plot'></span>

<h3>Description</h3>

<p>This function combines the R <code>image</code> function with some automatic 
placement of a legend. This is done by splitting the plotting region  
into two parts. Putting the image in one and the legend in the
other.
</p>
<p>This function and help file are copied from the fields package.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_plot(..., add = FALSE, nlevel = 64, legend.shrink = 0.9, 
    legend.width = 0.05, graphics.reset = FALSE, horizontal = FALSE, 
    offset = 2 * legend.width, bigplot = NULL, smallplot = NULL, 
    legend.only = FALSE, col = topo.colors(nlevel)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_plot_+3A_...">...</code></td>
<td>

<p>The usual arguments to the <code>image</code> function. 
because this function may change the size of the plotting 
region. (See details below)  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_add">add</code></td>
<td>

<p>If true add image and a legend strip to the existing plot. 
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_nlevel">nlevel</code></td>
<td>

<p>Number of color levels used in legend strip  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_legend.shrink">legend.shrink</code></td>
<td>

<p>Amount to shrink the size of legend relative to the full height or width
of the plot.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_legend.width">legend.width</code></td>
<td>

<p>Width in plotting 
coordinates (the full size plot is [0,1]X[0,1]) of the legend strip. 
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_offset">offset</code></td>
<td>

<p>Amount that the legend strip is set in from the left edge or the bottom 
of the plotting region. Units are with respect to the plotting 
coordinates.
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_graphics.reset">graphics.reset</code></td>
<td>

<p>If
false (default)  the plotting region ( plt in par) will not be reset and
one can add more information onto the image plot. (e.g. using functions
such as points or lines.)  If true will reset plot parameters to the
values before entering the function.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_horizontal">horizontal</code></td>
<td>

<p>If false (default) legend will be a vertical strip on the right side. If
true the legend strip will be along the bottom.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_bigplot">bigplot</code></td>
<td>

<p>Plot coordinates for image plot. If not passed
these will
be determined within the function.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_smallplot">smallplot</code></td>
<td>

<p>Plot coordinates for legend. If not passed these will be determined within
the function.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_legend.only">legend.only</code></td>
<td>

<p>If true just add the
legend to a the plot in the plot region defined by the coordinates in
smallplot.  
</p>
</td></tr>
<tr><td><code id="image_plot_+3A_col">col</code></td>
<td>

<p>Color table to use for image ( see help file on image for details).
Default is a pleasing range of 64 divisions on a topgraphic scale.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is surprising how hard it is just to automatically add the
legend! All &quot;plotting coordinates&quot; mentioned here are in device
coordinates. The plot region is assumed to be [0,1]X[0,1] and plotting
regions are defined as rectangles within this square. We found these
easier to work with than user coordinates.  There are always problems with
default solutions to placing information on graphs but the choices made
here may be useful for most cases. The most annoying thing is that after
using plot.image and adding information the next plot that is made may
have the slightly smaller plotting region set by the image plotting.
</p>
<p>The strategy is simple, divide the plotting region into two smaller
regions.  The image goes in one and the legend in the other. This way
there is always room for the legend. Some adjustments are made to this
rule by not shrinking the image plot if there is already room for the
legend strip and also sticking the legend strip close to the image plot.
Also, one can specify the plot regions explicitly by bigplot and small
plot if the default choices do not work. There may be problems with small
plotting regions in fitting both of these plot and one may have to change
the default character sizes or margins to make things fit.  
</p>
<p>By keeping the zlim argument the same across images one can generate
the same color scale. (See <code>image</code> help file)  One useful technique for a
panel of images is to just draw the first with image.plot to get a legend
and just use image for subsequent plots. Also keep in mind one can just
add a legend to an existing plot without changing plotting parameters.
Usually a square plot (pty=&quot;s&quot;) done in a rectangular plot region will
have room for the legend with any adjustments stuck to the right side.
</p>


<h3>Side Effects</h3>

<p>After exiting, the
plotting region may be changed to make it possible to add more features to
the plot. To be explicit, par()\$plt may be changed to reflect a smaller
plotting region that includes a legend subplot.  
</p>


<h3>See Also</h3>

<p><code>image</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;- 1:10 
y&lt;- 1:15 
z&lt;- outer( x,y,"+") 
image_plot(x,y,z) 
# now add some points on diagonal  
points( 5:10, 5:10)
#
#fat (5% of figure) and short (50% of figure)  legend strip on the bottom 
image_plot( x,y,z,legend.width=.05, legend.shrink=.5, horizontal=TRUE) 

# add a legend on the bottom but first change margin for some room 
par( mar=c(10,5,5,5))

image( x,y,z)
image_plot( zlim=c(0,25), legend.only=TRUE, horizontal=TRUE) 
</code></pre>

<hr>
<h2 id='is.gp'>Test if object is a spectral GP</h2><span id='topic+is.gp'></span>

<h3>Description</h3>

<p>Tests if the argument is a spectral GP object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gp(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 'TRUE' if the argument is a gp, and 'FALSE' otherwise.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
is.gp(gp1)
</code></pre>

<hr>
<h2 id='lines.gp'>Add a line plot for a one-dimensional process based on a spectral GP object</h2><span id='topic+lines.gp'></span>

<h3>Description</h3>

<p>Adds a line plot to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.gp_+3A_x">x</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="lines.gp_+3A_...">...</code></td>
<td>
<p>Extra arguments to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+getgrid.gp">getgrid.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(c(128),matern.specdens,c(1,4))
simulate(gp1)
plot(gp1)
simulate(gp1)
lines(gp1,col=2)

</code></pre>

<hr>
<h2 id='logdensity.gp'>Calculates log prior density of a spectral GP object</h2><span id='topic+logdensity.gp'></span>

<h3>Description</h3>

<p>Calculates the log prior density of a spectral GP object as the log
prior density of the basis coefficients, based on the prior variances
and a prior of independent Gaussians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
logdensity(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logdensity.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>. </p>
</td></tr>
<tr><td><code id="logdensity.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log density is calculated based on the real and imaginary
components of the basis function coefficients, but only those
coefficients that are not determined as the complex conjugates of
other coefficients. The density function is that the coefficients
are IID normal with mean zero and prior variance based on the
spectral density and correlation parameters.
</p>


<h3>Value</h3>

<p>The logarithm of the prior density.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+calc.variances.gp">calc.variances.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
propose.coeff(gp1)
propose.coeff(gp2)
print(logdensity(gp1))
print(logdensity(gp2))
</code></pre>

<hr>
<h2 id='lonlat2xy'>Projects lon/lat coordinates to x/y Euclidean coordinate system</h2><span id='topic+lonlat2xy'></span>

<h3>Description</h3>

<p>The projection calculates, for all points, the great circle distance in the x direction to the mean longitude and in the y direction to the mean latitude, and uses these distances as the x-y coordinates of the location. This function is copied from the fields library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lonlat2xy(lnlt,miles=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lonlat2xy_+3A_lnlt">lnlt</code></td>
<td>
<p>A two-column matrix-like object of lon/lat coordinates to
be projected, with longitude in the first column.</p>
</td></tr>
<tr><td><code id="lonlat2xy_+3A_miles">miles</code></td>
<td>
<p>Indicator of whether distances should be calculated in
miles or kilometers (FALSE, the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is an ad hoc projection best used only for small
portions of the globe.
</p>


<h3>Value</h3>

<p>A  two-column matrix of projected x/y coordinates, with the x-coordinate in the
first column.
</p>


<h3>Author(s)</h3>

<p>copied from the fields library by Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+xy2unit">xy2unit</a></code>, <code><a href="#topic+new.mapping">new.mapping</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(c(128,128),matern.specdens,c(1,4))
n=100
locs=cbind(runif(n,20,80),runif(n,40,50))
locs.predict=cbind(runif(n,30,90),runif(n,38,48))
locs=lonlat2xy(locs)
locs.predict=lonlat2xy(locs.predict)
scaled.locs=xy2unit(locs,rbind(locs,locs.predict))
scaled.locs.predict=xy2unit(locs.predict,rbind(locs,locs.predict))
train.map=new.mapping(gp1,scaled.locs)
predict.map=new.mapping(gp1,scaled.locs.predict)
plot(locs,xlim=c(min(locs[,1],locs.predict[,1]),max(locs[,1],
  locs.predict[,1])),ylim=c(min(locs[,2],locs.predict[,2]),
  max(locs[,2],locs.predict[,2])))
points(locs.predict,col=2)
plot(scaled.locs,xlim=c(0,1),ylim=c(0,1))
points(scaled.locs.predict,col=2)
</code></pre>

<hr>
<h2 id='matern.specdens'>Matern correlation spectral density function </h2><span id='topic+matern.specdens'></span>

<h3>Description</h3>

<p>Calculates the Matern spectral density for supplied frequencies and
Matern correlation parameters. Spectral density is evaluated for each
supplied frequency or pair of frequencies.  The output is generally
used as the prior variances for spectral GP basis coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern.specdens(omega, param, d = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.specdens_+3A_omega">omega</code></td>
<td>
<p>Vector or two-column matrix-like object of frequencies, with the
first column the frequencies in the first dimension and the second
column in the second dimension.</p>
</td></tr>
<tr><td><code id="matern.specdens_+3A_param">param</code></td>
<td>
<p>Vector of two Matern parameter values, first the spatial
range and second the differentiability parameter.</p>
</td></tr>
<tr><td><code id="matern.specdens_+3A_d">d</code></td>
<td>
<p>Dimension of the domain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral
density,</p>
<p style="text-align: center;"><code class="reqn">\frac{\Gamma(\nu+d/2)(4\nu)^\nu}{\pi^(d/2)\Gamma(\nu)(\pi \rho)^{2\nu}}\left(\frac{4\nu}{(\pi \rho)^2}+\omega^T \omega\right)^{-(\nu +d/2)},</code>
</p>

<p>corresponds to the following functional form of
the Matern correlation function,
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\Gamma(\nu)2^{\nu-1}}\left(\frac{2\sqrt{\nu}\tau}{\rho}\right)^{\nu}\mathcal{K}_{\nu}\left(\frac{2\sqrt{\nu}\tau}{\rho}\right),</code>
</p>
<p> where rho is the range and nu the differentiability.  Rho is interpreted on the scale <code class="reqn">(0,1)^d</code>. Nu of 0.5 is the exponential correlation, and as nu goes to infinity the correlation approaches the squared exponential (Gaussian).  Nu of 0.5 gives Gaussian processes with continuous but not differentiable sample paths, while nu of infinity gives infinitely-differentiable (and analytic) sample paths.  In the spectral GP approximation, the frequencies are a sequence of integers from 0 to half the gridsize in each dimension. 
</p>


<h3>Value</h3>

<p>A vector of spectral density values corresponding to the supplied frequencies.</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+calc.variances.gp">calc.variances.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
dens1=matern.specdens(gp1$omega,c(1,4),d=1)
dens2=matern.specdens(gp2$omega,c(1,4),d=2)
</code></pre>

<hr>
<h2 id='names.gp'>The names of the elements of a GP object</h2><span id='topic+names.gp'></span>

<h3>Description</h3>

<p>Gives the names of the elements of the GP object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
names(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.gp_+3A_x">x</code></td>
<td>
<p> Spectral GP object.</p>
</td></tr>
<tr><td><code id="names.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A vector of strings of the names of the elements of the GP object.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gp">gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
print(names(gp1))
add.blocks(gp1)
print(names(gp1))

</code></pre>

<hr>
<h2 id='new.mapping'>Map arbitrary locations to gridpoints of spectral GP object </h2><span id='topic+new.mapping'></span>

<h3>Description</h3>

<p>Finds the nearest gridpoint in a spectral GP representation for each
supplied location based on Euclidean distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.mapping(object, locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.mapping_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="new.mapping_+3A_locations">locations</code></td>
<td>
<p>A two-column matrix-like object (vector for one-dimensional data)
of locations of interest, for which the first column is the first
coordinate and the second column the second coordinate.  Locations
should lie in <code class="reqn">(0,1)^d</code>, as the process representation is on a grid on <code class="reqn">(0,1)^d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector for which each element is the index of the gridpoint nearest
the location.  The indices run from 1 to <code class="reqn">(k/2)^d</code> where k the number of
gridpoints in each direction (assuming there are an equal number in
each direction).  The indices run along the first dimension from the
lower right corner of the space, e.g.,
13 14 15 16
9 10 11 12
5 6 7 8
1 2 3 4
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
loc1=runif(100)
loc2=cbind(runif(100),runif(100,0,1))
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
map1=new.mapping(gp1,loc1)
map2=new.mapping(gp2,loc2)
simulate(gp1)
simulate(gp2)
vals1=predict(gp1,mapping=map1)
vals2=predict(gp2,mapping=map2)
plot(gp1)
points(loc1,vals1)
</code></pre>

<hr>
<h2 id='plot.gp'>Plot a process based on a spectral GP object</h2><span id='topic+plot.gp'></span>

<h3>Description</h3>

<p>Makes a line plot (for one-dimensional processes) or image plot
(two-dimensional processes) of a process represented in a spectral
GP object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
plot(x, type = "l", col = terrain.colors(32), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gp_+3A_x">x</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_type">type</code></td>
<td>
<p>Type of plot if process is one-dimensional, &quot;l&quot; for line,
&quot;p&quot; for points, etc.</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_col">col</code></td>
<td>
<p>Color scheme for image plot if process is
two-dimensional. E.g., topo.colors(64) is the default for
image_plot; I prefer terrain.colors(64) as topo.colors has sharp
color changes between adjacent bins.</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_...">...</code></td>
<td>
<p>Extra arguments to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+getgrid.gp">getgrid.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(c(128),matern.specdens,c(1,4))
simulate(gp1)
plot(gp1)
gp2=gp(c(256,256),matern.specdens,c(1,0.5))
simulate(gp2)
plot(gp2)

</code></pre>

<hr>
<h2 id='points.gp'>Add points for a one-dimensional process based on a spectral GP object</h2><span id='topic+points.gp'></span>

<h3>Description</h3>

<p>Adds points to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
points(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points.gp_+3A_x">x</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="points.gp_+3A_...">...</code></td>
<td>
<p>Extra arguments to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+getgrid.gp">getgrid.gp</a></code>, <code><a href="#topic+predict.gp">predict.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(c(128),matern.specdens,c(1,4))
simulate(gp1)
plot(gp1)
simulate(gp1)
points(gp1,col=2)

</code></pre>

<hr>
<h2 id='predict.gp'>Prediction from a spectral GP object</h2><span id='topic+predict.gp'></span>

<h3>Description</h3>

<p>Produces the process values of a spectral GP object on the defined
grid or predicts process values for a new set of inputs (domain points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
predict(object,newdata=NULL,mapping=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>. </p>
</td></tr>
<tr><td><code id="predict.gp_+3A_newdata">newdata</code></td>
<td>
<p>An optional two-column matrix-like object (vector for one-dimensional data)
of locations of interest, for which the first column is the first
coordinate and the second column the second coordinate.  Locations
should lie in <code class="reqn">(0,1)^d</code>, as the process representation is on a grid on <code class="reqn">(0,1)^d</code>.</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_mapping">mapping</code></td>
<td>
<p>Optional output of <code>new.mapping</code>, which creates a vector of indices mapping the prediction locations to
their nearest gridpoints.</p>
</td></tr>
<tr><td><code id="predict.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Does prediction for a spectral GP, either at the gridpoints or
for locations by associating locations with the nearest gridpoint,
depending on the arguments supplied.  If <code>newdata</code> and
<code>mapping</code> are both NULL, then prediction is done on the grid.  If only
<code>newdata</code> is supplied, the mapping is done using
<code>new.mapping</code> and then the prediction is done.  If <code>mapping</code>
is supplied (this should be done for computational efficiency if
prediction at the same locations will be done repeatedly) then the
mapping is used directly to calculate the predictions.
</p>


<h3>Value</h3>

<p>A vector of process values (matrix for two-dimensional processes in
which prediction on the grid is requested).
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+new.mapping">new.mapping</a></code>, <code><a href="#topic+plot.gp">plot.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
simulate(gp1)
simulate(gp2)
gridvals=predict(gp1)
gridvals2=predict(gp2)

loc1=runif(100)
loc2=cbind(runif(100),runif(100,0,1))
map1=new.mapping(gp1,loc1)
map2=new.mapping(gp2,loc2)
vals1=predict(gp1,mapping=map1)
vals2=predict(gp2,mapping=map2)
#equivalently:
vals1=predict(gp1,loc1)
vals2=predict(gp2,loc2)
plot(gp1)
points(loc1,vals1)

</code></pre>

<hr>
<h2 id='print.gp'>Spectral GP default print statement</h2><span id='topic+print.gp'></span>

<h3>Description</h3>

<p>This is the default print statement for a spectral GP object. If you need
a list of everything that is part of a spectral GP object,
use 'names()'. 
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+names.gp">names.gp</a></code></p>

<hr>
<h2 id='propose.coeff.gp'> Proposes new coeffients in a spectral GP object.</h2><span id='topic+propose.coeff.gp'></span>

<h3>Description</h3>

<p>Proposes new coefficients in a spectral GP object as normal deviates
centered around the current values, with the proposal standard deviation the
product of the supplied standard deviation(s) and the square root of
the prior variances.  The proposal can be done for all coefficients at
once (<code>block=0</code>) or for individual blocks. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
propose.coeff(object, block = 0, proposal.sd = 1,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="propose.coeff.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr> 
<tr><td><code id="propose.coeff.gp_+3A_block">block</code></td>
<td>
<p>The block of coefficients to be proposed, or 0 if all
coefficients are to be proposed.</p>
</td></tr>
<tr><td><code id="propose.coeff.gp_+3A_proposal.sd">proposal.sd</code></td>
<td>
<p>Proposal standard deviation. This is multiplied by
the square root of the prior variance for each coefficient to
produce the final proposal standard deviation.</p>
</td></tr>
<tr><td><code id="propose.coeff.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to simulate a GP by using
<code>proposal.sd=1</code> to sample coefficients, <code>coeff</code>, from the
prior or in a MCMC context to propose new coefficient
values via the Metropolis algorithm.  The function automatically
updates the process values in the <code>process</code> component of the gp
list based on the new coefficient values.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+calc.variances.gp">calc.variances.gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+updateprocess.gp">updateprocess.gp</a></code>,
<code><a href="#topic+zero.coeff.gp">zero.coeff.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
rho=1
gp1=gp(128,matern.specdens,c(rho,4))
gp2=gp(c(64,64),matern.specdens,c(rho,4))
propose.coeff(gp1)
propose.coeff(gp2)
plot(gp1)
plot(gp2)
prior1=logdensity(gp1)
prior2=logdensity(gp2)
add.blocks(gp1)
add.blocks(gp2)
propose.coeff(gp1,block=2,proposal.sd=0.1)
propose.coeff(gp2,block=3,proposal.sd=0.1)
priorstar1=logdensity(gp1)
priorstar2=logdensity(gp2)
plot(gp1)
plot(gp2)
</code></pre>

<hr>
<h2 id='rdist.earth'>
Great circle distance matrix 
</h2><span id='topic+rdist.earth'></span>

<h3>Description</h3>

<p>Given two sets of longitude/latitude locations computes the Great circle
(geogrpahic)  distance matrix
among all pairings. This function and help file are copied from the
fields library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdist.earth(loc1, loc2, miles = TRUE, R = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdist.earth_+3A_loc1">loc1</code></td>
<td>

<p>Matrix of first set of lon/lat coordinates first column is the
longitudes
and second is the latitudes. 
</p>
</td></tr>
<tr><td><code id="rdist.earth_+3A_loc2">loc2</code></td>
<td>

<p>Matrix of second  set of lon/lat coordinates first column is the
longitudes
and second is the latitudes. If missing x1 is used. 
</p>
</td></tr>
<tr><td><code id="rdist.earth_+3A_miles">miles</code></td>
<td>

<p>If true distances are in statute miles if false distances in kilometers. 
</p>
</td></tr>
<tr><td><code id="rdist.earth_+3A_r">R</code></td>
<td>

<p>Radius to use for sphere to find spherical distances. If NULL the radius
is either in miles or kilometers depending on the values of the miles
argument. If R=1 then distances are of course in radians. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Surprisingly this  all done efficiently in S.
</p>


<h3>Value</h3>

<p>The great circle distance matrix if nrow(x1)=m and nrow(
x2)=n then the returned matrix will be mXn. 
</p>


<h3>See Also</h3>

<p>rdist, exp.earth.cov 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> lon.lat=cbind(runif(20,0,360),runif(20,-90,90))
 out&lt;- rdist.earth (lon.lat)
#out is a 20X20 distance matrix	
</code></pre>

<hr>
<h2 id='simulate.gp'>Simulates a process realization from a spectral GP object </h2><span id='topic+simulate.gp'></span>

<h3>Description</h3>

<p>Simulates a process realization by drawing a random draw of
coefficients from their prior distribution and updating the process values.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
simulate(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="simulate.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modifies the <code>coeff</code> and <code>process</code> elements of the object.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+zero.coeff.gp">zero.coeff.gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+updateprocess.gp">updateprocess.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
simulate(gp1)
simulate(gp2)
plot(gp1)
plot(gp2)
</code></pre>

<hr>
<h2 id='spectralGP'>
spectralGP - tools for specifying Gaussian processes using the
computationally efficient Fourier basis
</h2><span id='topic+spectralGP'></span>

<h3>Description</h3>

<p>SpectralGP is a collection of functions for creating Gaussian processes in 
one and two dimensions using the Fourier basis approximation. It provides
fast  simulation and plotting of process realizations by use of the
FFT, allowing simulation and plotting on very dense grids.  For inference,
it provides tools for use in setting up an MCMC: calculation of 
coefficient variances, calculation of process density, and
coefficient proposals. It uses R environments to store GP objects as references/pointers.
</p>
<p>Some major methods include:
</p>

<ul>
<li> <p><code>gp</code>   Create a Gaussian process object
</p>
</li>
<li> <p><code>simulate.gp</code>  Simulate a Gaussian process realization
</p>
</li>
<li> <p><code>plot.gp</code>   Plot a Gaussian process
</p>
</li>
<li> <p><code>predict.gp</code> Extract process values at specified domain points
</p>
</li></ul>

<p>DISCLAIMER:
</p>
<p>This is software for statistical research and not for commercial
uses. The author does not guarantee the correctness of any function
or program in this package. Any changes to the software should not
be made without the author's permission.
</p>
<p>ACKNOWLEDGEMENT:
</p>
<p>Many thanks to Chris Wikle who first suggested I use the Fourier basis
approximation for Gaussian processes.
</p>
<p>REFERENCES:
</p>
<p>For more details, type 'citation(&quot;spectralGP&quot;)' for references.
</p>
<p>See also:
</p>
<p>Royle, J.A., and C.K. Wikle, (2005).  Efficient Statistical Mapping of
Avian Count Data.  Ecological and Environmental Statistics 12:225-243.
<a href="http://www.stat.missouri.edu/~wikle/pub_new.html">http://www.stat.missouri.edu/~wikle/pub_new.html</a>
</p>
<p>Wikle, C.K., (2002).  Spatial modeling of count data: A case study in modelling breeding bird survey data on large spatial domains.
In Spatial Cluster Modelling, A. Lawson and D. Denison, eds. Chapman
and Hall, 199-209.
<a href="http://www.stat.missouri.edu/~wikle/pub_new.html">http://www.stat.missouri.edu/~wikle/pub_new.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gp1=gp(128,matern.specdens,c(1,4))
gp2=gp(c(64,64),matern.specdens,c(1,4))
simulate(gp1)
simulate(gp2)
plot(gp1)
plot(gp2)
gridvals=predict(gp1)
newlocs=runif(100)
offgridvals=predict(gp1,newlocs)
</code></pre>

<hr>
<h2 id='spectralGP-generic'>
spectralGP generic functions
</h2><span id='topic+add.blocks'></span><span id='topic+calc.variances'></span><span id='topic+change.param'></span><span id='topic+copy'></span><span id='topic+expand.gpgrid'></span><span id='topic+getgrid'></span><span id='topic+Gibbs.sample.coeff'></span><span id='topic+Hastings.coeff'></span><span id='topic+image_plot_info'></span><span id='topic+image_plot_plt'></span><span id='topic+logdensity'></span><span id='topic+propose.coeff'></span><span id='topic+simulate'></span><span id='topic+updateprocess'></span><span id='topic+zero.coeff'></span>

<h3>Description</h3>

<p>These functions are generics; see the help files associated with the
spectralGP methods.
</p>

<hr>
<h2 id='updateprocess.gp'>Recalculate process values in a spectral GP object</h2><span id='topic+updateprocess.gp'></span>

<h3>Description</h3>

<p>Calculates the process values in a
spectral GP object based on the
current coefficient values.  The process values are calculated by
multiplying the coefficient values by the basis matrix, which is done
by the inverse FFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
updateprocess(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateprocess.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="updateprocess.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modifies the <code>process</code> values of the object.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+propose.coeff.gp">propose.coeff.gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+zero.coeff.gp">zero.coeff.gp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(128,matern.specdens,c(1,4))
propose.coeff(gp1)
gp1$coeff[1,1]=0
updateprocess(gp1)
</code></pre>

<hr>
<h2 id='xy2unit'>Scales locations to the unit hypercube for use in spectral GP</h2><span id='topic+xy2unit'></span>

<h3>Description</h3>

<p>Scales locations to <code class="reqn">(0,1)^d</code> so that they can be related to the
gridpoints in a spectral GP representation.  The
<code>locations.scale</code> argument allows one to scale the
<code>locations</code> to a separate set of locations.  E.g., if one wants
to predict over a certain set of locations, but has a separate
training set of locations that lie within the prediction set, one
would use the prediction locations as the <code>locations.scale</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy2unit(locations, locations.scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xy2unit_+3A_locations">locations</code></td>
<td>
<p>A two-column matrix-like object (vector for one-dimensional data) of
locations to be scaled. </p>
</td></tr>
<tr><td><code id="xy2unit_+3A_locations.scale">locations.scale</code></td>
<td>
<p>A two-column matrix-like object (vector for one-dimensional data) of
locations that provides the function with the min and max
coordinates in each direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One may want to use both training and prediction locations as the
<code>locations.scale</code> argument to ensure that all locations of
interest will lie in <code class="reqn">(0,1)^d</code> and be able to be related to the gridpoints.
</p>


<h3>Value</h3>

<p>A matrix (vector for one-dimensional data) of scaled locations lying
in <code class="reqn">(0,1)^d</code>.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+new.mapping">new.mapping</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spectralGP)
gp1=gp(c(128,128),matern.specdens,c(1,4))
n=100
locs=cbind(runif(n,0.2,1.2),runif(n,-0.2,1.4))
locs.predict=cbind(runif(n,-0.4,0.8),runif(n,-0.1,1.7))
scaled.locs=xy2unit(locs,rbind(locs,locs.predict))
scaled.locs.predict=xy2unit(locs.predict,rbind(locs,locs.predict))
train.map=new.mapping(gp1,scaled.locs)
predict.map=new.mapping(gp1,scaled.locs.predict)
plot(locs,xlim=c(min(locs[,1],locs.predict[,1]),max(locs[,1],
  locs.predict[,1])),ylim=c(min(locs[,2],locs.predict[,2]),
  max(locs[,2],locs.predict[,2])))
points(locs.predict,col=2)
plot(scaled.locs,xlim=c(0,1),ylim=c(0,1))
points(scaled.locs.predict,col=2)
</code></pre>

<hr>
<h2 id='zero.coeff.gp'>Sets coefficients to zero in a spectral GP object </h2><span id='topic+zero.coeff.gp'></span>

<h3>Description</h3>

<p>Sets coefficients to zero in a spectral GP object.  Used to zero out the
coefficients before simulating a new GP realization from the prior distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
zero.coeff(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero.coeff.gp_+3A_object">object</code></td>
<td>
<p>A GP object, created by <code>gp</code>.</p>
</td></tr>
<tr><td><code id="zero.coeff.gp_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modifies the <code>coeff</code> and <code>process</code> components of the object.
</p>


<h3>Value</h3>

<p>The function modifies the GP object, which is essentially a pointer
(an R environment in this case), so NULL is returned.
</p>


<h3>Author(s)</h3>

<p>Christopher Paciorek <a href="mailto:paciorek@alumni.cmu.edu">paciorek@alumni.cmu.edu</a> </p>


<h3>References</h3>

<p>Type 'citation(&quot;spectralGP&quot;)' for references.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code>, <code><a href="#topic+simulate.gp">simulate.gp</a></code>, <code><a href="#topic+updateprocess.gp">updateprocess.gp</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
