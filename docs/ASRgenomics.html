<!DOCTYPE html><html lang="en-US"><head><title>Help for package ASRgenomics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ASRgenomics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ASRgenomics-package'><p>ASRgenomics: Complementary Genomic Functions</p></a></li>
<li><a href='#callrate'><p>Estimates call rate</p></a></li>
<li><a href='#check.args_'><p>Check string arguments</p></a></li>
<li><a href='#check.data_'><p>Check data class</p></a></li>
<li><a href='#check.data.mode_'><p>Check data mode</p></a></li>
<li><a href='#check.logical_'><p>Check logical arguments</p></a></li>
<li><a href='#dummy.map_'><p>Creates a dummy map if not provided</p></a></li>
<li><a href='#Fis'><p>Estimates the population level inbreeding (Fis) by marker</p></a></li>
<li><a href='#full2sparse'><p>Generates a sparse form matrix from a full form matrix</p></a></li>
<li><a href='#G.inverse'><p>Obtains the inverse of the genomic relationship matrix G</p></a></li>
<li><a href='#G.matrix'><p>Obtains the genomic matrix from SNP data for additive or dominant relationships</p></a></li>
<li><a href='#G.predict'><p>Generates the conditional predictions of random effects (BLUPs)</p></a></li>
<li><a href='#G.tuneup'><p>Tune-up the the genomic relationship matrix G</p></a></li>
<li><a href='#geno.apple'><p>Genotypic data for apple dataset</p></a></li>
<li><a href='#geno.pine655'><p>Genotypic data of 655 genotypes for loblolly pine dataset</p></a></li>
<li><a href='#geno.pine926'><p>Genotypic data of 926 genotypes for loblolly pine dataset</p></a></li>
<li><a href='#geno.salmon'><p>Genotypic data for Atlantic salmon dataset</p></a></li>
<li><a href='#H.inverse'><p>Generates the inverse of the hybrid H matrix</p></a></li>
<li><a href='#H.matrix'><p>Generates the hybrid <code class="reqn">H</code> matrix</p></a></li>
<li><a href='#heterozygosity'><p>Estimates observed and expected heterozygosity</p></a></li>
<li><a href='#kinship.diagnostics'><p>Reports summary statistics, plots and filter options for a given kinship matrix K</p></a></li>
<li><a href='#kinship.heatmap'><p>Enhanced heatmap plot for a kinship matrix K</p></a></li>
<li><a href='#kinship.pca'><p>Performs a Principal Component Analysis (PCA) based on a kinship matrix K</p></a></li>
<li><a href='#Kinv.condition'><p>Assess condition of the inverse of <strong>K</strong></p></a></li>
<li><a href='#maf'><p>Estimates minor allele frequency (MAF)</p></a></li>
<li><a href='#match.G2A'><p>Check the genomic relationship matrix G against</p>
the pedigree relationship matrix A or vice versa</a></li>
<li><a href='#match.kinship2pheno'><p>Check any kinship matrix K against phenotypic data</p></a></li>
<li><a href='#ped.pine'><p>Pedigree data for loblolly pine dataset</p></a></li>
<li><a href='#ped.salmon'><p>Pedigree data for Atlantic salmon dataset</p></a></li>
<li><a href='#pheno.apple'><p>Phenotypic data for apple dataset</p></a></li>
<li><a href='#pheno.pine'><p>Phenotypic data for loblolly pine dataset</p></a></li>
<li><a href='#pheno.salmon'><p>Phenotypic data for Atlantic salmon dataset</p></a></li>
<li><a href='#qc.filtering'><p>Quality control filtering of molecular matrix M for downstream analyses</p></a></li>
<li><a href='#silent_'><p>Function that silences everything (e.g., <code>cat()</code>, <code>print()</code>, <code>message()</code>, ...)</p></a></li>
<li><a href='#snp.pca'><p>Performs a Principal Component Analysis (PCA) based on a molecular matrix M</p></a></li>
<li><a href='#snp.pruning'><p>Reduces the number of redundant markers on a molecular matrix M by pruning</p></a></li>
<li><a href='#snp.recode'><p>Recodes the molecular matrix M for downstream analyses</p></a></li>
<li><a href='#sparse2full'><p>Generates a full matrix form from a sparse form matrix</p></a></li>
<li><a href='#synthetic.cross'><p>Generates a molecular matrix M for hypothetical crosses based on the</p>
genomic information of the parents</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Complementary Genomic Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Presents a series of molecular and genetic routines in the R
    environment with the aim of assisting in analytical pipelines before
    and after the use of 'asreml' or another library to perform analyses such
    as Genomic Selection or Genome-Wide Association Analyses. 
    Methods and examples are described in Gezan, Oliveira, Galli, and Murray (2022) 
    <a href="https://asreml.kb.vsni.co.uk/wp-content/uploads/sites/3/ASRgenomics_Manual.pdf">https://asreml.kb.vsni.co.uk/wp-content/uploads/sites/3/ASRgenomics_Manual.pdf</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>AGHmatrix, cowplot, crayon, data.table, ellipse, factoextra,
ggplot2, Matrix, methods, scattermore, stats, superheat, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, V8, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>bzip2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 19:51:30 UTC; Giovanni Galli</td>
</tr>
<tr>
<td>Author:</td>
<td>Salvador Gezan [aut, cre],
  Darren Murray [aut],
  Amanda Avelar de Oliveira [aut],
  Giovanni Galli [aut],
  VSN International [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Salvador Gezan &lt;salvador.gezan@vsni.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ASRgenomics-package'>ASRgenomics: Complementary Genomic Functions</h2><span id='topic+ASRgenomics'></span><span id='topic+ASRgenomics-package'></span>

<h3>Description</h3>

<p>Presents a series of molecular and genetic routines in the R environment with the aim of assisting in analytical pipelines before and after the use of 'asreml' or another library to perform analyses such as Genomic Selection or Genome-Wide Association Analyses. Methods and examples are described in Gezan, Oliveira, Galli, and Murray (2022) <a href="https://asreml.kb.vsni.co.uk/wp-content/uploads/sites/3/ASRgenomics_Manual.pdf">https://asreml.kb.vsni.co.uk/wp-content/uploads/sites/3/ASRgenomics_Manual.pdf</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Salvador Gezan <a href="mailto:salvador.gezan@vsni.co.uk">salvador.gezan@vsni.co.uk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Darren Murray <a href="mailto:darren.murray@vsni.co.uk">darren.murray@vsni.co.uk</a>
</p>
</li>
<li><p> Amanda Avelar de Oliveira <a href="mailto:support@vsni.co.uk">support@vsni.co.uk</a>
</p>
</li>
<li><p> Giovanni Galli <a href="mailto:giovanni.galli@vsni.co.uk">giovanni.galli@vsni.co.uk</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> VSN International [copyright holder]
</p>
</li></ul>


<hr>
<h2 id='callrate'>Estimates call rate</h2><span id='topic+callrate'></span>

<h3>Description</h3>

<p>Estimates call rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callrate(M = NULL, margin = c("row", "col"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="callrate_+3A_m">M</code></td>
<td>
<p>The additive <code class="reqn">n \times p</code> matrix with any coding (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="callrate_+3A_margin">margin</code></td>
<td>
<p>A character indicating the margin for call rate calculations.
Options are: <code>row</code> and <code>col</code> (default = <code>row</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the call rate.
</p>

<hr>
<h2 id='check.args_'>Check string arguments</h2><span id='topic+check.args_'></span>

<h3>Description</h3>

<p>Check string arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.args_(
  data_ = NULL,
  mandatory_ = FALSE,
  arg_ = NULL,
  class_ = NULL,
  class.action_ = NULL,
  mutate_ = NULL,
  message_ = message
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.args__+3A_data_">data_</code></td>
<td>
<p>Data to be checked.</p>
</td></tr>
<tr><td><code id="check.args__+3A_mandatory_">mandatory_</code></td>
<td>
<p>If the argument is mandatory for the analysis.</p>
</td></tr>
<tr><td><code id="check.args__+3A_arg_">arg_</code></td>
<td>
<p>The string with the name of the function argument (e.g., <code>"gen"</code>).</p>
</td></tr>
<tr><td><code id="check.args__+3A_class_">class_</code></td>
<td>
<p>The expected class of the variable in data.</p>
</td></tr>
<tr><td><code id="check.args__+3A_class.action_">class.action_</code></td>
<td>
<p>The action to be taken if the variable has the wrong class
(e.g., <code>"message"</code>, <code>"warning"</code>, <code>"stop"</code>).</p>
</td></tr>
<tr><td><code id="check.args__+3A_mutate_">mutate_</code></td>
<td>
<p>If the argument should be mutated into the desired class.</p>
</td></tr>
<tr><td><code id="check.args__+3A_message_">message_</code></td>
<td>
<p>If <code>class.action_ == "message"</code>, write <code>message = "message"</code>
to capture upstream message command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions uses the <code>get</code> and <code>assign</code> which are need access to objects that
are one environment up on the hierarchy. The <code>envir</code> is set to <code>parent.frame</code>. If the function is looking
for something two or more environments up, the arguments of <code>parent.frame</code> have to be changed.
</p>

<hr>
<h2 id='check.data_'>Check data class</h2><span id='topic+check.data_'></span>

<h3>Description</h3>

<p>Check data class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.data_(data_ = NULL, class_ = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.data__+3A_data_">data_</code></td>
<td>
<p>Data to be checked.</p>
</td></tr>
<tr><td><code id="check.data__+3A_class_">class_</code></td>
<td>
<p>The expected class of data_.</p>
</td></tr>
</table>

<hr>
<h2 id='check.data.mode_'>Check data mode</h2><span id='topic+check.data.mode_'></span>

<h3>Description</h3>

<p>Check data mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.data.mode_(data_ = NULL, mode_ = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.data.mode__+3A_data_">data_</code></td>
<td>
<p>Data to be checked.</p>
</td></tr>
<tr><td><code id="check.data.mode__+3A_mode_">mode_</code></td>
<td>
<p>The expected mode of data_.</p>
</td></tr>
</table>

<hr>
<h2 id='check.logical_'>Check logical arguments</h2><span id='topic+check.logical_'></span>

<h3>Description</h3>

<p>Check logical arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.logical_(arg_ = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.logical__+3A_arg_">arg_</code></td>
<td>
<p>The boolean argument to be checked.</p>
</td></tr>
</table>

<hr>
<h2 id='dummy.map_'>Creates a dummy map if not provided</h2><span id='topic+dummy.map_'></span>

<h3>Description</h3>

<p>Creates a dummy map if not provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy.map_(marker.id = NULL, message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy.map__+3A_marker.id">marker.id</code></td>
<td>
<p>vector with names of markers to compose dummy map.</p>
</td></tr>
<tr><td><code id="dummy.map__+3A_message">message</code></td>
<td>
<p>logical value indicating whether diagnostic messages should be printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with dummy map. A single chromosome/linkage group is created and marker
distances are a sequence from one to the number of markers.
</p>

<hr>
<h2 id='Fis'>Estimates the population level inbreeding (Fis) by marker</h2><span id='topic+Fis'></span>

<h3>Description</h3>

<p>Estimates the population level inbreeding (Fis) by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fis(M = NULL, margin = c("col", "row"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fis_+3A_m">M</code></td>
<td>
<p>The additive <code class="reqn">n \times p</code> matrix with any coding (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="Fis_+3A_margin">margin</code></td>
<td>
<p>A character indicating the margin for call rate calculations.
Options are: <code>row</code> and <code>col</code> (default = <code>col</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the Fis for the markers.
</p>

<hr>
<h2 id='full2sparse'>Generates a sparse form matrix from a full form matrix</h2><span id='topic+full2sparse'></span>

<h3>Description</h3>

<p>Modifies the input square matrix into its sparse form with three columns per line,
corresponding to the set: <code>Row, Col, Value</code>. This matrix defines the lower triangle
row-wise of the original matrix and it is sorted as columns within row.
Values of zero on the matrix are dropped by default. Individual
names should be assigned to <code>rownames</code> and <code>colnames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full2sparse(K = NULL, drop.zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="full2sparse_+3A_k">K</code></td>
<td>
<p>A square matrix in full form (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="full2sparse_+3A_drop.zero">drop.zero</code></td>
<td>
<p>If <code>TRUE</code> observations equal to zero are dropped
(default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the function published by Borgognone <em>et al.</em> (2016).
</p>


<h3>Value</h3>

<p>A matrix in sparse form with columns: <code>Row, Col, Value</code>
together with the attributes <code>rowNames</code> and <code>colNames</code>.
If attribute <code>INVERSE</code> is found this is also passed to the sparse matrix.
</p>


<h3>References</h3>

<p>Borgognone, M.G., Butler, D.G., Ogbonnaya, F.C and Dreccer, M.F. 2016.
Molecular marker information in the analysis of multi-environment trial helps
differentiate superior genotypes from promising parents. Crop Science 56:2612-2628.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden", sparseform = FALSE)$G
G[1:5, 1:5]

# Transform matrix into sparse.
G.sparse &lt;- full2sparse(K = G)
head(G.sparse)
head(attr(G.sparse, "rowNames"))
head(attr(G.sparse, "colNames"))

</code></pre>

<hr>
<h2 id='G.inverse'>Obtains the inverse of the genomic relationship matrix G</h2><span id='topic+G.inverse'></span>

<h3>Description</h3>

<p>Generates the inverse of a genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> that is provided.
This input matrix should be of the full form (<code class="reqn">n \times n</code>)
with individual names assigned to
<code>rownames</code> and <code>colnames</code>. Several checks for the stability of the matrix are
presented based on the reciprocal conditional number.
</p>
<p>In case of an ill-conditioned matrix,
options of blending, bending or aligning before inverting are available.
These options will be deprecated (discontinued)
in future versions of <code>ASRgenomics</code>
as they can be better implemented in the function <code>G.tuneup()</code>.
</p>
<p>Based on procedures published by Nazarian and Gezan <em>et al.</em> (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G.inverse(
  G = NULL,
  A = NULL,
  rcn.thr = 1e-12,
  blend = FALSE,
  pblend = 0.02,
  bend = FALSE,
  eig.tol = NULL,
  align = FALSE,
  digits = 8,
  sparseform = FALSE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G.inverse_+3A_g">G</code></td>
<td>
<p>Input of the symmetric genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> in
full form (<code class="reqn">n \times n</code>), to obtain its inverse (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_a">A</code></td>
<td>
<p>Input of the pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>
to perform blending or aligning in full form.
It should be of the same dimension as the <code class="reqn">\boldsymbol{G}</code> matrix
(<code class="reqn">n \times n</code>) (default = <code>NULL</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_rcn.thr">rcn.thr</code></td>
<td>
<p>A threshold for identifying  the <code class="reqn">\boldsymbol{G}</code> matrix as an ill-conditioned matrix.
Based on the reciprocal conditional number (default = <code>1e-12</code>).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_blend">blend</code></td>
<td>
<p>If <code>TRUE</code> a &quot;blending&quot; with identity matrix <code class="reqn">\boldsymbol{I}</code> or pedigree relationship matrix
<code class="reqn">\boldsymbol{A}</code> (if provided) is performed (default = <code>FALSE</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_pblend">pblend</code></td>
<td>
<p>If blending is requested this is the proportion of the identity matrix <code class="reqn">\boldsymbol{I}</code> or
pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code> to blend for (default = <code>0.02</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_bend">bend</code></td>
<td>
<p>If <code>TRUE</code> a &quot;bending&quot; is performed by making the matrix near positive definite (default = <code>FALSE</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_eig.tol">eig.tol</code></td>
<td>
<p>Defines relative positiveness (<em>i.e.</em>, non-zero) of eigenvalues compared to the largest one.
It determines which threshold of eigenvalues will be treated as zero (default = <code>NULL</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_align">align</code></td>
<td>
<p>If <code>TRUE</code> the genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> is aligned to the
pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code> (default = <code>FALSE</code>) (to be deprecated).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits in used to round the output matrix (default = <code>8</code>).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_sparseform">sparseform</code></td>
<td>
<p>If <code>TRUE</code> it generates an inverse matrix in sparse form to be used directly in <span class="pkg">asreml</span> with
required attributes (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.inverse_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three of the following elements:
</p>

<ul>
<li><p><code>Ginv</code>: the inverse of <code class="reqn">\boldsymbol{G}</code> matrix in full form (only if <code>sparseform = FALSE</code>).
</p>
</li>
<li><p><code>Ginv.sparse</code>: the inverse of <code class="reqn">\boldsymbol{G}</code> matrix in sparse form (only if <code>sparseform = TRUE</code>).
</p>
</li>
<li><p><code>status</code>: the status (<code>ill-conditioned</code> or <code>well-conditioned</code>) of
the inverse of <code class="reqn">\boldsymbol{G}</code> matrix.
</p>
</li>
<li><p><code>rcn</code>: the reciprocal conditional number of the inverse of <code class="reqn">\boldsymbol{G}</code> matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Nazarian A., Gezan S.A. 2016. GenoMatrix: A software package for pedigree-based
and genomic prediction analyses on complex traits. Journal of Heredity 107:372-379.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: An ill-conditioned matrix.

# Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G
G[1:5, 1:5]

# Get the inverse of G.
GINV &lt;- G.inverse(G = G, bend = FALSE, blend = FALSE, align = FALSE)
GINV$Ginv[1:5, 1:5]
GINV$status

</code></pre>

<hr>
<h2 id='G.matrix'>Obtains the genomic matrix from SNP data for additive or dominant relationships</h2><span id='topic+G.matrix'></span>

<h3>Description</h3>

<p>Generates the genomic numerator relationship matrix for
additive (VanRaden or Yang) or dominant (Su or Vitezica) relationships.
Matrix provided <code class="reqn">\boldsymbol{M}</code> is of the form <code class="reqn">n \times p</code>, with <code class="reqn">n</code> individuals and <code class="reqn">p</code> markers.
Individual and
marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
SNP data is coded as 0, 1, 2 (integers or decimal numbers).
Missing values, if present, need to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G.matrix(
  M = NULL,
  method = "VanRaden",
  na.string = "NA",
  sparseform = FALSE,
  digits = 8,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G.matrix_+3A_m">M</code></td>
<td>
<p>A matrix with SNP data of form <code class="reqn">n \times p</code>, with <code class="reqn">n</code> individuals and <code class="reqn">p</code> markers.
Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
SNP data is coded as 0, 1, 2 (integers or decimal numbers) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.matrix_+3A_method">method</code></td>
<td>
<p>The method considered for calculation of genomic matrix.
Options are: <code>"VanRaden"</code> and <code>"Yang"</code> for additive matrix,
and <code>"Su"</code> and <code>"Vitezica"</code> for dominant matrix (default =  <code>"VanRaden"</code>).</p>
</td></tr>
<tr><td><code id="G.matrix_+3A_na.string">na.string</code></td>
<td>
<p>A character that is interpreted as missing values (default = <code>"NA"</code>).</p>
</td></tr>
<tr><td><code id="G.matrix_+3A_sparseform">sparseform</code></td>
<td>
<p>If <code>TRUE</code> it generates a matrix in sparse form to be used directly in <span class="pkg">asreml</span> with
required attributes (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.matrix_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits used to round the output matrix (default = 8).</p>
</td></tr>
<tr><td><code id="G.matrix_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: If data is provided with missing values, it will process calculations
of relationships on pairwise non-missing data.
</p>
<p>It uses function <code>Gmatrix</code> for calculations
from R package  <span class="pkg">AGHmatrix</span> (Amadeu <em>et al.</em> 2019).
</p>


<h3>Value</h3>

<p>A list with one of these two elements:
</p>

<ul>
<li><p><code>G</code>: the <code class="reqn">\boldsymbol{G}</code> matrix in full form (only if <code>sparseform = FALSE</code>).
</p>
</li>
<li><p><code>G.sparse</code>: the <code class="reqn">\boldsymbol{G}</code> matrix in sparse form (only if <code>sparseform = TRUE</code>).
</p>
</li></ul>



<h3>References</h3>

<p>Amadeu, R.R., Cellon, C., Olmstead, J.W., Garcia, A.A.F, Resende, M.F.R. and P.R. Munoz. 2016.
AGHmatrix: R package to construct relationship matrices for autotetraploid and diploid species:
A blueberry example. The Plant Genome 9(3). doi: 10.3835/plantgenome2016.01.0009
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Requesting a full matrix by VanRanden.

# Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G
G[1:5, 1:5]


# Example: Requesting a sparse form by VanRanden.

# Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden", sparseform = TRUE)$G.sparse
head(G)
head(attr(G, "rowNames"))


</code></pre>

<hr>
<h2 id='G.predict'>Generates the conditional predictions of random effects (BLUPs)</h2><span id='topic+G.predict'></span>

<h3>Description</h3>

<p>Predicts random effects values for individuals with unobserved responses (here called <code>x</code>,
a vector of length <code class="reqn">nx</code>) based on known random effect values for individuals with
observed responses (here called <code>y</code>, a vector of length <code class="reqn">ny</code>). This is done using the
common genomic relationship matrix  <code class="reqn">\boldsymbol{G}</code> for all
individuals (full matrix of dimension <code class="reqn">(nx + ny) \times (nx + ny)</code>).
</p>
<p>The prediction of unobserved responses will be performed through the
multivariante Normal conditional distribution. These predictions are identical to
what would be obtained if the entire set of individuals (<code class="reqn">nx + ny</code>) were included into a
GBLUP animal model fit with individuals in the set <code>x</code> coded as missing.
</p>
<p>The user needs to provide the matrix <code class="reqn">\boldsymbol{G}</code> in full form.
Individual names (<code class="reqn">nx + ny</code>) should be assigned to <code>rownames</code> and <code>colnames</code>, and these
can be in any order. If the variance-covariance matrix of the set <code>y</code> is provided,
standard errors of random effects in set <code>x</code> are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G.predict(G = NULL, gy = NULL, vcov.gy = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G.predict_+3A_g">G</code></td>
<td>
<p>Input of the genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> in full form
(of dimension <code class="reqn">(nx + ny) \times (nx + ny)</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.predict_+3A_gy">gy</code></td>
<td>
<p>Input of random effects (<em>e.g.</em> breeding values) for individuals with known values.
Individual names should be assigned to <code>rownames</code> of this vector
and be found on the matrix <code class="reqn">\boldsymbol{G}</code> (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.predict_+3A_vcov.gy">vcov.gy</code></td>
<td>
<p>The variance-covariance matrix associated with the random effects from the
individuals with known values (set <code>y</code>, of dimension <code class="reqn">ny \times ny</code>)
(default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the predicted random effect values for individuals with
unobserved responses in the set <code>x</code>. If the variance-covariance matrix is provided,
standard errors are included in an additional column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(asreml) # Load asreml.

# Example: Apple data creating 100 missing observations.

# Prepare G (nx + ny).
G &lt;- G.matrix(M = geno.apple, method = "VanRaden", sparseform = FALSE)$G
dim(G)

# Prepare subset of data.
# Select only 147 from 247 individuals from pheno.apple and geno.apple.
Gy &lt;- G[1:147, 1:147]
phenoy &lt;- pheno.apple[1:147, ]

# Obtain the BLUPs for the 147 individuals using ASReml-R.

# Blend Gy.
Gyb &lt;- G.tuneup(G = Gy, blend = TRUE, pblend = 0.02)$Gb

# Get the Gy inverse
Gyinv  &lt;- G.inverse(G = Gyb, sparseform = TRUE)$Ginv.sparse

# Fit a GBLUP model
phenoy$INDIV &lt;- as.factor(phenoy$INDIV)
modelGBLUP &lt;-
 asreml(
  fixed = JUI_MOT ~ 1,
  random = ~vm(INDIV, Gyinv),
  workspace = 128e06,
  data = phenoy)

# Obtain Predictions - BLUP (set y).
BLUP &lt;- summary(modelGBLUP,coef = TRUE)$coef.random
head(BLUP)
gy &lt;- as.matrix(BLUP[, 1])
rownames(gy) &lt;- phenoy$INDIV

# Ready to make conditional predictions.
g.cond &lt;- G.predict(G = G, gy = gy)
head(g.cond)

## End(Not run)

</code></pre>

<hr>
<h2 id='G.tuneup'>Tune-up the the genomic relationship matrix G</h2><span id='topic+G.tuneup'></span>

<h3>Description</h3>

<p>Generates a new matrix that can be <em>blended</em>, <em>bended</em> or <em>aligned</em>
in order to make it stable for future use or matrix inversion. The input matrix should
be of the full form (<code class="reqn">n \times n</code>) with individual names assigned to
<code>rownames</code> and <code>colnames</code>.
</p>
<p>This routine provides three options of tune-up:
</p>

<ul>
<li><p><em>Blend</em>. The <code class="reqn">\boldsymbol{G}</code> matrix is blended (or averaged)
with another matrix. <code class="reqn">\boldsymbol{G}^\ast=(1-p) \boldsymbol{G} + p
 \boldsymbol{A}</code>, where <code class="reqn">\boldsymbol{G}^\ast</code> is the blended matrix,
<code class="reqn">\boldsymbol{G}</code> is the original matrix,  <code class="reqn">p</code> is the proportion of
the identity matrix or pedigree-based relationship matrix to consider, and
<code class="reqn">\boldsymbol{A}</code> is the matrix to blend. Ideally, the pedigree-based
relationship matrix should be used, but if this is not available (or it is
of poor quality), then it is replaced by an identity matrix
<code class="reqn">\boldsymbol{I}</code>.
</p>
</li>
<li><p><em>Bend</em>. It consists on adjusting the original
<code class="reqn">\boldsymbol{G}</code> matrix to obtain a near positive definite matrix, which
is done by making all negative or very small eigenvalues slightly positive.
</p>
</li>
<li><p><em>Align</em>. The original <code class="reqn">\boldsymbol{G}</code> matrix is aligned to
the matching pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code> where an
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> parameters are obtained. More information can
be found in the manual or in Christensen <em>et al.</em> (2012).
</p>
</li></ul>

<p>The user should provide the matrices <code class="reqn">\boldsymbol{G}</code> and
<code class="reqn">\boldsymbol{A}</code> in full form (<code class="reqn">n \times n</code>)
and matching individual names should be
assigned to the <code>rownames</code> and <code>colnames</code> of the matrices.
</p>
<p>Based on procedures published by Nazarian and Gezan <em>et al.</em> (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G.tuneup(
  G = NULL,
  A = NULL,
  blend = FALSE,
  pblend = 0.02,
  bend = FALSE,
  eig.tol = 1e-06,
  align = FALSE,
  rcn = TRUE,
  digits = 8,
  sparseform = FALSE,
  determinant = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G.tuneup_+3A_g">G</code></td>
<td>
<p>Input of the genomic matrix <code class="reqn">\boldsymbol{G}</code> to tune-up
in full form (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_a">A</code></td>
<td>
<p>Input of the matching pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>
in full form (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_blend">blend</code></td>
<td>
<p>If <code>TRUE</code> a <em>blending</em> with identity matrix <code class="reqn">\boldsymbol{I}</code> or pedigree relationship matrix
<code class="reqn">\boldsymbol{A}</code> (if provided) is performed (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_pblend">pblend</code></td>
<td>
<p>If blending is requested this is the proportion of the identity matrix <code class="reqn">\boldsymbol{I}</code> or
pedigree-based relationship matrix <code class="reqn">\boldsymbol{A}</code> to blend for (default = <code>0.02</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_bend">bend</code></td>
<td>
<p>If <code>TRUE</code> a <em>bending</em> is performed by making the matrix near positive definite (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_eig.tol">eig.tol</code></td>
<td>
<p>Defines relative positiveness (<em>i.e.</em>, non-zero) of eigenvalues compared to the largest one.
It determines which threshold of eigenvalues will be treated as zero (default = <code>1e-06</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_align">align</code></td>
<td>
<p>If <code>TRUE</code> the genomic matrix <code class="reqn">\boldsymbol{G}</code> is <em>aligned</em> to the
matching pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code> (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_rcn">rcn</code></td>
<td>
<p>If <code>TRUE</code> the reciprocal conditional number of the original and the bended,
blended or aligned matrix will be calculated (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits used to round the output matrix (default = <code>8</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_sparseform">sparseform</code></td>
<td>
<p>If <code>TRUE</code> it generates an inverse matrix in sparse form to be used directly in <span class="pkg">asreml</span> with
required attributes (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_determinant">determinant</code></td>
<td>
<p>If <code>TRUE</code> the determinant will be calculated, otherwise, this is obtained for
matrices of a dimension of less than 1,500 <code class="reqn">\times</code> 1,500 (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="G.tuneup_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six of the following elements:
</p>

<ul>
<li><p><code>Gb</code>: the inverse of <code class="reqn">\boldsymbol{G}</code> matrix in full form
(only if sparseform = <code>FALSE</code>).
</p>
</li>
<li><p><code>Gb.sparse</code>: if requested, the inverse of <code class="reqn">\boldsymbol{G}</code> matrix in
sparse form (only if sparseform = <code>TRUE</code>).
</p>
</li>
<li><p><code>rcn0</code>: the reciprocal conditional number of the original matrix.
Values near zero are associated with an ill-conditioned matrix.
</p>
</li>
<li><p><code>rcnb</code>: the reciprocal conditional number of the blended, bended or aligned
matrix. Values near zero are associated with an ill-conditioned matrix.
</p>
</li>
<li><p><code>det0</code>: if requested, the determinant of the original matrix.
</p>
</li>
<li><p><code>blend</code>: if the matrix was <em>blended</em>.
</p>
</li>
<li><p><code>bend</code>: if the matrix was <em>bended</em>.
</p>
</li>
<li><p><code>align</code>: if the matrix was <em>aligned</em>.
</p>
</li></ul>



<h3>References</h3>

<p>Christensen, O.F., Madsen, P., Nielsen, B., Ostersen, T. and Su, G. 2012.
Single-step methods for genomic evaluation in pigs. Animal 6:1565-1571.
doi:10.1017/S1751731112000742.
</p>
<p>Nazarian A., Gezan S.A. 2016. GenoMatrix: A software package for pedigree-based
and genomic prediction analyses on complex traits. Journal of Heredity 107:372-379.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example: Apple dataset.

# Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G
G[1:5, 1:5]

# Blend G matrix.
G_blended &lt;- G.tuneup(G = G, blend = TRUE, pblend = 0.05)
G_blended$Gb[1:5, 1:5]

# Bend G matrix.
G_bended &lt;- G.tuneup(G = G, bend = TRUE, eig.tol = 1e-03)
G_bended$Gb[1:5, 1:5]


# Example: Loblolly Pine dataset with pedigree - Aligned G matrix.

A &lt;- AGHmatrix::Amatrix(ped.pine)
dim(A)

# Read and filter genotypic data.
M.clean &lt;- qc.filtering(
 M = geno.pine655,
 maf = 0.05,
 marker.callrate = 0.2, ind.callrate = 0.20,
 na.string = "-9")$M.clean

# Get G matrix.
G &lt;- G.matrix(M = M.clean, method = "VanRaden", na.string = "-9")$G
G[1:5, 1:5]
dim(G)

# Match G and A.
Aclean &lt;- match.G2A(A = A, G = G, clean = TRUE, ord = TRUE, mism = TRUE)$Aclean

# Align G with A.
G_align &lt;- G.tuneup(G = G, A = Aclean, align = TRUE)
G_align$Gb[1:5, 1:5]


</code></pre>

<hr>
<h2 id='geno.apple'>Genotypic data for apple dataset</h2><span id='topic+geno.apple'></span>

<h3>Description</h3>

<p>Genotypic data on 247 apple clones (<em>i.e.</em>, genotypes) with a total of
2,828 SNP markers (coded as 0, 1, 2 and there are no missing records).
Dataset obtained from supplementary material in Kumar <em>et al.</em> (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.apple
</code></pre>


<h3>Format</h3>

<p>matrix
</p>


<h3>References</h3>

<p>Kumar S., Molloy C., Muñoz P., Daetwyler H., Chagné D., and Volz R. 2015.
Genome-enabled estimates of additive and nonadditive genetic variances and prediction
of apple phenotypes across environments. G3 Genes, Genomes, Genetics 5:2711-2718.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno.apple[1:5, 1:5]

</code></pre>

<hr>
<h2 id='geno.pine655'>Genotypic data of 655 genotypes for loblolly pine dataset</h2><span id='topic+geno.pine655'></span>

<h3>Description</h3>

<p>Genotypic data for a total of 4,853 SNPs (coded as 0, 1, 2 and -9 for missing)
on 655 genotypes of Loblolly Pine (<em>Pinus taeda</em> L.).
Dataset modified from supplementary material from Resende <em>et al.</em> (2012).
This dataset differs from the original as some genotypes were made artificially
missing by full-sib family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.pine655
</code></pre>


<h3>Format</h3>

<p>matrix
</p>


<h3>References</h3>

<p>Resende, M.F.R., Munoz, P. Resende, M.D.V., Garrick, D.J., Fernando, R.L., Davis, J.M.,
Jokela, E.J., Martin, T.A., Peter, G.F., and Kirst, M. 2012. Accuracy of genomic
selection methods in a standard data set of loblolly pine (<em>Pinus taeda</em> L.).
Genetics 190:1503-1510.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno.pine655[1:5, 1:5]

</code></pre>

<hr>
<h2 id='geno.pine926'>Genotypic data of 926 genotypes for loblolly pine dataset</h2><span id='topic+geno.pine926'></span>

<h3>Description</h3>

<p>Genotypic data for a total of 4,853 SNPs (coded as 0, 1, 2 and -9 for missing)
on 926 genotypes of Loblolly Pine (<em>Pinus taeda</em> L.).
Dataset obtained from supplementary material in Resende <em>et al.</em> (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.pine926
</code></pre>


<h3>Format</h3>

<p>matrix
</p>


<h3>References</h3>

<p>Resende, M.F.R., Munoz, P. Resende, M.D.V., Garrick, D.J., Fernando, R.L., Davis, J.M.,
Jokela, E.J., Martin, T.A., Peter, G.F., and Kirst, M. 2012. Accuracy of genomic
selection methods in a standard data set of loblolly pine (<em>Pinus taeda</em> L.).
Genetics 190:1503-1510.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno.pine926[1:5, 1:5]

</code></pre>

<hr>
<h2 id='geno.salmon'>Genotypic data for Atlantic salmon dataset</h2><span id='topic+geno.salmon'></span>

<h3>Description</h3>

<p>Genotypic data on 1,481 Atlantic salmon samples. A total of 17,156
SNP markers (coded as 0, 1, 2 and <code>NA</code> for missing) are included in this dataset.
Dataset obtained from supplementary material in Robledo <em>et al.</em> (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.salmon
</code></pre>


<h3>Format</h3>

<p>matrix
</p>


<h3>References</h3>

<p>Robledo D., Matika O., Hamilton A., and Houston R.D. 2018.
Genome-wide association and genomic selection for resistance
to amoebic gill disease in Atlantic salmon.
G3 Genes, Genomes, Genetics 8:1195-1203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geno.salmon[1:5, 1:5]

</code></pre>

<hr>
<h2 id='H.inverse'>Generates the inverse of the hybrid H matrix</h2><span id='topic+H.inverse'></span>

<h3>Description</h3>

<p>The single-step GBLUP approach combines the information from the pedigree relationship matrix
<code class="reqn">\boldsymbol{A}</code> and the genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> in one
hybrid relationship matrix called <code class="reqn">\boldsymbol{H}</code>.
This function will calculate directly the inverse of this matrix <code class="reqn">\boldsymbol{H}</code>.
The user should provide the matrices <code class="reqn">\boldsymbol{A}</code> or
its inverse (only one of these is required) and the
inverse of the matrix <code class="reqn">\boldsymbol{G}</code> (<code class="reqn">\boldsymbol{G_{inv}}</code>) in its full form. Individual names should
be assigned to  <code>rownames</code> and <code>colnames</code>, and individuals from
<code class="reqn">\boldsymbol{G_{inv}}</code> are verified to be all a subset within individuals from
<code class="reqn">\boldsymbol{A}</code> (or <code class="reqn">\boldsymbol{A_{inv}}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.inverse(
  A = NULL,
  Ainv = NULL,
  Ginv = NULL,
  lambda = NULL,
  tau = 1,
  omega = 1,
  sparseform = FALSE,
  keep.order = TRUE,
  digits = 8,
  inverse = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H.inverse_+3A_a">A</code></td>
<td>
<p>Input of the pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>
in full form (<code class="reqn">na \times na</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_ainv">Ainv</code></td>
<td>
<p>Input of the inverse of the pedigree relationship matrix
<code class="reqn">\boldsymbol{A}^{-1}</code> in full form (<code class="reqn">na \times na</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_ginv">Ginv</code></td>
<td>
<p>Input of the inverse of the genomic relationship matrix
<code class="reqn">\boldsymbol{G}^{-1}</code> in full form (<code class="reqn">ng \times ng</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_lambda">lambda</code></td>
<td>
<p>The scaling factor for <code class="reqn">(\boldsymbol{G}^{-1}-\boldsymbol{A}^{-1}_{22})</code> (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_tau">tau</code></td>
<td>
<p>The scaling factor for <code class="reqn">\boldsymbol{G}^{-1}</code> (default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_omega">omega</code></td>
<td>
<p>The scaling factor for <code class="reqn">\boldsymbol{A}^{-1}_{22}</code> (default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_sparseform">sparseform</code></td>
<td>
<p>If <code>TRUE</code> it generates the requested matrix in sparse form to be used
directly in <span class="pkg">asreml</span> with required attributes (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_keep.order">keep.order</code></td>
<td>
<p>If <code>TRUE</code> the original order of the individuals from the
<code class="reqn">\boldsymbol{A}</code> or <code class="reqn">\boldsymbol{A_{inv}}</code> matrix is kept.
Otherwise the non-genotyped individuals are placed first and
then genotyped individuals (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits used to round the output matrix (default = <code>8</code>).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_inverse">inverse</code></td>
<td>
<p>If <code>TRUE</code> it generates the inverse of <code class="reqn">\boldsymbol{H}</code> matrix (default = <code>TRUE</code>)
(to be deprecated).</p>
</td></tr>
<tr><td><code id="H.inverse_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation of the <code class="reqn">\boldsymbol{H^{-1}}</code> matrix contains a few scaling factors
to help with the calculation of this inverse and
to allow further exploration of the combination of the
information from the <code class="reqn">\boldsymbol{A^{-1}}</code> and <code class="reqn">\boldsymbol{G^{-1}}</code>.
We follow the specifications described by Martini <em>et. al</em> (2018),
which is done by specifying the parameters <code class="reqn">\lambda</code>, or the pair
<code class="reqn">\tau</code> and <code class="reqn">\omega</code>.
</p>

<p>The general expression used is:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{H^{-1}}=\boldsymbol{A^{-1}}+\begin{bmatrix}\boldsymbol{0}&amp;\boldsymbol{0}\\\boldsymbol{0}&amp;(\tau\boldsymbol{G^{-1}}-\omega\boldsymbol{{A_{22}^{-1}}})\end{bmatrix}</code>
</p>



<p>and a more common representation of the above expression is found when <code class="reqn">\tau = \omega = \lambda</code>, as shown below:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{H^{-1}}=\boldsymbol{A^{-1}}+\begin{bmatrix}\boldsymbol{0}&amp;\boldsymbol{0}\\\boldsymbol{0}&amp;\lambda(\boldsymbol{G^{-1}}-\boldsymbol{{A_{22}^{-1}}})\end{bmatrix}</code>
</p>


<p>If <code>inverse = FALSE</code> the <code class="reqn">\boldsymbol{H}</code>
matrix is provided instead of its inverse. This option will be deprecated and
it is better to use the function <a href="#topic+H.matrix">H.matrix</a>.
</p>

<p>The <code class="reqn">\boldsymbol{H}</code> matrix is obtained with the following equations:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{H}=\boldsymbol{A}+\begin{bmatrix}\boldsymbol{A}_{12}\boldsymbol{A}_{22}^{-1}(\boldsymbol{G}-\boldsymbol{A}_{22})\boldsymbol{A}_{22}^{-1}\boldsymbol{A}_{21}&amp;\boldsymbol{A}_{12}\boldsymbol{A}_{22}^{-1}(\boldsymbol{G}-\boldsymbol{A}_{22})\\(\boldsymbol{G}-\boldsymbol{A}_{22})\boldsymbol{A}_{22}^{-1}\boldsymbol{A}_{21}&amp;(\boldsymbol{G}-\boldsymbol{A}_{22})\end{bmatrix}</code>
</p>




<h3>Value</h3>

<p>The inverse of the hybrid matrix <code class="reqn">\boldsymbol{H}</code> matrix, in full or sparse form with
required attributes to be used in <span class="pkg">asreml</span>.
</p>


<h3>References</h3>

<p>Christensen, O.F., Lund, M.S. 2010. Genomic prediction matrix when some animals
are not genotyped. Gen. Sel. Evol. 42(2):1–8.
</p>
<p>Christensen, O., Madsen, P., Nielsen, B., Ostersen, T., and Su, G. 2012. Single-step methods
for genomic evaluation in pigs. Animal 6(10):1565–1571.
</p>
<p>Legarra, A., Aguilar, I., and Misztal, I. 2009. A relationship matrix including full
pedigree and genomic information. J. Dairy Sci. 92:4656-4663.
</p>
<p>Martini, J.W.R., Schrauf, M.F., Garcia-Baccino, C.A., Pimentel, E.C.G., Munilla, S.,
Rogberg-Muñoz, A., Cantet, R.J.C., Reimer, C., Gao, N., Wimmer, V., and Simianer, H. 2018.
The effect of the <code class="reqn">H^{-1}</code> scaling factors <code class="reqn">\tau</code> and <code class="reqn">\omega</code>
on the structure of <code class="reqn">H</code> in the single-step procedure.
Genet. Sel. Evol. 50:1-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get A matrix.
A &lt;- AGHmatrix::Amatrix(data = ped.pine)
A[1:5,1:5]
dim(A)

# Read and filter genotypic data.
M.clean &lt;- qc.filtering(
 M = geno.pine655,
 maf = 0.05,
 marker.callrate = 0.2, ind.callrate = 0.20,
 na.string = "-9",
 plots = FALSE)$M.clean

# Get G matrix.
G &lt;- G.matrix(M.clean, method = "VanRaden", na.string = "-9")$G
G[1:5, 1:5]
dim(G)

# Match G and A.
check &lt;- match.G2A(
 A = A, G = G,
 clean = TRUE, ord = TRUE, mism = TRUE, RMdiff = TRUE)

# Align G matrix with A.
G_align &lt;- G.tuneup(G = check$Gclean, A = check$Aclean, align = TRUE, sparseform = FALSE)$Gb

# Get Ginverse using the G aligned.
Ginv &lt;- G.inverse(G = G_align, sparseform = FALSE)$Ginv
Ginv[1:5, 1:5]
dim(Ginv)

# Obtain Hinv.
Hinv &lt;- H.inverse(A = A, Ginv = Ginv, lambda = 0.90, sparseform = TRUE)
head(Hinv)
attr(Hinv, "INVERSE")


</code></pre>

<hr>
<h2 id='H.matrix'>Generates the hybrid <code class="reqn">H</code> matrix</h2><span id='topic+H.matrix'></span>

<h3>Description</h3>

<p>The single-step GBLUP approach combines the information from the pedigree relationship matrix
<code class="reqn">\boldsymbol{A}</code> and the genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> in one
hybrid relationship matrix called <code class="reqn">\boldsymbol{H}</code>.
This function will calculate directly this matrix <code class="reqn">\boldsymbol{H}</code>.
The user should provide the matrices <code class="reqn">\boldsymbol{A}</code> or
its inverse (only one of these is required) and the
inverse of the matrix <code class="reqn">\boldsymbol{G}</code> (<code class="reqn">\boldsymbol{G_{inv}}</code>) in its full form.
Individual names should
be assigned to  <code>rownames</code> and <code>colnames</code>, and individuals from
<code class="reqn">\boldsymbol{G_{inv}}</code> are verified to be all a subset within individuals from
<code class="reqn">\boldsymbol{A}</code> (or <code class="reqn">\boldsymbol{A_{inv}}</code>).
This function is a wrapper of  the <a href="#topic+H.inverse">H.inverse</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.matrix(
  A = NULL,
  Ainv = NULL,
  Ginv = NULL,
  lambda = NULL,
  tau = 1,
  omega = 1,
  sparseform = FALSE,
  keep.order = TRUE,
  digits = 8,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H.matrix_+3A_a">A</code></td>
<td>
<p>Input of the pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>
in full form (<code class="reqn">na \times na</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_ainv">Ainv</code></td>
<td>
<p>Input of the inverse of the pedigree relationship matrix
<code class="reqn">\boldsymbol{A}^{-1}</code> in full form (<code class="reqn">na \times na</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_ginv">Ginv</code></td>
<td>
<p>Input of the inverse of the genomic relationship matrix
<code class="reqn">\boldsymbol{G}^{-1}</code> in full form (<code class="reqn">ng \times ng</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_lambda">lambda</code></td>
<td>
<p>The scaling factor for <code class="reqn">(\boldsymbol{G}^{-1}-\boldsymbol{A}^{-1}_{22})</code> (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_tau">tau</code></td>
<td>
<p>The scaling factor for <code class="reqn">\boldsymbol{G}^{-1}</code> (default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_omega">omega</code></td>
<td>
<p>The scaling factor for <code class="reqn">\boldsymbol{A}^{-1}_{22}</code> (default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_sparseform">sparseform</code></td>
<td>
<p>If <code>TRUE</code> it generates the requested matrix in sparse form to be used
directly in <span class="pkg">asreml</span> with required attributes (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_keep.order">keep.order</code></td>
<td>
<p>If <code>TRUE</code> the original order of the individuals from the
<code class="reqn">\boldsymbol{A}</code> or <code class="reqn">\boldsymbol{A_{inv}}</code> matrix is kept.
Otherwise the non-genotyped individuals are placed first and
then genotyped individuals (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits used to round the output matrix (default = <code>8</code>).</p>
</td></tr>
<tr><td><code id="H.matrix_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is currently equivalent to using <a href="#topic+H.inverse">H.inverse</a> with (<code>inverse = FALSE</code>).
</p>

<p>The <code class="reqn">\boldsymbol{H}</code> matrix is obtained with the following equations:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{H}=\boldsymbol{A}+\begin{bmatrix}\boldsymbol{A}_{12}\boldsymbol{A}_{22}^{-1}(\boldsymbol{G}-\boldsymbol{A}_{22})\boldsymbol{A}_{22}^{-1}\boldsymbol{A}_{21}&amp;\boldsymbol{A}_{12}\boldsymbol{A}_{22}^{-1}(\boldsymbol{G}-\boldsymbol{A}_{22})\\(\boldsymbol{G}-\boldsymbol{A}_{22})\boldsymbol{A}_{22}^{-1}\boldsymbol{A}_{21}&amp;(\boldsymbol{G}-\boldsymbol{A}_{22})\end{bmatrix}</code>
</p>




<h3>Value</h3>

<p>The hybrid matrix <code class="reqn">\boldsymbol{H}</code> matrix, in full or sparse form.
</p>


<h3>References</h3>

<p>Christensen, O.F., Lund, M.S. 2010. Genomic prediction matrix when some animals
are not genotyped. Gen. Sel. Evol. 42(2):1–8.
</p>
<p>Christensen, O., Madsen, P., Nielsen, B., Ostersen, T., and Su, G. 2012. Single-step methods
for genomic evaluation in pigs. Animal 6(10):1565–1571.
</p>
<p>Legarra, A., Aguilar, I., and Misztal, I. 2009. A relationship matrix including full
pedigree and genomic information. J. Dairy Sci. 92:4656-4663.
</p>
<p>Martini, J.W.R., Schrauf, M.F., Garcia-Baccino, C.A., Pimentel, E.C.G., Munilla, S.,
Rogberg-Muñoz, A., Cantet, R.J.C., Reimer, C., Gao, N., Wimmer, V., and Simianer, H. 2018.
The effect of the <code class="reqn">H^{-1}</code> scaling factors <code class="reqn">\tau</code> and <code class="reqn">\omega</code>
on the structure of <code class="reqn">H</code> in the single-step procedure.
Genet. Sel. Evol. 50:1-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get A matrix.
A &lt;- AGHmatrix::Amatrix(data = ped.pine)
A[1:5,1:5]
dim(A)

# Read and filter genotypic data.
M.clean &lt;- qc.filtering(
 M = geno.pine655,
 maf = 0.05,
 marker.callrate = 0.2, ind.callrate = 0.20,
 na.string = "-9",
 plots = FALSE)$M.clean

# Get G matrix.
G &lt;- G.matrix(M = M.clean, method = "VanRaden", na.string = "-9")$G
G[1:5, 1:5]
dim(G)

# Match G2A.
check &lt;- match.G2A(
 A = A, G = G,
 clean = TRUE, ord = TRUE, mism = TRUE, RMdiff = TRUE)

# Align G matrix with A.
G_align &lt;- G.tuneup(G = check$Gclean, A = check$Aclean, align = TRUE, sparseform = FALSE)$Gb

# Get Ginverse using the aligned G.
Ginv &lt;- G.inverse(G = G_align, sparseform = FALSE)$Ginv
Ginv[1:5, 1:5]
dim(Ginv)

# Obtaining H.
H &lt;- H.matrix(A = A, G = Ginv, lambda = 0.90, sparseform = FALSE)
H[1:5, 1:5]


</code></pre>

<hr>
<h2 id='heterozygosity'>Estimates observed and expected heterozygosity</h2><span id='topic+heterozygosity'></span>

<h3>Description</h3>

<p>Estimates observed and expected heterozygosity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heterozygosity(M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heterozygosity_+3A_m">M</code></td>
<td>
<p>The additive <code class="reqn">n \times p</code> matrix coded with 0, 1, 2 coding (default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vectors containing the observed (ho) and expected (he) heterozygosity.
</p>

<hr>
<h2 id='kinship.diagnostics'>Reports summary statistics, plots and filter options for a given kinship matrix K</h2><span id='topic+kinship.diagnostics'></span>

<h3>Description</h3>

<p>It reports summary statistics, plots and allows for some filter options
for diagonal and off-diagonal elements for a given kinship matrix.
The input matrix can be a pedigree-based
relationship matrix <code class="reqn">\boldsymbol{A}</code>, a genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> or a
hybrid relationship matrix <code class="reqn">\boldsymbol{H}</code>.
Individual names should be assigned to <code>rownames</code> and <code>colnames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.diagnostics(
  K = NULL,
  diagonal.thr.large = 1.2,
  diagonal.thr.small = 0.8,
  duplicate.thr = 0.95,
  clean.diagonal = FALSE,
  clean.duplicate = FALSE,
  plots = TRUE,
  sample.plot = 1,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinship.diagnostics_+3A_k">K</code></td>
<td>
<p>Input of a kinship matrix in full format (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_diagonal.thr.large">diagonal.thr.large</code></td>
<td>
<p>A threshold value to flag large diagonal values (default = <code>1.2</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_diagonal.thr.small">diagonal.thr.small</code></td>
<td>
<p>A threshold value to flag small diagonal values (default = <code>0.8</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_duplicate.thr">duplicate.thr</code></td>
<td>
<p>A threshold value to flag possible duplicates. Any calculation larger than the
threshold based on
<code class="reqn">\boldsymbol{k}_{i,i}\mathbin{/}\sqrt{\boldsymbol{k}_{i,i} \times \boldsymbol{k}_{j,j}}</code>
is identified as a duplicate (default = <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_clean.diagonal">clean.diagonal</code></td>
<td>
<p>If <code>TRUE</code> returns a kinship matrix filtered by values smaller than
<code>diagonal.thr.large</code> and larger than <code>diagonal.thr.small</code> (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_clean.duplicate">clean.duplicate</code></td>
<td>
<p>If <code>TRUE</code> return a kinship matrix without the flagged duplicate individuals.
All individuals involved are removed (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_plots">plots</code></td>
<td>
<p>If <code>TRUE</code> generates graphical output of the diagonal and off-diagonal
values of the kinship matrix (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_sample.plot">sample.plot</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the proportion
of the data points to be sampled for fast plotting of off-diagonal values.
Note that for proportions other than 1, the method is not exact and low
proportions are only recommended for large kinship matrices (default = <code>1</code>).</p>
</td></tr>
<tr><td><code id="kinship.diagnostics_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>list.diagonal</code>: a data frame with the list of flagged large or small diagonal values.
</p>
</li>
<li><p><code>list.duplicate</code>: a data frame with the list of possible duplicates.
</p>
</li>
<li><p><code>clean.kinship</code>: output of kinship matrix filtered without the flagged diagonal
and/or duplicate individuals.
</p>
</li>
<li><p><code>plot.diagonal</code>: histogram with the distribution of diagonal values from the kinship matrix.
</p>
</li>
<li><p><code>plot.offdiag</code>: histogram with the distribution of off-diagonal values from kinship matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G

# Diagnose G.
G_summary &lt;- kinship.diagnostics(
 K = G,
 diagonal.thr.large = 1.3, diagonal.thr.small = 0.7, clean.diagonal = TRUE,
 duplicate.thr = 0.8, clean.duplicate = TRUE,
 sample.plot = 0.50)
ls(G_summary)
dim(G_summary$clean.kinship)
G_summary$clean.kinship[1:5, 1:5]
G_summary$list.duplicate
G_summary$list.diagonal
G_summary$plot.diag
G_summary$plot.offdiag

</code></pre>

<hr>
<h2 id='kinship.heatmap'>Enhanced heatmap plot for a kinship matrix K</h2><span id='topic+kinship.heatmap'></span>

<h3>Description</h3>

<p>Generates a heatmap with dendrogram based on a provided kinship matrix.
This matrix can be a pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>, a
genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> or a hybrid relationship
matrix <code class="reqn">\boldsymbol{H}</code>.
Individual names should be assigned to <code>rownames</code> and <code>colnames</code>.
It sorts individuals according to dendrogram in both columns and rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.heatmap(
  K = NULL,
  dendrogram = TRUE,
  clustering.method = c("hierarchical", "kmeans"),
  dist.method = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  row.label = TRUE,
  col.label = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinship.heatmap_+3A_k">K</code></td>
<td>
<p>Input of a kinship matrix in full format (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="kinship.heatmap_+3A_dendrogram">dendrogram</code></td>
<td>
<p>If <code>TRUE</code> a dendrogram is added to the columns based on the
kinship matrix (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="kinship.heatmap_+3A_clustering.method">clustering.method</code></td>
<td>
<p>The clustering method considered for the dendrogram.
Options are: <code>"hierarchical"</code> and <code>"kmeans"</code> (default = <code>"hierarchical"</code>).</p>
</td></tr>
<tr><td><code id="kinship.heatmap_+3A_dist.method">dist.method</code></td>
<td>
<p>The method considered to calculate the distance matrix between
individuals used for hierarchical clustering. Options are: <code>"euclidean"</code>,
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code> and
<code>"minkowski"</code> (default = <code>"euclidean"</code>).</p>
</td></tr>
<tr><td><code id="kinship.heatmap_+3A_row.label">row.label</code></td>
<td>
<p>If <code>TRUE</code> the individual names (<code>rownames</code>) are added as labels to
the left of the heatmap (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="kinship.heatmap_+3A_col.label">col.label</code></td>
<td>
<p>If <code>TRUE</code> the individual names (<code>colnames</code>) are added as labels to
the bottom of the heatmap (default = <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the library <code>superheat</code> from Barter and Yu (2018) to generate plots.
</p>


<h3>Value</h3>

<p>A plot with the properties specified by the above arguments.
</p>


<h3>References</h3>

<p>Barter, R.L. and Yu, B. 2018. Superheat: An R package for creating beautiful
and extendable heatmaps for visualizing complex data.
J. Comput. Graph. Stat. 27(4):910-922.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G
G[1:5, 1:5]

# Plot a subset of the individuals.
kinship.heatmap(K = G[1:10, 1:10], dendrogram = TRUE, row.label = TRUE, col.label = TRUE)

</code></pre>

<hr>
<h2 id='kinship.pca'>Performs a Principal Component Analysis (PCA) based on a kinship matrix K</h2><span id='topic+kinship.pca'></span>

<h3>Description</h3>

<p>Generates a PCA and summary statistics from a given kinship matrix for
population structure. This matrix
can be a pedigree-based relationship matrix <code class="reqn">\boldsymbol{A}</code>, a genomic
relationship matrix <code class="reqn">\boldsymbol{G}</code> or a hybrid relationship matrix
<code class="reqn">\boldsymbol{H}</code>. Individual names should be assigned to <code>rownames</code> and
<code>colnames</code>. There is additional output such as plots and other data frames
to be used on other downstream analyses (such as GWAS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship.pca(
  K = NULL,
  scale = TRUE,
  label = FALSE,
  ncp = 10,
  groups = NULL,
  ellipses = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinship.pca_+3A_k">K</code></td>
<td>
<p>Input of a kinship matrix in full form (<code class="reqn">n \times n</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="kinship.pca_+3A_scale">scale</code></td>
<td>
<p>If <code>TRUE</code> the PCA analysis will scale the kinship matrix, otherwise
it is used in its original scale (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="kinship.pca_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code> then includes in output individuals names (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="kinship.pca_+3A_ncp">ncp</code></td>
<td>
<p>The number of PC dimensions to be shown in the screeplot, and to provide
in the output data frame (default = <code>10</code>).</p>
</td></tr>
<tr><td><code id="kinship.pca_+3A_groups">groups</code></td>
<td>
<p>Specifies a vector of class factor that will be used to define different
colors for individuals in the PCA plot. It must be presented in the same order as the individuals
in the kinship matrix (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="kinship.pca_+3A_ellipses">ellipses</code></td>
<td>
<p>If <code>TRUE</code>, ellipses will will be drawn around each of the define levels in
<code>groups</code> (default = <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calls function <code>eigen()</code> to obtain eigenvalues and later generate the PCA and the
<code>factoextra</code> R package to extract and visualize results.
</p>


<h3>Value</h3>

<p>A list with the following four elements:
</p>

<ul>
<li><p><code>eigenvalues</code>: a data frame with the eigenvalues and its variances associated with each dimension
including only the first <code>ncp</code> dimensions.
</p>
</li>
<li><p><code>pca.scores</code>: a data frame with scores (rotated observations on the new components) including
only the first <code>ncp</code> dimensions.
</p>
</li>
<li><p><code>plot.pca</code>: a scatterplot with the first two-dimensions (PC1 and PC2) and their scores.
</p>
</li>
<li><p><code>plot.scree</code>: a barchart with the percentage of variances explained by the <code>ncp</code> dimensions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get G matrix.
G &lt;- G.matrix(M = geno.apple, method = "VanRaden")$G
G[1:5, 1:5]

# Perform the PCA.
G_pca &lt;- kinship.pca(K = G, ncp = 10)
ls(G_pca)
G_pca$eigenvalues
head(G_pca$pca.scores)
G_pca$plot.pca
G_pca$plot.scree

# PCA plot by family (17 groups).
grp &lt;- as.factor(pheno.apple$Family)
G_pca_grp &lt;- kinship.pca(K = G, groups = grp, label = FALSE, ellipses = FALSE)
G_pca_grp$plot.pca

</code></pre>

<hr>
<h2 id='Kinv.condition'>Assess condition of the inverse of <strong>K</strong></h2><span id='topic+Kinv.condition'></span>

<h3>Description</h3>

<p>Assess condition of the inverse of <strong>K</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kinv.condition(Kinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kinv.condition_+3A_kinv">Kinv</code></td>
<td>
<p>An inverse relationship matrix in full or sparse form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class character with the condition of the matrix:
well-conditioned or ill-conditioned.
</p>

<hr>
<h2 id='maf'>Estimates minor allele frequency (MAF)</h2><span id='topic+maf'></span>

<h3>Description</h3>

<p>Estimates minor allele frequency (MAF)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maf(M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maf_+3A_m">M</code></td>
<td>
<p>The additive <code class="reqn">n \times p</code> matrix coded with 0, 1, 2, or <code>NA</code>
(default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the MAF of each molecular marker
</p>

<hr>
<h2 id='match.G2A'>Check the genomic relationship matrix G against
the pedigree relationship matrix A or vice versa</h2><span id='topic+match.G2A'></span>

<h3>Description</h3>

<p>Assesses a given genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> against the
pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code>, or vice versa,
to determine the matched and mismatched individuals.
If requested, it provides the cleaned versions containing only the matched individuals
between both matrices. The user should provide the matrices <code class="reqn">\boldsymbol{G}</code>and
<code class="reqn">\boldsymbol{A}</code> in full form (<code class="reqn">ng \times ng</code> and <code class="reqn">na \times na</code>, respectively).
Individual names should be assigned to <code>rownames</code> and <code>colnames</code> for both matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.G2A(
  A = NULL,
  G = NULL,
  clean = TRUE,
  ord = TRUE,
  mism = FALSE,
  RMdiff = FALSE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.G2A_+3A_a">A</code></td>
<td>
<p>Input of the pedigree relationship matrix <code class="reqn">\boldsymbol{A}</code> in full form (<code class="reqn">na \times na</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_g">G</code></td>
<td>
<p>Input of the genomic relationship matrix <code class="reqn">\boldsymbol{G}</code> in full form (<code class="reqn">ng \times ng</code>) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_clean">clean</code></td>
<td>
<p>If <code>TRUE</code> generates new clean <code class="reqn">\boldsymbol{G}</code> and <code class="reqn">\boldsymbol{A}</code>
matrices in full form containing only matched individuals (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_ord">ord</code></td>
<td>
<p>If <code>TRUE</code> it will order by ascending order of individual names
both of the clean <code class="reqn">\boldsymbol{A}</code> and <code class="reqn">\boldsymbol{G}</code> matrices (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_mism">mism</code></td>
<td>
<p>If <code>TRUE</code> generates two data frames with mismatched individual names
from the <code class="reqn">\boldsymbol{G}</code> and <code class="reqn">\boldsymbol{A}</code> matrices (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_rmdiff">RMdiff</code></td>
<td>
<p>If <code>TRUE</code> it generates the matrix (in lower diagonal row-wise sparse form) of matched
observations from both the <code class="reqn">\boldsymbol{G}</code> and <code class="reqn">\boldsymbol{A}</code> matrices.
This matrix can be used to identify inconsistent values between matched matrices, but it can be very large
(default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="match.G2A_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>Gclean</code>: a matrix with the portion of <code class="reqn">\boldsymbol{G}</code> containing only matched individuals.
</p>
</li>
<li><p><code>Aclean</code>: a matrix with the portion of <code class="reqn">\boldsymbol{A}</code> containing only matched individuals.
</p>
</li>
<li><p><code>mismG</code>: a vector containing the names of the individuals from matrix <code class="reqn">\boldsymbol{G}</code> that are
missing in matrix <code class="reqn">\boldsymbol{A}</code>.
</p>
</li>
<li><p><code>mismA</code>: a vector containing the names of the individuals from matrix <code class="reqn">\boldsymbol{A}</code> that are
missing in matrix <code class="reqn">\boldsymbol{G}</code>.
</p>
</li>
<li><p><code>RM</code>: a data frame with the observations from both the <code class="reqn">\boldsymbol{G}</code> and <code class="reqn">\boldsymbol{A}</code>
matched matrices, together with their absolute relationship difference.
</p>
</li>
<li><p><code>plotG2A</code>: scatterplot with the pairing of matched pedigree- against genomic-based
relationship values. This graph might take a long to plot with large datasets.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Get A matrix.
A &lt;- AGHmatrix::Amatrix(data = ped.pine)
A[1:5,1:5]
dim(A)

# Read and filter genotypic data.
M.clean &lt;- qc.filtering(
 M = geno.pine655,
 maf = 0.05,
 marker.callrate = 0.2, ind.callrate = 0.20,
 na.string = "-9",
 plots = FALSE)$M.clean

# Get G matrix.
G &lt;- G.matrix(M = M.clean, method = "VanRaden", na.string = "-9")$G
G[1:5, 1:5]
dim(G)

# Match G2A.
check &lt;- match.G2A(
 A = A, G = G,
 clean = TRUE, ord = TRUE, mism = TRUE, RMdiff = TRUE)
ls(check)
dim(check$Aclean)
dim(check$Gclean)
check$Aclean[1:5, 1:5]
check$Gclean[1:5, 1:5]
head(check$mismG)
head(check$mismA)
check$plotG2A
head(check$RM)


</code></pre>

<hr>
<h2 id='match.kinship2pheno'>Check any kinship matrix K against phenotypic data</h2><span id='topic+match.kinship2pheno'></span>

<h3>Description</h3>

<p>Assesses a given kinship matrix against the provided phenotypic data to determine
if all genotypes are in the kinship matrix or not. It also reports which individuals
match or are missing from one set or another.
If requested, a reduced kinship matrix is generated that has only the matched individuals.
The input kinship matrix can be a pedigree-based relationship matrix <code class="reqn">\boldsymbol{A}</code>,
a genomic-based relationship matrix <code class="reqn">\boldsymbol{G}</code>, or a hybrid
relationship matrix <code class="reqn">\boldsymbol{H}</code>.
Individual names should be assigned to <code>rownames</code> and <code>colnames</code> of input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.kinship2pheno(
  K = NULL,
  pheno.data = NULL,
  indiv = NULL,
  clean = FALSE,
  ord = TRUE,
  mism = FALSE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.kinship2pheno_+3A_k">K</code></td>
<td>
<p>Input of a kinship matrix in full form (<code class="reqn">n \times n</code>) (default = <code>NULL</code>);</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_pheno.data">pheno.data</code></td>
<td>
<p>A data fame with the phenotypic data to assess (for <code>n</code> individuals)
(default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_indiv">indiv</code></td>
<td>
<p>The string for the column name for genotypes/individuals in the phenotypic data (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_clean">clean</code></td>
<td>
<p>If <code>TRUE</code>, generates a new clean kinship matrix containing only the matched
phenotyped individuals (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_ord">ord</code></td>
<td>
<p>If <code>TRUE</code>, it will order the kinship matrix as in the phenotypic data, which is
recommended for some downstream genomic analyses (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_mism">mism</code></td>
<td>
<p>If <code>TRUE</code>, it generates data frames with matched and mismatched individual's names
from the kinship matrix and the phenotypic data (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="match.kinship2pheno_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>mismatchesK</code>: a vector containing the names of the individuals from the provided kinship matrix
that <em>mismatch</em> with the phenotypic data.
</p>
</li>
<li><p><code>matchesK</code>: a vector containing the names of the individuals from the provided kinship matrix
that <em>match</em> with the phenotypic data.
</p>
</li>
<li><p><code>mismatchesP</code>: a vector containing the names of phenotyped individuals
that <em>mismatch</em> with those from the kinship matrix.
</p>
</li>
<li><p><code>matchesP</code>: a vector containing the names of phenotyped individuals
that <em>match</em> with those from the kinship matrix.
</p>
</li>
<li><p><code>Kclean</code>: a clean kinship matrix containing only the matched phenotyped individuals.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get G matrix.
G &lt;- G.matrix(M = geno.pine655, method = "VanRaden", na.string = "-9", sparseform = FALSE)$G
dim(G)

# Match G and the phenotype.
check &lt;-
 match.kinship2pheno(
  K = G, pheno.data = pheno.pine,
  indiv = "Genotype",
  clean = TRUE, mism = TRUE)
ls(check)
length(check$matchesK)
length(check$mismatchesK)
length(check$matchesP)
length(check$mismatchesP)
dim(check$Kclean)

## End(Not run)
</code></pre>

<hr>
<h2 id='ped.pine'>Pedigree data for loblolly pine dataset</h2><span id='topic+ped.pine'></span>

<h3>Description</h3>

<p>Individual pedigree data for a total of 2,034 records of loblolly pine
(<em>Pinus taeda</em> L.).
Missing parental information coded as 0.
Dataset obtained from supplementary material in Resende <em>et al.</em> (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped.pine
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Resende, M.F.R., Munoz, P. Resende, M.D.V., Garrick, D.J., Fernando, R.L., Davis, J.M.,
Jokela, E.J., Martin, T.A., Peter, G.F., and Kirst, M. 2012. Accuracy of genomic
selection methods in a standard data set of loblolly pine (<em>Pinus taeda</em> L.).
Genetics 190:1503-1510.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped.pine |&gt; head()

</code></pre>

<hr>
<h2 id='ped.salmon'>Pedigree data for Atlantic salmon dataset</h2><span id='topic+ped.salmon'></span>

<h3>Description</h3>

<p>Pedigree data of 1,481 Atlantic salmon samples.
Missing parental information coded as 0.
Dataset obtained from supplementary material in Robledo <em>et al.</em> (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped.salmon
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Robledo D., Matika O., Hamilton A., and Houston R.D. 2018.
Genome-wide association and genomic selection for resistance
to amoebic gill disease in Atlantic salmon.
G3 Genes, Genomes, Genetics 8:1195-1203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped.salmon |&gt; head()

</code></pre>

<hr>
<h2 id='pheno.apple'>Phenotypic data for apple dataset</h2><span id='topic+pheno.apple'></span>

<h3>Description</h3>

<p>Phenotypic data on 247 apple clones (<em>i.e.</em>, genotypes) evaluated for
several fruit quality traits at two New Zealand sites, Motueka (MOT) and Hawkes Bay (HB).
Dataset obtained from supplementary material in Kumar <em>et al.</em> (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.apple
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Kumar S., Molloy C., Muñoz P., Daetwyler H., Chagné D., and Volz R. 2015.
Genome-enabled estimates of additive and nonadditive genetic variances and prediction
of apple phenotypes across environments. G3 Genes, Genomes, Genetics 5:2711–2718.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pheno.apple |&gt; head()

</code></pre>

<hr>
<h2 id='pheno.pine'>Phenotypic data for loblolly pine dataset</h2><span id='topic+pheno.pine'></span>

<h3>Description</h3>

<p>Deregressed estimated breeding values (DEBV) for the trait diameter at breast height (DBH)
at 6 years of age from trees grown at site Nassau.
The dataset contains a total of 861 genotypes of loblolly pine
(<em>Pinus taeda</em> L.).
Dataset obtained from supplementary material in Resende <em>et al.</em> (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.pine
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Resende, M.F.R., Munoz, P. Resende, M.D.V., Garrick, D.J., Fernando, R.L., Davis, J.M.,
Jokela, E.J., Martin, T.A., Peter, G.F., and Kirst, M. 2012. Accuracy of genomic
selection methods in a standard data set of loblolly pine (<em>Pinus taeda</em> L.).
Genetics 190:1503-1510.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pheno.pine |&gt; head()

</code></pre>

<hr>
<h2 id='pheno.salmon'>Phenotypic data for Atlantic salmon dataset</h2><span id='topic+pheno.salmon'></span>

<h3>Description</h3>

<p>Phenotypic data on 1,481 Atlantic salmon individuals.
All fish were phenotyped for mean gill score (mean of the left
gill and right gill scores) and amoebic load (qPCR values using
<em>Neoparamoeba perurans</em> specific primers, amplified from one of the gills).
Dataset obtained from supplementary material in Robledo <em>et al.</em> (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno.salmon
</code></pre>


<h3>Format</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Robledo D., Matika O., Hamilton A., and Houston R.D. 2018.
Genome-wide association and genomic selection for resistance
to amoebic gill disease in Atlantic salmon.
G3 Genes, Genomes, Genetics 8:1195-1203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pheno.salmon |&gt; head()

</code></pre>

<hr>
<h2 id='qc.filtering'>Quality control filtering of molecular matrix M for downstream analyses</h2><span id='topic+qc.filtering'></span>

<h3>Description</h3>

<p>Reads molecular data in the format 0, 1, 2 and performs some basic quality control
filters and simple imputation.
Matrix provided is of the full form (<code class="reqn">n \times p</code>), with <code class="reqn">n</code> individuals and <code class="reqn">p</code> markers.
Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>,
respectively. Filtering can be done with the some of the following options by
specifying thresholds for:
missing values on individuals, missing values on markers, minor allele frequency,
inbreeding Fis value (of markers), and observed heterozygosity (of markers).
String used for identifying missing values can be specified.
If requested, missing values will be imputed based on the mean of each SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc.filtering(
  M = NULL,
  base = FALSE,
  na.string = NA,
  map = NULL,
  marker = NULL,
  chrom = NULL,
  pos = NULL,
  ref = NULL,
  marker.callrate = 1,
  ind.callrate = 1,
  maf = 0,
  heterozygosity = 1,
  Fis = 1,
  impute = FALSE,
  Mrecode = FALSE,
  plots = TRUE,
  digits = 2,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qc.filtering_+3A_m">M</code></td>
<td>
<p>A matrix with SNP data of full form (<code class="reqn">n \times p</code>), with <code class="reqn">n</code> individuals and <code class="reqn">p</code> markers
Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
Data in matrix is coded as 0, 1, 2 (integer or numeric) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_base">base</code></td>
<td>
<p>If <code>TRUE</code> matrix <code class="reqn">\boldsymbol{M}</code> is considered as bi-allele SNP data format (character)
and the SNPs are recoded to numerical values before performing the quality control filters
(default = <code>FALSE</code>) (currently deprecated).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_na.string">na.string</code></td>
<td>
<p>A character that will be interpreted as <code>NA</code> values (default = <code>"NA"</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_map">map</code></td>
<td>
<p>(Optional) A data frame with the map information with <code class="reqn">p</code> rows (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_marker">marker</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of markers. This is mandatory if <code>map</code> is provided (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_chrom">chrom</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of chromosomes (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_pos">pos</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of marker positions (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_ref">ref</code></td>
<td>
<p>A character indicating the name of the column in the map containing the reference allele for
recoding. If absent, then conversion will be based on the major allele (most frequent).
The marker information of a given individuals with two of the specified major alleles
in <code>ref</code> will be coded as 2 (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_marker.callrate">marker.callrate</code></td>
<td>
<p>A numerical value between 0 and 1 used to remove SNPs with a rate
of missing values equal or larger than this value (default = 1, <em>i.e.</em> no removing).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_ind.callrate">ind.callrate</code></td>
<td>
<p>A numerical value between 0 and 1 used to remove individuals with a
rate of missing values equal or larger than this value (default = 1, <em>i.e.</em> no removing).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_maf">maf</code></td>
<td>
<p>A numerical value between 0 and 1 used to remove SNPs with a Minor Allele Frequency
(MAF) below this value (default = 0, <em>i.e.</em> no removing).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_heterozygosity">heterozygosity</code></td>
<td>
<p>A numeric value indicating the maximum value of accepted observed heterozygosity (Ho)
(default = 1, <em>i.e.</em> no removing).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_fis">Fis</code></td>
<td>
<p>A numeric value indicating the maximum value of accepted inbreeding (Fis) following
the equation <code class="reqn">|1 - (Ho/He)|</code> (default = 1, <em>i.e.</em> no removing).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_impute">impute</code></td>
<td>
<p>If <code>TRUE</code> imputation of missing values is done using the mean of each SNP
(default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_mrecode">Mrecode</code></td>
<td>
<p>If <code>TRUE</code> it provides the recoded <code class="reqn">\boldsymbol{M}</code> matrix from the bi-allelic to numeric SNP
(default = <code>FALSE</code>) (currently deprecated).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_plots">plots</code></td>
<td>
<p>If <code>TRUE</code> generates graphical output of the quality control based on the
original input matrix (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_digits">digits</code></td>
<td>
<p>Set up the number of digits used to round the output matrix (default = 2).</p>
</td></tr>
<tr><td><code id="qc.filtering_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Warning</strong>: The arguments <code>base</code>, <code>ref</code>, and <code>Mrecode</code>
currently are deprecated and will
be removed on the next version of <code>ASRgenomics</code>.
Use function <a href="#topic+snp.recode">snp.recode</a> to recode the matrix prior to using <code>qc.filtering</code>.
</p>
<p>The filtering process is carried out as expressed in the following simplified pseudo-code
that consists on a loop repeated twice:
</p>
<p><strong>for i in 1 to 2</strong>
</p>
<p>    Filter markers based on call rate.
</p>
<p>    Filter individuals based on call rate.
</p>
<p>    Filter markers based on minor allele frequency.
</p>
<p>    Filter markers based on observed heterozygosity.
</p>
<p>    Filter markers based on inbreeding.
</p>
<p><strong>end for</strong>
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li><p><code>M.clean</code>: the cleaned <code class="reqn">\boldsymbol{M}</code> matrix after the quality control filters have been applied.
</p>
</li>
<li><p><code>map</code>: if provided, a cleaned <code>map</code> data frame after the quality control filters have been applied.
</p>
</li>
<li><p><code>plot.missing.ind</code>: a plot of missing data per individual (original marker matrix).
</p>
</li>
<li><p><code>plot.missing.SNP</code>: a plot of missing data per SNP (original marker matrix).
</p>
</li>
<li><p><code>plot.heteroz</code>: a plot of observed heterozygocity per SNP (original marker matrix).
</p>
</li>
<li><p><code>plot.Fis</code>: a plot of Fis per SNP (original marker matrix).
</p>
</li>
<li><p><code>plot.maf</code>: a plot of the minor allele frequency (original marker matrix).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Pine dataset from ASRgenomics (coded as 0,1,2 with missing as -9).

M.clean &lt;- qc.filtering(
 M = geno.pine926,
 maf = 0.05,
 marker.callrate = 0.9, ind.callrate = 0.9,
 heterozygosity = 0.9, Fis = 0.6,
 na.string = "-9")
ls(M.clean)
M.clean$M.clean[1:5, 1:5]
dim(M.clean$M.clean)
head(M.clean$map)
M.clean$plot.maf
M.clean$plot.missing.ind
M.clean$plot.missing.SNP
M.clean$plot.heteroz
M.clean$plot.Fis


# Example: Salmon dataset (coded as 0,1,2 with missing as NA).

M.clean &lt;- qc.filtering(
 M = geno.salmon,
 maf = 0.02,
 marker.callrate = 0.10, ind.callrate = 0.20,
 heterozygosity = 0.9, Fis = 0.4)
M.clean$M.clean[1:5, 1:5]
dim(M.clean$M.clean)
head(M.clean$map)
M.clean$plot.maf
M.clean$plot.missing.ind
M.clean$plot.missing.SNP
M.clean$plot.heteroz
M.clean$plot.Fis


</code></pre>

<hr>
<h2 id='silent_'>Function that silences everything (e.g., <code>cat()</code>, <code>print()</code>, <code>message()</code>, ...)</h2><span id='topic+silent_'></span>

<h3>Description</h3>

<p>Function that silences everything (e.g., <code>cat()</code>, <code>print()</code>, <code>message()</code>, ...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silent_(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silent__+3A_code">code</code></td>
<td>
<p>code to be silenced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='snp.pca'>Performs a Principal Component Analysis (PCA) based on a molecular matrix M</h2><span id='topic+snp.pca'></span>

<h3>Description</h3>

<p>Generates a PCA and summary statistics from a given molecular matrix
for population structure. Matrix
provided is of full form (<code class="reqn">n \times p</code>), with n individuals and p markers. Individual and
marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
SNP data is coded as 0, 1, 2 (integers or decimal numbers). Missing values are
not accepted and these need to be imputed (see function <code>qc.filtering()</code>
for implementing mean imputation). There is additional output such as plots and
other data frames
to be used on other downstream analyses (such as GWAS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snp.pca(M = NULL, label = FALSE, ncp = 10, groups = NULL, ellipses = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snp.pca_+3A_m">M</code></td>
<td>
<p>A matrix with SNP data of full form (<code class="reqn">n \times p</code>), with <code class="reqn">n</code>
individuals and <code class="reqn">p</code> markers (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pca_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code> then includes in output individuals names (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="snp.pca_+3A_ncp">ncp</code></td>
<td>
<p>The number of PC dimensions to be shown in the screeplot, and to provide
in the output data frame (default = <code>10</code>).</p>
</td></tr>
<tr><td><code id="snp.pca_+3A_groups">groups</code></td>
<td>
<p>Specifies a vector of class factor that will be used to define different
colors for individuals in the PCA plot. It must be presented in the same order as the individuals
in the molecular <code class="reqn">\boldsymbol{M}</code> matrix (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pca_+3A_ellipses">ellipses</code></td>
<td>
<p>If <code>TRUE</code>, ellipses will will be drawn around each of the define levels in
<code>groups</code> (default = <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calls function <code>prcomp()</code> to generate the PCA and the
<code>factoextra</code> R package to extract and visualize results.
Methodology uses normalized allele frequencies as proposed by Patterson <em>et al.</em> (2006).
</p>


<h3>Value</h3>

<p>A list with the following four elements:
</p>

<ul>
<li><p><code>eigenvalues</code>: a data frame with the eigenvalues and its variances associated with each dimension
including only the first <code>ncp</code> dimensions.
</p>
</li>
<li><p><code>pca.scores</code>: a data frame with scores (rotated observations on the new components) including
only the first <code>ncp</code> dimensions.
</p>
</li>
<li><p><code>plot.pca</code>: a scatterplot with the first two-dimensions (PC1 and PC2) and their scores.
</p>
</li>
<li><p><code>plot.scree</code>: a barchart with the percentage of variances explained by the <code>ncp</code> dimensions.
</p>
</li></ul>



<h3>References</h3>

<p>Patterson N., Price A.L., and Reich, D. 2006. Population structure and eigenanalysis.
PLoS Genet 2(12):e190. doi:10.1371/journal.pgen.0020190
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform the PCA.
SNP_pca &lt;- snp.pca(M = geno.apple, ncp = 10)
ls(SNP_pca)
SNP_pca$eigenvalues
head(SNP_pca$pca.scores)
SNP_pca$plot.pca
SNP_pca$plot.scree

# PCA plot by family (17 groups).
grp &lt;- as.factor(pheno.apple$Family)
SNP_pca_grp &lt;- snp.pca(M = geno.apple, groups = grp, label = FALSE)
SNP_pca_grp$plot.pca

</code></pre>

<hr>
<h2 id='snp.pruning'>Reduces the number of redundant markers on a molecular matrix M by pruning</h2><span id='topic+snp.pruning'></span>

<h3>Description</h3>

<p>For a given molecular dataset <code class="reqn">\boldsymbol{M}</code> (in the format 0, 1 and 2)
it produces a reduced molecular matrix by eliminating &quot;redundant&quot;
markers using pruning techniques. This function finds and drops some of the
SNPs in high linkage disequilibrium (LD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snp.pruning(
  M = NULL,
  map = NULL,
  marker = NULL,
  chrom = NULL,
  pos = NULL,
  method = c("correlation"),
  criteria = c("callrate", "maf"),
  pruning.thr = 0.95,
  by.chrom = FALSE,
  window.n = 50,
  overlap.n = 5,
  iterations = 10,
  seed = NULL,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snp.pruning_+3A_m">M</code></td>
<td>
<p>A matrix with marker data of full form (<code class="reqn">n \times p</code>), with <code class="reqn">n</code> individuals
and <code class="reqn">p</code> markers. Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
Data in matrix is coded as 0, 1, 2 (integer or numeric) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_map">map</code></td>
<td>
<p>(Optional) A data frame with the map information with <code class="reqn">p</code> rows.
If <code>NULL</code> a dummy map is generated considering a single chromosome and sequential positions
for markers. A <code>map</code> is mandatory if <code>by.chrom = TRUE</code>, where also option <code>chrom</code>
must also be non-null.</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_marker">marker</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code>
with the identification
of markers. This is mandatory if <code>map</code> is provided (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_chrom">chrom</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of chromosomes. This is mandatory if <code>map</code> is provided (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_pos">pos</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of marker positions (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_method">method</code></td>
<td>
<p>A character indicating the method (or algorithm) to be used as reference for
identifying redundant markers.
The only method currently available is based on correlations (default = <code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_criteria">criteria</code></td>
<td>
<p>A character indicating the criteria to choose which marker to drop
from a detected redundant pair.
Options are: <code>"callrate"</code> (the marker with fewer missing values will be kept) and
<code>"maf"</code> (the marker with higher minor allele frequency will be kept) (default = <code>"callrate"</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_pruning.thr">pruning.thr</code></td>
<td>
<p>A threshold value to identify redundant markers with Pearson's correlation larger than the
value provided (default = <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_by.chrom">by.chrom</code></td>
<td>
<p>If TRUE the pruning is performed independently by chromosome (default = <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_window.n">window.n</code></td>
<td>
<p>A numeric value with number of markers to consider in each
window to perform pruning (default = <code>50</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_overlap.n">overlap.n</code></td>
<td>
<p>A numeric value with number of markers to overlap between consecutive windows
(default = <code>5</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_iterations">iterations</code></td>
<td>
<p>An integer indicating the number of sequential times the pruning procedure
should be executed on remaining markers.
If no markers are dropped in a given iteration/run, the algorithm will stop (default = <code>10</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_seed">seed</code></td>
<td>
<p>An integer to be used as seed for reproducibility. In case the criteria has the
same values for a given pair of markers, one will be dropped at random (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.pruning_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pruning is recommended as redundancies can affect
the quality of matrices used for downstream analyses.
The algorithm used is based on the Pearson's correlation between markers
as a <em>proxy</em> for LD. In the event of a pairwise correlation higher
than the selected threshold markers will be eliminated as specified by: call rate,
minor allele frequency. In case of tie, one marker will be dropped at random.
</p>
<p>Filtering markers (<a href="#topic+qc.filtering">qc.filtering</a>) is of high relevance before pruning.
Poor quality markers (<em>e.g.</em>, monomorphic markers) may prevent correlations from being
calculated and may affect eliminations.
</p>


<h3>Value</h3>


<ul>
<li><p><code>Mpruned</code>: a matrix containing the pruned marker <em>M</em> matrix.
</p>
</li>
<li><p><code>map</code>: an data frame containing the pruned map.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Read and filter genotypic data.
M.clean &lt;- qc.filtering(
 M = geno.pine655,
 maf = 0.05,
 marker.callrate = 0.20, ind.callrate = 0.20,
 Fis = 1, heterozygosity = 0.98,
 na.string = "-9",
 plots = FALSE)$M.clean

# Prune correlations &gt; 0.9.
Mpr &lt;- snp.pruning(
 M = M.clean, pruning.thr = 0.90,
 by.chrom = FALSE, window.n = 40, overlap.n = 10)
head(Mpr$map)
Mpr$Mpruned[1:5, 1:5]

</code></pre>

<hr>
<h2 id='snp.recode'>Recodes the molecular matrix M for downstream analyses</h2><span id='topic+snp.recode'></span>

<h3>Description</h3>

<p>Reads molecular data in format of bi-allelic nucleotide bases (AA,
AG, GG, CC, etc.) and recodes them as 0, 1, 2 and <code>NA</code> to be used in other
downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snp.recode(
  M = NULL,
  map = NULL,
  marker = NULL,
  ref = NULL,
  alt = NULL,
  recoding = c("ATGCto012"),
  na.string = NA,
  rename.markers = TRUE,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snp.recode_+3A_m">M</code></td>
<td>
<p>A character matrix with SNP data of full form (<code class="reqn">n \times p</code>),
with <code class="reqn">n</code> individuals and <code class="reqn">p</code> markers
Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
Data in matrix is coded as AA, AG, GG, CC, etc (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_map">map</code></td>
<td>
<p>(Optional) A data frame with the map information with <code class="reqn">p</code> rows.
If <code>NULL</code> a dummy map is generated considering a single chromosome and sequential
positions for markers and includes reference allele and alternative allele (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_marker">marker</code></td>
<td>
<p>A character indicating the name of the column in data frame <code>map</code> with the identification
of markers. This is mandatory if <code>map</code> is provided (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_ref">ref</code></td>
<td>
<p>A character indicating the name of the column in the map containing the reference allele for
recoding. If absent, then conversion will be based on the major allele (most frequent).
The marker information of a given individual with two of the specified major alleles
in <code>ref</code> will be coded as 2. This is mandatory if <code>map</code> is provided (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_alt">alt</code></td>
<td>
<p>A character indicating the name of the column in the map containing the alternative allele for
recoding. If absent, then it will be inferred from the data. The marker information of a given individual
with two of the specified alleles in <code>alt</code> will be coded as 0 (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_recoding">recoding</code></td>
<td>
<p>A character indicating the recoding option to be performed.
Currently, only the nucleotide bases (AA, AG, ...) to allele count is available (<code>"ATGCto012"</code>)
(default = <code>"ATGCto012"</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_na.string">na.string</code></td>
<td>
<p>A character that is interpreted as missing values (default = <code>"NA"</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_rename.markers">rename.markers</code></td>
<td>
<p>If <code>TRUE</code> marker names (as provided in <strong>M</strong>) will be expanded
to store the reference and alternative alleles. For example, from AX-88234566 to AX-88234566_C_A.
In the event of unidentified alleles, 0 will be used (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="snp.recode_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following two elements:
</p>

<ul>
<li><p><code>Mrecode</code>: the molecular matrix <code class="reqn">\boldsymbol{M}</code> recoded to 0, 1, 2 and <code>NA</code>.
</p>
</li>
<li><p><code>mapr</code>: the data frame with the map information including reference allele and alternative allele.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create bi-allelic base data set.
Mnb &lt;- matrix(c(
  "A-",  NA, "GG",   "CC",   "AT",   "CC",   "AA",   "AA",
  "AAA", NA, "GG",   "AC",   "AT",   "CG",   "AA",   "AT",
  "AA",  NA, "GG",   "CC",   "AA",   "CG",   "AA",   "AA",
  "AA",  NA, "GG",   "AA",   "AA",    NA,    "AA",   "AA",
  "AT",  NA, "GG",   "AA",   "TT",   "CC",   "AT",   "TT",
  "AA",  NA,   NA,   "CC",    NA,    "GG",   "AA",   "AA",
  "AA",  NA,   NA,   "CC",   "TT",   "CC",   "AA",   "AT",
  "TT",  NA, "GG",   "AA",   "AA",   "CC",   "AA",   "AA"),
  ncol = 8, byrow = TRUE, dimnames = list(paste0("ind", 1:8),
                                       paste0("m", 1:8)))
Mnb

# Recode without map (but map is created).
Mr &lt;- snp.recode(M = Mnb, na.string = NA)
Mr$Mrecode
Mr$map

# Create map.
mapnb &lt;- data.frame(
 marker = paste0("m", 1:8),
 reference = c("A", "T", "G", "C", "T", "C", "A", "T"),
 alternative = c("T", "G", "T", "A", "A", "G", "T", "A")
 )
 mapnb

# Recode with map without alternative allele.
Mr &lt;- snp.recode(M = Mnb, map = mapnb, marker = "marker", ref = "reference",
           na.string = NA, rename.markers = TRUE)
Mr$Mrecode
Mr$map

# Notice that the alternative allele is in the map as a regular variable,
# but in the names it is inferred from data (which might be 0 (missing)).

# Recode with map with alternative allele.
Mr &lt;- snp.recode(M = Mnb, map = mapnb, marker = "marker",
 ref = "reference", alt = "alternative",
 na.string = NA, rename.markers = TRUE)
Mr$Mrecode
Mr$map # Now the alternative is also on the names.

# We can also recode without renaming the markers.
Mr &lt;- snp.recode(M = Mnb, map = mapnb, marker = "marker", ref = "reference",
           na.string = NA, rename.markers = FALSE)
Mr$Mrecode
Mr$map # Now the alternative is also on the names.

</code></pre>

<hr>
<h2 id='sparse2full'>Generates a full matrix form from a sparse form matrix</h2><span id='topic+sparse2full'></span>

<h3>Description</h3>

<p>Modifies the input sparse form matrix into its full form.
The sparse form has three columns per line, corresponding to the set:
<code>Row, Col, Value</code>, and is defined by a lower triangle row-wise
of the full matrix and is sorted as columns within row.
Individual names should be assigned as attributes: <code>attr(K, "rowNames")</code>
and <code>attr(K, "colNames")</code>. If these are not provided they are considered
as 1 to <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse2full(K = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse2full_+3A_k">K</code></td>
<td>
<p>A square matrix in sparse form (default = <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a function from ASReml-R 3 library by Butler <em>et al.</em> (2009).
</p>


<h3>Value</h3>

<p>A full square matrix where individual names are assigned to
<code>rownames</code> and <code>colnames</code>.
If attribute <code>INVERSE</code> is found this is also passed to the full matrix.
</p>


<h3>References</h3>

<p>Butler, D.G., Cullis, B.R., Gilmour, A.R., and Gogel, B.J. 2009.
ASReml-R reference manual. Version 3. The Department of Primary
Industries and Fisheries (DPI&amp;F).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get G matrix.
Gsp &lt;- G.matrix(M = geno.apple, method = "VanRaden", sparseform = TRUE)$G.sparse
head(Gsp)
head(attr(Gsp, "rowNames"))

# Transform into full matrix.
G &lt;- sparse2full(K = Gsp)
G[1:5, 1:5]

</code></pre>

<hr>
<h2 id='synthetic.cross'>Generates a molecular matrix M for hypothetical crosses based on the
genomic information of the parents</h2><span id='topic+synthetic.cross'></span>

<h3>Description</h3>

<p>This function generates (or imputes) a molecular matrix for offspring
from hypothetical crosses based on the genomic information from the parents.
This is a common procedure in species such as maize, where only the parents
(inbred lines) are genotyped, and this information is used to generate/impute
the genotypic data of each of the hybrid offspring.
This function can be also used for bulked DNA analyses, in order to obtain an
bulked molecular matrix for full-sib individuals were only parents are genotyped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic.cross(
  M = NULL,
  ped = NULL,
  indiv = NULL,
  mother = NULL,
  father = NULL,
  heterozygote.action = c("useNA", "exact", "fail", "expected"),
  na.action = c("useNA", "expected"),
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="synthetic.cross_+3A_m">M</code></td>
<td>
<p>A matrix with marker data of full form (<code class="reqn">n \times p</code>), with <code class="reqn">n</code> individuals
(mothers and fathers) and <code class="reqn">p</code> markers.
Individual and marker names are assigned to <code>rownames</code> and <code>colnames</code>, respectively.
Data in matrix is coded as 0, 1, 2 (integer or numeric) (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_ped">ped</code></td>
<td>
<p>A data frame with three columns containing only the pedigree of the hypothetical offspring.
(not pedigree of parents)
It should include the three columns for individual, mother and father (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_indiv">indiv</code></td>
<td>
<p>A character indicating the column in <code>ped</code> data frame containing the identification
of the offspring (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_mother">mother</code></td>
<td>
<p>A character indicating the column in <code>ped</code> data frame containing the identification
of the mother (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_father">father</code></td>
<td>
<p>A character indicating the column in <code>ped</code> data frame containing the identification
of the father (default = <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_heterozygote.action">heterozygote.action</code></td>
<td>
<p>Indicates the action to take when heterozygotes are found in a marker.
Options are: <code>"useNA"</code>, <code>"exact"</code>, <code>"fail"</code>, and <code>"expected"</code>.
See details for more information (default = <code>"useNA"</code>)</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_na.action">na.action</code></td>
<td>
<p>Indicates the action to take when missing values are found in a marker.
Options are: <code>"useNA"</code> and <code>"expected"</code>.
See details for more information (default = <code>"useNA"</code>).</p>
</td></tr>
<tr><td><code id="synthetic.cross_+3A_message">message</code></td>
<td>
<p>If <code>TRUE</code> diagnostic messages are printed on screen (default = <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For double-haploids, almost the totality of the markers (except for genotyping errors)
will be homozygotic reads. But in many other cases (including recombinant inbred lines)
there will be a proportion of heterozygotic reads. In these case, it is
very difficult to infer (impute) the exact genotype of a given offspring individual.
For example, if parents are 0 (AA) and 1 (AC) then offsprings will differ given this
Mendelian sampling. However, different strategies exist to determine the
expected value for that specific cross (if required), which are detailed below
using the option <code>heterozygote.action</code>.
</p>

<ul>
<li><p>If <code>heterozygote.action =  "useNA"</code>,
the generated offspring will have, for the heterozygote read, an <code>NA</code>,
and no markers are removed.
Hence, no attempt will be done to impute/estimate this value.

</p>
</li>
<li><p>If <code>heterozygote.action = "exact"</code>,
any marker containing one or more heterozygote reads will be removed.
Hence, inconsistent markers are fully removed from the <code class="reqn">\boldsymbol{M}</code> matrix.

</p>
</li>
<li><p>If <code>heterozygote.action = "fail"</code>,
function stops and informs of the presence of heterozygote reads.

</p>
</li>
<li><p>If <code>heterozygote.action = "expected"</code>,
then an algorithm is implemented, on the heterozygote read to determine its
expected value. For example, if parents are 0 and 1, then the expected value
(with equal probability) is 0.5. For a cross between two heterozygotes,
the expected value is: <code class="reqn">0(1/4) + 1(1/2) + 2(1/4) = 1</code>. And for a cross
between 1 and 2, the expected value is: <code class="reqn">1(1/2) + 2(1/2) = 1.5</code>
</p>
</li></ul>

<p>Missing value require special treatment, and an imputation strategy is detailed
below as indicated using the option <code>na.action</code>.
</p>

<ul>
<li><p>If <code>na.action = "useNA"</code>, if at least one of the parental reads
is missing values for a given marker then it will be assigned as missing for
the hypothetical cross. Hence, no attempt will be done to impute/estimate
this value.
</p>
</li>
<li><p>If <code>na.action = "expected"</code>, then an algorithm is implemented that
will impute the expected read of the cross if the genotype of <strong>one of
the parents is missing</strong> (<em>e.g.</em>, cross between 0 and NA). Calculations
are based on parental allelic frequencies <code class="reqn">p</code> and <code class="reqn">q</code> for the given
marker. The expressions for expected values are detailed below.
</p>

<ul>
<li><p>If the genotype of the non-missing parent read is 0.
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 0) x 0 (expected value of the offspring from a 0 x 0 cross: <code class="reqn">0(1/1)</code>) +
</p>
<p><code class="reqn">2pq</code> (probability that the missing parent is 1) x 0.5 (expected offspring from a 0 x 1 cross: <code class="reqn">0(1/2) + 1(1/2)</code>) +
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 2) x 1 (expected offspring from a 0 x 2 cross: <code class="reqn">1(1/1)</code>)
</p>
</li>
<li><p>If the genotype of the non-missing parent read is 1.
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 0) x 0.5 (offspring: <code class="reqn">0(1/2) + 1(1/2)</code>) +
</p>
<p><code class="reqn">2pq</code> (probability that the missing parent is 1) x 1 (offspring: <code class="reqn">0(1/4) + 1(1/2) + 2(1/4)</code>) +
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 2) x 1.5 (offspring: <code class="reqn">1(1/2) + 2(1/2)</code>)
</p>
</li>
<li><p>If the genotype of the non-missing parent read is 2.
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 0) x 1 (offspring: <code class="reqn">1(1/1)</code>) +
</p>
<p><code class="reqn">2pq</code> (probability that the missing parent is 1) x 1.5 (offspring: <code class="reqn">1(1/2) + 2(1/2)</code>) +
</p>
<p><code class="reqn">q^2</code> (probability that the missing parent is 2) x 2 (offspring: <code class="reqn">2(1/1)</code>)
</p>
</li></ul>

<p>Similarly, the calculation of the expected read of a cross when <strong>both parents are missing</strong> is
also based on population allelic frequencies for the given marker.
The expressions for expected values are detailed below.
</p>
<p>              <code class="reqn">q^2 \times q^2</code> (probability that both parents are 0) x 0 (expected value of the offspring from a 0 x 0 cross: 0(1/1)) +
</p>
<p>              <code class="reqn">2 \times (q^2 \times 2pq)</code> (probability that the first parent is 0 and the second is 1; this requires
the multiplication by 2 because it is also possible that the first parent is 1 and the second is 0)
x 0.5 (offspring: <code class="reqn">0(1/2) + 1(1/2)</code>) +
</p>
<p>              <code class="reqn">2 \times (q^2 \times p^2)</code> (this could be 0 x 2 or 2 x 0) x 1 (offspring: <code class="reqn">1(1/1)</code>) +
</p>
<p>              <code class="reqn">2pq \times 2pq</code> (both parents are 1) x 1 (offspring: <code class="reqn">0(1/4) + 1(1/2) + 2(1/4)</code>) +
</p>
<p>              <code class="reqn">2 \times (2pq \times q2)</code> (this could be 1 x 2 or 2 x 1) x 1.5 (offspring: <code class="reqn">1(1/2) + 2(1/2)</code>) +
</p>
<p>              <code class="reqn">p^2 \times p^2</code> (both parents are 2) x 2 (offspring: <code class="reqn">2(1/1)</code>)
</p>
<p>Note that the use of <code>na.action = "expected"</code> is recommended when
a large number of offspring will conform the hybrid cross (such as
with bulked DNA analyses) for family groups with reasonable number of individuals.
</p>
<p><strong>Warning</strong>. If <code>"expected"</code> is used for <code>heterozygote.action</code> or <code>na.action</code>,
direct transformation of the molecular data to other codings (<em>e.g.</em>,
dominance matrix coded as <code>c(0,1,0)</code>) is not recommended.
</p>
</li></ul>



<h3>Value</h3>

<p>A molecular matrix <code class="reqn">\boldsymbol{M}</code> containing the genotypes generated/imputed for the
hypothetical cross.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create dummy pedigree (using first 10 as parents).
ped &lt;- data.frame(
 male = rownames(geno.apple)[1:5],
 female = rownames(geno.apple)[6:10])
ped$offs &lt;- paste(ped$male, ped$female, sep = "_")
ped

# Select portion of M for parents.
Mp &lt;- geno.apple[c(ped$male, ped$female), 1:15]

# Get genotype of crosses removing markers with heterozygotes.
synthetic.cross(
 M = Mp, ped = ped,
 indiv = "offs", mother = "female", father = "male",
 heterozygote.action = "exact",
 na.action = "useNA")

# Request the synthetic cross to be NA in the respective samples.
synthetic.cross(
 M = Mp, ped = ped,
 indiv = "offs", mother = "female", father = "male",
 heterozygote.action = "useNA",
 na.action = "useNA")

# Get genotype of crosses and use expected values.
synthetic.cross(
 M = Mp, ped = ped,
 indiv = "offs", mother = "female", father = "male",
 heterozygote.action = "expected", na.action = "expected")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
