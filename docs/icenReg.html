<!DOCTYPE html><html><head><title>Help for package icenReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icenReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesControls'><p>Control parameters for ic_bayes</p></a></li>
<li><a href='#cs2ic'><p>Convert current status data into interval censored format</p></a></li>
<li><a href='#diag_baseline'><p>Compare parametric baseline distributions with semi-parametric baseline</p></a></li>
<li><a href='#diag_covar'><p>Evaluate covariate effect for regression model</p></a></li>
<li><a href='#getFitEsts'><p>Get Survival Curve Estimates from icenReg Model</p></a></li>
<li><a href='#getSCurves'><p>Get Estimated Survival Curves from Semi-parametric Model for Interval Censored Data</p></a></li>
<li><a href='#ic_bayes'><p>Bayesian Regression  Models for Interval Censored Data</p></a></li>
<li><a href='#ic_np'><p>Non-Parametric Estimator for Interval Censored Data</p></a></li>
<li><a href='#ic_par'><p>Parametric Regression  Models for Interval Censored Data</p></a></li>
<li><a href='#ic_sample'><p>Draw samples from an icenReg model</p></a></li>
<li><a href='#ic_sp'><p>Semi-Parametric models for Interval Censored Data</p></a></li>
<li><a href='#imputeCens'><p>Impute Interval Censored Data from icenReg Regression Model</p></a></li>
<li><a href='#ir_clustBoot'><p>Updates the covariance using cluster bootstrap</p></a></li>
<li><a href='#IR_diabetes'><p>Interval censored time from diabetes onset to diabetic nephronpathy</p></a></li>
<li><a href='#lines.icenReg_fit'><p>Plotting for icenReg Fits</p></a></li>
<li><a href='#makeCtrls_icsp'><p>Control Parameters for ic_sp</p></a></li>
<li><a href='#miceData'><p>Lung Tumor Interval Censored Data from Hoel and Walburg 1972</p></a></li>
<li><a href='#plot.icenReg_fit'><p>Plotting for icenReg Fits</p></a></li>
<li><a href='#predict.icenReg_fit'><p>Predictions from icenReg Regression Model</p></a></li>
<li><a href='#sampleSurv'><p>Samples fitted survival function</p></a></li>
<li><a href='#simCS_weib'><p>Simulate Current Status Data</p></a></li>
<li><a href='#simDC_weib'><p>Simulate Doubly Censored Data</p></a></li>
<li><a href='#simIC_cluster'><p>Simulates data with multiple observations per subject</p></a></li>
<li><a href='#simIC_weib'><p>Simulates interval censored data from regression model with a Weibull baseline</p></a></li>
<li><a href='#survCIs'><p>Confidence/Credible intervals for survival curves</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Models for Interval Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Clifford Anderson-Bergman</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, Rcpp, coda</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, methods, MLEcens</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clifford Anderson-Bergman &lt;pistacliffcho@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Regression models for interval censored data. Currently supports
    Cox-PH, proportional odds, and accelerated failure time models. Allows for
    semi and fully parametric models (parametric only for accelerated failure
    time models) and Bayesian parametric models. Includes functions for easy visual
    diagnostics of model fits and imputation of censored data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> [expanded from: LGPL (&ge; 2.0, &lt; 3)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 19:45:53 UTC; cliffordanderson-bergman</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesControls'>Control parameters for ic_bayes</h2><span id='topic+bayesControls'></span>

<h3>Description</h3>

<p>Control parameters for ic_bayes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesControls(
  samples = 4000,
  chains = 4,
  useMLE_start = TRUE,
  burnIn = 2000,
  samplesPerUpdate = 1000,
  initSD = 0.1,
  updateChol = TRUE,
  acceptRate = 0.25,
  thin = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesControls_+3A_samples">samples</code></td>
<td>
<p>Number of samples.</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_chains">chains</code></td>
<td>
<p>Number of MCMC chains to run</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_usemle_start">useMLE_start</code></td>
<td>
<p>Should MLE used for starting point?</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_burnin">burnIn</code></td>
<td>
<p>Number of samples discarded for burn in</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_samplesperupdate">samplesPerUpdate</code></td>
<td>
<p>Number of iterations between updates of proposal covariance matrix</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_initsd">initSD</code></td>
<td>
<p>If <code>useMLE_start == FALSE</code>, initial standard deviation used</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_updatechol">updateChol</code></td>
<td>
<p>Should cholesky decomposition be updated?</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_acceptrate">acceptRate</code></td>
<td>
<p>Target acceptance rate</p>
</td></tr>
<tr><td><code id="bayesControls_+3A_thin">thin</code></td>
<td>
<p>Amount of thinning</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Control parameters for the MH block updater used by <code>ic_bayes</code>.
</p>
<p>The <code>samples</code> argument dictates how many MCMC samples are taken. One 
sample will be saved every <code>thin</code> iterations, so there will a total of
<code>thin * samples + burnIn</code> iterations. The burn in samples are not saved at all. 
</p>
<p>Default behavior is to first calculate the MLE (not the MAP) estimate and use 
Hessian at the MLE to seed the proposal covariance matrix. After this, an updative 
covariance matrix is used. In cases with weakly informative likelihoods, 
using the MLE startpoint may lead to overly diffuse proposal or even undefined 
starting values. 
In this case, it suggested to use a cold start by setting <code>useMLE_start = F</code>
for the <code>controls</code> argument. In this case, the initial starting proposal
covariance matrix will be a diagonal matrix with <code>initSD</code> standard deviations.
</p>

<hr>
<h2 id='cs2ic'>Convert current status data into interval censored format</h2><span id='topic+cs2ic'></span>

<h3>Description</h3>

<p>Convert current status data into interval censored format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs2ic(time, eventOccurred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs2ic_+3A_time">time</code></td>
<td>
<p>Time of inspection</p>
</td></tr>
<tr><td><code id="cs2ic_+3A_eventoccurred">eventOccurred</code></td>
<td>
<p>Indicator if event has occurred. 0/FALSE implies event has not occurred by inspection time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts current status data to the interval censored format for 
usage in icenReg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simData &lt;- simCS_weib()
# Simulate current status data

head(cs2ic(simData$time, simData$event))
# Converting data to current status format

fit &lt;- ic_par(cs2ic(time, event) ~ x1 + x2, data = simData)
# Can be used directly in formula

</code></pre>

<hr>
<h2 id='diag_baseline'>Compare parametric baseline distributions with semi-parametric baseline</h2><span id='topic+diag_baseline'></span>

<h3>Description</h3>

<p>Creates plots to diagnosis fit of different choices of parametric baseline model. 
Plots the semi paramtric model against different choices of parametric models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_baseline(
  object,
  data,
  model = "ph",
  weights = NULL,
  dists = c("exponential", "weibull", "gamma", "lnorm", "loglogistic", "generalgamma"),
  cols = NULL,
  lgdLocation = "bottomleft",
  useMidCovars = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_baseline_+3A_object">object</code></td>
<td>
<p>Either a formula or a model fit with <code>ic_sp</code> or <code>ic_par</code></p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_data">data</code></td>
<td>
<p>Data. Unnecessary if <code>object</code> is a fit</p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_model">model</code></td>
<td>
<p>Type of model. Choices are <code>'ph'</code> or <code>'po'</code></p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_weights">weights</code></td>
<td>
<p>Case weights</p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_dists">dists</code></td>
<td>
<p>Parametric baseline fits</p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_cols">cols</code></td>
<td>
<p>Colors of baseline distributions</p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_lgdlocation">lgdLocation</code></td>
<td>
<p>Where legend will be placed. See <code>?legend</code> for more details</p>
</td></tr>
<tr><td><code id="diag_baseline_+3A_usemidcovars">useMidCovars</code></td>
<td>
<p>Should the distribution plotted be for covariates = mean values instead of 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>useMidCovars = T</code>, then the survival curves plotted are for fits with the mean covariate value, 
rather than 0. This is because often the baseline distribution (i.e. with all covariates = 0) will be 
far away from the majority of the data.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(IR_diabetes)
fit &lt;- ic_par(cbind(left, right) ~ gender, 
             data = IR_diabetes)

diag_baseline(fit, lgdLocation = "topright", 
             dist = c("exponential", "weibull", "loglogistic"))

</code></pre>

<hr>
<h2 id='diag_covar'>Evaluate covariate effect for regression model</h2><span id='topic+diag_covar'></span>

<h3>Description</h3>

<p>Creates plots to diagnosis fit of covariate effect in a regression model. 
For a given variable, stratifies the data across different levels of the variable and adjusts 
for all the other covariates included in <code>fit</code> and then plots a given function to help 
diagnosis where covariate effect follows model assumption 
(i.e. either proportional hazards or proportional odds). See <code>details</code> for descriptions of the plots. 
</p>
<p>If <code>varName</code> is not provided, will attempt to figure out how to divide up each covariate 
and plot all of them, although this may fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_covar(
  object,
  varName,
  data,
  model,
  weights = NULL,
  yType = "meanRemovedTransform",
  factorSplit = TRUE,
  numericCuts,
  col,
  xlab,
  ylab,
  main,
  lgdLocation = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_covar_+3A_object">object</code></td>
<td>
<p>Either a formula or a model fit with <code>ic_sp</code> or <code>ic_par</code></p>
</td></tr>
<tr><td><code id="diag_covar_+3A_varname">varName</code></td>
<td>
<p>Covariate to split data on. If left blank, will split on each covariate</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_data">data</code></td>
<td>
<p>Data. Unnecessary if <code>object</code> is a fit</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_model">model</code></td>
<td>
<p>Type of model. Choices are <code>'ph'</code> or <code>'po'</code></p>
</td></tr>
<tr><td><code id="diag_covar_+3A_weights">weights</code></td>
<td>
<p>Case weights</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_ytype">yType</code></td>
<td>
<p>Type of plot created. See details</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_factorsplit">factorSplit</code></td>
<td>
<p>Should covariate be split as a factor (i.e. by levels)</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_numericcuts">numericCuts</code></td>
<td>
<p>If <code>fractorSplit == FALSE</code>, cut points of covariate to stratify data on</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_col">col</code></td>
<td>
<p>Colors of each subgroup plot. If left blank, will auto pick colors</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_xlab">xlab</code></td>
<td>
<p>Label of x axis</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_ylab">ylab</code></td>
<td>
<p>Label of y axis</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_main">main</code></td>
<td>
<p>title of plot</p>
</td></tr>
<tr><td><code id="diag_covar_+3A_lgdlocation">lgdLocation</code></td>
<td>
<p>Where legend should be placed. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Cox-PH and proportional odds models, there exists a transformation of survival curves 
such that the difference should be constant for subjects with different covariates. 
In the case of the Cox-PH, this is the log(-log(S(t|X))) transformation, for the proporitonal odds, 
this is the log(S(t|X) / (1 - S(t|X))) transformation. 
</p>
<p>The function diag_covar allows the user to easily use these transformations to diagnosis 
whether such a model is appropriate. In particular, it takes a single covariate and 
stratifies the data on different levels of that covariate. 
Then, it fits the semi-parametric regression model 
(adjusting for all other covariates in the data set) on each of these 
stratum and extracts the baseline survival function. If the stratified covariate does 
follow the regression assumption, the difference between these transformed baseline 
survival functions should be approximately constant. 
</p>
<p>To help diagnosis, the default function plotted is the transformed survival functions, 
with the overall means subtracted off. If the assumption holds true, then the mean 
removed curves should be approximately parallel lines (with stochastic noise). 
Other choices of <code>yType</code>, the function to plot, are <code>"transform"</code>, 
which is the transformed functions without the means subtracted and <code>"survival"</code>, 
which is the baseline survival distribution is plotted for each strata. 
</p>
<p>Currently does not support stratifying covariates that are involved in an interaction term. 
</p>
<p>For variables that are factors, it will create a strata for each level of the covariate, up to 20 levels. 
If <code>factorSplit == FALSE</code>, will divide up numeric covariates according to the cuts provided to numericCuts. 
</p>
<p><code>lgdLocation</code> is an argument placed to <code>legend</code> dictating where the legend will be placed. 
If <code>lgdLocation = NULL</code>, will use standard placement given <code>yType</code>. See <code>?legend</code> for more details.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>

<hr>
<h2 id='getFitEsts'>Get Survival Curve Estimates from icenReg Model</h2><span id='topic+getFitEsts'></span>

<h3>Description</h3>

<p>Gets probability or quantile estimates from a <code>ic_sp</code>, <code>ic_par</code> or <code>ic_bayes</code> object. 
Provided estimates conditional on regression parameters found in <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFitEsts(fit, newdata = NULL, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFitEsts_+3A_fit">fit</code></td>
<td>
<p>model fit with <code>ic_par</code> or <code>ic_sp</code></p>
</td></tr>
<tr><td><code id="getFitEsts_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing covariates</p>
</td></tr>
<tr><td><code id="getFitEsts_+3A_p">p</code></td>
<td>
<p>Percentiles</p>
</td></tr>
<tr><td><code id="getFitEsts_+3A_q">q</code></td>
<td>
<p>Quantiles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>ic_sp</code> and <code>ic_par</code>, the MLE estimate is returned. For <code>ic_bayes</code>, 
the MAP estimate is returned. To compute the posterior means, use <code>sampleSurv</code>.
</p>
<p>If <code>newdata</code> is left blank, baseline estimates will be returned (i.e. all covariates = 0). 
If <code>p</code> is provided, will return the estimated Q(p | x), where Q is the inverse of F. If <code>q</code> is provided, 
will return the estimated F(q | x). If neither <code>p</code> nor <code>q</code> are provided, 
the estimated conditional median is returned.
</p>
<p>In the case of <code>ic_sp</code>, the MLE of the baseline survival is not necessarily unique, 
as probability mass is assigned to disjoint Turnbull intervals, but the likelihood function is 
indifferent to how probability mass is assigned within these intervals. In order to have a well 
defined estimate returned, we assume probability is assigned uniformly in these intervals. 
In otherwords, we return *a* maximum likelihood estimate, but don't attempt to characterize *all* maximum 
likelihood estimates with this function. If that is desired, all the information needed can be 
extracted with <code>getSCurves</code>.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simdata &lt;- simIC_weib(n = 500, b1 = .3, b2 = -.3,
inspections = 6, inspectLength = 1)
fit &lt;- ic_par(Surv(l, u, type = 'interval2') ~ x1 + x2,
             data = simdata)
new_data &lt;- data.frame(x1 = c(1,2), x2 = c(-1,1))
rownames(new_data) &lt;- c('grp1', 'grp2')

estQ &lt;- getFitEsts(fit, new_data, p = c(.25, .75))

estP &lt;- getFitEsts(fit, q = 400)
</code></pre>

<hr>
<h2 id='getSCurves'>Get Estimated Survival Curves from Semi-parametric Model for Interval Censored Data</h2><span id='topic+getSCurves'></span>

<h3>Description</h3>

<p>Extracts the estimated survival curve(s) from an ic_sp or ic_np model for interval censored data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSCurves(fit, newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSCurves_+3A_fit">fit</code></td>
<td>
<p>model fit with <code>ic_sp</code></p>
</td></tr>
<tr><td><code id="getSCurves_+3A_newdata">newdata</code></td>
<td>
<p>data.frame containing covariates for which the survival curve will be fit to. 
Rownames from <code>newdata</code> will be used to name survival curve. 
If left blank, baseline covariates will be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output will be a list with two elements: the first item will be <code>$Tbull_ints</code>, 
which is the Turnbull intervals. 
This is a k x 2 matrix, with the first column being the beginning of the 
Turnbull interval and the second being the end. 
This is necessary due to the <em>representational non-uniqueness</em>;
any survival curve that lies between the survival curves created from the
upper and lower limits of the Turnbull intervals will have equal likelihood. 
See example for proper display of this. The second item is <code>$S_curves</code>, 
or the estimated survival probability at each Turnbull interval for individuals 
with the covariates provided in <code>newdata</code>. Note that multiple rows may 
be provided to newdata, which will result in multiple S_curves.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>

<hr>
<h2 id='ic_bayes'>Bayesian Regression  Models for Interval Censored Data</h2><span id='topic+ic_bayes'></span>

<h3>Description</h3>

<p>Fits a Bayesian regression model for interval censored data. 
Can fit a proportional hazards, proportional odds or accelerated failure time model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_bayes(
  formula,
  data,
  logPriorFxn = function(x) return(0),
  model = "ph",
  dist = "weibull",
  weights = NULL,
  controls = bayesControls(),
  useMCores = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_bayes_+3A_formula">formula</code></td>
<td>
<p>Regression formula. Response must be a <code>Surv</code> object of type
<code>'interval2'</code> or <code>cbind</code>. See details.</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_data">data</code></td>
<td>
<p>Dataset</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_logpriorfxn">logPriorFxn</code></td>
<td>
<p>An R function that computes the log prior</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_model">model</code></td>
<td>
<p>What type of model to fit. Current choices are &quot;<code>ph</code>&quot; (proportional hazards), 
&quot;<code>po</code>&quot; (proportional odds) or &quot;<code>aft</code>&quot; (accelerated failure time)</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_dist">dist</code></td>
<td>
<p>What baseline parametric distribution to use. See details for current choices</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_weights">weights</code></td>
<td>
<p>vector of case weights. Not standardized; see details</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_controls">controls</code></td>
<td>
<p>Control parameters passed to samplers</p>
</td></tr>
<tr><td><code id="ic_bayes_+3A_usemcores">useMCores</code></td>
<td>
<p>Should multiple cores be used? Each core is used to run a single chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported distributions choices are &quot;exponential&quot;, &quot;weibull&quot;, &quot;gamma&quot;, 
&quot;lnorm&quot;, &quot;loglogistic&quot; and &quot;generalgamma&quot; (i.e. generalized gamma distribution). 
</p>
<p>The <code>logPriorFxn</code> should take in the a vector of values corresponding to <em>all</em>
the parameters of the model (baseline parameters first, regression parameters second) and returns the
log prior, calculated up to an additive constant. Default behavior is to use a flat prior. 
See examples for an example of using the log prior function.
</p>
<p>Sampling is done by a single MH block updater on all the parameters. 
See <code>?bayesControls</code> for more details. 
</p>
<p>Response variable should either be of the form <code>cbind(l, u)</code> or <code>Surv(l, u, type = 'interval2')</code>, 
where <code>l</code> and <code>u</code> are the lower and upper ends of the interval known to contain the event of interest. 
Uncensored data can be included by setting <code>l == u</code>, right censored data can be included by setting 
<code>u == Inf</code> or <code>u == NA</code> and left censored data can be included by setting <code>l == 0</code>.
</p>
<p>Does not allow uncensored data points at t = 0 (i.e. <code>l == u == 0</code>), as this will 
lead to a degenerate estimator for most parametric families. Unlike the current implementation 
of survival's <code>survreg</code>, does allow left side of intervals of positive length to 0 and 
right side to be <code>Inf</code>. 
</p>
<p>In regards to weights, they are not standardized. This means that if weight[i] = 2, 
this is the equivalent to having two observations with the same values as subject i. 
</p>
<p>For numeric stability, if abs(right - left) &lt; 10^-6, observation are considered 
uncensored rather than interval censored with an extremely small interval.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miceData)

flat_prior_model &lt;- ic_bayes(cbind(l, u) ~ grp, data = miceData)
# Default behavior is flat prior

priorFxn &lt;- function(pars){
 ans &lt;- 0
 ans &lt;- ans + dnorm(pars[1], log = TRUE)
 ans &lt;- ans + dnorm(pars[3], sd = 0.25, log = TRUE)
}
# Prior function puts N(0,1) prior on baseline shape parameter (first parameter)
# flat prior on baseline scale parameter (second parameter)
# and N(0,0.25) on regression parameter (third parameter)

inform_prior_fit &lt;- ic_bayes(cbind(l, u) ~ grp, 
                             data = miceData,
                             logPriorFxn = priorFxn)

summary(flat_prior_model)
summary(inform_prior_fit)
# Note tight prior on the regression pulls posterior mean toward 0

</code></pre>

<hr>
<h2 id='ic_np'>Non-Parametric Estimator for Interval Censored Data</h2><span id='topic+ic_np'></span>

<h3>Description</h3>

<p>Fits the non-parametric maximum likelihood estimator (NPMLE) for univariate interval censored data. 
This is a generalization of the Kaplan-Meier curves that allows for interval censoring. 
Also referred to as the Turnbull estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_np(
  formula = NULL,
  data,
  maxIter = 1000,
  tol = 10^-10,
  B = c(0, 1),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_np_+3A_formula">formula</code></td>
<td>
<p>Formula for stratification. If only one group, can be left blank and 
data must be entered as n x 2 matrix.</p>
</td></tr>
<tr><td><code id="ic_np_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or an n x 2 matrix. See details.</p>
</td></tr>
<tr><td><code id="ic_np_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum iterations</p>
</td></tr>
<tr><td><code id="ic_np_+3A_tol">tol</code></td>
<td>
<p>Numeric tolerance</p>
</td></tr>
<tr><td><code id="ic_np_+3A_b">B</code></td>
<td>
<p>Should intervals be open or closed? See details.</p>
</td></tr>
<tr><td><code id="ic_np_+3A_weights">weights</code></td>
<td>
<p>Weights (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> must be an n x 2 matrix or data.frame containing two columns of data representing 
left and right sides of the censoring interval, denoted L and R. This allows for left censored 
(L == 0), right censored (R == inf), uncensored (L == R) along with general interval censored observations. 
</p>
<p>The argument <code>B</code> determines whether the intervals should be open or closed, i.e. 
<code>B = c(0,1)</code> implies that the event occurs within the interval <code>(l,u]</code>. 
The exception is that if <code>l == u</code>, it is assumed that the event is uncensored, regardless of <code>B</code>.
</p>
<p>The NPMLE is fit using an efficient implementation of the EMICM algorithm.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>References</h3>

<p>Turnbull, B. (1976) The empricial distribution with arbitrarily grouped and censored data 
<em>Journal of the Royal Statistical Society B</em>, vol 38 p290-295
</p>
<p>Wellner, J. A., and Zhan, Y. (1997) A hybrid algorithm for computation of the maximum likelihood estimator 
from censored data, <em>Journal of the  American Statistical Association</em>, Vol 92, pp945-959
</p>
<p>Anderson-Bergman, C. (2016) An efficient implementation of the EMICM algorithm for the interval censored NPMLE
<em>Journal of Computational and Graphical Statistics</em>, <em>just accepted</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miceData)
fit &lt;- ic_np(cbind(l, u) ~ grp, data = miceData)
# Stratifies fits by group

plot(fit) 
</code></pre>

<hr>
<h2 id='ic_par'>Parametric Regression  Models for Interval Censored Data</h2><span id='topic+ic_par'></span>

<h3>Description</h3>

<p>Fits a parametric regression model for interval censored data. 
Can fita proportional hazards, proportional odds or accelerated failure time model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_par(formula, data, model = "ph", dist = "weibull", weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_par_+3A_formula">formula</code></td>
<td>
<p>Regression formula. Response must be a <code>Surv</code> object of type
<code>'interval2'</code> or <code>cbind</code>. See details.</p>
</td></tr>
<tr><td><code id="ic_par_+3A_data">data</code></td>
<td>
<p>Dataset</p>
</td></tr>
<tr><td><code id="ic_par_+3A_model">model</code></td>
<td>
<p>What type of model to fit. Current choices are &quot;<code>ph</code>&quot; (proportional hazards), 
&quot;<code>po</code>&quot; (proportional odds) or &quot;<code>aft</code>&quot; (accelerated failure time)</p>
</td></tr>
<tr><td><code id="ic_par_+3A_dist">dist</code></td>
<td>
<p>What baseline parametric distribution to use. See details for current choices</p>
</td></tr>
<tr><td><code id="ic_par_+3A_weights">weights</code></td>
<td>
<p>vector of case weights. Not standardized; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported distributions choices are &quot;exponential&quot;, &quot;weibull&quot;, &quot;gamma&quot;, 
&quot;lnorm&quot;, &quot;loglogistic&quot; and &quot;generalgamma&quot; (i.e. generalized gamma distribution). 
</p>
<p>Response variable should either be of the form <code>cbind(l, u)</code> or <code>Surv(l, u, type = 'interval2')</code>, 
where <code>l</code> and <code>u</code> are the lower and upper ends of the interval known to contain the event of interest. 
Uncensored data can be included by setting <code>l == u</code>, right censored data can be included by setting 
<code>u == Inf</code> or <code>u == NA</code> and left censored data can be included by setting <code>l == 0</code>.
</p>
<p>Does not allow uncensored data points at t = 0 (i.e. <code>l == u == 0</code>), as this will 
lead to a degenerate estimator for most parametric families. Unlike the current implementation 
of survival's <code>survreg</code>, does allow left side of intervals of positive length to 0 and 
right side to be <code>Inf</code>. 
</p>
<p>In regards to weights, they are not standardized. This means that if weight[i] = 2, 
this is the equivalent to having two observations with the same values as subject i. 
</p>
<p>For numeric stability, if abs(right - left) &lt; 10^-6, observation are considered 
uncensored rather than interval censored with an extremely small interval.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miceData)

logist_ph_fit &lt;- ic_par(Surv(l, u, type = 'interval2') ~ grp, 
                       data = miceData, dist = 'loglogistic')

logist_po_fit &lt;- ic_par(cbind(l, u) ~ grp, 
                        data = miceData, dist = 'loglogistic',
                       model = 'po')

summary(logist_ph_fit)
summary(logist_po_fit)
</code></pre>

<hr>
<h2 id='ic_sample'>Draw samples from an icenReg model</h2><span id='topic+ic_sample'></span>

<h3>Description</h3>

<p>Samples response values from an icenReg fit conditional on covariates, but not 
censoring intervals. To draw response samples conditional on covariates and 
restrained to intervals, see <code>imputeCens</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_sample(fit, newdata = NULL, sampleType = "fullSample", samples = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_sample_+3A_fit">fit</code></td>
<td>
<p>icenReg model fit</p>
</td></tr>
<tr><td><code id="ic_sample_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing covariates. If blank, will use data from model</p>
</td></tr>
<tr><td><code id="ic_sample_+3A_sampletype">sampleType</code></td>
<td>
<p>type of samples See details for options</p>
</td></tr>
<tr><td><code id="ic_sample_+3A_samples">samples</code></td>
<td>
<p>Number of samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a matrix of samples. Each row of the matrix corresponds with a subject with the 
covariates of the corresponding row of <code>newdata</code>. For each column of the matrix, 
the same sampled parameters are used to sample response variables. 
</p>
<p>If <code>newdata</code> is left blank, will provide estimates for original data set. 
</p>
<p>There are several options for how to sample. To get random samples without accounting
for error in the estimated parameters <code>imputeType ='fixedParSample'</code> takes a 
random sample of the response variable, conditional on the response interval, 
covariates and estimated parameters at the MLE. Alternatively, 
<code>imputeType = 'fullSample'</code> first takes a random sample of the coefficients,
(assuming asymptotic normality for the ic_par) and then takes a random sample 
of the response variable, conditional on the response interval, 
covariates, and the random sample of the coefficients.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simdata &lt;- simIC_weib(n = 500)

fit &lt;- ic_par(cbind(l, u) ~ x1 + x2,
              data = simdata)

newdata = data.frame(x1 = c(0, 1), x2 = c(1,1))

sampleResponses &lt;- ic_sample(fit, newdata = newdata, samples = 100)
</code></pre>

<hr>
<h2 id='ic_sp'>Semi-Parametric models for Interval Censored Data</h2><span id='topic+ic_sp'></span>

<h3>Description</h3>

<p>Fits a semi-parametric model for interval censored data. 
Can fit either a Cox-PH model or a proportional odds model.  
</p>
<p>The covariance matrix for the regression coefficients is estimated via bootstrapping. 
For large datasets, this can become slow so parallel processing can be used to take advantage of multiple cores via the <code>foreach</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_sp(
  formula,
  data,
  model = "ph",
  weights = NULL,
  bs_samples = 0,
  useMCores = F,
  B = c(0, 1),
  controls = makeCtrls_icsp()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_sp_+3A_formula">formula</code></td>
<td>
<p>regression formula. Response must be a <code>Surv</code> object of type <code>'interval2'</code>or <code>cbind</code>. See details.</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_model">model</code></td>
<td>
<p>What type of model to fit. Current choices are &quot;<code>ph</code>&quot; (Cox PH) or &quot;<code>po</code>&quot; (proportional odds)</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_weights">weights</code></td>
<td>
<p>Vector of case weights. Not standardized; see details</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_bs_samples">bs_samples</code></td>
<td>
<p>Number of bootstrap samples used for estimation of standard errors</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_usemcores">useMCores</code></td>
<td>
<p>Should multiple cores be used for bootstrap sample? Does not register cluster (see example)</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_b">B</code></td>
<td>
<p>Should intervals be open or closed? See details.</p>
</td></tr>
<tr><td><code id="ic_sp_+3A_controls">controls</code></td>
<td>
<p>Advanced control options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Response variable should either be of the form <code>cbind(l, u)</code> or 
<code>Surv(l, u, type = 'interval2')</code>, where <code>l</code> and <code>u</code> are the lower 
and upper ends of the interval known to contain the event of interest. 
Uncensored data can be included by setting <code>l == u</code>, right censored data 
can be included by setting <code>u == Inf</code> or <code>u == NA</code> and left censored 
data can be included by setting <code>l == 0</code>.
</p>
<p>The argument <code>B</code> determines whether the intervals should be open or closed, 
i.e. <code>B = c(0,1)</code> implies that the event occurs within the interval <code>(l,u]</code>.
The exception is that if <code>l == u</code>, it is assumed that the event is uncensored, 
regardless of <code>B</code>. 
</p>
<p>In regards to weights, they are not standardized. 
This means that if weight[i] = 2, this is the equivalent to having two 
observations with the same values as subject i. 
</p>
<p>The algorithm used is inspired by the extended ICM algorithm from Wei Pan 1999.
However, it uses a conditional Newton Raphson step (for the regression parameters) 
and an ICM step (for the baseline survival parameters), rather than one single
ICM step (for both sets). In addition, a gradient ascent can also be used
to update the baseline parameters. This step is necessary if the
data contains many uncensored observations, very similar to how 
the EM algorithm greatly accelerates the ICM algorithm for the NPMLE 
(gradient ascent is used rather than the EM, as the M step is not 
in closed form for semi-parametric models). 
</p>
<p>Earlier versions of icenReg used an active set algorithm, which was not
as fast for large datasets.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>References</h3>

<p>Pan, W., (1999), Extending the iterative convex minorant algorithm to the Cox model for interval-censored data, <em>Journal of Computational and Graphical Statistics</em>, Vol 8(1), pp109-120
</p>
<p>Wellner, J. A., and Zhan, Y. (1997) A hybrid algorithm for computation of the maximum likelihood estimator from censored data, <em>Journal of the  American Statistical Association</em>, Vol 92, pp945-959
</p>
<p>Anderson-Bergman, C. (preprint) Revisiting the iterative convex minorant algorithm for interval censored survival regression models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

sim_data &lt;- simIC_weib(n = 100, inspections = 5, inspectLength = 1)
ph_fit &lt;- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, 
                data = sim_data)	
# Default fits a Cox-PH model

summary(ph_fit)		
# Regression estimates close to true 0.5 and -0.5 values


new_data &lt;- data.frame(x1 = c(0,1), x2 = c(1, 1) )
rownames(new_data) &lt;- c('group 1', 'group 2')
plot(ph_fit, new_data)
# plotting the estimated survival curves

po_fit &lt;- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2, 
                data = sim_data, model = 'po')
# fits a proportional odds model

summary(po_fit)

# Not run: how to set up multiple cores
# library(doParallel)
# myCluster &lt;- makeCluster(2) 
# registerDoParallel(myCluster)
# fit &lt;- ic_sp(Surv(l, u, type = 'interval2') ~ x1 + x2,
#              data = sim_data, useMCores = TRUE
#              bs_samples = 500)
# stopCluster(myCluster)


</code></pre>

<hr>
<h2 id='imputeCens'>Impute Interval Censored Data from icenReg Regression Model</h2><span id='topic+imputeCens'></span>

<h3>Description</h3>

<p>Imputes censored responses from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeCens(fit, newdata = NULL, imputeType = "fullSample", samples = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeCens_+3A_fit">fit</code></td>
<td>
<p>icenReg model fit</p>
</td></tr>
<tr><td><code id="imputeCens_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing covariates and censored intervals. If blank, will use data from model</p>
</td></tr>
<tr><td><code id="imputeCens_+3A_imputetype">imputeType</code></td>
<td>
<p>type of imputation. See details for options</p>
</td></tr>
<tr><td><code id="imputeCens_+3A_samples">samples</code></td>
<td>
<p>Number of imputations (ignored if <code>imputeType = "median"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is left blank, will provide estimates for original data set. 
</p>
<p>There are several options for how to impute. <code>imputeType = 'median'</code> 
imputes the median time, conditional on the response interval, covariates and 
regression parameters at the MLE. To get random imputations without accounting
for error in the estimated parameters <code>imputeType ='fixedParSample'</code> takes a 
random sample of the response variable, conditional on the response interval, 
covariates and estimated parameters at the MLE. Finally, 
<code>imputeType = 'fullSample'</code> first takes a random sample of the coefficients,
(assuming asymptotic normality) and then takes a random sample 
of the response variable, conditional on the response interval, 
covariates, and the random sample of the coefficients.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simdata &lt;- simIC_weib(n = 500)

fit &lt;- ic_par(cbind(l, u) ~ x1 + x2,
              data = simdata)

imputedValues &lt;- imputeCens(fit)
</code></pre>

<hr>
<h2 id='ir_clustBoot'>Updates the covariance using cluster bootstrap</h2><span id='topic+ir_clustBoot'></span>

<h3>Description</h3>

<p>Adjusts error estimates for repeated measures data by use of the cluster bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_clustBoot(fit, ID, bs_samples = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_clustBoot_+3A_fit">fit</code></td>
<td>
<p>Either an ic_par or ic_sp model</p>
</td></tr>
<tr><td><code id="ir_clustBoot_+3A_id">ID</code></td>
<td>
<p>Subject identifier</p>
</td></tr>
<tr><td><code id="ir_clustBoot_+3A_bs_samples">bs_samples</code></td>
<td>
<p>Number of bootstrap samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard models in icenReg assume independence between each observation. 
This assumption is broken if we can have multiple observations from a single subject, 
which can lead to an underestimation of the standard errors. <code>ir_clustBoot</code>
addresses this by using a cluster bootstrap to fix up the standard errors. 
</p>
<p>Note that this requires refitting the model <code>bs_samples</code>, which means this can be 
fairly time consuming.
</p>


<h3>References</h3>

<p>Sherman, Michael, and Saskia le Cessie. 
&quot;A comparison between bootstrap methods and 
generalized estimating equations for correlated 
outcomes in generalized linear models.&quot; 
Communications in Statistics-Simulation and Computation 26.3 (1997): 901-925.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulating repeated measures data 
simdata = simIC_cluster(nIDs = 10, nPerID = 4)

# Fitting with basic model
fit = ic_par(cbind(l,u) ~ x1 + x2, data = simdata)
fit

# Updating covariance
ir_clustBoot(fit, ID = simdata$ID, bs_samples = 10)
# (Low number of bootstrap samples used for quick testing by CRAN, 
# never use this few!!)

# Note that the SE's have changed from above
fit
</code></pre>

<hr>
<h2 id='IR_diabetes'>Interval censored time from diabetes onset to diabetic nephronpathy</h2><span id='topic+IR_diabetes'></span>

<h3>Description</h3>

<p>Data set contains interval censored survival time for time from onset of
diabetes to to diabetic nephronpathy. Identical to the <code>diabetes</code>
dataset found in the package <code>glrt</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>left</code></dt><dd><p>left side of observation interval</p>
</dd>
<dt><code>right</code></dt><dd><p>right side of observation interval</p>
</dd>
<dt><code>gender</code></dt><dd><p>gender of subject</p>
</dd>
</dl>


<h3>References</h3>

<p>Borch-Johnsens, K, Andersen, P and Decker, T (1985).
&quot;The effect of proteinuria on relative mortality in Type I (insulin-dependent) diabetes mellitus.&quot;
Diabetologia, 28, 590-596.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(IR_diabetes)
 fit &lt;- ic_par(cbind(left, right) ~ gender, 
               data = IR_diabetes,
               model = "po",
               dist = "loglogistic")
</code></pre>

<hr>
<h2 id='lines.icenReg_fit'>Plotting for icenReg Fits</h2><span id='topic+lines.icenReg_fit'></span>

<h3>Description</h3>

<p>Plotting for icenReg Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icenReg_fit'
lines(
  x,
  y,
  newdata = NULL,
  fun = "surv",
  cis = F,
  ci_level = 0.9,
  survRange = c(0.025, 1),
  evalPoints = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.icenReg_fit_+3A_x">x</code></td>
<td>
<p>icenReg fit</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_y">y</code></td>
<td>
<p>new data.frame</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_newdata">newdata</code></td>
<td>
<p>new data.frame (ignored if <code>y</code> is included)</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_fun">fun</code></td>
<td>
<p>Function to be plotted. Options include <code>"surv"</code> or <code>"cdf"</code></p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_cis">cis</code></td>
<td>
<p>Should confidence/credible interval be plotted?</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence/credible interval</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_survrange">survRange</code></td>
<td>
<p>Range of survival curve to be plotted</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_evalpoints">evalPoints</code></td>
<td>
<p>Number of evaluations of survival curve to be plotted.</p>
</td></tr>
<tr><td><code id="lines.icenReg_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the base <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots survival function from either an <code>ic_np, ic_sp, ic_par</code> or <code>ic_bayes</code>
object. If <code>newdata</code> is <code>NULL</code>, the baseline distribution is plotted. Otherwise,
<code>newdata</code> should be a <code>data.frame</code> with each row containing a set 
covariates for which the fit will be plotted. If multiple rows are included, 
the lines will be colored and a legend will be created using the rownames of <code>newdata</code>.
</p>
<p>For <code>ic_np</code> and <code>ic_sp</code>, the MLE is plotted with no intervals (at the time
of writing this, there is no formula for standard errors of baseline distributions 
for these methods). 
</p>
<p>For <code>ic_par</code> and <code>ic_bayes</code>, the output plotted is directly extracted from
<code>survCIs</code>.
</p>
<p>If the argument <code>col</code> is provided, it will be used to color each 
survival function in order of the rows provided in <code>newdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Fitting mice data set
 data(miceData)
 miceFit &lt;- ic_par(cbind(l, u) ~ grp, data = miceData) 
 
 # Creating covariates we want plotted
 newData &lt;- data.frame(grp = c("ce", "ge"))
 # Naming rows for legend
 rownames(newData) &lt;- c("Conventional", "Germ-Free")
 
 plot(miceFit, newdata = newData, 
      col = c('blue', 'orange'))
</code></pre>

<hr>
<h2 id='makeCtrls_icsp'>Control Parameters for ic_sp</h2><span id='topic+makeCtrls_icsp'></span>

<h3>Description</h3>

<p>Control Parameters for ic_sp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCtrls_icsp(useGA = T, maxIter = 10000, baseUpdates = 5, regStart = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCtrls_icsp_+3A_usega">useGA</code></td>
<td>
<p>Should constrained gradient ascent step be used?</p>
</td></tr>
<tr><td><code id="makeCtrls_icsp_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum iterations</p>
</td></tr>
<tr><td><code id="makeCtrls_icsp_+3A_baseupdates">baseUpdates</code></td>
<td>
<p>number of baseline updates (ICM + GA) per iteration</p>
</td></tr>
<tr><td><code id="makeCtrls_icsp_+3A_regstart">regStart</code></td>
<td>
<p>Initial values for regression parameters
</p>
<p>@description
Creates the control options for the <code>ic_sp</code> function. 
Defaults not intended to be changed for use in standard analyses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constrained gradient step, actived by <code>useGA = T</code>, 
is a step that was added to improve the convergence in a special case. 
The option to turn it off is only in place to help demonstrate it's utility. 
</p>
<p><code>regStart</code> also for seeding of initial value of regression parameters. Intended for use in &ldquo;warm start&quot; for bootstrap samples 
and providing fixed regression parameters when calculating fit in qq-plots.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>

<hr>
<h2 id='miceData'>Lung Tumor Interval Censored Data from Hoel and Walburg 1972</h2><span id='topic+miceData'></span>

<h3>Description</h3>

<p>RFM mice were sacrificed and examined for lung tumors. This resulted in current status interval censored data: 
if the tumor was present, this implied left censoring and if no tumor was present this implied right censoring. 
Mice were placed in two different groups: conventional environment or germ free environment.
</p>


<h3>Fields</h3>


<dl>
<dt><code>l</code></dt><dd><p>left side of observation interval</p>
</dd>
<dt><code>u</code></dt><dd><p>right side of observation interval</p>
</dd>
<dt><code>grp</code></dt><dd><p>Group for mouse. Either ce (conventional environment) or ge (grem-free environment)</p>
</dd>
</dl>


<h3>References</h3>

<p>Hoel D. and Walburg, H.,(1972), Statistical analysis of survival experiments, <em>The Annals of Statistics</em>, 
18, 1259-1294
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(miceData)
 
coxph_fit &lt;- ic_sp(Surv(l, u, type = 'interval2') ~ grp, 
                    bs_samples = 50,	
                    data = miceData)
 
#In practice, more bootstrap samples should be used for inference
#Keeping it quick for CRAN testing purposes 
 
summary(coxph_fit)
</code></pre>

<hr>
<h2 id='plot.icenReg_fit'>Plotting for icenReg Fits</h2><span id='topic+plot.icenReg_fit'></span>

<h3>Description</h3>

<p>Plotting for icenReg Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icenReg_fit'
plot(
  x,
  y,
  newdata = NULL,
  fun = "surv",
  plot_legend = T,
  cis = T,
  ci_level = 0.9,
  survRange = c(0.025, 1),
  evalPoints = 200,
  lgdLocation = lgd_default(fun),
  xlab = "time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.icenReg_fit_+3A_x">x</code></td>
<td>
<p>icenReg fit</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_y">y</code></td>
<td>
<p>new data.frame</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_newdata">newdata</code></td>
<td>
<p>new data.frame (ignored if <code>y</code> is included)</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_fun">fun</code></td>
<td>
<p>Function to be plotted. Options include <code>"surv"</code> or <code>"cdf"</code></p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Should legend be plotted?</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_cis">cis</code></td>
<td>
<p>Should confidence/credible interval be plotted?</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence/credible interval</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_survrange">survRange</code></td>
<td>
<p>Range of survival curve to be plotted</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_evalpoints">evalPoints</code></td>
<td>
<p>Number of evaluations of survival curve to be plotted.</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_lgdlocation">lgdLocation</code></td>
<td>
<p>Location of legend; see <code>?legend</code> for options</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis</p>
</td></tr>
<tr><td><code id="plot.icenReg_fit_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the base <code>plot</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots survival function from either an <code>ic_np, ic_sp, ic_par</code> or <code>ic_bayes</code>
object. If <code>newdata</code> is <code>NULL</code>, the baseline distribution is plotted. Otherwise,
<code>newdata</code> should be a <code>data.frame</code> with each row containing a set 
covariates for which the fit will be plotted. If multiple rows are included, 
the lines will be colored and a legend will be created using the rownames of <code>newdata</code>.
</p>
<p>For <code>ic_np</code> and <code>ic_sp</code>, the MLE is plotted with no intervals (at the time
of writing this, there is no formula for standard errors of baseline distributions 
for these methods). 
</p>
<p>For <code>ic_par</code> and <code>ic_bayes</code>, the output plotted is directly extracted from
<code>survCIs</code>.
</p>
<p>If the argument <code>col</code> is provided, it will be used to color each 
survival function in order of the rows provided in <code>newdata</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Fitting mice data set
 data(miceData)
 miceFit &lt;- ic_par(cbind(l, u) ~ grp, data = miceData) 
 
 # Creating covariates we want plotted
 newData &lt;- data.frame(grp = c("ce", "ge"))
 # Naming rows for legend
 rownames(newData) &lt;- c("Conventional", "Germ-Free")
 
 plot(miceFit, newdata = newData, 
      col = c('blue', 'orange'))
</code></pre>

<hr>
<h2 id='predict.icenReg_fit'>Predictions from icenReg Regression Model</h2><span id='topic+predict.icenReg_fit'></span>

<h3>Description</h3>

<p>Gets various estimates from an <code>ic_np</code>, <code>ic_sp</code> or <code>ic_par</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'icenReg_fit'
predict(object, type = "response", newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.icenReg_fit_+3A_object">object</code></td>
<td>
<p>Model fit with <code>ic_par</code> or <code>ic_sp</code></p>
</td></tr>
<tr><td><code id="predict.icenReg_fit_+3A_type">type</code></td>
<td>
<p>type of prediction. Options include <code>"lp", "response"</code></p>
</td></tr>
<tr><td><code id="predict.icenReg_fit_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing covariates</p>
</td></tr>
<tr><td><code id="predict.icenReg_fit_+3A_...">...</code></td>
<td>
<p>other arguments (will be ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is left blank, will provide estimates for original data set. 
</p>
<p>For the argument <code>type</code>, there are two options. <code>"lp"</code> provides the 
linear predictor for each subject (i.e. in a proportional hazards model, 
this is the log-hazards ratio, in proportional odds, the log proporitonal odds), 
<code>"response"</code> provides the median response value for each subject, 
*conditional on that subject's covariates, but ignoring their actual response interval*. 
Use <code>imputeCens</code> to impute the censored values.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simdata &lt;- simIC_weib(n = 500, b1 = .3, b2 = -.3,
                      inspections = 6,
                      inspectLength = 1)

fit &lt;- ic_par(cbind(l, u) ~ x1 + x2,
              data = simdata)

imputedValues &lt;- predict(fit)
</code></pre>

<hr>
<h2 id='sampleSurv'>Samples fitted survival function</h2><span id='topic+sampleSurv'></span>

<h3>Description</h3>

<p>Samples fitted survival function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSurv(fit, newdata = NULL, p = NULL, q = NULL, samples = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleSurv_+3A_fit">fit</code></td>
<td>
<p>Either an ic_bayes or ic_par fit</p>
</td></tr>
<tr><td><code id="sampleSurv_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with a single row of covariates</p>
</td></tr>
<tr><td><code id="sampleSurv_+3A_p">p</code></td>
<td>
<p>A set of survival probabilities to sample corresponding time for</p>
</td></tr>
<tr><td><code id="sampleSurv_+3A_q">q</code></td>
<td>
<p>A set of times to sample corresponding cumulative probability for</p>
</td></tr>
<tr><td><code id="sampleSurv_+3A_samples">samples</code></td>
<td>
<p>Number of samples to draw</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Bayesian models, draws samples from the survival distribution with a given set of covariates.
Does this by first drawing a set of parameters (both regression and baseline) from <code>fit$samples</code> and then computing the quantiles of 
the distribution (if <code>p</code> is provided) or the CDF at <code>q</code>. 
</p>
<p>If a <code>ic_par</code> model is provided, the procedure is the same, but the sampled parameters are drawn using
the normal approximation.
</p>
<p>Not compatible with <code>ic_np</code> or <code>ic_sp</code> objects.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IR_diabetes")
fit &lt;- ic_par(cbind(left, right) ~ gender, data = IR_diabetes)

newdata &lt;- data.frame(gender = "male")
time_samps &lt;- sampleSurv(fit, newdata, 
                         p = c(0.5, .9), 
                         samples = 100)
# 100 samples of the median and 90th percentile for males                        

prob_samps &lt;- sampleSurv(fit, newdata, 
                         q = c(10, 20),
                         samples = 100)
# 100 samples of the cumulative probability at t = 10 and 20 for males                        
</code></pre>

<hr>
<h2 id='simCS_weib'>Simulate Current Status Data</h2><span id='topic+simCS_weib'></span>

<h3>Description</h3>

<p>Simulates current status data from a survival regression model 
with a Weibull baseline distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCS_weib(n = 100, b1 = 0.5, b2 = -0.5, model = "ph", shape = 2, scale = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simCS_weib_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="simCS_weib_+3A_b1">b1</code></td>
<td>
<p>Regression coefficient 1</p>
</td></tr>
<tr><td><code id="simCS_weib_+3A_b2">b2</code></td>
<td>
<p>Regression coefficient 2</p>
</td></tr>
<tr><td><code id="simCS_weib_+3A_model">model</code></td>
<td>
<p>Regression model to use. Choices are <code>"ph"</code>, <code>"po"</code> or <code>"aft"</code></p>
</td></tr>
<tr><td><code id="simCS_weib_+3A_shape">shape</code></td>
<td>
<p>Baseline shape parameter</p>
</td></tr>
<tr><td><code id="simCS_weib_+3A_scale">scale</code></td>
<td>
<p>Baseline scale parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact event times are simulated according to the given survival regression model.
Two covariates are used; <code>x1 = rnorm(n), x2 = 1 - 2 * rbinom(n, 1, .5)</code>. After
event times are simulated, current status inspection times are simulated following the 
exact same conditional distribution as event time (so each event time necessarily has 
probability 0.5 of being right censored). 
</p>
<p>Returns data in current status format, i.e. inspection time and event indicator. 
Use <code>cs2ic</code> to convert to interval censored format (see example).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simData &lt;- simCS_weib()
fit &lt;- ic_par(cs2ic(time, event) ~ x1 + x2, data = simData)
</code></pre>

<hr>
<h2 id='simDC_weib'>Simulate Doubly Censored Data</h2><span id='topic+simDC_weib'></span>

<h3>Description</h3>

<p>Simulates doubly censored data from a survival regression model 
with a Weibull baseline distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDC_weib(
  n = 100,
  b1 = 0.5,
  b2 = -0.5,
  model = "ph",
  shape = 2,
  scale = 2,
  lowerLimit = 0.75,
  upperLimit = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simDC_weib_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_b1">b1</code></td>
<td>
<p>Regression coefficient 1</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_b2">b2</code></td>
<td>
<p>Regression coefficient 2</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_model">model</code></td>
<td>
<p>Regression model to use. Choices are <code>"ph"</code>, <code>"po"</code> or <code>"aft"</code></p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_shape">shape</code></td>
<td>
<p>Baseline shape parameter</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_scale">scale</code></td>
<td>
<p>Baseline scale parameter</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>Lower censoring threshold</p>
</td></tr>
<tr><td><code id="simDC_weib_+3A_upperlimit">upperLimit</code></td>
<td>
<p>Upper censoring threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact event times are simulated according to the given survival regression model.
Two covariates are used; <code>x1 = rnorm(n), x2 = 1 - 2 * rbinom(n, 1, .5)</code>. After
event times are simulated, all values less than <code>lowerLimit</code> are left censored
and all values less than <code>upperLimit</code> are right censored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simData &lt;- simDC_weib()
fit &lt;- ic_par(cbind(l, u) ~ x1 + x2, data = simData)
</code></pre>

<hr>
<h2 id='simIC_cluster'>Simulates data with multiple observations per subject</h2><span id='topic+simIC_cluster'></span>

<h3>Description</h3>

<p>Simulates data in which each subject is observed several times. 
In this case, the covariance matrix should be updated with <code>ir_clustBoot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simIC_cluster(nIDs = 50, nPerID = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simIC_cluster_+3A_nids">nIDs</code></td>
<td>
<p>Number of subjects</p>
</td></tr>
<tr><td><code id="simIC_cluster_+3A_nperid">nPerID</code></td>
<td>
<p>Number of observations per subject</p>
</td></tr>
</table>

<hr>
<h2 id='simIC_weib'>Simulates interval censored data from regression model with a Weibull baseline</h2><span id='topic+simIC_weib'></span>

<h3>Description</h3>

<p>Simulates interval censored data from a regression model with a weibull baseline distribution. Used for demonstration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simIC_weib(
  n = 100,
  b1 = 0.5,
  b2 = -0.5,
  model = "ph",
  shape = 2,
  scale = 2,
  inspections = 2,
  inspectLength = 2.5,
  rndDigits = NULL,
  prob_cen = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simIC_weib_+3A_n">n</code></td>
<td>
<p>Number of samples simulated</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_b1">b1</code></td>
<td>
<p>Value of first regression coefficient</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_b2">b2</code></td>
<td>
<p>Value of second regression coefficient</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_model">model</code></td>
<td>
<p>Type of regression model. Options are 'po' (prop. odds) and 'ph' (Cox PH)</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_shape">shape</code></td>
<td>
<p>shape parameter of baseline distribution</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_scale">scale</code></td>
<td>
<p>scale parameter of baseline distribution</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_inspections">inspections</code></td>
<td>
<p>number of inspections times of censoring process</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_inspectlength">inspectLength</code></td>
<td>
<p>max length of inspection interval</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_rnddigits">rndDigits</code></td>
<td>
<p>number of digits to which the inspection time is rounded to, 
creating a discrete inspection time. If <code>rndDigits = NULL</code>, the inspection time is not rounded, 
resulting in a continuous inspection time</p>
</td></tr>
<tr><td><code id="simIC_weib_+3A_prob_cen">prob_cen</code></td>
<td>
<p>probability event being censored. If event is uncensored, l == u</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exact event times are simulated according to regression model: covariate <code>x1</code> 
is distributed <code>rnorm(n)</code> and covariate <code>x2</code> is distributed
<code>1 - 2 * rbinom(n, 1, 0.5)</code>. Event times are then censored with a 
case II interval censoring mechanism with <code>inspections</code> different inspection times. 
Time between inspections is distributed as <code>runif(min = 0, max = inspectLength)</code>. 
Note that the user should be careful in simulation studies not to simulate data 
where nearly all the data is right censored (or more over, all the data with x2 = 1 or -1) 
or this can result in degenerate solutions!
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sim_data &lt;- simIC_weib(n = 500, b1 = .3, b2 = -.3, model = 'ph', 
                      shape = 2, scale = 2, inspections = 6, 
                      inspectLength = 1)
#simulates data from a cox-ph with beta weibull distribution.

diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2, 
           data = sim_data, model = 'po')
diag_covar(Surv(l, u, type = 'interval2') ~ x1 + x2,
           data = sim_data, model = 'ph')

#'ph' fit looks better than 'po'; the difference between the transformed survival
#function looks more constant
</code></pre>

<hr>
<h2 id='survCIs'>Confidence/Credible intervals for survival curves</h2><span id='topic+survCIs'></span>

<h3>Description</h3>

<p>Confidence/Credible intervals for survival curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survCIs(
  fit,
  newdata = NULL,
  p = NULL,
  q = NULL,
  ci_level = 0.95,
  MC_samps = 4000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survCIs_+3A_fit">fit</code></td>
<td>
<p>Fitted model from <code>ic_par</code> or <code>ic_bayes</code></p>
</td></tr>
<tr><td><code id="survCIs_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> containing covariates for survival curves</p>
</td></tr>
<tr><td><code id="survCIs_+3A_p">p</code></td>
<td>
<p>Percentiles of distribution to sample</p>
</td></tr>
<tr><td><code id="survCIs_+3A_q">q</code></td>
<td>
<p>Times of disitribution to sample. Only p OR q should be specified, not p AND q</p>
</td></tr>
<tr><td><code id="survCIs_+3A_ci_level">ci_level</code></td>
<td>
<p>Confidence/credible level</p>
</td></tr>
<tr><td><code id="survCIs_+3A_mc_samps">MC_samps</code></td>
<td>
<p>Number of Monte Carlo samples taken</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a set of confidence intervals for the survival curves conditional
on the covariates provided in <code>newdata</code>. Several rows can be provided in newdata;
this will lead to several sets of confidence/credible intervals. 
</p>
<p>For Bayesian models, these are draws directly from the posterior; a set of parameters drawn 
from those saved in <code>fit$samples</code> repeatedly and then for each set of parameters, 
the given set of quantiles is calculated. For parametric models, the procedure is virtually the 
same, but rather than randomly drawing rows from saved samples, random samples are drawn using
the asymptotic normal approximation of the estimator. 
</p>
<p>This function is not compatible with <code>ic_np</code> or <code>ic_sp</code> objects, as the distribution 
of the baseline distribution of these estimators is still an open question.
</p>


<h3>Author(s)</h3>

<p>Clifford Anderson-Bergman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IR_diabetes")
fit &lt;- ic_par(cbind(left, right) ~ gender, 
                data = IR_diabetes)

# Getting confidence intervals for survival curves
# for males and females
newdata &lt;- data.frame(gender = c("male", "female"))
rownames(newdata) &lt;- c("Males", "Females")
diab_cis &lt;- survCIs(fit, newdata)
diab_cis

# Can add this to any plot
plot(fit, newdata = newdata, 
     cis = FALSE)
# Would have been included by default
lines(diab_cis, col = c("black", "red"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
