<!DOCTYPE html><html><head><title>Help for package NetworkDistance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetworkDistance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#graph20'><p>20 adjacency matrices from Erdős–Rényi models</p></a></li>
<li><a href='#nd.centrality'><p>Centrality Distance</p></a></li>
<li><a href='#nd.csd'><p><code class="reqn">L_2</code> Distance of Continuous Spectral Densities</p></a></li>
<li><a href='#nd.dsd'><p>Discrete Spectral Distance</p></a></li>
<li><a href='#nd.edd'><p>Edge Difference Distance</p></a></li>
<li><a href='#nd.extremal'><p>Extremal distance with top-<code class="reqn">k</code> eigenvalues</p></a></li>
<li><a href='#nd.gdd'><p>Graph Diffusion Distance</p></a></li>
<li><a href='#nd.graphon'><p>Graphon Estimates Distance</p></a></li>
<li><a href='#nd.hamming'><p>Hamming Distance</p></a></li>
<li><a href='#nd.him'><p>HIM Distance</p></a></li>
<li><a href='#nd.moments'><p>Log Moments Distance</p></a></li>
<li><a href='#nd.nfd'><p>Network Flow Distance</p></a></li>
<li><a href='#nd.wsd'><p>Distance with Weighted Spectral Distribution</p></a></li>
<li><a href='#NetworkDistance'><p>Distance Measures for Networks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Distance Measures for Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Network is a prevalent form of data structure in many fields. As an object of analysis, many distance or metric measures have been proposed to define the concept of similarity between two networks. We provide a number of distance measures for networks. See Jurman et al (2011) &lt;<a href="https://doi.org/10.3233%2F978-1-60750-692-8-227">doi:10.3233/978-1-60750-692-8-227</a>&gt; for an overview on spectral class of inter-graph distance measures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, Rcpp, Rdpack, RSpectra, doParallel, foreach, graphon,
parallel, stats, igraph, network, pracma, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graphics, knitr, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-21 04:01:10 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-21 15:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='graph20'>20 adjacency matrices from Erdős–Rényi models</h2><span id='topic+graph20'></span>

<h3>Description</h3>

<p>Simulated list of 20 adjacency matrices of 28 nodes. First 10 are from Erdős–Rényi model with <code class="reqn">p=0.9</code>, and
the latter 10 are generated using <code class="reqn">p=0.5</code>. Each element in the list is of size <code class="reqn">(28\times 28)</code>, symmetric,
having values in <code class="reqn">0</code> or <code class="reqn">1</code>, and every diagonal element is set as <code class="reqn">0</code> in accordance with no self-loop assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(graph20)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> of 20 adjacency matrices of size <code class="reqn">(28\times 28)</code>.
</p>


<h3>Details</h3>

<p>Below is the code used to generate <em>graph20</em>:
</p>
<pre>
require(stats)
graph20 = list()
for (i in 1:10){ # type-1 adjacency matrices
  rbin   = rbinom(784,1,0.9)
  mat    = matrix(rbin, nrow=28)
  matout = mat*t(mat)
  diag(matout) = 0
  graph20[[i]]=matout
}
for (i in 11:20){ # type-2 adjacency matrices
  rbin   = rbinom(784,1,0.5)
  mat    = matrix(rbin, nrow=28)
  matout = mat*t(mat)
  diag(matout) = 0
  graph20[[i]]=matout
}
</pre>

<hr>
<h2 id='nd.centrality'>Centrality Distance</h2><span id='topic+nd.centrality'></span>

<h3>Description</h3>

<p>Centrality is a core concept in studying the topological structure of
complex networks, which can be either defined for each node or edge.
<code>nd.centrality</code> offers 3 distance measures on node-defined centralities.
See this <a href="https://en.wikipedia.org/wiki/Centrality">Wikipedia page</a> for more
on network/graph centrality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.centrality(
  A,
  out.dist = TRUE,
  mode = c("Degree", "Close", "Between"),
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.centrality_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.centrality_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.centrality_+3A_mode">mode</code></td>
<td>
<p>type of node centrality definitions to be used.</p>
</td></tr>
<tr><td><code id="nd.centrality_+3A_directed">directed</code></td>
<td>
<p>a logical; <code>FALSE</code> as symmetric, undirected graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>features</dt><dd><p>an <code class="reqn">(N\times M)</code> matrix where rows are node centralities for each graph.</p>
</dd>
</dl>



<h3>References</h3>

<p>Roy M, Schmid S, Trédan G (2014).
&ldquo;Modeling and Measuring Graph Similarity: The Case for Centrality Distance.&rdquo;
In <em>FOMC 2014, 10th ACM International Workshop on Foundations of Mobile Computing</em>, 53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(graph20)

## use 3 types of centrality measures
out1 &lt;- nd.centrality(graph20, out.dist=FALSE,mode="Degree")
out2 &lt;- nd.centrality(graph20, out.dist=FALSE,mode="Close")
out3 &lt;- nd.centrality(graph20, out.dist=FALSE,mode="Between")

## visualize
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
image(out1$D[,20:1], main="Degree", col=gray(0:32/32), axes=FALSE)
image(out2$D[,20:1], main="Close", col=gray(0:32/32), axes=FALSE)
image(out3$D[,20:1], main="Between", col=gray(0:32/32), axes=FALSE)
par(opar)


</code></pre>

<hr>
<h2 id='nd.csd'><code class="reqn">L_2</code> Distance of Continuous Spectral Densities</h2><span id='topic+nd.csd'></span>

<h3>Description</h3>

<p>The method employs spectral density of eigenvalues from
Laplacian in that for each, we have corresponding
spectral density <code class="reqn">\rho(w)</code> as a sum of
narrow Lorentz distributions with <code>bandwidth</code> parameter.
Since it involves integration of a function over the
non-compact domain, it may blow up to infinity and the code
automatically aborts the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.csd(A, out.dist = TRUE, bandwidth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.csd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.csd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.csd_+3A_bandwidth">bandwidth</code></td>
<td>
<p>common bandwidth of positive real number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>spectra</dt><dd><p>an <code class="reqn">(N\times M-1)</code> matrix where each row is top-<code class="reqn">M-1</code> vibrational spectra.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ipsen M, Mikhailov AS (2002).
&ldquo;Evolutionary reconstruction of networks.&rdquo;
<em>Physical Review E</em>, <b>66</b>(4).
ISSN 1063-651X, 1095-3787.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(graph20)

## compute distance matrix
output = nd.csd(graph20, out.dist=FALSE, bandwidth=1.0)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,20:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)


</code></pre>

<hr>
<h2 id='nd.dsd'>Discrete Spectral Distance</h2><span id='topic+nd.dsd'></span>

<h3>Description</h3>

<p>Discrete Spectral Distance (DSD) is defined as the Euclidean distance between
the spectra of various matrices, such as adjacency matrix <code class="reqn">A</code>(<code>"Adj"</code>),
(unnormalized) Laplacian matrix <code class="reqn">L=D-A</code>(<code>"Lap"</code>),
signless Laplacian matrix <code class="reqn">|L|=D+A</code>(<code>"SLap"</code>), or
normalized Laplacian matrix <code class="reqn">\tilde{L}=D^{-1/2}LD^{-1/2}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.dsd(A, out.dist = TRUE, type = c("Lap", "SLap", "NLap", "Adj"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.dsd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.dsd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.dsd_+3A_type">type</code></td>
<td>
<p>type of target structure. One of <code>"Lap","SLap","NLap","Adj"</code> as defined above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>spectra</dt><dd><p>an <code class="reqn">(N\times M-1)</code> matrix where each row is top-<code class="reqn">M-1</code> vibrational spectra.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wilson RC, Zhu P (2008).
&ldquo;A study of graph spectra for comparing graphs and trees.&rdquo;
<em>Pattern Recognition</em>, <b>41</b>(9), 2833&ndash;2841.
ISSN 00313203.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data and extract only a few
data(graph20)
gr.small = graph20[c(1:5,11:15)]

## compute distance matrix
output &lt;- nd.dsd(gr.small, out.dist=FALSE)

## visualize
opar &lt;- par(no.readonly=TRUE)
par(pty="s")
image(output$D[,10:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)


</code></pre>

<hr>
<h2 id='nd.edd'>Edge Difference Distance</h2><span id='topic+nd.edd'></span>

<h3>Description</h3>

<p>It is of the most simplest form that Edge Difference Distance (EDD)
takestwo adjacency matrices and takes Frobenius norm of their differnces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.edd(A, out.dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.edd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.edd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hammond DK, Gur Y, Johnson CR (2013).
&ldquo;Graph Diffusion Distance: A Difference Measure for Weighted Graphs Based on the Graph Laplacian Exponential Kernel.&rdquo;
In <em>Proceedings of the IEEE global conference on information and signal processing (GlobalSIP'13)</em>, 419&ndash;422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(graph20)

## compute distance matrix
output = nd.edd(graph20, out.dist=FALSE)

## visualize
opar &lt;- par(no.readonly=TRUE)
par(pty="s")
image(output$D[,20:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)

</code></pre>

<hr>
<h2 id='nd.extremal'>Extremal distance with top-<code class="reqn">k</code> eigenvalues</h2><span id='topic+nd.extremal'></span>

<h3>Description</h3>

<p>Extremal distance (<code>nd.extremal</code>) is a type of spectral distance measures on two graphs' graph Laplacian,
</p>
<p style="text-align: center;"><code class="reqn">L := D-A</code>
</p>

<p>where <code class="reqn">A</code> is an adjacency matrix and <code class="reqn">D_{ii}=\sum_j A_{ij}</code>. It takes top-<code class="reqn">k</code> eigenvalues from
graph Laplacian matrices and take normalized sum of squared differences as metric. Note that it is
<em>1. non-negative</em>, <em>2. separated</em>, <em>3. symmetric</em>, and satisfies <em>4. triangle inequality</em> in that
it is indeed a metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.extremal(A, out.dist = TRUE, k = ceiling(nrow(A)/5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.extremal_+3A_a">A</code></td>
<td>
<p>a list of length <code>N</code> containing adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.extremal_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.extremal_+3A_k">k</code></td>
<td>
<p>the number of largest eigenvalues to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>spectra</dt><dd><p>an <code class="reqn">(N\times k)</code> matrix where each row is top-<code class="reqn">k</code> Laplacian eigenvalues.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jakobson D, Rivin I (2002).
&ldquo;Extremal metrics on graphs I.&rdquo;
<em>Forum Mathematicum</em>, <b>14</b>(1).
ISSN 0933-7741, 1435-5337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load data
data(graph20)

## compute distance matrix
output = nd.extremal(graph20, out.dist=FALSE, k=2)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,20:1], main="two group case", col=gray(0:32/32), axes=FALSE)
par(opar)


</code></pre>

<hr>
<h2 id='nd.gdd'>Graph Diffusion Distance</h2><span id='topic+nd.gdd'></span>

<h3>Description</h3>

<p>Graph Diffusion Distance (<code>nd.gdd</code>) quantifies the difference between two weighted graphs of same size. It takes
an idea from heat diffusion process on graphs via graph Laplacian exponential kernel matrices. For a given
adjacency matrix <code class="reqn">A</code>, the graph Laplacian is defined as
</p>
<p style="text-align: center;"><code class="reqn">L := D-A</code>
</p>

<p>where <code class="reqn">D_{ii}=\sum_j A_{ij}</code>. For two adjacency matrices <code class="reqn">A_1</code> and <code class="reqn">A_2</code>,
GDD is defined as
</p>
<p style="text-align: center;"><code class="reqn">d_{gdd}(A_1,A_2) = max_t \sqrt{\| \exp(-tL_1) -\exp(-tL_2)   \|_F^2}</code>
</p>

<p>where <code class="reqn">\exp(\cdot)</code> is matrix exponential, <code class="reqn">\|\cdot\|_F</code> a Frobenius norm, and <code class="reqn">L_1</code> and <code class="reqn">L_2</code>
Laplacian matrices corresponding to <code class="reqn">A_1</code> and <code class="reqn">A_2</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.gdd(A, out.dist = TRUE, vect = seq(from = 0.1, to = 1, length.out = 10))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.gdd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.gdd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.gdd_+3A_vect">vect</code></td>
<td>
<p>a vector of parameters <code class="reqn">t</code> whose values will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>maxt</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix whose entries are maximizer of the cost function.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hammond DK, Gur Y, Johnson CR (2013).
&ldquo;Graph Diffusion Distance: A Difference Measure for Weighted Graphs Based on the Graph Laplacian Exponential Kernel.&rdquo;
In <em>Proceedings of the IEEE global conference on information and signal processing (GlobalSIP'13)</em>, 419&ndash;422.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load data and extract a subset
data(graph20)
gr.small = graph20[c(1:5,11:15)]

## compute distance matrix
output = nd.gdd(gr.small, out.dist=FALSE)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,10:1], main="two group case", col=gray((0:32)/32), axes=FALSE)
par(opar)

</code></pre>

<hr>
<h2 id='nd.graphon'>Graphon Estimates Distance</h2><span id='topic+nd.graphon'></span>

<h3>Description</h3>

<p>Graphon is a symmetric measurable function
</p>
<p style="text-align: center;"><code class="reqn">W:[0,1]^2\rightarrow[0,1]</code>
</p>

<p>that is considered to be a generating model for an observed network. <code>nd.graphon</code> computes
distances between networks based on the estimated graphons of each network. Estimation methods
are taken from <span class="pkg">graphon</span> package. For more details, see the function links below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.graphon(
  A,
  out.dist = TRUE,
  method = c("completion", "LG", "nbdsmooth", "SBA", "USVT"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.graphon_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.graphon_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.graphon_+3A_method">method</code></td>
<td>
<p>type of graphon estimation methods to be used.</p>
</td></tr>
<tr><td><code id="nd.graphon_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed onto graphon estimation functions. See also <code><a href="graphon.html#topic+est.completion">est.completion</a></code>,
<code><a href="graphon.html#topic+est.LG">est.LG</a></code>, <code><a href="graphon.html#topic+est.nbdsmooth">est.nbdsmooth</a></code>, <code><a href="graphon.html#topic+est.SBA">est.SBA</a></code>, and <code><a href="graphon.html#topic+est.USVT">est.USVT</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Mukherjee SS, Sarkar P, Lin L (2017).
&ldquo;On clustering network-valued data.&rdquo;
In Guyon I, Luxburg UV, Bengio S, Wallach H, Fergus R, Vishwanathan S, Garnett R (eds.), <em>Advances in neural information processing systems 30</em>, 7071&ndash;7081.
Curran Associates, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(graph20)

## compute USVT-based distance
output &lt;- nd.graphon(graph20, out.dist=FALSE, method="usvt")

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,20:1], main="USVT", col=gray(0:32/32), axes=FALSE)
par(opar)

</code></pre>

<hr>
<h2 id='nd.hamming'>Hamming Distance</h2><span id='topic+nd.hamming'></span>

<h3>Description</h3>

<p>Hamming Distance is the count of discrepancy between two binary networks for each edge.
Therefore, if used with non-binary networks, it might return a warning message and distorted results.
It was originally designed to compare two strings of equal length, see <a href="https://en.wikipedia.org/wiki/Hamming_distance">Wikipedia page</a> for more detailed introduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.hamming(A, out.dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.hamming_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.hamming_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hamming RW (1950).
&ldquo;Error Detecting and Error Correcting Codes.&rdquo;
<em>Bell System Technical Journal</em>, <b>29</b>(2), 147&ndash;160.
ISSN 00058580.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data and extract only a few
data(graph20)
gr.small = graph20[c(1:5,11:15)]

## compute distance matrix
output = nd.hamming(gr.small, out.dist=FALSE)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,10:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)

</code></pre>

<hr>
<h2 id='nd.him'>HIM Distance</h2><span id='topic+nd.him'></span>

<h3>Description</h3>

<p>Hamming-Ipsen-Mikhailov (HIM) combines the local Hamming edit distance and the global
Ipsen-Mikhailov distance to merge information at each scale. For Ipsen-Mikhailove distance,
it is provided as <code>nd.csd</code> in our package for consistency. Given a parameter <code class="reqn">\xi</code> (<code>xi</code>),
it is defined as
</p>
<p style="text-align: center;"><code class="reqn">HIM_{\xi}(A,B)=\sqrt{H^2(A,B)+\xi\cdot IM^2(A,B)}/\sqrt{1+\xi}</code>
</p>

<p>where <code class="reqn">H</code> and <code class="reqn">IM</code> stand for Hamming and I-M distance, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.him(A, out.dist = TRUE, xi = 1, ntest = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.him_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.him_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.him_+3A_xi">xi</code></td>
<td>
<p>a parameter to control balance between two distances.</p>
</td></tr>
<tr><td><code id="nd.him_+3A_ntest">ntest</code></td>
<td>
<p>the number of searching over <code><a href="#topic+nd.csd">nd.csd</a></code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jurman G, Visintainer R, Filosi M, Riccadonna S, Furlanello C (2015).
&ldquo;The HIM glocal metric and kernel for network comparison and classification.&rdquo;
In <em>2015 IEEE International Conference on Data Science and Advanced Analytics (DSAA)</em>, 1&ndash;10.
ISBN 978-1-4673-8272-4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nd.hamming">nd.hamming</a></code>, <code><a href="#topic+nd.csd">nd.csd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(graph20)

## compute distance matrix
output = nd.him(graph20, out.dist=FALSE)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,20:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)


</code></pre>

<hr>
<h2 id='nd.moments'>Log Moments Distance</h2><span id='topic+nd.moments'></span>

<h3>Description</h3>

<p>For a graph with an adjacency matrix <code class="reqn">A</code>, <em>graph moment</em> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\rho_m (A) = tr(A/n)^m</code>
</p>

<p>where <code class="reqn">n</code> is the number of vertices and <code class="reqn">m</code> is an order of the moment. <code>nd.moments</code> computes
pairwise distances based on log of graph moments from <code class="reqn">m=1</code> to <code class="reqn">m=k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.moments(
  A,
  k = 3,
  metric = c("euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski"),
  out.dist = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.moments_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.moments_+3A_k">k</code></td>
<td>
<p>the integer order of moments. If <code class="reqn">k</code> is too large, it may incur numerical overflow.</p>
</td></tr>
<tr><td><code id="nd.moments_+3A_metric">metric</code></td>
<td>
<p>type of distance measures for log-moment features. See <code><a href="stats.html#topic+dist">dist</a></code> for more details.</p>
</td></tr>
<tr><td><code id="nd.moments_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>References</h3>

<p>Mukherjee SS, Sarkar P, Lin L (2017).
&ldquo;On clustering network-valued data.&rdquo;
In Guyon I, Luxburg UV, Bengio S, Wallach H, Fergus R, Vishwanathan S, Garnett R (eds.), <em>Advances in neural information processing systems 30</em>, 7071&ndash;7081.
Curran Associates, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data
data(graph20)

## compute distance based on different k's.
out3 &lt;- nd.moments(graph20, k=3, out.dist=FALSE)
out5 &lt;- nd.moments(graph20, k=5, out.dist=FALSE)
out7 &lt;- nd.moments(graph20, k=7, out.dist=FALSE)
out9 &lt;- nd.moments(graph20, k=9, out.dist=FALSE)

## visualize
opar = par(no.readonly=TRUE)
par(mfrow=c(2,2), pty="s")
image(out3$D[,20:1], col=gray(0:32/32), axes=FALSE, main="k=3")
image(out5$D[,20:1], col=gray(0:32/32), axes=FALSE, main="k=5")
image(out7$D[,20:1], col=gray(0:32/32), axes=FALSE, main="k=7")
image(out9$D[,20:1], col=gray(0:32/32), axes=FALSE, main="k=9")
par(opar)

</code></pre>

<hr>
<h2 id='nd.nfd'>Network Flow Distance</h2><span id='topic+nd.nfd'></span>

<h3>Description</h3>

<p>Network Flow Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.nfd(
  A,
  order = 0,
  out.dist = TRUE,
  vect = seq(from = 0, to = 10, length.out = 1000)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.nfd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.nfd_+3A_order">order</code></td>
<td>
<p>the order of Laplacian; currently only 0 and 1 are supported.</p>
</td></tr>
<tr><td><code id="nd.nfd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.nfd_+3A_vect">vect</code></td>
<td>
<p>a vector of parameters <code class="reqn">t</code> whose values will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load example data
data(graph20)

# compute two diffusion-based distances and visualize
out1 = nd.gdd(graph20, out.dist=FALSE)
out2 = nd.nfd(graph20, out.dist=FALSE)

# visualize
opar &lt;- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(out1$D[,20:1],col=gray((0:32)/32), main="nd.gdd",axes=FALSE)
image(out2$D[,20:1],col=gray((0:32)/32), main="nd.nfd",axes=FALSE)
par(opar)

## End(Not run)

</code></pre>

<hr>
<h2 id='nd.wsd'>Distance with Weighted Spectral Distribution</h2><span id='topic+nd.wsd'></span>

<h3>Description</h3>

<p>Normalized Laplacian matrix contains topological information of
a corresponding network via its spectrum. <code>nd.wsd</code> adopts weighted
spectral distribution of eigenvalues and brings about a metric via
binning strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nd.wsd(A, out.dist = TRUE, K = 50, wN = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nd.wsd_+3A_a">A</code></td>
<td>
<p>a list of length <code class="reqn">N</code> containing <code class="reqn">(M\times M)</code> adjacency matrices.</p>
</td></tr>
<tr><td><code id="nd.wsd_+3A_out.dist">out.dist</code></td>
<td>
<p>a logical; <code>TRUE</code> for computed distance matrix as a <code>dist</code> object.</p>
</td></tr>
<tr><td><code id="nd.wsd_+3A_k">K</code></td>
<td>
<p>the number of bins for the spectrum interval <code class="reqn">[0,2].</code></p>
</td></tr>
<tr><td><code id="nd.wsd_+3A_wn">wN</code></td>
<td>
<p>a decaying exponent; default is <code class="reqn">4</code> set by authors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>D</dt><dd><p>an <code class="reqn">(N\times N)</code> matrix or <code>dist</code> object containing pairwise distance measures.</p>
</dd>
<dt>spectra</dt><dd><p>an <code class="reqn">(N\times M)</code> matrix of rows being eigenvalues for each graph.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fay D, Haddadi H, Thomason A, Moore AW, Mortier R, Jamakovic A, Uhlig S, Rio M (2010).
&ldquo;Weighted Spectral Distribution for Internet Topology Analysis: Theory and Applications.&rdquo;
<em>IEEE/ACM Transactions on Networking</em>, <b>18</b>(1), 164&ndash;176.
ISSN 1063-6692, 1558-2566.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data and extract a few
data(graph20)
gr.small = graph20[c(1:5,11:15)]

## compute distance matrix
output = nd.wsd(gr.small, out.dist=FALSE, K=10)

## visualize
opar = par(no.readonly=TRUE)
par(pty="s")
image(output$D[,10:1], main="two group case", axes=FALSE, col=gray(0:32/32))
par(opar)

</code></pre>

<hr>
<h2 id='NetworkDistance'>Distance Measures for Networks</h2><span id='topic+NetworkDistance'></span>

<h3>Description</h3>

<p>Network has gathered much attention from many disciplines, as many of real data
can be well represented in the relational form. The concept of distance - or, metric - between
two networks is the starting point for inference on population of networks. <span class="pkg">NetworkDistance</span> package
provides a not-so-comprehensive collection of distance measures for measuring dissimilarity between two network objects.
Data should be supplied as <em>adjacency</em> matrices, where we support three formats of data representation;
<code>matrix</code> object in <span class="pkg">R</span> base, <code>network</code> class from <span class="pkg">network</span> package, and <code>igraph</code> class from
<span class="pkg">igraph</span> package.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
