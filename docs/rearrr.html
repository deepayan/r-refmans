<!DOCTYPE html><html><head><title>Help for package rearrr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rearrr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#angle'><p>Calculate the angle to an origin</p></a></li>
<li><a href='#apply_coord_fn_'><p>Apply coordinate function (internal wrapper)</p></a></li>
<li><a href='#apply_transformation_matrix'><p>Apply transformation matrix to a set of columns</p></a></li>
<li><a href='#by_distance_rearranger_'><p>Wrapper for running closest to / furthest from rearrange methods</p></a></li>
<li><a href='#center_max'><p>Centers the highest value with values decreasing around it</p></a></li>
<li><a href='#center_min'><p>Centers the lowest value with values increasing around it</p></a></li>
<li><a href='#centering_rearranger_'><p>Wrapper for running centering rearrange methods</p></a></li>
<li><a href='#centroid'><p>Find the coordinates for the centroid</p></a></li>
<li><a href='#circularize'><p>Create x-coordinates so the points form a circle</p></a></li>
<li><a href='#closest_to'><p>Orders values by shortest distance to an origin</p></a></li>
<li><a href='#cluster_groups'><p>Move data points into clusters</p></a></li>
<li><a href='#create_dimming_fn'><p>Create dimming_fn function</p></a></li>
<li><a href='#create_n_fn'><p>Create n_fn function</p></a></li>
<li><a href='#create_origin_fn'><p>Create origin_fn function</p></a></li>
<li><a href='#degrees_to_radians'><p>Conversion between radians and degrees</p></a></li>
<li><a href='#dim_values'><p>Dim values of a dimension based on the distance to an n-dimensional origin</p></a></li>
<li><a href='#distance'><p>Calculate the distance to an origin</p></a></li>
<li><a href='#expand_distances'><p>Expand the distances to an origin</p></a></li>
<li><a href='#expand_distances_each'><p>Expand the distances to an origin in each dimension</p></a></li>
<li><a href='#extreme_pairing_rearranger_'><p>Wrapper for running extreme pairing</p></a></li>
<li><a href='#extreme_triplet_grouping_rearranger_'><p>Wrapper for running extreme triplet grouping</p></a></li>
<li><a href='#FixedGroupsPipeline'><p>Chain multiple transformations with different argument values per group</p></a></li>
<li><a href='#FixedGroupsTransformation'><p>FixedGroupsTransformation</p></a></li>
<li><a href='#flip_values'><p>Flip the values around an origin</p></a></li>
<li><a href='#furthest_from'><p>Orders values by longest distance to an origin</p></a></li>
<li><a href='#generate_clusters'><p>Generate n-dimensional clusters</p></a></li>
<li><a href='#generate_wave'><p>Generate simple wave signal</p></a></li>
<li><a href='#GeneratedPipeline'><p>Chain multiple transformations and generate argument values per group</p></a></li>
<li><a href='#GeneratedTransformation'><p>GeneratedTransformation</p></a></li>
<li><a href='#hexagonalize'><p>Create x-coordinates so the points form a hexagon</p></a></li>
<li><a href='#is_most_centered'><p>Find which data point is closest to the centroid</p></a></li>
<li><a href='#median_index'><p>Find index of interest for each vector</p></a></li>
<li><a href='#midrange'><p>Find the midrange values</p></a></li>
<li><a href='#min_max_scale'><p>Scale to a range</p></a></li>
<li><a href='#most_centered'><p>Find the coordinates for the data point closest to the centroid</p></a></li>
<li><a href='#multi_mutator_'><p>Wrapper for running multi-column mutator methods</p></a></li>
<li><a href='#pair_extremes'><p>Pair extreme values and sort by the pairs</p></a></li>
<li><a href='#Pipeline'><p>Chain multiple transformations</p></a></li>
<li><a href='#position_max'><p>Positions the highest values with values decreasing around it</p></a></li>
<li><a href='#position_min'><p>Positions the lowest value with values increasing around it</p></a></li>
<li><a href='#positioning_rearranger_'><p>Wrapper for running positioning rearrange methods</p></a></li>
<li><a href='#rearranger_'><p>Wrapper for running rearranging methods</p></a></li>
<li><a href='#rearrr_fn_'><p>Parent function for documentation inheritance</p></a></li>
<li><a href='#render_toc'><p>Render Table of Contents</p></a></li>
<li><a href='#rev_windows'><p>Reverse order window-wise</p></a></li>
<li><a href='#rev_windows_rearranger_'><p>Wrapper for running centering rearrange methods</p></a></li>
<li><a href='#roll_elements'><p>Roll elements</p></a></li>
<li><a href='#roll_values'><p>Shift values and wrap to range</p></a></li>
<li><a href='#rotate_2d'><p>Rotate the values around an origin in 2 dimensions</p></a></li>
<li><a href='#rotate_3d'><p>Rotate the values around an origin in 3 dimensions</p></a></li>
<li><a href='#shear_2d'><p>Shear the values around an origin in 2 dimensions</p></a></li>
<li><a href='#shear_3d'><p>Shear values around an origin in 3 dimensions</p></a></li>
<li><a href='#shuffle_hierarchy'><p>Shuffle multi-column hierarchy of groups</p></a></li>
<li><a href='#square'><p>Create x-coordinates so the points form a square</p></a></li>
<li><a href='#swirl_2d'><p>Swirl the values around an origin in 2 dimensions</p></a></li>
<li><a href='#swirl_3d'><p>Swirl the values around an origin in 3 dimensions</p></a></li>
<li><a href='#to_unit_length'><p>Scale to unit length</p></a></li>
<li><a href='#transfer_centroids'><p>Transfer centroids from one data frame to another</p></a></li>
<li><a href='#Transformation'><p>Transformation</p></a></li>
<li><a href='#triangularize'><p>Create x-coordinates so the points form a triangle</p></a></li>
<li><a href='#triplet_extremes'><p>Makes triplets of extreme values and sort by them</p></a></li>
<li><a href='#vector_length'><p>Calculate vector length(s)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Rearranging Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Arrange data by a set of methods. Use rearrangers to reorder
    data points and mutators to change their values. From basic utilities,
    to centering the greatest value, to swirling in 3-dimensional space,
    'rearrr' enables creativity when plotting and experimenting with data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ludvigolsen/rearrr">https://github.com/ludvigolsen/rearrr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ludvigolsen/rearrr/issues">https://github.com/ludvigolsen/rearrr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.0.0), dplyr (&ge; 0.8.5), lifecycle, plyr, purrr
(&ge; 0.3.4), rlang (&ge; 0.4.7), R6, stats, tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, knitr, testthat, tidyr, xpectr (&ge; 0.4.3)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 13:14:58 UTC; au547627</td>
</tr>
<tr>
<td>Author:</td>
<td>Ludvig Renbo Olsen
    <a href="https://orcid.org/0009-0006-6798-7454"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]
    (@ludvigolsen)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ludvig Renbo Olsen &lt;r-pkgs@ludvigolsen.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='angle'>Calculate the angle to an origin</h2><span id='topic+angle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the angle between each data point <code class="reqn">(x2, y2)</code> and the origin <code class="reqn">(x1, y1)</code> with:
</p>
<p style="text-align: center;"><code class="reqn">atan2(y2 - y1, x2 - x1)</code>
</p>

<p>And converts to degrees <code>[0-360)</code>, measured counterclockwise from the <code>{x &gt; x1, y = y1}</code> line.
</p>
<img src='figures/angle_wheel.jpg' width="120" alt='Angles wheel'>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and finding the angle to e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle(
  data,
  x_col = NULL,
  y_col = NULL,
  origin = NULL,
  origin_fn = NULL,
  degrees_col_name = ".degrees",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="angle_+3A_x_col">x_col</code></td>
<td>
<p>Name of x column in <code>`data`</code>. If <code>NULL</code> and <code>`data`</code> is a <code>vector</code>,
the index of <code>`data`</code> is used. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="angle_+3A_y_col">y_col</code></td>
<td>
<p>Name of y column in <code>`data`</code>. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="angle_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to calculate angle to.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="angle_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="angle_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees.</p>
</td></tr>
<tr><td><code id="angle_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="angle_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the additional columns (degrees and origin coordinates).
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other measuring functions: 
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+vector_length">vector_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Calculate angles in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
df_angles &lt;- angle(
  data = df,
  x_col = "x",
  y_col = "y",
  origin = c(0.5, 0.5)
)
df_angles

# Plot points with degrees
# Degrees are measured counterclockwise around the
# positive side of the x-axis
if (has_ggplot){
  df_angles %&gt;%
    ggplot(aes(x = x, y = y, color = .degrees)) +
    geom_segment(aes(x = 0.5, xend = 1, y = 0.5, yend = 0.5), color = "magenta") +
    geom_point() +
    theme_minimal()
}

# Calculate angles to the centroid for each group in 'g'
angle(
  data = dplyr::group_by(df, g),
  x_col = "x",
  y_col = "y",
  origin_fn = centroid
)
</code></pre>

<hr>
<h2 id='apply_coord_fn_'>Apply coordinate function (internal wrapper)</h2><span id='topic+apply_coord_fn_'></span>

<h3>Description</h3>

<p>Apply coordinate function (internal wrapper)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_coord_fn_(..., cols, coord_fn, fn_name, coordinate_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_coord_fn__+3A_...">...</code></td>
<td>
<p><code>Numeric vectors</code> or a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="apply_coord_fn__+3A_cols">cols</code></td>
<td>
<p>Names of columns to use when <code>`...`</code> is a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="apply_coord_fn__+3A_coord_fn">coord_fn</code></td>
<td>
<p>Function that takes each <code>vector</code>/<code>column</code> as separate args via <code>...</code> and
returns a <code>vector</code> with one value per input <code>vector</code>/<code>column</code>.</p>
</td></tr>
<tr><td><code id="apply_coord_fn__+3A_fn_name">fn_name</code></td>
<td>
<p>Name of applied function for messages.</p>
</td></tr>
<tr><td><code id="apply_coord_fn__+3A_coordinate_name">coordinate_name</code></td>
<td>
<p>Name of coordinates (e.g. <code>"centroid"</code>) for messages.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_transformation_matrix'>Apply transformation matrix to a set of columns</h2><span id='topic+apply_transformation_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Perform <a href="base.html#topic+matmult">matrix multiplication</a> with a transformation matrix and a set of <code>data.frame</code> columns.
</p>
<p>The data points in <code>`data`</code> are moved prior to the transformation, to bring
the origin to <code>0</code> in all dimensions. After the transformation, the
inverse move is applied to bring the origin back to its original position. See <code>`Details`</code> section.
</p>
<p>The columns in <code>`data`</code> are transposed, making the operation (without the origin movement):
</p>
<p style="text-align: center;"><code class="reqn">mat · data[, cols]^T</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and transforming around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_transformation_matrix(
  data,
  mat,
  cols,
  origin = NULL,
  origin_fn = NULL,
  suffix = "_transformed",
  keep_original = TRUE,
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_transformation_matrix_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_mat">mat</code></td>
<td>
<p>Transformation <code>matrix</code>. Must have the same number of columns as <code>`cols`</code>.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_cols">cols</code></td>
<td>
<p>Columns to mutate values of. Must be specified when <code>`data`</code> is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin. <code>Vector</code> with the same number
of elements as <code>`cols`</code> (i.e. origin_x, origin_y, ...).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="apply_transformation_matrix_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Example with 2 columns (<code>x</code>, <code>y</code>) and a 2x2 transformation matrix:
</p>

<ul>
<li><p>Move origin to <code>(0, 0)</code>:
</p>
<p><code>x = x - origin_x</code>
</p>
<p><code>y = y - origin_y</code>
</p>
</li>
<li><p>Convert to transposed matrix:
</p>
<p><code>data_mat = rbind(x, y)</code>
</p>
</li>
<li><p>Matrix multiplication:
</p>
<p><code>transformed = mat %*% data_mat</code>
</p>
</li>
<li><p>Move origin to original position (after extraction from <code>transformed</code>):
</p>
<p><code>x = x + origin_x</code>
</p>
<p><code>y = y + origin_y</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the new, transformed columns and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(3)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:12,
  "y" = 13:24,
  "z" = runif(12),
  "g" = c(
    1, 1, 1, 1, 2, 2,
    2, 2, 3, 3, 3, 3
  )
)

# Apply identity matrix
mat &lt;- matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1), nrow = 3)
apply_transformation_matrix(
  data = df,
  mat = mat,
  cols = c("x", "y", "z"),
  origin = c(0, 0, 0)
)

# Apply rotation matrix
# 90 degrees around z-axis
# Origin is the most centered point
mat &lt;- matrix(c(0, 1, 0, -1, 0, 0, 0, 0, 1), nrow = 3)
res &lt;- apply_transformation_matrix(
  data = df,
  mat = mat,
  cols = c("x", "y", "z"),
  origin_fn = most_centered
)

# Plot the rotation
# z wasn't changed so we plot x and y
if (has_ggplot){
  res %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_transformed, y = y_transformed)) +
    theme_minimal()
}

# Apply rotation matrix to grouped data frame
# Around centroids
# Same matrix as before
res &lt;- apply_transformation_matrix(
  data = dplyr::group_by(df, g),
  mat = mat,
  cols = c("x", "y", "z"),
  origin_fn = centroid
)

# Plot the rotation
if (has_ggplot){
  res %&gt;%
    ggplot(aes(x = x, y = y, color = g)) +
    geom_point() +
    geom_point(aes(x = x_transformed, y = y_transformed)) +
    theme_minimal()
}
</code></pre>

<hr>
<h2 id='by_distance_rearranger_'>Wrapper for running closest to / furthest from rearrange methods</h2><span id='topic+by_distance_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running closest to / furthest from rearrange methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_distance_rearranger_(
  data,
  cols,
  origin = NULL,
  origin_fn = NULL,
  shuffle_ties = FALSE,
  decreasing = FALSE,
  origin_col_name = ".origin",
  distance_col_name = ".distance",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_distance_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_cols">cols</code></td>
<td>
<p>Column(s) to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to calculate distances to.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>`NULL`</code>.</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_shuffle_ties">shuffle_ties</code></td>
<td>
<p>Whether to shuffle elements with the same distance to the origin. (Logical)</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_decreasing">decreasing</code></td>
<td>
<p>Whether to order by decreasing distances to the origin. (Logical)</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_distance_col_name">distance_col_name</code></td>
<td>
<p>Name of new column with the distances to the origin. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="by_distance_rearranger__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>

<hr>
<h2 id='center_max'>Centers the highest value with values decreasing around it</h2><span id='topic+center_max'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The highest value is positioned in the middle with the other
values decreasing around it.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4,</code> <strong><code>5</code></strong><code>)</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(1, 3,</code> <strong><code>5</code></strong><code>, 4, 2)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_max(data, col = NULL, shuffle_sides = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_max_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="center_max_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="center_max_+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the center. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Center by the index (row numbers)
center_max(df)

# Center by each of the columns
center_max(df, col = "A")
center_max(df, col = "B")
center_max(df, col = "C")

# Randomize which elements are left and right of the center
center_max(df, col = "A", shuffle_sides = TRUE)

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  center_max(col = "A")

# Plot the centered values
plot(x = 1:10, y = center_max(df, col = "B")$B)
plot(x = 1:10, y = center_max(df, col = "B", shuffle_sides = TRUE)$B)
</code></pre>

<hr>
<h2 id='center_min'>Centers the lowest value with values increasing around it</h2><span id='topic+center_min'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The lowest value is positioned in the middle with the other
values increasing around it.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 3, 4, 5)</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(5, 3,</code> <strong><code>1</code></strong><code>, 2, 4)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_min(data, col = NULL, shuffle_sides = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_min_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="center_min_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="center_min_+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the center. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Center by the index (row numbers)
center_min(df)

# Center by each of the columns
center_min(df, col = "A")
center_min(df, col = "B")
center_min(df, col = "C")

# Randomize which elements are left and right of the center
center_min(df, col = "A", shuffle_sides = TRUE)

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  center_min(col = "A")

# Plot the centered values
plot(x = 1:10, y = center_min(df, col = "B")$B)
plot(x = 1:10, y = center_min(df, col = "B", shuffle_sides = TRUE)$B)
</code></pre>

<hr>
<h2 id='centering_rearranger_'>Wrapper for running centering rearrange methods</h2><span id='topic+centering_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running centering rearrange methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centering_rearranger_(data, col = NULL, shuffle_sides = FALSE, what = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centering_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="centering_rearranger__+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="centering_rearranger__+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the center. (Logical)</p>
</td></tr>
<tr><td><code id="centering_rearranger__+3A_what">what</code></td>
<td>
<p>What to position. <code>"max"</code> or <code>"min"</code>. (Character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>

<hr>
<h2 id='centroid'>Find the coordinates for the centroid</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the mean of each passed <code>vector</code>/<code>column</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(..., cols = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_...">...</code></td>
<td>
<p><code>Numeric vectors</code> or a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="centroid_+3A_cols">cols</code></td>
<td>
<p>Names of columns to use when <code>`...`</code> is a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="centroid_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to ignore missing values when calculating means. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Means of the supplied <code>vectors</code>/<code>columns</code>. Either as a <code>vector</code> or a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other coordinate functions: 
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>,
<code><a href="#topic+is_most_centered">is_most_centered</a>()</code>,
<code><a href="#topic+midrange">midrange</a>()</code>,
<code><a href="#topic+most_centered">most_centered</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Find centroid coordinates
# Aka. the means of each vector
centroid(x, y, z)

#
# For data.frames
#

# Create data frame
df &lt;- data.frame(
  "x" = x,
  "y" = y,
  "z" = z,
  "g" = rep(1:2, each = 5)
)

# Find centroid coordinates
# Aka. the means of each column
centroid(df, cols = c("x", "y", "z"))

# When 'df' is grouped
df %&gt;%
  dplyr::group_by(g) %&gt;%
  centroid(cols = c("x", "y", "z"))
</code></pre>

<hr>
<h2 id='circularize'>Create x-coordinates so the points form a circle</h2><span id='topic+circularize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Create the x-coordinates for a <code>vector</code> of y-coordinates such that
they form a circle.
</p>
<p>This will likely look most like a circle when the y-coordinates are somewhat equally distributed,
e.g. a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circularize(
  data,
  y_col = NULL,
  .min = NULL,
  .max = NULL,
  offset_x = 0,
  keep_original = TRUE,
  x_col_name = ".circle_x",
  degrees_col_name = ".degrees",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circularize_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="circularize_+3A_y_col">y_col</code></td>
<td>
<p>Name of column in <code>`data`</code> with y-coordinates to create x-coordinates for.</p>
</td></tr>
<tr><td><code id="circularize_+3A_.min">.min</code></td>
<td>
<p>Minimum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="circularize_+3A_.max">.max</code></td>
<td>
<p>Maximum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="circularize_+3A_offset_x">offset_x</code></td>
<td>
<p>Value to offset the x-coordinates by.</p>
</td></tr>
<tr><td><code id="circularize_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="circularize_+3A_x_col_name">x_col_name</code></td>
<td>
<p>Name of new column with the x-coordinates.</p>
</td></tr>
<tr><td><code id="circularize_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the angles in degrees. If <code>NULL</code>, no column is added.
</p>
<p>Angling is counterclockwise around <code>(0, 0)</code> and starts at <code>(max(x), 0)</code>.</p>
</td></tr>
<tr><td><code id="circularize_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates (center of circle). If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="circularize_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the added x-coordinates and the angle in degrees.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other forming functions: 
<code><a href="#topic+hexagonalize">hexagonalize</a>()</code>,
<code><a href="#topic+square">square</a>()</code>,
<code><a href="#topic+triangularize">triangularize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "y" = runif(200),
  "g" = factor(rep(1:5, each = 40))
)

# Circularize 'y'
df_circ &lt;- circularize(df, y_col = "y")
df_circ

# Plot circle
if (has_ggplot){
  df_circ %&gt;%
    ggplot(aes(x = .circle_x, y = y, color = .degrees)) +
    geom_point() +
    theme_minimal()
}

#
# Grouped circularization
#

# Circularize 'y' for each group
# First cluster the groups a bit to move the
# circles away from each other
df_circ &lt;- df %&gt;%
  cluster_groups(
    cols = "y",
    group_cols = "g",
    suffix = "",
    overwrite = TRUE
  ) %&gt;%
  dplyr::group_by(g) %&gt;%
  circularize(
    y_col = "y",
    overwrite = TRUE
  )

# Plot circles
if (has_ggplot){
  df_circ %&gt;%
    ggplot(aes(x = .circle_x, y = y, color = g)) +
    geom_point() +
    theme_minimal()
}

#
# Specifying minimum value
#

# Specify minimum value manually
df_circ &lt;- circularize(df, y_col = "y", .min = -2)
df_circ

# Plot circle
if (has_ggplot){
  df_circ %&gt;%
    ggplot(aes(x = .circle_x, y = y, color = .degrees)) +
    geom_point() +
    theme_minimal()
}

#
# Multiple circles by contraction
#

# Start by circularizing 'y'
df_circ &lt;- circularize(df, y_col = "y")

# Contract '.circle_x' and 'y' towards the centroid
# To contract with multiple multipliers at once,
# we wrap the call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = 1:10 / 10,
  .f = function(mult) {
    expand_distances(
      data = df_circ,
      cols = c(".circle_x", "y"),
      multiplier = mult,
      origin_fn = centroid,
      overwrite = TRUE
    )
  }
)
df_expanded

if (has_ggplot){
  df_expanded %&gt;%
    ggplot(aes(
      x = .circle_x_expanded, y = y_expanded,
      color = .degrees, alpha = .multiplier
    )) +
    geom_point() +
    theme_minimal()
}

</code></pre>

<hr>
<h2 id='closest_to'>Orders values by shortest distance to an origin</h2><span id='topic+closest_to'></span><span id='topic+closest_to_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Values are ordered by how close they are to the origin.
</p>
<p>In 1d (when
<code>`cols`</code> has length <code>1</code>), the origin can be thought of as a target value.
In <em>n</em> dimensions, the origin can be thought of as coordinates.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and ordering the rows by
their distance to the centroid of each group.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>and <code>origin = 2</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(</code><strong><code>2</code></strong><code>, 1, 3, 4, 5)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_to(
  data,
  cols = NULL,
  origin = NULL,
  origin_fn = NULL,
  shuffle_ties = FALSE,
  origin_col_name = ".origin",
  distance_col_name = ".distance",
  overwrite = FALSE
)

closest_to_vec(data, origin = NULL, origin_fn = NULL, shuffle_ties = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_to_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="closest_to_+3A_cols">cols</code></td>
<td>
<p>Column(s) to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="closest_to_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to calculate distances to.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>`NULL`</code>.</p>
</td></tr>
<tr><td><code id="closest_to_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="closest_to_+3A_shuffle_ties">shuffle_ties</code></td>
<td>
<p>Whether to shuffle elements with the same distance to the origin. (Logical)</p>
</td></tr>
<tr><td><code id="closest_to_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="closest_to_+3A_distance_col_name">distance_col_name</code></td>
<td>
<p>Name of new column with the distances to the origin. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="closest_to_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Closest to 3 in a vector
closest_to_vec(1:10, origin = 3)

# Closest to the third row (index of data.frame)
closest_to(df, origin = 3)$index

# By each of the columns
closest_to(df, cols = "A", origin = 3)$A
closest_to(df, cols = "A", origin_fn = most_centered)$A
closest_to(df, cols = "B", origin = 0.5)$B
closest_to(df, cols = "B", origin_fn = centroid)$B

# Shuffle the elements with the same distance to the origin
closest_to(df,
  cols = "A",
  origin_fn = create_origin_fn(median),
  shuffle_ties = TRUE
)$A

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  closest_to(
    cols = "A",
    origin_fn = create_origin_fn(median)
  )

# Plot the rearranged values
plot(
  x = 1:10,
  y = closest_to(df,
    cols = "B",
    origin_fn = create_origin_fn(median)
  )$B,
  xlab = "Position",
  ylab = "B"
)
plot(
  x = 1:10,
  y = closest_to(df,
    cols = "A",
    origin_fn = create_origin_fn(median),
    shuffle_ties = TRUE
  )$A,
  xlab = "Position",
  ylab = "A"
)

# In multiple dimensions
df %&gt;%
  closest_to(cols = c("A", "B"), origin_fn = most_centered)
</code></pre>

<hr>
<h2 id='cluster_groups'>Move data points into clusters</h2><span id='topic+cluster_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Transform values such that the elements in each group move closer to their centroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_groups(
  data,
  cols,
  group_cols = NULL,
  scale_min_fn = function(x) {
     quantile(x, 0.025)
 },
  scale_max_fn = function(x) {
     quantile(x, 0.975)
 },
  keep_centroids = FALSE,
  multiplier = 0.05,
  suffix = "_clustered",
  keep_original = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_groups_+3A_data">data</code></td>
<td>
<p><code>data.frame</code>. If <code>`group_cols`</code> is <code>NULL</code>, it must be grouped with
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to mutate.
Each column is considered a dimension to contract distances in.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_group_cols">group_cols</code></td>
<td>
<p>Names of grouping columns in <code>`data`</code>. Must be distinct from the names in <code>`cols`</code>.
</p>
<p>If <code>NULL</code> and <code>`data`</code> is grouped, those groups are used instead.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_scale_min_fn">scale_min_fn</code>, <code id="cluster_groups_+3A_scale_max_fn">scale_max_fn</code></td>
<td>
<p>Function to find the minimum/maximum value in
the original data when rescaling the contracted data.
</p>
<p><strong>Input</strong>: A <code>numeric vector</code>.
</p>
<p><strong>Output</strong>: A <code>numeric scalar</code>.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_keep_centroids">keep_centroids</code></td>
<td>
<p>Whether to ensure the clusters have their original centroids. (Logical)</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_multiplier">multiplier</code></td>
<td>
<p>Numeric constant to multiply the distance to the group centroid by. A smaller value
makes the clusters more compact and vice versa.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="cluster_groups_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>Contracts the distance from each data point to the centroid of its group.
</p>
</li>
<li><p>Performs MinMax scaling such that the scale of the data points is <em>similar</em> to the original data.
</p>
</li>
<li><p>If enabled (not default), the centroids are moved to the original centroids.
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the clustered columns.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other clustering functions: 
<code><a href="#topic+generate_clusters">generate_clusters</a>()</code>,
<code><a href="#topic+transfer_centroids">transfer_centroids</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(2)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(50),
  "y" = runif(50),
  "z" = runif(50),
  "g" = rep(c(1, 2, 3, 4, 5), each = 10)
)

# Move the data points into clusters
cluster_groups(df,
  cols = c("x", "y"),
  group_col = "g"
)
cluster_groups(df,
  cols = c("x", "y"),
  group_col = "g",
  multiplier = 0.1
)
cluster_groups(df,
  cols = c("x"),
  group_col = "g",
  multiplier = 0.1
)

#
# Plotting clusters
#

# Cluster x and y for each group in g
df_clustered &lt;- cluster_groups(
  data = df,
  cols = c("x", "y"),
  group_col = "g"
)

# Plot the clusters over the original data points
# As we work with random data, the cluster might overlap
if (has_ggplot){
  ggplot(
    df_clustered,
    aes(x = x_clustered, y = y_clustered, color = factor(g))
  ) +
    # Original data
    geom_point(aes(x = x, y = y), alpha = 0.3, size = 0.8) +
    # Clustered data
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "g")
}

#
# Maintain original group centroids
#

df_clustered &lt;- cluster_groups(
  data = df,
  cols = c("x", "y"),
  group_col = "g",
  keep_centroids = TRUE
)

# Plot the clusters over the original data points
# As we work with random data, the cluster might overlap
if (has_ggplot){
  ggplot(
    df_clustered,
    aes(x = x_clustered, y = y_clustered, color = factor(g))
  ) +
    # Original data
    geom_point(aes(x = x, y = y), alpha = 0.3, size = 0.8) +
    # Clustered data
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "g")
}

#
# Three dimensions
#

# Cluster in 3d
df_clustered &lt;- cluster_groups(
  data = df,
  cols = c("x", "y", "z"),
  group_col = "g"
)

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_clustered$x_clustered,
  y = df_clustered$y_clustered,
  z = df_clustered$z_clustered,
  type = "scatter3d",
  mode = "markers",
  color = df_clustered$g
)

## End(Not run)
</code></pre>

<hr>
<h2 id='create_dimming_fn'>Create dimming_fn function</h2><span id='topic+create_dimming_fn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Creates a function that takes 2 inputs (<code>`x`</code>, <code>`d`</code>) and performs the operation:
</p>
<p style="text-align: center;"><code class="reqn">x * (numerator / ((add_to_distance + d) ^ exponent))</code>
</p>

<p>Here, <code>`x`</code> is the current value and <code>`d`</code> is its distance to an origin.
The greater the distance, the more we will dim the value of <code>`x`</code>.
</p>
<p>With the default values, the returned function is:
</p>
<p><code>function(x, d){</code>
</p>
<p><code style="white-space: pre;">&#8288;  &#8288;</code><code>x * (1 / ((1 + d) ^ 2))</code>
</p>
<p><code>}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dimming_fn(numerator = 1, exponent = 2, add_to_distance = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_dimming_fn_+3A_numerator">numerator</code></td>
<td>
<p>The numerator. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="create_dimming_fn_+3A_exponent">exponent</code></td>
<td>
<p>The exponent. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="create_dimming_fn_+3A_add_to_distance">add_to_distance</code></td>
<td>
<p>Constant to add to the distance before exponentiation.
Ensures dimming even when the distance (<code>d</code>) is below <code>1</code>. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with the arguments <code>x</code> and <code>d</code>,
with both expected to be <code>numeric vector</code>s. More specifically:
</p>
<p><code>function(x, d){</code>
</p>
<p><code style="white-space: pre;">&#8288;  &#8288;</code><code>x * (numerator / ((add_to_distance + d) ^ exponent))</code>
</p>
<p><code>}</code>
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other function creators: 
<code><a href="#topic+create_n_fn">create_n_fn</a>()</code>,
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create two vectors
x &lt;- runif(10)
d &lt;- runif(10, max = 0.5)

# Create dimming_fn with an add_to_distance of 0
# Note: In practice this risks zero-division
non_smoothed_dimming_fn &lt;- create_dimming_fn(add_to_distance = 0)
non_smoothed_dimming_fn
as.list(environment(non_smoothed_dimming_fn))

# Use median_origin_fn
non_smoothed_dimming_fn(x, d)

# Plotting the dimming

# Create data.frame with distance-based dimming
df &lt;- data.frame(
  "x" = 1,
  "d" = 1:10
)
df$x_dimmed &lt;- non_smoothed_dimming_fn(df$x, df$d)

# Plot the dimming
if (has_ggplot){
  ggplot(df, aes(x=d, y=x_dimmed)) +
    geom_point() +
    geom_line() +
    theme_minimal()
}
</code></pre>

<hr>
<h2 id='create_n_fn'>Create n_fn function</h2><span id='topic+create_n_fn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Creates a function that applies a supplied function to all
input vectors, or their indices, and rounds the results.
</p>
<p>As used with <code><a href="#topic+roll_elements">roll_elements()</a></code>. E.g. to
find the the median index in a subset of a grouped <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_n_fn(fn, use_index = FALSE, negate = FALSE, round_fn = round, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_n_fn_+3A_fn">fn</code></td>
<td>
<p>Function to apply to each dimension. Should return a numeric scalar.</p>
</td></tr>
<tr><td><code id="create_n_fn_+3A_use_index">use_index</code></td>
<td>
<p>Whether to apply <code>`fn`</code> to the <em>indices</em> of the vectors. (Logical)
</p>
<p>The indices are created with <code>seq_along(x)</code>.</p>
</td></tr>
<tr><td><code id="create_n_fn_+3A_negate">negate</code></td>
<td>
<p>Whether to negate the result. I.e. to multiply it with <code>-1</code>. (Logical)</p>
</td></tr>
<tr><td><code id="create_n_fn_+3A_round_fn">round_fn</code></td>
<td>
<p>Function for rounding results of <code>`fn`</code>.
</p>
<p>Rounding is done <em>prior</em> to negation.
</p>
<p>E.g. <code><a href="base.html#topic+Round">round</a></code>, <code><a href="base.html#topic+Round">floor</a></code>, or <code><a href="base.html#topic+Round">ceiling</a></code>.
</p>
<p>To avoid rounding, supply <code><a href="base.html#topic+identity">identity</a></code>.</p>
</td></tr>
<tr><td><code id="create_n_fn_+3A_...">...</code></td>
<td>
<p>Arguments for <code>`fn`</code>. E.g. <code>`na.rm = TRUE`</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with the dots (<code>`...`</code>) argument
that applies the <code>`fn`</code> function to
each element in <code>`...`</code> (or indices thereof) (usually one vector per dimension).
The results are rounded with <code>`round_fn`</code>.
</p>
<p>Note: The dots argument in the generated function should not to be confused with the dots
argument in <code>create_n_fn()</code>).
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other n functions: 
<code><a href="#topic+median_index">median_index</a>()</code>
</p>
<p>Other function creators: 
<code><a href="#topic+create_dimming_fn">create_dimming_fn</a>()</code>,
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Create n_fn that gets the median index
# and rounds down with floor()
median_index_fn &lt;- create_n_fn(median, use_index = TRUE, round_fn = floor)

# Use median_index_fn
median_index_fn(x, y, z)

# Create n_fn that gets the median of each dimension
median_n_fn &lt;- create_n_fn(median)

# Use median_origin_fn
median_n_fn(x, y, z)

# Should be the same as
round(c(median(x), median(y), median(z)))

# Use mean and ignore missing values
mean_n_fn &lt;- create_n_fn(mean, na.rm = TRUE)

# Add missing values
x[[2]] &lt;- NA
y[[5]] &lt;- NA

# Use mean_n_fn
mean_n_fn(x, y, z)

# Should be the same as
round(c(
  mean(x, na.rm = TRUE),
  mean(y, na.rm = TRUE),
  mean(z, na.rm = TRUE)
))
</code></pre>

<hr>
<h2 id='create_origin_fn'>Create origin_fn function</h2><span id='topic+create_origin_fn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Creates a function that applies a supplied function to all input vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_origin_fn(fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_origin_fn_+3A_fn">fn</code></td>
<td>
<p>Function to apply to each dimension. Should return a numeric scalar.</p>
</td></tr>
<tr><td><code id="create_origin_fn_+3A_...">...</code></td>
<td>
<p>Arguments for <code>`fn`</code>. E.g. <code>`na.rm = TRUE`</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function with the dots (<code>...</code>) argument that applies the <code>`fn`</code> function to
each element in <code>...</code> (usually one vector per dimension).
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other coordinate functions: 
<code><a href="#topic+centroid">centroid</a>()</code>,
<code><a href="#topic+is_most_centered">is_most_centered</a>()</code>,
<code><a href="#topic+midrange">midrange</a>()</code>,
<code><a href="#topic+most_centered">most_centered</a>()</code>
</p>
<p>Other function creators: 
<code><a href="#topic+create_dimming_fn">create_dimming_fn</a>()</code>,
<code><a href="#topic+create_n_fn">create_n_fn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Create origin_fn that gets the median of each dimension
median_origin_fn &lt;- create_origin_fn(median)

# Use median_origin_fn
median_origin_fn(x, y, z)

# Should be the same as
c(median(x), median(y), median(z))

# Use mean and ignore missing values
mean_origin_fn &lt;- create_origin_fn(mean, na.rm = TRUE)

# Add missing values
x[[2]] &lt;- NA
y[[5]] &lt;- NA

# Use mean_origin_fn
mean_origin_fn(x, y, z)

# Should be the same as
c(mean(x, na.rm = TRUE),
  mean(y, na.rm = TRUE),
  mean(z, na.rm = TRUE)
)
</code></pre>

<hr>
<h2 id='degrees_to_radians'>Conversion between radians and degrees</h2><span id='topic+degrees_to_radians'></span><span id='topic+radians_to_degrees'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Convert degrees to radians or radians to degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degrees_to_radians(degrees)

radians_to_degrees(radians)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrees_to_radians_+3A_degrees">degrees</code></td>
<td>
<p><code>vector</code> of degrees to convert to radians with </p>
<p style="text-align: center;"><code class="reqn">`degrees` * (\pi / 180)</code>
</p>
</td></tr>
<tr><td><code id="degrees_to_radians_+3A_radians">radians</code></td>
<td>
<p><code>vector</code> of radians to convert to degrees with </p>
<p style="text-align: center;"><code class="reqn">`radians` / (\pi / 180)</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vector</code> with converted degrees/radians.
</p>
<p>Missing values (<code>NA</code>s) are returned as they are.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Degrees to radians
degrees_to_radians(c(90, 180, 270))

# Radians to degrees
radians_to_degrees(c(pi / 2, pi, 1.5 * pi))

# Get back the original degrees
radians_to_degrees(degrees_to_radians(c(90, 180, 270)))
</code></pre>

<hr>
<h2 id='dim_values'>Dim values of a dimension based on the distance to an n-dimensional origin</h2><span id='topic+dim_values'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Dims the values in the dimming dimension (last by default)
based on the data point's distance to the origin.
</p>
<p>Distance is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">d(P1, P2) = sqrt( (x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2 + ... )</code>
</p>

<p>The default <code>`dimming_fn`</code> multiplies by the inverse-square of
<code class="reqn">1 + distance</code> and is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">dimming_fn(x, d) = x * (1 / (1 + d) ^ 2)</code>
</p>

<p>Where <code class="reqn">x</code> is the value in the dimming dimension. The <code class="reqn">+1</code> is added
to ensure that values are dimmed even when the distance is below <code>1</code>. The quickest
way to change the exponent or the <code class="reqn">+1</code> is with
<code><a href="#topic+create_dimming_fn">create_dimming_fn()</a></code>.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and dimming around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_values(
  data,
  cols,
  dimming_fn = create_dimming_fn(numerator = 1, exponent = 2, add_to_distance = 1),
  origin = NULL,
  origin_fn = NULL,
  dim_col = tail(cols, 1),
  suffix = "_dimmed",
  keep_original = TRUE,
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_values_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to calculate distances from.
The dimming column (<code>`dim_col`</code>) is dimmed based on all the columns.
Each column is considered a dimension.
</p>
<p><strong>N.B.</strong> when the dimming dimension is included in <code>`cols`</code>,
it is used in the distance calculation as well.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_dimming_fn">dimming_fn</code></td>
<td>
<p><code>Function</code> for calculating the dimmed values.
</p>
<p><strong>Input</strong>: Two (2) input arguments:
</p>

<ol>
<li><p> A <code>numeric vector</code> with the values in the dimming dimension.
</p>
</li>
<li><p> A <code>numeric vector</code> with corresponding distances to the origin.
</p>
</li></ol>

<p><strong>Output</strong>: A <code>numeric vector</code> with the same length as the input vectors.
</p>
<p>E.g.:
</p>
<p><code>function(x, d){</code>
</p>
<p><code style="white-space: pre;">&#8288;  &#8288;</code><code>x * (1 / ((1 + d) ^ 2))</code>
</p>
<p><code>}</code>
</p>
<p>This kind of dimming function can be created with
<code><a href="#topic+create_dimming_fn">create_dimming_fn()</a></code>,
which for instance makes it easy to change the exponent (the <code>2</code> above).</p>
</td></tr>
<tr><td><code id="dim_values_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to dim around.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="dim_values_+3A_dim_col">dim_col</code></td>
<td>
<p>Name of column to dim. Default is the last column in <code>`cols`</code>.
</p>
<p>When the <code>`dim_col`</code> is not present in <code>`cols`</code>, it is not used in the distance calculation.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="dim_values_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Calculates distances to origin with: </p>
<p style="text-align: center;"><code class="reqn">d(P1, P2) = sqrt( (x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2 + ... )</code>
</p>

</li>
<li><p> Applies the <code>`dimming_fn`</code> to the <code>`dim_col`</code> based on the distances.
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the dimmed column,
along with the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(7)

# Create a data frame with clusters
df &lt;- generate_clusters(
  num_rows = 70,
  num_cols = 3,
  num_clusters = 5,
  compactness = 1.6
) %&gt;%
  dplyr::rename(x = D1, y = D2, z = D3) %&gt;%
  dplyr::mutate(o = 1)

# Dim the values in the z column
dim_values(
  data = df,
  cols = c("x", "y", "z"),
  origin = c(0.5, 0.5, 0.5)
)

# Dim the values in the `o` column (all 1s)
# around the centroid
dim_values(
  data = df,
  cols = c("x", "y"),
  dim_col = "o",
  origin_fn = centroid
)

# Specify dimming_fn
# around the centroid
dim_values(
  data = df,
  cols = c("x", "y"),
  dim_col = "o",
  origin_fn = centroid,
  dimming_fn = function(x, d) {
    x * 1 / (2^(1 + d))
  }
)

#
# Dim cluster-wise
#

# Group-wise dimming
df_dimmed &lt;- df %&gt;%
  dplyr::group_by(.cluster) %&gt;%
  dim_values(
    cols = c("x", "y"),
    dim_col = "o",
    origin_fn = centroid
  )

# Plot the dimmed data such that the alpha (opacity) is
# controlled by the dimming
# (Note: This works because the `o` column is 1 for all values)
if (has_ggplot){
  ggplot(
    data = df_dimmed,
    aes(x = x, y = y, alpha = o_dimmed, color = .cluster)
  ) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Cluster", alpha = "o_dimmed")
}
</code></pre>

<hr>
<h2 id='distance'>Calculate the distance to an origin</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the distance to the specified origin with:
</p>
<p style="text-align: center;"><code class="reqn">d(P1, P2) = sqrt( (x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2 + ... )</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and finding the distance to e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(
  data,
  cols = NULL,
  origin = NULL,
  origin_fn = NULL,
  distance_col_name = ".distance",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="distance_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to measure distance in.
Each column is considered a dimension.</p>
</td></tr>
<tr><td><code id="distance_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to calculate distances to.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distance_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="distance_+3A_distance_col_name">distance_col_name</code></td>
<td>
<p>Name of new column with the distances.</p>
</td></tr>
<tr><td><code id="distance_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="distance_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the additional columns (distances and origin coordinates).
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other measuring functions: 
<code><a href="#topic+angle">angle</a>()</code>,
<code><a href="#topic+vector_length">vector_length</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Calculate distances in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
distance(
  data = df,
  cols = c("x", "y"),
  origin = c(0.5, 0.5)
)

# Calculate distances to the centroid for each group in 'g'
distance(
  data = dplyr::group_by(df, g),
  cols = c("x", "y"),
  origin_fn = centroid
)
</code></pre>

<hr>
<h2 id='expand_distances'>Expand the distances to an origin</h2><span id='topic+expand_distances'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Moves the data points in n-dimensional space such that their distance
to a specified origin is increased/decreased.
A <code>`multiplier`</code> greater than 1 leads to expansion,
while a positive <code>`multiplier`</code> lower than 1 leads to contraction.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and expanding around e.g. the centroid
of each group.
</p>
<p>The multiplier/exponent can be supplied as a constant or as a function that returns a constant.
The latter can be useful when supplying a grouped <code>data.frame</code> and the multiplier/exponent depends
on the data in the groups.
</p>
<p>For expansion in each dimension separately, use <code><a href="#topic+expand_distances_each">expand_distances_each()</a></code>.
</p>
<p><strong>NOTE</strong>: When exponentiating, the default is to first add <code>1</code> to the distances,
to ensure expansion even when the distance is between <code>0</code> and <code>1</code>.
If you need the purely exponentiated distances,
disable <code>`add_one_exp`</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_distances(
  data,
  cols = NULL,
  multiplier = NULL,
  multiplier_fn = NULL,
  origin = NULL,
  origin_fn = NULL,
  exponentiate = FALSE,
  add_one_exp = TRUE,
  suffix = "_expanded",
  keep_original = TRUE,
  mult_col_name = ifelse(isTRUE(exponentiate), ".exponent", ".multiplier"),
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_distances_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to expand coordinates of.
Each column is considered a dimension.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_multiplier">multiplier</code></td>
<td>
<p>Constant to multiply/exponentiate the distances to the origin by.
</p>
<p><strong>N.B.</strong> When <code>`exponentiate`</code> is <code>TRUE</code>, the <code>`multiplier`</code> becomes an <em>exponent</em>.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_multiplier_fn">multiplier_fn</code></td>
<td>
<p>Function for finding the <code>`multiplier`</code>.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>numeric scalar</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to expand around.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="expand_distances_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Whether to exponentiate instead of multiplying. (Logical)</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_add_one_exp">add_one_exp</code></td>
<td>
<p>Whether to add <code>1</code> to the distances
before exponentiating to ensure they don't contract when between <code>0</code> and <code>1</code>.
The added value is subtracted after the exponentiation. (Logical)
</p>
<p>The distances to the origin (<code>`d`</code>) are exponentiated as such:
</p>
<p><code>d &lt;- d + 1</code>
</p>
<p><code>d &lt;- d ^ multiplier</code>
</p>
<p><code>d &lt;- d - 1</code>
</p>
<p><strong>N.B.</strong> Ignored when <code>`exponentiate`</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_mult_col_name">mult_col_name</code></td>
<td>
<p>Name of new column with the <code>`multiplier`</code>.
If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates.
If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="expand_distances_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Increases the distance to the origin in n-dimensional space by
multiplying or exponentiating it by the multiplier.
</p>
<p>We first move the origin to the zero-coordinates (e.g. <code>c(0, 0, 0)</code>)
and normalize each vector to unit length. We then multiply this unit vector by the
multiplied/exponentiated distance and moves the origin back to its original coordinates.
</p>
<p>The distance to the specified origin is calculated with:
</p>
<p style="text-align: center;"><code class="reqn">d(P1, P2) = sqrt( (x2 - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2 + ... )</code>
</p>

<p>Note: By default (when <code>`add_one_exp`</code> is <code>TRUE</code>),
we add <code>1</code> to the distance before the exponentiation
and subtract it afterwards. See <code>`add_one_exp`</code>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the expanded columns,
along with the applied multiplier/exponent and origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other expander functions: 
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Expand distances in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
# We multiply the distances by 2
expand_distances(
  data = df,
  cols = c("x", "y"),
  multiplier = 2,
  origin = c(0.5, 0.5)
)

# Expand distances in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
# We exponentiate the distances by 2
expand_distances(
  data = df,
  cols = c("x", "y"),
  multiplier = 2,
  exponentiate = TRUE,
  origin = 0.5
)

# Expand values in one dimension (x)
# With the origin at x=0.5
# We exponentiate the distances by 3
expand_distances(
  data = df,
  cols = c("x"),
  multiplier = 3,
  exponentiate = TRUE,
  origin = 0.5
)

# Expand x and y around the centroid
# We use exponentiation for a more drastic effect
# The add_one_exp makes sure it expands
# even when x or y is in the range [0, &lt;1]
# To compare multiple exponents, we wrap the
# call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 3, 5),
  .f = function(exponent) {
    expand_distances(
      data = df,
      cols = c("x", "y"),
      multiplier = exponent,
      origin_fn = centroid,
      exponentiate = TRUE,
      add_one_exp = TRUE
    )
  }
)
df_expanded

# Plot the expansions of x and y around the overall centroid
if (has_ggplot){
  ggplot(df_expanded, aes(x = x_expanded, y = y_expanded, color = factor(.exponent))) +
    geom_vline(
      xintercept = df_expanded[[".origin"]][[1]][[1]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_hline(
      yintercept = df_expanded[[".origin"]][[1]][[2]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_path(size = 0.2) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Exponent")
}

# Expand x and y around the centroid using multiplication
# To compare multiple multipliers, we wrap the
# call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 3, 5),
  .f = function(multiplier) {
    expand_distances(df,
      cols = c("x", "y"),
      multiplier = multiplier,
      origin_fn = centroid,
      exponentiate = FALSE
    )
  }
)
df_expanded

# Plot the expansions of x and y around the overall centroid
if (has_ggplot){
  ggplot(df_expanded, aes(x = x_expanded, y = y_expanded, color = factor(.multiplier))) +
    geom_vline(
      xintercept = df_expanded[[".origin"]][[1]][[1]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_hline(
      yintercept = df_expanded[[".origin"]][[1]][[2]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_path(size = 0.2, alpha = .8) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Multiplier")
}

#
# Contraction
#

# Group-wise contraction to create clusters
df_contracted &lt;- df %&gt;%
  dplyr::group_by(g) %&gt;%
  expand_distances(
    cols = c("x", "y"),
    multiplier = 0.07,
    suffix = "_contracted",
    origin_fn = centroid
  )

# Plot the clustered data point on top of the original data points
if (has_ggplot){
  ggplot(df_contracted, aes(x = x_contracted, y = y_contracted, color = factor(g))) +
    geom_point(aes(x = x, y = y, color = factor(g)), alpha = 0.3, shape = 16) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "g")
}
</code></pre>

<hr>
<h2 id='expand_distances_each'>Expand the distances to an origin in each dimension</h2><span id='topic+expand_distances_each'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Moves the data points in n-dimensional space such that their distance
to the specified origin is increased/decreased <em>in each dimension separately</em>.
A <code>`multiplier`</code> greater than 1 leads to expansion,
while a positive <code>`multiplier`</code> lower than 1 leads to contraction.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and expanding around e.g. the centroid
of each group.
</p>
<p>The multipliers/exponents can be supplied as constant(s) or as a function that returns constants.
The latter can be useful when supplying a grouped <code>data.frame</code> and the multiplier/exponent depends
on the data in the groups.
If supplying multiple constants, there must be one per dimension (length of <code>`cols`</code>).
</p>
<p>For expansion of the <em>multidimensional</em> distance, use <code><a href="#topic+expand_distances_each">expand_distances()</a></code>.
</p>
<p><strong>NOTE</strong>: When exponentiating, the default is to first add <code>1</code> or <code>-1</code>
(depending on the sign of the distance) to the distances,
to ensure expansion even when the distance is between <code>-1</code> and <code>1</code>.
If you need the purely exponentiated distances,
disable <code>`add_one_exp`</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_distances_each(
  data,
  cols = NULL,
  multipliers = NULL,
  multipliers_fn = NULL,
  origin = NULL,
  origin_fn = NULL,
  exponentiate = FALSE,
  add_one_exp = TRUE,
  suffix = "_expanded",
  keep_original = TRUE,
  mult_col_name = ifelse(isTRUE(exponentiate), ".exponents", ".multipliers"),
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_distances_each_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to expand.
Each column is considered a dimension to expand in.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_multipliers">multipliers</code></td>
<td>
<p>Constant(s) to multiply/exponentiate the distance to the origin by.
A scalar to use in all dimensions or
a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> When <code>`exponentiate`</code> is <code>TRUE</code>, the <code>`multipliers`</code> become <em>exponents</em>.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_multipliers_fn">multipliers_fn</code></td>
<td>
<p>Function for finding the <code>`multipliers`</code>.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>numeric vector</code> with one element per dimension.
</p>
<p>Just as for <code>`origin_fn`</code>, it can be created with
<code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension. See <code>`origin_fn`</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to expand around.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Whether to exponentiate instead of multiplying. (Logical)</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_add_one_exp">add_one_exp</code></td>
<td>
<p>Whether to add the <code>sign</code> (either <code>1</code> or <code>-1</code>)
before exponentiating to ensure the values don't contract.
The added value is subtracted after the exponentiation. (Logical)
</p>
<p>Exponentiation becomes:
</p>
<p><code>x &lt;- x + sign(x)</code>
</p>
<p><code>x &lt;- sign(x) * abs(x) ^ multiplier</code>
</p>
<p><code>x &lt;- x - sign(x)</code>
</p>
<p><strong>N.B.</strong> Ignored when <code>`exponentiate`</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_mult_col_name">mult_col_name</code></td>
<td>
<p>Name of new column with the multiplier(s). If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="expand_distances_each_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each value of each dimension (column), either multiply or exponentiate by the multiplier:
</p>
<p><code># Multiplication</code>
</p>
<p><code>x &lt;- x * multiplier</code>
</p>
<p><code># Exponentiation</code>
</p>
<p><code>x &lt;- sign(x) * abs(x) ^ multiplier</code>
</p>
<p>Note: By default (when <code>`add_one_exp`</code> is <code>TRUE</code>),
we add the sign (<code>1 / -1</code>) of the value before the exponentiation
and subtract it afterwards. See <code>`add_one_exp`</code>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the expanded columns,
along with the applied multiplier/exponent and origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other expander functions: 
<code><a href="#topic+expand_distances">expand_distances</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Expand values in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
# We expand x by 2 and y by 4
expand_distances_each(
  data = df,
  cols = c("x", "y"),
  multipliers = c(2, 4),
  origin = c(0.5, 0.5)
)

# Expand values in the two dimensions (x and y)
# With the origin at x=0.5, y=0.5
# We expand both by 3
expand_distances_each(
  data = df,
  cols = c("x", "y"),
  multipliers = 3,
  origin = 0.5
)

# Expand values in one dimension (x)
# With the origin at x=0.5
# We expand by 3
expand_distances_each(
  data = df,
  cols = c("x"),
  multipliers = 3,
  origin = 0.5
)

# Expand x and y around the centroid
# We use exponentiation for a more drastic effect
# The add_one_exp makes sure it expands
# even when x or y is in the range [&gt;-1, &lt;1]
# To compare multiple exponents, we wrap the
# call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 2.0, 3.0, 4.0),
  .f = function(exponent) {
    expand_distances_each(
      data = df,
      cols = c("x", "y"),
      multipliers = exponent,
      origin_fn = centroid,
      exponentiate = TRUE,
      add_one_exp = TRUE
    )
  }
)
df_expanded

# Plot the expansions of x and y around the overall centroid
if (has_ggplot){
  ggplot(df_expanded, aes(x = x_expanded, y = y_expanded, color = factor(.exponents))) +
    geom_vline(
      xintercept = df_expanded[[".origin"]][[1]][[1]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_hline(
      yintercept = df_expanded[[".origin"]][[1]][[2]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Exponent")
}

# Expand x and y around the centroid using multiplication
# To compare multiple multipliers, we wrap the
# call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 2.0, 3.0, 4.0),
  .f = function(multiplier) {
    expand_distances_each(df,
      cols = c("x", "y"),
      multipliers = multiplier,
      origin_fn = centroid,
      exponentiate = FALSE
    )
  }
)
df_expanded

# Plot the expansions of x and y around the overall centroid
if (has_ggplot){
ggplot(df_expanded, aes(x = x_expanded, y = y_expanded, color = factor(.multipliers))) +
    geom_vline(
      xintercept = df_expanded[[".origin"]][[1]][[1]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_hline(
      yintercept = df_expanded[[".origin"]][[1]][[2]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Multiplier")
}

# Expand x and y with different multipliers
# around the centroid using multiplication
df_expanded &lt;- expand_distances_each(
  df,
  cols = c("x", "y"),
  multipliers = c(1.25, 10),
  origin_fn = centroid,
  exponentiate = FALSE
)
df_expanded

# Plot the expansions of x and y around the overall centroid
# Note how the y axis is expanded a lot more than the x-axis
if (has_ggplot){
  ggplot(df_expanded, aes(x = x_expanded, y = y_expanded)) +
    geom_vline(
      xintercept = df_expanded[[".origin"]][[1]][[1]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_hline(
      yintercept = df_expanded[[".origin"]][[1]][[2]],
      size = 0.2, alpha = .4, linetype = "dashed"
    ) +
    geom_line(aes(color = "Expanded")) +
    geom_point(aes(color = "Expanded")) +
    geom_line(aes(x = x, y = y, color = "Original")) +
    geom_point(aes(x = x, y = y, color = "Original")) +
    theme_minimal() +
    labs(x = "x", y = "y", color = "Multiplier")
}

#
# Contraction
#

# Group-wise contraction to create clusters
df_contracted &lt;- df %&gt;%
  dplyr::group_by(g) %&gt;%
  expand_distances_each(
    cols = c("x", "y"),
    multipliers = 0.07,
    suffix = "_contracted",
    origin_fn = centroid
  )

# Plot the clustered data point on top of the original data points
if (has_ggplot){
  ggplot(df_contracted, aes(x = x_contracted, y = y_contracted, color = factor(g))) +
    geom_point(aes(x = x, y = y, color = factor(g)), alpha = 0.3, shape = 16) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "g")
}
</code></pre>

<hr>
<h2 id='extreme_pairing_rearranger_'>Wrapper for running extreme pairing</h2><span id='topic+extreme_pairing_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running extreme pairing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extreme_pairing_rearranger_(
  data,
  col = NULL,
  unequal_method = "middle",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_pairs = FALSE,
  num_pairings = 1,
  balance = "mean",
  factor_name = ".pair",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme_pairing_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_unequal_method">unequal_method</code></td>
<td>
<p>Method for dealing with an
unequal number of rows/elements in <code>`data`</code>.
</p>
<p>One of: <code>first</code>, <code>middle</code> or <code>last</code>
</p>


<h4>first</h4>

<p>The first group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 3, 3, 2)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 5, 3, 4)</code>
</p>



<h4>middle</h4>

<p>The middle group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 3, </code><strong><code>2</code></strong><code>, 3, 1)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 5, </code> <strong><code>3</code></strong><code>, 2, 4)</code>
</p>



<h4>last</h4>

<p>The last group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 2, 2, 1, </code><strong><code>3</code></strong><code>)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 4, 2, 3,</code> <strong><code>5</code></strong><code>)</code>
</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_order_by_aggregates">order_by_aggregates</code></td>
<td>
<p>Whether to order the pairs from initial pairings (first <code>`num_pairings` - 1</code>)
by their aggregate values instead of their pair identifiers.
</p>
<p>N.B. Only used when <code>`num_pairings` &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_shuffle_members">shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_shuffle_pairs">shuffle_pairs</code></td>
<td>
<p>Whether to shuffle the order of the pairs. Pair members remain together. (Logical)</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_num_pairings">num_pairings</code></td>
<td>
<p>Number of pairings to perform (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary pairings perform extreme pairing on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the pair elements.</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_balance">balance</code></td>
<td>
<p>What to balance pairs for in a given <em>secondary</em> pairing.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary pairings
or one for each secondary pairing (<code>`num_pairings` - 1</code>).
</p>
<p>The first pairing always pairs the actual element values.
</p>


<h4>mean</h4>

<p>Pairs have similar means. The values in the pairs from the previous pairing
are aggregated with <code>`sum()`</code> and paired.
</p>



<h4>spread</h4>

<p>Pairs have similar spread (e.g. standard deviations).
The values in the pairs from the previous pairing
are aggregated with <code>`sum(abs(diff()))`</code> and paired.
</p>



<h4>min / max</h4>

<p>Pairs have similar minimum / maximum values. The values in the pairs from the previous pairing
are aggregated with <code>`min()`</code> / <code>`max()`</code> and paired.
</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_factor_name">factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="extreme_pairing_rearranger__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor(s) added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`factor_name`</code> is <code>`NULL`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>

<hr>
<h2 id='extreme_triplet_grouping_rearranger_'>Wrapper for running extreme triplet grouping</h2><span id='topic+extreme_triplet_grouping_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running extreme triplet grouping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extreme_triplet_grouping_rearranger_(
  data,
  col = NULL,
  middle_is = "middle",
  unequal_method_1 = "middle",
  unequal_method_2 = c("middle", "middle"),
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_triplets = FALSE,
  num_groupings = 1,
  balance = "mean",
  factor_name = ".triplet",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_middle_is">middle_is</code></td>
<td>
<p>Whether the middle element in the triplet is the nth closest element
to the median value or the nth+1 lowest/highest value.
</p>
<p>One of: <code>middle</code> (default), <code>min</code>, or <code>max</code>.
</p>
<p>Triplet grouping is performed greedily from the most extreme values to the least extreme
values. E.g. <code>c(1, 6, 12)</code> is created before <code>c(2, 5, 11)</code> which is made
before <code>c(3, 7, 10)</code>.
</p>
<p><strong>Examples</strong>:
</p>
<p>When <code>`middle_is` == 'middle'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 6, 12), c(2, 7, 11), c(3, 5, 10),  c(4, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'min'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 2, 12), c(3, 4, 11), c(5, 6, 10),  c(7, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'max'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 11, 12), c(2, 9, 10), c(3, 7, 8),  c(4, 5, 6) )</code></p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_order_by_aggregates">order_by_aggregates</code></td>
<td>
<p>Whether to order the groups from initial groupings (first <code>`num_groupings` - 1</code>)
by their aggregate values instead of their group identifiers.
</p>
<p>N.B. Only used when <code>`num_groupings` &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_shuffle_members">shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_shuffle_triplets">shuffle_triplets</code></td>
<td>
<p>Whether to shuffle the order of the triplets. Triplet members remain together. (Logical)</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_num_groupings">num_groupings</code></td>
<td>
<p>Number of times to group into triplets (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary groupings perform extreme triplet grouping on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the triplet elements.</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_balance">balance</code></td>
<td>
<p>What to balance triplets for in a given <em>secondary</em> triplet grouping.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary groupings
or one for each secondary grouping (<code>`num_groupings` - 1</code>).
</p>
<p>The first triplet grouping always groups the actual element values.
</p>


<h4>mean</h4>

<p>Triplets have similar means. The values in the triplets from the previous grouping
are aggregated with <code>`sum()`</code> and extreme triplet grouped.
</p>



<h4>spread</h4>

<p>Triplets have similar spread (e.g. standard deviations). The values in the triplets
from the previous triplet grouping are aggregated with <code>`sum(abs(diff()))`</code> and
extreme triplet grouped.
</p>



<h4>min / max</h4>

<p>Triplets have similar minimum / maximum values. The values in the triplets from the
previous triplet grouping are aggregated with <code>`min()`</code> / <code>`max()`</code> and extreme
triplet grouped.
</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_factor_name">factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="extreme_triplet_grouping_rearranger__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor(s) added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`factor_name`</code> is <code>`NULL`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>

<hr>
<h2 id='FixedGroupsPipeline'>Chain multiple transformations with different argument values per group</h2><span id='topic+FixedGroupsPipeline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Build a pipeline of transformations to be applied sequentially.
</p>
<p>Specify different argument values for each group in a fixed set of groups.
E.g. if your <code>data.frame</code> contains 5 groups, you provide 5 argument values
for each of the non-constant arguments (see <code>`var_args`</code>).
</p>
<p>The number of expected groups is specified during initialization and the input
<code>`data`</code> must be grouped such that it contains that exact number of groups.
</p>
<p>Transformations are applied to groups separately, why the given transformation function
only receives the subset of <code>`data`</code> belonging to the current group.
</p>
<p><strong>Standard workflow</strong>: Instantiate pipeline -&gt; Add transformations -&gt; Apply to data
</p>
<p>To apply the same arguments to all groups, see
<code><a href="#topic+Pipeline">Pipeline</a></code>.
</p>
<p>To apply generated argument values to an arbitrary number of groups,
see <code><a href="#topic+GeneratedPipeline">GeneratedPipeline</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Pipeline">rearrr::Pipeline</a></code> -&gt; <code>FixedGroupsPipeline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>transformations</code></dt><dd><p><code>list</code> of transformations to apply.</p>
</dd>
<dt><code>names</code></dt><dd><p>Names of the transformations.</p>
</dd>
<dt><code>num_groups</code></dt><dd><p>Number of groups the pipeline will be applied to.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FixedGroupsPipeline-new"><code>FixedGroupsPipeline$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsPipeline-add_transformation"><code>FixedGroupsPipeline$add_transformation()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsPipeline-apply"><code>FixedGroupsPipeline$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsPipeline-print"><code>FixedGroupsPipeline$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsPipeline-clone"><code>FixedGroupsPipeline$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FixedGroupsPipeline-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the pipeline with the number of groups the
pipeline will be applied to.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsPipeline$new(num_groups)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num_groups</code></dt><dd><p>Number of groups the pipeline will be applied to.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FixedGroupsPipeline-add_transformation"></a>



<h4>Method <code>add_transformation()</code></h4>

<p>Add a transformation to the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsPipeline$add_transformation(fn, args, var_args, name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Function that performs the transformation.</p>
</dd>
<dt><code>args</code></dt><dd><p>Named <code>list</code> with arguments for the <code>`fn`</code> function.</p>
</dd>
<dt><code>var_args</code></dt><dd><p>Named <code>list</code> of arguments with <code>list</code> of differing
values for each group.
</p>
<p>E.g. <code>list("a" = list(1, 2, 3), "b" = list("a", "b", "c"))</code> given 3 groups.
</p>
<p>By adding <code>".apply"</code> with a list of <code>TRUE</code>/<code>FALSE</code> flags, the transformation
can be disabled for a specific group.
</p>
<p>E.g. <code>list(".apply" = list(TRUE, FALSE, TRUE), ...</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the transformation step. Must be unique.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-FixedGroupsPipeline-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Apply the pipeline to a <code>data.frame</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsPipeline$apply(data, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame</code> with the same number of groups as pre-registered
in the pipeline.
</p>
<p>You can find the number of groups in <code>`data`</code> with <code>`dplyr::n_groups(data)`</code>.
The number of groups expected by the pipeline can be accessed with <code>`pipe$num_groups`</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Whether to print the progress.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Transformed version of <code>`data`</code>.
</p>


<hr>
<a id="method-FixedGroupsPipeline-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsPipeline$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-FixedGroupsPipeline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsPipeline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other pipelines: 
<code><a href="#topic+GeneratedPipeline">GeneratedPipeline</a></code>,
<code><a href="#topic+Pipeline">Pipeline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach package
library(rearrr)
library(dplyr)

# Create a data frame
# We group it by G so we have 3 groups
df &lt;- data.frame(
  "Index" = 1:12,
  "A" = c(1:4, 9:12, 15:18),
  "G" = rep(1:3, each = 4)
) %&gt;%
  dplyr::group_by(G)

# Create new pipeline
pipe &lt;- FixedGroupsPipeline$new(num_groups = 3)

# Add 2D rotation transformation
pipe$add_transformation(
  fn = rotate_2d,
  args = list(
    x_col = "Index",
    y_col = "A",
    suffix = "",
    overwrite = TRUE
  ),
  var_args = list(
    degrees = list(45, 90, 180),
    origin = list(c(0, 0), c(1, 2), c(-1, 0))
  ),
  name = "Rotate"
)

# Add the `cluster_group` transformation
# As the function is fed an ungrouped subset of `data`,
# i.e. the rows of that group, we need to specify `group_cols` in `args`
# That is specific to `cluster_groups()` though
# Also note `.apply` in `var_args` which tells the pipeline *not*
# to apply this transformation to the second group
pipe$add_transformation(
  fn = cluster_groups,
  args = list(
    cols = c("Index", "A"),
    suffix = "",
    overwrite = TRUE,
    group_cols = "G"
  ),
  var_args = list(
    multiplier = list(0.5, 1, 5),
    .apply = list(TRUE, FALSE, TRUE)
  ),
  name = "Cluster"
)

# Check pipeline object
pipe

# Apply pipeline to already grouped data.frame
# Enable `verbose` to print progress
pipe$apply(df, verbose = TRUE)

</code></pre>

<hr>
<h2 id='FixedGroupsTransformation'>FixedGroupsTransformation</h2><span id='topic+FixedGroupsTransformation'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Container for the type of transformation used in
<code><a href="#topic+FixedGroupsPipeline">FixedGroupsPipeline</a></code>.
</p>
<p><strong>Note</strong>: For internal use.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Transformation">rearrr::Transformation</a></code> -&gt; <code>FixedGroupsTransformation</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of constant arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>var_args</code></dt><dd><p><code>list</code> of arguments for <code>`fn`</code> with different values per group.</p>
</dd>
<dt><code>num_groups</code></dt><dd><p>Number of groups that the transformation expects.</p>
</dd>
<dt><code>apply_arg</code></dt><dd><p><code>list</code> of <code>TRUE</code>/<code>FALSE</code> flags indicating
whether the transformation should be applied to each of the groups.
</p>
<p>When <code>`NULL`</code>, the transformation is applied to all groups.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FixedGroupsTransformation-new"><code>FixedGroupsTransformation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsTransformation-get_group_args"><code>FixedGroupsTransformation$get_group_args()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsTransformation-apply"><code>FixedGroupsTransformation$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsTransformation-print"><code>FixedGroupsTransformation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FixedGroupsTransformation-clone"><code>FixedGroupsTransformation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FixedGroupsTransformation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsTransformation$new(fn, args, var_args, name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of constant arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>var_args</code></dt><dd><p><code>list</code> of arguments for <code>`fn`</code> with different values per group.
Each argument should have a list of values (one per group).
</p>
<p>By adding <code>".apply"</code> with a list of <code>TRUE</code>/<code>FALSE</code> flags, the transformation
can be disabled for a specific group.
</p>
<p>E.g. <code>list(".apply" = list(TRUE, FALSE, TRUE), ...</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FixedGroupsTransformation-get_group_args"></a>



<h4>Method <code>get_group_args()</code></h4>

<p>Get arguments for specific group ID.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsTransformation$get_group_args(group_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group_id</code></dt><dd><p>ID of the group to get arguments for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>list</code> of arguments.
</p>


<hr>
<a id="method-FixedGroupsTransformation-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Apply the transformation to a <code>data.frame</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsTransformation$apply(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame</code> with the expected number of groups.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Transformed version of <code>`data`</code>.
</p>


<hr>
<a id="method-FixedGroupsTransformation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsTransformation$print(..., indent = 0, show_class = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
<dt><code>indent</code></dt><dd><p>How many spaces to indent when printing.</p>
</dd>
<dt><code>show_class</code></dt><dd><p>Whether to print the transformation class name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-FixedGroupsTransformation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FixedGroupsTransformation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other transformation classes: 
<code><a href="#topic+GeneratedTransformation">GeneratedTransformation</a></code>,
<code><a href="#topic+Transformation">Transformation</a></code>
</p>

<hr>
<h2 id='flip_values'>Flip the values around an origin</h2><span id='topic+flip_values'></span><span id='topic+flip_values_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are flipped with the formula <code class="reqn">`x = 2 * c - x`</code> where <em>x</em> is the value and <em>c</em> is
the origin coordinate to flip the values around.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and flipping around e.g. the centroid
of each group. By default the median value in each dimension is used.
</p>
<p>The <code>*_vec()</code> version take and return a vector.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(5, 2, 7, 4, 3, 1)</code>
</p>
<p>and the <code>origin_fn = create_origin_fn(median)</code>
</p>
<p>Changes the values to :
</p>
<p><code>c(2, 5, 0, 3, 4, 6)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip_values(
  data,
  cols = NULL,
  origin = NULL,
  origin_fn = create_origin_fn(median),
  suffix = "_flipped",
  keep_original = TRUE,
  origin_col_name = ".origin",
  overwrite = FALSE
)

flip_values_vec(data, origin = NULL, origin_fn = create_origin_fn(median))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_values_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="flip_values_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to flip values of.</p>
</td></tr>
<tr><td><code id="flip_values_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to flip around.
A scalar to use in all dimensions (columns)
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>NULL</code>. Remember to set it to <code>NULL</code>
when passing origin coordinates manually!</p>
</td></tr>
<tr><td><code id="flip_values_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="flip_values_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="flip_values_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="flip_values_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="flip_values_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "Index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Flip values of the columns
flip_values(df$A)
flip_values(df, cols = "A")
flip_values(df, cols = "B", origin = 0.3, origin_fn = NULL, keep_original = FALSE)
flip_values(df,
  cols = c("A", "B"),
  origin = c(3, 0.3),
  origin_fn = NULL,
  suffix = "",
  keep_original = FALSE,
  overwrite = TRUE
)
flip_values(df, cols = c("A", "B"), origin_fn = create_origin_fn(max))

# Grouped by G
df %&gt;%
  dplyr::group_by(G) %&gt;%
  flip_values(
    cols = c("A", "B"),
    origin_fn = create_origin_fn(median),
    keep_original = FALSE
  )

# Plot A and flipped A

# First flip A around the median and then around the value 3.
df &lt;- df %&gt;%
  flip_values(cols = "A", suffix = "_flip_median", origin_col_name = NULL) %&gt;%
  flip_values(cols = "A", suffix = "_flip_3", origin = 3,
              origin_fn = NULL, origin_col_name = NULL)

# Plot A and A flipped around its median
if (has_ggplot){
  ggplot(df, aes(x = Index, y = A)) +
    geom_line(aes(color = "A")) +
    geom_line(aes(y = A_flip_median, color = "Flipped A (median)")) +
    geom_hline(aes(color = "Median A", yintercept = median(A))) +
    theme_minimal()
}

# Plot A and A flipped around the value 3
if (has_ggplot){
  ggplot(df, aes(x = Index, y = A)) +
    geom_line(aes(color = "A")) +
    geom_line(aes(y = A_flip_3, color = "Flipped A (3)")) +
    geom_hline(aes(color = "3", yintercept = 3)) +
    theme_minimal()
}
</code></pre>

<hr>
<h2 id='furthest_from'>Orders values by longest distance to an origin</h2><span id='topic+furthest_from'></span><span id='topic+farthest_from'></span><span id='topic+furthest_from_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Values are ordered by how far they are from the origin.
</p>
<p>In 1d (when
<code>`cols`</code> has length <code>1</code>), the origin can be thought of as a target value.
In <em>n</em> dimensions, the origin can be thought of as coordinates.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and ordering the rows by
their distance to the centroid of each group.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>and <code>origin = 2</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(5, 4, 1, 3,</code> <strong><code>2</code></strong><code>)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>furthest_from(
  data,
  cols = NULL,
  origin = NULL,
  origin_fn = NULL,
  shuffle_ties = FALSE,
  origin_col_name = ".origin",
  distance_col_name = ".distance",
  overwrite = FALSE
)

furthest_from_vec(data, origin = NULL, origin_fn = NULL, shuffle_ties = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="furthest_from_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_cols">cols</code></td>
<td>
<p>Column(s) to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to calculate distances to.
A scalar to use in all dimensions
or a <code>vector</code> with one scalar per dimension.
</p>
<p><strong>N.B.</strong> Ignored when <code>`origin_fn`</code> is not <code>`NULL`</code>.</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="furthest_from_+3A_shuffle_ties">shuffle_ties</code></td>
<td>
<p>Whether to shuffle elements with the same distance to the origin. (Logical)</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_distance_col_name">distance_col_name</code></td>
<td>
<p>Name of new column with the distances to the origin. If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="furthest_from_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Furthest from 3 in a vector
furthest_from_vec(1:10, origin = 3)

# Furthest from the third row (index of data.frame)
furthest_from(df, origin = 3)$index

# By each of the columns
furthest_from(df, cols = "A", origin = 3)$A
furthest_from(df, cols = "A", origin_fn = most_centered)$A
furthest_from(df, cols = "B", origin = 0.5)$B
furthest_from(df, cols = "B", origin_fn = centroid)$B

# Shuffle the elements with the same distance to the origin
furthest_from(df,
  cols = "A",
  origin_fn = create_origin_fn(median),
  shuffle_ties = TRUE
)$A

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  furthest_from(
    cols = "A",
    origin_fn = create_origin_fn(median)
  )

# Plot the rearranged values
plot(
  x = 1:10,
  y = furthest_from(df,
    cols = "B",
    origin_fn = create_origin_fn(median)
  )$B,
  xlab = "Position", ylab = "B"
)
plot(
  x = 1:10,
  y = furthest_from(df,
    cols = "A",
    origin_fn = create_origin_fn(median),
    shuffle_ties = TRUE
  )$A,
  xlab = "Position", ylab = "A"
)

# In multiple dimensions
df %&gt;%
  furthest_from(cols = c("A", "B"), origin_fn = most_centered)

</code></pre>

<hr>
<h2 id='generate_clusters'>Generate n-dimensional clusters</h2><span id='topic+generate_clusters'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Generates <code>data.frame</code> (<code>tibble</code>) with clustered groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_clusters(
  num_rows,
  num_cols,
  num_clusters,
  compactness = 1.6,
  generator = runif,
  name_prefix = "D",
  cluster_col_name = ".cluster"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_clusters_+3A_num_rows">num_rows</code></td>
<td>
<p>Number of rows.</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_num_cols">num_cols</code></td>
<td>
<p>Number of columns (dimensions).</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_compactness">compactness</code></td>
<td>
<p>How compact the clusters should be. A larger value leads to more compact clusters (on average).
</p>
<p>Technically, it is passed to the <code>`multiplier`</code> argument in
<code><a href="#topic+cluster_groups">cluster_groups()</a></code> as <code class="reqn">`0.1 / compactness`</code>.</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_generator">generator</code></td>
<td>
<p>Function to generate the numeric values.
</p>
<p>Must have the <em>number of values to generate</em> as its first (and only required) argument,
as that is the only argument we pass to it.</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_name_prefix">name_prefix</code></td>
<td>
<p>Prefix string for naming columns.</p>
</td></tr>
<tr><td><code id="generate_clusters_+3A_cluster_col_name">cluster_col_name</code></td>
<td>
<p>Name of cluster factor.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>Generates <code>data.frame</code> with random values using the <code>`generator`</code>.
</p>
</li>
<li><p>Divides the rows into groups (the clusters).
</p>
</li>
<li><p>Contracts the distance from each data point to the centroid of its group.
</p>
</li>
<li><p>Performs MinMax scaling such that the scale of the data points is similar to the generated data.
</p>
</li></ul>



<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the clustered columns and the cluster grouping factor.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other clustering functions: 
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+transfer_centroids">transfer_centroids</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(10)

# Generate clusters
generate_clusters(num_rows = 20, num_cols = 3, num_clusters = 3, compactness = 1.6)
generate_clusters(num_rows = 20, num_cols = 5, num_clusters = 6, compactness = 2.5)

# Generate clusters and plot them
# Tip: Call this multiple times
# to see the behavior of `generate_clusters()`
if (has_ggplot){
  generate_clusters(
    num_rows = 50, num_cols = 2,
    num_clusters = 5, compactness = 1.6
  ) %&gt;%
    ggplot(
      aes(x = D1, y = D2, color = .cluster)
    ) +
    geom_point() +
    theme_minimal() +
    labs(x = "D1", y = "D2", color = "Cluster")
}

#
# Plot clusters in 3d view
#

# Generate clusters
clusters &lt;- generate_clusters(
  num_rows = 50, num_cols = 3,
  num_clusters = 5, compactness = 1.6
)

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = clusters$D1,
  y = clusters$D2,
  z = clusters$D3,
  type = "scatter3d",
  mode = "markers",
  color = clusters$.cluster
)

## End(Not run)
</code></pre>

<hr>
<h2 id='generate_wave'>Generate simple wave signal</h2><span id='topic+generate_wave'></span><span id='topic+generate_sine_wave'></span><span id='topic+generate_cosine_wave'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Generate y-values for the wave signal at the given time points with:
</p>
<p style="text-align: center;"><code class="reqn">amplitude * trig_fn(2 * pi * (1 / fs) * ts + phase)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>generate_wave(ts, fs = 44100, amplitude = 1, phase = 0, trig_fn = sin)

generate_sine_wave(ts, fs = 44100, amplitude = 1, phase = 0)

generate_cosine_wave(ts, fs = 44100, amplitude = 1, phase = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_wave_+3A_ts">ts</code></td>
<td>
<p>Time points.</p>
</td></tr>
<tr><td><code id="generate_wave_+3A_fs">fs</code></td>
<td>
<p>Sampling frequency (samples per second).
</p>
<p>Can be a vector with one frequency per time point.</p>
</td></tr>
<tr><td><code id="generate_wave_+3A_amplitude">amplitude</code></td>
<td>
<p>Scaling constant.
</p>
<p>Can be a vector with one amplitude per time point.</p>
</td></tr>
<tr><td><code id="generate_wave_+3A_phase">phase</code></td>
<td>
<p>Offset in radians.
</p>
<p>Can be a vector with one phase offset per time point.</p>
</td></tr>
<tr><td><code id="generate_wave_+3A_trig_fn">trig_fn</code></td>
<td>
<p>Trigonometric function like <code>sin</code> and <code>cos</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y-values for the wave signal.
</p>

<hr>
<h2 id='GeneratedPipeline'>Chain multiple transformations and generate argument values per group</h2><span id='topic+GeneratedPipeline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Build a pipeline of transformations to be applied sequentially.
</p>
<p>Generate argument values for selected arguments with a given set of generators.
E.g. randomly generate argument values for each group in a <code>data.frame</code>.
</p>
<p>Groupings are reset between each transformation. See <code>group_cols</code>.
</p>
<p><strong>Standard workflow</strong>: Instantiate pipeline -&gt; Add transformations -&gt; Apply to data
</p>
<p>To apply the same arguments to all groups, see
<code><a href="#topic+Pipeline">Pipeline</a></code>.
</p>
<p>To apply different but specified argument values to a fixed set of groups,
see <code><a href="#topic+FixedGroupsPipeline">FixedGroupsPipeline</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Pipeline">rearrr::Pipeline</a></code> -&gt; <code>GeneratedPipeline</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>transformations</code></dt><dd><p><code>list</code> of transformations to apply.</p>
</dd>
<dt><code>names</code></dt><dd><p>Names of the transformations.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GeneratedPipeline-add_transformation"><code>GeneratedPipeline$add_transformation()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedPipeline-print"><code>GeneratedPipeline$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedPipeline-clone"><code>GeneratedPipeline$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rearrr" data-topic="Pipeline" data-id="apply"><a href='../../rearrr/html/Pipeline.html#method-Pipeline-apply'><code>rearrr::Pipeline$apply()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GeneratedPipeline-add_transformation"></a>



<h4>Method <code>add_transformation()</code></h4>

<p>Add a transformation to the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedPipeline$add_transformation(
  fn,
  args,
  generators,
  name,
  group_cols = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Function that performs the transformation.</p>
</dd>
<dt><code>args</code></dt><dd><p>Named <code>list</code> with arguments for the <code>`fn`</code> function.</p>
</dd>
<dt><code>generators</code></dt><dd><p>Named <code>list</code> of functions for generating argument values
for a single call of <code>`fn`</code>.
</p>
<p>It is possible to include an <em>apply generator</em> for deciding whether
the transformation should be applied to the current group or not.
This is done by adding a function with the name <code>`.apply`</code> to the <code>`generators`</code> list.
E.g. <code>".apply" = function(){sample(c(TRUE, FALSE), 1)}</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the transformation step. Must be unique.</p>
</dd>
<dt><code>group_cols</code></dt><dd><p>Names of the columns to group the input
data by before applying the transformation.
</p>
<p>Note that the transformation function is applied separately to each group (subset).
If the <code>`fn`</code> function requires access to the entire <code>data.frame</code>, the
grouping columns should be specified as part of <code>`args`</code> and
handled by the <code>`fn`</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># `generators` is a list of functions for generating
# argument values for a chosen set of arguments
# `.apply` can be used to disable the transformation
generators = list(degrees = function(){sample.int(360, 1)},
                  origin = function(){rnorm(2)},
                  .apply = function(){sample(c(TRUE, FALSE), 1)})
</pre>
</div>


<hr>
<a id="method-GeneratedPipeline-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedPipeline$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-GeneratedPipeline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedPipeline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other pipelines: 
<code><a href="#topic+FixedGroupsPipeline">FixedGroupsPipeline</a></code>,
<code><a href="#topic+Pipeline">Pipeline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach package
library(rearrr)

# Create a data frame
df &lt;- data.frame(
  "Index" = 1:12,
  "A" = c(1:4, 9:12, 15:18),
  "G" = rep(1:3, each = 4)
)

# Create new pipeline
pipe &lt;- GeneratedPipeline$new()

# Add 2D rotation transformation
# Note that we specify the grouping via `group_cols`
pipe$add_transformation(
  fn = rotate_2d,
  args = list(
    x_col = "Index",
    y_col = "A",
    suffix = "",
    overwrite = TRUE
  ),
  generators = list(degrees = function(){sample.int(360, 1)},
                    origin = function(){rnorm(2)}),
  name = "Rotate",
  group_cols = "G"
)

# Add the `cluster_group` transformation
# Note that this function requires the entire input data
# to properly scale the groups. We therefore specify `group_cols`
# as part of `args`. This works as `cluster_groups()` accepts that
# argument.
# Also note the `.apply` generator which generates a TRUE/FALSE scalar
# for whether the transformation should be applied to the current group
pipe$add_transformation(
  fn = cluster_groups,
  args = list(
    cols = c("Index", "A"),
    suffix = "",
    overwrite = TRUE,
    group_cols = "G"
  ),
  generators = list(
    multiplier = function() {
      0.1 * runif(1) * 3 ^ sample.int(5, 1)
    },
    .apply = function(){sample(c(TRUE, FALSE), 1)}
  ),
  name = "Cluster"
)

# Check pipeline object
pipe

# Apply pipeline to data.frame
# Enable `verbose` to print progress
pipe$apply(df, verbose = TRUE)


## ------------------------------------------------
## Method `GeneratedPipeline$add_transformation`
## ------------------------------------------------

# `generators` is a list of functions for generating
# argument values for a chosen set of arguments
# `.apply` can be used to disable the transformation
generators = list(degrees = function(){sample.int(360, 1)},
                  origin = function(){rnorm(2)},
                  .apply = function(){sample(c(TRUE, FALSE), 1)})
</code></pre>

<hr>
<h2 id='GeneratedTransformation'>GeneratedTransformation</h2><span id='topic+GeneratedTransformation'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Container for the type of transformation used in
<code><a href="#topic+GeneratedPipeline">GeneratedPipeline</a></code>.
</p>
<p><strong>Note</strong>: For internal use.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Transformation">rearrr::Transformation</a></code> -&gt; <code>GeneratedTransformation</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of constant arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>generators</code></dt><dd><p><code>list</code> of generator functions
for generating argument values.</p>
</dd>
<dt><code>apply_generator</code></dt><dd><p>Generator function for deciding
whether to apply the transformation to the current group.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GeneratedTransformation-new"><code>GeneratedTransformation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedTransformation-get_group_args"><code>GeneratedTransformation$get_group_args()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedTransformation-generate_args"><code>GeneratedTransformation$generate_args()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedTransformation-print"><code>GeneratedTransformation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GeneratedTransformation-clone"><code>GeneratedTransformation$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="rearrr" data-topic="Transformation" data-id="apply"><a href='../../rearrr/html/Transformation.html#method-Transformation-apply'><code>rearrr::Transformation$apply()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GeneratedTransformation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedTransformation$new(
  fn,
  args,
  generators,
  name = NULL,
  group_cols = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of constant arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>generators</code></dt><dd><p>Named <code>list</code> of functions for generating argument values
for a single call of <code>`fn`</code>.
</p>
<p>It is possible to include an <em>apply generator</em> for deciding whether
the transformation should be applied to the current group or not.
This is done by adding a function with the name <code>`.apply`</code> to the <code>`generators`</code> list.
E.g. <code>".apply" = function(){sample(c(TRUE, FALSE), 1)}</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
<dt><code>group_cols</code></dt><dd><p>Names of columns to group <code>data.frame</code>
by before applying <code>`fn`</code>.
</p>
<p>When <code>`NULL`</code>, the <code>data.frame</code> is not grouped.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GeneratedTransformation-get_group_args"></a>



<h4>Method <code>get_group_args()</code></h4>

<p>Get arguments for a group.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedTransformation$get_group_args()</pre></div>



<h5>Returns</h5>

<p><code>list</code> of arguments (both constant and generated).
</p>


<hr>
<a id="method-GeneratedTransformation-generate_args"></a>



<h4>Method <code>generate_args()</code></h4>

<p>Generate arguments for a group with the <code>`generators`</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedTransformation$generate_args()</pre></div>



<h5>Returns</h5>

<p><code>list</code> of generated arguments.
</p>
<p>Does not include the constant arguments.
</p>


<hr>
<a id="method-GeneratedTransformation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedTransformation$print(..., indent = 0, show_class = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
<dt><code>indent</code></dt><dd><p>How many spaces to indent when printing.</p>
</dd>
<dt><code>show_class</code></dt><dd><p>Whether to print the transformation class name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-GeneratedTransformation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GeneratedTransformation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other transformation classes: 
<code><a href="#topic+FixedGroupsTransformation">FixedGroupsTransformation</a></code>,
<code><a href="#topic+Transformation">Transformation</a></code>
</p>

<hr>
<h2 id='hexagonalize'>Create x-coordinates so the points form a hexagon</h2><span id='topic+hexagonalize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Create the x-coordinates for a <code>vector</code> of y-coordinates such that
they form a hexagon.
</p>
<p>This will likely look most like a hexagon when the y-coordinates are somewhat equally distributed,
e.g. a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexagonalize(
  data,
  y_col = NULL,
  .min = NULL,
  .max = NULL,
  offset_x = 0,
  keep_original = TRUE,
  x_col_name = ".hexagon_x",
  edge_col_name = ".edge",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexagonalize_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_y_col">y_col</code></td>
<td>
<p>Name of column in <code>`data`</code> with y-coordinates to create x-coordinates for.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_.min">.min</code></td>
<td>
<p>Minimum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_.max">.max</code></td>
<td>
<p>Maximum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_offset_x">offset_x</code></td>
<td>
<p>Value to offset the x-coordinates by.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_x_col_name">x_col_name</code></td>
<td>
<p>Name of new column with the x-coordinates.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_edge_col_name">edge_col_name</code></td>
<td>
<p>Name of new column with the edge identifiers. If <code>NULL</code>, no column is added.
</p>
<p>Numbering is clockwise and starts at the upper-right edge.</p>
</td></tr>
<tr><td><code id="hexagonalize_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the added x-coordinates and an identifier
for the edge the data point is a part of.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other forming functions: 
<code><a href="#topic+circularize">circularize</a>()</code>,
<code><a href="#topic+square">square</a>()</code>,
<code><a href="#topic+triangularize">triangularize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "y" = runif(200),
  "g" = factor(rep(1:5, each = 40))
)

# Hexagonalize 'y'
df_hex &lt;- hexagonalize(df, y_col = "y")
df_hex

# Plot hexagon
if (has_ggplot){
  df_hex %&gt;%
    ggplot(aes(x = .hexagon_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Grouped hexagonalization
#

# Hexagonalize 'y' for each group
# First cluster the groups a bit to move the
# hexagons away from each other
df_hex &lt;- df %&gt;%
  cluster_groups(
    cols = "y",
    group_cols = "g",
    suffix = "",
    overwrite = TRUE
  ) %&gt;%
  dplyr::group_by(g) %&gt;%
  hexagonalize(
    y_col = "y",
    overwrite = TRUE
  )

# Plot hexagons
if (has_ggplot){
  df_hex %&gt;%
    ggplot(aes(x = .hexagon_x, y = y, color = g)) +
    geom_point() +
    theme_minimal()
}

#
# Specifying minimum value
#

# Specify minimum value manually
df_hex &lt;- hexagonalize(df, y_col = "y", .min = -2)
df_hex

# Plot hexagon
if (has_ggplot){
  df_hex %&gt;%
    ggplot(aes(x = .hexagon_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Multiple hexagons by contraction
#

# Start by hexagonalizing 'y'
df_hex &lt;- hexagonalize(df, y_col = "y")

# Contract '.hexagon_x' and 'y' towards the centroid
# To contract with multiple multipliers at once,
# we wrap the call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 0.75, 0.5, 0.25, 0.125),
  .f = function(mult) {
    expand_distances(
      data = df_hex,
      cols = c(".hexagon_x", "y"),
      multiplier = mult,
      origin_fn = centroid,
      overwrite = TRUE
    )
  }
)
df_expanded

if (has_ggplot){
  df_expanded %&gt;%
    ggplot(aes(
      x = .hexagon_x_expanded, y = y_expanded,
      color = .edge, alpha = .multiplier
    )) +
    geom_point() +
    theme_minimal()
}
</code></pre>

<hr>
<h2 id='is_most_centered'>Find which data point is closest to the centroid</h2><span id='topic+is_most_centered'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Finds the data point with the
shortest distance to the centroid.
</p>
<p>To get the coordinates of the most centered data point,
use <code><a href="#topic+most_centered">most_centered()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_most_centered(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_most_centered_+3A_...">...</code></td>
<td>
<p><code>Numeric vector</code>s.</p>
</td></tr>
<tr><td><code id="is_most_centered_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to ignore missing values. At least one data point must be complete. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector (<code>TRUE</code>/<code>FALSE</code>) indicating if a data point is the most centered.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other coordinate functions: 
<code><a href="#topic+centroid">centroid</a>()</code>,
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>,
<code><a href="#topic+midrange">midrange</a>()</code>,
<code><a href="#topic+most_centered">most_centered</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Find the data point closest to the centroid
is_most_centered(x, y, z)

# Compare to coordinates for the most centered
most_centered(x, y, z)

#
# For data.frames
#

# Create data frame
df &lt;- data.frame(
  "x" = x,
  "y" = y,
  "z" = z,
  "g" = rep(1:2, each = 5)
)

# Filter the data points
# closest to the centroid
df %&gt;%
  dplyr::filter(is_most_centered(x, y, z))

# When 'df' is grouped
df %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::filter(is_most_centered(x, y, z))

# Add as column
df %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::mutate(mc = is_most_centered(x, y, z))

</code></pre>

<hr>
<h2 id='median_index'>Find index of interest for each vector</h2><span id='topic+median_index'></span><span id='topic+quantile_index'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Applies function to the indices of each <code>vector</code> in <code>`...`</code>.
</p>
<p>These functions were created with <code><a href="#topic+create_n_fn">create_n_fn()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_index(..., negate = FALSE, round_fn = round)

quantile_index(..., prob, type = 7, negate = FALSE, round_fn = round)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_index_+3A_...">...</code></td>
<td>
<p>Numeric <code>vector</code>s.</p>
</td></tr>
<tr><td><code id="median_index_+3A_negate">negate</code></td>
<td>
<p>Whether to negate the result. I.e. to multiply it with <code>-1</code>. (Logical)</p>
</td></tr>
<tr><td><code id="median_index_+3A_round_fn">round_fn</code></td>
<td>
<p>Function for rounding output. Rounding is done <em>prior</em> to negation.
</p>
<p>E.g. <code><a href="base.html#topic+Round">round</a></code>, <code><a href="base.html#topic+Round">floor</a></code>, or <code><a href="base.html#topic+Round">ceiling</a></code>.</p>
</td></tr>
<tr><td><code id="median_index_+3A_prob">prob</code></td>
<td>
<p>Probability in <code>[0,1]</code> for <code><a href="stats.html#topic+quantile">quantile()</a></code>.</p>
</td></tr>
<tr><td><code id="median_index_+3A_type">type</code></td>
<td>
<p>Quantile algorithm to use. See <code><a href="stats.html#topic+quantile">quantile()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric vector</code> with one element per supplied vector.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other n functions: 
<code><a href="#topic+create_n_fn">create_n_fn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Attach packages
library(rearrr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(15)
z &lt;- runif(20)

median_index(x, y, z)
quantile_index(x, y, z, prob = 0.2)

# Negate result
median_index(x, y, z, negate = TRUE)

</code></pre>

<hr>
<h2 id='midrange'>Find the midrange values</h2><span id='topic+midrange'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the midrange for each of the passed <code>vectors</code>/<code>columns</code>.
</p>
<p>Midrange is defined as:
</p>
<p style="text-align: center;"><code class="reqn">(max x + min x) / 2</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>midrange(..., cols = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midrange_+3A_...">...</code></td>
<td>
<p><code>Numeric vectors</code> or a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="midrange_+3A_cols">cols</code></td>
<td>
<p>Names of columns to use when <code>`...`</code> is a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="midrange_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to ignore missing values when calculating
<code>min</code> and <code>max</code> values. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code>vector</code> with the midrange of each supplied <code>vector</code>
or a <code>data.frame</code> with the midrange of each supplied column along with any grouping variables.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other coordinate functions: 
<code><a href="#topic+centroid">centroid</a>()</code>,
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>,
<code><a href="#topic+is_most_centered">is_most_centered</a>()</code>,
<code><a href="#topic+most_centered">most_centered</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Find midrange for each vector
midrange(x, y, z)

#
# For data.frames
#

# Create data frame
df &lt;- data.frame(
  "x" = x,
  "y" = y,
  "z" = z,
  "g" = rep(1:2, each = 5)
)

# Find midrange for each column
midrange(df, cols = c("x", "y", "z"))

# When 'df' is grouped
df %&gt;%
  dplyr::group_by(g) %&gt;%
  midrange(cols = c("x", "y", "z"))
</code></pre>

<hr>
<h2 id='min_max_scale'>Scale to a range</h2><span id='topic+min_max_scale'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Scales the values to a range with MinMax scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_max_scale(
  x,
  new_min,
  new_max,
  old_min = NULL,
  old_max = NULL,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_max_scale_+3A_x">x</code></td>
<td>
<p>Numeric <code>vector</code> to scale.</p>
</td></tr>
<tr><td><code id="min_max_scale_+3A_new_min">new_min</code></td>
<td>
<p>Minimum value of target range.</p>
</td></tr>
<tr><td><code id="min_max_scale_+3A_new_max">new_max</code></td>
<td>
<p>Maximum value of target range.</p>
</td></tr>
<tr><td><code id="min_max_scale_+3A_old_min">old_min</code></td>
<td>
<p>Minimum value of original range.
</p>
<p>If <code>NULL</code>, this is the minimum value in <code>`x`</code>.</p>
</td></tr>
<tr><td><code id="min_max_scale_+3A_old_max">old_max</code></td>
<td>
<p>Maximum value of original range.
</p>
<p>If <code>NULL</code>, this is the maximum value in <code>`x`</code>.</p>
</td></tr>
<tr><td><code id="min_max_scale_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether missing values should be removed when calculating <code>`old_min`</code> and/or <code>`old_max`</code>.
</p>
<p><strong>N.B.</strong> Ignored when both <code>`old_min`</code> and <code>`old_max`</code> are <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled version of <code>`x`</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other scaling functions: 
<code><a href="#topic+to_unit_length">to_unit_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)

# Set seed
set.seed(1)

# Create numeric vector
x &lt;- runif(10)

# Scale
min_max_scale(x, new_min = -1, new_max = 0)
min_max_scale(x, new_min = -1, new_max = 0, old_max = 3)
</code></pre>

<hr>
<h2 id='most_centered'>Find the coordinates for the data point closest to the centroid</h2><span id='topic+most_centered'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Returns the coordinates for the data point with the
shortest distance to the <code><a href="#topic+centroid">centroid</a></code>.
</p>
<p>To get a logical vector (<code>TRUE</code>/<code>FALSE</code>) indicating
whether a data point is the most centered,
use <code><a href="#topic+is_most_centered">is_most_centered()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>most_centered(..., cols = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="most_centered_+3A_...">...</code></td>
<td>
<p><code>Numeric vectors</code> or a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="most_centered_+3A_cols">cols</code></td>
<td>
<p>Names of columns to use when <code>`...`</code> is a single <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="most_centered_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to ignore missing values. At least one data point must be complete. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinates for the data point closest to the centroid.
Either as a <code>vector</code> or a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other coordinate functions: 
<code><a href="#topic+centroid">centroid</a>()</code>,
<code><a href="#topic+create_origin_fn">create_origin_fn</a>()</code>,
<code><a href="#topic+is_most_centered">is_most_centered</a>()</code>,
<code><a href="#topic+midrange">midrange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create three vectors
x &lt;- runif(10)
y &lt;- runif(10)
z &lt;- runif(10)

# Find coordinates of the data point
# closest to the centroid
most_centered(x, y, z)

# Compare to centroid coordinates
centroid(x, y, z)

#
# For data.frames
#

# Create data frame
df &lt;- data.frame(
  "x" = x,
  "y" = y,
  "z" = z,
  "g" = rep(1:2, each = 5)
)

# Find coordinates of the data point
# closest to the centroid
most_centered(df, cols = c("x", "y", "z"))

# When 'df' is grouped
df %&gt;%
  dplyr::group_by(g) %&gt;%
  most_centered(cols = c("x", "y", "z"))

# Filter to only include most centered data points
df %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::filter(is_most_centered(x, y, z))
</code></pre>

<hr>
<h2 id='multi_mutator_'>Wrapper for running multi-column mutator methods</h2><span id='topic+multi_mutator_'></span>

<h3>Description</h3>

<p>Wrapper for running multi-column mutator methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_mutator_(
  data,
  mutate_fn,
  check_fn,
  cols = NULL,
  suffix = "_mutated",
  overwrite = FALSE,
  force_df = TRUE,
  allowed_types = c("numeric", "factor"),
  allow_missing = FALSE,
  min_dims = 1,
  altered_col = NULL,
  keep_original = TRUE,
  origin_fn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_mutator__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_mutate_fn">mutate_fn</code></td>
<td>
<p>Mutator to apply.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_check_fn">check_fn</code></td>
<td>
<p>Function with checks post-preparation of <code>`data`</code> and <code>`col(s)`</code>.
Should not return anything.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_cols">cols</code></td>
<td>
<p>Columns to mutate values of. Must be specified when <code>`data`</code> is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_force_df">force_df</code></td>
<td>
<p>Whether to return a <code>data.frame</code> when <code>`data`</code> is a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_allowed_types">allowed_types</code></td>
<td>
<p>Allowed types of the <code>`col(s)`</code> columns. The type restrictions do not apply to
columns not mentioned in the <code>`col(s)`</code> argument.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_allow_missing">allow_missing</code></td>
<td>
<p>Whether to allow missing values (<code>NA</code>s). (Logical)</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_min_dims">min_dims</code></td>
<td>
<p>Minimum number of dimensions (cols) after preparations. When <code>`data`</code> is a <code>vector</code>
setting <code>`min_dims`</code> to <code>2</code> will use both the index and the values as columns.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_altered_col">altered_col</code></td>
<td>
<p>Additional column that is mutated but is not
mentioned in <code>`cols`</code>.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="multi_mutator__+3A_...">...</code></td>
<td>
<p>Named arguments for the <code>`mutate_fn`</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mutated <code>data.frame</code> (<code>tibble</code>).
</p>

<hr>
<h2 id='pair_extremes'>Pair extreme values and sort by the pairs</h2><span id='topic+pair_extremes'></span><span id='topic+pair_extremes_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are paired/grouped such that the lowest and highest values
form the first group, the second lowest and the second highest values
form the second group, and so on.
The values are then sorted by these groups/pairs.
</p>
<p>When <code>`data`</code> has an uneven number of rows, the <code>`unequal_method`</code>
determines which group should have only <code>1</code> element.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5, 6)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 2, 3, 3, 2, 1)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 6, 2, 5, 3, 4)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_extremes(
  data,
  col = NULL,
  unequal_method = "middle",
  num_pairings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_pairs = FALSE,
  factor_name = ifelse(num_pairings == 1, ".pair", ".pairing"),
  overwrite = FALSE
)

pair_extremes_vec(
  data,
  unequal_method = "middle",
  num_pairings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_pairs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair_extremes_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_unequal_method">unequal_method</code></td>
<td>
<p>Method for dealing with an
unequal number of rows/elements in <code>`data`</code>.
</p>
<p>One of: <code>first</code>, <code>middle</code> or <code>last</code>
</p>


<h4>first</h4>

<p>The first group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 3, 3, 2)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 5, 3, 4)</code>
</p>



<h4>middle</h4>

<p>The middle group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 3, </code><strong><code>2</code></strong><code>, 3, 1)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 5, </code> <strong><code>3</code></strong><code>, 2, 4)</code>
</p>



<h4>last</h4>

<p>The last group will have size <code>1</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The ordered column values:
</p>
<p><code>c(1, 2, 3, 4, 5)</code>
</p>
<p>Creates the <strong>sorting factor</strong>:
</p>
<p><code>c(1, 2, 2, 1, </code><strong><code>3</code></strong><code>)</code>
</p>
<p>And are <strong>ordered as</strong>:
</p>
<p><code>c(1, 4, 2, 3,</code> <strong><code>5</code></strong><code>)</code>
</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_num_pairings">num_pairings</code></td>
<td>
<p>Number of pairings to perform (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary pairings perform extreme pairing on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the pair elements.</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_balance">balance</code></td>
<td>
<p>What to balance pairs for in a given <em>secondary</em> pairing.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary pairings
or one for each secondary pairing (<code>`num_pairings` - 1</code>).
</p>
<p>The first pairing always pairs the actual element values.
</p>


<h4>mean</h4>

<p>Pairs have similar means. The values in the pairs from the previous pairing
are aggregated with <code>`sum()`</code> and paired.
</p>



<h4>spread</h4>

<p>Pairs have similar spread (e.g. standard deviations).
The values in the pairs from the previous pairing
are aggregated with <code>`sum(abs(diff()))`</code> and paired.
</p>



<h4>min / max</h4>

<p>Pairs have similar minimum / maximum values. The values in the pairs from the previous pairing
are aggregated with <code>`min()`</code> / <code>`max()`</code> and paired.
</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_order_by_aggregates">order_by_aggregates</code></td>
<td>
<p>Whether to order the pairs from initial pairings (first <code>`num_pairings` - 1</code>)
by their aggregate values instead of their pair identifiers.
</p>
<p>N.B. Only used when <code>`num_pairings` &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_shuffle_members">shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_shuffle_pairs">shuffle_pairs</code></td>
<td>
<p>Whether to shuffle the order of the pairs. Pair members remain together. (Logical)</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_factor_name">factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="pair_extremes_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`keep_factors`</code> is <code>FALSE</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Pair extreme indices (row numbers)
pair_extremes(df)

# Pair extremes in each of the columns
pair_extremes(df, col = "A")$A
pair_extremes(df, col = "B")$B
pair_extremes(df, col = "C")$C

# Shuffle the members pair-wise
# The rows within each pair are shuffled
# while the `.pair` column maintains it order
pair_extremes(df, col = "A", shuffle_members = TRUE)

# Shuffle the order of the pairs
# The rows within each pair maintain their order
# and stay together but the `.pair` column is shuffled
pair_extremes(df, col = "A", shuffle_pairs = TRUE)

# Use recursive pairing
# Mostly meaningful with much larger datasets
# Order initial grouping by pair identifiers
pair_extremes(df, col = "A", num_pairings = 2)
# Order initial grouping by aggregate values
pair_extremes(df, col = "A", num_pairings = 2, order_by_aggregates = TRUE)

# Grouped by G
# Each G group only has 3 elements
# so it only creates 1 pair and a group
# with the single excessive element
# per G group
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  pair_extremes(col = "A")

# Plot the extreme pairs
plot(
  x = 1:10,
  y = pair_extremes(df, col = "B")$B,
  col = as.character(rep(1:5, each = 2))
)
# With shuffled pair members (run a few times)
plot(
  x = 1:10,
  y = pair_extremes(df, col = "B", shuffle_members = TRUE)$B,
  col = as.character(rep(1:5, each = 2))
)
# With shuffled pairs (run a few times)
plot(
  x = rep(1:5, each = 2),
  y = pair_extremes(df, col = "B", shuffle_pairs = TRUE)$B,
  col = as.character(rep(1:5, each = 2))
)
</code></pre>

<hr>
<h2 id='Pipeline'>Chain multiple transformations</h2><span id='topic+Pipeline'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Build a pipeline of transformations to be applied sequentially.
</p>
<p>Uses the same arguments for all groups in <code>`data`</code>.
</p>
<p>Groupings are reset between each transformation. See <code>group_cols</code>.
</p>
<p><strong>Standard workflow</strong>: Instantiate pipeline -&gt; Add transformations -&gt; Apply to data
</p>
<p>To apply different argument values to each group, see
<code><a href="#topic+GeneratedPipeline">GeneratedPipeline</a></code> for generating
argument values for an arbitrary number of groups and
<code><a href="#topic+FixedGroupsPipeline">FixedGroupsPipeline</a></code> for specifying
specific values for a fixed set of groups.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>transformations</code></dt><dd><p><code>list</code> of transformations to apply.</p>
</dd>
<dt><code>names</code></dt><dd><p>Names of the transformations.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Pipeline-add_transformation"><code>Pipeline$add_transformation()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-apply"><code>Pipeline$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-print"><code>Pipeline$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Pipeline-clone"><code>Pipeline$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Pipeline-add_transformation"></a>



<h4>Method <code>add_transformation()</code></h4>

<p>Add a transformation to the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$add_transformation(fn, args, name, group_cols = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Function that performs the transformation.</p>
</dd>
<dt><code>args</code></dt><dd><p>Named <code>list</code> with arguments for the <code>`fn`</code> function.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of the transformation step. Must be unique.</p>
</dd>
<dt><code>group_cols</code></dt><dd><p>Names of the columns to group the input
data by before applying the transformation.
</p>
<p>Note that the transformation function is applied separately to each group (subset).
If the <code>`fn`</code> function requires access to the entire <code>data.frame</code>, the
grouping columns should be specified as part of <code>`args`</code> and
handled by the <code>`fn`</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-Pipeline-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Apply the pipeline to a <code>data.frame</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$apply(data, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame</code>.
</p>
<p>A grouped <code>data.frame</code> will raise a warning and the grouping will be ignored.
Use the <code>`group_cols`</code> argument in the <code>`add_transformation`</code> method to
specify how <code>`data`</code> should be grouped for each transformation.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Whether to print the progress.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Transformed version of <code>`data`</code>.
</p>


<hr>
<a id="method-Pipeline-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the pipeline.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-Pipeline-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Pipeline$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other pipelines: 
<code><a href="#topic+FixedGroupsPipeline">FixedGroupsPipeline</a></code>,
<code><a href="#topic+GeneratedPipeline">GeneratedPipeline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach package
library(rearrr)

# Create a data frame
df &lt;- data.frame(
  "Index" = 1:12,
  "A" = c(1:4, 9:12, 15:18),
  "G" = rep(1:3, each = 4)
)

# Create new pipeline
pipe &lt;- Pipeline$new()

# Add 2D rotation transformation
# Note that we specify the grouping via `group_cols`
pipe$add_transformation(
  fn = rotate_2d,
  args = list(
    x_col = "Index",
    y_col = "A",
    origin = c(0, 0),
    degrees = 45,
    suffix = "",
    overwrite = TRUE
  ),
  name = "Rotate",
  group_cols = "G"
)

# Add the `cluster_group` transformation
# Note that this function requires the entire input data
# to properly scale the groups. We therefore specify `group_cols`
# as part of `args`. This works as `cluster_groups()` accepts that
# argument.
pipe$add_transformation(
  fn = cluster_groups,
  args = list(
    cols = c("Index", "A"),
    suffix = "",
    overwrite = TRUE,
    multiplier = 0.05,
    group_cols = "G"
  ),
  name = "Cluster"
)

# Check pipeline object
pipe

# Apply pipeline to data.frame
# Enable `verbose` to print progress
pipe$apply(df, verbose = TRUE)
</code></pre>

<hr>
<h2 id='position_max'>Positions the highest values with values decreasing around it</h2><span id='topic+position_max'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The highest value is positioned at the given index/quantile with the other
values decreasing around it.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, </code><strong><code>5</code></strong><code>)</code>
</p>
<p>and <code>position = 2</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(3,</code> <strong><code>5</code></strong><code>, 4, 2, 1)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_max(data, col = NULL, position = NULL, shuffle_sides = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_max_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="position_max_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="position_max_+3A_position">position</code></td>
<td>
<p>Index or quantile (in <code>0-1</code>) at which to position the element of interest.</p>
</td></tr>
<tr><td><code id="position_max_+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the position. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Position the highest index (row number)
position_max(df, position = 3)$index
position_max(df, position = 8)$index

# Position the maximum value in each of the columns
position_max(df, col = "A", position = 3)$A
position_max(df, col = "B", position = 3)$B
position_max(df, col = "C", position = 3)$C

# Randomize which elements are left and right of the position
position_max(df, col = "A", position = 3, shuffle_sides = TRUE)$A

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  position_max(col = "A", position = 2)

# Plot the rearranged values
plot(x = 1:10, y = position_max(df, col = "B", position = 3)$B)
plot(x = 1:10, y = position_max(df, col = "B", position = 3, shuffle_sides = TRUE)$B)
</code></pre>

<hr>
<h2 id='position_min'>Positions the lowest value with values increasing around it</h2><span id='topic+position_min'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The lowest value is positioned at the given index/quantile with the other
values increasing around it.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(</code><strong><code>1</code></strong><code>, 2, 3, 4, 5)</code>
</p>
<p>and <code>position = 2</code>
</p>
<p>are <strong>ordered as</strong>:
</p>
<p><code>c(3,</code> <strong><code>1</code></strong><code>, 2, 4, 5)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_min(data, col = NULL, position = NULL, shuffle_sides = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_min_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="position_min_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="position_min_+3A_position">position</code></td>
<td>
<p>Index or quantile (in <code>0-1</code>) at which to position the element of interest.</p>
</td></tr>
<tr><td><code id="position_min_+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the position. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = c(
    1, 1, 1, 2, 2,
    2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Position the smallest index (row number)
position_min(df, position = 3)$index
position_min(df, position = 8)$index

# Position the minimum value in each of the columns
position_min(df, col = "A", position = 3)$A
position_min(df, col = "B", position = 3)$B
position_min(df, col = "C", position = 3)$C

# Randomize which elements are left and right of the position
position_min(df, col = "A", position = 3, shuffle_sides = TRUE)$A

# Grouped by G
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  position_min(col = "A", position = 2)

# Plot the rearranged values
plot(x = 1:10, y = position_min(df, col = "B", position = 3)$B)
plot(x = 1:10, y = position_min(df, col = "B", position = 3, shuffle_sides = TRUE)$B)

</code></pre>

<hr>
<h2 id='positioning_rearranger_'>Wrapper for running positioning rearrange methods</h2><span id='topic+positioning_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running positioning rearrange methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>positioning_rearranger_(
  data,
  col = NULL,
  position = NULL,
  shuffle_sides = FALSE,
  what = "max"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positioning_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="positioning_rearranger__+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="positioning_rearranger__+3A_position">position</code></td>
<td>
<p>Index or quantile (in <code>0-1</code>) at which to position the element of interest.</p>
</td></tr>
<tr><td><code id="positioning_rearranger__+3A_shuffle_sides">shuffle_sides</code></td>
<td>
<p>Whether to shuffle which elements are left and right of the position. (Logical)</p>
</td></tr>
<tr><td><code id="positioning_rearranger__+3A_what">what</code></td>
<td>
<p>What to position. <code>"max"</code> or <code>"min"</code>. (Character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
</p>

<hr>
<h2 id='rearranger_'>Wrapper for running rearranging methods</h2><span id='topic+rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running rearranging methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearranger_(
  data,
  rearrange_fn,
  check_fn,
  cols = NULL,
  allowed_types = c("numeric", "factor", "character"),
  col = deprecated(),
  overwrite = FALSE,
  origin_fn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_rearrange_fn">rearrange_fn</code></td>
<td>
<p>Rearrange function to apply.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_check_fn">check_fn</code></td>
<td>
<p>Function with checks post-preparation of <code>`data`</code> and <code>`col(s)`</code>.
Should not return anything.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_cols">cols</code></td>
<td>
<p>Column(s) to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_allowed_types">allowed_types</code></td>
<td>
<p>Allowed types of the <code>`col(s)`</code> columns. The type restrictions do not apply to
columns not mentioned in the <code>`col(s)`</code> argument.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="rearranger__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
<tr><td><code id="rearranger__+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="rearranger__+3A_...">...</code></td>
<td>
<p>Named arguments for the <code>`rearrange_fn`</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with (a) sorting factor(s) added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and
no extra factors are returned by <code>`rearrange_fn`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>

<hr>
<h2 id='rearrr_fn_'>Parent function for documentation inheritance</h2><span id='topic+rearrr_fn_'></span>

<h3>Description</h3>

<p>Do not call. Only used to avoid repetition of documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rearrr_fn_(
  data,
  origin_fn,
  check_fn,
  allowed_types,
  force_df,
  min_dims,
  overwrite
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rearrr_fn__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_check_fn">check_fn</code></td>
<td>
<p>Function with checks post-preparation of <code>`data`</code> and <code>`col(s)`</code>.
Should not return anything.</p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_allowed_types">allowed_types</code></td>
<td>
<p>Allowed types of the <code>`col(s)`</code> columns. The type restrictions do not apply to
columns not mentioned in the <code>`col(s)`</code> argument.</p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_force_df">force_df</code></td>
<td>
<p>Whether to return a <code>data.frame</code> when <code>`data`</code> is a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_min_dims">min_dims</code></td>
<td>
<p>Minimum number of dimensions (cols) after preparations. When <code>`data`</code> is a <code>vector</code>
setting <code>`min_dims`</code> to <code>2</code> will use both the index and the values as columns.</p>
</td></tr>
<tr><td><code id="rearrr_fn__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>

<hr>
<h2 id='render_toc'>Render Table of Contents</h2><span id='topic+render_toc'></span>

<h3>Description</h3>

<p>From: https://gist.github.com/gadenbuie/c83e078bf8c81b035e32c3fc0cf04ee8
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_toc(
  filename,
  toc_header_name = "Table of Contents",
  base_level = NULL,
  toc_depth = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_toc_+3A_filename">filename</code></td>
<td>
<p>Name of RMarkdown or Markdown document</p>
</td></tr>
<tr><td><code id="render_toc_+3A_toc_header_name">toc_header_name</code></td>
<td>
<p>The table of contents header name. If specified, any
header with this format will not be included in the TOC. Set to <code>NULL</code> to
include the TOC itself in the TOC (but why?).</p>
</td></tr>
<tr><td><code id="render_toc_+3A_base_level">base_level</code></td>
<td>
<p>Starting level of the lowest header level. Any headers
prior to the first header at the base_level are dropped silently.</p>
</td></tr>
<tr><td><code id="render_toc_+3A_toc_depth">toc_depth</code></td>
<td>
<p>Maximum depth for TOC, relative to base_level. Default is
<code>toc_depth = 3</code>, which results in a TOC of at most 3 levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple function to extract headers from an RMarkdown or Markdown document
and build a table of contents. Returns a markdown list with links to the
headers using
<a href="https://pandoc.org/MANUAL.html">pandoc header identifiers</a>.
</p>
<p>WARNING: This function only works with hash-tag headers.
</p>
<p>Because this function returns only the markdown list, the header for the
Table of Contents itself must be manually included in the text. Use
<code>toc_header_name</code> to exclude the table of contents header from the TOC, or
set to <code>NULL</code> for it to be included.
</p>


<h3>Usage</h3>

<p>Just drop in a chunk where you want the toc to appear (set <code>echo=FALSE</code>):
</p>
<div class="sourceCode"><pre># Table of Contents

```{r echo=FALSE}
render_toc("/path/to/the/file.Rmd")
```
</pre></div>

<hr>
<h2 id='rev_windows'>Reverse order window-wise</h2><span id='topic+rev_windows'></span><span id='topic+rev_windows_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are windowed and reversed within windows.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5, 6)</code>
</p>
<p>With <code>window_size = 3</code>
</p>
<p>Are <strong>ordered as</strong>:
</p>
<p><code>c(3, 2, 1, 6, 4, 5)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_windows(data, window_size, factor_name = ".window", overwrite = FALSE)

rev_windows_vec(data, window_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_windows_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rev_windows_+3A_window_size">window_size</code></td>
<td>
<p>Size of the windows. (Logical)</p>
</td></tr>
<tr><td><code id="rev_windows_+3A_factor_name">factor_name</code></td>
<td>
<p>Name of the factor with window identifiers.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="rev_windows_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the windows factor added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`keep_windows`</code> is <code>FALSE</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:10,
  "A" = sample(1:10),
  "B" = runif(10),
  "C" = LETTERS[1:10],
  "G" = rep(1:2, each = 5),
  stringsAsFactors = FALSE
)

# For vector
rev_windows_vec(1:10, window_size = 3)

# For data frame
rev_windows(df, window_size = 3)
rev_windows(df, window_size = 3, factor_name = NULL)

# Grouped by G
df %&gt;%
  dplyr::select(G, index) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  rev_windows(window_size = 3)

# Plot the extreme pairs
plot(
  x = 1:10,
  y = rev_windows_vec(1:10, window_size = 3)
)
</code></pre>

<hr>
<h2 id='rev_windows_rearranger_'>Wrapper for running centering rearrange methods</h2><span id='topic+rev_windows_rearranger_'></span>

<h3>Description</h3>

<p>Wrapper for running centering rearrange methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_windows_rearranger_(
  data,
  window_size,
  factor_name = ".window",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_windows_rearranger__+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rev_windows_rearranger__+3A_window_size">window_size</code></td>
<td>
<p>Size of the windows. (Logical)</p>
</td></tr>
<tr><td><code id="rev_windows_rearranger__+3A_factor_name">factor_name</code></td>
<td>
<p>Name of the factor with window identifiers.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="rev_windows_rearranger__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the windows factor added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`keep_windows`</code> is <code>`FALSE`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>

<hr>
<h2 id='roll_elements'>Roll elements</h2><span id='topic+roll_elements'></span><span id='topic+roll_elements_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Rolls positions of elements.
</p>
<p>Example:
</p>
<p>Rolling <code>c(1, 2, 3, 4, 5)</code> with <code>`n = 2`</code> becomes:
</p>
<p><code>c(3, 4, 5, 1, 2)</code>
</p>
<p><code>roll_elements_vec()</code> takes and returns a <code>vector</code>.
</p>
<p>Should not be confused with <code><a href="#topic+roll_values">roll_values()</a></code>,
which changes the <em>values</em> of the elements and wraps to a given range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_elements(
  data,
  cols = NULL,
  n = NULL,
  n_fn = NULL,
  n_col_name = ".n",
  overwrite = FALSE,
  ...
)

roll_elements_vec(data, n = NULL, n_fn = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_elements_+3A_data">data</code></td>
<td>
<p><code>vector</code> or <code>data.frame</code> to roll elements of. When a <code>data.frame</code> is
grouped, the rolling is applied group-wise.</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to roll.
If <code>NULL</code>, the <em>index</em> is rolled and used to reorder <code>`data`</code>.
</p>
<p><strong>N.B.</strong> only used when <code>`data`</code> is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_n">n</code></td>
<td>
<p>Number of positions to roll. A positive number rolls <em>left/up</em>.
A negative number rolls <em>right/down</em>.</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_n_fn">n_fn</code></td>
<td>
<p>Function to find <code>`n`</code>. Useful when <code>`data`</code> is a
grouped <code>data.frame</code> and <code>`n`</code> should depend on the rows in the group.
</p>
<p><strong>Input</strong>: Each specified <code>vector</code>/<code>column</code> in <code>`data`</code>
is passed to the function as a separate argument.
</p>
<p><strong>Output</strong>: It should return either a <code>vector</code>
with one <code>integer-like scalar</code> <em>per column</em>
or a single <code>integer-like scalar</code> to use for all columns.
</p>
<p>Can be created with <code><a href="#topic+create_n_fn">create_n_fn()</a></code>.
See also <code><a href="#topic+median_index">median_index()</a></code> and
<code><a href="#topic+median_index">quantile_index()</a></code>.</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_n_col_name">n_col_name</code></td>
<td>
<p>Name of new column with the applied <code>`n`</code> values.
If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of columns with the
same name as <code>`n_col_name`</code>. (Logical)</p>
</td></tr>
<tr><td><code id="roll_elements_+3A_...">...</code></td>
<td>
<p>Extra arguments for <code>`n_fn`</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rolled <code>`data`</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other roll functions: 
<code><a href="#topic+roll_values">roll_values</a>()</code>
</p>
<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Roll vector left
roll_elements(1:10, n = 2)

# Roll vector right and return the vector
roll_elements_vec(1:10, n = -2)

# Roll vector left by median index (rounded to 6)
roll_elements(3:12, n_fn = median_index)

# Roll vector right by median value (rounded to 8)
roll_elements(3:12, n_fn = create_n_fn(median, negate = TRUE))

# Pass extra arguments (here 'prob') to 'n_fn' via '...'
roll_elements(
  1:10,
  n_fn = quantile_index,
  prob = 0.2
)

#
# Roll data.frame
#

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:20,
  "y" = runif(20) * 10,
  "g" = rep(1:4, each = 5)
)

# Roll rows left/up
roll_elements(df, n = 2)

# Roll rows right/down
roll_elements(df, n = -2)

# Roll 'x' column right/down
roll_elements(df, cols = "x", n = -2)

# Roll rows right by median index in each group
# Specify 'negate' for the 'median_index' function
roll_elements(
  df %&gt;% dplyr::group_by(g),
  n_fn = median_index,
  negate = TRUE
)
</code></pre>

<hr>
<h2 id='roll_values'>Shift values and wrap to range</h2><span id='topic+roll_values'></span><span id='topic+wrap_to_range'></span><span id='topic+roll_values_vec'></span><span id='topic+wrap_to_range_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Adds a specified value to each element in the vector and wraps the values around
the min-max range with:
</p>
<p><code class="reqn">(x - .min)</code><code> % </code><code class="reqn">(.max - .min + between) + .min</code>
</p>
<p>Useful when adding to the degrees of a circle, where the values should remain in the
<code>0-360</code> range. A value larger than <code>360</code> will start over from <code>0</code>, e.g. <code class="reqn">365 -&gt; 5</code>,
while a value smaller than <code>0</code> would become e.g. <code class="reqn">-5 -&gt; 355</code>.
Here, <code>0</code> and <code>360</code> are considered the same angle.
If we were instead adding days to the weekdays <code>1-7</code>,
where <code>1</code> and <code>7</code> are separate days,
we can set <code>`between = 1`</code> to have one day in-between them.
</p>
<p><code>wrap_to_range()</code> is a wrapper with <code>`add = 0`</code>.
</p>
<p>The <code>*_vec()</code> versions take and return a vector.
</p>
<p>Should not be confused with <code><a href="#topic+roll_elements">roll_elements()</a></code>,
which changes the <em>positions</em> of the elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roll_values(
  data,
  cols = NULL,
  add = 0,
  .min = NULL,
  .max = NULL,
  between = 0,
  na.rm = FALSE,
  suffix = "_rolled",
  keep_original = TRUE,
  range_col_name = ".range",
  overwrite = FALSE
)

wrap_to_range(
  data,
  cols = NULL,
  .min = NULL,
  .max = NULL,
  between = 0,
  na.rm = FALSE,
  suffix = "_wrapped",
  keep_original = TRUE,
  range_col_name = ".range",
  overwrite = FALSE
)

roll_values_vec(
  data,
  add = 0,
  .min = NULL,
  .max = NULL,
  between = 0,
  na.rm = FALSE
)

wrap_to_range_vec(data, .min = NULL, .max = NULL, between = 0, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_values_+3A_data">data</code></td>
<td>
<p><code>vector</code> or <code>data.frame</code> to roll/wrap values of. When a <code>data.frame</code> is
grouped, the rolling/wrapping is applied group-wise.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_cols">cols</code></td>
<td>
<p>Names of columns to roll/wrap in <code>`data`</code>. Must be specified
when <code>`data`</code> is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_add">add</code></td>
<td>
<p>Amount to add to each element. (<code>numeric scalar</code>)
</p>
<p>When <code>0</code>, the wrapping is applied without any rolling.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_.min">.min</code></td>
<td>
<p>Minimum value allowed. If <code>NULL</code>, the
minimum value in the <code>vector</code>/<code>column</code> is used.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_.max">.max</code></td>
<td>
<p>Maximum value allowed. If <code>NULL</code>, the
maximum value in the <code>vector</code>/<code>column</code> is used.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_between">between</code></td>
<td>
<p>The wrapping distance between <code>`.max`</code> and <code>`.min`</code>.
</p>
<p>When <code>0</code>, they are considered the same. I.e. <code class="reqn">`.max == .min`</code>.
</p>
<p>When <code>1</code>, <code>`x`</code> can be greater than <code>`.max`</code> by up to <code>1</code>, why
<code>`.min`</code> and <code>`.max`</code> are two separate values with <code>1</code> in-between them. I.e.
<code class="reqn">`.max + 1 == .min`</code>.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to remove missing values (<code>NA</code>s)
when finding the <code>`.min`</code> and <code>`.max`</code> values.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_range_col_name">range_col_name</code></td>
<td>
<p>Name of new column with the min-max range. If <code>NULL</code>, no column is added.
</p>
<p><strong>N.B.</strong> Ignored when <code>`data`</code> is a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="roll_values_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>`data`</code> with new columns with values in the specified min-max range(s)
and columns with the applied ranges.
</p>
<p>The <code>*_vec()</code> versions return a <code>vector</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other roll functions: 
<code><a href="#topic+roll_elements">roll_elements</a>()</code>
</p>
<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)

# Add 90 to all degrees
# Note that 0 and 360 is considered the same angle
# why there is no distance between the two
roll_values(c(0:360), add = 90)

# Get as vector
roll_values_vec(c(0:360), add = 90)

# Change limits to 0-180
# so e.g. 270 becomes 90
roll_values(c(0:360), .min = 0, .max = 180)

# Change values first, then wrap to range
x &lt;- c(1:7)
x &lt;- x^2
wrap_to_range(x, .min = 1, .max = 7)

# With 1 in-between .min and .max
wrap_to_range(x, .min = 1, .max = 7, between = 1)

# Get as vector
wrap_to_range_vec(x, .min = 1, .max = 7, between = 1)

#
# Roll data.frame
#

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "w" = 1:7,
  "d" = c(0, 45, 90, 135, 180, 270, 360)
)

# Roll weekdays by 1 day
roll_values(
  df,
  cols = "w",
  add = 1,
  .min = 1,
  .max = 7,
  between = 1
)

# Roll degrees by -90 degrees
roll_values(
  df,
  cols = "d",
  add = -90,
  .min = 0,
  .max = 360,
  between = 0
)

# Roll both weekdays and degrees by 1
# We don't specify .min and .max, so they
# are based on the values in the columns
# Note: This is not that meaningful but shows
# the option
roll_values(
  df,
  cols = c("w", "d"),
  add = 1
)

# Wrap weekdays to 2-5 range
wrap_to_range(
  df,
  cols = "w",
  .min = 2,
  .max = 5,
  between = 1
)
</code></pre>

<hr>
<h2 id='rotate_2d'>Rotate the values around an origin in 2 dimensions</h2><span id='topic+rotate_2d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are rotated counterclockwise around a specified origin.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and rotating around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_2d(
  data,
  degrees,
  x_col = NULL,
  y_col = NULL,
  suffix = "_rotated",
  origin = NULL,
  origin_fn = NULL,
  keep_original = TRUE,
  degrees_col_name = ".degrees",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_2d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_degrees">degrees</code></td>
<td>
<p>Degrees to rotate values counterclockwise. In <code>[-360, 360]</code>.
Can be a <code>vector</code> with multiple degrees.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_x_col">x_col</code></td>
<td>
<p>Name of x column in <code>`data`</code>. If <code>NULL</code> and <code>`data`</code> is a <code>vector</code>,
the index of <code>`data`</code> is used. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_y_col">y_col</code></td>
<td>
<p>Name of y column in <code>`data`</code>. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to rotate around.
A <code>vector</code> with 2 elements (i.e. origin_x, origin_y).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="rotate_2d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the following rotation matrix:</p>

<table>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">cos \theta</code> </td><td style="text-align: left;"> , <code class="reqn"> -sin \theta</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">sin \theta</code> </td><td style="text-align: left;"> , <code class="reqn"> cos \theta</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>That is:
</p>
<p><code class="reqn">x' = x cos \theta - y sin \theta</code>
</p>
<p><code class="reqn">y' = x sin \theta + y cos \theta</code>
</p>
<p>Where <code class="reqn">\theta</code> is the angle in radians.
</p>
<p>As specified at <a href="https://en.wikipedia.org/wiki/Rotation_matrix">Wikipedia/Rotation_matrix</a>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with seven new columns containing
the rotated x-,y- and z-values and the degrees, radiuses and origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other rotation functions: 
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "Index" = 1:12,
  "A" = c(1:4, 9:12, 15:18),
  "G" = rep(1:3, each = 4)
)

# Rotate values around (0, 0)
rotate_2d(df, degrees = 45, x_col = "Index", y_col = "A", origin = c(0, 0))

# Rotate A around the centroid
df_rotated &lt;- df %&gt;%
  rotate_2d(
    x_col = "Index",
    y_col = "A",
    degrees = c(0, 120, 240),
    origin_fn = centroid
  )
df_rotated

# Plot A and A rotated around overall centroid
if (has_ggplot){
  ggplot(df_rotated, aes(x = Index_rotated, y = A_rotated, color = factor(.degrees))) +
    geom_hline(yintercept = mean(df$A), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_vline(xintercept = mean(df$Index), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_line(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "Index", y = "Value", color = "Degrees")
}

# Rotate around group centroids
df_grouped &lt;- df %&gt;%
  dplyr::group_by(G) %&gt;%
  rotate_2d(
    x_col = "Index",
    y_col = "A",
    degrees = c(0, 120, 240),
    origin_fn = centroid
  )
df_grouped

# Plot A and A rotated around group centroids
if (has_ggplot){
  ggplot(df_grouped, aes(x = Index_rotated, y = A_rotated, color = factor(.degrees))) +
    geom_point() +
    theme_minimal() +
    labs(x = "Index", y = "Value", color = "Degrees")
}
</code></pre>

<hr>
<h2 id='rotate_3d'>Rotate the values around an origin in 3 dimensions</h2><span id='topic+rotate_3d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are rotated counterclockwise around a specified origin.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and rotating around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_3d(
  data,
  x_col,
  y_col,
  z_col,
  x_deg = 0,
  y_deg = 0,
  z_deg = 0,
  suffix = "_rotated",
  origin = NULL,
  origin_fn = NULL,
  keep_original = TRUE,
  degrees_col_name = ".degrees",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_3d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_x_col">x_col</code>, <code id="rotate_3d_+3A_y_col">y_col</code>, <code id="rotate_3d_+3A_z_col">z_col</code></td>
<td>
<p>Name of x/y/z column in <code>`data`</code>. All must be specified.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_x_deg">x_deg</code>, <code id="rotate_3d_+3A_y_deg">y_deg</code>, <code id="rotate_3d_+3A_z_deg">z_deg</code></td>
<td>
<p>Degrees to rotate values around the x/y/z-axis counterclockwise. In <code>[-360, 360]</code>.
Can be <code>vector</code>s with multiple degrees.
</p>
<p><code>`x_deg`</code> is <em>roll</em>. <code>`y_deg`</code> is <em>pitch</em>. <code>`z_deg`</code> is <em>yaw</em>.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to rotate around.
<code>Vector</code> with 3 elements (i.e. origin_x, origin_y, origin_z).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees. If <code>NULL</code>, no column is added.
</p>
<p>Also adds a string version with the same name + <code>"_str"</code>, making it easier to group by the degrees
when plotting multiple rotations.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="rotate_3d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies the following rotation matrix:</p>

<table>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">cos \alpha cos \beta</code> </td><td style="text-align: left;"> , <code class="reqn">cos \alpha sin \beta sin \gamma - sin \alpha cos \gamma</code> </td><td style="text-align: left;"> , <code class="reqn">cos \alpha sin \beta cos \gamma + sin \alpha sin \gamma</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">sin \alpha cos \beta</code> </td><td style="text-align: left;"> , <code class="reqn">sin \alpha sin \beta sin \gamma + cos \alpha cos \gamma</code> </td><td style="text-align: left;"> , <code class="reqn">sin \alpha sin \beta cos \gamma - cos \alpha sin \gamma</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">-sin \beta</code> </td><td style="text-align: left;"> , <code class="reqn">cos \beta sin \gamma </code> </td><td style="text-align: left;"> , <code class="reqn">cos \beta cos \gamma</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Where <code class="reqn">\alpha =</code> <code>`z_deg`</code> in radians, <code class="reqn">\beta =</code> <code>`y_deg`</code> in radians, <code class="reqn">\gamma =</code> <code>`x_deg`</code> in radians.
</p>
<p>As specified at <a href="https://en.wikipedia.org/wiki/Rotation_matrix">Wikipedia/Rotation_matrix</a>.
</p>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with six new columns containing
the rotated x-,y- and z-values and the degrees and origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other rotation functions: 
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(3)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:12,
  "y" = c(1:4, 9:12, 15:18),
  "z" = runif(12),
  "g" = rep(1:3, each = 4)
)

# Rotate values 45 degrees around x-axis at (0, 0, 0)
rotate_3d(df, x_col = "x", y_col = "y", z_col = "z", x_deg = 45, origin = c(0, 0, 0))

# Rotate all axes around the centroid
df_rotated &lt;- df %&gt;%
  rotate_3d(
    x_col = "x",
    y_col = "y",
    z_col = "z",
    x_deg = c(0, 72, 144, 216, 288),
    y_deg = c(0, 72, 144, 216, 288),
    z_deg = c(0, 72, 144, 216, 288),
    origin_fn = centroid
  )
df_rotated

# Plot rotations
if (has_ggplot){
  ggplot(df_rotated, aes(x = x_rotated, y = y_rotated, color = .degrees_str, alpha = z_rotated)) +
    geom_vline(xintercept = mean(df$x), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$y), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_line(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "degrees", alpha = "z (opacity)")
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_rotated$x_rotated,
  y = df_rotated$y_rotated,
  z = df_rotated$z_rotated,
  type = "scatter3d",
  mode = "markers",
  color = df_rotated$.degrees_str
)

## End(Not run)


# Rotate randomly around all axes
df_rotated &lt;- df %&gt;%
  rotate_3d(
    x_col = "x",
    y_col = "y",
    z_col = "z",
    x_deg = round(runif(10, min = 0, max = 360)),
    y_deg = round(runif(10, min = 0, max = 360)),
    z_deg = round(runif(10, min = 0, max = 360)),
    origin_fn = centroid
  )
df_rotated

# Plot rotations
if (has_ggplot){
  ggplot(df_rotated, aes(x = x_rotated, y = y_rotated, color = .degrees_str, alpha = z_rotated)) +
    geom_vline(xintercept = mean(df$x), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$y), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_line(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "degrees", alpha = "z (opacity)")
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_rotated$x_rotated,
  y = df_rotated$y_rotated,
  z = df_rotated$z_rotated,
  type = "scatter3d",
  mode = "markers",
  color = df_rotated$.degrees_str
)

## End(Not run)


# Rotate around group centroids
df_grouped &lt;- df %&gt;%
  dplyr::group_by(g) %&gt;%
  rotate_3d(
    x_col = "x",
    y_col = "y",
    z_col = "z",
    x_deg = c(0, 72, 144, 216, 288),
    y_deg = c(0, 72, 144, 216, 288),
    z_deg = c(0, 72, 144, 216, 288),
    origin_fn = centroid
  )

# Plot A and A rotated around group centroids
if (has_ggplot){
  ggplot(df_grouped, aes(x = x_rotated, y = y_rotated, color = .degrees_str, alpha = z_rotated)) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "degrees", alpha = "z (opacity)")
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_grouped$x_rotated,
  y = df_grouped$y_rotated,
  z = df_grouped$z_rotated,
  type = "scatter3d",
  mode = "markers",
  color = df_grouped$.degrees_str
)

## End(Not run)
</code></pre>

<hr>
<h2 id='shear_2d'>Shear the values around an origin in 2 dimensions</h2><span id='topic+shear_2d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Shear a set of 2d points around an origin.
The shearing formulas (excluding the origin movements) is:
</p>
<p style="text-align: center;"><code class="reqn">x' = x + x_shear * y</code>
</p>

<p style="text-align: center;"><code class="reqn">y' = y + y_shear * x</code>
</p>

<p>The data points in <code>`data`</code> are moved prior to the shearing, to bring
the origin to <code>0</code> in all dimensions. After the shearing, the
inverse move is applied to bring the origin back to its original position.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and shearing around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shear_2d(
  data,
  x_shear,
  y_shear = 0,
  x_col = NULL,
  y_col = NULL,
  suffix = "_sheared",
  origin = NULL,
  origin_fn = NULL,
  keep_original = TRUE,
  shear_col_name = ".shear",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shear_2d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_x_shear">x_shear</code></td>
<td>
<p>Shear factor for the x dimension (<code>numeric</code>). Decides the amount of shearing.
Can be a <code>vector</code> with multiple shear factors.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_y_shear">y_shear</code></td>
<td>
<p>Shear factor for the y dimension (<code>numeric</code>). Decides the amount of shearing.
Can be a <code>vector</code> with multiple shear factors.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_x_col">x_col</code></td>
<td>
<p>Name of x column in <code>`data`</code>.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_y_col">y_col</code></td>
<td>
<p>Name of y column in <code>`data`</code>.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to shear around.
<code>Vector</code> with 2 elements (origin_x, origin_y).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="shear_2d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_shear_col_name">shear_col_name</code></td>
<td>
<p>Name of new column with the shearing factors.
If <code>NULL</code>, no column is added.
</p>
<p>Also adds a string version with the same name + <code>"_str"</code>,
making it easier to group by the shearing factors
when plotting multiple shearings.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates.
If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="shear_2d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with sheared columns,
the shearing factors and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other shearing functions: 
<code><a href="#topic+shear_3d">shear_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Create a data frame
df &lt;- data.frame(
  "x" = rep(1:6, each = 2),
  "y" = rep(c(1, 4), 6),
  "g" = rep(1:2, each = 6)
)

# Shear the x variable with regards to y
# around the centroid
df_sheared &lt;- shear_2d(
  data = df,
  x_shear = 2.5,
  x_col = "x",
  y_col = "y",
  origin_fn = centroid
)

# Plot sheared data
# Black: original points
# Red: sheared points
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_sheared, y = y_sheared, color = "red")) +
    theme_minimal()
}

# Shear in both dimensions
df_sheared &lt;- shear_2d(
  data = df,
  x_shear = 2.5,
  y_shear = 2.5,
  x_col = "x",
  y_col = "y",
  origin_fn = centroid
)

# Plot sheared data
# Black: original points
# Red: sheared points
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_sheared,y = y_sheared, color = "red")) +
    theme_minimal()
}

# Shear grouped data frame
# Affects the calculated origin
df_sheared &lt;- shear_2d(
  data = dplyr::group_by(df, g),
  x_shear = 2.5,
  x_col = "x",
  y_col = "y",
  origin_fn = centroid
)

# Plot sheared data
# Black: original points
# Red: sheared points
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_sheared, y = y_sheared, color = "red")) +
    theme_minimal()
}

# Shear a vector with multiple shearing factors
shear_2d(
  data = c(1:10),
  x_shear = c(1, 1.5, 2, 2.5),
  origin = c(0, 0)
)
</code></pre>

<hr>
<h2 id='shear_3d'>Shear values around an origin in 3 dimensions</h2><span id='topic+shear_3d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Shears points around an origin in 3-dimensional space.
See applied shearing matrices under <strong>Details</strong>.
</p>
<p>The data points in <code>`data`</code> are moved prior to the shearing, to bring
the origin to <code>0</code> in all dimensions. After the shearing, the
inverse move is applied to bring the origin back to its original position.
</p>
<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and shearing around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shear_3d(
  data,
  x_col,
  y_col,
  z_col,
  x_shear = NULL,
  y_shear = NULL,
  z_shear = NULL,
  suffix = "_sheared",
  origin = NULL,
  origin_fn = NULL,
  keep_original = TRUE,
  shear_col_name = ".shear",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shear_3d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_x_col">x_col</code>, <code id="shear_3d_+3A_y_col">y_col</code>, <code id="shear_3d_+3A_z_col">z_col</code></td>
<td>
<p>Name of x/y/z column in <code>`data`</code>. All must be specified.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_x_shear">x_shear</code>, <code id="shear_3d_+3A_y_shear">y_shear</code>, <code id="shear_3d_+3A_z_shear">z_shear</code></td>
<td>
<p>Shear factor for the x/y/z dimension (<code>numeric</code>). Decides the amount of shearing.
Can be <code>vector</code>s with multiple shear factors.
</p>
<p><strong>N.B.</strong> Exactly <strong>2</strong> of the dimensions must have shear factors specified.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to shear around.
<code>Vector</code> with 3 elements (i.e. origin_x, origin_y, origin_z).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="shear_3d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_shear_col_name">shear_col_name</code></td>
<td>
<p>Name of new column with the shearing amounts. If <code>NULL</code>, no column is added.
</p>
<p>Also adds a string version with the same name + <code>"_str"</code>, making it easier to group by the shearing amounts
when plotting multiple shears.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="shear_3d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies one of the following transformation matrices, depending on which
two shearing amounts are specified:
</p>
<p>Given <code>`x_shear`</code> and <code>`y_shear`</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">1</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> , <code>x_shear</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> , <code>y_shear</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Given <code>`x_shear`</code> and <code>`z_shear`</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">1</code> </td><td style="text-align: left;"> , <code>x_shear</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">0</code> </td><td style="text-align: left;"> , <code>z_shear</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Given <code>`y_shear`</code> and <code>`z_shear`</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   [ <code class="reqn">1</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code>y_shear</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
   [ <code>z_shear</code> </td><td style="text-align: left;"> , <code class="reqn">0</code> </td><td style="text-align: left;"> , <code class="reqn">1</code> </td><td style="text-align: left;"> ] </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with six new columns containing
the sheared x-, y- and z-values and the shearing amounts and origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other shearing functions: 
<code><a href="#topic+shear_2d">shear_2d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

df_square &lt;- square(runif(100)) %&gt;%
  rename(x = .square_x,
         y = Value) %&gt;%
  mutate(z = 1)

# Shear the x and z axes
# around the centroid
df_sheared &lt;- shear_3d(
  data = df_square,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  x_shear = 2,
  z_shear = 4,
  origin_fn = centroid
)

# Plot sheared data
# Black: original points
# Red: sheared points
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_sheared, y = y_sheared, color = "red")) +
    theme_minimal()
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_sheared$x_sheared,
  y = df_sheared$y_sheared,
  z = df_sheared$z_sheared,
  type = "scatter3d",
  mode = "markers",
  color = df_sheared$.shear_str
)

## End(Not run)

# Shear the y and z axes
# around the centroid
df_sheared &lt;- shear_3d(
  data = df_square,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  y_shear = 2,
  z_shear = 4,
  origin_fn = centroid
)

# Plot sheared data
# Black: original points
# Red: sheared points
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x, y = y)) +
    geom_point() +
    geom_point(aes(x = x_sheared, y = y_sheared, color = "red")) +
    theme_minimal()
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_sheared$x_sheared,
  y = df_sheared$y_sheared,
  z = df_sheared$z_sheared,
  type = "scatter3d",
  mode = "markers",
  color = df_sheared$.shear_str
)

## End(Not run)

# Shear the y and z axes with multiple amounts at once
# around the centroid
df_sheared &lt;- shear_3d(
  data = df_square,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  y_shear = c(0, 2, 4),
  z_shear = c(0, 4, 6),
  origin_fn = centroid
)

# Plot sheared data
if (has_ggplot){
  df_sheared %&gt;%
    ggplot(aes(x = x_sheared, y = y_sheared, color = .shear_str)) +
    geom_point() +
    theme_minimal()
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_sheared$x_sheared,
  y = df_sheared$y_sheared,
  z = df_sheared$z_sheared,
  type = "scatter3d",
  mode = "markers",
  color = df_sheared$.shear_str
)

## End(Not run)
</code></pre>

<hr>
<h2 id='shuffle_hierarchy'>Shuffle multi-column hierarchy of groups</h2><span id='topic+shuffle_hierarchy'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Shuffles a tree/hierarchy of groups, one column at a time.
The levels in the last (&quot;leaf&quot;) column are shuffled first, then the second-last column, and so on.
Elements of the same group are ordered sequentially.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_hierarchy(
  data,
  group_cols,
  cols_to_shuffle = group_cols,
  leaf_has_groups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_hierarchy_+3A_data">data</code></td>
<td>
<p><code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="shuffle_hierarchy_+3A_group_cols">group_cols</code></td>
<td>
<p>Names of columns making up the group hierarchy.
The last column is the <em>leaf</em> and is shuffled first (if also in <code>`cols_to_shuffle`</code>).</p>
</td></tr>
<tr><td><code id="shuffle_hierarchy_+3A_cols_to_shuffle">cols_to_shuffle</code></td>
<td>
<p>Names of columns to shuffle hierarchically.
By default, all the <code>`group_cols`</code> are shuffled.</p>
</td></tr>
<tr><td><code id="shuffle_hierarchy_+3A_leaf_has_groups">leaf_has_groups</code></td>
<td>
<p>Whether the leaf column contains groups or values. (Logical)
</p>
<p>When the elements are <em>group identifiers</em>, they are ordered sequentially and shuffled together.
</p>
<p>When the elements are <em>values</em>, they are simply shuffled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The shuffled <code>data.frame</code> (<code>tibble</code>).
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+triplet_extremes">triplet_extremes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

df &lt;- data.frame(
  'a' = rep(1:4, each = 4),
  'b' = rep(1:8, each = 2),
  'c' = 1:16
)

# Set seed for reproducibility
set.seed(2)

# Shuffle all columns
shuffle_hierarchy(df, group_cols = c('a', 'b', 'c'))

# Don't shuffle 'b' but keep grouping by it
# So 'c' will be shuffled within each group in 'b'
shuffle_hierarchy(
  data = df,
  group_cols = c('a', 'b', 'c'),
  cols_to_shuffle = c('a', 'c')
)

# Shuffle 'b' as if it's not a group column
# so elements are independent within their group
# (i.e. same-valued elements are not necessarily ordered sequentially)
shuffle_hierarchy(df, group_cols = c('a', 'b'), leaf_has_groups = FALSE)
</code></pre>

<hr>
<h2 id='square'>Create x-coordinates so the points form a square</h2><span id='topic+square'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Create the x-coordinates for a <code>vector</code> of y-coordinates such that
they form a rotated square.
</p>
<p>This will likely look most like a square when the y-coordinates are somewhat equally distributed,
e.g. a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>square(
  data,
  y_col = NULL,
  .min = NULL,
  .max = NULL,
  offset_x = 0,
  keep_original = TRUE,
  x_col_name = ".square_x",
  edge_col_name = ".edge",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="square_+3A_y_col">y_col</code></td>
<td>
<p>Name of column in <code>`data`</code> with y-coordinates to create x-coordinates for.</p>
</td></tr>
<tr><td><code id="square_+3A_.min">.min</code></td>
<td>
<p>Minimum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="square_+3A_.max">.max</code></td>
<td>
<p>Maximum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="square_+3A_offset_x">offset_x</code></td>
<td>
<p>Value to offset the x-coordinates by.</p>
</td></tr>
<tr><td><code id="square_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="square_+3A_x_col_name">x_col_name</code></td>
<td>
<p>Name of new column with the x-coordinates.</p>
</td></tr>
<tr><td><code id="square_+3A_edge_col_name">edge_col_name</code></td>
<td>
<p>Name of new column with the edge identifiers. If <code>NULL</code>, no column is added.
</p>
<p>Numbering is clockwise and starts at the upper-right edge.</p>
</td></tr>
<tr><td><code id="square_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the added x-coordinates and an identifier
for the edge the data point is a part of.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other forming functions: 
<code><a href="#topic+circularize">circularize</a>()</code>,
<code><a href="#topic+hexagonalize">hexagonalize</a>()</code>,
<code><a href="#topic+triangularize">triangularize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "y" = runif(200),
  "g" = factor(rep(1:5, each = 40))
)

# Square 'y'
df_sq &lt;- square(df, y_col = "y")
df_sq

# Plot square
if (has_ggplot){
  df_sq %&gt;%
    ggplot(aes(x = .square_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Grouped squaring
#

# Square 'y' for each group
# First cluster the groups a bit to move the
# squares away from each other
df_sq &lt;- df %&gt;%
  cluster_groups(
    cols = "y",
    group_cols = "g",
    suffix = "",
    overwrite = TRUE
  ) %&gt;%
  dplyr::group_by(g) %&gt;%
  square(
    y_col = "y",
    overwrite = TRUE
  )

# Plot squares
if (has_ggplot){
  df_sq %&gt;%
    ggplot(aes(x = .square_x, y = y, color = g)) +
    geom_point() +
    theme_minimal()
}

#
# Specifying minimum value
#

# Specify minimum value manually
df_sq &lt;- square(df, y_col = "y", .min = -2)
df_sq

# Plot square
if (has_ggplot){
  df_sq %&gt;%
    ggplot(aes(x = .square_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Multiple squares by contraction
#

# Start by squaring 'y'
df_sq &lt;- square(df, y_col = "y")

# Contract '.square_x' and 'y' towards the centroid
# To contract with multiple multipliers at once,
# we wrap the call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = c(1, 0.75, 0.5, 0.25, 0.125),
  .f = function(mult) {
    expand_distances(
      data = df_sq,
      cols = c(".square_x", "y"),
      multiplier = mult,
      origin_fn = centroid,
      overwrite = TRUE
    )
  }
)
df_expanded

if (has_ggplot){
  df_expanded %&gt;%
    ggplot(aes(
      x = .square_x_expanded, y = y_expanded,
      color = .edge, alpha = .multiplier
    )) +
    geom_point() +
    theme_minimal()
}
</code></pre>

<hr>
<h2 id='swirl_2d'>Swirl the values around an origin in 2 dimensions</h2><span id='topic+swirl_2d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are swirled counterclockwise around a specified origin.
The swirling is done by rotating around the origin with the degrees based
on the distances to the origin as so: </p>
<p style="text-align: center;"><code class="reqn">degrees = scale_fn(distances) / (2 * radius) * 360</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and swirling around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swirl_2d(
  data,
  radius,
  x_col = NULL,
  y_col = NULL,
  suffix = "_swirled",
  origin = NULL,
  origin_fn = NULL,
  scale_fn = identity,
  keep_original = TRUE,
  degrees_col_name = ".degrees",
  radius_col_name = ".radius",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swirl_2d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_radius">radius</code></td>
<td>
<p>Radius of the most-inner swirl on the x-axis in the <em>simplest</em> case.
A negative number changes the direction to clockwise rotation.
Can be a <code>vector</code> with multiple radiuses.
</p>
<p>Note: With a custom <code>`scaling_fn`</code>, this might not be the actual swirl radius anymore. Think of
it more as a width setting where a larger number leads to fewer full rotations.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_x_col">x_col</code></td>
<td>
<p>Name of x column in <code>`data`</code>. If <code>NULL</code> and <code>`data`</code> is a <code>vector</code>,
the index of <code>`data`</code> is used. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_y_col">y_col</code></td>
<td>
<p>Name of y column in <code>`data`</code>. If <code>`data`</code> is a <code>data.frame</code>, it must be specified.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to swirl around.
<code>Vector</code> with 2 elements (i.e. origin_x, origin_y).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_scale_fn">scale_fn</code></td>
<td>
<p>Function for scaling the distances before calculating the degrees.
</p>
<p><strong>Input</strong>: A <code>numeric vector</code> (the distances).
</p>
<p><strong>Output</strong>: A <code>numeric vector</code> (the scaled distances) of the same length.
</p>
<p>E.g.:
</p>
<p><code>function(d){</code>
</p>
<p><code style="white-space: pre;">&#8288;  &#8288;</code><code>d ^ 1.5</code>
</p>
<p><code>}</code></p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_radius_col_name">radius_col_name</code></td>
<td>
<p>Name of new column with the radius. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="swirl_2d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with three new columns containing
the swirled x- and y-values, the degrees, the radius, and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other rotation functions: 
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_3d">swirl_3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(4)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:50,
  "y" = 1,
  "r1" = runif(50),
  "r2" = runif(50) * 35,
  "g" = rep(1:5, each = 10)
)

# Swirl values around (0, 0)
swirl_2d(
  data = df,
  radius = 45,
  x_col = "x",
  y_col = "y",
  origin = c(0, 0)
)


# Swirl around the centroid
# with 6 different radius settings
# Scale the distances with custom function
df_swirled &lt;- swirl_2d(
  data = df,
  radius = c(95, 96, 97, 98, 99, 100),
  x_col = "x",
  y_col = "y",
  origin_fn = centroid,
  scale_fn = function(d) {
    d^1.6
  }
)

df_swirled

# Plot swirls
if (has_ggplot){
  df_swirled %&gt;%
    ggplot(aes(x = x_swirled, y = y_swirled, color = factor(.radius))) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = ".radius")
}


#
# Swirl random data
# The trick lies in finding the right radius
#

# Swirl the random columns
df_swirled &lt;- swirl_2d(
  data = df,
  radius = 5,
  x_col = "r1",
  y_col = "r2",
  origin_fn = centroid
)

# Plot swirls
if (has_ggplot){
  df_swirled %&gt;%
    ggplot(aes(x = r1_swirled, y = r2_swirled)) +
    geom_point() +
    theme_minimal() +
    labs(x = "r1", y = "r2")
}
</code></pre>

<hr>
<h2 id='swirl_3d'>Swirl the values around an origin in 3 dimensions</h2><span id='topic+swirl_3d'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are swirled counterclockwise around a specified origin.
The swirling is done by rotating around the origin, basing the degrees
for each rotation-axis on the distances to the origin as so:
</p>
<p style="text-align: center;"><code class="reqn">x_degrees = scale_fn(distances) / (2 * x_radius) * 360</code>
</p>

<p>The origin can be supplied as coordinates or as a function that returns coordinates. The
latter can be useful when supplying a grouped <code>data.frame</code> and swirling around e.g. the centroid
of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swirl_3d(
  data,
  x_col,
  y_col,
  z_col,
  x_radius = 0,
  y_radius = 0,
  z_radius = 0,
  suffix = "_swirled",
  origin = NULL,
  origin_fn = NULL,
  scale_fn = identity,
  keep_original = TRUE,
  degrees_col_name = ".degrees",
  radius_col_name = ".radius",
  origin_col_name = ".origin",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swirl_3d_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_x_col">x_col</code>, <code id="swirl_3d_+3A_y_col">y_col</code>, <code id="swirl_3d_+3A_z_col">z_col</code></td>
<td>
<p>Name of x/y/z column in <code>`data`</code>. All must be specified.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_x_radius">x_radius</code>, <code id="swirl_3d_+3A_y_radius">y_radius</code>, <code id="swirl_3d_+3A_z_radius">z_radius</code></td>
<td>
<p>Radiuses of the
most-inner swirls around each axis (in the <em>simplest</em> case).
Can be <code>vector</code>s with multiple radiuses.
</p>
<p>E.g. the <code>`x_radius`</code> specifies the radius when rotating <em>around</em> the x-axis,
not the radius <em>on</em> the x-axis.
</p>
<p>Note: With a custom <code>`scaling_fn`</code>, these might not be the actual swirl radiuses anymore. Think of
them more as width settings where a larger number leads to fewer full rotations.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_origin">origin</code></td>
<td>
<p>Coordinates of the origin to swirl around.
<code>Vector</code> with 3 elements (i.e. origin_x, origin_y, origin_z).
Ignored when <code>`origin_fn`</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_origin_fn">origin_fn</code></td>
<td>
<p>Function for finding the origin coordinates.
</p>
<p><strong>Input</strong>: Each column will be passed as a <code>vector</code> in the order of <code>`cols`</code>.
</p>
<p><strong>Output</strong>: A <code>vector</code> with one scalar per dimension.
</p>
<p>Can be created with <code><a href="#topic+create_origin_fn">create_origin_fn()</a></code> if you want to apply
the same function to each dimension.
</p>
<p>E.g. <code>`create_origin_fn(median)`</code> would find the median of each column.
</p>
<p><strong>Built-in functions</strong> are <code><a href="#topic+centroid">centroid()</a></code>,
<code><a href="#topic+most_centered">most_centered()</a></code>,
and <code><a href="#topic+midrange">midrange()</a></code></p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_scale_fn">scale_fn</code></td>
<td>
<p>Function for scaling the distances before calculating the degrees.
</p>
<p><strong>Input</strong>: A <code>numeric vector</code> (the distances).
</p>
<p><strong>Output</strong>: A <code>numeric vector</code> (the scaled distances) of the same length.
</p>
<p>E.g.:
</p>
<p><code>function(d){</code>
</p>
<p><code style="white-space: pre;">&#8288;  &#8288;</code><code>d ^ 1.5</code>
</p>
<p><code>}</code></p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_degrees_col_name">degrees_col_name</code></td>
<td>
<p>Name of new column with the degrees. If <code>NULL</code>, no column is added.
</p>
<p>Also adds a string version with the same name + <code>"_str"</code>, making it easier to group by the degrees
when plotting multiple rotations.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_radius_col_name">radius_col_name</code></td>
<td>
<p>Name of new column with the radiuses. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_origin_col_name">origin_col_name</code></td>
<td>
<p>Name of new column with the origin coordinates. If <code>NULL</code>, no column is added.</p>
</td></tr>
<tr><td><code id="swirl_3d_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with new columns containing
the swirled x- and y-values, the degrees, the radiuses, and the origin coordinates.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other mutate functions: 
<code><a href="#topic+apply_transformation_matrix">apply_transformation_matrix</a>()</code>,
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+flip_values">flip_values</a>()</code>,
<code><a href="#topic+roll_values">roll_values</a>()</code>,
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+shear_2d">shear_2d</a>()</code>,
<code><a href="#topic+shear_3d">shear_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>
</p>
<p>Other rotation functions: 
<code><a href="#topic+rotate_2d">rotate_2d</a>()</code>,
<code><a href="#topic+rotate_3d">rotate_3d</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>
</p>
<p>Other distance functions: 
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+dim_values">dim_values</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>,
<code><a href="#topic+expand_distances">expand_distances</a>()</code>,
<code><a href="#topic+expand_distances_each">expand_distances_each</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+swirl_2d">swirl_2d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(4)

# Create a data frame
df &lt;- data.frame(
  "x" = 1:50,
  "y" = 1:50,
  "z" = 1:50,
  "r1" = runif(50),
  "r2" = runif(50) * 35,
  "o" = 1,
  "g" = rep(1:5, each = 10)
)

# Swirl values around (0, 0, 0)
swirl_3d(
  data = df,
  x_radius = 45,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  origin = c(0, 0, 0)
)

# Swirl around the centroid
df_swirled &lt;- swirl_3d(
  data = df,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  x_radius = c(100, 0, 0),
  y_radius = c(0, 100, 0),
  z_radius = c(0, 0, 100),
  origin_fn = centroid
)

df_swirled

# Plot swirls
if (has_ggplot){
  ggplot(df_swirled, aes(x = x_swirled, y = y_swirled, color = .radius_str, alpha = z_swirled)) +
    geom_vline(xintercept = mean(df$x), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$y), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_path(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "radius", alpha = "z (opacity)")
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_swirled$x_swirled,
  y = df_swirled$y_swirled,
  z = df_swirled$z_swirled,
  type = "scatter3d",
  mode = "markers",
  color = df_swirled$.radius_str
)

## End(Not run)

# Swirl around the centroid
df_swirled &lt;- swirl_3d(
  data = df,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  x_radius = c(50, 0, 0),
  y_radius = c(0, 50, 0),
  z_radius = c(0, 0, 50),
  origin_fn = centroid
)

df_swirled

# Plot swirls
if (has_ggplot){
  ggplot(df_swirled, aes(x = x_swirled, y = y_swirled, color = .radius_str, alpha = z_swirled)) +
    geom_vline(xintercept = mean(df$x), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$y), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_path(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "radius", alpha = "z (opacity)")
}

## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_swirled$x_swirled,
  y = df_swirled$y_swirled,
  z = df_swirled$z_swirled,
  type = "scatter3d",
  mode = "markers",
  color = df_swirled$.radius_str
)

## End(Not run)


df_swirled &lt;- swirl_3d(
  data = df,
  x_col = "x",
  y_col = "y",
  z_col = "z",
  x_radius = c(25, 50, 25, 25),
  y_radius = c(50, 75, 100, 25),
  z_radius = c(75, 25, 25, 25),
  origin_fn = centroid,
  scale_fn = function(x) {
    x^0.81
  }
)

# Plot swirls
if (has_ggplot){
  ggplot(df_swirled, aes(x = x_swirled, y = y_swirled, color = .radius_str, alpha = z_swirled)) +
    geom_vline(xintercept = mean(df$x), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$y), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_path(alpha = .4) +
    geom_point() +
    theme_minimal() +
    labs(x = "x", y = "y", color = "radius", alpha = "z (opacity)")
}


## Not run: 
# Plot 3d with plotly
plotly::plot_ly(
  x = df_swirled$x_swirled,
  y = df_swirled$y_swirled,
  z = df_swirled$z_swirled,
  type = "scatter3d",
  mode = "markers",
  color = df_swirled$.radius_str
)

## End(Not run)


#
# Swirl random data
# The trick lies in finding the right radiuses
#

# Swirl the random columns
df_swirled &lt;- swirl_3d(
  data = df,
  x_col = "r1",
  y_col = "r2",
  z_col = "o",
  x_radius = c(0, 0, 0, 0),
  y_radius = c(0, 30, 60, 90),
  z_radius = c(10, 10, 10, 10),
  origin_fn = centroid
)

# Not let's rotate it every 10 degrees
df_rotated &lt;- df_swirled %&gt;%
  rotate_3d(
    x_col = "r1_swirled",
    y_col = "r2_swirled",
    z_col = "o_swirled",
    x_deg = rep(0, 36),
    y_deg = rep(0, 36),
    z_deg = (1:36) * 10,
    suffix = "",
    origin = df_swirled$.origin[[1]],
    overwrite = TRUE
  )

# Plot rotated swirls
if (has_ggplot){
  ggplot(
    df_rotated,
    aes(
      x = r1_swirled,
      y = r2_swirled,
      color = .degrees_str,
      alpha = o_swirled
    )
  ) +
    geom_vline(xintercept = mean(df$r1), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_hline(yintercept = mean(df$r2), size = 0.2, alpha = .4, linetype = "dashed") +
    geom_point(show.legend = FALSE) +
    theme_minimal() +
    labs(x = "r1", y = "r2", color = "radius", alpha = "o (opacity)")
}

</code></pre>

<hr>
<h2 id='to_unit_length'>Scale to unit length</h2><span id='topic+to_unit_length'></span><span id='topic+to_unit_length_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Scales the vectors to unit length <em>row-wise</em> or <em>column-wise</em>.
</p>
<p>The <code>*_vec()</code> version take and return a <code>vector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_unit_length(
  data,
  cols = NULL,
  by_row = is.data.frame(data),
  suffix = ifelse(isTRUE(by_row), "_row_unit", "_col_unit"),
  overwrite = FALSE
)

to_unit_length_vec(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_unit_length_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="to_unit_length_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to scale.</p>
</td></tr>
<tr><td><code id="to_unit_length_+3A_by_row">by_row</code></td>
<td>
<p>Whether to scale row <code>vector</code>s instead of column <code>vector</code>s. (Logical)
</p>
<p>Note: Disable when <code>`data`</code> is a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="to_unit_length_+3A_suffix">suffix</code></td>
<td>
<p>Suffix to add to the names of the generated columns.
</p>
<p>Use an empty string (i.e. <code>""</code>) to overwrite the original columns.</p>
</td></tr>
<tr><td><code id="to_unit_length_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scaled <code>vector</code> or <code>data.frame</code> (<code>tibble</code>) with the scaled columns.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other scaling functions: 
<code><a href="#topic+min_max_scale">min_max_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Scale row-wise
to_unit_length(df, cols = c("x", "y"), by_row = TRUE)

# Scale column-wise
to_unit_length(df, cols = c("x", "y"), by_row = FALSE)

# Overwrite columns
to_unit_length(df, cols = c("x", "y"), suffix = "", overwrite = TRUE)

# By groups in 'g'
df %&gt;%
  dplyr::group_by(g) %&gt;%
  to_unit_length(cols = c("x", "y"), by_row = FALSE)

# Scale a vector
to_unit_length_vec(c(1:10))
to_unit_length(c(1:10), suffix = "", overwrite = TRUE)
vector_length(to_unit_length_vec(c(1:10)))
</code></pre>

<hr>
<h2 id='transfer_centroids'>Transfer centroids from one data frame to another</h2><span id='topic+transfer_centroids'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Given two <code>data.frames</code> with the same columns (and groupings),
transfer the centroids from one to the other.
</p>
<p>This is commonly used to restore the centroids after transforming the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_centroids(to_data, from_data, cols, group_cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transfer_centroids_+3A_to_data">to_data</code></td>
<td>
<p><code>data.frame</code>.
</p>
<p>Existing <code>`dplyr`</code> groups are ignored. Specify in <code>`group_cols`</code> instead.</p>
</td></tr>
<tr><td><code id="transfer_centroids_+3A_from_data">from_data</code></td>
<td>
<p><code>data.frame</code> with the same columns (and groupings) as <code>`to_data`</code>.
</p>
<p>Existing <code>`dplyr`</code> groups are ignored. Specify in <code>`group_cols`</code> instead.</p>
</td></tr>
<tr><td><code id="transfer_centroids_+3A_cols">cols</code></td>
<td>
<p>Names of numeric columns to transfer centroids to.
Must exist in both <code>`to_data`</code> and <code>`from_data`</code>.</p>
</td></tr>
<tr><td><code id="transfer_centroids_+3A_group_cols">group_cols</code></td>
<td>
<p>Names of grouping columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>`to_data`</code> <code>data.frame</code> (<code>tibble</code>) with the
centroids from the <code>`from_data`</code> <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other clustering functions: 
<code><a href="#topic+cluster_groups">cluster_groups</a>()</code>,
<code><a href="#topic+generate_clusters">generate_clusters</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Create another data frame with different x and y values
df2 &lt;- df
df2$x &lt;- runif(20)
df2$y &lt;- runif(20)

# Check centroids before transfer

df %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::summarize_all(mean)

df2 %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::summarize_all(mean)

# Now let's transfer the centroids from df to df2

df3 &lt;- transfer_centroids(
  to_data = df2,
  from_data = df,
  cols = c("x", "y"),
  group_cols = "g"
)

# Check that the transfer gave us the same centroids as df
df3 %&gt;%
  dplyr::group_by(g) %&gt;%
  dplyr::summarize_all(mean)
</code></pre>

<hr>
<h2 id='Transformation'>Transformation</h2><span id='topic+Transformation'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Container for the type of transformation used in
<code><a href="#topic+Pipeline">Pipeline</a></code>.
</p>
<p><strong>Note</strong>: For internal use.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>group_cols</code></dt><dd><p>Names of columns to group <code>data.frame</code>
by before applying <code>`fn`</code>.
</p>
<p>When <code>`NULL`</code>, the <code>data.frame</code> is not grouped.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Transformation-new"><code>Transformation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Transformation-apply"><code>Transformation$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Transformation-print"><code>Transformation$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Transformation-clone"><code>Transformation$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Transformation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transformation$new(fn, args, name = NULL, group_cols = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Transformation function.</p>
</dd>
<dt><code>args</code></dt><dd><p><code>list</code> of arguments for <code>`fn`</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Name of transformation.</p>
</dd>
<dt><code>group_cols</code></dt><dd><p>Names of columns to group <code>data.frame</code>
by before applying <code>`fn`</code>.
</p>
<p>When <code>`NULL`</code>, the <code>data.frame</code> is not grouped.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Transformation-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Apply the transformation to a <code>data.frame</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transformation$apply(data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame</code>.
</p>
<p>A grouped <code>data.frame</code> will first be ungrouped. If <code>`group_cols`</code> is specified,
it will then be grouped by those columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Transformed version of <code>`data`</code>.
</p>


<hr>
<a id="method-Transformation-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print an overview of the transformation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transformation$print(..., indent = 0, show_class = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>further arguments passed to or from other methods.</p>
</dd>
<dt><code>indent</code></dt><dd><p>How many spaces to indent when printing.</p>
</dd>
<dt><code>show_class</code></dt><dd><p>Whether to print the transformation class name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The pipeline. To allow chaining of methods.
</p>


<hr>
<a id="method-Transformation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Transformation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other transformation classes: 
<code><a href="#topic+FixedGroupsTransformation">FixedGroupsTransformation</a></code>,
<code><a href="#topic+GeneratedTransformation">GeneratedTransformation</a></code>
</p>

<hr>
<h2 id='triangularize'>Create x-coordinates so the points form a triangle</h2><span id='topic+triangularize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Create the x-coordinates for a <code>vector</code> of y-coordinates such that
they form a triangle.
</p>
<p>The data points are stochastically distributed based on edge lengths, why it might be preferable to
set a random seed.
</p>
<p>This will likely look most like a triangle when the y-coordinates are somewhat equally distributed,
e.g. a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangularize(
  data,
  y_col = NULL,
  .min = NULL,
  .max = NULL,
  offset_x = 0,
  keep_original = TRUE,
  x_col_name = ".triangle_x",
  edge_col_name = ".edge",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangularize_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_y_col">y_col</code></td>
<td>
<p>Name of column in <code>`data`</code> with y-coordinates to create x-coordinates for.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_.min">.min</code></td>
<td>
<p>Minimum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_.max">.max</code></td>
<td>
<p>Maximum y-coordinate. If <code>NULL</code>, it is inferred by the given y-coordinates.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_offset_x">offset_x</code></td>
<td>
<p>Value to offset the x-coordinates by.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_keep_original">keep_original</code></td>
<td>
<p>Whether to keep the original columns. (Logical)
</p>
<p>Some columns may have been overwritten, in which case only the newest versions are returned.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_x_col_name">x_col_name</code></td>
<td>
<p>Name of new column with the x-coordinates.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_edge_col_name">edge_col_name</code></td>
<td>
<p>Name of new column with the edge identifiers. If <code>NULL</code>, no column is added.
</p>
<p>Numbering is clockwise and starts at the upper-right edge.</p>
</td></tr>
<tr><td><code id="triangularize_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> (<code>tibble</code>) with the added x-coordinates and an identifier
for the edge the data point is a part of.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other forming functions: 
<code><a href="#topic+circularize">circularize</a>()</code>,
<code><a href="#topic+hexagonalize">hexagonalize</a>()</code>,
<code><a href="#topic+square">square</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)
library(purrr)
has_ggplot &lt;- require(ggplot2)  # Attach if installed

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "y" = runif(200),
  "g" = factor(rep(1:5, each = 40))
)

# Triangularize 'y'
df_tri &lt;- triangularize(df, y_col = "y")
df_tri

# Plot triangle
if (has_ggplot){
  df_tri %&gt;%
    ggplot(aes(x = .triangle_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Grouped squaring
#

# Triangularize 'y' for each group
# First cluster the groups a bit to move the
# triangles away from each other
df_tri &lt;- df %&gt;%
  cluster_groups(
    cols = "y",
    group_cols = "g",
    suffix = "",
    overwrite = TRUE
  ) %&gt;%
  dplyr::group_by(g) %&gt;%
  triangularize(
    y_col = "y",
    overwrite = TRUE
  )

# Plot triangles
if (has_ggplot){
  df_tri %&gt;%
    ggplot(aes(x = .triangle_x, y = y, color = g)) +
    geom_point() +
    theme_minimal()
}

#
# Specifying minimum value
#

# Specify minimum value manually
df_tri &lt;- triangularize(df, y_col = "y", .min = -2)
df_tri

# Plot triangle
if (has_ggplot){
  df_tri %&gt;%
    ggplot(aes(x = .triangle_x, y = y, color = .edge)) +
    geom_point() +
    theme_minimal()
}

#
# Multiple triangles by contraction
#


# Start by squaring 'y'
df_tri &lt;- triangularize(df, y_col = "y")

# Contract '.triangle_x' and 'y' towards the centroid
# To contract with multiple multipliers at once,
# we wrap the call in purrr::map_dfr
df_expanded &lt;- purrr::map_dfr(
  .x = 1:10 / 10,
  .f = function(mult) {
    expand_distances(
      data = df_tri,
      cols = c(".triangle_x", "y"),
      multiplier = mult,
      origin_fn = centroid,
      overwrite = TRUE
    )
  }
)
df_expanded

if (has_ggplot){
  df_expanded %&gt;%
    ggplot(aes(
      x = .triangle_x_expanded, y = y_expanded,
      color = .edge, alpha = .multiplier
    )) +
    geom_point() +
    theme_minimal()
}

</code></pre>

<hr>
<h2 id='triplet_extremes'>Makes triplets of extreme values and sort by them</h2><span id='topic+triplet_extremes'></span><span id='topic+triplet_extremes_vec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>The values are grouped in three such that the first group is formed by
the lowest and highest values and the value closest to the median,
the second group is formed by the second lowest and second
highest values and the value second closest to the median, and so on.
The values are then sorted by these groups and their actual value.
</p>
<p>When the number of rows/elements in <code>`data`</code> is not evenly divisible by three,
the <code>`unequal_method_1`</code> (single excessive element) and
<code>`unequal_method_2`</code> (two excessive elements)
determines which element(s) should form a smaller group.
This group will be the first group <em>in a given grouping</em> (see <code>`num_groupings`</code>)
with the identifier <code>1</code>.
</p>
<p>The <code>*_vec()</code> version takes and returns a <code>vector</code>.
</p>
<p><strong>Example</strong>:
</p>
<p>The column values:
</p>
<p><code>c(1, 2, 3, 4, 5, 6)</code>
</p>
<p>Are sorted in triplets as:
</p>
<p><code>c(1, 3, 6, 2, 4, 5)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triplet_extremes(
  data,
  col = NULL,
  middle_is = "middle",
  unequal_method_1 = "middle",
  unequal_method_2 = c("middle", "middle"),
  num_groupings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_triplets = FALSE,
  factor_name = ifelse(num_groupings == 1, ".triplet", ".tripleting"),
  overwrite = FALSE
)

triplet_extremes_vec(
  data,
  middle_is = "middle",
  unequal_method_1 = "middle",
  unequal_method_2 = c("middle", "middle"),
  num_groupings = 1,
  balance = "mean",
  order_by_aggregates = FALSE,
  shuffle_members = FALSE,
  shuffle_triplets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triplet_extremes_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_col">col</code></td>
<td>
<p>Column to create sorting factor by.
When <code>`NULL`</code> and <code>`data`</code> is a <code>data.frame</code>,
the row numbers are used.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_middle_is">middle_is</code></td>
<td>
<p>Whether the middle element in the triplet is the nth closest element
to the median value or the nth+1 lowest/highest value.
</p>
<p>One of: <code>middle</code> (default), <code>min</code>, or <code>max</code>.
</p>
<p>Triplet grouping is performed greedily from the most extreme values to the least extreme
values. E.g. <code>c(1, 6, 12)</code> is created before <code>c(2, 5, 11)</code> which is made
before <code>c(3, 7, 10)</code>.
</p>
<p><strong>Examples</strong>:
</p>
<p>When <code>`middle_is` == 'middle'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 6, 12), c(2, 7, 11), c(3, 5, 10),  c(4, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'min'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 2, 12), c(3, 4, 11), c(5, 6, 10),  c(7, 8, 9) )</code>
</p>
<p>When <code>`middle_is` == 'max'</code>, a <code>1:12</code> sequence is grouped into:
</p>
<p><code>c( c(1, 11, 12), c(2, 9, 10), c(3, 7, 8),  c(4, 5, 6) )</code></p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_unequal_method_1">unequal_method_1</code>, <code id="triplet_extremes_+3A_unequal_method_2">unequal_method_2</code></td>
<td>
<p>Method for dealing with either
a single excessive element (<code>`unequal_method_1`</code>) or two excessive elements (<code>`unequal_method_2`</code>)
when the number of rows/elements in <code>`data`</code> are not evenly divisible by three.
</p>
<p><code>`unequal_method_1`</code>: One of: <code>min</code>, <code>middle</code> or <code>max</code>.
</p>
<p><code>`unequal_method_2`</code>: Vector with two of: <code>min</code>, <code>middle</code> or <code>max</code>. Can be the same value twice.
</p>
<p>Note: The excessive element(s) are extracted before triplet grouping. These elements
are put in their own group and given group identifier <code>1</code>.
</p>
<p>E.g. When <code>`unequal_method_2`</code> is <code>c("middle", "middle")</code> the two elements
closest to the median are extracted.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_num_groupings">num_groupings</code></td>
<td>
<p>Number of times to group into triplets (recursively). At least <code>1</code>.
</p>
<p>Based on <code>`balance`</code>, the secondary groupings perform extreme triplet grouping on either the
<em>sum</em>, <em>absolute difference</em>, <em>min</em>, or <em>max</em> of the triplet elements.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_balance">balance</code></td>
<td>
<p>What to balance triplets for in a given <em>secondary</em> triplet grouping.
Either <code>"mean"</code>, <code>"spread"</code>, <code>"min"</code>, or <code>"max"</code>.
Can be a single string used for all secondary groupings
or one for each secondary grouping (<code>`num_groupings` - 1</code>).
</p>
<p>The first triplet grouping always groups the actual element values.
</p>


<h4>mean</h4>

<p>Triplets have similar means. The values in the triplets from the previous grouping
are aggregated with <code>`sum()`</code> and extreme triplet grouped.
</p>



<h4>spread</h4>

<p>Triplets have similar spread (e.g. standard deviations). The values in the triplets
from the previous triplet grouping are aggregated with <code>`sum(abs(diff()))`</code> and
extreme triplet grouped.
</p>



<h4>min / max</h4>

<p>Triplets have similar minimum / maximum values. The values in the triplets from the
previous triplet grouping are aggregated with <code>`min()`</code> / <code>`max()`</code> and extreme
triplet grouped.
</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_order_by_aggregates">order_by_aggregates</code></td>
<td>
<p>Whether to order the groups from initial groupings (first <code>`num_groupings` - 1</code>)
by their aggregate values instead of their group identifiers.
</p>
<p>N.B. Only used when <code>`num_groupings` &gt; 1</code>.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_shuffle_members">shuffle_members</code></td>
<td>
<p>Whether to shuffle the order of the group members within the groups. (Logical)</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_shuffle_triplets">shuffle_triplets</code></td>
<td>
<p>Whether to shuffle the order of the triplets. Triplet members remain together. (Logical)</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_factor_name">factor_name</code></td>
<td>
<p>Name of new column with the sorting factor.
If <code>`NULL`</code>, no column is added.</p>
</td></tr>
<tr><td><code id="triplet_extremes_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted <code>data.frame</code> (<code>tibble</code>) / <code>vector</code>.
Optionally with the sorting factor added.
</p>
<p>When <code>`data`</code> is a <code>vector</code> and <code>`keep_factors`</code> is <code>`FALSE`</code>,
the output will be a <code>vector</code>. Otherwise, a <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other rearrange functions: 
<code><a href="#topic+center_max">center_max</a>()</code>,
<code><a href="#topic+center_min">center_min</a>()</code>,
<code><a href="#topic+closest_to">closest_to</a>()</code>,
<code><a href="#topic+furthest_from">furthest_from</a>()</code>,
<code><a href="#topic+pair_extremes">pair_extremes</a>()</code>,
<code><a href="#topic+position_max">position_max</a>()</code>,
<code><a href="#topic+position_min">position_min</a>()</code>,
<code><a href="#topic+rev_windows">rev_windows</a>()</code>,
<code><a href="#topic+roll_elements">roll_elements</a>()</code>,
<code><a href="#topic+shuffle_hierarchy">shuffle_hierarchy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "index" = 1:12,
  "A" = sample(1:12),
  "B" = runif(12),
  "C" = LETTERS[1:12],
  "G" = c(
    1, 1, 1, 1, 2, 2,
    2, 2, 3, 3, 3, 3
  ),
  stringsAsFactors = FALSE
)

# Triplet group extreme indices (row numbers)
triplet_extremes(df)

# Triplet group extremes in each of the columns
triplet_extremes(df, col = "A")$A
triplet_extremes(df, col = "B")$B
triplet_extremes(df, col = "C")$C

# Shuffle the members triplet-wise
# The triplets maintain their order
# but the rows within each triplet are shuffled
triplet_extremes(df, col = "A", shuffle_members = TRUE)

# Shuffle the order of the triplets
# The triplets are shuffled but
# the rows within each triplet maintain their order
triplet_extremes(df, col = "A", shuffle_triplets = TRUE)

# Use recursive grouping
# Mostly meaningful with much larger datasets
# Order initial grouping by group identifiers
triplet_extremes(df, col = "A", num_groupings = 2)
# Order initial grouping by aggregate values
triplet_extremes(df, col = "A", num_groupings = 2, order_by_aggregates = TRUE)

# Grouped by G
# Each G group only has 4 elements
# so it only creates 1 triplet and a group
# with the single excessive element
# per G group
df %&gt;%
  dplyr::select(G, A) %&gt;% # For clarity
  dplyr::group_by(G) %&gt;%
  triplet_extremes(col = "A")

# Plot the extreme triplets
plot(
  x = 1:12,
  y = triplet_extremes(df, col = "A")$A,
  col = as.character(rep(1:4, each = 3))
)
# With shuffled triplet members (run a few times)
plot(
  x = 1:12,
  y = triplet_extremes(df, col = "A", shuffle_members = TRUE)$A,
  col = as.character(rep(1:4, each = 3))
)
# With shuffled triplets (run a few times)
plot(
  x = rep(1:6, each = 2),
  y = triplet_extremes(df, col = "A", shuffle_triplets = TRUE)$A,
  col = as.character(rep(1:4, each = 3))
)
</code></pre>

<hr>
<h2 id='vector_length'>Calculate vector length(s)</h2><span id='topic+vector_length'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates vector lengths/magnitudes <em>row-</em> or <em>column-wise</em> with
</p>
<p style="text-align: center;"><code class="reqn">sqrt(sum(x^2))</code>
</p>

<p>Where <code class="reqn">x</code> is the <code>vector</code> to get the length/magnitude of.
</p>
<p>Should not be confused with <code><a href="base.html#topic+length">length()</a></code>, which counts the elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_length(
  data,
  cols = NULL,
  by_row = is.data.frame(data),
  len_col_name = ".vec_len",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_length_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>vector</code>.</p>
</td></tr>
<tr><td><code id="vector_length_+3A_cols">cols</code></td>
<td>
<p>Names of columns in <code>`data`</code> to measure vector length of.</p>
</td></tr>
<tr><td><code id="vector_length_+3A_by_row">by_row</code></td>
<td>
<p>Whether to measure length of row vectors instead of column vectors. (Logical)
</p>
<p>Note: Disable when <code>`data`</code> is a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="vector_length_+3A_len_col_name">len_col_name</code></td>
<td>
<p>Name of new column with the row vector lengths when
<code>`data`</code> is a <code>data.frame</code> and <code>`by_row`</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vector_length_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to allow overwriting of existing columns. (Logical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector length(s).
</p>
<p>When <code>`data`</code> is a <code>vector</code>: <code>scalar</code>
</p>
<p>When <code>`data`</code> is a <code>data.frame</code> and <code>`by_row`</code> is <code>TRUE</code>:
<code>`data`</code> with an extra column with row vector lengths.
</p>
<p>When <code>`data`</code> is a <code>data.frame</code> and <code>`by_row`</code> is <code>FALSE</code>:
A <code>data.frame</code> with the summarized column vector lengths.
</p>


<h3>Author(s)</h3>

<p>Ludvig Renbo Olsen, <a href="mailto:r-pkgs@ludvigolsen.dk">r-pkgs@ludvigolsen.dk</a>
</p>


<h3>See Also</h3>

<p>Other measuring functions: 
<code><a href="#topic+angle">angle</a>()</code>,
<code><a href="#topic+distance">distance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Attach packages
library(rearrr)
library(dplyr)

# Set seed
set.seed(1)

# Create a data frame
df &lt;- data.frame(
  "x" = runif(20),
  "y" = runif(20),
  "g" = rep(1:4, each = 5)
)

# Measure row-wise
vector_length(df, cols = c("x", "y"), by_row = TRUE)

# Measure column-wise
vector_length(df, cols = c("x", "y"), by_row = FALSE)

# By groups in 'g'
df %&gt;%
  dplyr::group_by(g) %&gt;%
  vector_length(cols = c("x", "y"), by_row = FALSE)

# Measure vector length of a vector
vector_length(c(1:10))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
