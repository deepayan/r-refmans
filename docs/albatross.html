<!DOCTYPE html><html><head><title>Help for package albatross</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {albatross}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#albatross-package'>
<p>PARAFAC Analysis of Fluorescence Excitation-Emission Matrices</p></a></li>
<li><a href='#[.feem'><p>Extract or replace parts of FEEM objects</p></a></li>
<li><a href='#[.feemcube'><p>Extract or replace parts of FEEM cubes</p></a></li>
<li><a href='#absindex'><p>Functions of absorbance data</p></a></li>
<li><a href='#as.data.frame.feem'><p>Transform a FEEM object into a data.frame</p></a></li>
<li><a href='#cmf'><p>Implementation notes for constrained matrix factorisation</p></a></li>
<li><a href='#feem'>
<p>Create a fluorescence excitation-emission matrix object</p></a></li>
<li><a href='#feemcube'><p>Data cubes of fluorescence excitation-emission matrices</p></a></li>
<li><a href='#feemflame'>
<p>Fluorescence and scAttering Model Estimation</p></a></li>
<li><a href='#feemgrid'>
<p>Interpolate FEEMs on a given wavelength grid</p></a></li>
<li><a href='#feemife'><p>Absorbance-based inner filter effect correction</p></a></li>
<li><a href='#feemindex'><p>Fluorescence indices and peak values</p></a></li>
<li><a href='#feemjackknife'><p>Jack-knife outlier detection in PARAFAC models</p></a></li>
<li><a href='#feemlist'><p>Create lists of FEEM objects</p></a></li>
<li><a href='#feemparafac'>
<p>Compute PARAFAC on a FEEM cube object and access the results</p></a></li>
<li><a href='#feems'>
<p>Synthetic fluorescence excitation-emission matrices and absorbance spectra</p></a></li>
<li><a href='#feemscale'><p>Rescale FEEM spectra to a given norm and remember the scale factor</p></a></li>
<li><a href='#feemscatter'><p>Handle scattering signal in FEEMs</p></a></li>
<li><a href='#feemsplithalf'><p>Split-half analysis of PARAFAC models</p></a></li>
<li><a href='#marine.colours'><p>Perceptually uniform palettes</p></a></li>
<li><a href='#plot.feem'><p>Plot a FEEM object</p></a></li>
<li><a href='#whittaker2'>
<p>Implementation notes for Whittaker smoothing and interpolation of surfaces</p></a></li>
<li><a href='#write.openfluor'><p>Export a PARAFAC model for the OpenFluor database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>PARAFAC Analysis of Fluorescence Excitation-Emission Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>multiway (&ge; 1.0-4), CMLS, pracma, lattice, parallel, Matrix</td>
</tr>
<tr>
<td>Enhances:</td>
<td>eemR, EEM</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform parallel factor analysis (PARAFAC: Hitchcock, 1927)
	&lt;<a href="https://doi.org/10.1002%2Fsapm192761164">doi:10.1002/sapm192761164</a>&gt; on fluorescence excitation-emission
	matrices: handle scattering signal and inner filter effect, scale
	the dataset, fit the model; perform split-half validation or
	jack-knifing. Modified approaches such as Whittaker interpolation,
	randomised split-half, and fluorescence and scattering model
	estimation are also available. The package has a low dependency
	footprint and has been tested on a wide range of R versions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>BuildManual:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-10 18:43:10 UTC; nobody</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Krylov [aut, cre],
  Timur Labutin [ths],
  Anastasia Drozdova [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Krylov &lt;ikrylov@laser.chem.msu.ru&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-10 21:03:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='albatross-package'>
PARAFAC Analysis of Fluorescence Excitation-Emission Matrices
</h2><span id='topic+albatross-package'></span><span id='topic+albatross'></span>

<h3>Description</h3>

<div style="text-align: right; font-size: small;">

<p>Day after day, day after day, <br />
We stuck, nor breath nor motion; <br />
As idle as a painted ship <br />
Upon a painted ocean.
</p>
<p>Water, water, every where, <br />
And all the boards did shrink; <br />
Water, water, every where, <br />
Nor any drop to drink.
</p>
<p>&ndash; Samuel Taylor Coleridge, <em>The Rime of the Ancient Mariner</em>
</p>

</div>
<p>Perform parallel factor analysis (PARAFAC: Hitchcock, 1927)
	&lt;doi:10.1002/sapm192761164&gt; on fluorescence excitation-emission
	matrices: handle scattering signal and inner filter effect, scale
	the dataset, fit the model; perform split-half validation or
	jack-knifing. Modified approaches such as Whittaker interpolation,
	randomised split-half, and fluorescence and scattering model
	estimation are also available. The package has a low dependency
	footprint and has been tested on a wide range of R versions.
</p>


<h3>Details</h3>

<p>In order to work with your data, create <code><a href="#topic+feem">feem</a></code> and/or
<code><a href="#topic+feemcube">feemcube</a></code> objects from files or matrix or array objects.
Use <code><a href="#topic+feemlist">feemlist</a></code> to import files in bulk. If your files
aren't in one of the formats supported by <code><a href="#topic+feem">feem</a></code> but you
can read their contents by other means, you can supply an importer
function to <code><a href="#topic+feemlist">feemlist</a></code>; it should take a file name and
return the corresponding <code><a href="#topic+feem">feem</a></code> object.
</p>
<p>Operations that can be performed on the objects include plotting
(<code><a href="#topic+plot.feem">plot.feem</a></code>), calculation of fluorescence indices
(<code><a href="#topic+feemindex">feemindex</a></code>), inner-filter effect correction
(<code><a href="#topic+feemife">feemife</a></code>), handling of scattering signal
(<code><a href="#topic+feemscatter">feemscatter</a></code>), changing the wavelength grid of the data
by means of interpolation (<code><a href="#topic+feemgrid">feemgrid</a></code>), and scaling
(<code><a href="#topic+feemscale">feemscale</a></code>). Scaling may be automatically undone after
performing the PARAFAC decomposition so that the resulting scores
would correspond to the data as it was before the scaling.
</p>
<p>All processing functions can take individual <code><a href="#topic+feem">feem</a></code>
objects, lists of them, or <code><a href="#topic+feemcube">feemcube</a></code> objects and return
values of the appropriate kind. For example, <code><a href="#topic+feemscatter">feemscatter</a></code>
always returns an object of the same class but with the scattering
signal handled, while <code><a href="#topic+feemindex">feemindex</a></code> returns named numeric
vectors for individual <code><a href="#topic+feem">feem</a></code>s but
<code><a href="base.html#topic+data.frame">data.frame</a></code>s for collections of them. There's a
slight memory benefit to using lists of <code><a href="#topic+feem">feem</a></code> objects,
but the difference shouldn't be noticeable, so there's nothing to
worry about if you started with a <code><a href="#topic+feemcube">feemcube</a></code>.
</p>
<p>In order to compute PARAFAC, you need to convert your data into a
<code><a href="#topic+feemcube">feemcube</a></code>. Whether you perform jack-knifing, split-half
analysis, or PARAFAC itself, a copy of the data cube is kept together
with the results and can be extracted back using the
<code><a href="#topic+feemcube">feemcube</a></code> function. The resulting objects support a
<code>plot</code> method (described in the same help page) and can give you
the data as a few-column <code><a href="base.html#topic+data.frame">data.frame</a></code> using the
<code>coef</code> method.
</p>
<p>Once the analysis is finished, the PARAFAC model can be exported for
the OpenFluor database (<code><a href="#topic+write.openfluor">write.openfluor</a></code>) or stored as an
<span class="rlang"><b>R</b></span> object using standard <span class="rlang"><b>R</b></span> tools (<code><a href="base.html#topic+save">save</a></code> or
<code><a href="base.html#topic+saveRDS">saveRDS</a></code>).
</p>

<p>Index of help topics:
</p>
<pre>
[.feem                  Extract or replace parts of FEEM objects
[.feemcube              Extract or replace parts of FEEM cubes
absindex                Functions of absorbance data
albatross-package       PARAFAC Analysis of Fluorescence
                        Excitation-Emission Matrices
as.data.frame.feem      Transform a FEEM object into a data.frame
feem                    Create a fluorescence excitation-emission
                        matrix object
feemcube                Data cubes of fluorescence excitation-emission
                        matrices
feemflame               Fluorescence and scAttering Model Estimation
feemgrid                Interpolate FEEMs on a given wavelength grid
feemife                 Absorbance-based inner filter effect correction
feemindex               Fluorescence indices and peak values
feemjackknife           Jack-knife outlier detection in PARAFAC models
feemlist                Create lists of FEEM objects
feemparafac             Compute PARAFAC on a FEEM cube object and
                        access the results
feems                   Synthetic fluorescence excitation-emission
                        matrices and absorbance spectra
feemscale               Rescale FEEM spectra to a given norm and
                        remember the scale factor
feemscatter             Handle scattering signal in FEEMs
feemsplithalf           Split-half analysis of PARAFAC models
marine.colours          Perceptually uniform palettes
plot.feem               Plot a FEEM object
write.openfluor         Export a PARAFAC model for the OpenFluor
                        database
</pre>


<h3>Author(s)</h3>

<p>Ivan Krylov [aut, cre],
  Timur Labutin [ths],
  Anastasia Drozdova [rev]</p>


<h3>References</h3>

<p>Murphy KR, Stedmon CA, Graeber D, Bro R (2013).
&ldquo;Fluorescence spectroscopy and multi-way techniques. PARAFAC.&rdquo;
<em>Analytical Methods</em>, <b>5</b>, 6557-6566.
<a href="https://doi.org/10.1039/c3ay41160e">doi:10.1039/c3ay41160e</a>.
</p>
<p>Pucher M, Wünsch U, Weigelhofer G, Murphy K, Hein T, Graeber D (2019).
&ldquo;staRdom: Versatile Software for Analyzing Spectroscopic Data of Dissolved Organic Matter in R.&rdquo;
<em>Water</em>, <b>11</b>(11), 2366.
<a href="https://doi.org/10.3390/w11112366">doi:10.3390/w11112366</a>.
</p>
<p>Cleese J, Jones T (1970).
&ldquo;Albatross: Flavours of different sea birds.&rdquo;
<em>Journal of Flying Circus</em>, <b>1.13</b>, 7:05-7:45.
</p>
<p>Krylov I, Drozdova A, Labutin T (2020).
&ldquo;Albatross R package to study PARAFAC components of DOM fluorescence from mixing zones of arctic shelf seas.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>207</b>(104176).
<a href="https://doi.org/10.1016/j.chemolab.2020.104176">doi:10.1016/j.chemolab.2020.104176</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code>, <code><a href="#topic+feemlist">feemlist</a></code>, <code><a href="#topic+feemindex">feemindex</a></code>,
<code><a href="#topic+feemife">feemife</a></code>, <code><a href="#topic+feemscatter">feemscatter</a></code>,
<code><a href="#topic+feemgrid">feemgrid</a></code>, <code><a href="#topic+feemcube">feemcube</a></code>,
<code><a href="#topic+feemscale">feemscale</a></code>, <code><a href="#topic+feemsplithalf">feemsplithalf</a></code>,
<code><a href="#topic+feemparafac">feemparafac</a></code>, <code><a href="#topic+feemjackknife">feemjackknife</a></code>,
<code><a href="#topic+feemflame">feemflame</a></code>, <code><a href="#topic+absindex">absindex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)

  dataset &lt;- feemcube(feems, FALSE)
  dataset &lt;- feemscatter(dataset, rep(24, 4), 'pchip')
  dataset &lt;- feemife(dataset, absorp)
  plot(dataset &lt;- feemscale(dataset, na.rm = TRUE))

  
    # takes a long time
    (sh &lt;- feemsplithalf(cube, nfac = 2:5, splits = 4))
    plot(sh)
    jk &lt;- feemjackknife(cube, nfac = 3)
    plot(jk)
  

  pf &lt;- feemparafac(cube, nfac = 3)
  plot(pf)
</code></pre>

<hr>
<h2 id='+5B.feem'>Extract or replace parts of FEEM objects</h2><span id='topic++5B.feem'></span><span id='topic++5B+3C-.feem'></span>

<h3>Description</h3>

<p>Extract or replace parts of FEEM spectra. Returns FEEM objects unless
dimensions should be dropped. When assigning from a FEEM object,
requires wavelengths to match and warns if scale factors differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'feem'
x[i, j, drop = TRUE]
  ## S3 replacement method for class 'feem'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.feem_+3A_x">x</code></td>
<td>

<p>A FEEM object.
</p>
</td></tr>
<tr><td><code id="+2B5B.feem_+3A_i">i</code>, <code id="+2B5B.feem_+3A_j">j</code></td>
<td>

<p>Row and column indices, respectively. As in usual <span class="rlang"><b>R</b></span> subsetting
(see <a href="base.html#topic+Extract">Extract</a>), may be integer, logical or character vectors,
or missing.
</p>
</td></tr>
<tr><td><code id="+2B5B.feem_+3A_drop">drop</code></td>
<td>

<p>Coerce result to the lowest possible dimension (dropping the
<code>feem</code> class if so).
</p>
</td></tr>
<tr><td><code id="+2B5B.feem_+3A_value">value</code></td>
<td>

<p>An array-like object to assign values from. When assigning from
FEEM objects, wavelengths are required to match and warnings are
issued if scale factors don't match. Use vector subsetting (zero or
one argument inside the brackets) to disable the check.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>[</code>: If <code>drop</code> is <code>TRUE</code> and at least one of the
index arguments chooses only one element along its axis, a named
numeric vector. Otherwise, a FEEM object.
</p>
<p>For <code>[&lt;-</code>: a FEEM object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code>, <code><a href="#topic++5B.feemcube">[.feemcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  (z &lt;- feem(matrix(1:40, ncol = 8), 66 + 1:5, 99 + 1:8, 3))
  str(z[1:4, 1:2])
  str(z[1,, drop = TRUE])
  z[2:3, 4:5] &lt;- feem(matrix(1:4, 2), 66 + 2:3, 99 + 4:5, 3)
  z
</code></pre>

<hr>
<h2 id='+5B.feemcube'>Extract or replace parts of FEEM cubes</h2><span id='topic++5B.feemcube'></span><span id='topic++5B+3C-.feemcube'></span>

<h3>Description</h3>

<p>Extract or replace single intensities, vectors of them, whole FEEM
spectra or even data cubes or their parts from a FEEM cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'feemcube'
x[i, j, k, drop = TRUE]
  ## S3 replacement method for class 'feemcube'
x[i, j, k] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.feemcube_+3A_x">x</code></td>
<td>

<p>A FEEM cube object.
</p>
</td></tr>
<tr><td><code id="+2B5B.feemcube_+3A_i">i</code>, <code id="+2B5B.feemcube_+3A_j">j</code>, <code id="+2B5B.feemcube_+3A_k">k</code></td>
<td>

<p>Row, column and sample indices, respectively. As usual, may be
integer, logical or character vectors. Omitting a parameter results
in choosing the whole axis.
</p>
</td></tr>
<tr><td><code id="+2B5B.feemcube_+3A_drop">drop</code></td>
<td>

<p>Coerce result to the lowest possible dimension (dropping the
<code>feemcube</code> class).
</p>
</td></tr>
<tr><td><code id="+2B5B.feemcube_+3A_value">value</code></td>
<td>

<p>An array-like object to assign values from. When assigning from
FEEM or FEEM cube objects, wavelengths are required to match and
warnings are issued if scale factors don't match. Use vector
subsetting (zero or one argument inside the brackets) to disable the
check.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>[</code>: If choosing multiple values along each axis or
<code>drop</code> is <code>FALSE</code>, a FEEM cube object. If choosing only one
sample but multiple wavelengths, a FEEM object. Otherwise, a named
numeric matrix or vector, depending on the dimensions chosen.
</p>
<p>For <code>[&lt;-</code>: a FEEM cube object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemcube">feemcube</a></code>, <code><a href="#topic++5B.feem">[.feem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z &lt;- feemcube(array(1:385, c(5, 7, 11)), 1:5, 1:7, 1:11)
  str(z[1:4, 1:2, 1:2])
  z[2:3, 4:5, 3] &lt;- feem(matrix(1:4, 2), 2:3, 4:5, 3)
  z[,,3]
</code></pre>

<hr>
<h2 id='absindex'>Functions of absorbance data</h2><span id='topic+absindex'></span>

<h3>Description</h3>

<p>Calculate absorption coefficients and/or absorbance data at given
wavelengths, spectral slopes, and their ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  absindex(
    x, abs.path, unit = c("log10", "m^-1"), out.A = 254,
    out.a = c(350, 355, 374, 443),
    out.a.ratio = list(c(250, 365), c(465, 665)),
    out.slope = list(c(275, 295), c(350, 400)),
    out.slope.ratio = list(c(275, 295, 350, 400)),
    out.slope.nrmse = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absindex_+3A_x">x</code></td>
<td>

<p>Absorption data, either a <code><a href="base.html#topic+list">list</a></code> of two-column
matrix-like objects with wavelengths in first column and values in
second column, or a multi-column matrix-like object with wavelengths
in first column and values in all other columns. Can be named in
order to match with the <code>abs.path</code> values, see
<code><a href="#topic+feemife">feemife</a></code> for details.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_abs.path">abs.path</code></td>
<td>

<p>A numeric vector of optical path lengths for every spectrum, in
centimetres. Defaults to <code class="reqn">1</code> for all samples. If specified,
should be either named, with names matching <code>x</code>, or unnamed and
containing exactly the same number of path lengths.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_unit">unit</code></td>
<td>

<p>Specifies whether <code>x</code> contains absorbance (<code style="white-space: pre;">&#8288;log10&#8288;</code>;
<code class="reqn">A = \log_{10}\frac{I_0}{I}</code>;
unitless) or absorption coefficients (<code style="white-space: pre;">&#8288;m^-1&#8288;</code>;
<code class="reqn">
      \alpha = \frac{\ln \frac{I_0}{I}}{l}
    </code>;
<code class="reqn">[\mathrm{m}^{-1}]</code>).
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.a">out.A</code></td>
<td>

<p>Return absorbance values at the wavelengths given as a numeric
vector.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.a">out.a</code></td>
<td>

<p>Return absorption coefficients at the wavelengths given as a numeric
vector.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.a.ratio">out.a.ratio</code></td>
<td>

<p>Return ratios of absorption coefficients at the wavelengths given as
a list of two-element numeric vectors. For every pair of
wavelengths, <code class="reqn">\frac{\alpha(\lambda_1)}{\alpha(\lambda_2)}
    </code> is returned.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.slope">out.slope</code></td>
<td>

<p>Return spectral slopes at wavelength ranges given as a list of
two-element numeric vectors. See the <code>slope.method</code> for the
description of how spectral slopes are computed.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.slope.ratio">out.slope.ratio</code></td>
<td>

<p>Return ratios of spectral slopes for pairs of wavelength ranges
given as a list of four-element numeric vectors. For every list
element, the value returned is <code class="reqn">
      \frac{S(\lambda_1, \lambda_2)}{S(\lambda_3, \lambda_4)}
    </code>.
</p>
</td></tr>
<tr><td><code id="absindex_+3A_out.slope.nrmse">out.slope.nrmse</code></td>
<td>

<p>When computing slopes, also return the root-mean-square error for
the models providing them, divided by the range of the response:
<code class="reqn">
      \frac{1}{y_\mathrm{max} - y_\mathrm{min}}
      \sqrt{\sum_{i=1}^n\frac{(\hat{y}_i - y_i)^2}{n}}
    </code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the spectral slopes are calculated by fitting a linear
model <code class="reqn">
      \ln \alpha = b_0 - b_1 \lambda
    </code> and returning <code class="reqn">b_1</code> as the slope. See
(Twardowski, Boss, Sullivan, and Donaghay 2004) for a discussion of the calculation methods for
spectral slopes.
</p>
<p>Requested wavelengths missing from the original grid are interpolated
using <code><a href="stats.html#topic+spline">spline</a></code>. <code>NA</code> values are returned
outside the original wavelength range.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with one row per sample, containing
the following columns:
</p>
<table>
<tr><td><code>sample</code></td>
<td>

<p>Names or numbers of the samples.
</p>
</td></tr>
<tr><td><code>A.&lt;wavelength&gt;</code></td>
<td>

<p>Absorbance values, for every <var>wavelength</var> in <code>out.A</code>.
</p>
</td></tr>
<tr><td><code>a.&lt;wavelength&gt;</code></td>
<td>

<p>Absorption coefficients, for every <var>wavelength</var> in <code>out.a</code>.
</p>
</td></tr>
<tr><td><code>aR.&lt;wl[1]&gt;.&lt;wl[2]&gt;</code></td>
<td>

<p>Ratios of absorption coefficients, for every <var>wl</var> in
<code>out.a.ratio</code>.
</p>
</td></tr>
<tr><td><code>S.&lt;wl[1]&gt;.&lt;wl[2]&gt;</code></td>
<td>

<p>Spectral slopes, for every <var>wl</var> in <code>out.slope</code>.
</p>
</td></tr>
<tr><td><code>NRMSE.S.&lt;wl[1]&gt;.&lt;wl[2]&gt;</code></td>
<td>

<p>If <code>out.slope.nrmse</code> is <code>TRUE</code>, root-mean-square errors
normalised by the range of the absorption coefficients for the
models providing spectral slopes.
</p>
</td></tr>
<tr><td><code>SR.&lt;wl[1]&gt;.&lt;wl[2]&gt;.&lt;wl[3]&gt;.&lt;wl[4]&gt;</code></td>
<td>

<p>Ratios of spectral slopes, for every <var>wl</var> in
<code>out.slope.ratio</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p> Twardowski MS, Boss E, Sullivan JM, Donaghay PL (2004).
&ldquo;Modeling the spectral shape of absorption by chromophoric dissolved organic matter.&rdquo;
<em>Marine Chemistry</em>, <b>89</b>(1), 69-88.
<a href="https://doi.org/10.1016/j.marchem.2004.02.008">doi:10.1016/j.marchem.2004.02.008</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemife">feemife</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  absindex(absorp)
</code></pre>

<hr>
<h2 id='as.data.frame.feem'>Transform a FEEM object into a data.frame</h2><span id='topic+as.data.frame.feem'></span><span id='topic+as.data.frame.feemcube'></span>

<h3>Description</h3>

<p>Transform a FEEM object from its matrix form accompanied by vectors of
wavelengths into a three-column form consisting of <code class="reqn">
    (\lambda_\mathrm{em}, \lambda_\mathrm{ex}, I)
  </code> tuples, which could be useful for
export or plotting with <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> or <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'feem'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
  ## S3 method for class 'feemcube'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.feem_+3A_x">x</code></td>
<td>

<p>A FEEM object, or a FEEM cube object.
</p>
</td></tr>
<tr><td><code id="as.data.frame.feem_+3A_row.names">row.names</code></td>
<td>

<p>Passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>. If default of <code>NULL</code>
is used, <code><a href="base.html#topic+data.frame">data.frame</a></code> will generate sequential
integer <code>row.names</code>.
</p>
</td></tr>
<tr><td><code id="as.data.frame.feem_+3A_optional">optional</code></td>
<td>

<p>This option is required for compatibility with
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> generic, but is ignored, since the
column names are already syntactic and the row names are generated
by <code><a href="base.html#topic+data.frame">data.frame</a></code> automatically by default.
</p>
</td></tr>
<tr><td><code id="as.data.frame.feem_+3A_...">...</code></td>
<td>

<p>Passed as-is to <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rows where intensity is <code>NA</code> are omitted from the output.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing three numeric columns:
</p>
<table>
<tr><td><code>emission</code></td>
<td>
<p>Emission wavelength, nm.</p>
</td></tr>
<tr><td><code>excitation</code></td>
<td>
<p>Excitation wavelength, nm.</p>
</td></tr>
<tr><td><code>intensity</code></td>
<td>

<p>Fluorescence intensity at
<code class="reqn">
      (\lambda_\mathrm{em}, \lambda_\mathrm{ex})
    </code>
</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>

<p>For FEEM cube objects, the unique name of the sample possessing this
tuple of values, a factor. If the original object didn't have any
names, sequential integers are used instead. If the original object
had non-unique names, sequence numbers are appended to them using
<code><a href="base.html#topic+make.unique">make.unique</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+feem.data.frame">feem.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  z &lt;- feem(matrix(1:42, nrow = 7), 1:7, 1:6)
  head(as.data.frame(z))
</code></pre>

<hr>
<h2 id='cmf'>Implementation notes for constrained matrix factorisation</h2><span id='topic+cmf'></span><span id='topic+fitted.cmf'></span><span id='topic+wcmls'></span>

<h3>Description</h3>


<dl>
<dt>cmf</dt><dd>
<p>Compute a low-rank matrix factorisation <code class="reqn">
        \min_{\mathbf A, \mathbf B}
        || (\mathbf X - \mathbf A \mathbf{B}^\top ) \circ \mathbf W ||_\mathrm F
      </code> subject to weights <code class="reqn">\mathbf W</code> (set to <code class="reqn">0</code>
where <code class="reqn">\mathbf X</code> is not defined) and constraints
on rows of <code class="reqn">\mathbf{A}, \mathbf{B}</code>.
</p>
</dd>
<dt>wcmls</dt><dd>
<p>Solve the weighted multivariate least squares problem <code class="reqn">
        \min_\mathbf{B}
        || (\mathbf X - \mathbf A \mathbf{B}^\top) \circ \mathbf W ||_\mathrm F
      </code> subject to constraints on rows of <code class="reqn">\mathbf B</code>.
</p>
</dd>
</dl>

<p><em>This is not a public interface.</em> Subject to change without
further notice. Please do not call from outside <a href="https://CRAN.R-project.org/package=albatross"><span class="pkg">albatross</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cmf(
    X, nfac = 1,
    const = list(list(const = "nonneg"), list(const = "nonneg")),
    start = c("svd", "random"), ctol = 1e-04, maxiter = 10
  )
  ## S3 method for class 'cmf'
fitted(object, ...)
  wcmls(X, A, W, ..., struc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmf_+3A_x">X</code></td>
<td>

<p>The matrix for a low-rank approximation.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_nfac">nfac</code></td>
<td>

<p>The rank of the factorisation; the number of columns in matrices
<code class="reqn">\mathbf A, \mathbf B</code>.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_const">const</code></td>
<td>

<p>Constraints on the two matrices: a list of two lists of arguments to
pass to <code>wcmls</code> when computing the corresponding matrix.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_start">start</code></td>
<td>

<p>A <code>cmf</code> object to take the starting values from.
Alternatively, a string: </p>

<dl>
<dt>svd</dt><dd>
<p>Compute a truncated SVD <code class="reqn">
          \mathbf X =
          \mathbf U \,
          \mathrm{diag}(\sigma_1, \dots, \sigma_k)
          \, \mathbf{V}^\top
        </code>.
Use
<code class="reqn">
          \mathbf A = \mathbf U \,
          \mathrm{diag}(\sqrt{\sigma_1}, \dots, \sqrt{\sigma_k})
        </code>,
<code class="reqn">
          \mathbf B = \mathbf V \,
          \mathrm{diag}(\sqrt{\sigma_1}, \dots, \sqrt{\sigma_k})
        </code> as the starting values.
</p>
</dd>
<dt>random</dt><dd>
<p>Use uniformly distributed nonnegative starting values rescaled to
be of comparable norms.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="cmf_+3A_ctol">ctol</code></td>
<td>

<p>Given <code class="reqn">L = ||
      (\mathbf X - \mathbf A \mathbf{B}^\top ) \circ \mathbf W
    ||_\mathrm F</code>,
stop when
<code class="reqn">
      \frac{|\Delta L|}{L} \le \mathtt{ctol}
    </code>.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_maxiter">maxiter</code></td>
<td>

<p>Iteration number limit.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_object">object</code></td>
<td>

<p>An object of class <code>cmf</code>.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_a">A</code></td>
<td>

<p>The predictor matrix in the weighted multivariate least squares
problem.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_w">W</code></td>
<td>

<p>The weights matrix.
</p>
</td></tr>
<tr><td><code id="cmf_+3A_...">...</code>, <code id="cmf_+3A_struc">struc</code></td>
<td>

<dl>
<dt>wcmls</dt><dd><p>Passed to <code><a href="CMLS.html#topic+cmls">cmls</a></code>.</p>
</dd>
<dt>fitted.cmf</dt><dd><p>Ignored.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="https://CRAN.R-project.org/package=CMLS"><span class="pkg">CMLS</span></a> package function <code><a href="CMLS.html#topic+cmls">cmls</a></code> can solve
constrained multivariate least squares problems of the form:
</p>
<p style="text-align: center;"><code class="reqn">
    \min_\mathbf{B} || \mathbf X - \mathbf A \mathbf B ||_\mathrm F
    = L(\mathbf X, \mathbf A, \mathbf B)
  </code>
</p>

<p>We use it to solve a weighted problem. Let
<code class="reqn">\mathbf X, \mathbf W</code> be
<code class="reqn">(m \times n)</code> matrices,
<code class="reqn">\mathbf A</code> be an
<code class="reqn">(m \times k)</code> matrix,
<code class="reqn">\mathbf B</code> be an
<code class="reqn">(n \times k)</code>
matrix,
<code class="reqn">\mathbf{J}_{p,q}</code> be a
<code class="reqn">(p \times q)</code> matrix of ones:
</p>
<p style="text-align: center;"><code class="reqn">
    \min_\mathbf{B}
    || \mathbf W \circ (\mathbf X - \mathbf A \mathbf B^\top) ||_\mathrm F
    = \sum_{i,j} (
      w_{i,j} x_{i,j} - w_{i,j} \mathbf{a}_{i,\cdot} \mathbf{b}_{j,\cdot}^\top
    )^2
    = {}
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    {} = \sum_j ||
      \mathbf{w}_{\cdot,j} \circ \mathbf{x}_{\cdot,j} - (
        (\mathbf{w}_{\cdot,j} \mathbf{J}_{1,k}) \circ \mathbf A
      ) \mathbf{b}_{j,\cdot}^\top
    ||_\mathrm F
    = \sum_j L(
      \mathbf{w}_{\cdot,j} \circ \mathbf{x}_{\cdot,j},
      (\mathbf{w}_{\cdot,j} \mathbf{J}_{1,k}) \circ \mathbf A,
      \mathbf{b}_{j,\cdot}^\top
    )
  </code>
</p>

<p>Here, <code class="reqn">\mathbf{w}_{\cdot,j}</code>
and <code class="reqn">\mathbf{x}_{\cdot,j}</code>
are columns of <code class="reqn">\mathbf W</code> and
<code class="reqn">\mathbf X</code>, while
<code class="reqn">\mathbf{a}_{i,\cdot}</code> and
<code class="reqn">\mathbf{b}_{j,\cdot}</code> are
rows of <code class="reqn">\mathbf A</code> and <code class="reqn">\mathbf B</code>,
respectively. Thus, in the weighted case, the
<code class="reqn">\mathbf B</code> matrix is determined row by row by
calling the <code><a href="CMLS.html#topic+cmls">cmls</a></code> function for pre-processed
<code class="reqn">\mathbf A</code> matrix and columns of
<code class="reqn">\mathbf X</code>.
</p>
<p>The problem we're actually interested in is a low-rank approximation
of <code class="reqn">\mathbf X</code>. It doesn't have a unique solution,
especially if the rank is more than <code class="reqn">1</code>, unless we apply
constraints and some luck. We solve it by starting with (typically)
SVD and refining the solution with alternating least squares until it
satisfies the constraints: <code class="reqn">
    \min_\mathbf{B}
    || (\mathbf X - \mathbf A \mathbf{B}^\top) \circ \mathbf W ||_\mathrm F
  </code> and <code class="reqn">
    \min_\mathbf{A} ||
    (\mathbf{X}^\top - \mathbf B \mathbf{A}^\top) \circ \mathbf{W}^\top
    ||_\mathrm F
  </code>.
</p>


<h3>Value</h3>


<dl>
<dt>cmf</dt><dd>
<p>An list of class <code>cmf</code> containing the
<code class="reqn">\mathbf A, \mathbf B</code> matrices.
</p>
</dd>
<dt>wcmls</dt><dd>
<p>The <code class="reqn">\mathbf B</code> matrix solving the constrained weighted
multivariate least squares problem.
</p>
</dd>
<dt>fitted.cmf</dt><dd>
<p>A matrix reconstructed from its <code>nfac</code>-rank decomposition.
</p>
</dd>
</dl>


<h3>References</h3>

<p>de Juan A, Jaumot J, Tauler R (2014).
&ldquo;Multivariate Curve Resolution (MCR). Solving the mixture analysis problem.&rdquo;
<em>Anal. Methods</em>, <b>6</b>, 4964-4976.
<a href="https://doi.org/10.1039/c4ay00571f">doi:10.1039/c4ay00571f</a>.
</p>


<h3>See Also</h3>

<p><code><a href="CMLS.html#topic+cmls">cmls</a></code>; the <a href="https://CRAN.R-project.org/package=ALS"><span class="pkg">ALS</span></a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  z &lt;- feemscatter(feems$a, rep(25, 4), 'omit')
  str(zf &lt;- albatross:::cmf(unclass(z)))
  str(albatross:::fitted.cmf(zf))
</code></pre>

<hr>
<h2 id='feem'>
Create a fluorescence excitation-emission matrix object
</h2><span id='topic+feem'></span><span id='topic+feem.matrix'></span><span id='topic+feem.data.frame'></span><span id='topic+feem.character'></span><span id='topic+feem.connection'></span><span id='topic+t.feem'></span>

<h3>Description</h3>

<p>Functions to create fluorescence excitation-emission matrix objects from
<span class="rlang"><b>R</b></span> matrices coupled with excitation and emission wavelengths, three-column
<code>data.frame</code>s containing <code class="reqn">
    (\lambda_\mathrm{em}, \lambda_\mathrm{ex}, I)
  </code> tuples or files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feem(x, ...)
  ## S3 method for class 'matrix'
feem(x, emission, excitation, scale = 1, ...)
  ## S3 method for class 'data.frame'
feem(
    x, scale = 1, emission = 'emission',
    excitation = 'excitation', intensity = 'intensity', ...
  )
  ## S3 method for class 'character'
feem(x, format, ...)
  ## S3 method for class 'connection'
feem(x, format, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feem_+3A_x">x</code></td>
<td>

<p>The source of the information to create a FEEM object from: a matrix,
a three-column <code>data.frame</code>, a file path as a single string,
or a <a href="base.html#topic+connection">connection</a>.
</p>
<p>If converting a matrix, its rows should correspond to different
fluorescence emission wavelengths specified in the <code>emission</code>
argument; conversely, its columns should correspond to excitation
wavelengths specified in the <code>excitation</code> argument.
</p>
<p>If converting a <code>data.frame</code>, it should have exactly three
columns containing emission wavelengths, excitation wavelength,
and intensity values. The names of the columns are expected to be
&ldquo;emission&rdquo;, &ldquo;excitation&rdquo;, and &ldquo;intensity&rdquo;,
respectively, but can be overridden using namesake arguments.
</p>
<p>If reading a single file by file path or connection, the <code>format</code>
argument must specify the kind of file to parse, see below.
</p>
</td></tr>
<tr><td><code id="feem_+3A_emission">emission</code></td>
<td>

<p>If converting a matrix, this should be a vector of emission wavelengths,
each wavelength corresponding to a row of the matrix.
</p>
<p>If converting a <code>data.frame</code>, this optional argument specifies the
name of the column containing the emission wavelengths.
</p>
</td></tr>
<tr><td><code id="feem_+3A_excitation">excitation</code></td>
<td>

<p>If converting a matrix, this should be a vector of excitation wavelengths,
each wavelength corresponding to a column of the matrix.
</p>
<p>If converting a <code>data.frame</code>, this optional argument specifies the
name of the column containing the excitation wavelengths.
</p>
</td></tr>
<tr><td><code id="feem_+3A_intensity">intensity</code></td>
<td>

<p>If converting a <code>data.frame</code>, this optional argument specifies the
name of the column containing the fluorescence intensities.
</p>
</td></tr>
<tr><td><code id="feem_+3A_scale">scale</code></td>
<td>

<p>The scale value of a EEM is preserved through the analysis procedure
to divide the resulting score values after running PARAFAC. If
the EEM has been pre-multiplied prior to creating the FEEM object,
you can set the multiplier here.
</p>
</td></tr>
<tr><td><code id="feem_+3A_format">format</code></td>
<td>

<dl>
<dt>table</dt><dd>
<p>The FEEM is assumed to be stored as a plain text matrix, readable
using <code><a href="utils.html#topic+read.table">read.table</a></code>, with the first column and
the first row containing wavelengths. For example, it is possible
to import CSV files obtained from a HORIBA Aqualog&reg;
fluorometer by using <code>feem(<var>file</var>, 'table', sep = ',')</code>.
</p>
<p>Rows are assumed to correspond to emission wavelengths, columns
are assumed to correspond to excitation wavelengths; if that's
not the case, set the <code>transpose</code> argument to <code>TRUE</code>.
</p>
<p>If there are unmeasured points in the spectrum (e.g. the anti-Stokes
area) but they are hard to distinguish from measured values
(e.g. stored as zeroes instead of <code>NA</code>), specify their
values as the <code>na</code> argument (numeric vector). The function
will check for triangles filled with these values (such that a
threshold <code class="reqn">\Delta</code> exists where for all <code class="reqn">
        \lambda_\mathrm{em} - \lambda_\mathrm{ex} &gt; \Delta
      </code> or <code class="reqn">
        \lambda_\mathrm{em} - \lambda_\mathrm{ex} &lt; \Delta
      </code>,
<code class="reqn">
        X(\lambda_\mathrm{em}, \lambda_\mathrm{ex}) \in \mathtt{na}
      </code>)
and replace them with <code>NA</code>s. If the unmeasured values
are not stored as numbers, use the <code>na.strings</code> argument of
<code><a href="utils.html#topic+read.table">read.table</a></code> to specify them.
</p>
<p>The <code>fileEncoding</code> argument is treated specially (but
preserving the <code><a href="utils.html#topic+read.table">read.table</a></code> semantics regarding
numbers), preventing errors in case the session charset cannot
represent all characters from the file: the contents are first
converted to UTF-8, then forwarded to
<code><a href="utils.html#topic+read.table">read.table</a></code>. This only works when <code>file</code>
is a file path, not a connection. (When passing a connection with
an encoding attribute set, make sure that the file contents after
decoding can be represented in the session charset.)
</p>
<p>All other arguments are passed to <code><a href="utils.html#topic+read.table">read.table</a></code>,
with <code>fill</code> defaulting to <code>TRUE</code> instead of
<code>FALSE</code>.
</p>
</dd>
<dt>panorama</dt><dd>
<p>Read a &lsquo;<span class="file">.dat</span>&rsquo; file as created by &ldquo;Panorama&rdquo; software
that comes with FLUORAT&reg;-02-PANORAMA fluorometer.
Such files contain a header describing the wavelength range, e.g.:
</p>
<pre>   240.0   650.0     1.0    ; Emission(columns)
   230.0   320.0     5.0    ; Excitation(rows)</pre>
<p>The header is followed by the intensity data as matrix,
whitespace-separated. Missing points (anti-Stokes area) stored as
<code class="reqn">0</code> or <code class="reqn">100</code> and are automatically filtered out on import.
No additional parameters are accepted.
</p>
</dd>
<dt>F900txt</dt><dd>
<p>Read an emission map text file created by &ldquo;F900&rdquo; software
that comes with Edinburgh Instruments fluorescence spectrometers.
Separated by empty lines, these files are assumed to contain:
</p>

<ol>
<li><p> Sample name
</p>
</li>
<li><p> Metadata of each emission scan, with names in the first
column, including the excitation wavelengths
</p>
</li>
<li><p> Fluorescence values with emission wavelengths in the first
column
</p>
</li></ol>

<p>The <code>fileEncoding</code> argument specifies the encoding of the
text file and has a safe default of &ldquo;latin1&rdquo;. It should
typically correspond to the ANSI code page on the computer running
F900 that was used to create the file. See
<code><a href="base.html#topic+iconvlist">iconvlist</a>()</code> for a list of encodings understood
by <span class="rlang"><b>R</b></span>.
</p>
<p>The <code>sep</code> argument specifies the column separator used in the
file. A semicolon <code>;</code> is typically used, though other options
are possible.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="feem_+3A_...">...</code></td>
<td>

<p>When converting matrices and <code><a href="base.html#topic+data.frame">data.frame</a></code>s, extra
arguments besides those specified above are not allowed.
</p>
<p>When reading the FEEM from a file, additional arguments may be passed
to <code>format</code>-specific reading functions, see above.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transposing a <code>feem</code> object using <code><a href="base.html#topic+t">t</a></code> will
remove the class attribute, returning an ordinary matrix.
</p>


<h3>Value</h3>

<p>A FEEM object is a matrix with the following attributes added:
</p>
<table>
<tr><td><code>emission</code></td>
<td>

<p>Fluorescence emission wavelengths corresponding to the rows of the
matrix, nm.
</p>
</td></tr>
<tr><td><code>excitation</code></td>
<td>

<p>Fluorescence excitation wavelengths corresponding to the columns of
the matrix, nm.
</p>
</td></tr>
<tr><td><code>dimnames</code></td>
<td>

<p>Dimension names, copies of information above. Used only for
presentation purposes.
</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>

<p>Scale factor, preserved through the analysis, which may be used
later to undo the scaling. Initially <code class="reqn">1</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>FEEM methods: <code><a href="#topic+plot.feem">plot.feem</a></code>, <code><a href="#topic+as.data.frame.feem">as.data.frame.feem</a></code>,
<code><a href="#topic++5B.feem">[.feem</a></code>, <code><a href="#topic+feemgrid">feemgrid</a></code>, <code><a href="#topic+feemife">feemife</a></code>,
<code><a href="#topic+feemscale">feemscale</a></code>, <code><a href="#topic+feemscatter">feemscatter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  feem(matrix(1:40, ncol = 8), 1:5, 1:8)
  feem(
    data.frame(x = 1:10, y = 21:30, z = 31:40),
    emission = 'x', excitation = 'y', intensity = 'z'
  )
  feem(
    system.file('extdata/ho_aq.csv', package = 'albatross'),
    'table', sep = ','
  )
  feem(
    system.file('extdata/F900.txt', package = 'albatross'), 'F900txt'
  )
</code></pre>

<hr>
<h2 id='feemcube'>Data cubes of fluorescence excitation-emission matrices</h2><span id='topic+feemcube'></span><span id='topic+feemcube.array'></span><span id='topic+feemcube.list'></span><span id='topic+feemcube.feemparafac'></span><span id='topic+feemcube.feemsplithalf'></span><span id='topic+feemcube.feemjackknife'></span><span id='topic+feemcube.feemflame'></span><span id='topic+as.list.feemcube'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+feem">feem</a></code> objects or a 3-way array, build
tagged 3-dimensional arrays of fluorescence excitation-emission
spectra. Extract the data cube from the corresponding model objects.
Transform the data cube into a list of <code><a href="#topic+feem">feem</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemcube(x, ...)
  ## S3 method for class 'list'
feemcube(x, all.wavelengths, ...)
  ## S3 method for class 'array'
feemcube(x, emission, excitation, scales, names = NULL, ...)
  ## S3 method for class 'feemparafac'
feemcube(x, ...)
  ## S3 method for class 'feemsplithalf'
feemcube(x, ...)
  ## S3 method for class 'feemjackknife'
feemcube(x, ...)
  ## S3 method for class 'feemflame'
feemcube(x, ...)
  ## S3 method for class 'feemcube'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemcube_+3A_x">x</code></td>
<td>

<dl>
<dt>feemcube</dt><dd>
<p>A list of FEEM objects, possibly named, or a numeric array.
</p>
<p>Alternatively, a <code><a href="#topic+feemparafac">feemparafac</a></code>,
<code><a href="#topic+feemjackknife">feemjackknife</a></code>, <code><a href="#topic+feemsplithalf">feemsplithalf</a></code>, or a
<code><a href="#topic+feemflame">feemflame</a></code> object.
</p>
</dd>
<dt>as.list.feemcube</dt><dd>
<p>A <code>feemcube</code> object.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="feemcube_+3A_all.wavelengths">all.wavelengths</code></td>
<td>

<p>Logical, a flag specifying whether to include wavelengths not present
in <em>all</em> of the samples. If <code>FALSE</code>, only those wavelength
present in all of the samples are included.
</p>
</td></tr>
<tr><td><code id="feemcube_+3A_emission">emission</code></td>
<td>

<p>Numeric vector of emission wavelengths. Should correspond to the
first dimension of the array <code>x</code>.
</p>
</td></tr>
<tr><td><code id="feemcube_+3A_excitation">excitation</code></td>
<td>

<p>Numeric vector of excitation wavelengths. Should correspond to the
second dimension of the array <code>x</code>.
</p>
</td></tr>
<tr><td><code id="feemcube_+3A_scales">scales</code></td>
<td>

<p>Numeric vector of scale factors corresponding to the spectra in the
array. Should correspond to the third dimension of the array
<code>x</code>. If missing, assumed to be all <code class="reqn">1</code>.
</p>
</td></tr>
<tr><td><code id="feemcube_+3A_names">names</code></td>
<td>

<p>Character vector of names of the samples. Should correspond to the
third dimension of the array <code>x</code>.
</p>
</td></tr>
<tr><td><code id="feemcube_+3A_...">...</code></td>
<td>

<p>Additional arguments besides those specified above are not allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>feemcube.list</code> can be used to build FEEM data cubes from lists
of FEEM objects even if their wavelength grids do not exactly match.
The missing wavelengths may be set to <code>NA</code>
(<code>all.wavelengths = TRUE</code>) or omitted from the cube
(<code>all.wavelengths = FALSE</code>). See <code><a href="#topic+feemgrid">feemgrid</a></code> if you
need to adjust the wavelength grid of a list of EEMs before making it
into a FEEM cube.
</p>
<p><code>feemcube.feemparafac</code>, <code>feemcube.jackknife</code>, and
<code>feemcube.feemsplithalf</code> return the data cube originally passed
to the corresponding functions.
</p>


<h3>Value</h3>

<p>A FEEM data cube is a numeric three-dimensional array with the
following attributes:
</p>
<table>
<tr><td><code>emission</code></td>
<td>

<p>Fluorescence emission wavelengths corresponding to the first
dimension of the array, nm.
</p>
</td></tr>
<tr><td><code>excitation</code></td>
<td>

<p>Fluorescence excitation wavelengths corresponding to the second
dimension of the array, nm.
</p>
</td></tr>
<tr><td><code>dimnames</code></td>
<td>

<p>Dimension names, copies of information above. Used only for
presentation purposes.
</p>
</td></tr>
<tr><td><code>scales</code></td>
<td>

<p>Scale factors of the samples, corresponding to the third dimension
of the array. Assumed to be <code class="reqn">1</code> if not specified by the user.
</p>
</td></tr>
</table>
<p><code>as.list.feemcube</code>: A named list of FEEM objects comprising
<code>x</code>.
</p>


<h3>See Also</h3>

<p>FEEM cube methods: <code><a href="#topic++5B.feemcube">[.feemcube</a></code>,
<code><a href="#topic+plot.feemcube">plot.feemcube</a></code>, <code><a href="#topic+as.data.frame.feemcube">as.data.frame.feemcube</a></code>,
<code><a href="#topic+feemife">feemife</a></code>, <code><a href="#topic+feemscale">feemscale</a></code>,
<code><a href="#topic+feemscatter">feemscatter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # array form
  feemcube(
    array(1:24, c(4, 3, 2)), # 3-way array obtained elsewhere
    seq(340, 400, len = 4), seq(250, 300, len = 3) # wavelengths
  )
  # list form
  feemcube(
    replicate(2, feem( # list of feem objects
      matrix(1:6, 2), c(340, 400), c(250, 275, 300)
    ), FALSE),
    TRUE
  )
  str(as.list(feemcube(array(1:60, 3:5), 1:3, 1:4)))
</code></pre>

<hr>
<h2 id='feemflame'>
Fluorescence and scAttering Model Estimation
</h2><span id='topic+feemflame'></span><span id='topic+fitted.feemflame'></span><span id='topic+residuals.feemflame'></span><span id='topic+coef.feemflame'></span><span id='topic+plot.feemflame'></span>

<h3>Description</h3>

<p>Given a FEEM cube, model the fluorescence and the scattering signals
at the same time as a sum of a PARAFAC model and a low-rank
unfolded matrix factorisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemflame(
    X, ffac, sfac, maxiter = 32, widths = rep(25, 4), Raman.shift = 3400,
    ctol = 1e-04, progress = TRUE
  )
  ## S3 method for class 'feemflame'
fitted(object, ...)
  ## S3 method for class 'feemflame'
residuals(object, ...)
  ## S3 method for class 'feemflame'
coef(
    object, type = c(
      "fluorescence",
      "scores", "loadings", "emission", "excitation", "samples",
      "scattering", "sc.scores", "sc.loadings"
    ), ...
  )
  ## S3 method for class 'feemflame'
plot(
    x, type = c('both', 'fl.image', 'fl.lines'), ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemflame_+3A_x">X</code></td>
<td>
<p>A <code><a href="#topic+feemcube">feemcube</a></code> object.</p>
</td></tr>
<tr><td><code id="feemflame_+3A_ffac">ffac</code></td>
<td>

<p>The number of trilinear components used to model fluorescence,
passed to <code><a href="#topic+feemparafac">feemparafac</a></code>.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_sfac">sfac</code></td>
<td>

<p>The number of bilinear (low-rank matrix factorisation) components
used to model the scattering signal.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of alternating PARAFAC and constrained matrix
factorisation iterations.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_widths">widths</code></td>
<td>

<p>Widths of the scattering regions, like in <code><a href="#topic+feemscatter">feemscatter</a></code>:
A numeric vector of length 4 containing the widths (in nm) of the
scattering signal, in the following order:
</p>

<ol>
<li><p> Rayleigh scattering
</p>
</li>
<li><p> Raman scattering
</p>
</li>
<li><p> Rayleigh scattering, <code class="reqn">2\lambda</code>
</p>
</li>
<li><p> Raman scattering, <code class="reqn">2\lambda</code>
</p>
</li></ol>

</td></tr>
<tr><td><code id="feemflame_+3A_raman.shift">Raman.shift</code></td>
<td>

<p>Raman shift of the scattering signal, in
<code class="reqn">\textrm{cm}^{-1}</code>, like in
<code><a href="#topic+feemscatter">feemscatter</a></code>.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_ctol">ctol</code></td>
<td>

<p>Given <code class="reqn">
      L = ||\mathbf X - \hat{\mathbf X}||^2
    </code>,
stop when <code class="reqn">
      \frac{|\Delta L|}{L} \le \mathtt{ctol}
    </code>.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_progress">progress</code></td>
<td>

<p>Print progress information on the console, including the iteration
number, relative sum of squared residuals, and relative change in
sum of squared residuals.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_object">object</code>, <code id="feemflame_+3A_x">x</code></td>
<td>

<p>A <code>feemflame</code> object.
</p>
</td></tr>
<tr><td><code id="feemflame_+3A_type">type</code></td>
<td>

<dl>
<dt>coef</dt><dd>
<p>Determines the type of coefficients to return: </p>

<dl>
<dt>fluorescence</dt><dd>
<p>Equivalent to calling <code><a href="#topic+coef.feemparafac">coef.feemparafac</a></code> on the
fluorescence model (default).
</p>
</dd>
<dt>scores, loadings, emission, excitation, samples</dt><dd>
<p>Equivalent to calling <code><a href="#topic+coef.feemparafac">coef.feemparafac</a></code> on the
fluorescence model and passing the respective <code>type</code>
argument.
</p>
</dd>
<dt>sc.scores</dt><dd>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>Sample numbers or names.</p>
</dd>
<dt>value</dt><dd><p>Scattering intensity value for a given factor.</p>
</dd>
<dt>factor</dt><dd><p>The number of the scattering component.</p>
</dd>
</dl>

</dd>
<dt>sc.loadings</dt><dd>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the following columns:
</p>

<dl>
<dt>emission, excitation</dt><dd>
<p>The wavelengths corresponding to the value of the
scattering profile.
</p>
</dd>
<dt>value</dt><dd><p>Scattering intensity value for a given factor.</p>
</dd>
<dt>factor</dt><dd><p>The number of the scattering component.</p>
</dd>
</dl>

</dd>
<dt>scattering</dt><dd>
<p>A list with names &ldquo;scores&rdquo; and &ldquo;loadings&rdquo;
containing results of <code>coef(object, 'sc.scores')</code> and
<code>coef(object, 'sc.loadings')</code>, respectively.
</p>
</dd>
</dl>

</dd>
<dt>plot</dt><dd>
<p>Describes the kind of plot to produce: </p>

<dl>
<dt>both</dt><dd>
<p>Plot the loadings of the fluorescence and scattering models as
false colour images.
</p>
</dd>
<dt>fl.image, fl.lines</dt><dd>
<p>Equivalent to calling <code><a href="#topic+plot.feemparafac">plot.feemparafac</a></code> on the
fluorescence model with the argument &ldquo;image&rdquo; or
&ldquo;lines&rdquo;, respectively.
</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="feemflame_+3A_...">...</code></td>
<td>

<p>No other parameters are allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FLAME models the input data as a sum of fluorescence signal (PARAFAC
model) and scattering signal (low rank model):
</p>
<p style="text-align: center;"><code class="reqn">
    X_k(\lambda^\mathrm{em}_i, \lambda^\mathrm{ex}_j) =
    \underbrace{\sum_p A_{i,p} B_{j,p} C_{k,p}}_{\mbox{fluorescence}}
    + \underbrace{\sum_q S_{i,j,q} D_{k,q}}_{\mbox{scattering}}
  </code>
</p>

<p>The function alternates between fitting the PARAFAC model on the
dataset with scattering signal subtracted and fitting the low-rank
model on the dataset with fluorescence signal subtracted. The PARAFAC
model is fitted using the <code><a href="#topic+feemparafac">feemparafac</a></code> function.  The
low-rank model is fitted by means of unfolding the wavelength
dimensions into one, resulting in a matrix, followed by the same
alternating least squares procedure as done in multivariate curve
resolution. Both models are constrained to result in non-negative
factors.
</p>
<p>The low-rank model is additionally constrained to zero outside the
scattering region. The scattering region is defined the same way as in
<code><a href="#topic+feemscatter">feemscatter</a></code>, using the <code>widths</code> and the
<code>Raman.shift</code> arguments.
</p>
<p>Initial PARAFAC model is fitted with the scattering region set to
missing. The low-rank model is initialised with truncated singular
value decomposition forced to be non-negative.
</p>


<h3>Value</h3>

<table>
<tr><td><code>feemflame</code></td>
<td>

<p>An object of class <code>feemflame</code>, which is a list containing the
following components: </p>

<dl>
<dt>fl</dt><dd>
<p>A <code><a href="#topic+feemparafac">feemparafac</a></code> object containing the fluorescence
part of the model.
</p>
</dd>
<dt>sc</dt><dd>
<p>An object of internal class <code>cmf</code>. Please don't rely on its
structure.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code>fitted.feemflame</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object containing the part of <code>X</code>
fitted by the model.
</p>
</td></tr>
<tr><td><code>residuals.feemparafac</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object equal to <code class="reqn">
      \mathbf{X} - \hat{\mathbf{X}}
    </code>, with an extra class
<code>feem.resid</code> set. Objects of this class are plotted with a
different default palette, see <code><a href="#topic+plot.feem.resid">plot.feem.resid</a></code>.
</p>
</td></tr>
<tr><td><code>coef.feemflame</code></td>
<td>

<p>See the description of the <code>type</code> argument.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The structure of the <code>feemflame</code> object, the initialisation, and
the constraints may be subject to change in a future version.
</p>


<h3>References</h3>

<p>Tauler R, Marqués I, Casassas E (1998).
&ldquo;Multivariate curve resolution applied to three-way trilinear data: Study of a spectrofluorimetric acid-base titration of salicylic acid at three excitation wavelengths.&rdquo;
<em>Journal of Chemometrics</em>, <b>12</b>(1), 55-75.
<a href="https://doi.org/10.1002/%28SICI%291099-128X%28199801/02%2912%3A1%3C55%3A%3AAID-CEM501%3E3.0.CO%3B2-%23">doi:10.1002/(SICI)1099-128X(199801/02)12:1&lt;55::AID-CEM501&gt;3.0.CO;2-#</a>.
</p>
<p>Krylov I, Labutin T, Rinnan Å, Bro R (2021).
&ldquo;Modelling of scattering signal for direct PARAFAC decompositions of excitation-emission matrices.&rdquo;
17th Scandinavian Symposium on Chemometrics.
<a href="https://web.archive.org/web/20220314144225/https://ssc17.org/abstract/Krylov1.html">https://web.archive.org/web/20220314144225/https://ssc17.org/abstract/Krylov1.html</a>.
<a href="https://files.libs.chem.msu.ru/~ivan/SSC17/P13.pdf">https://files.libs.chem.msu.ru/~ivan/SSC17/P13.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemparafac">feemparafac</a></code>, <code><a href="#topic+feemcube">feemcube</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(feems)
  cube &lt;- feemscale(cube)
  factors &lt;- feemflame(cube, ffac = 3, sfac = 1)
  str(coef(factors))
  str(coef(factors, 'scattering'))
  plot(factors)
</code></pre>

<hr>
<h2 id='feemgrid'>
Interpolate FEEMs on a given wavelength grid
</h2><span id='topic+feemgrid'></span><span id='topic+feemgrid.feem'></span><span id='topic+feemgrid.feemcube'></span><span id='topic+feemgrid.list'></span>

<h3>Description</h3>

<p>Use interpolation to change the wavelength grid of a single FEEM or
unify the grid of a collection of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemgrid(x, ...)
  ## S3 method for class 'feem'
feemgrid(
    x, emission, excitation,
    method = c("whittaker", "loess", "kriging", "pchip"), ...
  )
  ## S3 method for class 'feemcube'
feemgrid(
    x, emission, excitation, ..., progress = TRUE
  )
  ## S3 method for class 'list'
feemgrid(
    x, emission, excitation, ..., progress = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemgrid_+3A_x">x</code></td>
<td>

<p>A <code><a href="#topic+feem">feem</a></code> object, a <code><a href="#topic+feemcube">feemcube</a></code>, or a list of
<code><a href="#topic+feem">feem</a></code> objects.
</p>
</td></tr>
<tr><td><code id="feemgrid_+3A_emission">emission</code>, <code id="feemgrid_+3A_excitation">excitation</code></td>
<td>

<p>Desired wavelength grid, as numeric vectors. Must be specified for
a single FEEM.  If not specified for a collection of FEEMs, all
wavelengths falling in the range of the intersection all wavelengths
intervals are chosen.
</p>
</td></tr>
<tr><td><code id="feemgrid_+3A_method">method</code></td>
<td>

<p>Interpolation method, see <code><a href="#topic+feemscatter">feemscatter</a></code> for details.
</p>
</td></tr>
<tr><td><code id="feemgrid_+3A_...">...</code></td>
<td>

<p>Passed from generics to <code>feemgrid.feem</code>, then to interpolation
methods.  See <code><a href="#topic+feemscatter">feemscatter</a></code> for details.
</p>
</td></tr>
<tr><td><code id="feemgrid_+3A_progress">progress</code></td>
<td>

<p>Set to <code>FALSE</code> to disable the progress bar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm doesn't know how to distinguish between <code>NA</code>s
that haven't been measured and <code>NA</code>s that resulted from
combining different wavelength grids, so it tries to interpolate all
of them.  As a result, leaving large areas of the spectrum undefined
(e.g. anti-Stokes area) is not recommended, since it would result in
extrapolation and introduce strong artefacts.
</p>


<h3>Value</h3>

<p>An object of the same kind (FEEM object / FEEM cube / list of them)
with emission and excitation wavelengths as requested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemscatter">feemscatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  x &lt;- feemscatter(feems$a, rep(25, 4))
  y &lt;- feemgrid(x, seq(240, 600, 5), seq(230, 550, 10))
  plot(plot(x, main = 'Original'    ), split = c(1, 1, 2, 1), more = TRUE)
  plot(plot(y, main = 'Interpolated'), split = c(2, 1, 2, 1))
</code></pre>

<hr>
<h2 id='feemife'>Absorbance-based inner filter effect correction</h2><span id='topic+feemife'></span><span id='topic+feemife.feem'></span><span id='topic+feemife.feemcube'></span><span id='topic+feemife.list'></span>

<h3>Description</h3>

<p>Use absorbance data to correct inner-filter effect in FEEM objects
and collections of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemife(x, ...)
  ## S3 method for class 'feem'
feemife(x, absorbance, abs.path = 1, ...)
  ## S3 method for class 'feemcube'
feemife(x, absorbance, abs.path, ..., progress = FALSE)
  ## S3 method for class 'list'
feemife(x, absorbance, abs.path, ..., progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemife_+3A_x">x</code></td>
<td>

<p>A FEEM object, a FEEM data cube, or a list of them.
</p>
</td></tr>
<tr><td><code id="feemife_+3A_absorbance">absorbance</code></td>
<td>

<p>If <code>x</code> is a FEEM object: a two-column matrix-like object
containing the absorbance spectrum of the sample: the wavelengths
in the first column and the unitless absorbance values in the
second column.
</p>
<p>Otherwise, this could be a list of such objects or a multi-column
matrix-like object. If <code>x</code> contains names of the samples
(is a named list or had <code>names</code> specified when calling
<code><a href="#topic+feemcube">feemcube</a></code>), <code>absorbance</code> is a named list or has
named columns, and all samples from <code>x</code> can be looked up in
<code>absorbance</code>, results of this lookup are used. If <code>x</code>
or <code>absorbance</code> isn't named, but (given <code class="reqn">N</code>-sample
<code>x</code>) <code>absorbance</code> has exactly <code class="reqn">N+1</code> columns or is an
<code class="reqn">N</code>-element list, absorbance spectra are assumed to be present
in the same order as the samples in <code>x</code>. Otherwise, an error
is raised.
</p>
</td></tr>
<tr><td><code id="feemife_+3A_abs.path">abs.path</code></td>
<td>

<p>If <code>x</code> is a FEEM object, a number specifying the length of the
optical path used when measuring the absorbance, cm.
</p>
<p>Otherwise, a named vector containing the names from <code>x</code>, or a
vector of exactly same length as the number of FEEMs in <code>x</code>:
same lookup rules apply as for <code>absorbance</code> argument.
</p>
<p>If not set, assumed to be <code class="reqn">1</code>.
</p>
</td></tr>
<tr><td><code id="feemife_+3A_progress">progress</code></td>
<td>

<p>Set to <code>TRUE</code> to enable a progress bar (implemented via
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>).
</p>
</td></tr>
<tr><td><code id="feemife_+3A_...">...</code></td>
<td>

<p>No parameters besides those described above are allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you receive errors alleging that some names don't match, but
are absolutely sure that the absorbance spectra and path lengths are
present in the same order as in <code>x</code>, remove the names from either
of the objects, e.g. by passing <code><a href="base.html#topic+unname">unname</a>(absorbance)</code>.
</p>
<p>The formula used to correct for inner filter effect is:
</p>
<p style="text-align: center;"><code class="reqn">
    I_\mathrm{corr}(\lambda_\mathrm{em}, \lambda_\mathrm{ex}) =
    I_\mathrm{orig}(\lambda_\mathrm{em}, \lambda_\mathrm{ex}) 10^{
      \frac{A(\lambda_\mathrm{em}) + A(\lambda_\mathrm{ex})}{2 L_\mathrm{abs}}
    }
  </code>
</p>



<h3>Value</h3>

<p>An object of the same kind as <code>x</code>, with inner filter effect
corrected.
</p>


<h3>References</h3>

<p>Lakowicz JR (2006).
<em>Principles of Fluorescence Spectroscopy, 3rd ed.</em>.
Springer US.
<a href="https://doi.org/10.1007/978-0-387-46312-4">doi:10.1007/978-0-387-46312-4</a>.
</p>
<p>Kothawala DN, Murphy KR, Stedmon CA, Weyhenmeyer GA, Tranvik LJ (2013).
&ldquo;Inner filter correction of dissolved organic matter fluorescence.&rdquo;
<em>Limnology and Oceanography: Methods</em>, <b>11</b>(12), 616-630.
<a href="https://doi.org/10.4319/lom.2013.11.616">doi:10.4319/lom.2013.11.616</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)

  str(cube)
  str(absorp)
  plot(feemife(cube,absorp) / cube)
</code></pre>

<hr>
<h2 id='feemindex'>Fluorescence indices and peak values</h2><span id='topic+feemindex'></span><span id='topic+feemindex.feem'></span><span id='topic+feemindex.feemcube'></span><span id='topic+feemindex.list'></span>

<h3>Description</h3>

<p>Calculate fluorescence indices or peak values for individual FEEMs or
groups of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemindex(x, ...)
  ## S3 method for class 'feem'
feemindex(
    x,
    indices = c(
      "HIX", "BIX", "MFI", "CFI", "YFI", "FrI",
      "A", "B", "C", "M", "P", "T"
    ),
    tolerance = 1, interpolate = FALSE, ...
  )
  ## S3 method for class 'feemcube'
feemindex(x, ..., progress = FALSE)
  ## S3 method for class 'list'
feemindex(x, ..., progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemindex_+3A_x">x</code></td>
<td>

<p>A FEEM, a FEEM cube, or a list of <code><a href="#topic+feem">feem</a></code> objects.
</p>
</td></tr>
<tr><td><code id="feemindex_+3A_indices">indices</code></td>
<td>

<p>Fluorescence indices or peaks to return. By default, all indices and
peaks known to the function are returned. See Details for their
meaning.
</p>
</td></tr>
<tr><td><code id="feemindex_+3A_tolerance">tolerance</code></td>
<td>

<p>A numeric scalar signifying the acceptable emission and excitation
wavelength error in nm. For example, if a wavelength of <code class="reqn">254</code> nm is
needed to calculate an index, a value at <code class="reqn">255</code> nm can be considered if
<code>tolerance &gt;= 1</code>. Defaults to <code class="reqn">1</code> nm. See below for what happens
if no matching value is found.
</p>
</td></tr>
<tr><td><code id="feemindex_+3A_interpolate">interpolate</code></td>
<td>

<p>A string specifying an interpolation method (&ldquo;whittaker&rdquo;,
&ldquo;loess&rdquo;, &ldquo;kriging&rdquo;, &ldquo;pchip&rdquo;), or <code>FALSE</code>
to disable interpolation (default).
</p>
<p>If interpolation is disabled, an index will get an <code>NA</code> value
when required points are too far from the measured grid or are
present in the grid but set to <code>NA</code>.
</p>
<p>When interpolation is enabled, required points that are missing from
the grid or present but set to <code>NA</code> will be interpolated using
<code><a href="#topic+feemgrid">feemgrid</a></code> as long as they are within the wavelength
bounds of the FEEM. <code>NA</code>s may still be returned only when the
desired value is impossible to interpolate due to it being outside
the wavelength range.
</p>
</td></tr>
<tr><td><code id="feemindex_+3A_...">...</code></td>
<td>

<p>Additional parameters eventually passed to interpolation methods.
See <code><a href="#topic+feemscatter">feemscatter</a></code> for details.
</p>
</td></tr>
<tr><td><code id="feemindex_+3A_progress">progress</code></td>
<td>

<p>Set to <code>TRUE</code> to enable a progress bar (implemented via
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available indices and peaks are: </p>

<dl>
<dt>HIX</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{HIX} = \frac{
          \int_{435 \, \mathrm{nm}}^{480 \, \mathrm{nm}}
          I \, d\lambda_\mathrm{em}
        }{
          \int_{300 \, \mathrm{nm}}^{345 \, \mathrm{nm}}
          I \, d\lambda_\mathrm{em}
        }
        \; \mathrm{at} \; \lambda_\mathrm{ex} = 254 \, \mathrm{nm}
      </code>
</p>

<p>Higher values of the humification index correspond to more
condensed fluorescing molecules (higher C/H), more humified
matter. (Zsolnay, Baigar, Jimenez, Steinweg, and Saccomandi 1999)
</p>
</dd>
<dt>BIX</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{BIX} =
          \frac{
            I(\lambda_\mathrm{em} = 380 \, \mathrm{nm})
          }{
            I(\lambda_\mathrm{em} = 430 \, \mathrm{nm})
          } \; \mathrm{at} \; \lambda_\mathrm{ex} = 310 \, \mathrm{nm}
      </code>
</p>

<p>Index of recent autochthonous contribution determines the presence
of the <code class="reqn">\beta</code> fluorophore, characteristic of autochthonous
biological activity in water samples. (Huguet, Vacher, Relexans, Saubusse, Froidefond, and Parlanti 2009)
</p>
</dd>
<dt>MFI</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{MFI} =
          \frac{
            I(\lambda_\mathrm{em} = 450 \, \mathrm{nm})
          }{
            I(\lambda_\mathrm{em} = 500 \, \mathrm{nm})
          } \; \mathrm{at} \; \lambda_\mathrm{ex} = 370 \, \mathrm{nm}
      </code>
</p>

<p>The fluorescence index by (McKnight, Boyer, Westerhoff, Doran, Kulbe, and Andersen 2001) helps distinguish
sources of isolated aquatic fulvic acids and may indicate their
aromaticity.
</p>
</dd>
<dt>CFI</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{CFI} =
          \frac{
            I(\lambda_\mathrm{em} = 470 \, \mathrm{nm})
          }{
            I(\lambda_\mathrm{em} = 520 \, \mathrm{nm})
          } \; \mathrm{at} \; \lambda_\mathrm{ex} = 370 \, \mathrm{nm}
      </code>
</p>

<p>The fluorescence index by (Cory and McKnight 2005) is correlated to
relative contribution of microbial versus higher plant-derived
organic matter to the DOM pool.
</p>
</dd>
<dt>YFI</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{YFI} = \frac{
          \bar{I}(\lambda_\mathrm{em} \in [350, 400] \, \mathrm{nm})
        }{
          \bar{I}(\lambda_\mathrm{em} \in [400, 450] \, \mathrm{nm})
        } \; \mathrm{at} \; \lambda_\mathrm{ex} = 280 \, \mathrm{nm}
      </code>
</p>

<p>Yeomin fluorescence index (Heo, Yoon, Kim, Lee, Lee, and Her 2016) is lowest for humic-like
and fulvic-like samples, higher for aminosugar-like samples and
highest for protein-like samples.
</p>
</dd>
<dt>FrI</dt><dd>
<p style="text-align: center;"><code class="reqn">
        \mathrm{FrI} = \frac{
          I(\lambda_\mathrm{em} = 380 \, \mathrm{nm})
        }{
          \max I(\lambda_\mathrm{em} \in [420, 435] \, \mathrm{nm})
        } \; \mathrm{at} \; \lambda_\mathrm{ex} = 310 \, \mathrm{nm}
      </code>
</p>

<p>The freshness index, also known as
<code class="reqn">\frac{\beta}{\alpha}</code>, is an indicator of
autochthonous inputs (Wilson and Xenopoulos 2009) and may provide indication
of relative contribution of microbially produced DOM.
</p>
</dd>
<dt>A, B, C, M, P, T</dt><dd>
<p>Fluorophore peaks taken from (Coble 2007): </p>

<table>
<tr>
 <td style="text-align: center;">
        Peak
        </td><td style="text-align: center;"> <code class="reqn">\lambda_\mathrm{ex}</code>
        </td><td style="text-align: center;"> <code class="reqn">\lambda_\mathrm{em}</code>
        </td><td style="text-align: left;"> Fluorescence </td>
</tr>
<tr>
 <td style="text-align: center;">

        A </td><td style="text-align: center;">   260   </td><td style="text-align: center;"> 400-460 </td><td style="text-align: left;"> humic-like        </td>
</tr>
<tr>
 <td style="text-align: center;">
        B </td><td style="text-align: center;">   275   </td><td style="text-align: center;">   305   </td><td style="text-align: left;"> tyrosine-like     </td>
</tr>
<tr>
 <td style="text-align: center;">
        C </td><td style="text-align: center;"> 320-360 </td><td style="text-align: center;"> 420-460 </td><td style="text-align: left;"> humic-like        </td>
</tr>
<tr>
 <td style="text-align: center;">
        M </td><td style="text-align: center;"> 290-310 </td><td style="text-align: center;"> 370-410 </td><td style="text-align: left;"> marine humic-like </td>
</tr>
<tr>
 <td style="text-align: center;">
        P </td><td style="text-align: center;">   398   </td><td style="text-align: center;">   660   </td><td style="text-align: left;"> pigment-like      </td>
</tr>
<tr>
 <td style="text-align: center;">
        T </td><td style="text-align: center;">   275   </td><td style="text-align: center;">   340   </td><td style="text-align: left;"> tryptophan-like
      </td>
</tr>

</table>

<p>When a range of wavelengths specified in one or both axes, the
maximal signal value over that range is taken.
</p>
</dd>
</dl>


 

 <p><img src="../help/figures/feemindex.svg" width="700"       alt="The two plots summarise the information above by plotting the       source areas for the peaks and indices on a FEEM with scattering       areas marked separately."      />
</p>
<p>Positions of the peaks and the areas used to determine the
fluorescence indices of an EEM. The Rayleigh and Raman scattering
areas for both 1st and 2nd diffraction orders are shown in grey,
assuming a width of <code class="reqn">\pm 20</code> nm and a Raman
shift of <code class="reqn">3400 \: \mathrm{cm}^{-1}</code>. The
tolerance interval of <code class="reqn">\pm 1</code> nm is invisible
at the scale of the figure.
</p>
<p>Integration for HIX and YFI is done using the trapezoidal method:
</p>
<p style="text-align: center;"><code class="reqn">
      \int_a^b f(x) dx \approx (b - a) \frac{f(a) + f(b)}{2}
    </code>
</p>




<h3>Value</h3>

<p>For individual <code><a href="#topic+feem">feem</a></code> objects, a named numeric vector
containing the values requested via the <code>indices</code> argument.
</p>
<p>Otherwise, a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the values from
the vectors above and a column named <code>sample</code> containing the
names of the samples (or numbers, if names were absent).
</p>


<h3>Author(s)</h3>

<p>With edits and suggestions by Anastasia Drozdova.
</p>


<h3>References</h3>

<p> Coble PG (2007).
&ldquo;Marine Optical Biogeochemistry: The Chemistry of Ocean Color.&rdquo;
<em>Chemical Reviews</em>, <b>107</b>(2), 402-418.
<a href="https://doi.org/10.1021/cr050350%2B">doi:10.1021/cr050350+</a>.

<p> Cory RM, McKnight DM (2005).
&ldquo;Fluorescence spectroscopy reveals ubiquitous presence of oxidized and reduced quinones in dissolved organic matter.&rdquo;
<em>Environmental science &amp; technology</em>, <b>39</b>(21), 8142-8149.
<a href="https://doi.org/10.1021/es0506962">doi:10.1021/es0506962</a>.

<p> Heo J, Yoon Y, Kim D, Lee H, Lee D, Her N (2016).
&ldquo;A new fluorescence index with a fluorescence excitation-emission matrix for dissolved organic matter (DOM) characterization.&rdquo;
<em>Desalination and Water Treatment</em>, <b>57</b>(43), 20270-20282.
<a href="https://doi.org/10.1080/19443994.2015.1110719">doi:10.1080/19443994.2015.1110719</a>.

<p> Huguet A, Vacher L, Relexans S, Saubusse S, Froidefond JM, Parlanti E (2009).
&ldquo;Properties of fluorescent dissolved organic matter in the Gironde Estuary.&rdquo;
<em>Organic Geochemistry</em>, <b>40</b>(6), 706-719.
<a href="https://doi.org/10.1016/j.orggeochem.2009.03.002">doi:10.1016/j.orggeochem.2009.03.002</a>.

<p> McKnight DM, Boyer EW, Westerhoff PK, Doran PT, Kulbe T, Andersen DT (2001).
&ldquo;Spectrofluorometric characterization of dissolved organic matter for indication of precursor organic material and aromaticity.&rdquo;
<em>Limnology and Oceanography</em>, <b>46</b>(1), 38-48.
<a href="https://doi.org/10.4319/lo.2001.46.1.0038">doi:10.4319/lo.2001.46.1.0038</a>.

<p> Wilson HF, Xenopoulos MA (2009).
&ldquo;Effects of agricultural land use on the composition of fluvial dissolved organic matter.&rdquo;
<em>Nature Geoscience</em>, <b>2</b>(1), 37-41.
<a href="https://doi.org/10.1038/ngeo391">doi:10.1038/ngeo391</a>.

<p> Zsolnay A, Baigar E, Jimenez M, Steinweg B, Saccomandi F (1999).
&ldquo;Differentiating with fluorescence spectroscopy the sources of dissolved organic matter in soils subjected to drying.&rdquo;
<em>Chemosphere</em>, <b>38</b>(1), 45-50.
<a href="https://doi.org/10.1016/S0045-6535%2898%2900166-0">doi:10.1016/S0045-6535(98)00166-0</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)

  x &lt;- feemscatter(feems$a, rep(25, 4), 'omit')
  feemindex(x)
  feemindex(x, interpolate = 'whittaker')

  feemindex(feems[2:3])
  feemindex(feemcube(feems[4:5], TRUE))
</code></pre>

<hr>
<h2 id='feemjackknife'>Jack-knife outlier detection in PARAFAC models</h2><span id='topic+feemjackknife'></span><span id='topic+plot.feemjackknife'></span><span id='topic+coef.feemjackknife'></span>

<h3>Description</h3>

<p>Perform leave-one-out fitting + validation of PARAFAC models on a
given FEEM cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemjackknife(cube, ..., progress = TRUE)
  ## S3 method for class 'feemjackknife'
plot(
    x, kind = c('estimations', 'RIP', 'IMP'), ...
  )
  ## S3 method for class 'feemjackknife'
coef(
    object, kind = c('estimations', 'RIP', 'IMP'), ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemjackknife_+3A_cube">cube</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object.
</p>
</td></tr>
<tr><td><code id="feemjackknife_+3A_progress">progress</code></td>
<td>

<p>Set to <code>FALSE</code> to disable the progress bar.
</p>
</td></tr>
<tr><td><code id="feemjackknife_+3A_x">x</code>, <code id="feemjackknife_+3A_object">object</code></td>
<td>

<p>An object returned by <code><a href="#topic+feemjackknife">feemjackknife</a></code>.
</p>
</td></tr>
<tr><td><code id="feemjackknife_+3A_kind">kind</code></td>
<td>

<p>Chooses what to plot (when called as <code>plot(...)</code>) or return
as a <code><a href="base.html#topic+data.frame">data.frame</a></code> (when called as
<code>coef(...)</code>):
</p>

<dl>
<dt>estimations</dt><dd>
<p>Produce the loadings from every leave-one-out model.
</p>
</dd>
<dt>RIP</dt><dd>
<p>Produce a Resample Influence Plot, i.e. mean squared difference
between loadings in overall and leave-one-out models plotted
against mean squared residuals in leave-one-out models.
</p>
</dd>
<dt>IMP</dt><dd>
<p>Produce an Identity Match Plot, i.e. scores in leave-one-out
models plotted against scores in the overall model.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="feemjackknife_+3A_...">...</code></td>
<td>

<dl>
<dt>feemjackknife</dt><dd>
<p>Passed as-is to <code><a href="#topic+feemparafac">feemparafac</a></code> and, eventually, to
<a href="https://CRAN.R-project.org/package=multiway"><span class="pkg">multiway</span></a> function <code><a href="multiway.html#topic+parafac">parafac</a></code>.
</p>
</dd>
<dt>plot.feemjackknife</dt><dd>
<p>When <code>kind</code> is &ldquo;RIP&rdquo; or &ldquo;IMP&rdquo;, pass a <code>q</code>
argument to specify the quantile of residual values (for RIP)
or absolute score differences (IMP) above which sample names (or
numbers) should be plotted. Default value for <code>q</code> is <code class="reqn">0.9</code>.
</p>
<p>Remaining arguments are passed as-is to
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</dd>
<dt>coef.feemjackknife</dt><dd>
<p>No further parameters are allowed.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes each sample out of the dataset, fits a PARAFAC
model without it, then fits the outstanding sample to the model with
emission and excitation factors fixed:
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\mathbf{c}} =
      (\mathbf{A} \ast \mathbf{B})^{+} \times \mathrm{vec}(\mathbf{X})
  </code>
</p>

<p>The individual leave-one-out models (fitted loadings
<code class="reqn">\mathbf A</code>, <code class="reqn">\mathbf B</code> and scores
<code class="reqn">\mathbf C</code>) are reordered according to best Tucker's
congruence coefficient match and rescaled by minimising <code class="reqn">
    || \mathbf A \, \mathrm{diag}(\mathbf s_\mathrm A) -
      \mathbf A^\mathrm{orig} ||^2
  </code> and <code class="reqn">
    || \mathbf{B} \, \mathrm{diag}(\mathbf s_\mathrm B) -
      \mathbf B^\mathrm{orig} ||^2
  </code> over <code class="reqn">\mathbf s_\mathrm A</code> and
<code class="reqn">\mathbf s_\mathrm B</code>, subject to <code class="reqn">
    \mathrm{diag}(\mathbf s_\mathrm A) \times
    \mathrm{diag}(\mathbf s_\mathrm B) \times
    \mathrm{diag}(\mathbf s_\mathrm C) = \mathbf I
  </code>, to make them comparable.
</p>
<p>Once the models are fitted, resample influence plots and identity
match plots can be produced from resulting data to detect outliers.
</p>
<p>To conserve memory, <code>feemjackknife</code> puts the user-provided
<code>cube</code> in an environment and passes it via <code>envir</code> and
<code>subset</code> options of <code><a href="#topic+feemparafac">feemparafac</a></code>. This means that,
unlike in <code><a href="#topic+feemparafac">feemparafac</a></code>, the <code>cube</code> argument has
to be a <code><a href="#topic+feemcube">feemcube</a></code> object and passing <code>envir</code> and
<code>subset</code> options to <code>feemjackknife</code> is not supported. It
is recommended to fully name the parameters to be passed to
<code><a href="#topic+feemparafac">feemparafac</a></code> to avoid problems.
</p>
<p><code>plot.feemjackknife</code> provides sane defaults for
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> parameters <code>xlab</code>, <code>ylab</code>,
<code>scales</code>, <code>as.table</code>, but they can be overridden.
</p>


<h3>Value</h3>


<dl>
<dt>feemjackknife</dt><dd>
<p>A list of class <code>feemjackknife</code> containing the following
entries:</p>

<dl>
<dt>overall</dt><dd>
<p>Result of fitting the overall <code>cube</code> with
<code><a href="#topic+feemparafac">feemparafac</a></code>.
</p>
</dd>
<dt>leaveone</dt><dd>
<p>A list of length <code>dim(cube)[3]</code> containing the reduced dataset
components. Every <code><a href="#topic+feemparafac">feemparafac</a></code> object in the list has
an additional <code>Chat</code> attribute containing the result of
fitting the excluded spectrum back to the loadings of the reduced
model.
</p>
</dd>
</dl>
</dd>
<dt>plot.feemjackknife</dt><dd>
<p>A <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> plot object. Its <code>print</code> or <code>plot</code> method
will draw the plot on an appropriate plotting device.
</p>
</dd>
<dt>coef.feemjackknife</dt><dd>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing various columns,
depending on the value of the <code>kind</code> argument:
</p>

<dl>
<dt>estimations</dt><dd>
<dl>
<dt>loading</dt><dd><p>Values of the loadings.</p>
</dd>
<dt>mode</dt><dd>
<p>The axis of the loadings, &ldquo;Emission&rdquo; or &ldquo;Excitation&rdquo;.
</p>
</dd>
<dt>wavelength</dt><dd>
<p>Emission or excitation wavelength the loading values correspond to.
</p>
</dd>
<dt>factor</dt><dd><p>The component number.</p>
</dd>
<dt>omitted</dt><dd>
<p>The sample (name if <code>cube</code> had names, integer if it didn't)
that was omitted to get the resulting loading values.
</p>
</dd>
</dl>
</dd>
<dt>RIP</dt><dd>
<dl>
<dt>msq.resid</dt><dd>
<p>Mean squared residual value for the model with a given sample
omitted.
</p>
</dd>
<dt>Emission</dt><dd>
<p>Mean squared difference in emission mode loadings between the
overall model and the model with a given sample omitted.
</p>
</dd>
<dt>Excitation</dt><dd>
<p>Mean squared difference in excitation mode loadings between
the overall model and the model with a given sample omitted.
</p>
</dd>
<dt>omitted</dt><dd>
<p>The sample (name if <code>cube</code> had names, integer if it didn't)
that was omitted from a given model.
</p>
</dd>
</dl>
</dd>
<dt>IMP</dt><dd>
<dl>
<dt>score.overall</dt><dd><p>Score values for the overall model.</p>
</dd>
<dt>score.predicted</dt><dd>
<p>Score values estimated from the loadings of the model missing
a given sample.
</p>
</dd>
<dt>factor</dt><dd><p>The component number.</p>
</dd>
<dt>omitted</dt><dd>
<p>The sample (name if <code>cube</code> had names, integer if it didn't)
that was omitted from a given model.
</p>
</dd>
</dl>
</dd>
</dl>

</dd>
</dl>


<h3>References</h3>

<p>Riu J, Bro R (2003).
&ldquo;Jack-knife technique for outlier detection and estimation of standard errors in PARAFAC models.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>65</b>(1), 35-49.
<a href="https://doi.org/10.1016/S0169-7439%2802%2900090-4">doi:10.1016/S0169-7439(02)00090-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemparafac">feemparafac</a></code>, <code><a href="#topic+feemcube">feemcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(feems)
  cube &lt;- feemscale(feemscatter(cube, rep(14, 4)), na.rm = TRUE)
  # takes a long time
  jk &lt;- feemjackknife(cube, nfac = 3)
  # feemparafac methods should be able to use the environment and subset
  plot(jk$leaveone[[1]])
  plot(jk)
  plot(jk, 'IMP')
  plot(jk, 'RIP')
  head(coef(jk))
</code></pre>

<hr>
<h2 id='feemlist'>Create lists of FEEM objects</h2><span id='topic+feemlist'></span><span id='topic+feemlist.character'></span><span id='topic+feemlist.eemlist'></span><span id='topic+feemlist.EEM'></span>

<h3>Description</h3>

<p>Convert vectors of file names or objects from other packages (such as
<a href="https://CRAN.R-project.org/package=eemR"><span class="pkg">eemR</span></a> or <a href="https://CRAN.R-project.org/package=EEM"><span class="pkg">EEM</span></a>) into flat named lists of
<code><a href="#topic+feem">feem</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemlist(x, ...)
  ## S3 method for class 'character'
feemlist(
    x, format, pattern = NULL, recursive = TRUE, ignore.case = FALSE,
    simplify.names = TRUE, ...
  )
  ## S3 method for class 'eemlist'
feemlist(x, ...)
  ## S3 method for class 'EEM'
feemlist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemlist_+3A_x">x</code></td>
<td>

<p>A character vector containing names of files and directories to
import using <code><a href="#topic+feem">feem</a></code>.
</p>
<p>Alternatively, an <code>eemlist</code> object from the <a href="https://CRAN.R-project.org/package=eemR"><span class="pkg">eemR</span></a>
package or an <code>EEM</code> object from the <a href="https://CRAN.R-project.org/package=EEM"><span class="pkg">EEM</span></a> package.
</p>
</td></tr>
<tr><td><code id="feemlist_+3A_format">format</code></td>
<td>

<p>Corresponds to the <code>format</code> argument of <code><a href="#topic+feem">feem</a></code>.
Currently, one format is assumed for all files to be imported.
</p>
<p>Alternatively, can be a function that takes a path to a file and
anything passed in <code>...</code> and returns a <code><a href="#topic+feem">feem</a></code>
object corresponding to the file. This is done to make it easier to
import groups of files in formats not yet supported by
<code><a href="#topic+feem">feem</a></code> itself.
</p>
</td></tr>
<tr><td><code id="feemlist_+3A_pattern">pattern</code>, <code id="feemlist_+3A_recursive">recursive</code>, <code id="feemlist_+3A_ignore.case">ignore.case</code></td>
<td>

<p>These options are passed to <code><a href="base.html#topic+list.files">list.files</a></code> for
directories encountered in <code>x</code> and can be used to e.g. only
choose files with a given suffix in the name. Note the non-default
value for the <code>recursive</code> option.
</p>
</td></tr>
<tr><td><code id="feemlist_+3A_simplify.names">simplify.names</code></td>
<td>

<p>If <code>TRUE</code> (default), split resulting names by the path separator
(<code>/</code>, also <code>\</code> on Windows) and remove leading components
that have the same value for all samples, but leave at least one
component. See Details on how this is related to name generation.
</p>
</td></tr>
<tr><td><code id="feemlist_+3A_...">...</code></td>
<td>

<p>When importing files, remaining options are passed to
<code><a href="#topic+feem">feem</a></code> or the import function passed in the
<code>format</code> argument. Otherwise, no options are allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names of <code>x</code> are preserved; if <code>x</code> is not named, names are
assigned from the values of <code>x</code> itself, and so are empty names
in partially-named <code>x</code>. Every directory in <code>x</code> is replaced
with its contents (as returned by <code><a href="base.html#topic+list.files">list.files</a></code>),
their names obtained by concatenating the name of the directory
element with their paths inside the directory (with
<code><a href="base.html#topic+.Platform">.Platform</a>$file.sep</code> as a separator). For example,
when importing <code>x = c('foo' = 'bar')</code> with directory &lsquo;<span class="file">bar</span>&rsquo;
containing &lsquo;<span class="file">baz.txt</span>&rsquo;, resulting name would be &lsquo;<span class="file">foo/baz.txt</span>&rsquo;.
</p>
<p>When importing many files from the same directory, the
<code>simplify.names</code> option is useful to avoid duplication in resulting
names. For example,
<code>feemlist('.', simplify.names = FALSE)</code> results in a list with
all names starting with <code>./</code>, while
<code>feemlist('foo/bar/baz', simplify.names = TRUE)</code> (default) would
shave off all three common path components and the separators.
</p>
<p>Mixing files and directories in <code>x</code> will most likely not preserve
the order of the elements.
</p>
<p><em>Note</em>: Please don't rely on the name generation behaving exactly
as specified as it may be changed in the future versions.
</p>
<p>When importing custom file formats, the <code>format</code> function should
typically take the following form: </p>
<pre>
  function(filename, ...) {
    # read data from filename
    # take additional arguments passed from feemlist(...) if needed
    return(feem(data))
  }</pre>


<h3>Value</h3>

<p>A flat named list of <code><a href="#topic+feem">feem</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code>; the packages <a href="https://CRAN.R-project.org/package=eemR"><span class="pkg">eemR</span></a> and <a href="https://CRAN.R-project.org/package=EEM"><span class="pkg">EEM</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  feemlist(
    system.file('extdata/pano2.txt', package = 'albatross'),
    'table', transpose = TRUE, na = 0
  )
  if (requireNamespace('eemR')) feemlist(eemR::eem_read(
    system.file('extdata/ho_aq.csv', package = 'albatross'),
    import_function='aqualog'
  ))
  if (requireNamespace('EEM')) feemlist(EEM::readEEM(
    system.file('extdata/ho_aq.dat', package = 'albatross')
  ))
  feemlist(
    system.file('extdata/custom.rds', package = 'albatross'),
    readRDS
  )
</code></pre>

<hr>
<h2 id='feemparafac'>
Compute PARAFAC on a FEEM cube object and access the results
</h2><span id='topic+feemparafac'></span><span id='topic+plot.feemparafac'></span><span id='topic+coef.feemparafac'></span><span id='topic+fitted.feemparafac'></span><span id='topic+residuals.feemparafac'></span><span id='topic+reorder.feemparafac'></span><span id='topic+rescale'></span><span id='topic+rescale.feemparafac'></span><span id='topic+print.feemparafac'></span>

<h3>Description</h3>

<p><code>feemparafac</code> forwards its arguments to
<code><a href="multiway.html#topic+parafac">parafac</a></code> from the <a href="https://CRAN.R-project.org/package=multiway"><span class="pkg">multiway</span></a> package,
optionally rescales the result and attaches a few attributes.
Resulting objects of class <code>feemparafac</code> can be accessed using
methods presented below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemparafac(
    X, ..., const = rep('nonneg', 3),
    rescale = 3, retries = 10, subset = TRUE, envir = NULL
  )
  ## S3 method for class 'feemparafac'
plot(x, type = c("image", "lines"), ...)
  ## S3 method for class 'feemparafac'
coef(
    object, type = c(
      "all", "scores", "loadings", "emission", "excitation", "samples"
    ), ...
  )
  ## S3 method for class 'feemparafac'
fitted(object, ...)
  ## S3 method for class 'feemparafac'
residuals(object, ...)
  ## S3 method for class 'feemparafac'
reorder(x, neworder, like, ...)
  ## S3 method for class 'feemparafac'
rescale(x, mode, newscale, absorb, like, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemparafac_+3A_x">X</code></td>
<td>

<p>A FEEM cube object. The per-sample factors will be multiplied by
<code>attr(X, 'scales')</code> stored in it.
</p>
<p>If <code>envir</code> is <code>NULL</code> (by default), this should be just a
value. If <code>envir</code> is given, this should be a name of the value
to <code><a href="base.html#topic+get">get</a></code> from the environment.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_...">...</code></td>
<td>

<dl>
<dt>feemparafac</dt><dd><p>Passed as-is to <code><a href="multiway.html#topic+parafac">parafac</a></code>.</p>
</dd>
<dt>plot.feemparafac</dt><dd>
<p>Passed as-is to <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> functions
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> and
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</dd>
<dt>reorder.feemparafac, rescale.feemparafac</dt><dd>
<p>Forwarded to the respective <a href="https://CRAN.R-project.org/package=multiway"><span class="pkg">multiway</span></a> functions.
</p>
</dd>
<dt>coef.feemparafac, fitted.feemparafac, residuals.feemparafac</dt><dd>
<p>No other parameters are allowed.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="feemparafac_+3A_const">const</code></td>
<td>

<p>A character vector of length 3 specifying the constraints for all
modes of <code>X</code>, passed to <code><a href="multiway.html#topic+parafac">parafac</a></code>.
Defaults to non-negativity. See <code><a href="CMLS.html#topic+const">const</a></code> for more
information.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_rescale">rescale</code></td>
<td>

<p>Rescale the resulting factors to leave all the variance in the given
mode: emission, excitation, or sample (default). Set to <code>NA</code>
to disable.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_retries">retries</code></td>
<td>

<p>Retry for given number of tries until
<code><a href="multiway.html#topic+parafac">parafac</a></code> returns a successfully fitted model
or stops due to the iteration number limit. Raise a fatal error if
all tries were unsuccessful.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_subset">subset</code></td>
<td>

<p>An integer or logical vector choosing the samples from <code>X</code>, as
in <code>feemparafac(X[,,subset], ...)</code>. Defaults to the whole cube.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_envir">envir</code></td>
<td>

<p>An environment to look up <code>X</code> in.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_x">x</code>, <code id="feemparafac_+3A_object">object</code></td>
<td>

<p>An object returned by <code><a href="#topic+feemparafac">feemparafac</a></code>.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_type">type</code></td>
<td>

<p>Given a fitted PARAFAC model:
</p>
<p style="text-align: center;"><code class="reqn">
      X_{i,j,k} = \sum_r A_{i,r} B_{j,r} C_{k,r}
    </code>
</p>

<p>With <code class="reqn">\mathbf{A}</code> corresponding to fluorescence
emission loadings, <code class="reqn">\mathbf{B}</code> corresponding to
fluorescence excitation loadings, and <code class="reqn">\mathbf{C}</code>
corresponding to the scores of the components in different samples,
the following plots can be produced:
</p>

<dl>
<dt>image</dt><dd>
<p>Plot the factors (&ldquo;loadings&rdquo;) as a series of pseudo-colour
images of outer products
<code class="reqn">
          \mathbf{a}_r \times \mathbf{b}_r^\top
        </code>
</p>
</dd>
<dt>lines</dt><dd>
<p>Plot the factors <code class="reqn">\mathbf a_r</code>
and <code class="reqn">\mathbf b_r</code> as functions
of wavelengths, with each pair of factors on a different panel.
</p>
</dd>
</dl>

<p>Fitted PARAFAC coefficients can be returned in the following forms:
</p>

<dl>
<dt>emission, excitation, samples</dt><dd>
<p>Return the contents of <code class="reqn">\mathbf{A}</code>,
<code class="reqn">\mathbf{B}</code> or <code class="reqn">\mathbf{C}</code>,
respectively, as a <code><a href="base.html#topic+data.frame">data.frame</a></code> with three
columns, the first one (named <code>wavelength</code> or
<code>sample</code>) containing the independent variable
(<code class="reqn">\lambda_\mathrm{em}</code> /
<code class="reqn">\lambda_\mathrm{ex}</code> /
sample name or number),
the second one (named <code>value</code>) containing the values and
the third one (named <code>factor</code>) containing the factor numbers.
</p>
</dd>
<dt>scores</dt><dd><p>Same as samples.</p>
</dd>
<dt>loadings</dt><dd>
<p>Same as &ldquo;emission&rdquo; and &ldquo;excitation&rdquo; combined using
<code><a href="base.html#topic+rbind">rbind</a></code>, with a fourth column (<code>mode</code>)
added, naming the kinds of loadings.
</p>
</dd>
<dt>all</dt><dd>
<p>A list with names &ldquo;emission&rdquo;, &ldquo;excitation&rdquo;,
&ldquo;samples&rdquo; containing results of
<code>coef(object, "emission")</code>, <code>coef(object, "excitation")</code>,
<code>coef(object, "samples")</code>, respectively.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="feemparafac_+3A_neworder">neworder</code></td>
<td>

<p>A permutation of integers between <code class="reqn">1</code> and <code>ncol(x$A)</code> (the
number of components) specifying the new order of factors.
Forwarded to <code><a href="multiway.html#topic+reorder.parafac">reorder.parafac</a></code>. Incompatible
with the <code>like</code> argument.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_like">like</code></td>
<td>

<p>A <code>feemparafac</code> object.
</p>
<p>In <code>reorder</code>, the factors in <code>x</code> will be reordered to
match the factors in <code>like</code> according to the smallest of the
cosine similarities (<code><a href="multiway.html#topic+congru">congru</a></code>) for the
emission and excitation wavelengths.
</p>
<p>In <code>rescale</code>, every factor matrix
<code class="reqn">\mathbf{A}</code> from <code>x</code> that was specified in
<code>mode</code> will be multiplied by scaling factors
<code class="reqn">\mathbf{c}</code> so in order to minimise
<code class="reqn">
      \| \mathbf{A}_\mathtt{like}
         - \mathrm{diag}(\mathbf c) \mathbf{A}_\mathtt{x} \|^2
    </code>.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_mode">mode</code></td>
<td>

<p>The modes to rescale, with <code>"A"</code>, <code>"B"</code>, <code>"C"</code>
corresponding to emission, excitation, and samples, respectively.
When <code>like</code> is specified, defaults to <code>c("A", "B")</code>.
Forwarded to <code><a href="multiway.html#topic+rescale.parafac">rescale.parafac</a></code>.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_newscale">newscale</code></td>
<td>

<p>The desired root-mean-square for each column of the modes being
rescaled.
Forwarded to <code><a href="multiway.html#topic+rescale.parafac">rescale.parafac</a></code>. Incompatible
with the <code>like</code> argument.
</p>
</td></tr>
<tr><td><code id="feemparafac_+3A_absorb">absorb</code></td>
<td>

<p>The mode that should absorb the inverse rescaling coefficients.
When <code>like</code> is specified, defaults to <code>"C"</code>.
Forwarded to <code><a href="multiway.html#topic+rescale.parafac">rescale.parafac</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>feemparafac</code> tries hard to guarantee the convergence flag to be
<code>0</code> (normal convergence) or <code>1</code> (iteration number limit
reached), but never <code>2</code> (a problem with the constraints). A fatal
error is raised if repeated runs of <code><a href="multiway.html#topic+parafac">parafac</a></code> do
not return a (semi-)successfully fitted model.
</p>
<p>After the PARAFAC decomposition is calculated, the scores are
multiplied by the <code>scales</code> attribute of the <code>X</code> object,
making them represent the cube with scaling undone. Use
<code><a href="#topic+feemscale">feemscale</a>(remember = FALSE)</code> if you don't want to undo
the scaling.
</p>
<p>The <code>output</code> option is fixed to <code>"best"</code> value. Obtaining
a list of alternative solutions can therefore be achieved by running:
</p>
<p><code>replicate(<var>n</var>, feemparafac(..., nstart = 1), simplify = FALSE)</code>
</p>
<p>The <code>subset</code> and <code>envir</code> options are useful to repeatedly
perform PARAFAC on different subsets of the same FEEM cube, e.g. in
jack-knifing or split-half analysis. Since <code>feemparafac</code> keeps
a reference to the its <code>X</code> and <code>envir</code> arguments, the use
of <code>subset</code> should ensure that the same FEEM cube is referenced
from multiple <code>feemparafac</code> objects instead of creating copies
of its subsets. Additionally, environment objects are not duplicated
on <code><a href="base.html#topic+save">save</a></code> or <code><a href="base.html#topic+load">load</a></code>, so storing
<code>X</code> in an environment and passing it to multiple invocations of
<code>feemparafac</code> will save a lot of memory when the results are
serialised together.
</p>
<p><code>plot.feemparafac</code> provides sane defaults for <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>
options such as <code>xlab</code>, <code>ylab</code>, <code>as.table</code>,
<code>auto.key</code>, <code>type</code>, <code>cuts</code>, <code>col.regions</code>, but
they can be overridden.
</p>


<h3>Value</h3>

<table>
<tr><td><code>feemparafac</code></td>
<td>

<p>An object of classes <code>feemparafac</code> and <code>parafac</code> with the
following attributes added: </p>

<dl>
<dt>cube</dt><dd><p>A copy of the <code>X</code> argument.</p>
</dd>
<dt>subset</dt><dd><p>A copy of the <code>subset</code> argument.</p>
</dd>
<dt>envir</dt><dd><p>A copy of the <code>envir</code> argument.</p>
</dd>
</dl>

<p><code><a href="base.html#topic+rownames">rownames</a></code> are added from the original data cube
to the <code>A</code>, <code>B</code>, <code>C</code> components of the list returned
by <code><a href="multiway.html#topic+parafac">parafac</a></code>.
</p>
<p>Use <code><a href="#topic+feemcube">feemcube</a></code> on the return value to access the original
data cube.
</p>
</td></tr>
<tr><td><code>plot.feemparafac</code></td>
<td>

<p>A <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> plot object. Its <code>print</code> or <code>plot</code>
method will draw the plot on an appropriate plotting device.
</p>
</td></tr>
<tr><td><code>coef.feemparafac</code></td>
<td>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or a list of them (only if
<code>type</code> is &ldquo;all&rdquo;). See the description of the <code>type</code>
argument for more information.
</p>
</td></tr>
<tr><td><code>fitted.feemparafac</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object comparable to <code>X</code> as it was
decomposed by <code><a href="multiway.html#topic+parafac">parafac</a></code>, ignoring the scaling.
</p>
</td></tr>
<tr><td><code>resid.feemparafac</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object equal to <code class="reqn">
      \mathbf{X} - \hat{\mathbf{X}}
    </code>, with an additional
class <code>feem.resid</code> set. Objects of this class are plotted with
a different default palette, see <code><a href="#topic+plot.feem.resid">plot.feem.resid</a></code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bro R (1997).
&ldquo;PARAFAC. Tutorial and applications.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>38</b>(2), 149-171.
<a href="https://doi.org/10.1016/S0169-7439%2897%2900032-4">doi:10.1016/S0169-7439(97)00032-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="multiway.html#topic+parafac">parafac</a></code> class structure;
<code><a href="#topic+write.openfluor">write.openfluor</a></code>, <code><a href="#topic+feemcube">feemcube</a></code> for methods
specific to values returned from this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  cube &lt;- feemscale(feemscatter(cube, rep(14, 4)), na.rm = TRUE)
  (factors &lt;- feemparafac(cube, nfac = 3))
  plot(factors, 'image')
  plot(factors, 'line')
  head(coef(factors, 'loadings'))
  str(coef(factors, 'all'))
  str(feemcube(factors)) # original cube is retained
  plot(fitted(factors))
  plot(resid(factors))
</code></pre>

<hr>
<h2 id='feems'>
Synthetic fluorescence excitation-emission matrices and absorbance spectra
</h2><span id='topic+feems'></span><span id='topic+absorp'></span><span id='topic+cube'></span>

<h3>Description</h3>

<p>This dataset consists of twelve fluorescence and absorbance spectra
simulated from three trilinear components, with scattering signal
added and divided by a correction factor to simulate inner filter
effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("feems")</code></pre>


<h3>Format</h3>


<dl>
<dt>feems</dt><dd>
<p>A named list of 12 <code><a href="#topic+feem">feem</a></code> objects containing
fluorescence data measured with excitation wavelengths between
<code class="reqn">230</code> nm and <code class="reqn">350</code> nm (with a step of <code class="reqn">2</code> nm) and
emission wavelengths between <code class="reqn">240</code> nm and <code class="reqn">435</code> (with a step
of <code class="reqn">5</code> nm).
</p>
</dd>
<dt>cube</dt><dd>
<p>A 12-sample <code><a href="#topic+feemcube">feemcube</a></code> object consisting of of 32 by 10
FEEMs measured at the same wavelength range as above with inner
filter effect corrected.
</p>
</dd>
<dt>absorp</dt><dd>
<p>A 12-element named list containing absorbance spectra measured between
<code class="reqn">230</code> and <code class="reqn">450</code> nm in <code class="reqn">1</code> cm cells. Each element of the
list is a two-column matrix. The first column contains the
wavelengths and the second column contains the absorbance values.
</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  plot(cube)
  plot(feems$a)
  matplot(
    absorp[[1]][,1],
    sapply(absorp, function(x) x[,2]),
    type = 'l', lty = 1
  )
</code></pre>

<hr>
<h2 id='feemscale'>Rescale FEEM spectra to a given norm and remember the scale factor</h2><span id='topic+feemscale'></span><span id='topic+feemscale.feem'></span><span id='topic+feemscale.feemcube'></span><span id='topic+feemscale.list'></span>

<h3>Description</h3>

<p>Given a norm function (typically, standard deviation), scale the
intensities in FEEM objects to it and optionally remember the scale
factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemscale(x, ...)
  ## S3 method for class 'feem'
feemscale(x, norm = sd, remember = TRUE, ...)
  ## S3 method for class 'feemcube'
feemscale(x, ..., progress = FALSE)
  ## S3 method for class 'list'
feemscale(x, ..., progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemscale_+3A_x">x</code></td>
<td>

<p>A FEEM object, a FEEM cube object, or a list of anything compatible
with <code>feemscale</code> generic.
</p>
</td></tr>
<tr><td><code id="feemscale_+3A_norm">norm</code></td>
<td>

<p>A function taking a numeric matrix and returning its norm. Typically,
<code><a href="stats.html#topic+sd">sd</a></code> or <code><a href="multiway.html#topic+sumsq">sumsq</a></code>.
</p>
</td></tr>
<tr><td><code id="feemscale_+3A_remember">remember</code></td>
<td>

<p>Whether to remember the scale factor. If <code>FALSE</code>, the scale
factor in the returned object is unchanged.
</p>
</td></tr>
<tr><td><code id="feemscale_+3A_...">...</code></td>
<td>

<p>Passed as-is to <code>feemscale</code>, to <code>feemscale.feem</code>, then
to the <code>norm</code> function. Use this to set <code>na.rm = TRUE</code>
for functions like <code><a href="stats.html#topic+sd">sd</a></code> or
<code><a href="multiway.html#topic+sumsq">sumsq</a></code>.
</p>
</td></tr>
<tr><td><code id="feemscale_+3A_progress">progress</code></td>
<td>

<p>Set to <code>TRUE</code> to enable a progress bar (implemented via
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>feemscale.feem</code>: a FEEM object with intensities divided by scale
factor (<code>norm(x)</code>) and its <code>scale</code> attribute multiplied by
the scale factor.
</p>
<p><code>feemscale.feemcube</code>: a FEEM cube built from FEEM objects scaled
as described above.
</p>
<p><code>feemscale.list</code>: a list consisting of results of
<code>feemscale</code> generic applied to its elements.
</p>


<h3>References</h3>

<p>Bro R, Smilde AK (2003).
&ldquo;Centering and scaling in component analysis.&rdquo;
<em>Journal of Chemometrics</em>, <b>17</b>(1), 16-33.
<a href="https://doi.org/10.1002/cem.773">doi:10.1002/cem.773</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  feemscale(feem(matrix(1:42, 6), 1:6, 1:7))
</code></pre>

<hr>
<h2 id='feemscatter'>Handle scattering signal in FEEMs</h2><span id='topic+feemscatter'></span><span id='topic+feemscatter.feem'></span><span id='topic+feemscatter.list'></span><span id='topic+feemscatter.feemcube'></span>

<h3>Description</h3>

<p>Remove or interpolate scattering signal in individual FEEM objects,
FEEM cube objects, or lists of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemscatter(x, ...)
  ## S3 method for class 'list'
feemscatter(x, ..., cl, progress = TRUE)
  ## S3 method for class 'feemcube'
feemscatter(x, ..., cl, progress = TRUE)
  ## S3 method for class 'feem'
feemscatter(
    x, widths, method = c("omit", "pchip", "loess", "kriging", "whittaker"),
    add.zeroes = 30, Raman.shift = 3400, ...
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemscatter_+3A_x">x</code></td>
<td>

<p>An individual FEEM object, FEEM cube object, or a list of them, to
handle the scattering signal in.
</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_widths">widths</code></td>
<td>

<p>A numeric vector or a list containing the half-widths of the
scattering bands, in nm. Rayleigh scattering is followed by Raman
scattering, followed by second diffraction order for Rayleigh and
Raman, and so on. (Typically, there's no need for anything higher
than third order, and even that is rare.) For example:
</p>

<ol>
<li><p> Rayleigh scattering
</p>
</li>
<li><p> Raman scattering
</p>
</li>
<li><p> Rayleigh scattering, <code class="reqn">2\lambda</code>
</p>
</li>
<li><p> Raman scattering, <code class="reqn">2\lambda</code>
</p>
</li>
<li> <p>...
</p>
</li></ol>

<p>For higher diffraction orders, the peak widths are proportionally
scaled, making it possible to provide the same number for all kinds
of scattering visible in the EEM. Set a width to <code class="reqn">0</code> if you
don't want to handle this particular kind of scattering signal.
</p>
<p>It's possible to specify the bands asymmetrically. If the area to be
corrected should range from <var>x</var> nm to the left of the scattering
peak to <var>y</var> nm to the right of it, pass a list instead of a
vector, and put a two-element vector <code>c(<var>x</var>, <var>y</var>)</code> for
the appropriate kind of scattering. For example, passing
<code>widths = list(c(30, 20), 20)</code> means &ldquo;handle <code class="reqn">-30</code>
nm to the left and <code class="reqn">+20</code> nm to the right of Rayleigh peak and
<code class="reqn">\pm 20</code> nm around Raman peak&rdquo;.
</p>
<p>To sum up, given two half-widths <code class="reqn">W_1</code> and
<code class="reqn">W_2</code>, the test for being inside a
<code class="reqn">k</code>th diffraction order of a scattering band is as follows:
</p>
<p style="text-align: center;"><code class="reqn">
      -W_1 &lt;
      \frac{\lambda_\mathrm{center}}{k} - \lambda_\mathrm{em}
      &lt; +W_2
    </code>
</p>

 

 <p><img src="../help/figures/scatter-widths.svg" width="700" alt="scatter-widths.svg" />
</p>

<p>In this example, a much larger portion of the anti-Stokes area is
removed near the first order Rayleigh scattering signal than in
the Stokes area. This can be useful to get rid of undesired signal
where no fluorescence is observed on some spectrometers. The
second and third order scattering signal areas are automatically
scaled <code class="reqn">2</code> and <code class="reqn">3</code> times, respectively.

</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_method">method</code></td>
<td>

<p>A string choosing <em>how</em> to handle the scattering signal:
</p>

<dl>
<dt>omit</dt><dd><p>Replace it with <code>NA</code>.</p>
</dd>
<dt>pchip</dt><dd>
<p>Interpolate it line-by-line using piecewise cubic Hermitean
polynomials (<code><a href="pracma.html#topic+pchip">pchip</a></code>). Pass a <code>by</code>
argument to choose the direction of interpolation; see Details.
</p>
</dd>
<dt>loess</dt><dd>
<p>Interpolate it by fitting a locally weighted polynomial surface
(<code><a href="stats.html#topic+loess">loess</a></code>). Extra arguments are passed
verbatim to <code><a href="stats.html#topic+loess">loess</a></code>, which may be used to set
parameters such as <code>span</code>.
</p>
</dd>
<dt>kriging</dt><dd>
<p>Interpolate it by means of ordinary or simple Kriging, as
implemented in <a href="https://CRAN.R-project.org/package=pracma"><span class="pkg">pracma</span></a> function
<code><a href="pracma.html#topic+kriging">kriging</a></code>.  Pass a <code>type</code> argument to
choose between the two methods. This method is not recommended
due to its high CPU time and memory demands: it has to invert a
dense <code class="reqn">O(N^2)</code> matrix (which
easily reaches multiple gigabytes for some EEMs), and compute
its product with a vector then take scalar products <code class="reqn">O(N)</code>
times, with <code class="reqn">N =</code> <code>length(x)</code>.
</p>
</dd>
<dt>whittaker</dt><dd>
<p>Interpolate it by minimising a weighted sum of squared residuals
(for known part of the spectrum) and roughness penalty (squared
central difference approximations for derivatives by
<code class="reqn">\lambda_\mathrm{em}</code>
and <code class="reqn">\lambda_\mathrm{ex}</code>).
See Details for more information and parameters.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="feemscatter_+3A_add.zeroes">add.zeroes</code></td>
<td>

<p>Set intensities at <code class="reqn">
      \lambda_\mathrm{em} &lt; \lambda_\mathrm{ex}
      - \mathtt{add.zeroes}\:\mathrm{nm}
    </code> to <code class="reqn">0</code> unless they have been measured in order to stabilise
the resulting decomposition (Thygesen, Rinnan, Barsberg, and Møller 2004). Set to <code>NA</code> to
disable this behaviour.
</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_raman.shift">Raman.shift</code></td>
<td>

<p>Raman shift of the scattering signal of water,
<code class="reqn">\textrm{cm}^{-1}</code>.
</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_...">...</code></td>
<td>

<p>Passed verbatim from <code>feemscatter</code> generics to
<code>feemscatter.feem</code>.
</p>
<p>If &ldquo;pchip&rdquo; method is selected, the <code>by</code> parameter
chooses between interpolating by row, by column, or averaging both,
see Details.
</p>
<p>If &ldquo;loess&rdquo; method is selected, remaining options are passed
to <code><a href="stats.html#topic+loess">loess</a></code> (the <code>span</code> parameter is of
particular interest there).
</p>
<p>If &ldquo;kriging&rdquo; method is selected, remaining options are passed
to <code><a href="pracma.html#topic+kriging">kriging</a></code>.
</p>
<p>If &ldquo;whittaker&rdquo; method is selected, available parameters
include <code>d</code>, <code>lambda</code>, <code>nonneg</code> and <code>logscale</code>,
see Details.
</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_cl">cl</code></td>
<td>

<p>If not <code><a href="base.html#topic+missing">missing</a></code>, a <span class="pkg">parallel</span> cluster object
to run the scattering correction code on or <code>NULL</code> for the
default cluster object registered via
<code><a href="parallel.html#topic+setDefaultCluster">setDefaultCluster</a></code>.
</p>
</td></tr>
<tr><td><code id="feemscatter_+3A_progress">progress</code></td>
<td>

<p>Set to <code>FALSE</code> to disable the progress bar.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;pchip&rdquo; method works by default as described in
(Bahram, Bro, Stedmon, and Afkhami 2006): each emission spectrum at different excitation
wavelengths is considered one by one. Zeroes are inserted in the
corners of the spectrum if they are undefined (<code>NA</code>) to prevent
extrapolation from blowing up, then the margins are interpolated using
the corner points, then the rest of the spectrum is interpolated line
by line. Since <code><a href="pracma.html#topic+pchip">pchip</a></code> requires at least 3 points
to interpolate, the function falls back to linear interpolation if it
has only two defined points to work with. The <code>by</code> argument
controls whether the function proceeds by rows of the matrix
(&ldquo;emission&rdquo;, default), by columns of the matrix
(&ldquo;excitation&rdquo;), or does both (&ldquo;both&rdquo;) and averages the
results to make the resulting artefacts less severe (Pucher, Wünsch, Weigelhofer, Murphy, Hein, and Graeber 2019)
(see the <a href="https://CRAN.R-project.org/package=staRdom"><span class="pkg">staRdom</span></a> package itself).
</p>
<p>The &ldquo;loess&rdquo; method feeds the whole FEEM except the area to be
interpolated to <code><a href="stats.html#topic+loess">loess</a></code>, then asks it to predict
the remaining part of the spectrum. Any negative values predicted by
<code><a href="stats.html#topic+loess">loess</a></code> are replaced by <code class="reqn">0</code>.
</p>
<p>The &ldquo;kriging&rdquo; method (Press, Teukolsky, Vetterling, and Flannery 2007) is much more
computationally expensive than the previous two, but, on some spectra,
provides best results, not affected by artefacts resulting from
line-by-line one-dimensional interpolation (<code>pchip</code>) or varying
degrees of smoothness in different areas of the spectrum
(<code>loess</code>). Any negative values returned by
<code><a href="pracma.html#topic+kriging">kriging</a></code> are replaced by <code class="reqn">0</code>.
</p>


<h4>Whittaker smoothing</h4>

<p>The &ldquo;whittaker&rdquo; method (Krylov and Labutin 2023) works by minimising a
sum of penalties, requiring the interpolated surface to be close to
the original points around it and to be smooth in terms of derivatives
by
<code class="reqn">\lambda_\mathrm{em}</code>
and
<code class="reqn">\lambda_\mathrm{ex}</code>.
</p>
<p>The parameters <code>d</code> and <code>lambda</code> should be numeric vectors
of the same length, corresponding to the derivative orders (whole
numbers <code class="reqn">\ge 1</code>) and their respective penalty weights (small
real numbers; larger is smoother). For interpolation purposes, the
default penalty is <code class="reqn">
      10^{-2} \mathbf{D}_1 + 10 \mathbf{D}_2
    </code>,
which corresponds to <code>d = 1:2</code> and <code>lambda = c(1e-2, 10)</code>.
</p>
<p>Any resulting negative values are pulled towards <code class="reqn">0</code> by adding
zero-valued points with weight <code>nonneg</code> (default <code class="reqn">1</code>) and
retrying. Set <code>nonneg</code> to <code class="reqn">0</code> to disable this behaviour. It
is also possible to deal with resulting negative values by scaling and
shifting the signal between <code>logscale</code> (typically) and <code class="reqn">1</code>,
interpolating the logarithm of the signal, then undoing the
transformation. By default <code>logscale</code> is <code>NA</code>, disabling
this behaviour, since it may negatively affect the shape of
interpolated signal.
</p>
<p>See the internal help page <a href="#topic+whittaker2">whittaker2</a> for implementation
details.
</p>



<h3>Value</h3>

<p>An object of the same kind (FEEM object / FEEM cube / list of them)
with scattering signal handled as requested.
</p>


<h3>References</h3>

<p> Bahram M, Bro R, Stedmon C, Afkhami A (2006).
&ldquo;Handling of Rayleigh and Raman scatter for PARAFAC modeling of fluorescence data using interpolation.&rdquo;
<em>Journal of Chemometrics</em>, <b>20</b>(3-4), 99-105.
<a href="https://doi.org/10.1002/cem.978">doi:10.1002/cem.978</a>.

<p> Krylov IN, Labutin TA (2023).
&ldquo;Recovering fluorescence spectra hidden by scattering signal: in search of the best smoother.&rdquo;
<em>Spectrochimica Acta Part A: Molecular and Biomolecular Spectroscopy</em>, 122441.
<a href="https://doi.org/10.1016/j.saa.2023.122441">doi:10.1016/j.saa.2023.122441</a>.

<p> Press WH, Teukolsky SA, Vetterling WT, Flannery BP (2007).
&ldquo;Interpolation by Kriging.&rdquo;
In <em>Numerical recipes: The Art of Scientific Computing (3rd Ed.)</em>, chapter 3.7.4, 144-147.
Cambridge University Press, New York.

<p> Pucher M, Wünsch U, Weigelhofer G, Murphy K, Hein T, Graeber D (2019).
&ldquo;staRdom: Versatile Software for Analyzing Spectroscopic Data of Dissolved Organic Matter in R.&rdquo;
<em>Water</em>, <b>11</b>(11), 2366.
<a href="https://doi.org/10.3390/w11112366">doi:10.3390/w11112366</a>.

<p> Thygesen LG, Rinnan Å, Barsberg S, Møller JKS (2004).
&ldquo;Stabilizing the PARAFAC decomposition of fluorescence spectra by insertion of zeros outside the data area.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>71</b>(2), 97-106.
ISSN 0169-7439, <a href="https://doi.org/10.1016/j.chemolab.2003.12.012">doi:10.1016/j.chemolab.2003.12.012</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+feem">feem</a></code>, <code><a href="#topic+feemcube">feemcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  plot(x &lt;- feemscatter(
    feems[[1]], widths = c(25, 25, 20, 20),
    method = 'whittaker', Raman.shift = 3500
  ))
</code></pre>

<hr>
<h2 id='feemsplithalf'>Split-half analysis of PARAFAC models</h2><span id='topic+feemsplithalf'></span><span id='topic+plot.feemsplithalf'></span><span id='topic+print.feemsplithalf'></span><span id='topic+coef.feemsplithalf'></span>

<h3>Description</h3>

<p>This function validates PARAFAC with different numbers of components
by means of splitting the data cube in halves, fitting PARAFAC to them
and comparing the results (DeSarbo 1984).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  feemsplithalf(
    cube, nfac, splits, random, groups, fixed, ..., progress = TRUE
  )
  ## S3 method for class 'feemsplithalf'
plot(x, kind = c('tcc', 'factors'), ...)
  ## S3 method for class 'feemsplithalf'
print(x, ...)
  ## S3 method for class 'feemsplithalf'
coef(object, kind = c('tcc', 'factors'), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feemsplithalf_+3A_cube">cube</code></td>
<td>

<p>A <code><a href="#topic+feemcube">feemcube</a></code> object.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_nfac">nfac</code></td>
<td>

<p>An integer vector of numbers of factors to check.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_splits">splits</code></td>
<td>

<p>A scalar or a two-element vector consisting of whole numbers.
</p>
<p>The first element is the number of parts to split the data cube
into, which must be even. After splitting, the parts are recombined
into non-intersecting halves (Murphy, Stedmon, Graeber, and Bro 2013), which are subjected
to PARAFAC decomposition and compared against each other.
</p>
<p>The second element, if specified, limits the total number of
comparisons between the pairs, since the number of potential ways to
recombine the parts of the data cube into halves grows very quickly.
</p>
<p>The number of PARAFAC models fitted is
<code class="reqn">
      2 \cdot \mathtt{splits[2]}
    </code>. If only <code>splits[1]</code> is
specified, <code>splits[2]</code> defaults to <code class="reqn">
      \mathtt{splits[1]} \choose {\mathtt{splits[1]}/2}
    </code>.
</p>
<p>Mutually incompatible with the parameters <code>random</code>, <code>fixed</code>.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_random">random</code></td>
<td>

<p>Number of times to shuffle the dataset, split into non-intersecting
halves, fit a PARAFAC model to each of the halves and compare halves
against each other (Krylov, Drozdova, and Labutin 2020).
</p>
<p>The number of PARAFAC models fitted is
<code class="reqn">2 \cdot \mathtt{random}</code>.
</p>
<p>Mutually incompatible with the parameters <code>splits</code>, <code>fixed</code>.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_groups">groups</code></td>
<td>

<p>Use this argument to preserve the ratios between the groups present
in the original dataset when constructing the halves. If specified,
must be a factor or an integer vector of length <code>dim(cube)[3]</code>
(specifying the group each sample belongs to) or a list of them,
i.e., a valid <code>f</code> argument to <code><a href="base.html#topic+split">split</a></code>. By
default, samples are considered to form a single group.
</p>
<p>For the split-combine method (<code>splits</code>), each group must have
at least <code>splits</code> elements; for best results, sizes of groups
should be close to a multiple of <code>splits</code>. For the randomised
split-half method (<code>random</code>), each group should have at least
<code class="reqn">2</code> elements.
</p>
<p>Mutually incompatible with the <code>fixed</code> parameter.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_fixed">fixed</code></td>
<td>

<p>Use this argument to manually specify the contents of the halves to
test. The argument must be a list containing two-element lists
specifying the halves to compare. Each half must be a vector
consisting of whole numbers specifying sample indices in the cube
(see the example).
</p>
<p>It is considered an error to specify a sample in both halves.
</p>
<p>Mutually incompatible with the parameters <code>splits</code>, <code>random</code>,
<code>groups</code>.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_progress">progress</code></td>
<td>

<p>Set to FALSE to disable the progress bar.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_x">x</code>, <code id="feemsplithalf_+3A_object">object</code></td>
<td>

<p>An object returned by <code>feemsplithalf</code>.
</p>
</td></tr>
<tr><td><code id="feemsplithalf_+3A_kind">kind</code></td>
<td>

<p>Chooses what type of data to return or plot:
</p>

<dl>
<dt>tcc</dt><dd>
<p>Statistics of between-half TCCs for different numbers of
components. The smallest TCC is chosen between emission- and
excitation-mode values, but otherwise they are not aggregated.
</p>
<p>When plotting, TCC values for the component with the same number
have the same colour.
</p>
</dd>
<dt>factors</dt><dd>
<p>The resulting loading values.
</p>
<p>When plotting, split the plot into panels per each number of
components and each mode (emission or excitation). Components
with the same number have the same colour.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="feemsplithalf_+3A_...">...</code></td>
<td>

<dl>
<dt>feemsplithalf</dt><dd>
<p>Remaining options are passed to <code><a href="#topic+feemparafac">feemparafac</a></code> and,
eventually, to <code><a href="multiway.html#topic+parafac">parafac</a></code>. It is recommended
to fully name the parameters instead of relying on partial or
positional matching.
</p>
</dd>
<dt>plot.feemsplithalf</dt><dd><p>Passed as-is to <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</dd>
<dt>print.feemsplithalf, coef.feemsplithalf</dt><dd>
<p>No additional options are allowed.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>As the models (loadings <code class="reqn">\mathbf A</code>,
<code class="reqn">\mathbf B</code> and scores <code class="reqn">\mathbf C</code>)
are fitted, they are compared to the first model of the same number
of factors (Tucker's congruence coefficient is calculated using
<code><a href="multiway.html#topic+congru">congru</a></code> for emission and excitation mode
factors, then the smallest value of the two is chosen for the purposes
of matching). The models are first reordered according to the best
match by TCC value, then rescaled (Riu and Bro 2003) by minimising <code class="reqn">
    || \mathbf A \, \mathrm{diag}(\mathbf s_\mathrm A) -
      \mathbf A^\mathrm{orig} ||^2
  </code> and <code class="reqn">
    || \mathbf{B} \, \mathrm{diag}(\mathbf s_\mathrm B) -
      \mathbf B^\mathrm{orig} ||^2
  </code> over <code class="reqn">\mathbf s_\mathrm A</code> and
<code class="reqn">\mathbf s_\mathrm B</code>, subject to <code class="reqn">
    \mathrm{diag}(\mathbf s_\mathrm A) \times
    \mathrm{diag}(\mathbf s_\mathrm B) \times
    \mathrm{diag}(\mathbf s_\mathrm C) = \mathbf I
  </code>, to make them comparable.
</p>
<p>To perform stratified sampling on a real-valued variable (e.g. salinity,
depth), consider binning samples into groups using
<code><a href="base.html#topic+cut">cut</a></code>, perhaps after histogram flattening using
<code><a href="stats.html#topic+ecdf">ecdf</a>(x)(x)</code>. To determine the number of breaks, consider
<code><a href="grDevices.html#topic+nclass.Sturges">nclass.Sturges</a></code>.
</p>
<p>To conserve memory, <code>feemsplithalf</code> puts the user-provided
<code>cube</code> in an environment and passes it via <code>envir</code> and
<code>subset</code> options of <code><a href="#topic+feemparafac">feemparafac</a></code>. This means that,
unlike in <code><a href="#topic+feemparafac">feemparafac</a></code>, the <code>cube</code> argument has
to be a <code><a href="#topic+feemcube">feemcube</a></code> object and passing <code>envir</code> and
<code>subset</code> options to <code>feemsplithalf</code> is not supported.
</p>
<p><code>plot.feemsplithalf</code> plots results of the split-half procedure
(TCC or loading values depending on the <code>kind</code> argument)
using <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> graphics. Sane defaults are provided for
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> parameters <code>xlab</code>, <code>ylab</code>,
<code>as.table</code>, but they can be overridden.
</p>
<p><code>print.feemsplithalf</code> displays a very short summary of the
analysis, currently the minimum TCC value for each number of components.
</p>
<p><code>coef.feemsplithalf</code> returns the Tucker's congruence
coefficients resulting from the split-half analysis.
</p>


<h3>Value</h3>


<dl>
<dt>feemsplithalf, print.feemsplithalf</dt><dd>
<p>An object of class <code>feemsplithalf</code>, containing named fields:
</p>

<dl>
<dt>factors</dt><dd>
<p>A <code><a href="base.html#topic+list">list</a></code> of <code><a href="#topic+feemparafac">feemparafac</a></code> objects
containing the factors of the halves. The list has dimensions,
the first one corresponding to the halves (always 2), the second
to different numbers of factors (as many as in <code>nfac</code>) and
the third to different groupings of the samples (depends on
<code>splits</code> or <code>random</code>).
</p>
</dd>
<dt>tcc</dt><dd>
<p>A named list containing arrays of Tucker's congruence coefficients
between the halves. Each entry in the list corresponds to an element
in the <code>nfac</code> argument. The dimensions of each array in the
list correspond to, in order: the factors (1 to <code>nfac[i]</code>), the
modes (emission or excitation) and the groupings of the samples
(depending on <code>splits</code> or <code>random</code>).
</p>
</dd>
<dt>nfac</dt><dd>
<p>A copy of <code>nfac</code> argument.
</p>
</dd>
</dl>

</dd>
<dt>plot.feemsplithalf</dt><dd>
<p>A <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> plot object. Its <code>print</code> or <code>plot</code> method
will draw the plot on an appropriate plotting device.
</p>
</dd>
<dt>coef.feemsplithalf</dt><dd>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing various columns,
depending on the value of the <code>kind</code> argument:
</p>

<dl>
<dt>tcc</dt><dd>
<dl>
<dt>factor</dt><dd>
<p>The factor (out of <code>nfac</code>) under consideration.
</p>
</dd>
<dt>tcc</dt><dd>
<p>Tucker's congruence coefficient between a pair of matching
components.  Out of two possible values (TCC between excitation
loadings or emission loadings), the minimal one is chosen,
because the same rule is used to find which components match
when reordering them in a pair of models.
</p>
</dd>
<dt>test</dt><dd>
<p>The sequence number for each pair of models in the split-half
test, related to the third dimension of <code>object$factors</code>
or <code>object$tcc</code>.  May be used to group values for plotting
or aggregation.
</p>
</dd>
<dt>subset</dt><dd>
<p>Consists of two-element lists containing indices of the samples
in each half of the original cube.
</p>
</dd>
<dt>nfac</dt><dd>
<p>The number of factors in the pair of models under consideration.
</p>
</dd>
</dl>
</dd>
<dt>factors</dt><dd>
<dl>
<dt>wavelength</dt><dd>
<p>Emission and excitation wavelengths.
</p>
</dd>
<dt>value</dt><dd>
<p>The values of the loadings.
</p>
</dd>
<dt>factor</dt><dd>
<p>Number of the factor, <code class="reqn">1</code> to <code>nfac</code>.
</p>
</dd>
<dt>mode</dt><dd>
<p>The mode the loading value belongs to, &ldquo;Emission&rdquo;
or &ldquo;Excitation&rdquo;.
</p>
</dd>
<dt>nfac</dt><dd>
<p>Total number of factors.
</p>
</dd>
<dt>test</dt><dd>
<p>Sequence number of a split-half test, indicating a given way
to split the dataset in a group of splits with the same numbers
of factors.
</p>
</dd>
<dt>half</dt><dd>
<p>Number of the half, <code class="reqn">1</code> or <code class="reqn">2</code>.
</p>
</dd>
<dt>subset</dt><dd>
<p>For every row, this is an integer vector indicating the
subset of the original data cube that the loadings have been
obtained from.
</p>
</dd>
</dl>
</dd>
</dl>

</dd>
</dl>


<h3>References</h3>

<p> DeSarbo WS (1984).
&ldquo;An Application of PARAFAC to a Small Sample Problem, Demonstrating Preprocessing, Orthogonality Constraints, and Split-Half Diagnostic Techniques (Appendix).&rdquo;
<em>Research Methods for Multimode Data Analysis</em>, 602-642.
<a href="https://papers.ssrn.com/abstract=2783446">https://papers.ssrn.com/abstract=2783446</a>.

<p> Krylov I, Drozdova A, Labutin T (2020).
&ldquo;Albatross R package to study PARAFAC components of DOM fluorescence from mixing zones of arctic shelf seas.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>207</b>(104176).
<a href="https://doi.org/10.1016/j.chemolab.2020.104176">doi:10.1016/j.chemolab.2020.104176</a>.

<p> Murphy KR, Stedmon CA, Graeber D, Bro R (2013).
&ldquo;Fluorescence spectroscopy and multi-way techniques. PARAFAC.&rdquo;
<em>Analytical Methods</em>, <b>5</b>, 6557-6566.
<a href="https://doi.org/10.1039/c3ay41160e">doi:10.1039/c3ay41160e</a>.

<p> Riu J, Bro R (2003).
&ldquo;Jack-knife technique for outlier detection and estimation of standard errors in PARAFAC models.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>65</b>(1), 35-49.
<a href="https://doi.org/10.1016/S0169-7439%2802%2900090-4">doi:10.1016/S0169-7439(02)00090-4</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemparafac">feemparafac</a></code>, <code><a href="multiway.html#topic+parafac">parafac</a></code>,
<code><a href="multiway.html#topic+congru">congru</a></code>, <code><a href="#topic+feemcube">feemcube</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(feems)
  cube &lt;- feemscale(feemscatter(cube, rep(14, 4)), na.rm = TRUE)

  (sh &lt;- feemsplithalf(
    cube, 1:4, splits = 4 # =&gt; S4C6T3
    # splits = c(4, 2) would be S4C4T2, and so on
    # the rest is passed to multiway::parafac;
    # setting ctol and maxit is recommended
  ))

  # specifying fixed halves to compare as list of 2-element lists
  fixed &lt;- list(
    list(1:6, 7:12),
    list(seq(1, 11, 2), seq(2, 12, 2))
  )
  sh.f &lt;- feemsplithalf(cube, 2:3, fixed = fixed)

  # can use feemparafac methods for individual models in $factors
  plot(sh$factors[[1]])
  plot(sh)
  plot(sh, 'factors')
  head(coef(sh))
  head(coef(sh, 'factors'))
</code></pre>

<hr>
<h2 id='marine.colours'>Perceptually uniform palettes</h2><span id='topic+marine.colours'></span><span id='topic+diverging.colours'></span>

<h3>Description</h3>

<p>Create perceptually continuous palettes of <span class="rlang"><b>R</b></span> colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  marine.colours(
    n, chroma = 0.65, luminance = c(0.35, 1),
    alpha = 1, gamma = 1, fixup = TRUE
  )
  diverging.colours(
    n, chroma = c(.1, .75), luminance = c(1, .35),
    alpha = 1, gamma = 1, fixup = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marine.colours_+3A_n">n</code></td>
<td>

<p>Number of colours to return.
</p>
</td></tr>
<tr><td><code id="marine.colours_+3A_chroma">chroma</code></td>
<td>

<p>Specifies the chroma (how saturated should the colours be) for the
palette, a real number between <code class="reqn">0</code> and <code class="reqn">1</code>. May also be a
two-element vector, in which case the chroma is changed smoothly
from start to finish of the resulting palette.
</p>
</td></tr>
<tr><td><code id="marine.colours_+3A_luminance">luminance</code></td>
<td>

<p>Specifies the luminance (how bright should the colours be) of the
colours constituting the palette. Typically, a two-element vector
of real numbers between <code class="reqn">0</code> and <code class="reqn">1</code> to indicate smooth
change along the palette, but can also be a fixed number.
</p>
</td></tr>
<tr><td><code id="marine.colours_+3A_alpha">alpha</code></td>
<td>

<p>Specifies the transparency of the colours of the palette. As above,
can be a fixed number or a two-element vector in the range
<code class="reqn">[0,1]</code>. Typically, fully opaque (<code>alpha=1</code>) colours are
used.
</p>
</td></tr>
<tr><td><code id="marine.colours_+3A_gamma">gamma</code></td>
<td>

<p>Provides the power coefficient for the hue/chroma/luminance/alpha
growth formulae. May be useful when it is needed to sacrifice the
perceptual linearity of the palette to provide more contrast for
smaller or bigger values on the plot. The gamma-corrected values
are obtained by computing
<code class="reqn">x ^ \gamma</code>,
<code class="reqn">x \in [0;1]</code>, then scaling
the result linearly to the required range. Typically, linear growth
(<code>gamma = 1</code>) is preferred.
</p>
</td></tr>
<tr><td><code id="marine.colours_+3A_fixup">fixup</code></td>
<td>

<p>Whether to correct the palette if the resulting colours happen to
fall outside the valid RGB range (passed as-is to <code>hcl</code>).
Unrepresentable colours are returned as <code>NA</code>s, but fixing the
palette may make it less perceptually uniform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>marine.colours</code> palette is used by default by all
<code>plot</code> methods (e.g. <code><a href="#topic+plot.feem">plot.feem</a></code>) for FEEM-like data
to show absolute values.  It is designed to retain perceptual
uniformity even after complete desaturation.
</p>
<p>The <code>diverging.colours</code> palette is used by
<code><a href="#topic+plot.feem.resid">plot.feem.resid</a></code> to display residual values. People with
severe colour vision deficiency (tritanopia or monochromacy) won't be
able to discern positive and negative branches of the palette, but
it's supposed to be legible for people with deuteranopia and
protanopia.
</p>


<h3>Value</h3>

<p>A character vector of length <code>n</code> containing colour specifications
for use with <span class="rlang"><b>R</b></span> graphics functions.
</p>

 

 <p><img src="../help/figures/marinecolours.png" width="400" alt="marinecolours.png" />
</p>
<p>The <code>marine.colours</code> palette at the default values of
<code class="reqn">C_{uv}^* = 0.65</code>, <code class="reqn">L^* \in [0.35; 1]</code>, <code class="reqn">\alpha = \gamma = 1</code>.
</p>
 

 <p><img src="../help/figures/divergingcolours.png" width="400" alt="divergingcolours.png" />
</p>
<p>The <code>diverging.colours</code> palette at the default values of
<code class="reqn">C_{uv}^* \in [0.1; 0.75]</code>, <code class="reqn">L^* \in [0.35;
    1]</code>,
<code class="reqn">\alpha = \gamma = 1</code>.

</p>


<h3>References</h3>

<p>Insired by cmocean palette called &ldquo;haline&rdquo;
(<a href="https://matplotlib.org/cmocean/#haline">https://matplotlib.org/cmocean/#haline</a>), but using <span class="rlang"><b>R</b></span>'s
implementation of polar CIE-LUV colour space instead of CAM02-UCS.
</p>
<p>CUBEHELIX (<a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/">https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/</a>) is a
similar technique using BT.601 luminance coefficients and RGB colour
space.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.feem">plot.feem</a></code>, <code><a href="grDevices.html#topic+hcl">hcl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  image(volcano, col = marine.colours(256))
</code></pre>

<hr>
<h2 id='plot.feem'>Plot a FEEM object</h2><span id='topic+plot.feem'></span><span id='topic+plot.feemcube'></span><span id='topic+plot.feem.resid'></span>

<h3>Description</h3>

<p>Plot a 2D fluorescence intensity surface as a pseudo-colour image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feem'
plot(
  x,
  xlab = quote(lambda[em] * ", nm"), ylab = quote(lambda[ex] * ", nm"),
  cuts = 128, col.regions = marine.colours(256), ...
)
## S3 method for class 'feemcube'
plot(
  x,
  xlab = quote(lambda[em] * ", nm"), ylab = quote(lambda[ex] * ", nm"),
  cuts = 128, col.regions = marine.colours(256), as.table = TRUE, ...
)
## S3 method for class 'feem.resid'
plot(
  x, ..., at, col.regions = diverging.colours(256)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.feem_+3A_x">x</code></td>
<td>

<p>An FEEM object.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_xlab">xlab</code></td>
<td>

<p>The x-axis label for the plot, with a sane default.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_ylab">ylab</code></td>
<td>

<p>The y-axis label for the plot, with a sane default.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_cuts">cuts</code></td>
<td>

<p>The number of distinct levels the intensity would be divided into,
areas between them assigned different colours.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_col.regions">col.regions</code></td>
<td>

<p>The palette to take the colours from, a character vector of <span class="rlang"><b>R</b></span>
colour specifications.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_at">at</code></td>
<td>

<p>The breakpoints in the intensity values. For residual plots,
automatically set in a symmetric manner, ignoring the <code>cuts</code>
argument.
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_as.table">as.table</code></td>
<td>

<p>Whether to draw the panels left to right, top to bottom. (Otherwise
they are drawn left to right, bottom to top.)
</p>
</td></tr>
<tr><td><code id="plot.feem_+3A_...">...</code></td>
<td>

<p>Passed as-is to <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a> plot object. Its <code>print</code> or <code>plot</code> method
will draw the plot on an appropriate plotting device.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+levelplot">levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(feem(matrix(1:42/42, nrow = 7), 320 + 1:7, 300 + 1:6))
</code></pre>

<hr>
<h2 id='whittaker2'>
Implementation notes for Whittaker smoothing and interpolation of surfaces
</h2><span id='topic+whittaker2'></span><span id='topic+diffmat'></span><span id='topic+vandermonde'></span>

<h3>Description</h3>

<p>Smooth (Eilers 2003) or estimate the baseline
(Eilers 2004) of a surface measured on an arbitrary grid by
minimising a sum of penalties. Combined difference orders and two
different methods of preventing negative values in the output are
supported.
</p>
<p><em>This is not a public interface.</em> Subject to change without
further notice. Please do not call from outside <a href="https://CRAN.R-project.org/package=albatross"><span class="pkg">albatross</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whittaker2(x, y, z, lambda, d, p, logscale, nonneg)
  diffmat(x, y, d)
  vandermonde(x0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whittaker2_+3A_x">x</code></td>
<td>
<p>Grid values along the rows of <code>z</code>.</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_y">y</code></td>
<td>
<p>Grid values along the columns of <code>z</code>.</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_z">z</code></td>
<td>

<p>Matrix containing the surface values to smooth or <code>NA</code>s to
interpolate.
</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_lambda">lambda</code></td>
<td>

<p>A vector of smoothness penalties, one for every difference order.
Must be of the same length as <code>d</code>.
</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_d">d</code></td>
<td>

<dl>
<dt><code>whittaker2</code></dt><dd>
<p>A vector of difference orders corresponding to elements of
<code>lambda</code>.
</p>
</dd>
<dt><code>diffmat</code></dt><dd>
<p>Difference order, an integer scalar.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="whittaker2_+3A_p">p</code></td>
<td>

<p>If not missing, use the asymmetric penalty method
(Eilers 2004) to estimate the baseline by penalising the
differences with weight <code class="reqn">p</code> if
<code class="reqn">\hat{z} &lt; z</code> and <code class="reqn">1 - p</code>
otherwise. Typically, values around
<code class="reqn">10^{-3}</code> are used.
</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_logscale">logscale</code></td>
<td>

<p>If not <code>NA</code>, rescale <code>z</code> between <code>logscale</code> and
<code class="reqn">1</code> and take its logarithm before smoothing, then undo it.
</p>
<p>Such transformation prevents the resulting values from getting lower
than <code class="reqn">
      \mathrm{min}(x) - (\mathrm{max}(x) - \mathrm{min}(x))
      \frac{\mathtt{logscale}}{1 - \mathtt{logscale}}
    </code>,
which is approximately <code class="reqn">
      -\mathtt{logscale} \cdot \mathrm{max}(x)
    </code> if <code>logscale</code> and <code class="reqn">\mathrm{min}(x)</code> are both close to <code class="reqn">0</code>.
</p>
<p>A typical value would be <code class="reqn">10^{-4}</code>.
Disabled by default because it may damage the surface shape in the
process.
</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_nonneg">nonneg</code></td>
<td>

<p>If not <code class="reqn">0</code>, for every resulting negative value in the
interpolated surface, add a penalty of <code class="reqn">
      \mathtt{nonneg} \cdot \sum_i \mathbf{1}_{\hat{z}_i &lt; 0}
      \, \hat{z}_i^2
    </code> to pull it towards <code class="reqn">0</code> and repeat the process until no new
penalties are introduced.
</p>
</td></tr>
<tr><td><code id="whittaker2_+3A_x0">x0</code></td>
<td>

<p>A vector specifying the grid where the function to be differentiated
is measured. Must be sorted.
</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Finite difference approximation</h4>

<p>How to differentiate a function tabulated on a fixed, potentially
nonuniform grid before you even know its values? Use its Taylor
series.
</p>
<p>First derivative is special because it's possible to use central
differences and get a second-order accurate result, even on a
non-uniform grid, by carefully choosing the points where the
derivative is calculated. Let <code class="reqn">x + \frac{h}{2}</code> and
<code class="reqn">x - \frac{h}{2}</code> be a pair of adjacent points from the
grid. Here's the Taylor series expansion for <code class="reqn">f</code> around <code class="reqn">x</code>,
with the Lagrange form of the reminder:
</p>
<p style="text-align: center;"><code class="reqn">
      f \left(x + \frac{h}{2}\right) =
        f(x) + \frac{h}{2} f'(x) + \frac{h^2}{8} f''(x) +
        \frac{h^3}{48} f'''(\zeta)
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      f \left(x - \frac{h}{2}\right) =
        f(x) - \frac{h}{2} f'(x) + \frac{h^2}{8} f''(x) -
        \frac{h^3}{48} f'''(\eta)
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      f \left(x + \frac{h}{2}\right) -
        f \left(x - \frac{h}{2}\right) = h f'(x) +
        \frac{h^3}{48} \left(f'''(\zeta) + f'''(\eta)\right)
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      f'(x) = \frac{
        f\left(x + \frac{h}{2}\right) - f\left(x - \frac{h}{2}\right)
      }{h} - \frac{h^2}{48} \left(f'''(\zeta) + f'''(\eta)\right)
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      |\delta f'(x)| \le \max_{
        \xi \in [x - \frac{h}{2}, x + \frac{h}{2}]
      } \frac{h^2}{24} f'''(\xi)
    </code>
</p>

<p>Suppose the three grid points
<code class="reqn">\xi_1 = x_1 - \frac{h_1}{2}</code>,
<code class="reqn">
      \xi_2 = x_1 + \frac{h_1}{2} = x_2 - \frac{h_2}{2}
    </code>,
<code class="reqn">\xi_3 = x_2 + \frac{h_2}{2}</code> are adjacent on the grid, and we
know the <code class="reqn">f'</code> estimates in <code class="reqn">x_1</code> and
<code class="reqn">x_2</code>:
</p>

 

 <p><img src="../help/figures/whittaker2points.svg" width="400" alt="whittaker2points.svg" />


</p>
<p>On the one hand, Taylor series
expansion for <code class="reqn">f'(x)</code> around
<code class="reqn">\frac{x_1 + x_2}{2}</code> gives:
</p>
<p style="text-align: center;"><code class="reqn">
      f'(x_2) = f'\left(\frac{x_1 + x_2}{2}\right)
        + f''\left(\frac{x_1 + x_2}{2}\right)\frac{x_2 - x_1}{2}
        + f'''\left(\frac{x_1 + x_2}{2}\right)\frac{(x_2 - x_1)^2}{8}
        + f''''(\zeta)\frac{(x_2 - x_1)^3}{48}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      f'(x_1) = f'\left(\frac{x_1 + x_2}{2}\right)
        - f''\left(\frac{x_1 + x_2}{2}\right)\frac{x_2 - x_1}{2}
        + f'''\left(\frac{x_1 + x_2}{2}\right)\frac{(x_2 - x_1)^2}{8}
        - f''''(\eta)\frac{(x_2 - x_1)^3}{48}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      f''\left(\frac{x_1 + x_2}{2}\right) =
        \frac{f'(x_2) - f'(x_1)}{x_2 - x_1} -
        \frac{(x_2 - x_1)^2}{48}(f''''(\zeta) + f''''(\eta))
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      |\delta f''(x)| \le \max_{
        \xi \in [x_1, x_2]
      } \frac{(x_2 - x_1)^2}{24} f''''(\xi)
    </code>
</p>

<p>On the other hand, if we substitute the estimations of <code class="reqn">f'(x)</code>
from above, we get:
</p>
<p style="text-align: center;"><code class="reqn">
      f''\left(\frac{x_1 + x_2}{2}\right) = \frac{
        h_1 f(\xi_3) - h_1 f(\xi_2)
        - h_2 f(\xi_2) + h_2 f(\xi_1)
      }{h_1 h_2 (x_2 - x_1)} - \frac{
        h_2^2 f'''(\zeta_2)
        - h_1^2 f'''(\zeta_1)
      }{24(x_2 - x_1)}
      - \frac{(x_2 - x_1)^2}{24} f''''(\eta)
    </code>
</p>

<p>This is why we can't just keep using central differences and get
<code class="reqn">n+1</code>th order accurate results.
</p>
<p>What are the general methods of finding the coefficients for the
<code class="reqn">\mathbf D</code> matrix? Start with a system of Taylor
series expansions for every grid point:
</p>
<p style="text-align: center;"><code class="reqn">
      f(x_i) = \sum_{k=0}^{n-1} f^{(k)}(x) \frac{(x_i - x)^k}{k!}
      + f^{(n)}(\xi) \frac{(x_i - x)^{n}}{n!}
      \; \forall i = 1 \dots n
    </code>
</p>

<p>We can solve this system for coefficients
<code class="reqn">c_i</code> giving the desired <code class="reqn">l</code>-th
derivative estimate with highest accuracy <code class="reqn">p</code> possible
(LeVeque 2007):
</p>
<p style="text-align: center;"><code class="reqn">
      \sum_{i = 1}^n c_i f(x_i) = f^{(l)}(x) + o(h^p)
    </code>
</p>

<p>Substituting the approximations for
<code class="reqn">f(x_i)</code> into the equation, we get the
following condition for the multiplier in front of each
<code class="reqn">f^{(k)}(x)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
      \frac{1}{k!} \sum_{i = 1}^n c_i (x_i - x)^k = \mathbf{1}_{k = l}
      \; \forall k = 0 \dots n-1
    </code>
</p>

<p>In the matrix form, this becomes a Vandermonde system:
</p>
<p style="text-align: center;"><code class="reqn">
      V_{k,i} = \frac{(x_i - x)^k}{k!}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      b_k = \mathbf{1}_{k = l}
    </code>
</p>

<p style="text-align: center;"><code class="reqn">
      \mathbf c = \mathbf{V}^{-1} \mathbf b
    </code>
</p>

<p>Unfortunately, this system becomes ill-conditioned for &ldquo;large&rdquo;
numbers of points. (Experiment shows noticeably growing
<code class="reqn">c_i</code> even for third derivative from <code class="reqn">10</code>
points and no solution for <code class="reqn">32</code> points on a uniform grid.)
Fornberg (Fornberg 1988) suggests a more numerically stable
procedure, but it still breaks down for <code class="reqn">1000</code> points.
</p>
<p>It is important to note that the performance of the method depends
on the matrix <code class="reqn">\mathbf D</code> being sparse. While the methods
described above could give more accurate results, they do so at the cost of
providing nonzero weights for a lot of points, and the weights get larger
as the number of points increases. Therefore, with the knowledge that
difference orders above <code class="reqn">3</code> are used very rarely and the interest in
simplicity and performance, we'll minimise the number of coefficients and
their values by solving the Vandermonde system for the minimally accurate
derivative estimations, taking exactly <code class="reqn">k + 1</code> points for <code class="reqn">k</code>-th
derivative.
</p>
<p>What is the error of such estimation? Substituting the Lagrange form
of the remainder into <code class="reqn">
      \mathbf{c}^\top f(\mathbf x)
    </code>, we get:
</p>
<p style="text-align: center;"><code class="reqn">
      \sum_{i = 1}^n c_i f(x_i) = f^{(n-1)}(x) +
        \sum_{i = 1}^n c_i f^{(n)}(\xi_i) \frac{(x_i - x)^n}{n!},
      \; \xi_i \in [ x_i, x ]
    </code>
</p>

<p>Our choice of <code class="reqn">x</code> (middle point for odd <code class="reqn">n</code>, average of
middle points for even <code class="reqn">n</code>) lets us shave off one term from the
sum above for odd <code class="reqn">n</code> and get second order accurate results for
<code class="reqn">n = 2</code>, but other than that, the method is <code class="reqn">n</code>-th order
accurate.
</p>



<h4>Whittaker smoothing</h4>

<p>Whittaker smoothing works by minimising a sum of penalties
(Eilers 2003). Interpolation can be achieved by setting weights
<code class="reqn">\mathbf w</code> to <code class="reqn">0</code> for the missing points.
</p>
<p style="text-align: center;"><code class="reqn">
      \min_{\mathbf{\hat z}} \:
      (\mathbf{\hat z} - \mathbf{z})^\top
        \mathrm{diag}(\mathbf w)
        (\mathbf{\hat z} - \mathbf{z})
      + \lambda | \mathbf D \mathbf{\hat z} |^2
    </code>
</p>

<p>By writing down the derivatives over
<code class="reqn">\mathbf{\hat z}</code> and equating them to
<code class="reqn">0</code>, we get the normal equation:
</p>
<p style="text-align: center;"><code class="reqn">
      (
        \mathrm{diag}(\mathbf w) +
        \lambda \mathbf{D}^\top \mathbf{D}
      ) \mathbf{\hat z} = \mathrm{diag}(\mathbf w) \mathbf z
    </code>
</p>

<p>The equation is then solved using <code><a href="Matrix.html#topic+solve">solve</a></code>.
</p>
<p>Given a one-dimensional penalty matrix
<code class="reqn">\mathbf{D}_d</code> of order <code class="reqn">d</code>
obtained by solving a Vandermonde system for every successive group
of <code class="reqn">d+1</code> points, we can adapt it for every applicable group of
points from a fluorescence excitation-emission matrix unfolded into
a vector <code class="reqn">\mathbf z = \mathrm{vec}\, \mathbf F</code> by
taking Kronecker products with unit matrices: </p>
<p style="text-align: center;"><code class="reqn">
      \mathbf D = \begin{pmatrix}
        \mathbf I \otimes \mathbf{D}_\mathrm{em} \\
        \mathbf{D}_\mathrm{ex} \otimes \mathbf I
      \end{pmatrix}
    </code>
</p>

<p>Penalties of different orders are concatenated by rows in a similar
manner (which is equivalent to adding the corresponding
<code class="reqn">\mathbf{D}^\top\mathbf D</code> matrices together in the normal equation).
</p>
<p>It has been shown in (Eilers and Goeman 2004) that a combination of
first- and second-order penalty (<code class="reqn">
      2 \lambda \mathbf{D}_1 + \lambda^2 \mathbf{D}_2
    </code>)
results in a non-negative impulse response, but the resulting peak
shape may be sub-optimal.
</p>



<h3>Value</h3>

<table>
<tr><td><code>whittaker2</code></td>
<td>

<p>A matrix of the same shape as <code>z</code>, with values smoothed,
interpolated, or baseline estimated.
</p>
</td></tr>
<tr><td><code>diffmat</code></td>
<td>

<p>A difference matrix <code class="reqn">\mathbf D</code> that, when
multiplied by <code class="reqn">\mathrm{vec}(\mathbf{Z})</code>,
returns a vector of estimated derivatives of <code class="reqn">\mathbf
    Z</code> of given order by <code class="reqn">x</code> and <code class="reqn">y</code> in every available
point (see below).
</p>
</td></tr>
<tr><td><code>vandermonde</code></td>
<td>

<p>A vector <code class="reqn">\mathbf c</code> of length <code class="reqn">n =</code>
<code>length(x0)</code> such that
<code class="reqn">
      \mathbf{c}^\top f(\mathbf{x_0}) \approx f^{(n-1)}(x)
    </code>. The
<code class="reqn">x</code> is either the median point of <code>x0</code> or the average of
two points in the middle, depending on whether <code class="reqn">n</code> is odd or even.
</p>
</td></tr>
</table>


<h3>References</h3>

<p> Eilers PHC (2003).
&ldquo;A Perfect Smoother.&rdquo;
<em>Analytical Chemistry</em>, <b>75</b>(14), 3631-3636.
<a href="https://doi.org/10.1021/ac034173t">doi:10.1021/ac034173t</a>.

<p> Eilers PHC (2004).
&ldquo;Parametric Time Warping.&rdquo;
<em>Analytical Chemistry</em>, <b>76</b>(2), 404-411.
<a href="https://doi.org/10.1021/ac034800e">doi:10.1021/ac034800e</a>.

<p> Eilers PHC, Goeman JJ (2004).
&ldquo;Enhancing scatterplots with smoothed densities.&rdquo;
<em>Bioinformatics</em>, <b>20</b>(5), 623-628.
<a href="https://doi.org/10.1093/bioinformatics/btg454">doi:10.1093/bioinformatics/btg454</a>.

<p> Fornberg B (1988).
&ldquo;Generation of finite difference formulas on arbitrarily spaced grids.&rdquo;
<em>Mathematics of Computation</em>, <b>51</b>(184), 699-706.
<a href="https://doi.org/10.1090/S0025-5718-1988-0935077-0">doi:10.1090/S0025-5718-1988-0935077-0</a>.

<p> LeVeque RJ (2007).
&ldquo;Finite Difference Approximations.&rdquo;
In <em>Finite Difference Methods for Ordinary and Partial Differential Equations</em>, chapter 1, 3-11.
Society for Industrial and Applied Mathematics (SIAM).
<a href="https://faculty.washington.edu/rjl/fdmbook/">https://faculty.washington.edu/rjl/fdmbook/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemscatter">feemscatter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  z &lt;- feemscatter(feems$a, rep(25, 4), 'omit')
  str(albatross:::whittaker2(
    attr(z, 'emission'), attr(z, 'excitation'), z,
    c(1, 1e-3), 1:2, logscale = NA, nonneg = 1
  ))
</code></pre>

<hr>
<h2 id='write.openfluor'>Export a PARAFAC model for the OpenFluor database</h2><span id='topic+write.openfluor'></span>

<h3>Description</h3>

<p>Prepares a fitted PARAFAC model for submission to OpenFluor - an online
spectral database of fluorescence by environmental organic compounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.openfluor(
  model, filename, name = "?", creator = "?", doi = "?",
  reference = "?", unit = "?", toolbox =, date =, fluorometer = "?",
  constraints =, validation = "?", methods = "?", preprocess = "?",
  sources = "?", ecozones = "?", description = "",
  shift = FALSE, scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.openfluor_+3A_model">model</code></td>
<td>
<p>A <code><a href="#topic+feemparafac">feemparafac</a></code> object.</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_filename">filename</code></td>
<td>

<p>Path to the text file to create from the <code>model</code> argument.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_name">name</code></td>
<td>

<p>Short name of the model.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_creator">creator</code></td>
<td>

<p>Name of the creator of the model.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_doi">doi</code></td>
<td>

<p>Digital object identifier of the referenced source. Can also be
&ldquo;ISBN:...&rdquo; for books.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_reference">reference</code></td>
<td>

<p>Full citation for the referenced source using the following style:
&ldquo;Author AA, Author BB, Author CC, (year), &lsquo;Title&rsquo;,
Journal Abbrev, Vol, pages&rdquo;.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_unit">unit</code></td>
<td>

<p>Units the fluorescence was measured in. Typically, one of &ldquo;RU&rdquo;,
&ldquo;QSE&rdquo;, &ldquo;AU&rdquo;.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_toolbox">toolbox</code></td>
<td>

<p>Defaults to
&ldquo;albatross <var>version</var>, multiway <var>version</var>&rdquo;.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_date">date</code></td>
<td>

<p>Defaults to today, in &ldquo;<var>yyyy</var>-<var>mm</var>-<var>dd</var>&rdquo; format.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_fluorometer">fluorometer</code></td>
<td>

<p>The model of the instrument that produced the data.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_constraints">constraints</code></td>
<td>

<p>Constraints applied to the PARAFAC model. Defaults to
<code>model$const</code>, but please edit it to a more human-readable form.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_validation">validation</code></td>
<td>

<p>Validation method used for the PARAFAC model, examples include:
&ldquo;Split-Half Analysis&rdquo;, &ldquo;core-consistency&rdquo;.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_methods">methods</code></td>
<td>

<p>The sequence of steps taken to handle the samples and to ensure
proper fluorescence intensity measurement. Examples include: </p>

<ul>
<li><p> Sampling: Filtration GF/F
</p>
</li>
<li><p> Sampling: Filtration <var>x</var> um
</p>
</li>
<li><p> Sampling: samples frozen
</p>
</li>
<li><p> Instrument spectral bias correction: Ex
</p>
</li>
<li><p> Instrument spectral bias correction: Em
</p>
</li>
<li><p> Instrument spectral bias correction: Ex &amp; Em
</p>
</li>
<li><p> Inner filter effect correction: absorbance method
</p>
</li>
<li><p> Inner filter effect correction: dilution
</p>
</li>
<li><p> Inner filter effect correction: CDA
</p>
</li>
<li><p> Inner filter effect correction: <var>other (please describe)</var>
</p>
</li>
<li><p> Internal calibration: Raman Peak area
</p>
</li>
<li><p> Internal calibration: Raman Peak height
</p>
</li>
<li><p> Internal calibration: Blank Subtraction
</p>
</li>
<li><p> External calibration: Quinine Sulphate dilution series
</p>
</li>
<li><p> External calibration: STARNA reference standards
</p>
</li>
<li><p> External calibration: NIST reference standards
</p>
</li>
<li><p> External calibration: <var>other (please describe)</var>
</p>
</li></ul>

</td></tr>
<tr><td><code id="write.openfluor_+3A_preprocess">preprocess</code></td>
<td>

<p>PARAFAC-specific pre-processing steps applied to the dataset. Examples
include (but are not limited to): </p>

<ul>
<li><p> Outliers removed
</p>
</li>
<li><p> Scatter region excised (replaced with NaNs)
</p>
</li>
<li><p> Scatter region smoothed (replaced with interpolated values)
</p>
</li>
<li><p> Sample mode normalised to DOC concentration
</p>
</li>
<li><p> Sample mode normalised to unit variance
</p>
</li></ul>

</td></tr>
<tr><td><code id="write.openfluor_+3A_sources">sources</code></td>
<td>

<p>Should preferably include one or more of the following keywords:
</p>

<ul>
<li><p> river
</p>
</li>
<li><p> stream
</p>
</li>
<li><p> lake
</p>
</li>
<li><p> wetland
</p>
</li>
<li><p> reservoir
</p>
</li>
<li><p> estuary
</p>
</li>
<li><p> ocean - coastal and shelf seas
</p>
</li>
<li><p> ocean - surface off-shore
</p>
</li>
<li><p> ocean - deep off-shore
</p>
</li>
<li><p> freshwater
</p>
</li>
<li><p> seawater
</p>
</li>
<li><p> groundwater
</p>
</li>
<li><p> wastewater
</p>
</li>
<li><p> drinking water
</p>
</li>
<li><p> treated water
</p>
</li>
<li><p> recycled water
</p>
</li>
<li><p> ballast water
</p>
</li>
<li><p> sediment
</p>
</li>
<li><p> mudflat
</p>
</li>
<li><p> mangrove
</p>
</li>
<li><p> aquarium
</p>
</li>
<li><p> mesocosm
</p>
</li></ul>

</td></tr>
<tr><td><code id="write.openfluor_+3A_ecozones">ecozones</code></td>
<td>

<p>List all major or minor terrestrial, freshwater and
marine ecozones and ecoregions that apply. The full set
of possible options is too large to include here, but see
<a href="https://en.wikipedia.org/wiki/Lists_of_ecoregions">https://en.wikipedia.org/wiki/Lists_of_ecoregions</a> for a source
of inspiration.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_description">description</code></td>
<td>

<p>Brief description of the model and its source data in <code class="reqn">\le 256</code>
characters.
</p>
</td></tr>
<tr><td><code id="write.openfluor_+3A_shift">shift</code>, <code id="write.openfluor_+3A_scale">scale</code></td>
<td>

<p>If <code>shift</code> is specified (default <code>FALSE</code>), the loadings
are first shifted by subtracting <code>min(x)</code> to ensure that the
minimal value is <code class="reqn">0</code>.
</p>
<p>If <code>scale</code> is specified (default <code>TRUE</code>), the loadings
are then rescaled by dividing by <code>max(x)</code> so that the maximal
value is <code class="reqn">1</code>.
</p>
<p>Note that OpenFluor clamps values outside the <code class="reqn">[0, 1]</code> range
and uses scale-invariant (but <em>not</em> shift-invariant) Tucker's
congruence coefficient to find matches.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provided the <code>model</code> and the <code>filename</code> arguments, this
function exports the loadings into a file that passes OpenFluor syntax
check and is suitable for further editing. Alternatively, some or all
of the fields may be specified programmatically.
</p>
<p>The fields <code>constraints</code>, <code>methods</code>, <code>preprocess</code>,
<code>sources</code>, <code>ecozones</code> can be specified as character vectors
(to be comma-separated on output); others should be single strings.
</p>


<h3>References</h3>

<p>Murphy KR, Stedmon CA, Wenig P, Bro R (2014).
&ldquo;OpenFluor - an online spectral library of auto-fluorescence by organic compounds in the environment.&rdquo;
<em>Analytical Methods</em>, <b>6</b>, 658-661.
<a href="https://doi.org/10.1039/C3AY41935E">doi:10.1039/C3AY41935E</a>.
</p>
<p><a href="https://openfluor.lablicate.com/">https://openfluor.lablicate.com/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feemparafac">feemparafac</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(feems)
  cube &lt;- feemscale(feemscatter(cube, rep(14, 4)), na.rm = TRUE)
  factors &lt;- feemparafac(cube, nfac = 3)
  # all defaults
  write.openfluor(factors, f1 &lt;- tempfile(fileext = '.txt'))
  if (interactive()) file.show(f1)
  unlink(f1)
  # all non-default arguments
  write.openfluor(
    factors, f2 &lt;- tempfile(fileext = '.txt'), name = 'example',
    creator = 'J. Doe', doi = '10.1000/1', reference = paste(
      'Upper D, (1973),', "'The unsuccessful self-treatment of a case",
      "of \"writer's block\"',", 'J Appl Behav Anal, 7(3), 497'
    ), unit = 'AU', toolbox = 'all calculations done by hand',
    date = '2038-01-19', fluorometer = 'Acme Fluor-o-matic 9000',
    constraints = 'non-negative', validation = 'prior knowledge',
    methods = 'Instrument spectral bias correction: Ex &amp; Em',
    preprocess = 'Scatter region excised (replaced with NaNs)',
    sources = 'freshwater', ecozones = 'Balkash',
    description = 'not a real model', shift = FALSE, scale = TRUE
  )
  if (interactive()) file.show(f2)
  unlink(f2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
