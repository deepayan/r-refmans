<!DOCTYPE html><html lang="en"><head><title>Help for package qfasar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qfasar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_cc_err'><p>Add error to the calibration coefficients</p></a></li>
<li><a href='#adj_diet_fat'><p>Adjust diet composition estimates for prey fat content</p></a></li>
<li><a href='#cc_aug'><p>Calibration coefficient for an augmented signature proportion</p></a></li>
<li><a href='#comp_chi_gamma'><p>Compute gamma parameter of chi-square distance measure</p></a></li>
<li><a href='#diet_obj_func'><p>Diet estimation objective function</p></a></li>
<li><a href='#diet_pool'><p>Pool diet estimates to combined prey types</p></a></li>
<li><a href='#dimac'><p>Diversive magnetic clustering</p></a></li>
<li><a href='#dist_between_2_sigs'><p>Compute the distance between two fatty acid signatures</p></a></li>
<li><a href='#dist_pairs_map'><p>Creats a map of the distance between pairs of fatty acid signatures</p></a></li>
<li><a href='#dist_sigs_2_mean'><p>Distance between fatty acid signatures and their mean</p></a></li>
<li><a href='#dist_sum_pairwise'><p>Distance between pairs of fatty acid signatures</p></a></li>
<li><a href='#est_diet'><p>Estimate predator diet composition</p></a></li>
<li><a href='#find_boot_ss'><p>Find realistic bootstrap sample sizes</p></a></li>
<li><a href='#gof'><p>Goodness-of-fit for modeled predator signatures</p></a></li>
<li><a href='#lopo'><p>Leave-one-prey-out analysis</p></a></li>
<li><a href='#lopo_pool'><p>Pool lopo results to original prey types</p></a></li>
<li><a href='#make_diet_grid'><p>Generate a regular grid of diet compositions</p></a></li>
<li><a href='#make_diet_rand'><p>Generate random diet compositions</p></a></li>
<li><a href='#make_ghost'><p>Make a ghost prey signature</p></a></li>
<li><a href='#make_pred_sigs'><p>Simulate predator signatures</p></a></li>
<li><a href='#make_prey_part'><p>Make prey partition</p></a></li>
<li><a href='#pm_obj_func'><p>Parameterized mean objective function</p></a></li>
<li><a href='#pred_beyond_prey'><p>Identify predator signature proportions beyond range of prey</p></a></li>
<li><a href='#prep_fa'><p>Prepare fatty acid information analysis</p></a></li>
<li><a href='#prep_sig'><p>Prepare fatty acid signature data for analysis</p></a></li>
<li><a href='#sig_rep_zero'><p>Replace invalid fatty acid signature proportions</p></a></li>
<li><a href='#sig_scale'><p>Scale fatty acid signature proportions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantitative Fatty Acid Signature Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of Quantitative Fatty Acid Signature
    Analysis (QFASA) in R.  QFASA is a method of estimating the diet
    composition of predators.  The fundamental unit of information in
    QFASA is a fatty acid signature (signature), which is a vector of
    proportions describing the composition of fatty acids within lipids.
    Signature data from at least one predator and from samples of all
    potential prey types are required.  Calibration coefficients, which
    adjust for the differential metabolism of individual fatty acids by
    predators, are also required. Given those data inputs, a predator
    signature is modeled as a mixture of prey signatures and its diet
    estimate is obtained as the mixture that minimizes a measure of
    distance between the observed and modeled signatures.  A variety of
    estimation options and simulation capabilities are implemented.
    Please refer to the vignette for additional details and references.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp (&ge; 1.16)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-19 21:07:27 UTC; jbromaghin</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-18</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey F. Bromaghin [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey F. Bromaghin &lt;jbromaghin@usgs.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-19 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_cc_err'>Add error to the calibration coefficients</h2><span id='topic+add_cc_err'></span>

<h3>Description</h3>

<p>Bromaghin et al (2016) studied the performance of QFASA estimators when
predator diets were estimated using calibration coefficients that
incorporated a degree of error. <code>add_cc_err</code> implements their method of
adding error to a set of calibration coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cc_err(cc_true, err_bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_cc_err_+3A_cc_true">cc_true</code></td>
<td>
<p>A vector of calibration coefficients, intended to be the object
<code>cc</code> returned by the function <code><a href="#topic+prep_fa">prep_fa</a></code>.</p>
</td></tr>
<tr><td><code id="add_cc_err_+3A_err_bound">err_bound</code></td>
<td>
<p>A proportion strictly greater than 0 and less than 1 used to
control the lower and upper bounds of calibration coefficient error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>cc</dt><dd><p>A numeric vector of calibration coefficients with error
incorporated.</p>
</dd>
<dt>err</dt><dd><p>The mean relative absolute error in the calibration
coefficients.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>One of the major assumptions of QFASA is that the calibration coefficients
are known perfectly. Bromaghin et al. (2016) investigated the robustness of
diet estimators to violations of this assumption. The function
<code>add_cc_err</code> uses the methods of Bromaghin et al. (2016) to add error
to a set of calibration coefficients.
</p>
<p>The argument err_bound is used to compute box constraints for the calibration
coefficients: lower bound equals <code>(1 - err_bound)*cc_true</code> and upper
bound equals <code>(1 + err_bound)*cc_true</code>. A uniformly distributed random
number is generated between the bounds for each calibration coefficient and
the vector of coefficients is scaled so that their sum equals the sum of the
true calibration coefficients. Because only the relative magnitudes of the
calibration coefficients are important in diet estimation, scaling the
coefficients to have a common sum ensures comparability between multiple
sets of coefficients.
</p>
<p>The mean relative absolute difference between the true and error-added
calibration coefficients is computed as a measure of error for the entire
vector.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, G.W. Thiemann, and K.D. Rode. 2016. Assessing
the robustness of quantitative fatty acid signature analysis to assumption
violations. <em>Methods in Ecology and Evolution</em> 7:51-59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_cc_err(cc_true = c(0.75, 1.00, 1.50, 1.15),
           err_bound = 0.25)

</code></pre>

<hr>
<h2 id='adj_diet_fat'>Adjust diet composition estimates for prey fat content</h2><span id='topic+adj_diet_fat'></span>

<h3>Description</h3>

<p>The function <code>est_diet</code> estimates diet composition in terms of the
mass of fatty acids consumed. The function <code>adj_diet_fat</code> uses
estimates of fatty acid mass per prey type to transform estimates of diet
composition in terms of fatty acid mass to another scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_diet_fat(prey_fat, diet_est, diet_var = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj_diet_fat_+3A_prey_fat">prey_fat</code></td>
<td>
<p>A numeric vector of the mean fatty acid mass for each prey
type.</p>
</td></tr>
<tr><td><code id="adj_diet_fat_+3A_diet_est">diet_est</code></td>
<td>
<p>A numeric vector or matrix of the estimated diet
composition(s) of individual predator(s) or predator type(s). Intended to
be the object <code>est_ind</code> or <code>est_mean</code>returned by the function
<code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="adj_diet_fat_+3A_diet_var">diet_var</code></td>
<td>
<p>A numeric matrix or array containing the estimated variance
matrix for the estimated diet(s) of individual predator(s) or predator
type(s). Intended to be the object <code>var_ind</code> or <code>var_mean)</code>
returned by the function <code><a href="#topic+est_diet">est_diet</a></code>. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>diet_est</dt><dd><p>A numeric vector or matrix of the estimated diet
composition of individual predator(s) or predator type(s) in terms of
the scale represented by <code>prey_fat</code>.</p>
</dd>
<dt>diet_var</dt><dd><p>A numeric matrix or array containing the estimated variance
matrix for the estimated diet of individual predator(s) or predator
type(s), in terms of the scale represented by <code>prey_fat</code>.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code>est_diet</code> estimates diet composition in terms of the
mass of fatty acids consumed. Such estimates may be of direct ecological
interest, especially for ecosystems in which lipids are particularly
important. In other cases, one may wish to transform estimates to a different
scale. For example, if the units of <code>prey_fat</code> are (fatty acid mass)/
(animal mass), the function <code>adj_diet_fat</code> returns diet composition
estimates in terms of the relative prey mass consumed. Alternatively, if the
units of <code>prey_fat</code> are (fatty acid mass)/(animal), the function
<code>adj_diet_fat</code> returns diet composition estimates in terms of the
relative numbers of prey animals consumed.
</p>
<p><code>adj_diet_fat</code> uses the fat transformation of Iverson et al. (2004).
Variance matrices are estimated using the delta method (Seber 1982).
</p>
<p>NOTE: values of mass per prey type are treated as known constants without
variance.
</p>


<h3>References</h3>

<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Seber, G.A.F. 1982. The Estimation of Animal Abundance and Related
Parameters, second edition. Macmillan Publishing Co., New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj_diet_fat(prey_fat = c(0.5, 1, 2),
             diet_est = c(0.3, 0.2, 0.5),
             diet_var = matrix(c( 0.030,  0.004, -0.003,
                                 0.004,  0.025, -0.007,
                                -0.003, -0.007,  0.045),
                               nrow = 3, ncol = 3))

adj_diet_fat(prey_fat = c(0.5, 1, 2),
             diet_est = c(0.3, 0.2, 0.5))

</code></pre>

<hr>
<h2 id='cc_aug'>Calibration coefficient for an augmented signature proportion</h2><span id='topic+cc_aug'></span>

<h3>Description</h3>

<p><code>cc_aug</code> computes the optimal calibration coefficient for an
augmented signature proportion (Bromaghin et al. 2016).
If signature augmentation is to be used, the user must call <code>cc_aug</code>
after first calling <code><a href="#topic+prep_sig">prep_sig</a></code> with the prey signature data, in
order to derive a calibration coefficient for the augmented signature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_aug(sig_rep, sig_scale, cc_all, use_fa, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_aug_+3A_sig_rep">sig_rep</code></td>
<td>
<p>A numeric matrix containing fatty acid signatures with
proportions from all fatty acids.  See Details.</p>
</td></tr>
<tr><td><code id="cc_aug_+3A_sig_scale">sig_scale</code></td>
<td>
<p>A numeric matrix containing fatty acid signatures with
proportions from a subset of all fatty acids and an augmented proportion.
See Details.</p>
</td></tr>
<tr><td><code id="cc_aug_+3A_cc_all">cc_all</code></td>
<td>
<p>A numeric vector of calibration coefficients for the fatty
acids in <code>sig_rep</code>.</p>
</td></tr>
<tr><td><code id="cc_aug_+3A_use_fa">use_fa</code></td>
<td>
<p>A logical vector denoting the fatty acids in <code>sig_rep</code>
that are also in <code>sig_scale</code>.</p>
</td></tr>
<tr><td><code id="cc_aug_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="cc_aug_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>cc</dt><dd><p>A numeric vector of calibration coefficients for the augmented
signatures.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Calibration coefficients provide a one-to-one mapping between the prey and
predator spaces (Bromaghin et al. 2015).  However, when using signature
augmentation (Bromaghin et al. 2016), no calibration coefficient is
available for the augmented proportion and the function <code>cc_aug</code> was
developed to remedy that lack.
</p>
<p><code>cc_aug</code> transforms complete prey signatures in <code>sig_rep</code> to the
predator space, censors them using <code>fa</code>, and then augments them.
The subset of calibration coefficients in <code>cc_all</code> corresponding to
<code>fa</code> are combined with a calibration coefficient for the  augmented
proportion, the censored signatures in <code>sig_scale</code> are also transformed to
the predator space, and the distance between the two sets of censored
signatures is computed.  The calibration coefficient for the augmented
proportion is taken as the value that minimizes the distance.  The function
Rsolnp::solnp() is used to minimize the distance.
</p>
<p>The entity passed as the argument <code>fa</code> is intended to be the
corresponding entity returned by a call to <code>prep_fa</code>.  Similarly,
the entities passed as the arguments <code>sig_rep</code> and <code>sig_scale</code>
are intended to be the corresponding entities returned by a call to
<code>prep_sig</code> with data in a prey library.  Consequently, no error
checks are made on these objects.  Please refer to the documentation for
<code><a href="#topic+prep_fa">prep_fa</a></code> and <code><a href="#topic+prep_sig">prep_sig</a></code> for additional details.
</p>
<p>Use of Rsolnp::solnp limits the ability to return any errors from the
function <code>dist_between_2_sigs</code>.  A crash may be caused by passing
invalid values for the arguments <code>dist_meas</code> or <code>gamma</code>.  Please
refer to documentation for the function <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for
additional information about valid values for these arguments.
</p>
<p>Utility and external functions called by <code>cc_aug</code>:
</p>

<ul>
<li> <p><code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>
</p>
</li>
<li><p> Rsolnp::solnp
</p>
</li></ul>



<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc_aug(sig_rep = matrix(c(0.05, 0.10, 0.30, 0.55,
                          0.04, 0.11, 0.29, 0.56,
                          0.10, 0.05, 0.35, 0.50), ncol = 3),
       sig_scale = matrix(c(0.40, 0.50, 0.10,
                            0.45, 0.49, 0.06,
                            0.35, 0.45, 0.20), ncol = 3),
       cc_all = c(0.75, 1.05, 1.86, 0.80),
       use_fa = c(FALSE, FALSE, TRUE, TRUE))

cc_aug(sig_rep = matrix(c(0.05, 0.10, 0.30, 0.55,
                          0.04, 0.11, 0.29, 0.56,
                          0.10, 0.05, 0.35, 0.50), ncol = 3),
       sig_scale = matrix(c(0.40, 0.50, 0.10,
                            0.45, 0.49, 0.06,
                            0.35, 0.45, 0.20), ncol = 3),
       cc_all = c(0.75, 1.05, 1.86, 0.80),
       use_fa = c(FALSE, FALSE, TRUE, TRUE),
       dist_meas = 1)

cc_aug(sig_rep = matrix(c(0.05, 0.10, 0.30, 0.55,
                          0.04, 0.11, 0.29, 0.56,
                          0.10, 0.05, 0.35, 0.50), ncol = 3),
       sig_scale = matrix(c(0.40, 0.50, 0.10,
                            0.45, 0.49, 0.06,
                            0.35, 0.45, 0.20), ncol = 3),
       cc_all = c(0.75, 1.05, 1.86, 0.80),
       use_fa = c(FALSE, FALSE, TRUE, TRUE),
       dist_meas = 2)

cc_aug(sig_rep = matrix(c(0.05, 0.10, 0.30, 0.55,
                          0.04, 0.11, 0.29, 0.56,
                          0.10, 0.05, 0.35, 0.50), ncol = 3),
       sig_scale = matrix(c(0.40, 0.50, 0.10,
                            0.45, 0.49, 0.06,
                            0.35, 0.45, 0.20), ncol = 3),
       cc_all = c(0.75, 1.05, 1.86, 0.80),
       use_fa = c(FALSE, FALSE, TRUE, TRUE),
       dist_meas = 3,
       gamma = 0.25)

cc_aug(sig_rep = matrix(c(0.05, 0.10, 0.30, 0.55,
                          0.04, 0.11, 0.29, 0.56,
                          0.10, 0.05, 0.35, 0.50), ncol = 3),
       sig_scale = matrix(c(0.40, 0.50, 0.10,
                            0.45, 0.49, 0.06,
                            0.35, 0.45, 0.20), ncol = 3),
       cc_all = c(0.75, 1.05, 1.86, 0.80),
       use_fa = c(FALSE, FALSE, TRUE, TRUE),
       dist_meas = 3)

</code></pre>

<hr>
<h2 id='comp_chi_gamma'>Compute gamma parameter of chi-square distance measure</h2><span id='topic+comp_chi_gamma'></span>

<h3>Description</h3>

<p>The function <code>comp_chi_gamma</code> computes the gamma parameter of the
chi-square distance measure using the algorithm of Stewart et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_chi_gamma(sigs, cc, near_zero = 1e-05, min_gamma = 0.05, space = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_chi_gamma_+3A_sigs">sigs</code></td>
<td>
<p>A matrix of fatty acid signatures ready for analysis. Intended to
be the object <code>sig_rep</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code>.</p>
</td></tr>
<tr><td><code id="comp_chi_gamma_+3A_cc">cc</code></td>
<td>
<p>A vector of calibration coefficients, intended to be the object
<code>cc</code> returned by the function <code><a href="#topic+prep_fa">prep_fa</a></code> or
<code>cc_aug</code>.</p>
</td></tr>
<tr><td><code id="comp_chi_gamma_+3A_near_zero">near_zero</code></td>
<td>
<p>A small constant used to terminate the algorithm. Default
value 0.00001.</p>
</td></tr>
<tr><td><code id="comp_chi_gamma_+3A_min_gamma">min_gamma</code></td>
<td>
<p>Smallest desired value of gamma, potentially used to
terminate the algorithm. Default value 0.05.</p>
</td></tr>
<tr><td><code id="comp_chi_gamma_+3A_space">space</code></td>
<td>
<p>An integer indicator of the estimation space to be used. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>gamma</dt><dd><p>The estimated value of gamma.</p>
</dd>
<dt>gamma_vec</dt><dd><p>A numeric vector containing the value of gamma at each
step of the iteration.</p>
</dd>
<dt>prop_vec</dt><dd><p>A numeric vector containing the proportion of all possible
two-element signatures with distance exceeding that of the full
signatures at each step of the iteration. This value is compared to the
argument near_zero.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The chi-square distance involves a power transformation of signature
proportions, with the power parameter being denoted gamma.
<code>comp_chi_gamma</code> implements the algorithm of Stewart et al. (2014) to
find a suitable value of gamma.
</p>
<p>The algorithm is initialized with inv_gamma equal to 1 and gamma is computed
as 1/inv_gamma. The distances between all possible pairs of full signatures
are computed (distances). For each pair of full signatures, the distances
between all possible sub-signatures comprised of only two fatty acid
proportions are computed (sub-distances). The proportion of sub-distances
that exceed the corresponding distance is computed across all possible pairs
of signatures. If that proportion is less than the argument near_zero, the
function returns with gamma equal to 1. Otherwise, the function enters an
iterative phase. At each iteration, inv_gamma is incremented by 1, gamma is
computed as 1/inv_gamma, distances and sub-distances are recomputed, and the
proportion of the sub-distances that exceed their corresponding distance is
recomputed. The algorithm terminates when the proportion is less than the
argument near_zero or the value of gamma is less than min_gamma.
</p>
<p>The argument space must equal 1 or 2 (see <code><a href="#topic+est_diet">est_diet</a></code>). If its
value is 1, the calibration coefficients are used to map the signatures to
the predator space prior to initializing the algorithm.
</p>
<p>As the number of signatures in the library and/or the number of fatty acids
in a signature increases, the number of possible pairs of signatures and the
number of all possible two-proportion sub-signatures increases rapidly.
Consequently, this algorithm may require long run times. However, it only
needs to be run once for any particular library of signatures.
</p>


<h3>References</h3>

<p>Stewart, C., S. Iverson, and C. Field. 2014. Testing for a change in diet
using fatty acid signatures. <em>Environmental and Ecological Statistics</em>
21:775-792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_chi_gamma(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                               0.04, 0.11, 0.29, 0.56,
                               0.10, 0.05, 0.35, 0.50,
                               0.12, 0.03, 0.37, 0.48,
                               0.10, 0.06, 0.35, 0.49,
                               0.05, 0.15, 0.35, 0.45), ncol=6),
               cc = c(0.75, 1.00, 1.50, 0.90),
               near_zero = 0.05,
               min_gamma = 0.01,
               space = 1)

</code></pre>

<hr>
<h2 id='diet_obj_func'>Diet estimation objective function</h2><span id='topic+diet_obj_func'></span>

<h3>Description</h3>

<p>The utility function <code>diet_obj_func</code> computes the distance between an
observed fatty acid signature and a modeled signature computed as a mixture
of mean prey signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diet_obj_func(diet, obs_sig, mean_sigs, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diet_obj_func_+3A_diet">diet</code></td>
<td>
<p>A numeric vector of diet composition.</p>
</td></tr>
<tr><td><code id="diet_obj_func_+3A_obs_sig">obs_sig</code></td>
<td>
<p>A numeric vector containing an observed fatty acid signature.</p>
</td></tr>
<tr><td><code id="diet_obj_func_+3A_mean_sigs">mean_sigs</code></td>
<td>
<p>A numeric matrix of the mean fatty acid signature for each
prey type in the prey library, in column-major format.</p>
</td></tr>
<tr><td><code id="diet_obj_func_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="diet_obj_func_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between the observed and modeled signatures.
</p>


<h3>Details</h3>

<p>This is an internal utility function.  Consequently, to increase execution
speed, no numeric error checking is performed within <code>diet_obj_func</code>.
Rather, error checking is presumed to have occurred at a higher level in the
calling sequence.
</p>
<p>The argument <code>obs_sig</code> is presumed to be a fatty acid signature that has
been prepared for analysis, which is best accomplished by a call to the
function <code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data  frame.  Similarly,
the contents of <code>mean_sig</code> should be mean signatures computed from
signatures that were prepared for analysis by call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code>.
</p>
<p>The argument <code>diet</code> is presumed to contain non-negative proportions that
sum to 1.0.
</p>
<p>The arguments <code>dist_meas</code> and <code>gamma</code> must be compatible with the
function <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>.
</p>
<p>Please refer to the vignette and documentation for the functions
<code><a href="#topic+prep_sig">prep_sig</a></code>, <code><a href="#topic+sig_scale">sig_scale</a></code>, and
<code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for additional details.
</p>
<p><code>diet_obj_func</code> models a predator signature as a mixture of the mean
prey-type signatures, with the diet proportions as the mixture proportions,
returning the distance between the observed and modeled signatures.  The
diet composition of a predator is estimated by minimizing this function with
respect to the <code>diet</code> using the function Rsolnp::solnp.
</p>

<hr>
<h2 id='diet_pool'>Pool diet estimates to combined prey types</h2><span id='topic+diet_pool'></span>

<h3>Description</h3>

<p><code>diet_pool</code> pools estimated diets and variance matrices to a smaller
number of combined prey types. If <code><a href="#topic+est_diet">est_diet</a></code> is used to estimate
predator diet composition using a partitioned prey library
(<code><a href="#topic+make_prey_part">make_prey_part</a></code>), <code>diet_pool</code> pools the partitioned
results back to the original, unpartitioned prey types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diet_pool(rep_grp, est_ind, var_ind = NA, est_mean = NA, var_mean = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diet_pool_+3A_rep_grp">rep_grp</code></td>
<td>
<p>The post-multiplication matrix returned by a call to
<code><a href="#topic+make_prey_part">make_prey_part</a></code> as the object <code>pool_post</code>, or a
user-defined matrix for custom pooling. Each column defines a prey type
to which estimates should be pooled.</p>
</td></tr>
<tr><td><code id="diet_pool_+3A_est_ind">est_ind</code></td>
<td>
<p>A numeric matrix of the estimated diet compositions of
individual predators using a partitioned prey library, intended to be the
object est_ind returned by a call to <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="diet_pool_+3A_var_ind">var_ind</code></td>
<td>
<p>A numeric array containing the estimated variance matrix for
the estimated diet of each predator, intended to be the object
var_ind returned by a call to <code><a href="#topic+est_diet">est_diet</a></code>. Optional.</p>
</td></tr>
<tr><td><code id="diet_pool_+3A_est_mean">est_mean</code></td>
<td>
<p>A numeric matrix containing the estimated mean diet of each
predator type, intended to be the object est_mean returned by a call to
<code><a href="#topic+est_diet">est_diet</a></code>. Optional.</p>
</td></tr>
<tr><td><code id="diet_pool_+3A_var_mean">var_mean</code></td>
<td>
<p>A numeric array containing the estimated variance matrix for
the estimated mean diet of each predator type, intended to be the object
var_mean returned by a call to <code><a href="#topic+est_diet">est_diet</a></code>. Optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements, all of which are organized
on the basis of the original, unpartitioned prey types: </p>

<dl>
<dt>est_ind</dt><dd><p>A numeric matrix of the estimated diet compositions of
individual predators.</p>
</dd>
<dt>var_ind</dt><dd><p>A numeric array containing the estimated variance matrix for
the estimated mean diet of each predator.</p>
</dd>
<dt>est_mean</dt><dd><p>A numeric matrix containing the estimated mean diet of each
predator type.</p>
</dd>
<dt>var_mean</dt><dd><p>A numeric array containing the estimated variance matrix
for the estimated mean diet of each predator type.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code><a href="#topic+dimac">dimac</a></code> explores the prey library for additional
structure with identified prey types. If significant structure is found
within a library, estimating diet composition on the basis of a
partitioned prey library may lead to estimates with less bias and possibly
less variation through reduced prey confounding (Bromaghin et al. 2016). The
function <code><a href="#topic+make_prey_part">make_prey_part</a></code> takes the clustering results returned
by <code><a href="#topic+dimac">dimac</a></code> and user specification of the number of clusters in
which to partition each prey type and returns a partitioned prey library
that is ready for use in diet estimation.
</p>
<p>However, when estimating diet composition using a partitioned prey library
one may still wish to pool partitioned estimates back to the original,
unpartitioned prey types for reporting purposes. That is the purpose of the
function <code>diet_pool</code>.
</p>
<p>NOTE: <code>diet_pool</code> can also be used to pool estimates into a smaller
number of combined prey types for reporting purposes. For example, imagine a
prey library with a large number of prey types.  If subsets of the prey
types have similar ecological function, their signatures may share some
similarities (prey confounding, Bromaghin et al. 2016).  In such a case, one
may wish to estimate diet on the basis of the full prey library, but
subsequently pool the resulting estimates to a smaller number of combined
prey types for reporting purposes (reporting groups, Bromaghin 2008) to
reduce the effect of prey confounding. <code>diet_pool</code> can also be used for
this purpose, though the user would need to manually construct the reporting
group matrix <code>rep_grp</code>.
</p>


<h3>References</h3>

<p>Bromaghin, J.F. 2008. BELS: Backward elimination locus selection for studies
of mixture composition or individual assignment. <em>Molecular Ecology
Resources</em> 8:568-571.
</p>
<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diet_pool(rep_grp = matrix(c(1, 0, 0, 0, 0, 0, 0,
                             0, 1, 0, 0, 0, 0, 0,
                             0, 1, 0, 0, 0, 0, 0,
                             0, 0, 1, 0, 0, 0, 0,
                             0, 0, 0, 1, 0, 0, 0,
                             0, 0, 0, 1, 0, 0, 0,
                             0, 0, 0, 0, 1, 0, 0,
                             0, 0, 0, 0, 0, 1, 0,
                             0, 0, 0, 0, 0, 1, 0,
                             0, 0, 0, 0, 0, 0, 1),
                           nrow = 10, byrow = TRUE),
         est_ind = matrix(c(0.116, 0.315,
                            0.028, 0.073,
                            0.000, 0.000,
                            0.131, 0.120,
                            0.000, 0.000,
                            0.000, 0.000,
                            0.723, 0.452,
                            0.000, 0.000,
                            0.000, 0.000,
                            0.002, 0.040),
                          nrow = 10, byrow = TRUE))


</code></pre>

<hr>
<h2 id='dimac'>Diversive magnetic clustering</h2><span id='topic+dimac'></span>

<h3>Description</h3>

<p>The function <code>dimac</code> implements the <strong>di</strong>visive
<strong>ma</strong>gnetic <strong>c</strong>lustering algorithm to partition fatty acid
signatures into clusters.  The DiMaC algorithm was modified from the diana
algorithm of the package cluster (Maechler et al. 2016).  <code>dimac</code> is
intended to be called by the user, but only after the fatty acid signatures
have been prepared for analysis by calls to the functions
<code><a href="#topic+prep_fa">prep_fa</a></code> and <code><a href="#topic+prep_sig">prep_sig</a></code>.  Consequently, error
checking of the arguments associated with the signatures (<code>sigs</code>,
<code>id</code>, <code>type</code>, and <code>loc</code>) is necessarily limited, and
calling <code>dimac</code> without preceding calls to <code><a href="#topic+prep_fa">prep_fa</a></code>
and <code><a href="#topic+prep_sig">prep_sig</a></code> could return meaningless results.  Please see
Details or the vignette for additional information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimac(sigs, id, type, loc, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimac_+3A_sigs">sigs</code></td>
<td>
<p>A numeric matrix of fatty acid signatures in column-major
format.</p>
</td></tr>
<tr><td><code id="dimac_+3A_id">id</code></td>
<td>
<p>A character vector with a unique sample ID for each signature.</p>
</td></tr>
<tr><td><code id="dimac_+3A_type">type</code></td>
<td>
<p>A character vector of prey or predator type names.</p>
</td></tr>
<tr><td><code id="dimac_+3A_loc">loc</code></td>
<td>
<p>A numeric matrix specifying the location of signatures within
<code>sig</code> for each <code>type</code>.</p>
</td></tr>
<tr><td><code id="dimac_+3A_dist_meas">dist_meas</code></td>
<td>
<p>A integer indicator of the distance measure to use. Default
value 1.</p>
</td></tr>
<tr><td><code id="dimac_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>clust</dt><dd><p>A data frame denoting cluster assignments at each iteration
of the algorithm.</p>
</dd>
<dt>clust_dist</dt><dd><p>A numeric matrix of the summed distance within clusters
at each iteration.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code(0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The signatures in <code>sigs</code> are presumed to be ready for analysis, which
is best accomplished by a call to the function <code>prep_sig</code>.  Please
refer to the documentation for <code><a href="#topic+prep_sig">prep_sig</a></code> and/or the vignette
for additional details.
</p>
<p>The matrix <code>loc</code> provides a mapping of the location of data for each
<code>type</code> within <code>sig</code>.  It must contain a row for each <code>type</code>
and two columns, which contain integers designating the first and last
signature of each <code>type</code> within <code>sigs</code>.  Such a matrix is returned
by the function <code><a href="#topic+prep_sig">prep_sig</a></code>.
</p>
<p>Please refer to the documentation for the function
<code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for information regarding permissable
values for the arguments <code>dist_meas</code> and <code>gamma</code>.
</p>
<p>The DiMaC algorithm is initialized with all signatures in one cluster.  The
first two magnets are chosen as the two signatures having the greatest
distance between them and each non-magnet signature is placed in the cluster
associated with the closest magnet.  The algorithm then enters an iterative
phase.  At each iteration, the cluster with the greatest average distance
between its signatures and the mean signature is identified as the &quot;active&quot;
cluster.  The two signatures within the active cluster having the greatest
distance between them are selected as new magnets.  One of the two new
magnets replaces the original magnet for the active cluster and the second
starts the formation of an additional cluster.  Each non-magnet signature is
placed in the cluster associated with the closest magnet, without regard for
its cluster designation in the preceding iteration.  Consequently, the
algorithm is not simply bifurcating, but rather is much more dynamic and
flexible.  The iterations continue until each signature is in its own
cluster.
</p>
<p>Unfortunately, there is no objective method to determine the most appropriate
number of clusters for each prey or predator <code>type</code>.  Our suggestion is
to examine the distance results and identify any substantial reductions in
distance, which are likely caused by the discovery of structure within that
<code>type</code>, that are followed by a more gradual decrease in distance as the
number of clusters increases.  For diet estimation applications, partitioning
a prey library into more clusters than the number of fatty acids used to
estimate diet may result in estimates that are not unique.  In such a case,
estimates of diet composition need to be pooled into a smaller number of
&quot;reporting groups&quot; (e.g., Bromaghin 2008; Meynier et al. 2010).
</p>
<p>Utility functions called by <code>dimac</code>:
</p>

<ul>
<li> <p><code><a href="#topic+dist_pairs_map">dist_pairs_map</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dist_sigs_2_mean">dist_sigs_2_mean</a></code>
</p>
</li></ul>



<h3>References</h3>

<p>Bromaghin, J.F. 2008. BELS: Backward elimination locus selection for studies
of mixture composition or individual assignment. <em>Molecular Ecology
Resources</em> 8:568-571.
</p>
<p>Maechler, M., P. Rousseeuw, A. Struyf, M. Hubert, and K. Hornik. 2016.
cluster: cluster analysis basics and extensions. R package version 2.0.4.
</p>
<p>Meynier, L., P.C.H. morel, B.L. Chilvers, D.D.S. Mackenzie, and P. Duignan.
2010. Quantitative fatty acid signature analysis on New Zealand sea lions:
model sensitivity and diet estimates. <em>Journal of Mammalogy</em>
91:1484-1495.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimac(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                      0.04, 0.11, 0.29, 0.56,
                      0.10, 0.05, 0.35, 0.50,
                      0.12, 0.03, 0.37, 0.48,
                      0.10, 0.06, 0.35, 0.49,
                      0.05, 0.15, 0.35, 0.45), ncol=6),
      id = c("ID_1", "ID_2", "ID_3", "ID_4", "ID_5", "ID_6"),
      type = c("Type_1", "Type_2", "Type_3"),
      loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
      dist_meas = 1,
      gamma = NA)
dimac(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                      0.04, 0.11, 0.29, 0.56,
                      0.10, 0.05, 0.35, 0.50,
                      0.12, 0.03, 0.37, 0.48,
                      0.10, 0.06, 0.35, 0.49,
                      0.05, 0.15, 0.35, 0.45), ncol=6),
      id = c("ID_1", "ID_2", "ID_3", "ID_4", "ID_5", "ID_6"),
      type = c("Type_1", "Type_2", "Type_3"),
      loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
      dist_meas = 2,
      gamma = NA)
dimac(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                      0.04, 0.11, 0.29, 0.56,
                      0.10, 0.05, 0.35, 0.50,
                      0.12, 0.03, 0.37, 0.48,
                      0.10, 0.06, 0.35, 0.49,
                      0.05, 0.15, 0.35, 0.45), ncol=6),
      id = c("ID_1", "ID_2", "ID_3", "ID_4", "ID_5", "ID_6"),
      type = c("Type_1", "Type_2", "Type_3"),
      loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
      dist_meas = 3,
      gamma = 0.5)
dimac(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                      0.04, 0.11, 0.29, 0.56,
                      0.10, 0.05, 0.35, 0.50,
                      0.12, 0.03, 0.37, 0.48,
                      0.10, 0.06, 0.35, 0.49,
                      0.05, 0.15, 0.35, 0.45), ncol=6),
      id = c("ID_1", "ID_2", "ID_3", "ID_4", "ID_5", "ID_6"),
      type = c("Type_1", "Type_2", "Type_3"),
      loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2))

</code></pre>

<hr>
<h2 id='dist_between_2_sigs'>Compute the distance between two fatty acid signatures</h2><span id='topic+dist_between_2_sigs'></span>

<h3>Description</h3>

<p>The utility function <code>dist_between_2_sigs</code> computes the distance
between two fatty acid signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_between_2_sigs(sig_1, sig_2, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_between_2_sigs_+3A_sig_1">sig_1</code>, <code id="dist_between_2_sigs_+3A_sig_2">sig_2</code></td>
<td>
<p>Equal-length numeric vectors of fatty acid signature
proportions.</p>
</td></tr>
<tr><td><code id="dist_between_2_sigs_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="dist_between_2_sigs_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure.  See
Details. Default value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selected distance between the two signatures.
</p>


<h3>Details</h3>

<p>This is an internal utility function.  The signatures in <code>sig_1</code> and
<code>sig_2</code> are presumed to be ready for analysis, which is best
accomplished by a call to the function <code><a href="#topic+prep_sig">prep_sig</a></code>.  Consequently,
to increase execution speed during simulations, no numeric error checking is
performed.  Please refer to documentation for the function
<code><a href="#topic+prep_sig">prep_sig</a></code> for additional details.
</p>
<p>If the argument <code>dist_meas</code> is not one of the following integers, a
value of NA is returned:
</p>

<ul>
<li><p> dist_meas == 1 yields the Aitchison distance measure (Stewart et al.
2014).  This is the default value.
</p>
</li>
<li><p> dist_meas == 2 yields the Kullback-Leibler distance measure of
Iverson et al. (2004).
</p>
</li>
<li><p> dist_meas == 3 yields the chi-square distance measure (Stewart et
al. 2014).
</p>
</li></ul>

<p>The argument <code>gamma</code> is only used if <code>dist_meas == 3</code> and need not
be passed otherwise.  If <code>dist_meas == 3</code>, <code>gamma</code> must be greater
than 0 and cannot exceed 1.  If <code>dist_meas == 3</code> and a value for
<code>gamma</code> is not passed, a default value of 1 is used.
</p>


<h3>References</h3>

<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Stewart, C., S. Iverson, and C. Field. 2014. Testing for a change in diet
using fatty acid signatures. <em>Environmental and Ecological
Statistics</em> 21:775-792.
</p>

<hr>
<h2 id='dist_pairs_map'>Creats a map of the distance between pairs of fatty acid signatures</h2><span id='topic+dist_pairs_map'></span>

<h3>Description</h3>

<p>The utility function <code>dist_pairs_map</code> computes the distance between all
possible pairs of fatty acid signatures within each type of prey or predator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_pairs_map(sig_data, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_pairs_map_+3A_sig_data">sig_data</code></td>
<td>
<p>A numeric matrix of fatty acid signatures in column-major
format.</p>
</td></tr>
<tr><td><code id="dist_pairs_map_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="dist_pairs_map_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:</p>

<dl>
<dt>n_sig</dt><dd><p>The number of signatures (columns) in <code>sig_data</code>.</p>
</dd>
<dt>sig_1</dt><dd><p>The column of <code>sig_data</code> containing one signature.</p>
</dd>
<dt>sig_2</dt><dd><p>The column of <code>sig_data</code> containing the other
signature.</p>
</dd>
<dt>dist</dt><dd><p>The distance between signatures <code>sig_1</code> and <code>sig_2</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an internal utility function.  The signature data in <code>sig_data</code>
are presumed to be ready for analysis, which is best accomplished by a call
to the function <code>prep_sig</code>.  Consequently, to increase execution
speed during simulations, no numeric error checking is performed.  Please
refer to the documentation for <code><a href="#topic+prep_sig">prep_sig</a></code> for additional
information.
</p>
<p>Please refer to the documentation for <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for
additional information regarding distance measures.
</p>
<p>Storing the distances between all possible pairs of fatty acid signatures
along with the locations of each pair requires less memory than a square
matrix of all possible pairs, while allowing the location of the signatures
to be easily determined.
</p>
<p>Utility functions called by <code>dist_sigs_2_mean</code>:
</p>

<ul>
<li> <p><code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>
</p>
</li></ul>


<hr>
<h2 id='dist_sigs_2_mean'>Distance between fatty acid signatures and their mean</h2><span id='topic+dist_sigs_2_mean'></span>

<h3>Description</h3>

<p>The utility function <code>dist_sigs_2_mean</code> computes the summed and mean
distance between a collection of fatty acid signatures and their mean
signature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_sigs_2_mean(sig_data, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_sigs_2_mean_+3A_sig_data">sig_data</code></td>
<td>
<p>A numeric matrix of fatty acid signatures in column-major
format.</p>
</td></tr>
<tr><td><code id="dist_sigs_2_mean_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="dist_sigs_2_mean_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:</p>

<dl>
<dt>dist_sum</dt><dd><p>The summed distance between each signature and the mean
signature.</p>
</dd>
<dt>dist_mean</dt><dd><p>The mean distance between each signature and the mean
signature.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an internal utility function.  The signature data in <code>sig_data</code>
are presumed to be ready for analysis, which is best accomplished by a call
to the function <code><a href="#topic+prep_sig">prep_sig</a></code>.  Consequently, to increase execution
speed during simulations, no numeric error checking is performed.  Please
refer to the documentation for <code><a href="#topic+prep_sig">prep_sig</a></code> for additional
information.
</p>
<p>Please refer to the documentation for <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for
additional information regarding distance measures.
</p>
<p>Utility functions called by <code>dist_sigs_2_mean</code>:
</p>

<ul>
<li> <p><code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>
</p>
</li></ul>


<hr>
<h2 id='dist_sum_pairwise'>Distance between pairs of fatty acid signatures</h2><span id='topic+dist_sum_pairwise'></span>

<h3>Description</h3>

<p>The utility function <code>dist_sum_pairwise</code> computes the total distance
between all possible pairs of fatty acid signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_sum_pairwise(sig_data, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_sum_pairwise_+3A_sig_data">sig_data</code></td>
<td>
<p>A numeric matrix of fatty acid signatures in column-major
format.</p>
</td></tr>
<tr><td><code id="dist_sum_pairwise_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="dist_sum_pairwise_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The summed distance between all possible pairs of signatures.
</p>


<h3>Details</h3>

<p><code>dist_sum_pairwise</code> is an internal utility function.  The signature
data in <code>sig_data</code> are presumed to be ready for analysis, which is best
accomplished by a call to the function <code>prep_sig</code>.  Consequently, to
increase execution speed during simulations, no numeric error checking of the
signatures is performed.  Please refer to documentation for the function
<code><a href="#topic+prep_sig">prep_sig</a></code> for information regarding signature preparation.
</p>
<p>Please refer to documentation for the function
<code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for additional information regarding the
arguments <code>dist_meas</code> and <code>gamma</code>.
</p>
<p>Utility functions called by <code>dist_sigs_2_mean</code>:
</p>

<ul>
<li> <p><code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>
</p>
</li></ul>


<hr>
<h2 id='est_diet'>Estimate predator diet composition</h2><span id='topic+est_diet'></span>

<h3>Description</h3>

<p><code>est_diet</code> estimates the diet of one or more predators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_diet(
  pred_sigs,
  pred_uniq_types,
  pred_loc,
  prey_sigs,
  prey_uniq_types,
  prey_loc,
  cc,
  space = 1,
  dist_meas = 1,
  gamma = 1,
  ind_boot = 100,
  mean_meth = 1,
  var_meth = 1,
  mean_boot = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_diet_+3A_pred_sigs">pred_sigs</code></td>
<td>
<p>A vector or matrix of predator signatures ready for
analysis, intended to be the object <code>sig_scale</code> returned by a call to
the function <code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data frame.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_pred_uniq_types">pred_uniq_types</code></td>
<td>
<p>A character vector of the unique predator types,
intended to be the object <code>uniq_types</code> returned by a call to the
function <code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data frame.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_pred_loc">pred_loc</code></td>
<td>
<p>A vector or matrix giving the first and last locations of the
signatures of each predator type within <code>pred_sigs</code>, intended to be
the object <code>loc</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data frame.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A matrix of prey signatures ready for analysis, intended to
be the object <code>sig_scale</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame or the object
<code>sig_part</code> returned by <code><a href="#topic+make_prey_part">make_prey_part</a></code>.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_prey_uniq_types">prey_uniq_types</code></td>
<td>
<p>A character vector of the unique prey types, intended
to be the object <code>uniq_types</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_prey_loc">prey_loc</code></td>
<td>
<p>A matrix giving the first and last locations of the
signatures of each prey type within <code>prey_sigs</code>, intended to be the
object <code>loc</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_cc">cc</code></td>
<td>
<p>A vector of calibration coefficients, intended to be a subset of
the object <code>cc</code> returned by the function <code><a href="#topic+prep_fa">prep_fa</a></code> or the
object <code>cc</code> returned by the function <code><a href="#topic+cc_aug">cc_aug</a></code>.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_space">space</code></td>
<td>
<p>An integer indicator of the estimation space to be used. Default
value 1.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to be used.
Default value 1.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_ind_boot">ind_boot</code></td>
<td>
<p>The number of bootstrap replications to use in the estimation
of the variance of an individual predator's diet. Default value 100.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_mean_meth">mean_meth</code></td>
<td>
<p>An integer indicator of the estimation method for mean diet.
Default value 1.</p>
</td></tr>
<tr><td><code id="est_diet_+3A_var_meth">var_meth</code></td>
<td>
<p>An integer indicator of the estimation method for the
variance of mean diet. Default value 1 (bootstrap estimator).</p>
</td></tr>
<tr><td><code id="est_diet_+3A_mean_boot">mean_boot</code></td>
<td>
<p>The number of bootstrap replications to use, needed only if
the bootstrap method of estimating the variance of meat diet is selected
(var_meth == 1). Default value 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>pred_sigs</dt><dd><p>A numeric matrix of predator signatures, potentially
transformed to the prey space.</p>
</dd>
<dt>prey_sigs</dt><dd><p>A numeric matrix of prey signatures, potentially
transformed to the predator space.</p>
</dd>
<dt>mean_sigs</dt><dd><p>A numeric matrix of mean prey-type signatures, potentially
transformed to the predator space.</p>
</dd>
<dt>est_ind</dt><dd><p>A numeric matrix of the estimated diet compositions of
individual predators.</p>
</dd>
<dt>conv</dt><dd><p>A logical vector indicating whether the optimization function
successfully converged.</p>
</dd>
<dt>obj_func</dt><dd><p>A numeric vector of the values of the objective function at
each predator's estimated diet.</p>
</dd>
<dt>mod_sigs</dt><dd><p>A numeric matrix of the modeled signature of each predator
at its estimated diet.</p>
</dd>
<dt>var_ind</dt><dd><p>A numeric array containing the estimated variance matrix for
the estimated mean diet of each predator.</p>
</dd>
<dt>est_mean</dt><dd><p>A numeric matrix containing the estimated mean diet of each
predator type.</p>
</dd>
<dt>conv_mean</dt><dd><p>A logical vector indicating whether the estimated mean
diet of each predator type is based on at least one diet estimate that
converged.</p>
</dd>
<dt>var_mean</dt><dd><p>A numeric array containing the estimated variance matrix
for the estimated mean diet of each predator type.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>est_diet</code> estimates the diet of one or more predators.  It implements a
variety of estimation options, and is therefore one of the more complicated
functions in <code>qfasar</code>.  Please read the following information and the
Diet Estimation section of the vignette for a description of the options.
</p>
<p>The objects passed via the arguments <code>pred_sig</code>, <code>pred_uniq_types</code>,
and <code>pred_loc</code> are presumed to be the objects <code>sig_scale</code>,
<code>uniq_types</code>, and <code>loc</code>, respectively, returned by a call to the
function <code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data frame.
</p>
<p>The objects passed via the arguments <code>prey_sig</code>, <code>prey_uniq_types</code>,
and <code>prey_loc</code> are presumed to be the objects <code>sig_scale</code>,
<code>uniq_types</code>, and <code>loc</code>, respectively, returned by a call to the
function <code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame.
</p>
<p>The object passed via the argument <code>cc</code> is presumed to be a subset of
the object <code>cc</code> returned by a call to the function
<code><a href="#topic+prep_fa">prep_fa</a></code> with the fatty acid suite data frame. Use the logical
vector <code>use</code> returned by <code><a href="#topic+prep_fa">prep_fa</a></code> to subset the list of
all calibration coefficients to the suite to be used for diet estimation.
Alternatively, if signature augmentation is used, pass the object <code>cc</code>
returned by the funtion <code><a href="#topic+cc_aug">cc_aug</a></code>.
</p>
<p>Bromaghin et al. (2015) introduced the terms <strong>prey space</strong> and
<strong>predator space</strong>. These terms refer to the simplexes in which the prey
and predator signatures reside. The spaces differ due to predator metabolism
of ingested prey tissue and the resulting modification of signature
proportions. The calibration coefficients <code>cc</code> provide a one-to-one
mapping or transformation between the prey and predator spaces.  Diet
estimation can be performed in either space. Iverson et al. (2004) used
calibration coefficients to map predator signatures to the prey space, while
Bromaghin et al. (2013) took the opposite approach and mapped prey signatures
to the predator space. Simulation work has not revealed any strong reason
to prefer one space over the other (Bromaghin et al. 2015). However, be aware
that some distance measures will produce different diet estimates in the two
spaces.  Please see the vignette for more information.
</p>
<p>Estimation space options:
</p>

<ul>
<li><p> space == 1 Estimation in the predator space, the default value.
</p>
</li>
<li><p> space == 2 Estimation in the prey space.
</p>
</li></ul>

<p><code>qfasar</code> implements three distance measures that have been used by QFASA
practitioners and researchers: Aitchison, Kullback-Leibler, and chi-square.
The argument <code>gamma</code> is a parameter of the chi-square distance measure
and its value must be strictly greater than 0 and less than or equal to 1.
The distance measure options are:
</p>

<ul>
<li><p> dist_meas == 1 yields the Aitchison distance measure (Stewart et al.
2014).  This is the default value.
</p>
</li>
<li><p> dist_meas == 2 yields the Kullback-Leibler distance measure of
Iverson et al. (2004).
</p>
</li>
<li><p> dist_meas == 3 yields the chi-square distance measure (Stewart et
al. 2014).
</p>
</li></ul>

<p>Please refer to the vignette for additional information about distance
measures.
</p>
<p>The covariance matrix of each estimated diet can be estimated by bootstrap
sampling the prey library.  The signatures of each prey type are
independently sampled with replacement and the predator diet is
estimated with the bootstrapped library.  This is replicated <code>ind_boot</code>
times and the covariance matrix is estimated from the replicated estimates
(Beck et al. 2007, Bromaghin et al. 2015). If you do not wish to estimate
variances for the individual diet estimates, pass a bootstrap sample size
of 0 via the argument ind_boot.
</p>
<p><code>qfasar</code> implements two methods of estimating the mean diet of each
class of predator.  The first is the empirical mean of the estimated diets.
In the second method, called the <strong>parameterized mean</strong> method, the
model is parameterized with a single vector of diet proportions common to all
predators and mean diet is estimated by minimizing the distance between the
signature modeled from the mean diet proportions and each predator's
observed signature, summed over all predators.  The parameterized mean method
has not yet been thoroughly tested and its inclusion is intended to
facilitate future research.  Our limited and unpublished work with the
parameterized mean estimator suggests it may perform well when predator
signatures are homogeneous, but may be more sensitive to the presence of
predators with quite different signatures than the empirical estimator.
The options for <code>mean_meth</code> are:
</p>

<ul>
<li><p> mean_meth == 0 skips estimation of mean diet.
</p>
</li>
<li><p> mean_meth == 1 yields the empirical estimate of mean diet.  This is the
default value.
</p>
</li>
<li><p> mean_meth == 2 yields the parameterized mean estimate of mean diet.
</p>
</li></ul>

<p><code>qfasar</code> implements two methods of estimating the variance of mean diet
estimates, the variance estimator of Beck et al. (2007) and a bootstrap
estimator, controlled by the argument <code>var_meth</code>.  The bootstrap
estimator draws independent samples of each prey type to form a bootstrap
prey library and a random sample of each predator type, with sample sizes
equal to the observed sample sizes.  Mean diet is estimated using the method
indicated by <code>mean_meth</code>.  The argument <code>mean_boot</code> controls the
number of times this is repeated, and the replications are used to estimate
the covariance matrix for each predator type. Unpublished work suggests
that the bootstrap estimator is more reliable. Note that if using the
parameterized-mean estimator for mean diet composition, the Beck estimator
is not appropriate.  The options for
<code>var_meth</code> are:
</p>

<ul>
<li><p> var_meth == 0 skips variance estimation for mean diets.
</p>
</li>
<li><p> var_meth == 1 yields the bootstrap estimator.  This is the default
value.
</p>
</li>
<li><p> var_meth == 2 yields the Beck et al. (2007) estimator.
</p>
</li></ul>

<p>NOTE: The numerical optimization and bootstrap sampling performed by
<code>est_diet</code> are numerically intensive and can cause long runs times.
Patience is advised!  The primary factors causing slow execution are the
number of predator signatures, the number of predator and prey types, and
bootstrap sample sizes.
</p>


<h3>References</h3>

<p>Beck, C.A., S.J. Iverson, W.D. Bowen, and W. Blanchard. 2007. Sex differences
in grey seal diet reflect seasonal variation in foraging behaviour and
reproductive espenditure: evidence from quantitative fatty acid signature
analysis. <em>Journal of Animal Ecology</em> 76:490-502.
</p>
<p>Bromaghin, J.F., M.M. Lance, E.W. Elliott, S.J. Jeffries, A.
Acevedo-Gutierrez, and J.M. Kennish. 2013. New insights into the diets of
harbor seals (<em>Phoca vitulina</em>) in the Salish Sea revealed by analysis
of fatty acid signatures. <em>Fishery Bulletin</em> 111:13-26.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>
<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Stewart, C., S. Iverson, and C. Field. 2014. Testing for a change in diet
using fatty acid signatures. <em>Environmental and Ecological Statistics</em>
21:775-792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est_diet(pred_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                              0.04, 0.11, 0.29, 0.56,
                              0.10, 0.06, 0.35, 0.49,
                              0.05, 0.15, 0.35, 0.45), ncol=4),
         pred_uniq_types = c("Pred_1", "Pred_2"),
         pred_loc = matrix(c(1, 3, 2, 4), ncol=2),
         prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                              0.05, 0.09, 0.30, 0.56,
                              0.03, 0.10, 0.30, 0.57,
                              0.08, 0.07, 0.30, 0.55,
                              0.09, 0.05, 0.33, 0.53,
                              0.09, 0.06, 0.34, 0.51,
                              0.09, 0.07, 0.34, 0.50,
                              0.08, 0.11, 0.35, 0.46,
                              0.06, 0.14, 0.36, 0.44), ncol=9),
         prey_uniq_types = c("Prey_1", "Prey_2", "Prey_3"),
         prey_loc = matrix(c(1, 4, 7, 3, 6, 9), ncol=2),
         cc = c(0.75, 1.00, 1.50, 1.15),
         space = 1, dist_meas = 1, ind_boot = 2,
         mean_meth = 0)

</code></pre>

<hr>
<h2 id='find_boot_ss'>Find realistic bootstrap sample sizes</h2><span id='topic+find_boot_ss'></span>

<h3>Description</h3>

<p>In QFASA simulation studies, predator signatures are often simulated by
bootstrap resampling prey signature data. <code><a href="#topic+find_boot_ss">find_boot_ss</a></code> finds
bootstrap sample sizes for each prey type that produce simulated predator
signatures with realistic levels of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_boot_ss(pred_sigs, pred_diets, prey_sigs, prey_loc, n_pred_boot = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_boot_ss_+3A_pred_sigs">pred_sigs</code></td>
<td>
<p>A vector or matrix of predator signatures, intended to be
the object <code>pred_sigs</code> returned by a call to the function
<code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="find_boot_ss_+3A_pred_diets">pred_diets</code></td>
<td>
<p>A numeric matrix of the estimated diet compositions of
individual predators, intended to be the object <code>est_ind</code> returned by
a call to <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="find_boot_ss_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A matrix of prey signatures, intended to be the object
<code>prey_sigs</code> returned by a call to the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="find_boot_ss_+3A_prey_loc">prey_loc</code></td>
<td>
<p>A matrix giving the first and last locations of the
signatures of each prey type within <code>prey_sigs</code>, intended to be the
object <code>loc</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame, or by a call to the
function <code><a href="#topic+make_prey_part">make_prey_part</a></code> if a partitioned prey library was
used for diet estimation.</p>
</td></tr>
<tr><td><code id="find_boot_ss_+3A_n_pred_boot">n_pred_boot</code></td>
<td>
<p>An integer designating the number of predator signatures
to bootstrap. See Details. Default value 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>var_diet</dt><dd><p>A numeric vector of the variance between the estimated
diets of all possible pairs of predators, sorted in increasing order.</p>
</dd>
<dt>var_sig</dt><dd><p>A numeric vector of the variance between the signatures
of all possible pairs of predators, sorted consistently with
<code>var_diet</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>var_sig_smooth</dt><dd><p>A loess-smoothed version of var_sig.</p>
</dd>
<dt>mod_sig_var</dt><dd><p>A numeric vector of the modeled variance between
bootstrapped predator signatures at each iteration of the algorithm.</p>
</dd>
<dt>var_target</dt><dd><p>The target level of variance between bootstrapped
predator signatures.</p>
</dd>
<dt>boot_ss</dt><dd><p>An integer vector of bootstrap sample sizes for each prey
type.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>QFASA simulation studies may require the generation of predator signatures
given a specified diet, against which estimates of diet composition can then
be compared (e.g., Bromaghin et al. 2015). Given a specified diet, a
bootstrap sample of each prey type is drawn and mean prey-type signatures
are computed.  A predator signature is then generated by multiplying the mean
bootstrapped prey signatures by the diet proportions.
</p>
<p>Although authors often fail to report the bootstrap sample sizes used for
each prey type when describing simulations (e.g., Haynes et al. 2015;
Thiemann et al. 2008; Wang et al. 2010), they are subjectively selected
(e.g., Iverson et al. 2004; Bromaghin et al. 2015). However, Bromaghin et al.
(2016) found that bootstrap sample sizes strongly influence both the bias and
the variance of diet composition estimates in simulation studies.
Consequently, the selection of bootstrap sample sizes is an important aspect
of simulation design.
</p>
<p>Bromaghin (2015) presented an objective method of establishing a bootstrap
sample size for each prey type that produces simulated predator signatures
having a realistic level of between-signature variation.  The function
<code><a href="#topic+find_boot_ss">find_boot_ss</a></code> implements the algorithm of Bromaghin (2015). A
brief summary of the algorithm, sufficient to understand the objects returned
by <code>find_boot_ss</code>, follows below. Please refer to Bromaghin (2015) for
additional details.
</p>
<p>The concept underlying the algorithm is that the variation in predator
signatures can be partitioned into variation due to differences in diet and
variation due to prey animals consumed given diet. Consequently, a realistic
level of variation between signatures for predators sharing the same diet is
approximated from the empirical relationship between a measure of variation
between pairs of predator signatures <code>var_sig</code> and a measure of
variation between the estimated diets <code>var_diets</code> of the same predator
pairs. As the variance in diets approaches zero, the predators are
effectively eating the same diet and variation in their signatures therefore
approaches the level of variation due to prey selection only.
<code><a href="#topic+find_boot_ss">find_boot_ss</a></code> models the relationship between <code>var_diet</code>
and <code>var_sig</code> using a loess smooth, and the modeled signature variance
<code>var_sig_smooth</code> for the pair of predators whose value of
<code>var_diet</code> is smallest is taken as the target level of variation for
predator signatures.
</p>
<p>The algorithm is initialized with a sample size of 1 from each prey type.
A sample of <code>n_pred_boot</code> predator signatures is generated using those
sample sizes and the measure of variance among the signatures is computed.
If the variance measure exceeds the target level, the prey type contributing
most to the variance measure is identified and its sample size is increased
by 1. The algorithm then iterates, increasing the sample size by one at each
iteration, until the measure of variation is less than the target level. The
level of variation at each iteration and the target level of variation are
returned in the objects <code>mod_sig_var</code> and <code>var_terget</code>,
respectively.
</p>
<p>The argument <code>n_boot_pred</code> should be large enough to return an estimate
of the variance measure that itself has low variance, so that the algorithm
returns numerically stable results. We suspect that the default value of 1000
errs on the side of caution.
</p>
<p>NOTE: Because <code>find_boot_ss</code> is intended to operate on the predator and
prey signatures returned by a call to the function <code><a href="#topic+est_diet">est_diet</a></code>,
<code>find_boot_ss</code> can be based on diet estimates obtained in either the
predator or prey space, using an original or partitioned prey library.
However, it is imperative that the arguments are compatible.
</p>


<h3>References</h3>

<p>Bromaghin, J.F. 2015. Simulating realistic predator signatures in
quantitative fatty acid signature analysis. <em>Ecological Informatics</em>
30:68-71.
</p>
<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty acid
signature proportions sum to 1 for diet estimation? <em>Ecological
Research</em> 31:597-606.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>
<p>Haynes, T.B., J.A. Schmutz, J.F. Bromaghin, S.J. Iverson, V.M. Padula, and
A.E. Rosenberger. 2015. Diet of yellow-billed loons (<em>Gavia adamsii</em>)
in Arctic lakes during the nesting season inferred from fatty acid
analysis. <em>Polar Biology</em> 38:1239-1247.
</p>
<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Thiemann, G.W., S.J. Iverson, and I. Stirling. 2008. Polar bear diets and
Arctic marine food webs: insights from fatty acid analysis.
<em>Ecological Monographs</em> 78:591-613.
</p>
<p>Wang, S.W., T.E. Hollmen, and S.J. Iverson. 2010. Validating quantitative
fatty acid signature analysis to estimate diets of spectacled and Stellers
eiders (<em>Somateria fischeri</em> and <em>Polysticta stelleri</em>).
<em>Journal of Comparative Physiology B</em> 180:125-139.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_boot_ss(pred_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                                  0.04, 0.11, 0.29, 0.56,
                                  0.10, 0.05, 0.35, 0.50,
                                  0.12, 0.03, 0.37, 0.48,
                                  0.10, 0.06, 0.35, 0.49,
                                  0.05, 0.15, 0.35, 0.45), ncol = 6),
             pred_diets = matrix(c(0.33, 0.34, 0.33,
                                   0.10, 0.80, 0.10,
                                   0.35, 0.50, 0.15,
                                   0.20, 0.35, 0.45,
                                   0.20, 0.45, 0.35,
                                   0.15, 0.65, 0.20), ncol = 6),
             prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                                  0.05, 0.09, 0.30, 0.56,
                                  0.03, 0.10, 0.30, 0.57,
                                  0.08, 0.07, 0.30, 0.55,
                                  0.09, 0.05, 0.33, 0.53,
                                  0.09, 0.06, 0.34, 0.51,
                                  0.09, 0.07, 0.34, 0.50,
                                  0.08, 0.11, 0.35, 0.46,
                                  0.06, 0.14, 0.36, 0.44), ncol = 9),
             prey_loc = matrix(c(1, 4, 7, 3, 6, 9), ncol=2),
             n_pred_boot = 500)

find_boot_ss(pred_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                                  0.04, 0.11, 0.29, 0.56,
                                  0.10, 0.05, 0.35, 0.50,
                                  0.12, 0.03, 0.37, 0.48,
                                  0.10, 0.06, 0.35, 0.49,
                                  0.05, 0.15, 0.35, 0.45), ncol = 6),
             pred_diets = matrix(c(0.33, 0.34, 0.33,
                                   0.10, 0.80, 0.10,
                                   0.35, 0.50, 0.15,
                                   0.20, 0.35, 0.45,
                                   0.20, 0.45, 0.35,
                                   0.15, 0.65, 0.20), ncol = 6),
             prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                                  0.05, 0.09, 0.30, 0.56,
                                  0.03, 0.10, 0.30, 0.57,
                                  0.08, 0.07, 0.30, 0.55,
                                  0.09, 0.05, 0.33, 0.53,
                                  0.09, 0.06, 0.34, 0.51,
                                  0.09, 0.07, 0.34, 0.50,
                                  0.08, 0.11, 0.35, 0.46,
                                  0.06, 0.14, 0.36, 0.44), ncol = 9),
             prey_loc = matrix(c(1, 4, 7, 3, 6, 9), ncol=2))

</code></pre>

<hr>
<h2 id='gof'>Goodness-of-fit for modeled predator signatures</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>The function <code>gof</code> uses estimated diet compositions and bootstrap
resampling of the prey library to construct a statistic that may
conservatively indicate predator fatty acid signatures that were not
accurately modeled during diet estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(
  prey_sigs,
  prey_loc,
  mean_sigs,
  diet_est,
  conv,
  obj_func,
  dist_meas = 1,
  gamma = 1,
  boot_gof = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A matrix of prey signatures in the optimization space used
for diet estimation. Intended to be the object <code>prey_sigs</code> returned by
the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_prey_loc">prey_loc</code></td>
<td>
<p>A matrix giving the first and last locations of the
signatures of each prey type within <code>prey_sigs</code>. Intended to be the
object <code>loc</code> returned by the function <code><a href="#topic+prep_sig">prep_sig</a></code> if diets
were estimated using an unpartitioned prey library or
<code><a href="#topic+make_prey_part">make_prey_part</a></code> if diets were estimated using a partitioned
library.</p>
</td></tr>
<tr><td><code id="gof_+3A_mean_sigs">mean_sigs</code></td>
<td>
<p>A numeric matrix of mean prey-type signatures in the
optimization space used for diet estimation. Intended to be the object
<code>mean_sigs</code> returned by the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_diet_est">diet_est</code></td>
<td>
<p>A numeric matrix of estimated diet compositions. Intended to
be the object <code>est_ind</code> returned by the function
<code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_conv">conv</code></td>
<td>
<p>A logical vector indicating whether the optimization function
successfully converged during diet estimation. Intended to be the object
<code>conv</code> returned by the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_obj_func">obj_func</code></td>
<td>
<p>A numeric vector of the value of the minimized objective
function for each predator. Intended to be the object <code>obj_func</code>
returned by the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure used for diet
estimation. Default value 1.</p>
</td></tr>
<tr><td><code id="gof_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
<tr><td><code id="gof_+3A_boot_gof">boot_gof</code></td>
<td>
<p>The number of bootstrap replications to use. Default value 500.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>gof_ss</dt><dd><p>The number of diet estimates that converged for each
predator, therefore producing a simulated value of the objective
function.</p>
</dd>
<dt>p_val</dt><dd><p>The proportion of the simulated objective function values that
exceeded the value produced during diet estimation.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Diet estimation involves modeling an observed predator fatty acid signature
as a mixture of prey signatures. However, methods to assess how well predator
signatures are modeled have received little attention in the literature
(but see Bromaghin et al. 2015).
</p>
<p>One byproduct of diet estimation is the value of the distance measure that is
minimized during diet estimation (<code><a href="#topic+est_diet">est_diet</a></code>), called the
objective function. If a predator signature is accurately modeled, the
value of the objective function will be relatively small. Conversely, the
more poorly the signature is approximated, the larger the objective function
will tend to be. However, what value of the objective function to use as a
warning flag for a potentially poor fit is not clear.
</p>
<p>The function <code>gof</code> represents one attempt to answer this question. The
algorithm is based on the following logic. First, we assume that a predator
consumes the mixture of prey specified by its estimated diet composition.
Given that assumption, the expected value of the objective function is, in
a sense, fixed (Bromaghin 2015). Large values of the objective function are
then most likely to occur when variation in a predator signature, which
results from the selection of individual prey within prey types, is
maximized. Within the framework of simulating predator signatures, variation
in the signatures is maximized when the bootstrap sample sizes of the prey
signatures used to construct a predator signature are minimized
(Bromaghin et al. 2016).
</p>
<p>Implementing the above logic, <code>gof</code> randomly samples a single prey
signature from each prey type and weights the resulting signatures with a
predator's estimated diet composition to construct a modeled signature. The
modeled signature is then used to estimate diet. If the optimization function
converges, the value of the objective function obtained with the modeled
signature is compared to the value of the objective function obtained while
estimating diet with the observed signature (argument <code>obj_func</code>. This
is repeated <code>boot_gof</code> times and the proportion of the simulated
objective function values that exceed the observed objective function value
is computed. <code>gof</code> therefore constructs a statistic similar to a
p-value, with small values being suggestive of a predator signature that
was not closely approximated during diet estimation.
</p>
<p>NOTE: the method implemented in <code>gof</code> is at this point only an idea
whose performance has not been explored. It has been included in
<code>qfasar</code> to support future research on this topic.
</p>


<h3>References</h3>

<p>Bromaghin, J.F. 2015. Simulating realistic predator signatures in
quantitative fatty acid signature analysis. Ecological Informatics
30:68-71.
</p>
<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty acid
signature proportions sum to 1 for diet estimation? Ecological Research
31:597-606.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gof(prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                         0.05, 0.09, 0.30, 0.56,
                         0.03, 0.10, 0.30, 0.57,
                         0.08, 0.07, 0.30, 0.55,
                         0.09, 0.05, 0.33, 0.53,
                         0.09, 0.06, 0.34, 0.51,
                         0.09, 0.07, 0.34, 0.50,
                         0.08, 0.11, 0.35, 0.46,
                         0.06, 0.14, 0.36, 0.44), ncol = 9),
    prey_loc = matrix(c(1, 4, 7, 3, 6, 9), ncol=2),
    mean_sigs = matrix(c(0.047, 0.093, 0.303, 0.557,
                         0.087, 0.050, 0.323, 0.530,
                         0.077, 0.106, 0.350, 0.467), ncol = 3),
    diet_est = matrix(c(0.394, 0.356, 0.250,
                        0.336, 0.365, 0.299), ncol = 2),
    conv = c(TRUE, TRUE),
    obj_func = c(1.13, 2.24),
    dist_meas = 1,
    boot_gof = 10)


</code></pre>

<hr>
<h2 id='lopo'>Leave-one-prey-out analysis</h2><span id='topic+lopo'></span>

<h3>Description</h3>

<p>The function <code>lopo</code> evaluates the distinctiveness of a prey library by
performing a leave-one-prey-out analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lopo(sigs, type, uniq_types, type_ss, loc, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lopo_+3A_sigs">sigs</code></td>
<td>
<p>A numeric matrix of fatty acid signatures in column-major
format.</p>
</td></tr>
<tr><td><code id="lopo_+3A_type">type</code></td>
<td>
<p>A character vector of prey or predator type names.</p>
</td></tr>
<tr><td><code id="lopo_+3A_uniq_types">uniq_types</code></td>
<td>
<p>A character vector of the unique types, sorted
alphanumerically.</p>
</td></tr>
<tr><td><code id="lopo_+3A_type_ss">type_ss</code></td>
<td>
<p>The number of signatures (sample size) for each unique
<code>type</code>.</p>
</td></tr>
<tr><td><code id="lopo_+3A_loc">loc</code></td>
<td>
<p>A numeric matrix specifying the location of signatures within
<code>sigs</code> for each <code>uniq_types</code>.</p>
</td></tr>
<tr><td><code id="lopo_+3A_dist_meas">dist_meas</code></td>
<td>
<p>A integer indicator of the distance measure to use. Default
value 1.</p>
</td></tr>
<tr><td><code id="lopo_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>est</dt><dd><p>A square matrix containing the mean distribution of estimates
among all prey types, by prey-type.</p>
</dd>
<dt>mean_correct</dt><dd><p>The mean proportion correctly estimated across prey
types, unweighted by prey-type sample sizes.</p>
</dd>
<dt>total_correct</dt><dd><p>The proportion of all signatures correctly estimated.</p>
</dd>
<dt>n_conv</dt><dd><p>An integer vector containing the number of estimates that
converged.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The object passed as the argument <code>sigs</code> is intended to be the signature
object returned by <code><a href="#topic+sig_scale">sig_scale</a></code> or, if the prey library has been
partitioned, by <code><a href="#topic+make_prey_part">make_prey_part</a></code>.
</p>
<p>The objects passed as the arguments <code>type</code>, <code>uniq_types</code>,
<code>type_ss</code>, and <code>loc</code> are intended to be the corresponding objects
returned by <code><a href="#topic+prep_sig">prep_sig</a></code> or, if the prey library has been
partitioned, by <code><a href="#topic+make_prey_part">make_prey_part</a></code>.
</p>
<p>The arguments <code>dist_meas</code> and <code>gamma</code> must be compatible with the
function <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>.
</p>
<p><code>lopo</code> performs a leave-one-prey-out analysis with a prey library and
defined prey types (Bromaghin et al. 2016b).  Each signature is
temporarily removed from the library, the mean prey-type signature is
recomputed, and the &quot;diet&quot; of the removed signature is estimated, after which
the removed signature is returned to the library.  This is done for each
signature in turn.  The mean estimate for each prey type is returned as a
row of <code>est</code>.  Perfect estimation would result in the square matrix
<code>est</code> having 1.0 along its diagonal and 0.0 in all off-diagonal
positions.  Large off-diagonal elements are indicative of confounding, or
similarity, between the corresponding prey types.  The returned object
<code>mean_correct</code> is the mean of the diagonal elements of <code>est</code>,
while the returned object <code>total_correct</code> is the mean computed over all
signatures in the prey library.
</p>
<p>Note: the statistics are computed based on the estimates that successfully
converge (<code>n_conv</code>) and prey types that only have a sample size of 1 are
skipped.
</p>
<p>Because of the numerical optimization involved in a leave-one-prey-out
analysis, <code>lopo</code> can take a few minutes to run with a large prey
library.
</p>
<p>The statistics computed by <code>lopo</code> are one measure of the distinctiveness
of prey types within a prey library.  However, it is important to be aware
that such statistics are not necessarily informative of the ability of QFASA
to accurately estimate predator diets, as Bromaghin et al. (2015, 2016a,
2016b) found that QFASA performance depends strongly on the interaction
between characteristics of a prey library, the specific diet of a predator,
and the accuracy of the calibration coefficients.  Consequently, the user is
warned not to misinterpret or misrepresent these statistics.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016b. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>
<p>Bromaghin, J.F., S.M. Budge, G.W. Thiemann, and K.D. Rode. 2016b. Assessing
the robustness of quantitative fatty acid signature analysis to assumption
violations. <em>Methods in Ecology and Evolution</em> 7:51-59.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lopo(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                     0.04, 0.11, 0.29, 0.56,
                     0.10, 0.05, 0.35, 0.50,
                     0.12, 0.03, 0.37, 0.48,
                     0.10, 0.06, 0.35, 0.49,
                     0.05, 0.15, 0.35, 0.45), ncol=6),
     type = c("Type_1", "Type_1", "Type_2", "Type_2", "Type_3", "Type_3"),
     uniq_types = c("Type_1", "Type_2", "Type_3"),
     type_ss &lt;- c(2, 2, 2),
     loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
     dist_meas = 1)

lopo(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                     0.04, 0.11, 0.29, 0.56,
                     0.10, 0.05, 0.35, 0.50,
                     0.12, 0.03, 0.37, 0.48,
                     0.10, 0.06, 0.35, 0.49,
                     0.05, 0.15, 0.35, 0.45), ncol=6),
     type = c("Type_1", "Type_1", "Type_2", "Type_2", "Type_3", "Type_3"),
     uniq_types = c("Type_1", "Type_2", "Type_3"),
     type_ss &lt;- c(2, 2, 2),
     loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
     dist_meas = 2)

lopo(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                     0.04, 0.11, 0.29, 0.56,
                     0.10, 0.05, 0.35, 0.50,
                     0.12, 0.03, 0.37, 0.48,
                     0.10, 0.06, 0.35, 0.49,
                     0.05, 0.15, 0.35, 0.45), ncol=6),
     type = c("Type_1", "Type_1", "Type_2", "Type_2", "Type_3", "Type_3"),
     uniq_types = c("Type_1", "Type_2", "Type_3"),
     type_ss &lt;- c(2, 2, 2),
     loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
     dist_meas = 3,
     gamma = 0.25)

lopo(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                     0.04, 0.11, 0.29, 0.56,
                     0.10, 0.05, 0.35, 0.50,
                     0.12, 0.03, 0.37, 0.48,
                     0.10, 0.06, 0.35, 0.49,
                     0.05, 0.15, 0.35, 0.45), ncol=6),
     type = c("Type_1", "Type_1", "Type_2", "Type_2", "Type_3", "Type_3"),
     uniq_types = c("Type_1", "Type_2", "Type_3"),
     type_ss &lt;- c(2, 2, 2),
     loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
     dist_meas = 3)

lopo(sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                     0.04, 0.11, 0.29, 0.56,
                     0.10, 0.05, 0.35, 0.50,
                     0.12, 0.03, 0.37, 0.48,
                     0.10, 0.06, 0.35, 0.49,
                     0.05, 0.15, 0.35, 0.45), ncol=6),
     type = c("Type_1", "Type_1", "Type_2", "Type_2", "Type_3", "Type_3"),
     uniq_types = c("Type_1", "Type_2", "Type_3"),
     type_ss &lt;- c(2, 2, 2),
     loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2))

</code></pre>

<hr>
<h2 id='lopo_pool'>Pool lopo results to original prey types</h2><span id='topic+lopo_pool'></span>

<h3>Description</h3>

<p>If <code><a href="#topic+lopo">lopo</a></code> is used to perform a leave-one-prey-out analysis with
a partitioned prey library (<code><a href="#topic+make_prey_part">make_prey_part</a></code>), <code>lopo_pool</code>
pools the partitioned results back to the original unpartitioned prey types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lopo_pool(est, n_conv, type_ss, pre, post)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lopo_pool_+3A_est">est</code></td>
<td>
<p>The estimation matrix of a leave-one-prey-out analysis performed
by the function <code><a href="#topic+lopo">lopo</a></code>, returned as the <code>est</code> object.</p>
</td></tr>
<tr><td><code id="lopo_pool_+3A_n_conv">n_conv</code></td>
<td>
<p>An integer vector denoting the number of signature estimates in
the partitioned prey types that converged, returned by a call to
<code><a href="#topic+lopo">lopo</a></code> as the <code>n_conv</code> object.</p>
</td></tr>
<tr><td><code id="lopo_pool_+3A_type_ss">type_ss</code></td>
<td>
<p>An integer vector with the number of signatures (sample size)
in each of the partitioned prey types, returned by a call to
<code><a href="#topic+make_prey_part">make_prey_part</a></code> as the <code>type_ss</code> object.</p>
</td></tr>
<tr><td><code id="lopo_pool_+3A_pre">pre</code></td>
<td>
<p>The pre-multiplication matrix returned by a call to
<code><a href="#topic+make_prey_part">make_prey_part</a></code> as the <code>pool_pre</code> object.</p>
</td></tr>
<tr><td><code id="lopo_pool_+3A_post">post</code></td>
<td>
<p>The post-multiplication matrix returned by a call to
<code><a href="#topic+make_prey_part">make_prey_part</a></code> as the <code>pool_post</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements, all of which are organized
on the basis of the original unpartitioned prey types: </p>

<dl>
<dt>est</dt><dd><p>A square matrix containing the mean distribution of
leave-one-prey-out estimates among all prey types.</p>
</dd>
<dt>mean_correct</dt><dd><p>The mean proportion correctly estimated across prey
types, unweighted by prey-type sample sizes.</p>
</dd>
<dt>total_correct</dt><dd><p>The proportion of all signatures correctly estimated.</p>
</dd>
<dt>n_conv</dt><dd><p>An integer vector containing the number of estimates that
converged.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The statistics computed by <code><a href="#topic+lopo">lopo</a></code> and <code>lopo_pool</code> are one
measure of the distinctiveness of prey types within a prey library.  However,
it is important to be aware that such statistics are not necessarily
informative of the ability of QFASA to accurately estimate predator diets, as
Bromaghin et al. (2015, 2016a, 2016b) found that QFASA performance depends
strongly on the interaction between characteristics of a prey library, the
specific diet of a predator, and the accuracy of the calibration
coefficients.  Consequently, the user is warned not to misinterpret or
misrepresent these statistics.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016b. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>
<p>Bromaghin, J.F., S.M. Budge, G.W. Thiemann, and K.D. Rode. 2016a. Assessing
the robustness of quantitative fatty acid signature analysis to assumption
violations. <em>Methods in Ecology and Evolution</em> 7:51-59.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lopo_pool(est = matrix(c(0.90, 0.05, 0.30, 0.02,
                         0.04, 0.84, 0.09, 0.03,
                         0.02, 0.06, 0.35, 0.57,
                         0.05, 0.10, 0.15, 0.70), nrow = 4, byrow = TRUE),
          n_conv = c(2, 8, 8, 11),
          type_ss = c(2, 8, 8, 12),
          pre = matrix(c(0.2, 0.8, 0.0, 0.0,
                         0.0, 0.0, 0.4, 0.6), nrow = 2, byrow = TRUE),
          post = matrix(c(1, 1, 0, 0,
                          0, 0, 1, 1), ncol = 2)
          )

</code></pre>

<hr>
<h2 id='make_diet_grid'>Generate a regular grid of diet compositions</h2><span id='topic+make_diet_grid'></span>

<h3>Description</h3>

<p>The function <code>make_diet_grid</code> generates a systematic grid of
regularly-spaced diet compositions with a user-specified resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_diet_grid(uniq_types, inv_inc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_diet_grid_+3A_uniq_types">uniq_types</code></td>
<td>
<p>A factor of unique prey-type names.</p>
</td></tr>
<tr><td><code id="make_diet_grid_+3A_inv_inc">inv_inc</code></td>
<td>
<p>The integer inverse of the resolution between consecutive
diet compositions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>diet_grid</dt><dd><p>A numeric matrix of grid diet compositions, in
column-major format.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code>make_diet_grid</code> generates a systematic grid of
regularly-spaced diet compositions throughout the space of all possible
diets for a given number of prey types. Such a diet composition grid may be
useful in some simulation studies of estimator performance (e.g., Bromaghin
et al. 2016). Given a diet composition, predator fatty acid signatures can be
generated using the function <code><a href="#topic+make_pred_sigs">make_pred_sigs</a></code>. The diets of such
simulated predators can then be estimated, and the resulting estimates can be
compared to the known diet composition to evaluate bias, variance, and
perhaps other properties.
</p>
<p>The algorithm starts with a diet proportion of 1.0 assigned to the first prey
type, and therefore 0.0 for the other prey types. The algorithm then begins
an iterative loop in which an increment of diet proportion is repeatedly
shifted to the other prey types, stopping when the last prey type has a diet
proportion of 1.0. The user controls the resolution of the grid by specifying
the integer inverse of the desired diet increment.  For example, an inverse
increment of 10 would produce diet compositions with proportions shifted by
an increment of 0.1. See Bromaghin et al. (2016) for a small example with
three prey types and a diet increment of 0.25.  However, note that unlike
Bromaghin et al. (2016), <code>make_diet_grid</code> retains diet compositions
comprised of a single prey type.
</p>
<p>It is critical that the prey-type names match those in the prey library. The
easiest way to ensure this happens is to pass the object uniq_types returned
a call to the function <code><a href="#topic+prep_sig">prep_sig</a></code> as the uniq_types argument.
Alternatively, and more risky, a vector of unique prey names can be created
using the concatenate function and cast as a factor, i.e.,
uniq_types &lt;- as.factor(c(&quot;Prey_1&quot;, &quot;Prey_2&quot;, ..., &quot;Prey_P)).
</p>
<p>NOTE: The number of possible diets grows quickly as the number of prey types
increases and the diet increment decreases, and may exceed memory limits.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty acid
signature proportions sum to 1 for diet estimation? Ecological Research
31:597-606.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_diet_grid(uniq_types = as.factor(c("Bearded",
                                        "Beluga",
                                        "Bowhead",
                                        "Ribbon",
                                        "Ringed",
                                        "Spotted",
                                        "Walrus")),
               inv_inc = 10)

</code></pre>

<hr>
<h2 id='make_diet_rand'>Generate random diet compositions</h2><span id='topic+make_diet_rand'></span>

<h3>Description</h3>

<p>The function <code>make_diet_rand</code> generates a user-specified number of
random diet compositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_diet_rand(uniq_types, n_diet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_diet_rand_+3A_uniq_types">uniq_types</code></td>
<td>
<p>A factor of unique prey-type names.</p>
</td></tr>
<tr><td><code id="make_diet_rand_+3A_n_diet">n_diet</code></td>
<td>
<p>The integer number of diet compositions to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>diet_rand</dt><dd><p>A numeric matrix of random diet compositions, in
column-major format.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code>make_diet_rand</code> generates a specified number of random
diet compositions to support simulation-based research of the performance
of QFASA diet estimation procedures. Given a diet composition, predator
fatty acid signatures can be generated using the
function <code><a href="#topic+make_pred_sigs">make_pred_sigs</a></code>. The diets of such simulated predators
can then be estimated, and the diet estimates can be compared to the
known diet composition to evaluate bias, variance, and perhaps other
properties.
</p>
<p>The algorithm starts by generating a uniformly distributed random number
between 0 and 1 as the diet proportion for the first prey type. The algorithm
then considers each additional prey type in turn, generating a uniform random
number between zero and 1 minus the sum of the proportions assigned to the
preceding prey types. The diet proportion for the last prey type is 1 minus
the sum of the other diet proportions. As a hedge against limitations in the
random number generator, the proportions are then randomly ordered among prey
types.
</p>
<p>It is critical that the prey-type names match those in the prey library. The
easiest way to ensure this happens is to pass the object uniq_types returned
a call to the function <code><a href="#topic+prep_sig">prep_sig</a></code> as the uniq_types argument.
Alternatively, and more risky, a vector of unique prey names can be created
using the concatenate function and cast as a factor, i.e.,
uniq_types &lt;- as.factor(c(&quot;Prey_1&quot;, &quot;Prey_2&quot;, ..., &quot;Prey_P)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_diet_rand(uniq_types = as.factor(c("Bearded",
                                        "Beluga",
                                        "Bowhead",
                                        "Ribbon",
                                        "Ringed",
                                        "Spotted",
                                        "Walrus")),
               n_diet = 100)

</code></pre>

<hr>
<h2 id='make_ghost'>Make a ghost prey signature</h2><span id='topic+make_ghost'></span>

<h3>Description</h3>

<p>Bromaghin et al (2016) studied the performance of QFASA estimators when
predators consumed a prey type that was not represented in the prey library,
termed a ghost prey.  <code>make_ghost</code> constructs a signature for a
ghost prey type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ghost(prey_sigs, loc, ghost_err = 0.25, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_ghost_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A matrix of prey signatures ready for analysis, intended to
be the object <code>sig_scale</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame or the object
<code>sig_part</code> returned by <code><a href="#topic+make_prey_part">make_prey_part</a></code>.</p>
</td></tr>
<tr><td><code id="make_ghost_+3A_loc">loc</code></td>
<td>
<p>A matrix giving the first and last locations of the
signatures of each prey type within <code>prey_sigs</code>, intended to be the
object <code>loc</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code> with the prey data frame or the object
<code>loc</code> returned by <code><a href="#topic+make_prey_part">make_prey_part</a></code>.</p>
</td></tr>
<tr><td><code id="make_ghost_+3A_ghost_err">ghost_err</code></td>
<td>
<p>A proportion strictly greater than 0 and less than 1 used to
control the lower and upper bounds of ghost prey signature proportions.
Default value 0.25.</p>
</td></tr>
<tr><td><code id="make_ghost_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to be used.
Default value 1.</p>
</td></tr>
<tr><td><code id="make_ghost_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>sig</dt><dd><p>A numeric vector containing the ghost prey signature.</p>
</dd>
<dt>dist</dt><dd><p>Summed distance between the ghost signature and the mean prey
signatures.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>One of the major assumptions of QFASA is that the prey library contains
representatives of all prey types consumed by a predator. Bromaghin et al.
(2016) investigated the robustness of diet estimators to violations of this
assumption. The function <code>make_ghost</code> constructs a ghost prey signature
using the methods of Bromaghin et al. (2016).
</p>
<p>The ghost prey signature is constructed by maximizing the summed distance
between the ghost prey signature and the mean prey signatures, while
constraining the ghost signature proportions within reasonable bounds to
ensure that the signature is somewhat realistic for the prey library. The
definition of reasonable bounds is embodied in the argument <code>ghost_err</code>.
<code>ghost_err</code> is a proportion greater than or equal to zero and less than 1
that is used to construct lower and upper bounds of the signature
proportions. The lower bound is obtained by multiplying <code>1 - ghost_err</code>
by the minimum mean prey proportion for each fatty acid. Similarly, the upper
bound is obtained by multiplying <code>1 + ghost_err</code> by the maximum mean
prey proportion for each fatty acid. The ghost prey signature is then
obtained by maximizing the summed distance between the signature and the mean
prey signatures, constraining the signature to lie within the
bounds and sum to 1. See <code><a href="#topic+est_diet">est_diet</a></code> for information regarding
distance measures.
</p>
<p>This method ensures that the ghost prey signature is somewhat distinct from
the other prey types, but not so wildly different that it represents a
completely different pattern from the other prey types. Although research
into suitable values for <code>ghost_err</code> has not been conducted, it is
probably advisable to use small to moderate values. Bromaghin et al. (2016)
used a value of 0.25. As the value of <code>ghost_err</code> is increased, the
resulting signature will tend to become increasing different from any prey
type in the library.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, G.W. Thiemann, and K.D. Rode. 2016. Assessing
the robustness of quantitative fatty acid signature analysis to assumption
violations. <em>Methods in Ecology and Evolution</em> 7:51-59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_ghost(prey_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                                0.04, 0.11, 0.29, 0.56,
                                0.10, 0.05, 0.35, 0.50,
                                0.12, 0.03, 0.37, 0.48,
                                0.10, 0.06, 0.35, 0.49,
                                0.05, 0.15, 0.35, 0.45), ncol=6),
           loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2),
           ghost_err = 0.15,
           dist_meas = 1,
           gamma = NA)

make_ghost(prey_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                                0.04, 0.11, 0.29, 0.56,
                                0.10, 0.05, 0.35, 0.50,
                                0.12, 0.03, 0.37, 0.48,
                                0.10, 0.06, 0.35, 0.49,
                                0.05, 0.15, 0.35, 0.45), ncol=6),
           loc = matrix(c(1, 3, 5, 2, 4, 6), ncol=2))

</code></pre>

<hr>
<h2 id='make_pred_sigs'>Simulate predator signatures</h2><span id='topic+make_pred_sigs'></span>

<h3>Description</h3>

<p><code>make_pred_sigs</code> generates predator signatures based on a specified
predator diet composition and bootstrap sampling signatures from a prey
library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pred_sigs(prey_sigs, prey_loc, cc, diet, prey_ss, n_pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_pred_sigs_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A matrix of prey signatures in the prey space, intended
to be the object <code>sig_scale</code> returned by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code>, or the object <code>sig_part</code> returned by a call to
the function <code><a href="#topic+make_prey_part">make_prey_part</a></code>.</p>
</td></tr>
<tr><td><code id="make_pred_sigs_+3A_prey_loc">prey_loc</code></td>
<td>
<p>A matrix giving the first and last locations of the
signatures of each prey type within <code>prey_sigs</code>, intended to be the
object <code>loc</code> returned by a call to one of the functions
<code><a href="#topic+prep_sig">prep_sig</a></code> or <code><a href="#topic+make_prey_part">make_prey_part</a></code>.</p>
</td></tr>
<tr><td><code id="make_pred_sigs_+3A_cc">cc</code></td>
<td>
<p>A numeric vector containing the calibration coefficients.</p>
</td></tr>
<tr><td><code id="make_pred_sigs_+3A_diet">diet</code></td>
<td>
<p>A numeric vector specifying the predator diet composition as
proportions.</p>
</td></tr>
<tr><td><code id="make_pred_sigs_+3A_prey_ss">prey_ss</code></td>
<td>
<p>An integer vector specifying the bootstrap sample size to use
for each prey type.</p>
</td></tr>
<tr><td><code id="make_pred_sigs_+3A_n_pred">n_pred</code></td>
<td>
<p>An integer specifying the number of predator signatures to
generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>sim_pred_sigs</dt><dd><p>A numeric matrix containing simulated predator
signatures in the predator space.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string containing a brief summary of the results.</p>
</dd>
</dl>



<h3>Details</h3>

<p>QFASA simulation studies often require the generation of predator signatures
given a specified diet, against which subsequent estimates of diet
composition can then be compared (e.g., Bromaghin et al. 2016). Given a
specified diet, a bootstrap sample of each prey type is drawn and mean
prey-type signatures are computed.  A predator signature is then generated
by multiplying the mean bootstrapped prey signatures by the diet proportions.
Finally, the calibration coefficients are then used to transform the predator
signatures to the predator space (Bromaghin et al. 2015).
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty acid
signature proportions sum to 1 for diet estimation? <em>Ecological
Research</em> 31:597-606.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_pred_sigs(prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                                  0.05, 0.09, 0.30, 0.56,
                                  0.03, 0.10, 0.30, 0.57,
                                  0.08, 0.07, 0.30, 0.55,
                                  0.09, 0.05, 0.33, 0.53,
                                  0.09, 0.06, 0.34, 0.51,
                                  0.09, 0.07, 0.34, 0.50,
                                  0.08, 0.11, 0.35, 0.46,
                                  0.06, 0.14, 0.36, 0.44), ncol = 9),
               prey_loc = matrix(c(1, 4, 7, 3, 6, 9), ncol=2),
               cc = c(0.75, 1.05, 0.55, 1.75),
               diet = c(0.25, 0.25, 0.50),
               prey_ss = c(5, 3, 7),
               n_pred = 50)

</code></pre>

<hr>
<h2 id='make_prey_part'>Make prey partition</h2><span id='topic+make_prey_part'></span>

<h3>Description</h3>

<p>The function <code>make_prey_part</code> partitions a prey library into clusters
based on user specifications informed by the results of a call to the
function <code>dimac</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_prey_part(sig, clust, n_clust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_prey_part_+3A_sig">sig</code></td>
<td>
<p>A matrix of scaled signatures ready for analysis, intended to be
the object <code>sig_scale</code> returned by the function <code>prep_sig</code>.</p>
</td></tr>
<tr><td><code id="make_prey_part_+3A_clust">clust</code></td>
<td>
<p>A data frame containing cluster definitions, intended to be the
object <code>clust</code> returned by the function <code>dimac</code>.</p>
</td></tr>
<tr><td><code id="make_prey_part_+3A_n_clust">n_clust</code></td>
<td>
<p>An integer vector constructed by the user to specify the
number of clusters into which each prey type should be partitioned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>type</dt><dd><p>A character vector of the partitioned type of each signature.</p>
</dd>
<dt>id</dt><dd><p>A character vector of the unique sample ID of each signature.</p>
</dd>
<dt>n_types</dt><dd><p>The number of unique types in the partitioned library.</p>
</dd>
<dt>uniq_types</dt><dd><p>A character vector of the unique types, sorted
alphanumerically.</p>
</dd>
<dt>type_ss</dt><dd><p>The number of signatures for each unique <code>type</code>.</p>
</dd>
<dt>loc</dt><dd><p>A vector or matrix giving the first and last locations of the
signatures of each <code>type</code>, after being sorted by <code>type</code> and
<code>id</code>.</p>
</dd>
<dt>sig_part</dt><dd><p>A matrix of partitioned signatures ready for analysis,
sorted by <code>type</code> and <code>id</code>, in column-major format.</p>
</dd>
<dt>pool_pre</dt><dd><p>A matrix to pre-multiply diet estimates associated with a
partitioned library to pool estimates back to the original prey types.</p>
</dd>
<dt>pool_post</dt><dd><p>A matrix to post-multiply diet estimates associated with a
partitioned library to pool estimates back to the original prey types.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code>make_prey_part</code> partitions a matrix of prey signatures
and into a larger number of prey types based on user input (in the vector
<code>n_clust</code>) informed by the results of a preceding call to the clustering
function <code>dimac</code>.  The signatures in <code>sig</code> are presumed to be
ready for analysis, which is best accomplished by a call to the function
<code>prep_sig</code>.
</p>
<p>For each prey type, the column in <code>clust</code> designated by the
corresponding integer in <code>n_clust</code> is accessed and used to partition the
prey type.  For example, if the element of <code>n_clust</code> is 1, the first
column of <code>clust</code> is accessed and the prey type is not partitioned.  If
the element of <code>n_clust</code> is 3, the third column of <code>clust</code> is
accessed and the prey type is partitioned into three clusters.
</p>
<p>The length of the integer vector <code>n_clust</code> must equal the number of
unique types in <code>type</code>.  The integers themselves should be between 1 and
the number of signatures of each type.
</p>
<p>After all prey types have been partitioned, the prey signatures are sorted by
<code>type</code> and <code>id</code>.  The matrix <code>rep_grp</code> is created to map the
new prey types to the original prey types.  Multiplying diet estimates
corresponding to a partitioned prey library <code>sig_part</code> by <code>rep_grp</code>
pools the diet estimates into the original prey types.
</p>
<p>Please refer to the vignette and documentation for the functions
<code><a href="#topic+dimac">dimac</a></code> and <code><a href="#topic+prep_sig">prep_sig</a></code> for additional
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_prey_part(sig = matrix(c(0.01, 0.20, 0.30, 0.49,
                              0.05, 0.14, 0.39, 0.42,
                              0.07, 0.21, 0.28, 0.44,
                              0.04, 0.19, 0.34, 0.43,
                              0.12, 0.29, 0.39, 0.20,
                              0.15, 0.28, 0.34, 0.23,
                              0.17, 0.21, 0.31, 0.31,
                              0.18, 0.22, 0.28, 0.32), ncol = 8),
               data.frame(type = c("prey_1", "prey_1", "prey_1", "prey_2",
                                   "prey_2", "prey_2", "prey_2", "prey_2"),
                          id = c("1-1", "1-2", "1-3", "2-1",
                                 "2-2", "2-3", "2-4", "2-5"),
                          clust_1 = c(1, 1, 1, 1, 1, 1, 1, 1),
                          clust_2 = c(1, 2, 1, 2, 1, 1, 2, 2),
                          clust_3 = c(1, 2, 3, 3, 1, 2, 3, 3),
                          clust_4 = c(0, 0, 0, 4, 1, 2, 3, 4)),
               n_clust = c(1, 2))

</code></pre>

<hr>
<h2 id='pm_obj_func'>Parameterized mean objective function</h2><span id='topic+pm_obj_func'></span>

<h3>Description</h3>

<p>The utility function <code>pm_obj_func</code> computes the total distance between
observed predator signatures and vector of mean diet proportions common to
all predators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm_obj_func(diet, obs_sig, mean_sigs, dist_meas = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pm_obj_func_+3A_diet">diet</code></td>
<td>
<p>A numeric vector of mean diet composition.</p>
</td></tr>
<tr><td><code id="pm_obj_func_+3A_obs_sig">obs_sig</code></td>
<td>
<p>A numeric matrix containing observed predator signatures, in
column-major format.</p>
</td></tr>
<tr><td><code id="pm_obj_func_+3A_mean_sigs">mean_sigs</code></td>
<td>
<p>A numeric matrix of the mean fatty acid signature for each
prey type in the prey library, in column-major format.</p>
</td></tr>
<tr><td><code id="pm_obj_func_+3A_dist_meas">dist_meas</code></td>
<td>
<p>An integer indicator of the distance measure to compute.
Default value 1.</p>
</td></tr>
<tr><td><code id="pm_obj_func_+3A_gamma">gamma</code></td>
<td>
<p>The power parameter of the chi-square distance measure. Default
value 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The total distance between observed and modeled signatures.
</p>


<h3>Details</h3>

<p>This is an internal utility function.  Consequently, to increase execution
speed, no numeric error checking is performed within <code>pm_obj_func</code>.
Rather, error checking is presumed to have occurred at a higher level in the
calling sequence.
</p>
<p>The argument <code>obs_sig</code> is presumed to be a matrix of predator
signatures that has been prepared for analysis, which is best accomplished
by a call to the function <code><a href="#topic+prep_sig">prep_sig</a></code> with the predator data.
Similarly, the contents of <code>mean_sigs</code> should be mean signatures computed
from signatures that were prepared for analysis by a call to the function
<code><a href="#topic+prep_sig">prep_sig</a></code>.
</p>
<p>The argument <code>diet</code> is presumed to contain non-negative proportions that
sum to 1.0.
</p>
<p>The arguments <code>dist_meas</code> and <code>gamma</code> must be compatible with the
function <code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code>.
</p>
<p>Please refer to the vignette and documentation for the functions
<code><a href="#topic+prep_sig">prep_sig</a></code>, <code><a href="#topic+sig_scale">sig_scale</a></code>, and
<code><a href="#topic+dist_between_2_sigs">dist_between_2_sigs</a></code> for additional details.
</p>
<p><code>diet_obj_func</code> models a predator signature as a mixture of the mean
prey-type signatures, with the diet proportions as the mixture proportions,
returning the distance between the observed and modeled signatures.  The
diet composition of a predator is estimated by minimizing this function with
respect to the <code>diet</code> using the function Rsolnp::solnp.
</p>

<hr>
<h2 id='pred_beyond_prey'>Identify predator signature proportions beyond range of prey</h2><span id='topic+pred_beyond_prey'></span>

<h3>Description</h3>

<p>The function <code>pred_beyond_prey</code> identifies predator signaturee
proportions that are outside the range of proportions observed in the
individual and mean prey signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_beyond_prey(pred_sigs, prey_sigs, mean_sigs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_beyond_prey_+3A_pred_sigs">pred_sigs</code></td>
<td>
<p>A numeric matrix of predator signature(s) in
column-major format. Intended to be the object <code>pred_sigs</code> returned by
the function <code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="pred_beyond_prey_+3A_prey_sigs">prey_sigs</code></td>
<td>
<p>A numeric matrix of prey signatures in column-major format.
Intended to be the object <code>prey_sigs</code> returned by the function
<code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
<tr><td><code id="pred_beyond_prey_+3A_mean_sigs">mean_sigs</code></td>
<td>
<p>A numeric matrix of mean prey-type signatures. Intended to
be the object <code>prey_sigs</code> returned by the function
<code><a href="#topic+est_diet">est_diet</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>beyond_ind</dt><dd><p>A logical matrix with TRUE indicating that the
corresponding predator proportion is outside the range of individual
prey proportions.</p>
</dd>
<dt>beyond_mean</dt><dd><p>A logical matrix with TRUE indicating that the
corresponding predator proportion is outside the range of mean prey
proportions.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In quantitative fatty acid signature analysis, predator signatues are assumed
to be a linear mixture of mean prey signatures (Iverson et al. 2004).
Predator signature proportions should therefore be within the range of
the prey signature proportions. Signature proportions outside the range of
prey proportions are indicative of a violation of one or both of the primary
model assumptions, i.e., the prey library is incomplete or the calibration
coefficients are inaccurate (Bromaghin et al. 2015, 2016a). Consequently,
checking for predator proportions that are outside the range of mean prey
proportions is an important diagnostic aid to evaluate the reliability
of diet estimates.
</p>
<p>The function <code>pred_beyond_prey</code> identifies predator signature
proportions that outside the range of proportions observed among the
individual and mean prey signatures. For purposes of diet estimation,
proportions outside the range of the mean signatures are most important.
However, <code>pred_beyond_prey</code> also identifies predator proportions that
are outside the range of the individual prey proportions for exploratory
purposes.
</p>
<p><code>pred_beyond_prey</code> is designed to be called with inputs returned by the
function <code><a href="#topic+est_diet">est_diet</a></code>. Although it is not conceptually necessary to
estimate diets before performing this diagnostic check, doing so ensures that
the predator and prey signatures have been transformed to the optimization
space (Bromaghin et al. 2015) in which diets have been estimated.
</p>


<h3>References</h3>

<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Bromaghin, J.F., S.M. Budge, G.W. Thiemann, and K.D. Rode. 2016. Assessing
the robustness of quantitative fatty acid signature analysis to assumption
violations. <em>Methods in Ecology and Evolution</em> 7:51-59.
</p>
<p>Bromaghin, J.F., K.D. Rode, S.M. Budge, and G.W. Thiemann. 2015. Distance
measures and optimization spaces in quantitative fatty acid signature
analysis. <em>Ecology and Evolution</em> 5:1249-1262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pred_beyond_prey(pred_sigs = matrix(c(0.05, 0.10, 0.30, 0.55,
                                      0.04, 0.11, 0.29, 0.56,
                                      0.10, 0.05, 0.35, 0.50,
                                      0.12, 0.03, 0.37, 0.48,
                                      0.10, 0.06, 0.35, 0.49,
                                      0.05, 0.15, 0.35, 0.45), ncol = 6),
                 prey_sigs = matrix(c(0.06, 0.09, 0.31, 0.54,
                                      0.05, 0.09, 0.30, 0.56,
                                      0.03, 0.10, 0.30, 0.57,
                                      0.08, 0.07, 0.30, 0.55,
                                      0.09, 0.05, 0.33, 0.53,
                                      0.09, 0.06, 0.34, 0.51,
                                      0.09, 0.07, 0.34, 0.50,
                                      0.08, 0.11, 0.35, 0.46,
                                      0.06, 0.14, 0.36, 0.44), ncol = 9),
                 mean_sigs = matrix(c(0.047, 0.093, 0.303, 0.557,
                                      0.087, 0.050, 0.323, 0.530,
                                      0.077, 0.106, 0.350, 0.467), ncol = 3))

</code></pre>

<hr>
<h2 id='prep_fa'>Prepare fatty acid information analysis</h2><span id='topic+prep_fa'></span>

<h3>Description</h3>

<p>The function <code>prep_fa</code> processes the information in a fatty acid
suites data frame and prepares that information for application to fatty
acid signatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_fa(df_fa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_fa_+3A_df_fa">df_fa</code></td>
<td>
<p>A data frame containing fatty acid names, calibration
coefficients, and 0/1 definitions of fatty acid suites.  <code>qfasar</code> has
strict formatting requirements for <code>df_fa</code>; please see Details and/or
the vignette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>cc</dt><dd><p>A numeric vector of calibration coefficients.</p>
</dd>
<dt>use</dt><dd><p>A logical vector defining a fatty acid suite.</p>
</dd>
<dt>fa_names</dt><dd><p>A character vector of fatty acid names.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This function is designed to be called by the user after the fatty acid data
frame has been read.  The data frame should contain a complete list of all
fatty acids in the prey and predator signature data, one or more sets of
calibration coefficients with an indicator of which set to use, one or more
fatty acid suite definitions with an indicator of which suite to use, and
optional comments.  Please refer to the vignette for additional information.
</p>
<p>The fatty acid data frame must strictly meet the following formatting
requirements.
</p>

<ul>
<li><p> The first row must contain a header for each column.
</p>
</li>
<li><p> The second row must list &quot;use_me&quot; in the first column, a 1 in the
column for the set of calibration coefficients to be used, a 1 in the
column for the fatty acid suite to be used, and a 0 in all other columns.
</p>
</li>
<li><p> Starting with row three, the first column must contain fatty acid
names, which must exactly match the corresponding components of the
headers in any prey and predator signature data frames.
</p>
</li>
<li><p> Starting with row three, Columns 2 to k must contain calibration
coefficients for each fatty acid.  Multiple sets of calibration
coefficients can be in the data frame.  The set to be used must contain
a 1 in Row 1 and the others must contain a 0 in Row 1.
</p>
</li>
<li><p> Columns k+1 to m must contain one or more definitions of fatty acid
suites. Membership in a suite is defined by 0/1 indicators, with a 1
indicating membership.  Definitions for multiple suites can be in the
data frame.  For example, two columns could contain indicators defining
membership in the dietary and extended-dietary suites of fatty acids
(Iverson et al. 2004).  The suite to be used must contain a 1 in Row 1
and the others must contain a 0 in Row 1.
</p>
</li>
<li><p> An optional last column can contain comments.
</p>
</li>
<li><p> Please see the vignette for examples of how to format this data
frame.
</p>
</li></ul>



<h3>References</h3>

<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep_fa(data.frame(fa = c("use_me", "fa_1", "fa_2", "fa_3"),
                   cc = c(1, 0.75, 1.25, 1.0),
                   use = c(1, 1, 1, 1)))

prep_fa(data.frame(fa = c("use_me", "fa_1", "fa_2", "fa_3"),
                   cc1 = c(0, 0.75, 1.25, 1.00),
                   cc2 = c(1, 1.2, 0.8, 0.9),
                   use_1 = c(0, 1, 1, 0),
                   use_2 = c(1, 1, 1, 0)))

</code></pre>

<hr>
<h2 id='prep_sig'>Prepare fatty acid signature data for analysis</h2><span id='topic+prep_sig'></span>

<h3>Description</h3>

<p>The function <code>prep_sig</code> prepares raw fatty acid signatures for
analysis.  Signature proportions that are missing, negative, or equal to zero
are replaced with a small user-specified constant and the signatures are
scaled to sum to 1.0. The fatty acids that are not to be used in the analysis
are censored and the signatures are scaled using one of three options
(Bromaghin et al. In press).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_sig(df_sig, fa_names, use_fa, zero_rep = 75, scale = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_sig_+3A_df_sig">df_sig</code></td>
<td>
<p>A data frame containing prey fatty acid signature data.
<code>qfasar</code> has strict formatting requirements for <code>df_sig</code>; please
see Details and/or the vignette.</p>
</td></tr>
<tr><td><code id="prep_sig_+3A_fa_names">fa_names</code></td>
<td>
<p>A character vector of all fatty acid names.</p>
</td></tr>
<tr><td><code id="prep_sig_+3A_use_fa">use_fa</code></td>
<td>
<p>A logical vector defining a fatty acid suite.</p>
</td></tr>
<tr><td><code id="prep_sig_+3A_zero_rep">zero_rep</code></td>
<td>
<p>A constant associated with the method and value to replace
signature proportions that are missing or less than or equal to 0. Default
value 75.</p>
</td></tr>
<tr><td><code id="prep_sig_+3A_scale">scale</code></td>
<td>
<p>An integer indicator of the desired scaling option. Default
value 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>type</dt><dd><p>A character vector of the type of each signature.</p>
</dd>
<dt>id</dt><dd><p>A character vector of the unique sample ID of each signature.</p>
</dd>
<dt>n_types</dt><dd><p>The number of unique types.</p>
</dd>
<dt>uniq_types</dt><dd><p>A character vector of the unique types, sorted
alphanumerically.</p>
</dd>
<dt>n_sig</dt><dd><p>The total number of signatures.</p>
</dd>
<dt>type_ss</dt><dd><p>The number of signatures for each unique <code>type</code>.</p>
</dd>
<dt>loc</dt><dd><p>A vector or matrix giving the first and last locations of the
signatures of each <code>type</code>, after being sorted by <code>type</code> and
<code>id</code>.</p>
</dd>
<dt>sig_rep</dt><dd><p>A vector or matrix of the original signatures, with any
values missing or less than or equal to 0 replaced, in column-major
format.</p>
</dd>
<dt>n_fa_rep</dt><dd><p>The number of fatty acids in <code>sig_rep</code>.</p>
</dd>
<dt>sig_scale</dt><dd><p>A vector or matrix of scaled signatures ready for
analysis, sorted by <code>type</code> and <code>id</code>, in column-major format.</p>
</dd>
<dt>n_fa_suite</dt><dd><p>The number of fatty acids in <code>sig_scale</code>.</p>
</dd>
<dt>fa_suite</dt><dd><p>A character vector of the names of fatty acids in the suite
to be used in the analysis.</p>
</dd>
<dt>zero_rep_val</dt><dd><p>A constant associated with the method and value to be
used to replace proportions that are missing or less than or equal to 0.
See Details.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This function is designed to be called by the user to prepare fatty acid
signatures for analysis.  For most analyses, <code>prep_sig</code> should be
called immediately after the fatty acid suites and fatty acid signatures have
been read into data frames, and after the fatty acid suites data frame has
been processed by the function <code>prep_fa</code>.  Please refer to the
vignette for additional information.
</p>
<p>The data frame with fatty acid signatures must meet the following formatting
requirements:
</p>

<ul>
<li><p> The file must be in row-major format, i.e., each row contains the
information for an individual animal.
</p>
</li>
<li><p> The first column must contain a designation of animal <code>type</code>.
For prey data, <code>type</code> often denotes species.  For predator data,
<code>type</code> denotes classes of predators for which separate estimates of
mean diet composition are desired.
</p>
</li>
<li><p> The second column must contain an identifier unique to each
signature, i.e. a sample ID.
</p>
</li>
<li><p> The remaining columns must contain fatty acid signature proportions
or percentages.
</p>
</li>
<li><p> The data frame must contain a header record, with a name for each
column, such as &quot;type&quot;, &quot;id&quot;, name of fatty acid 1, name of fatty
acid 2, ...
</p>
</li>
<li><p> The file should contain data from all available fatty acids, rather
than a subset.  The fatty acid suite to be used in the analysis is
defined by the argument <code>fa</code>.
</p>
</li></ul>

<p>Please refer to the documentation for the utility function
<code><a href="#topic+sig_rep_zero">sig_rep_zero</a></code> for information regarding the argument
<code>zero_rep</code>.
</p>
<p>Please refer to the documentation for the utility function
<code><a href="#topic+sig_scale">sig_scale</a></code> for information regarding the argument
<code>scale</code>.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. In press. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em>.
</p>
<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prep_sig(df_sig = data.frame(type = c("Type_1", "Type_1", "Type_2",
                                      "Type_2"),
                             id = c("ID_1", "ID_2", "ID_3", "ID_4"),
                             fa_1 = c(0.0, 0.2, 0.3, 0.6),
                             fa_2 = c(0.1, 0.3, 0.3, 0.4),
                             fa_3 = c(0.9, 0.5, 0.4, NA),
                             row.names = c("Prey_1", "Prey_2", "Prey_3",
                                           "Prey_4")),
         fa_names = c("fa_1", "fa_2", "fa_3"),
         use_fa = c(TRUE, FALSE, TRUE),
         zero_rep = 0.0001,
         scale=2)

prep_sig(df_sig = data.frame(type = c("Type_1", "Type_1", "Type_2",
                                      "Type_2"),
                             id = c("ID_1", "ID_2", "ID_3", "ID_4"),
                             fa_1 = c(0.0, 0.2, 0.3, 0.6),
                             fa_2 = c(0.1, 0.3, 0.3, 0.4),
                             fa_3 = c(0.9, 0.5, 0.4, NA),
                             row.names = c("Prey_1", "Prey_2", "Prey_3",
                                           "Prey_4")),
         fa_names = c("fa_1", "fa_2", "fa_3"),
         use_fa = c(TRUE, FALSE, TRUE),
         zero_rep = 90,
         scale=1)

prep_sig(df_sig = data.frame(type = c("Type_1", "Type_1", "Type_2",
                                      "Type_2"),
                             id = c("ID_1", "ID_2", "ID_3", "ID_4"),
                             fa_1 = c(0.0, 0.2, 0.3, 0.6),
                             fa_2 = c(0.1, 0.3, 0.3, 0.4),
                             fa_3 = c(0.9, 0.5, 0.4, NA),
                             row.names = c("Prey_1", "Prey_2", "Prey_3",
                                           "Prey_4")),
         fa_names = c("fa_1", "fa_2", "fa_3"),
         use_fa = c(TRUE, FALSE, TRUE),
         scale=3)

prep_sig(df_sig = data.frame(type = c("Type_1", "Type_1", "Type_2",
                                      "Type_2"),
                             id = c("ID_1", "ID_2", "ID_3", "ID_4"),
                             fa_1 = c(0.0, 0.2, 0.3, 0.6),
                             fa_2 = c(0.1, 0.3, 0.3, 0.4),
                             fa_3 = c(0.9, 0.5, 0.4, NA),
                             row.names = c("Prey_1", "Prey_2", "Prey_3",
                                           "Prey_4")),
         fa_names = c("fa_1", "fa_2", "fa_3"),
         use_fa = c(TRUE, FALSE, TRUE))

</code></pre>

<hr>
<h2 id='sig_rep_zero'>Replace invalid fatty acid signature proportions</h2><span id='topic+sig_rep_zero'></span>

<h3>Description</h3>

<p>The utility function <code>sig_rep_zero</code> replaces fatty acid signature
proportions that are less than or equal to zero or missing with a small
constant and uses the multiplicative method (Martin-Fernandez et al. 2011)
to scale the proportions to sum to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_rep_zero(sig_data, zero_rep = 75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sig_rep_zero_+3A_sig_data">sig_data</code></td>
<td>
<p>A numeric matrix containing signature data as either
proportions or percentages in column-major format.</p>
</td></tr>
<tr><td><code id="sig_rep_zero_+3A_zero_rep">zero_rep</code></td>
<td>
<p>A constant associated with the method and value to be
used to replace invalid values.  See Details. Default value 75.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>sig_adj</dt><dd><p>The signature data with non-positive or missing proportions
replaced and scaled to sum to 1.0.</p>
</dd>
<dt>rep_val</dt><dd><p>The value used to replace invalid proporitons.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The function <code>sig_rep_zero</code> is an internal utility function.
</p>
<p>The Kullback-Leibler (Iverson et al. 2004) and Aitchison (Stewart et al.
2014) distance measures are not defined for proportions of zero.
Consequently, if either of these distance measures will be used in an
analysis, the argument <code>zero_rep</code> should be strictly greater than 0.
The chi-square distance measure (Stewart et al. 2014) is defined for
proportions of zero, so if that distance measure will be used in the
analysis, the argument <code>zero_rep</code> may equal zero.  For simulation or
other comparative work involving multiple distance measures, it may be
advisable to use a common value to replace zeros.
</p>
<p>The argument <code>zero_rep</code> must be either:</p>

<ul>
<li><p> Greater than or equal to 0 and no greater than 0.01, in which case
the specified value is used to replace invalid proportions.
</p>
</li>
<li><p> Between 10 and 100, with an uninformed  default of 75.  In this
case, <code>zero_rep</code> is interpreted as a percentage.  The smallest
non-zero proportion in <code>sig_data</code> is multiplied by the percentage
and divided by 100.  The result is used to replace invalid proportions.
</p>
</li></ul>

<p>Although Bromaghin et al. (2016) found that scaling signatures
by varying constants introduces a bias in diet estimation, the slight
distortion of the signatures caused by replacing invalid proportions
with a small constant that varies between signatures is unlikely to
introduce meaningful bias.
</p>


<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>
<p>Iverson, S.J., C. Field, W.D. Bowen, and W. Blanchard. 2004.
Quantitative fatty acid signature analysis: A new method of
estimating predator diets. <em>Ecological Monographs</em> 74:211-235.
</p>
<p>Martin-Fernandez, J.A., J. Palarea-Albaladejo, and R.A. Olea. 2011.
Dealing with zeros. P. 43-58 in V. Pawlowsky-Glahn and A. Buccianto,
eds. Compositional data analysis: theory and application. John Wiley,
Chichester.
</p>
<p>Stewart, C., and C. Field. 2011. Managing the essential zeros in quantitative
fatty acid signature analysis. <em>Journal of Agricultural, Biological, and
Environmental Statistics</em> 16:45?69.
</p>

<hr>
<h2 id='sig_scale'>Scale fatty acid signature proportions</h2><span id='topic+sig_scale'></span>

<h3>Description</h3>

<p>The utility function <code>sig_scale</code> implements the three options for
scaling fatty acid signature data summarized by Bromaghin et al. (2016).
A logical vector denotes the subset of all fatty acids to be used in the
analysis.  The fatty acids that are not to be used are censored and one of
three scaling options is implemented.  See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_scale(sig_data, fa_use, scale = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sig_scale_+3A_sig_data">sig_data</code></td>
<td>
<p>A numeric matrix containing prey signature data as
proportions in column-major.  These data should have previously been
processed by <code><a href="#topic+sig_rep_zero">sig_rep_zero</a></code>.</p>
</td></tr>
<tr><td><code id="sig_scale_+3A_fa_use">fa_use</code></td>
<td>
<p>A logical vector denoting the fatty acids to be used, of length
equal to the total number of fatty acids. This vector originates from a
data file required by <code>qfasar</code>. See the vignette for details.</p>
</td></tr>
<tr><td><code id="sig_scale_+3A_scale">scale</code></td>
<td>
<p>An integer indicator of the desired scaling option. See
Details. Default value 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements: </p>

<dl>
<dt>n_fa</dt><dd><p>The number of fatty acids in the processed signatures.</p>
</dd>
<dt>sig</dt><dd><p>A numeric matrix of processed signatures in column-major
format.</p>
</dd>
<dt>err_code</dt><dd><p>An integer error code (0 if no error is detected).</p>
</dd>
<dt>err_message</dt><dd><p>A string contains a brief summary of the execution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an internal utility function.
</p>
<p>The argument <code>scale</code> must be one of three integer values and its value
denotes the scaling option that will be implemented:</p>

<ul>
<li> <p><code>scale</code> == 1.  The proportions within each censored signature
are scaled to sum to 1.0.  This option is not recommended for routine
use in QFASA applications, as Bromaghin et al. (2016) found that it
can meaningfully bias diet estimates under some conditions.  It is
implemented here to provide compatibility with original methods and to
facilitate potential future research.
</p>
</li>
<li> <p><code>scale</code> == 2.  The proportions within each censored signature
are not scaled, so each signature will have a different partial sum.
</p>
</li>
<li> <p><code>scale</code> == 3.  Each censored signature is augmented with an
additional proportion whose value equals the sum of the censored
proportions, so that the proportions in each signature sum to 1.
This is the default option.
</p>
</li></ul>



<h3>References</h3>

<p>Bromaghin, J.F., S.M. Budge, and G.W. Thiemann. 2016. Should fatty
acid signature proportions sum to 1 for diet estimation?
<em>Ecological Research</em> 31:597-606.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
