<!DOCTYPE html><html><head><title>Help for package OpenMx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OpenMx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.statusCode'><p>Convert a numeric or character vector into an optimizer status code factor</p></a></li>
<li><a href='#BaseCompute-class'><p>BaseCompute</p></a></li>
<li><a href='#Bollen'>
<p>Bollen Data on Industrialization and Political Democracy</p></a></li>
<li><a href='#cvectorize'><p>Vectorize By Column</p></a></li>
<li><a href='#demoOneFactor'>
<p>Demonstration data for a one factor model</p></a></li>
<li><a href='#demoTwoFactor'>
<p>Demonstration data for a two factor model</p></a></li>
<li><a href='#diag2vec'><p>Extract Diagonal of a Matrix</p></a></li>
<li><a href='#DiscreteBase-class'><p>An S4 base class for discrete marginal distributions</p></a></li>
<li><a href='#dzfData'>
<p>Example twin extended kinship data: DZ female data</p></a></li>
<li><a href='#dzmData'>
<p>Example twin extended kinship data: DZ Male data</p></a></li>
<li><a href='#dzoData'>
<p>Example twin extended kinship data: DZ opposite sex twins</p></a></li>
<li><a href='#eigenvec'><p>Eigenvector/Eigenvalue Decomposition</p></a></li>
<li><a href='#example1'>
<p>Bivariate twin data, wide-format from Classic Mx Manual</p></a></li>
<li><a href='#example2'>
<p>Bivariate twin data, long-format from Classic Mx Manual</p></a></li>
<li><a href='#expm'><p>Matrix exponential</p></a></li>
<li><a href='#factorExample1'>
<p>Example Factor Analysis Data</p></a></li>
<li><a href='#factorScaleExample1'>
<p>Example Factor Analysis Data for Scaling the Model</p></a></li>
<li><a href='#factorScaleExample2'>
<p>Example Factor Analysis Data for Scaling the Model</p></a></li>
<li><a href='#genericFitDependencies,MxBaseFitFunction-method'><p>Add dependencies</p></a></li>
<li><a href='#HS.ability.data'>
<p>Holzinger &amp; Swineford (1939) Ability in 301 children from 2 schools</p></a></li>
<li><a href='#imxAddDependency'><p>Add a dependency</p></a></li>
<li><a href='#imxAutoOptionValue'><p>imxAutoOptionValue</p></a></li>
<li><a href='#imxCheckMatrices'><p>imxCheckMatrices</p></a></li>
<li><a href='#imxCheckVariables'><p>imxCheckVariables</p></a></li>
<li><a href='#imxConDecMatrixSlots'><p>Condense/de-condense slots of an MxMatrix</p></a></li>
<li><a href='#imxConstraintRelations'><p>imxConstraintRelations</p></a></li>
<li><a href='#imxConvertIdentifier'><p>imxConvertIdentifier</p></a></li>
<li><a href='#imxConvertLabel'><p>imxConvertLabel</p></a></li>
<li><a href='#imxConvertSubstitution'><p>imxConvertSubstitution</p></a></li>
<li><a href='#imxCreateMatrix'><p>Create a matrix</p></a></li>
<li><a href='#imxDataTypes'><p>Valid types of data that can be contained by MxData</p></a></li>
<li><a href='#imxDefaultGetSlotDisplayNames'><p>imxDefaultGetSlotDisplayNames</p></a></li>
<li><a href='#imxDeparse'><p>Deparse for MxObjects</p></a></li>
<li><a href='#imxDependentModels'><p>Are submodels dependence?</p></a></li>
<li><a href='#imxDetermineDefaultOptimizer'><p>imxDetermineDefaultOptimizer</p></a></li>
<li><a href='#imxDmvnorm'><p>A C implementation of dmvnorm</p></a></li>
<li><a href='#imxEvalByName'><p>imxEvalByName</p></a></li>
<li><a href='#imxExtractMethod'><p>imxExtractMethod</p></a></li>
<li><a href='#imxExtractNames'><p>imxExtractNames</p></a></li>
<li><a href='#imxExtractReferences'><p>imxExtractReferences</p></a></li>
<li><a href='#imxExtractSlot'><p>imxExtractSlot</p></a></li>
<li><a href='#imxFlattenModel'><p>Remove hierarchical structure from model</p></a></li>
<li><a href='#imxFreezeModel'><p>Freeze model</p></a></li>
<li><a href='#imxGenerateLabels'><p>imxGenerateLabels</p></a></li>
<li><a href='#imxGenerateNamespace'><p>imxGenerateNamespace</p></a></li>
<li><a href='#imxGenericModelBuilder'><p>imxGenericModelBuilder</p></a></li>
<li><a href='#imxGenSwift'><p>imxGenSwift</p></a></li>
<li><a href='#imxGentleResize'><p>Resize an MxMatrix while preserving entries</p></a></li>
<li><a href='#imxGetNumThreads'><p>imxGetNumThreads</p></a></li>
<li><a href='#imxGetSlotDisplayNames'><p>imxGetSlotDisplayNames</p></a></li>
<li><a href='#imxHasConstraint'><p>imxHasConstraint</p></a></li>
<li><a href='#imxHasDefinitionVariable'><p>imxHasDefinitionVariable</p></a></li>
<li><a href='#imxHasNPSOL'><p>imxHasNPSOL</p></a></li>
<li><a href='#imxHasOpenMP'><p>imxHasOpenMP</p></a></li>
<li><a href='#imxHasThresholds'><p>imxHasThresholds</p></a></li>
<li><a href='#imxHasWLS'><p>imxHasWLS</p></a></li>
<li><a href='#imxIdentifier'><p>imxIdentifier</p></a></li>
<li><a href='#imxIndependentModels'><p>Are submodels independent?</p></a></li>
<li><a href='#imxInitModel'><p>imxInitModel</p></a></li>
<li><a href='#imxIsDefinitionVariable'><p>imxIsDefinitionVariable</p></a></li>
<li><a href='#imxIsMultilevel'><p>imxIsMultilevel</p></a></li>
<li><a href='#imxIsPath'><p>imxIsPath</p></a></li>
<li><a href='#imxIsStateSpace'><p>imxIsStateSpace</p></a></li>
<li><a href='#imxLocateFunction'><p>imxLocateFunction</p></a></li>
<li><a href='#imxLocateIndex'><p>imxLocateIndex</p></a></li>
<li><a href='#imxLocateLabel'><p>imxLocateLabel</p></a></li>
<li><a href='#imxLog'><p>Test thread-safe output code</p></a></li>
<li><a href='#imxLookupSymbolTable'><p>imxLookupSymbolTable</p></a></li>
<li><a href='#imxModelBuilder'><p>imxModelBuilder</p></a></li>
<li><a href='#imxModelTypes'><p>imxModelTypes</p></a></li>
<li><a href='#imxMpiWrap'><p>imxMpiWrap</p></a></li>
<li><a href='#imxOriginalMx'><p>Run an classic mx script</p></a></li>
<li><a href='#imxPenaltyTypes'><p>imxPenaltyTypes</p></a></li>
<li><a href='#imxPPML'><p>imxPPML</p></a></li>
<li><a href='#imxPPML.Test.Battery'><p>imxPPML.Test.Battery</p></a></li>
<li><a href='#imxPPML.Test.Test'><p>imxPPML.Test.Test</p></a></li>
<li><a href='#imxPreprocessModel'><p>imxPreprocessModel</p></a></li>
<li><a href='#imxReplaceMethod'><p>imxReplaceMethod</p></a></li>
<li><a href='#imxReplaceModels'><p>Replace parts of a model</p></a></li>
<li><a href='#imxReplaceSlot'><p>imxReplaceSlot</p></a></li>
<li><a href='#imxReportProgress'><p>Report backend progress</p></a></li>
<li><a href='#imxReservedNames'><p>imxReservedNames</p></a></li>
<li><a href='#imxReverseIdentifier'><p>imxReverseIdentifier</p></a></li>
<li><a href='#imxRobustSE'><p>imxRobustSE</p></a></li>
<li><a href='#imxRowGradients'><p>imxRowGradients</p></a></li>
<li><a href='#imxSameType'><p>imxSameType</p></a></li>
<li><a href='#imxSeparatorChar'><p>imxSeparatorChar</p></a></li>
<li><a href='#imxSfClient'><p>imxSfClient</p></a></li>
<li><a href='#imxSimpleRAMPredicate'><p>imxSimpleRAMPredicate</p></a></li>
<li><a href='#imxSparseInvert'><p>Sparse symmetric matrix invert</p></a></li>
<li><a href='#imxSquareMatrix'><p>imxSquareMatrix</p></a></li>
<li><a href='#imxSymmetricMatrix'><p>imxSymmetricMatrix</p></a></li>
<li><a href='#imxTypeName'><p>imxTypeName</p></a></li>
<li><a href='#imxUntitledName'><p>imxUntitledName</p></a></li>
<li><a href='#imxUntitledNumber'><p>imxUntitledNumber</p></a></li>
<li><a href='#imxUntitledNumberReset'><p>imxUntitledNumberReset</p></a></li>
<li><a href='#imxUpdateModelValues'><p>imxUpdateModelValues</p></a></li>
<li><a href='#imxVariableTypes'><p>imxVariableTypes</p></a></li>
<li><a href='#imxVerifyMatrix'><p>imxVerifyMatrix</p></a></li>
<li><a href='#imxVerifyModel'><p>imxVerifyModel</p></a></li>
<li><a href='#imxVerifyName'><p>imxVerifyName</p></a></li>
<li><a href='#imxVerifyReference'><p>imxVerifyReference</p></a></li>
<li><a href='#imxWlsChiSquare'><p>Calculate Chi Square for a WLS Model</p></a></li>
<li><a href='#imxWlsStandardErrors'><p>Calculate Standard Errors for a WLS Model</p></a></li>
<li><a href='#jointdata'>
<p>Joint Ordinal and continuous variables to be modeled together</p></a></li>
<li><a href='#latentMultipleRegExample1'>
<p>Example data for multiple regression among latent variables</p></a></li>
<li><a href='#latentMultipleRegExample2'>
<p>Example data for multiple regression among latent variables</p></a></li>
<li><a href='#lazarsfeld'>
<p>Respondent-soldiers on four dichotomous items</p></a></li>
<li><a href='#logm'><p>Matrix logarithm</p></a></li>
<li><a href='#LongitudinalOverdispersedCounts'>
<p>Longitudinal, Overdispersed Count Data</p></a></li>
<li><a href='#multiData1'>
<p>Data for multiple regression</p></a></li>
<li><a href='#mxAlgebra'><p>Create MxAlgebra Object</p></a></li>
<li><a href='#MxAlgebra-class'><p>MxAlgebra Class</p></a></li>
<li><a href='#MxAlgebraFormula-class'><p>MxAlgebraFormula</p></a></li>
<li><a href='#mxAlgebraFromString'><p>Create MxAlgebra object from a string</p></a></li>
<li><a href='#mxAlgebraObjective'><p>DEPRECATED:  Create MxAlgebraObjective Object</p></a></li>
<li><a href='#mxAutoStart'><p>Automatically set starting values for an MxModel</p></a></li>
<li><a href='#mxAvailableOptimizers'><p>mxAvailableOptimizers</p></a></li>
<li><a href='#MxBaseExpectation-class'><p>MxBaseExpectation</p></a></li>
<li><a href='#MxBaseFitFunction-class'><p>MxBaseFitFunction</p></a></li>
<li><a href='#MxBaseNamed-class'><p>MxBaseNamed</p></a></li>
<li><a href='#MxBaseObjectiveMetaData-class'><p>MxBaseObjectiveMetaData</p></a></li>
<li><a href='#mxBootstrap'><p>Repeatedly estimate model using resampling with replacement</p></a></li>
<li><a href='#mxBootstrapEval'><p>Evaluate Values in a bootstrapped MxModel</p></a></li>
<li><a href='#mxBootstrapStdizeRAMpaths'><p>Bootstrap distribution of standardized RAM path coefficients</p></a></li>
<li><a href='#mxBounds'><p>Create MxBounds Object</p></a></li>
<li><a href='#MxBounds-class'><p>MxBounds Class</p></a></li>
<li><a href='#MxCharOrList-class'><p>A character, list or NULL</p></a></li>
<li><a href='#MxCharOrLogical-class'><p>A character or logical</p></a></li>
<li><a href='#MxCharOrNumber-class'><p>A character or integer</p></a></li>
<li><a href='#mxCheckIdentification'><p>Check that a model is locally identified</p></a></li>
<li><a href='#mxCI'><p>Create mxCI Object</p></a></li>
<li><a href='#MxCI-class'><p>MxCI Class</p></a></li>
<li><a href='#mxCompare'><p>Likelihood ratio test</p></a></li>
<li><a href='#MxCompare-class'><p>The MxCompare Class</p></a></li>
<li><a href='#MxCompute-class'><p>MxCompute</p></a></li>
<li><a href='#mxComputeBootstrap'><p>Repeatedly estimate model using resampling with replacement</p></a></li>
<li><a href='#mxComputeCheckpoint'><p>Log parameters and state to disk or memory</p></a></li>
<li><a href='#mxComputeConfidenceInterval'><p>Find likelihood-based confidence intervals</p></a></li>
<li><a href='#mxComputeDefault'><p>Default compute plan</p></a></li>
<li><a href='#mxComputeEM'><p>Fit a model using DLR's (1977) Expectation-Maximization (EM) algorithm</p></a></li>
<li><a href='#mxComputeGenerateData'><p>Generate data</p></a></li>
<li><a href='#mxComputeGradientDescent'><p>Optimize parameters using a gradient descent optimizer</p></a></li>
<li><a href='#mxComputeHessianQuality'><p>Compute the quality of the Hessian</p></a></li>
<li><a href='#mxComputeIterate'><p>Repeatedly invoke a series of compute objects until change is less than tolerance</p></a></li>
<li><a href='#mxComputeJacobian'><p>Numerically estimate the Jacobian with respect to free parameters</p></a></li>
<li><a href='#mxComputeLoadContext'><p>Load contextual data to supplement checkpoint</p></a></li>
<li><a href='#mxComputeLoadData'><p>Load columns into an MxData object</p></a></li>
<li><a href='#mxComputeLoadMatrix'><p>Load data from CSV files directly into the backend</p></a></li>
<li><a href='#mxComputeLoop'><p>Repeatedly invoke a series of compute objects</p></a></li>
<li><a href='#mxComputeNelderMead'>
<p>Optimize parameters using a variation of the Nelder-Mead algorithm.</p></a></li>
<li><a href='#mxComputeNewtonRaphson'><p>Optimize parameters using the Newton-Raphson algorithm</p></a></li>
<li><a href='#mxComputeNothing'><p>Compute nothing</p></a></li>
<li><a href='#mxComputeNumericDeriv'><p>Numerically estimate Hessian using Richardson extrapolation</p></a></li>
<li><a href='#mxComputeOnce'><p>Compute something once</p></a></li>
<li><a href='#mxComputePenaltySearch'><p>Regularize parameter estimates</p></a></li>
<li><a href='#mxComputeReportDeriv'><p>Report derivatives</p></a></li>
<li><a href='#mxComputeReportExpectation'><p>Report expectation</p></a></li>
<li><a href='#mxComputeSequence'><p>Invoke a series of compute objects in sequence</p></a></li>
<li><a href='#mxComputeSetOriginalStarts'><p>Reset parameter starting values</p></a></li>
<li><a href='#mxComputeSimAnnealing'><p>Optimization using generalized simulated annealing</p></a></li>
<li><a href='#mxComputeStandardError'><p>Compute standard errors</p></a></li>
<li><a href='#mxComputeTryCatch'><p>Execute a sub-compute plan, catching errors</p></a></li>
<li><a href='#mxComputeTryHard'><p>Repeatedly attempt a compute plan until successful</p></a></li>
<li><a href='#mxConstraint'><p>Create MxConstraint Object</p></a></li>
<li><a href='#MxConstraint-class'><p>Class <code>"MxConstraint"</code></p></a></li>
<li><a href='#mxData'><p>Create MxData Object</p></a></li>
<li><a href='#MxData-class'><p>MxData Class</p></a></li>
<li><a href='#mxDataDynamic'><p>Create dynamic data</p></a></li>
<li><a href='#MxDataStatic-class'><p>Create static data</p></a></li>
<li><a href='#mxDataWLS'><p>Create legacy MxData Object for Least Squares (WLS, DWLS, ULS) Analyses</p></a></li>
<li><a href='#mxDescribeDataWLS'><p>Determine whether a dataset will have weights and summary statistics for the means if used with mxFitFunctionWLS</p></a></li>
<li><a href='#MxDirectedGraph-class'><p>MxDirectedGraph</p></a></li>
<li><a href='#mxEval'><p>Evaluate Values in MxModel</p></a></li>
<li><a href='#mxEvaluateOnGrid'><p>Evaluate an algebra on an abscissa grid and collect column results</p></a></li>
<li><a href='#MxExpectation-class'><p>MxExpectation</p></a></li>
<li><a href='#mxExpectationBA81'><p>Create a Bock &amp; Aitkin (1981) expectation</p></a></li>
<li><a href='#mxExpectationGREML'>
<p>Create MxExpectationGREML Object</p></a></li>
<li><a href='#MxExpectationGREML-class'><p>Class &quot;MxExpectationGREML&quot;</p></a></li>
<li><a href='#mxExpectationHiddenMarkov'><p>Hidden Markov expectation</p></a></li>
<li><a href='#mxExpectationLISREL'><p>Create MxExpectationLISREL Object</p></a></li>
<li><a href='#mxExpectationMixture'><p>Mixture expectation</p></a></li>
<li><a href='#mxExpectationNormal'><p>Create MxExpectationNormal Object</p></a></li>
<li><a href='#mxExpectationRAM'><p>Create an MxExpectationRAM Object</p></a></li>
<li><a href='#mxExpectationStateSpace'><p>Create an MxExpectationStateSpace Object</p></a></li>
<li><a href='#mxExpectationStateSpaceContinuousTime'><p>Create an MxExpectationStateSpace Object</p></a></li>
<li><a href='#mxFactor'><p>Fail-safe Factors</p></a></li>
<li><a href='#mxFactorScores'><p>Estimate factor scores and standard errors</p></a></li>
<li><a href='#mxFIMLObjective'><p>DEPRECATED: Create MxFIMLObjective Object</p></a></li>
<li><a href='#MxFitFunction-class'><p>MxFitFunction</p></a></li>
<li><a href='#mxFitFunctionAlgebra'><p>Create MxFitFunctionAlgebra Object</p></a></li>
<li><a href='#mxFitFunctionGREML'>
<p>Create MxFitFunctionGREML Object</p></a></li>
<li><a href='#MxFitFunctionGREML-class'><p>Class <code>"MxFitFunctionGREML"</code></p></a></li>
<li><a href='#mxFitFunctionML'><p>Create MxFitFunctionML Object</p></a></li>
<li><a href='#mxFitFunctionMultigroup'><p>Create a fit function used to fit multiple-group models</p></a></li>
<li><a href='#mxFitFunctionR'><p>Create MxFitFunctionR Object</p></a></li>
<li><a href='#mxFitFunctionRow'><p>Create an MxFitFunctionRow Object</p></a></li>
<li><a href='#mxFitFunctionWLS'><p>Create MxFitFunctionWLS Object</p></a></li>
<li><a href='#MxFlatModel-class'><p>MxFlatModel</p></a></li>
<li><a href='#mxGenerateData'><p>Generate data based on an mxModel (or a data.frame)</p></a></li>
<li><a href='#mxGetExpected'><p>Extract the component from a model's expectation</p></a></li>
<li><a href='#mxGREMLDataHandler'>
<p>Helper Function for Structuring GREML Data</p></a></li>
<li><a href='#MxInterval-class'><p>MxInterval</p></a></li>
<li><a href='#mxJiggle'>
<p>Jiggle parameter values.</p></a></li>
<li><a href='#mxKalmanScores'><p>Estimate Kalman scores and error covariance matrices</p></a></li>
<li><a href='#MxLISRELModel-class'><p>MxLISRELModel</p></a></li>
<li><a href='#mxLISRELObjective'><p>Create MxLISRELObjective Object</p></a></li>
<li><a href='#MxListOrNull-class'><p>An optional list</p></a></li>
<li><a href='#mxMakeNames'><p>mxMakeNames</p></a></li>
<li><a href='#mxMarginalNegativeBinomial'><p>Indicator with marginal Negative Binomial distribution</p></a></li>
<li><a href='#mxMarginalPoisson'><p>Indicator with marginal Poisson distribution</p></a></li>
<li><a href='#mxMatrix'><p>Create MxMatrix Object</p></a></li>
<li><a href='#MxMatrix-class'><p>MxMatrix Class</p></a></li>
<li><a href='#mxMI'><p>Estimate Modification Indices for MxModel Objects</p></a></li>
<li><a href='#mxMLObjective'><p>DEPRECATED: Create MxMLObjective Object</p></a></li>
<li><a href='#mxModel'><p>Create MxModel Object</p></a></li>
<li><a href='#MxModel-class'><p>MxModel Class</p></a></li>
<li><a href='#mxModelAverage'>
<p>Information-Theoretic Model-Averaging and Multimodel Inference</p></a></li>
<li><a href='#mxNormalQuantiles'><p>mxNormalQuantiles</p></a></li>
<li><a href='#mxOption'><p>Set or Clear an Optimizer Option</p></a></li>
<li><a href='#MxOptionalChar-class'><p>An optional character</p></a></li>
<li><a href='#MxOptionalCharOrNumber-class'><p>A character, integer, or NULL</p></a></li>
<li><a href='#MxOptionalDataFrame-class'><p>An optional data.frame</p></a></li>
<li><a href='#MxOptionalDataFrameOrMatrix-class'><p>An optional data.frame or matrix</p></a></li>
<li><a href='#MxOptionalInteger-class'><p>An optional integer</p></a></li>
<li><a href='#MxOptionalLogical-class'><p>An optional logical</p></a></li>
<li><a href='#MxOptionalMatrix-class'><p>An optional matrix</p></a></li>
<li><a href='#MxOptionalNumeric-class'><p>An optional numeric</p></a></li>
<li><a href='#mxParametricBootstrap'><p>Assess whether potential parameters should be freed using</p>
parametric bootstrap</a></li>
<li><a href='#mxPath'><p>Create List of Paths</p></a></li>
<li><a href='#mxPearsonSelCov'><p>Perform Pearson Aitken selection</p></a></li>
<li><a href='#mxPenalty'><p>This function creates a penalty object</p></a></li>
<li><a href='#MxPenalty-class'><p>MxPenalty</p></a></li>
<li><a href='#mxPenaltyElasticNet'><p>mxPenaltyElasticNet</p></a></li>
<li><a href='#mxPenaltyLASSO'><p>mxPenaltyLASSO</p></a></li>
<li><a href='#mxPenaltyRidge'><p>mxPenaltyRidge</p></a></li>
<li><a href='#mxPenaltySearch'><p>mxPenaltySearch</p></a></li>
<li><a href='#mxPenaltyZap'><p>mxPenaltyZap</p></a></li>
<li><a href='#mxPowerSearch'><p>Power curve</p></a></li>
<li><a href='#MxRAMGraph-class'><p>MxRAMGraph</p></a></li>
<li><a href='#MxRAMModel-class'><p>MxRAMModel</p></a></li>
<li><a href='#mxRAMObjective'><p>DEPRECATED: Create MxRAMObjective Object</p></a></li>
<li><a href='#mxRename'><p>Rename a model or submodel</p></a></li>
<li><a href='#mxRestore'><p>Restore model state from a checkpoint file</p></a></li>
<li><a href='#mxRetro'><p>Return random classic Mx error message</p></a></li>
<li><a href='#mxRObjective'><p>DEPRECATED: Create MxRObjective Object</p></a></li>
<li><a href='#mxRowObjective'><p>DEPRECATED: Create MxRowObjective Object</p></a></li>
<li><a href='#mxRun'><p>Run an OpenMx model</p></a></li>
<li><a href='#mxSave'><p>Save model state to a checkpoint file</p></a></li>
<li><a href='#mxSE'><p>Compute standard errors in OpenMx</p></a></li>
<li><a href='#mxSetDefaultOptions'><p>Reset global options to the default</p></a></li>
<li><a href='#mxSimplify2Array'><p>Like simplify2array but works with vectors of different lengths</p></a></li>
<li><a href='#mxStandardizeRAMpaths'><p>Standardize RAM models' path coefficients</p></a></li>
<li><a href='#mxThreshold'><p>Create List of Thresholds</p></a></li>
<li><a href='#mxTryHard'><p>Make multiple attempts to run a model</p></a></li>
<li><a href='#mxTypes'><p>List Currently Available Model Types</p></a></li>
<li><a href='#mxVersion'><p>Returns Current Version String</p></a></li>
<li><a href='#MxVersionType-class'><p>A package_version or character</p></a></li>
<li><a href='#myAutoregressiveData'>
<p>Example data with autoregressively related columns</p></a></li>
<li><a href='#myFADataRaw'><p>Example 500-row dataset with 12 generated variables</p></a></li>
<li><a href='#myGrowthKnownClassData'>
<p>Data for a growth mixture model with the true class membership</p></a></li>
<li><a href='#myGrowthMixtureData'>
<p>Data for a growth mixture model</p></a></li>
<li><a href='#myLongitudinalData'>
<p>Data for a linear latent growth curve model</p></a></li>
<li><a href='#myRegData'>
<p>Example regression data with correlated predictors</p></a></li>
<li><a href='#myRegDataRaw'>
<p>Example regression data with correlated predictors</p></a></li>
<li><a href='#myTwinData'>
<p>Duplicate of twinData</p></a></li>
<li><a href='#mzfData'>
<p>Example twin extended kinship data: MZ female twins</p></a></li>
<li><a href='#mzmData'>
<p>Example twin extended kinship data: MZ Male data</p></a></li>
<li><a href='#Named-entity'><p>Named Entities</p></a></li>
<li><a href='#nhanesDemo'>
<p>Modified National Health and Nutrition Examination Survey demographic data</p></a></li>
<li><a href='#nuclear_twin_design_data'>
<p>Twin data from a nuclear family design</p></a></li>
<li><a href='#numHess1'>
<p>numeric Hessian data 1</p></a></li>
<li><a href='#numHess2'>
<p>numeric Hessian data 2</p></a></li>
<li><a href='#omxAllInt'><p>All Interval Multivariate Normal Integration</p></a></li>
<li><a href='#omxApply'><p>On-Demand Parallel Apply</p></a></li>
<li><a href='#omxAssignFirstParameters'><p>Assign First Available Values to Model Parameters</p></a></li>
<li><a href='#omxAugmentDataWithWLSSummary'><p>Estimate summary statistics used by the WLS fit function</p></a></li>
<li><a href='#omxBrownie'><p>Make Brownies in OpenMx</p></a></li>
<li><a href='#omxBuildAutoStartModel'><p>Build the model used for mxAutoStart</p></a></li>
<li><a href='#omxCheckCloseEnough'><p>Approximate Equality Testing Function</p></a></li>
<li><a href='#omxCheckEquals'><p>Equality Testing Function</p></a></li>
<li><a href='#omxCheckError'><p>Correct Error Message Function</p></a></li>
<li><a href='#omxCheckIdentical'><p>Exact Equality Testing Function</p></a></li>
<li><a href='#omxCheckNamespace'><p>omxCheckNamespace</p></a></li>
<li><a href='#omxCheckSetEquals'><p>Set Equality Testing Function</p></a></li>
<li><a href='#omxCheckTrue'><p>Boolean Equality Testing Function</p></a></li>
<li><a href='#omxCheckWarning'><p>Correct Warning Message Function</p></a></li>
<li><a href='#omxCheckWithinPercentError'><p>Approximate Percent Equality Testing Function</p></a></li>
<li><a href='#omxConstrainMLThresholds'><p>omxConstrainMLThresholds</p></a></li>
<li><a href='#omxDefaultComputePlan'>
<p>Construct default compute plan</p></a></li>
<li><a href='#omxDetectCores'><p>omxDetectCores</p></a></li>
<li><a href='#omxGetBootstrapReplications'><p>omxGetBootstrapReplications</p></a></li>
<li><a href='#omxGetNPSOL'><p>omxGetNPSOL</p></a></li>
<li><a href='#omxGetParameters'><p>Fetch Model Parameters</p></a></li>
<li><a href='#omxGetRAMDepth'><p>omxGetRAMDepth</p></a></li>
<li><a href='#omxGraphviz'><p>Show RAM Model in Graphviz Format</p></a></li>
<li><a href='#omxHasDefaultComputePlan'><p>omxHasDefaultComputePlan</p></a></li>
<li><a href='#omxLapply'><p>On-Demand Parallel Lapply</p></a></li>
<li><a href='#omxLocateParameters'><p>Get the location (model, matrix, row, column) and other info for a parameter</p></a></li>
<li><a href='#omxLogical'><p>Logical mxAlgebra() operators</p></a></li>
<li><a href='#omxManifestModelByParameterJacobian'><p>Estimate the Jacobian of manifest model with respect to parameters</p></a></li>
<li><a href='#omxMatrixOperations'><p>MxMatrix operations</p></a></li>
<li><a href='#omxMnor'><p>Multivariate Normal Integration</p></a></li>
<li><a href='#omxModelDeleteData'><p>Remove all instances of data from a model</p></a></li>
<li><a href='#omxNameAnonymousParameters'><p>omxNameAnonymousParameters</p></a></li>
<li><a href='#omxParallelCI'>
<p>Calculate confidence intervals without re-doing the primary optimization.</p></a></li>
<li><a href='#omxQuotes'><p>omxQuotes</p></a></li>
<li><a href='#omxRAMtoML'><p>omxRAMtoML</p></a></li>
<li><a href='#omxReadGRMBin'>
<p>Read a GCTA-Format Binary GRM into R.</p></a></li>
<li><a href='#omxRMSEA'><p>Get the RMSEA with confidence intervals from model</p></a></li>
<li><a href='#omxSapply'><p>On-Demand Parallel Sapply</p></a></li>
<li><a href='#omxSaturatedModel'><p>Create Reference (Saturated and Independence) Models</p></a></li>
<li><a href='#omxSelectRowsAndCols'><p>Filter rows and columns from an mxMatrix</p></a></li>
<li><a href='#omxSetParameters'><p>Assign Model Parameters</p></a></li>
<li><a href='#omxSymbolTable'>
<p>Internal OpenMx algebra operations</p></a></li>
<li><a href='#OpenMx'><p>OpenMx: An package for Structural Equation Modeling and Matrix Algebra Optimization</p></a></li>
<li><a href='#ordinalTwinData'>
<p>Data for ordinal twin model</p></a></li>
<li><a href='#Oscillator'>
<p>Oscillator Data for Latent Differential Equations</p></a></li>
<li><a href='#predict.MxModel'><p><code>predict</code> method for <code>MxModel</code> objects</p></a></li>
<li><a href='#rvectorize'><p>Vectorize By Row</p></a></li>
<li><a href='#summary.MxModel'><p>Model Summary</p></a></li>
<li><a href='#tr'><p>trace</p></a></li>
<li><a href='#twin_NA_dot'>
<p>Twin biometric data (Practice cleaning: &quot;.&quot; for missing data, wrong data types etc.)</p></a></li>
<li><a href='#twinData'><p>Australian twin sample biometric data.</p></a></li>
<li><a href='#vec2diag'><p>Create Diagonal Matrix From Vector</p></a></li>
<li><a href='#vech'><p>Half-vectorization</p></a></li>
<li><a href='#vech2full'><p>Inverse Half-vectorization</p></a></li>
<li><a href='#vechs'><p>Strict Half-vectorization</p></a></li>
<li><a href='#vechs2full'><p>Inverse Strict Half-vectorization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Structural Equation Modelling</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://openmx.ssri.psu.edu">http://openmx.ssri.psu.edu</a>, <a href="https://github.com/OpenMx/OpenMx">https://github.com/OpenMx/OpenMx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://openmx.ssri.psu.edu/forums">http://openmx.ssri.psu.edu/forums</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Create structural equation models that can be manipulated programmatically.
    Models may be specified with matrices or paths (LISREL or RAM)
    Example models include confirmatory factor, multiple group, mixture
    distribution, categorical threshold, modern test theory, differential
    Fit functions include full information maximum likelihood, maximum likelihood, and weighted least squares.
    equations, state space, and many others.
	Support and advanced package binaries available at <a href="http://openmx.ssri.psu.edu">http://openmx.ssri.psu.edu</a>.
    The software is described in Neale, Hunter, Pritikin, Zahery, Brick,
    Kirkpatrick, Estabrook, Bates, Maes, &amp; Boker (2016) &lt;<a href="https://doi.org/10.1007%2Fs11336-014-9435-8">doi:10.1007/s11336-014-9435-8</a>&gt;.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, C++17</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.9.4), RcppParallel, StanHeaders
(&ge; 2.10.0.2), BH (&ge; 1.69.0-1), rpf (&ge; 0.45), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, MASS, Matrix (&ge; 1.2-16), methods, Rcpp, RcppParallel,
parallel, lifecycle</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, numDeriv, roxygen2 (&ge; 6.1), rpf (&ge; 0.45),
snowfall, lme4, covr, testthat, umx, ifaTools, knitr, markdown,
rmarkdown, reshape2, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0ClassUnion.R' 'cache.R' 'MxBaseNamed.R' 'MxData.R'
'MxDataWLS.R' 'DefinitionVars.R' 'MxReservedNames.R'
'MxNamespace.R' 'MxSearchReplace.R' 'MxFlatSearchReplace.R'
'MxUntitled.R' 'MxAlgebraFunctions.R' 'MxExponential.R'
'MxMatrix.R' 'DiagMatrix.R' 'FullMatrix.R' 'IdenMatrix.R'
'LowerMatrix.R' 'SdiagMatrix.R' 'StandMatrix.R' 'SymmMatrix.R'
'UnitMatrix.R' 'ZeroMatrix.R' 'MxMatrixFunctions.R'
'MxAlgebra.R' 'MxCycleDetection.R' 'MxDependencies.R'
'MxAlgebraConvert.R' 'MxSquareBracket.R' 'MxEval.R'
'MxRename.R' 'MxPath.R' 'MxObjectiveMetaData.R'
'MxExpectation.R' 'MxExpectationNormal.R' 'MxExpectationRAM.R'
'MxExpectationLISREL.R' 'MxFitFunction.R'
'MxFitFunctionAlgebra.R' 'MxFitFunctionML.R'
'MxFitFunctionMultigroup.R' 'MxFitFunctionRow.R'
'MxFitFunctionWLS.R' 'MxRAMObjective.R' 'MxLISRELObjective.R'
'MxFIMLObjective.R' 'MxMLObjective.R' 'MxRowObjective.R'
'MxAlgebraObjective.R' 'MxBounds.R' 'MxConstraint.R'
'MxInterval.R' 'MxTypes.R' 'MxCompute.R' 'MxModel.R'
'MxRAMModel.R' 'MxLISRELModel.R' 'MxModelDisplay.R'
'MxFlatModel.R' 'MxMultiModel.R' 'MxModelFunctions.R'
'MxModelParameters.R' 'MxUnitTesting.R' 'MxApply.R' 'MxRun.R'
'MxRunHelperFunctions.R' 'MxSummary.R' 'MxCompare.R'
'MxSwift.R' 'MxOptions.R' 'MxThreshold.R' 'OriginalMx.R'
'MxGraph.R' 'MxGraphviz.R' 'MxDeparse.R' 'MxCommunication.R'
'MxRestore.R' 'MxVersion.R' 'MxPPML.R' 'MxRAMtoML.R'
'MxErrorHandling.R' 'MxDetectCores.R' 'MxSaturatedModel.R'
'omxBrownie.R' 'omxConstrainThresholds.R' 'omxGetNPSOL.R'
'MxFitFunctionR.R' 'MxRObjective.R'
'MxExpectationHiddenMarkov.R' 'MxExpectationMixture.R'
'MxExpectationStateSpace.R' 'MxExpectationBA81.R'
'MxFitFunctionGREML.R' 'MxExpectationGREML.R' 'MxMI.R'
'MxFactorScores.R' 'MxRobustSE.R' 'MxAvailableOptimizers.R'
'MxTryHard.R' 'MxSE.R' 'MxAutoStart.R' 'MxRetro.R'
'MxPenalty.R' 'MxMMI.R' 'omxReadGRMBin.R' 'MxPredict.R' 'zzz.R'</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Version:</td>
<td>2.21.11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 21:51:30 UTC; joshua</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven M. Boker [aut],
  Michael C. Neale [aut],
  Hermine H. Maes [aut],
  Michael J. Wilde [ctb],
  Michael Spiegel [aut],
  Timothy R. Brick [aut],
  Ryne Estabrook [aut],
  Timothy C. Bates [aut],
  Paras Mehta [ctb],
  Timo von Oertzen [ctb],
  Ross J. Gore [aut],
  Michael D. Hunter [aut],
  Daniel C. Hackett [ctb],
  Julian Karch [ctb],
  Andreas M. Brandmaier [ctb],
  Joshua N. Pritikin [aut, cre],
  Mahsa Zahery [aut],
  Robert M. Kirkpatrick [aut],
  Yang Wang [ctb],
  Ben Goodrich [ctb],
  Charles Driver [ctb],
  Massachusetts Institute of Technology [cph],
  S. G. Johnson [cph],
  Association for Computing Machinery [cph],
  Dieter Kraft [cph],
  Stefan Wilhelm [cph],
  Sarah Medland [cph],
  Carl F. Falk [cph],
  Matt Keller [cph],
  Manjunath B G [cph],
  The Regents of the University of California [cph],
  Lester Ingber [cph],
  Wong Shao Voon [cph],
  Juan Palacios [cph],
  Jiang Yang [cph],
  Gael Guennebaud [cph],
  Jitse Niesen [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua N. Pritikin &lt;jpritikin@pobox.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 05:20:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.statusCode'>Convert a numeric or character vector into an optimizer status code factor</h2><span id='topic+as.statusCode'></span>

<h3>Description</h3>

<p>Below we provide a brief, technical description of each status code followed by
a more colloquial, less precise desciption.
</p>

<ul>
<li><p> 0,&lsquo;OK&rsquo;: Optimization succeeded.  Everything seems fine.
</p>
</li>
<li><p> 1,&lsquo;OK/green&rsquo;: Optimization succeeded, but the sequence
of iterates has not yet converged (Mx status GREEN). This condition is only detected by
NPSOL.  The solution is likely okay.  You might want to re-run the model
from its final esimates to resolve this.
</p>
</li>
<li><p> 2,&lsquo;infeasible linear constraint&rsquo;:
The linear constraints and bounds could not be satisfied. The problem has no feasible solution.
Right now, it should not be possible obtain this status code, so call Ripley's.
</p>
</li>
<li><p> 3,&lsquo;infeasible non-linear constraint&rsquo;:
The nonlinear constraints and bounds could not be satisfied. The problem may have no feasible solution.
Sometimes this happens when your starting values do not satisfy the constraints.
Also, optimization could not satisfy the constraints and get a better fit.
</p>
</li>
<li><p> 4,&lsquo;iteration limit&rsquo;:
Optimization was stopped prematurely because the iteration limit was
reached (Mx status BLUE). You might want to rerun: <code>m1 = mxRun(m1)</code> or increase the
iteration limit (see <code><a href="#topic+mxOption">mxOption</a></code>).
The optimizer took all the steps it could and did not finish.  You can
increase the number of steps or get better starting values.
</p>
</li>
<li><p> 5,&lsquo;not convex&rsquo;:
The Hessian at the solution does not appear to be convex (Mx status
RED). There may be more than one solution to the model. See
<code><a href="#topic+mxCheckIdentification">mxCheckIdentification</a></code>.
I would not trust this solution; it does not appear to be a good one.
Perhaps, try <code><a href="#topic+mxTryHard">mxTryHard</a></code>.
</p>
</li>
<li><p> 6,&lsquo;nonzero gradient&rsquo;:
The model does not satisfy the first-order optimality conditions to
the required accuracy, and no improved point for the merit function
could be found during the final linesearch (Mx status RED).
I would not trust this solution; it does not appear to be a good one.
To search nearby, see <code><a href="#topic+mxTryHard">mxTryHard</a></code>.
</p>
</li>
<li><p> 7,&lsquo;bad deriv&rsquo;:
You have provided analytic derivatives. However,
your provided derivatives differ too much from numerically
approximated derivatives. Double check your math.
</p>
</li>
<li><p> 9,&lsquo;internal error&rsquo;: An input parameter was invalid. The
most likely cause is a bug in the code. Please report occurrences to
the OpenMx developers.
</p>
</li>
<li><p> 10,&lsquo;infeasible start&rsquo;:
Starting values were infeasible.
Modify the start values for one or more parameters. For instance,
set means to their measured value, or set variances and covariances to
plausible values. See <code><a href="#topic+mxAutoStart">mxAutoStart</a></code> and <code><a href="#topic+mxTryHard">mxTryHard</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>as.statusCode(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.statusCode_+3A_code">code</code></td>
<td>
<p>a character or numeric vector of optimizer status code</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrap">mxBootstrap</a></code>
<code><a href="#topic+summary.MxModel">summary.MxModel</a></code>
</p>

<hr>
<h2 id='BaseCompute-class'>BaseCompute</h2><span id='topic+BaseCompute-class'></span><span id='topic++24+2CBaseCompute-method'></span><span id='topic++24+3C-+2CBaseCompute-method'></span><span id='topic+print+2CBaseCompute-method'></span><span id='topic+show+2CBaseCompute-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxComputeEM">mxComputeEM</a>, <a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>, <a href="#topic+mxComputeHessianQuality">mxComputeHessianQuality</a>,
<a href="#topic+mxComputeIterate">mxComputeIterate</a>, <a href="#topic+mxComputeNewtonRaphson">mxComputeNewtonRaphson</a>, <a href="#topic+mxComputeNumericDeriv">mxComputeNumericDeriv</a>
</p>

<hr>
<h2 id='Bollen'>
Bollen Data on Industrialization and Political Democracy
</h2><span id='topic+Bollen'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples, for instance WLS. The data were reported in Bollen (1989, p. 428, Table 9.4)
This set includes data from 75 developing countries each assessed on four measures of democracy measured twice (1960 and 1965), and three measures of industrialization measured once (1960).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Bollen")</code></pre>


<h3>Format</h3>

<p>A data frame with 75 observations on the following 11 numeric variables.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>Freedom of the press, 1960 </p>
</dd>
<dt><code>y2</code></dt><dd><p>Freedom of political opposition, 1960</p>
</dd>
<dt><code>y3</code></dt><dd><p>Fairness of elections, 1960</p>
</dd>
<dt><code>y4</code></dt><dd><p>Effectiveness of elected legislature, 1960</p>
</dd>
<dt><code>y5</code></dt><dd><p>Freedom of the press, 1965</p>
</dd>
<dt><code>y6</code></dt><dd><p>Freedom of political opposition, 1965</p>
</dd>
<dt><code>y7</code></dt><dd><p>Fairness of elections, 1965</p>
</dd>
<dt><code>y8</code></dt><dd><p>Effectiveness of elected legislature, 1965</p>
</dd>
<dt><code>x1</code></dt><dd><p>GNP per capita, 1960</p>
</dd>
<dt><code>x2</code></dt><dd><p>Energy consumption per capita, 1960</p>
</dd>
<dt><code>x3</code></dt><dd><p>Percentage of labor force in industry, 1960</p>
</dd>
</dl>



<h3>Details</h3>

<p>Variables y1-y4 and y5-y8 are typically used as indicators of the latent trait of &ldquo;political democracy&rdquo; in 1960 and 1965 respectively. x1-x3 are used as indicators of industrialization (1960).
</p>


<h3>Source</h3>

<p>The <code>sem</code> package (in turn, via personal communication Bollen to Fox)</p>


<h3>References</h3>

<p>Bollen, K. A. (1979). Political democracy and the timing of development. <em>American Sociological Review</em>, <b>44</b>, 572-587.
</p>
<p>Bollen, K. A. (1980). Issues in the comparative measurement of political democracy. <em>American Sociological Review</em>, <b>45</b>, 370-390.
</p>
<p>Bollen, K. A. (1989). <em>Structural equation models</em>. New York: Wiley-Interscience.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Bollen)
str(Bollen)
plot(y1 ~ y2, data = Bollen)
</code></pre>

<hr>
<h2 id='cvectorize'>Vectorize By Column</h2><span id='topic+cvectorize'></span>

<h3>Description</h3>

<p>This function returns the vectorization of an input matrix in a column by column traversal of the matrix.  The output is returned as a column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvectorize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvectorize_+3A_x">x</code></td>
<td>
<p>an input matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+vechs">vechs</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cvectorize(matrix(1:9, 3, 3))
cvectorize(matrix(1:12, 3, 4))


</code></pre>

<hr>
<h2 id='demoOneFactor'>
Demonstration data for a one factor model
</h2><span id='topic+demoOneFactor'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("demoOneFactor")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 5 numeric variables.
</p>

<dl>
<dt><code>x1</code></dt><dd></dd>
<dt><code>x2</code></dt><dd></dd>
<dt><code>x3</code></dt><dd></dd>
<dt><code>x4</code></dt><dd></dd>
<dt><code>x5</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>Variables x1-x5 are typically used as indicators of the latent trait.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demoOneFactor)
cov(demoOneFactor)
cor(demoOneFactor)
</code></pre>

<hr>
<h2 id='demoTwoFactor'>
Demonstration data for a two factor model
</h2><span id='topic+demoTwoFactor'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("demoTwoFactor")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 10 numeric variables.
</p>

<dl>
<dt><code>x1</code></dt><dd></dd>
<dt><code>x2</code></dt><dd></dd>
<dt><code>x3</code></dt><dd></dd>
<dt><code>x4</code></dt><dd></dd>
<dt><code>x5</code></dt><dd></dd>
<dt><code>y1</code></dt><dd></dd>
<dt><code>y2</code></dt><dd></dd>
<dt><code>y3</code></dt><dd></dd>
<dt><code>y4</code></dt><dd></dd>
<dt><code>y5</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>Variables x1-x5 are typically used as indicators of one latent trait.  Variables y1-y5 are typically used as indicators of another latent trait.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demoTwoFactor)
cov(demoTwoFactor)
cor(demoTwoFactor)
</code></pre>

<hr>
<h2 id='diag2vec'>Extract Diagonal of a Matrix</h2><span id='topic+diag2vec'></span>

<h3>Description</h3>

<p>Given an input matrix, <code>diag2vec</code> returns a column vector of the elements along the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag2vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag2vec_+3A_x">x</code></td>
<td>
<p>an input matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the function <code><a href="base.html#topic+diag">diag</a></code>, except that the input argument is always
treated as a matrix (i.e., it doesn't have diag()'s functions of returning an Identity matrix from an nrow specification, nor to return 
a matrix wrapped around a diagonal if provided with a vector). To get vector2matrix functionality, call <code><a href="#topic+vec2diag">vec2diag</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vec2diag">vec2diag</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
diag2vec(matrix(1:9, nrow=3))
#      [,1]
# [1,]    1
# [2,]    5
# [3,]    9

diag2vec(matrix(1:12, nrow=3, ncol=4))
#      [,1]
# [1,]    1
# [2,]    5
# [3,]    9

</code></pre>

<hr>
<h2 id='DiscreteBase-class'>An S4 base class for discrete marginal distributions</h2><span id='topic+DiscreteBase-class'></span><span id='topic+DiscreteBase'></span><span id='topic++24+2CDiscreteBase-method'></span><span id='topic++24+3C-+2CDiscreteBase-method'></span>

<h3>Description</h3>

<p>An S4 base class for discrete marginal distributions
</p>


<h3>See Also</h3>

<p><a href="#topic+mxMarginalPoisson">mxMarginalPoisson</a>, <a href="#topic+mxMarginalNegativeBinomial">mxMarginalNegativeBinomial</a>
</p>

<hr>
<h2 id='dzfData'>
Example twin extended kinship data: DZ female data
</h2><span id='topic+dzfData'></span>

<h3>Description</h3>

<p>Data for extended twin example ETC88.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dzfData")</code></pre>


<h3>Format</h3>

<p>A data frame with 2007 observations on the following 37 variables.
</p>

<dl>
<dt><code>famid</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a18</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dzfData)
str(dzfData)
</code></pre>

<hr>
<h2 id='dzmData'>
Example twin extended kinship data: DZ Male data
</h2><span id='topic+dzmData'></span>

<h3>Description</h3>

<p>Data for extended twin example ETC88.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dzmData")</code></pre>


<h3>Format</h3>

<p>A data frame with 1990 observations on the following 37 variables.
</p>

<dl>
<dt><code>famid</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a18</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dzmData)
str(dzmData)
</code></pre>

<hr>
<h2 id='dzoData'>
Example twin extended kinship data: DZ opposite sex twins
</h2><span id='topic+dzoData'></span>

<h3>Description</h3>

<p>Data for extended twin example ETC88.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dzoData")</code></pre>


<h3>Format</h3>

<p>A data frame with 3981 observations on the following 37 variables.
</p>

<dl>
<dt><code>famid</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a18</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dzoData)
str(dzoData)
</code></pre>

<hr>
<h2 id='eigenvec'>Eigenvector/Eigenvalue Decomposition</h2><span id='topic+eigenval'></span><span id='topic+eigenvec'></span><span id='topic+ieigenval'></span><span id='topic+ieigenvec'></span>

<h3>Description</h3>

<p><code>eigenval</code> computes the real parts of the eigenvalues of a square matrix.
<code>eigenvec</code> computes the real parts of the eigenvectors of a square matrix.
<code>ieigenval</code> computes the imaginary parts of the eigenvalues of a square matrix.
<code>ieigenvec</code> computes the imaginary parts of the eigenvectors of a square matrix.
<code>eigenval</code> and <code>ieigenval</code> return nx1 matrices containing the real or imaginary parts of the eigenvalues, sorted in decreasing order of the modulus of the complex eigenvalue.  For eigenvalues without an imaginary part, this is equivalent to sorting in decreasing order of the absolute value of the eigenvalue. (See <code><a href="base.html#topic+Mod">Mod</a></code> for more info.)
<code>eigenvec</code> and <code>ieigenvec</code> return nxn matrices, where each column corresponds to an eigenvector.  These are sorted in decreasing order of the modulus of their associated complex eigenvalue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenval(x)
eigenvec(x)
ieigenval(x)
ieigenvec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenvec_+3A_x">x</code></td>
<td>
<p>the square matrix whose eigenvalues/vectors are to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eigenvectors returned by <code>eigenvec</code> and <code>ieigenvec</code> are normalized to unit length.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- mxMatrix(values = runif(25), nrow = 5, ncol = 5, name = 'A')
G &lt;- mxMatrix(values = c(0, -1, 1, -1), nrow=2, ncol=2, name='G')

model &lt;- mxModel(A, G, name = 'model')

mxEval(eigenvec(A), model)
mxEval(eigenvec(G), model)
mxEval(eigenval(A), model)
mxEval(eigenval(G), model)
mxEval(ieigenvec(A), model)
mxEval(ieigenvec(G), model)
mxEval(ieigenval(A), model)
mxEval(ieigenval(G), model)



</code></pre>

<hr>
<h2 id='example1'>
Bivariate twin data, wide-format from Classic Mx Manual
</h2><span id='topic+example1'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("example1")</code></pre>


<h3>Format</h3>

<p>A data frame with 400 observations on the following variables.
</p>

<dl>
<dt><code>IDNum</code></dt><dd><p>Twin pair ID</p>
</dd>
<dt><code>Zygosity</code></dt><dd><p>Zygosity of the twin pair</p>
</dd>
<dt><code>X1</code></dt><dd><p>X variable for twin 1</p>
</dd>
<dt><code>Y1</code></dt><dd><p>Y variable for twin 1</p>
</dd>
<dt><code>X2</code></dt><dd><p>X variable for twin 2</p>
</dd>
<dt><code>Y2</code></dt><dd><p>Y variable for twin 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>Same as <a href="#topic+example2">example2</a> but in wide format instead of tall.
</p>


<h3>Source</h3>

<p>Classic Mx Manual.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example1)
plot(X2 ~ X1, data = example1)
</code></pre>

<hr>
<h2 id='example2'>
Bivariate twin data, long-format from Classic Mx Manual
</h2><span id='topic+example2'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("example2")</code></pre>


<h3>Format</h3>

<p>A data frame with 800 observations on the following variables.
</p>

<dl>
<dt><code>IDNum</code></dt><dd><p>ID number</p>
</dd>
<dt><code>TwinNum</code></dt><dd><p>Twin ID number</p>
</dd>
<dt><code>Zygosity</code></dt><dd><p>Zygosity of the twin</p>
</dd>
<dt><code>X</code></dt><dd><p>X variable for twins 1 and 2</p>
</dd>
<dt><code>Y</code></dt><dd><p>Y variable for twins 1 and 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>Same as <a href="#topic+example1">example1</a> but in tall format instead of wide.
</p>


<h3>Source</h3>

<p>Classic Mx Manual.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at https://openmx.ssri.psu.edu/documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example2)
plot(Y ~ X, data = example2)
</code></pre>

<hr>
<h2 id='expm'>Matrix exponential</h2><span id='topic+expm'></span><span id='topic+omxExponential'></span>

<h3>Description</h3>

<p>Matrix exponential
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='factorExample1'>
Example Factor Analysis Data
</h2><span id='topic+factorExample1'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("factorExample1")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd></dd>
<dt><code>x2</code></dt><dd></dd>
<dt><code>x3</code></dt><dd></dd>
<dt><code>x4</code></dt><dd></dd>
<dt><code>x5</code></dt><dd></dd>
<dt><code>x6</code></dt><dd></dd>
<dt><code>x7</code></dt><dd></dd>
<dt><code>x8</code></dt><dd></dd>
<dt><code>x9</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>This appears to be a three factor model, but perhaps with an odd loading structure.
</p>


<h3>Source</h3>

<p>Simulated
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(factorExample1)
round(cor(factorExample1), 2)

factanal(covmat=cov(factorExample1), factors=3, rotation="promax")

</code></pre>

<hr>
<h2 id='factorScaleExample1'>
Example Factor Analysis Data for Scaling the Model
</h2><span id='topic+factorScaleExample1'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("factorScaleExample1")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following variables.
</p>

<dl>
<dt><code>X1</code></dt><dd></dd>
<dt><code>X2</code></dt><dd></dd>
<dt><code>X3</code></dt><dd></dd>
<dt><code>X4</code></dt><dd></dd>
<dt><code>X5</code></dt><dd></dd>
<dt><code>X6</code></dt><dd></dd>
<dt><code>X7</code></dt><dd></dd>
<dt><code>X8</code></dt><dd></dd>
<dt><code>X9</code></dt><dd></dd>
<dt><code>X10</code></dt><dd></dd>
<dt><code>X11</code></dt><dd></dd>
<dt><code>X12</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>This appears to be a three factor model with factor 1 loading on X1-X4, factor 2 on X5-X8, and factor 3 on X9-X12.
</p>


<h3>Source</h3>

<p>Simulated
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(factorScaleExample1)
round(cor(factorScaleExample1), 2)
</code></pre>

<hr>
<h2 id='factorScaleExample2'>
Example Factor Analysis Data for Scaling the Model
</h2><span id='topic+factorScaleExample2'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("factorScaleExample2")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following variables.
</p>

<dl>
<dt><code>X1</code></dt><dd></dd>
<dt><code>X2</code></dt><dd></dd>
<dt><code>X3</code></dt><dd></dd>
<dt><code>X4</code></dt><dd></dd>
<dt><code>X5</code></dt><dd></dd>
<dt><code>X6</code></dt><dd></dd>
<dt><code>X7</code></dt><dd></dd>
<dt><code>X8</code></dt><dd></dd>
<dt><code>X9</code></dt><dd></dd>
<dt><code>X10</code></dt><dd></dd>
<dt><code>X11</code></dt><dd></dd>
<dt><code>X12</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>Three-factor data with factor 1 loading on X1-X4, factor 2 on X5-X8, and factor 3 on X9-X12.  It differs from <a href="#topic+factorScaleExample1">factorScaleExample1</a> in the scaling of the variables.
</p>


<h3>Source</h3>

<p>Simulated
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(factorScaleExample2)
round(cor(factorScaleExample2), 2)

data(factorScaleExample2)
plot(sapply(factorScaleExample1, var), type='l', ylim=c(0, 6), lwd=3)
lines(1:12, sapply(factorScaleExample2, var), col='blue', lwd=3)

</code></pre>

<hr>
<h2 id='genericFitDependencies+2CMxBaseFitFunction-method'>Add dependencies</h2><span id='topic+genericFitDependencies+2CMxBaseFitFunction-method'></span>

<h3>Description</h3>

<p>If there is an expectation, then the fitfunction should always
depend on it. Hence, subclasses that implement this method must
ignore the passed-in dependencies and use &quot;dependencies &lt;-
callNextMethod()&quot; instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MxBaseFitFunction'
genericFitDependencies(.Object, flatModel, dependencies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genericFitDependencies+2B2CMxBaseFitFunction-method_+3A_.object">.Object</code></td>
<td>
<p>fit function object</p>
</td></tr>
<tr><td><code id="genericFitDependencies+2B2CMxBaseFitFunction-method_+3A_flatmodel">flatModel</code></td>
<td>
<p>flat model that lives with .Object</p>
</td></tr>
<tr><td><code id="genericFitDependencies+2B2CMxBaseFitFunction-method_+3A_dependencies">dependencies</code></td>
<td>
<p>accumulated dependency relationships</p>
</td></tr>
</table>

<hr>
<h2 id='HS.ability.data'>
Holzinger &amp; Swineford (1939) Ability in 301 children from 2 schools
</h2><span id='topic+HS.ability.data'></span>

<h3>Description</h3>

<p>This classic data set contains of intelligence-test scores from 301 children on 26 
tests of cognitive ability.
</p>
<p>The tests cover mental speed, memory, mathematical-ability, spatial, and verbal ability as listed below.
</p>
<p>The data are also available in the MBESS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HS.ability.data")</code></pre>


<h3>Format</h3>

<p>A data frame comprising 301 observations on 22 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p> student ID number (int)</p>
</dd>
<dt><code>Gender</code></dt><dd><p> Sex (Factor w/ 2 levels &ldquo;Female&rdquo; and &ldquo;Male&rdquo;)</p>
</dd>
<dt><code>grade</code></dt><dd><p> Grade in school (integer 7 or 8)</p>
</dd>
<dt><code>agey</code></dt><dd><p>  Age in years (integer)</p>
</dd>
<dt><code>agem</code></dt><dd><p>  Age in months (integer)</p>
</dd>
<dt><code>school</code></dt><dd><p> School attended (Factor w/2 levels &ldquo;Grant-White&rdquo; and &ldquo;Pasteur&rdquo;)</p>
</dd>
<dt><code>addition</code></dt><dd><p> A speed test of addition (numeric)</p>
</dd>
<dt><code>code</code></dt><dd><p> A speed test (numeric)</p>
</dd>
<dt><code>counting</code></dt><dd><p> A speed test of counting groups of dots (numeric)</p>
</dd>
<dt><code>straight</code></dt><dd><p> A speed test discriminating straight and curved capitals (numeric)</p>
</dd>
<dt><code>wordr</code></dt><dd><p> A memory subtest of word recognition</p>
</dd>
<dt><code>numberr</code></dt><dd><p> A memory subtest of number recognition</p>
</dd>
<dt><code>figurer</code></dt><dd><p> A memory subtest of figure recognition</p>
</dd>
<dt><code>object</code></dt><dd><p> A memory subtest: object-number test</p>
</dd>
<dt><code>numberf</code></dt><dd><p> A memory subtest: number-figure test</p>
</dd>
<dt><code>figurew</code></dt><dd><p> A memory subtest: figure-word test</p>
</dd>
<dt><code>deduct</code></dt><dd><p>A mathematical subtest of deduction</p>
</dd>
<dt><code>numeric</code></dt><dd><p>A mathematical subtest of numerical puzzles</p>
</dd>
<dt><code>problemr</code></dt><dd><p>A mathematical subtest of problem reasoning</p>
</dd>
<dt><code>series</code></dt><dd><p>A mathematical subtest of series completion</p>
</dd>
<dt><code>arithmet</code></dt><dd><p>A mathematical subtest: Woody-McCall mixed fundamentals, form I</p>
</dd>
<dt><code>visual</code></dt><dd><p> A spatial subtest of visual perception</p>
</dd>
<dt><code>cubes</code></dt><dd><p> A spatial subtest</p>
</dd>
<dt><code>paper</code></dt><dd><p> A spatial subtest paper form board</p>
</dd>
<dt><code>flags</code></dt><dd><p> A spatial subtest (also known as lozenges)</p>
</dd>
<dt><code>paperrev</code></dt><dd><p> A spatial subtest additional paper form board test (can substitute for paper)</p>
</dd>
<dt><code>flagssub</code></dt><dd><p> A spatial subtest additional lozenges test (can substitute for flags)</p>
</dd>
<dt><code>general</code></dt><dd><p> A verbal subtest of general information</p>
</dd>
<dt><code>paragrap</code></dt><dd><p> A verbal subtest of paragraph comprehension</p>
</dd>
<dt><code>sentence</code></dt><dd><p> A verbal subtest of sentence completion</p>
</dd>
<dt><code>wordc</code></dt><dd><p> A verbal subtest of word classification</p>
</dd>
<dt><code>wordm</code></dt><dd><p> A verbal subtest of word meaning</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data are from children who differ in grade (seventh- and eighth-grade) and are nested in one of two schools (Pasteur and Grant-White). You will see it in use elsewhere, both in R (<code>lavaan</code>, and <code>MBESS</code>), and in Joreskog (1969) reporting a CFA on the Grant-White school subject subset.
</p>
<p>Some tests are alternate or substitute forms, e.g. <code>paperrev</code> (a paper form board test) can substitute for <code>paper</code> and <code>flagssub</code> for the lozenges test <code>flags</code>.
</p>


<h3>Source</h3>

<p>Holzinger, K., and Swineford, F. (1939).
</p>


<h3>References</h3>

<p>Holzinger, K., and Swineford, F. (1939). A study in factor analysis: The stability of a bifactor solution. <em>Supplementary Educational Monograph</em>, no. <b>48</b>. Chicago: University of Chicago Press.
</p>
<p>Joreskog, K. G. (1969). A general approach to confirmatory maximum likelihood factor analysis. <em>Psychometrika</em>, <b>34</b>, 183-202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HS.ability.data)
str(HS.ability.data)
levels(HS.ability.data$school)
plot(flags ~ flagssub, data = HS.ability.data)
</code></pre>

<hr>
<h2 id='imxAddDependency'>Add a dependency</h2><span id='topic+imxAddDependency'></span>

<h3>Description</h3>

<p>The dependency tracking system ensures that algebra and
fitfunctions are not recomputed if their inputs have not changed.
Dependency information is computed prior to handing the model off
to the optimizer to reduce overhead during optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxAddDependency(source, sink, dependencies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxAddDependency_+3A_source">source</code></td>
<td>
<p>a character vector of the names of the computation sources (inputs)</p>
</td></tr>
<tr><td><code id="imxAddDependency_+3A_sink">sink</code></td>
<td>
<p>the name of the computation sink (output)</p>
</td></tr>
<tr><td><code id="imxAddDependency_+3A_dependencies">dependencies</code></td>
<td>
<p>the dependency graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each free parameter keeps track of all the objects that store that
free parameter and the transitive closure of all algebras and fit
functions that depend on that free parameter.  Similarly, each
definition variable keeps track of all the objects that store that
free parameter and the transitive closure of all the algebras and
fit functions that depend on that free parameter. At each
iteration of the optimization, when the free parameter values are
updated, all of the dependencies of that free parameter are marked
as dirty (see <code>omxFitFunction.repopulateFun</code>). After an
algebra or fit function is computed, <code>omxMarkClean()</code> is
called to to indicate that the algebra or fit function is updated.
Similarly, when definition variables are populated in FIML, all of
the dependencies of the definition variables are marked as dirty.
Particularly for FIML, the fact that non-definition-variable
dependencies remain clean is a big performance gain.
</p>

<hr>
<h2 id='imxAutoOptionValue'>imxAutoOptionValue</h2><span id='topic+imxAutoOptionValue'></span>

<h3>Description</h3>

<p>Convert &quot;Auto&quot; placeholders in global mxOptions to actual default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxAutoOptionValue(optionName, optionList = options()$mxOption)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxAutoOptionValue_+3A_optionname">optionName</code></td>
<td>
<p>Character string naming the <a href="#topic+mxOption">mxOption</a> for which a numeric or integer value is wanted.</p>
</td></tr>
<tr><td><code id="imxAutoOptionValue_+3A_optionlist">optionList</code></td>
<td>
<p>List of options; defaults to list of global <a href="#topic+mxOption">mxOption</a>s.
imxAutoOptionValue</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function exported for documentation purposes.
Its primary purpose is to convert the on-load value of &quot;Auto&quot;to
valid values for <a href="#topic+mxOption">mxOption</a>s &lsquo;Gradient step size&rsquo;,
&lsquo;Gradient iterations&rsquo;, and
&lsquo;Function precision&rsquo;&ndash;respectively, 1.0e-7, 1L, and 1e-14.
</p>

<hr>
<h2 id='imxCheckMatrices'>imxCheckMatrices</h2><span id='topic+imxCheckMatrices'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxCheckMatrices(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxCheckMatrices_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxCheckVariables'>imxCheckVariables</h2><span id='topic+imxCheckVariables'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxCheckVariables(flatModel, namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxCheckVariables_+3A_flatmodel">flatModel</code></td>
<td>
<p>flatModel</p>
</td></tr>
<tr><td><code id="imxCheckVariables_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
</table>

<hr>
<h2 id='imxConDecMatrixSlots'>Condense/de-condense slots of an MxMatrix</h2><span id='topic+imxConDecMatrixSlots'></span><span id='topic+imxConDecMatrixSlots+2CMxMatrix-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxConDecMatrixSlots(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxConDecMatrixSlots_+3A_object">object</code></td>
<td>
<p>of class MxMatrix</p>
</td></tr>
</table>

<hr>
<h2 id='imxConstraintRelations'>imxConstraintRelations</h2><span id='topic+imxConstraintRelations'></span>

<h3>Description</h3>

<p>A string vector of valid constraint binary relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxConstraintRelations
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>

<hr>
<h2 id='imxConvertIdentifier'>imxConvertIdentifier</h2><span id='topic+imxConvertIdentifier'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxConvertIdentifier(identifiers, modelname, namespace, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxConvertIdentifier_+3A_identifiers">identifiers</code></td>
<td>
<p>identifiers</p>
</td></tr>
<tr><td><code id="imxConvertIdentifier_+3A_modelname">modelname</code></td>
<td>
<p>modelname</p>
</td></tr>
<tr><td><code id="imxConvertIdentifier_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
<tr><td><code id="imxConvertIdentifier_+3A_strict">strict</code></td>
<td>
<p>strict</p>
</td></tr>
</table>

<hr>
<h2 id='imxConvertLabel'>imxConvertLabel</h2><span id='topic+imxConvertLabel'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxConvertLabel(label, modelname, dataname, namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxConvertLabel_+3A_label">label</code></td>
<td>
<p>label</p>
</td></tr>
<tr><td><code id="imxConvertLabel_+3A_modelname">modelname</code></td>
<td>
<p>modelname</p>
</td></tr>
<tr><td><code id="imxConvertLabel_+3A_dataname">dataname</code></td>
<td>
<p>dataname</p>
</td></tr>
<tr><td><code id="imxConvertLabel_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
</table>

<hr>
<h2 id='imxConvertSubstitution'>imxConvertSubstitution</h2><span id='topic+imxConvertSubstitution'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxConvertSubstitution(substitution, modelname, namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxConvertSubstitution_+3A_substitution">substitution</code></td>
<td>
<p>substitution</p>
</td></tr>
<tr><td><code id="imxConvertSubstitution_+3A_modelname">modelname</code></td>
<td>
<p>modelname</p>
</td></tr>
<tr><td><code id="imxConvertSubstitution_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
</table>

<hr>
<h2 id='imxCreateMatrix'>Create a matrix</h2><span id='topic+imxCreateMatrix'></span><span id='topic+imxCreateMatrix+2CMxMatrix-method'></span><span id='topic+imxCreateMatrix+2CDiagMatrix-method'></span><span id='topic+imxCreateMatrix+2CFullMatrix-method'></span><span id='topic+imxCreateMatrix+2CIdenMatrix-method'></span><span id='topic+imxCreateMatrix+2CLowerMatrix-method'></span><span id='topic+imxCreateMatrix+2CSdiagMatrix-method'></span><span id='topic+imxCreateMatrix+2CStandMatrix-method'></span><span id='topic+imxCreateMatrix+2CSymmMatrix-method'></span><span id='topic+imxCreateMatrix+2CUnitMatrix-method'></span><span id='topic+imxCreateMatrix+2CZeroMatrix-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxCreateMatrix(
  .Object,
  labels,
  values,
  free,
  lbound,
  ubound,
  nrow,
  ncol,
  byrow,
  name,
  condenseSlots,
  joinKey,
  joinModel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxCreateMatrix_+3A_.object">.Object</code></td>
<td>
<p>the matrix</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_labels">labels</code></td>
<td>
<p>labels</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_values">values</code></td>
<td>
<p>values</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_free">free</code></td>
<td>
<p>free</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_lbound">lbound</code></td>
<td>
<p>lbound</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_ubound">ubound</code></td>
<td>
<p>ubound</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_nrow">nrow</code></td>
<td>
<p>nrow</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_ncol">ncol</code></td>
<td>
<p>ncol</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_byrow">byrow</code></td>
<td>
<p>byrow</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_condenseslots">condenseSlots</code></td>
<td>
<p>condenseSlots</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_joinkey">joinKey</code></td>
<td>
<p>joinKey</p>
</td></tr>
<tr><td><code id="imxCreateMatrix_+3A_joinmodel">joinModel</code></td>
<td>
<p>joinModel</p>
</td></tr>
</table>

<hr>
<h2 id='imxDataTypes'>Valid types of data that can be contained by MxData</h2><span id='topic+imxDataTypes'></span>

<h3>Description</h3>

<p>Valid types of data that can be contained by MxData
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDataTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 4.
</p>

<hr>
<h2 id='imxDefaultGetSlotDisplayNames'>imxDefaultGetSlotDisplayNames</h2><span id='topic+imxDefaultGetSlotDisplayNames'></span>

<h3>Description</h3>

<p>Returns a list of display-friendly object slot names
This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDefaultGetSlotDisplayNames(x, pattern = ".*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxDefaultGetSlotDisplayNames_+3A_x">x</code></td>
<td>
<p>The object from which to get slot names</p>
</td></tr>
<tr><td><code id="imxDefaultGetSlotDisplayNames_+3A_pattern">pattern</code></td>
<td>
<p>Initial pattern to match (default of '.*' matches any)</p>
</td></tr>
</table>

<hr>
<h2 id='imxDeparse'>Deparse for MxObjects</h2><span id='topic+imxDeparse'></span><span id='topic+imxDeparse+2CIdenMatrix-method'></span><span id='topic+imxDeparse+2CMxAlgebra-method'></span><span id='topic+imxDeparse+2CMxConstraint-method'></span><span id='topic+imxDeparse+2CMxData-method'></span><span id='topic+imxDeparse+2CMxMatrix-method'></span><span id='topic+imxDeparse+2CUnitMatrix-method'></span><span id='topic+imxDeparse+2CZeroMatrix-method'></span><span id='topic+imxDeparse+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Deparse for MxObjects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDeparse(object, indent = "   ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxDeparse_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="imxDeparse_+3A_indent">indent</code></td>
<td>
<p>indent</p>
</td></tr>
</table>

<hr>
<h2 id='imxDependentModels'>Are submodels dependence?</h2><span id='topic+imxDependentModels'></span>

<h3>Description</h3>

<p>Are submodels dependence?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDependentModels(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxDependentModels_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxDetermineDefaultOptimizer'>imxDetermineDefaultOptimizer</h2><span id='topic+imxDetermineDefaultOptimizer'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDetermineDefaultOptimizer()
</code></pre>


<h3>Details</h3>

<p>Returns a character, the default optimizer
</p>

<hr>
<h2 id='imxDmvnorm'>A C implementation of dmvnorm</h2><span id='topic+imxDmvnorm'></span>

<h3>Description</h3>

<p>This API is visible to permit testing. Please do not use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxDmvnorm(loc, mean, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxDmvnorm_+3A_loc">loc</code></td>
<td>
<p>loc</p>
</td></tr>
<tr><td><code id="imxDmvnorm_+3A_mean">mean</code></td>
<td>
<p>mean</p>
</td></tr>
<tr><td><code id="imxDmvnorm_+3A_sigma">sigma</code></td>
<td>
<p>sigma</p>
</td></tr>
</table>

<hr>
<h2 id='imxEvalByName'>imxEvalByName</h2><span id='topic+imxEvalByName'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxEvalByName(name, model, compute = FALSE, show = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxEvalByName_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxEvalByName_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxEvalByName_+3A_compute">compute</code></td>
<td>
<p>compute</p>
</td></tr>
<tr><td><code id="imxEvalByName_+3A_show">show</code></td>
<td>
<p>show</p>
</td></tr>
</table>

<hr>
<h2 id='imxExtractMethod'>imxExtractMethod</h2><span id='topic+imxExtractMethod'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxExtractMethod(model, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxExtractMethod_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxExtractMethod_+3A_index">index</code></td>
<td>
<p>index</p>
</td></tr>
</table>

<hr>
<h2 id='imxExtractNames'>imxExtractNames</h2><span id='topic+imxExtractNames'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxExtractNames(lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxExtractNames_+3A_lst">lst</code></td>
<td>
<p>lst</p>
</td></tr>
</table>

<hr>
<h2 id='imxExtractReferences'>imxExtractReferences</h2><span id='topic+imxExtractReferences'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxExtractReferences(lst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxExtractReferences_+3A_lst">lst</code></td>
<td>
<p>lst</p>
</td></tr>
</table>

<hr>
<h2 id='imxExtractSlot'>imxExtractSlot</h2><span id='topic+imxExtractSlot'></span>

<h3>Description</h3>

<p>Checks for and extracts a slot from the object
This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxExtractSlot(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxExtractSlot_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="imxExtractSlot_+3A_name">name</code></td>
<td>
<p>the name of the slot</p>
</td></tr>
</table>

<hr>
<h2 id='imxFlattenModel'>Remove hierarchical structure from model</h2><span id='topic+imxFlattenModel'></span>

<h3>Description</h3>

<p>Remove hierarchical structure from model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxFlattenModel(model, namespace, unsafe = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxFlattenModel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxFlattenModel_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
<tr><td><code id="imxFlattenModel_+3A_unsafe">unsafe</code></td>
<td>
<p>whether to skip sanity checks</p>
</td></tr>
</table>

<hr>
<h2 id='imxFreezeModel'>Freeze model</h2><span id='topic+imxFreezeModel'></span>

<h3>Description</h3>

<p>Remove free parameters and fit function from model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxFreezeModel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxFreezeModel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxGenerateLabels'>imxGenerateLabels</h2><span id='topic+imxGenerateLabels'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGenerateLabels(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGenerateLabels_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxGenerateNamespace'>imxGenerateNamespace</h2><span id='topic+imxGenerateNamespace'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGenerateNamespace(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGenerateNamespace_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxGenericModelBuilder'>imxGenericModelBuilder</h2><span id='topic+imxGenericModelBuilder'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGenericModelBuilder(
  model,
  lst,
  name,
  manifestVars,
  latentVars,
  productVars,
  submodels,
  remove,
  independent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGenericModelBuilder_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_lst">lst</code></td>
<td>
<p>lst</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_manifestvars">manifestVars</code></td>
<td>
<p>manifestVars</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_latentvars">latentVars</code></td>
<td>
<p>latentVars</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_productvars">productVars</code></td>
<td>
<p>productVars</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_submodels">submodels</code></td>
<td>
<p>submodels</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_remove">remove</code></td>
<td>
<p>remove</p>
</td></tr>
<tr><td><code id="imxGenericModelBuilder_+3A_independent">independent</code></td>
<td>
<p>independent</p>
</td></tr>
</table>

<hr>
<h2 id='imxGenSwift'>imxGenSwift</h2><span id='topic+imxGenSwift'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGenSwift(tc, sites, sfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGenSwift_+3A_tc">tc</code></td>
<td>
<p>tc</p>
</td></tr>
<tr><td><code id="imxGenSwift_+3A_sites">sites</code></td>
<td>
<p>sites</p>
</td></tr>
<tr><td><code id="imxGenSwift_+3A_sfile">sfile</code></td>
<td>
<p>sfile</p>
</td></tr>
</table>

<hr>
<h2 id='imxGentleResize'>Resize an MxMatrix while preserving entries</h2><span id='topic+imxGentleResize'></span>

<h3>Description</h3>

<p>Resize an MxMatrix while preserving entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGentleResize(matrix, dimnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGentleResize_+3A_matrix">matrix</code></td>
<td>
<p>the MxMatrix to resize</p>
</td></tr>
<tr><td><code id="imxGentleResize_+3A_dimnames">dimnames</code></td>
<td>
<p>desired dimnames for the new matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a resized MxMatrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- mxMatrix(values=1:9, nrow=3, ncol=3,
               dimnames=list(paste0('r',1:3), paste0('c',1:3)))

imxGentleResize(m1, dimnames=list(paste0('r',c(1,3,5)),
                                  paste0('c',c(2,4,6))))
</code></pre>

<hr>
<h2 id='imxGetNumThreads'>imxGetNumThreads</h2><span id='topic+imxGetNumThreads'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>
<p>This function hard codes responses to a set of environments, like detecting snowfall,
or running on a cluster where &quot;OMP_NUM_THREADS&quot; is set or otherwise returning 1 or 2 cores
to avoid consuming all the resources on CRAN's test machines during release cycles.
</p>
<p>This makes it <em>not</em> suitable for getting the number of available threads.
</p>
<p>To get the number of cores available locally you want <code><a href="#topic+omxDetectCores">omxDetectCores</a></code>
or perhaps the <code>detectCores</code> function in the parallel package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGetNumThreads()
</code></pre>

<hr>
<h2 id='imxGetSlotDisplayNames'>imxGetSlotDisplayNames</h2><span id='topic+imxGetSlotDisplayNames'></span>

<h3>Description</h3>

<p>Returns a list of display-friendly object slot names
This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxGetSlotDisplayNames(
  object,
  pattern = ".*",
  slotList = slotNames(object),
  showDots = FALSE,
  showEmpty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxGetSlotDisplayNames_+3A_object">object</code></td>
<td>
<p>The object from which to get slot names</p>
</td></tr>
<tr><td><code id="imxGetSlotDisplayNames_+3A_pattern">pattern</code></td>
<td>
<p>Initial pattern to match (default of '.*' matches any)</p>
</td></tr>
<tr><td><code id="imxGetSlotDisplayNames_+3A_slotlist">slotList</code></td>
<td>
<p>List of slots for which toget display names (default = slotNames(object), i.e., all)</p>
</td></tr>
<tr><td><code id="imxGetSlotDisplayNames_+3A_showdots">showDots</code></td>
<td>
<p>Include slots whose names start with '.' (default FALSE)</p>
</td></tr>
<tr><td><code id="imxGetSlotDisplayNames_+3A_showempty">showEmpty</code></td>
<td>
<p>Include slots with length-zero contents (default FALSE)</p>
</td></tr>
</table>

<hr>
<h2 id='imxHasConstraint'>imxHasConstraint</h2><span id='topic+imxHasConstraint'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  This function checks if a model (or its
submodels) has at least one MxConstraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasConstraint(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxHasConstraint_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxHasDefinitionVariable'>imxHasDefinitionVariable</h2><span id='topic+imxHasDefinitionVariable'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  This function checks if a model (or its
submodels) has at least one definition variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasDefinitionVariable(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxHasDefinitionVariable_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxHasNPSOL'>imxHasNPSOL</h2><span id='topic+imxHasNPSOL'></span>

<h3>Description</h3>

<p>imxHasNPSOL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasNPSOL()
</code></pre>


<h3>Value</h3>

<p>Returns TRUE if the NPSOL proprietary optimizer is compiled and
linked with OpenMx. Otherwise FALSE.
</p>

<hr>
<h2 id='imxHasOpenMP'>imxHasOpenMP</h2><span id='topic+imxHasOpenMP'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasOpenMP()
</code></pre>

<hr>
<h2 id='imxHasThresholds'>imxHasThresholds</h2><span id='topic+imxHasThresholds'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  This function checks if a model (or its
submodels) has any thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasThresholds(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxHasThresholds_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxHasWLS'>imxHasWLS</h2><span id='topic+imxHasWLS'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  This function checks if a model uses a
fitfunction with WLS units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxHasWLS(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxHasWLS_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxIdentifier'>imxIdentifier</h2><span id='topic+imxIdentifier'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIdentifier(namespace, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIdentifier_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
<tr><td><code id="imxIdentifier_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
</table>

<hr>
<h2 id='imxIndependentModels'>Are submodels independent?</h2><span id='topic+imxIndependentModels'></span>

<h3>Description</h3>

<p>Are submodels independent?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIndependentModels(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIndependentModels_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxInitModel'>imxInitModel</h2><span id='topic+imxInitModel'></span><span id='topic+imxInitModel+2CMxModel-method'></span><span id='topic+imxInitModel+2CMxRAMModel-method'></span><span id='topic+imxInitModel+2CMxLISRELModel-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxInitModel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxInitModel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxIsDefinitionVariable'>imxIsDefinitionVariable</h2><span id='topic+imxIsDefinitionVariable'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIsDefinitionVariable(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIsDefinitionVariable_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
</table>

<hr>
<h2 id='imxIsMultilevel'>imxIsMultilevel</h2><span id='topic+imxIsMultilevel'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  If you don't know what you're doing, but want to,
here's a brief description of the function.  You give this function an MxModel. It
returns TRUE if the model is multilevel and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIsMultilevel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIsMultilevel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxIsPath'>imxIsPath</h2><span id='topic+imxIsPath'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIsPath(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIsPath_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>

<hr>
<h2 id='imxIsStateSpace'>imxIsStateSpace</h2><span id='topic+imxIsStateSpace'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.  If you don't know what you're doing, but want to,
here's a brief description of the function.  You give this function an MxModel. It
returns TRUE if the model is a state space model and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxIsStateSpace(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxIsStateSpace_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxLocateFunction'>imxLocateFunction</h2><span id='topic+imxLocateFunction'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxLocateFunction(function_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxLocateFunction_+3A_function_name">function_name</code></td>
<td>
<p>function_name</p>
</td></tr>
</table>

<hr>
<h2 id='imxLocateIndex'>imxLocateIndex</h2><span id='topic+imxLocateIndex'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxLocateIndex(model, name, referant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxLocateIndex_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxLocateIndex_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxLocateIndex_+3A_referant">referant</code></td>
<td>
<p>referant</p>
</td></tr>
</table>

<hr>
<h2 id='imxLocateLabel'>imxLocateLabel</h2><span id='topic+imxLocateLabel'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxLocateLabel(label, model, parameter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxLocateLabel_+3A_label">label</code></td>
<td>
<p>label</p>
</td></tr>
<tr><td><code id="imxLocateLabel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxLocateLabel_+3A_parameter">parameter</code></td>
<td>
<p>parameter</p>
</td></tr>
</table>

<hr>
<h2 id='imxLog'>Test thread-safe output code</h2><span id='topic+imxLog'></span>

<h3>Description</h3>

<p>This is the code that the backend uses to write diagnostic
information to standard error. This function should not be called
from R. We make it available only for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxLog(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxLog_+3A_str">str</code></td>
<td>
<p>the character string to output</p>
</td></tr>
</table>

<hr>
<h2 id='imxLookupSymbolTable'>imxLookupSymbolTable</h2><span id='topic+imxLookupSymbolTable'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxLookupSymbolTable(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxLookupSymbolTable_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
</table>

<hr>
<h2 id='imxModelBuilder'>imxModelBuilder</h2><span id='topic+imxModelBuilder'></span><span id='topic+imxModelBuilder+2CMxLISRELModel-method'></span><span id='topic+imxModelBuilder+2CMxModel-method'></span><span id='topic+imxModelBuilder+2CMxRAMModel-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxModelBuilder(
  model,
  lst,
  name,
  manifestVars,
  latentVars,
  productVars,
  submodels,
  remove,
  independent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxModelBuilder_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_lst">lst</code></td>
<td>
<p>lst</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_manifestvars">manifestVars</code></td>
<td>
<p>manifestVars</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_latentvars">latentVars</code></td>
<td>
<p>latentVars</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_productvars">productVars</code></td>
<td>
<p>productVars</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_submodels">submodels</code></td>
<td>
<p>submodels</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_remove">remove</code></td>
<td>
<p>remove</p>
</td></tr>
<tr><td><code id="imxModelBuilder_+3A_independent">independent</code></td>
<td>
<p>independent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO: It probably makes sense to split this into separate
methods. For example, modelAddVariables and modelRemoveVariables
could be their own methods. This would reduce some cut&amp;paste
duplication.
</p>

<hr>
<h2 id='imxModelTypes'>imxModelTypes</h2><span id='topic+imxModelTypes'></span>

<h3>Description</h3>

<p>A list of supported model types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxModelTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='imxMpiWrap'>imxMpiWrap</h2><span id='topic+imxMpiWrap'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxMpiWrap(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxMpiWrap_+3A_fun">fun</code></td>
<td>
<p>fun</p>
</td></tr>
</table>

<hr>
<h2 id='imxOriginalMx'>Run an classic mx script</h2><span id='topic+imxOriginalMx'></span>

<h3>Description</h3>

<p>For this to work, classic mx must be installed, and callable from the command line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxOriginalMx(mx.filename, output.directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxOriginalMx_+3A_mx.filename">mx.filename</code></td>
<td>
<p>Name of file containing the mx script.</p>
</td></tr>
<tr><td><code id="imxOriginalMx_+3A_output.directory">output.directory</code></td>
<td>
<p>Where to write mxo output from the script</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed matrix output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
output = imxOriginalMx(mx.filename = "power1.mx", "~/Desktop")

## End(Not run)
</code></pre>

<hr>
<h2 id='imxPenaltyTypes'>imxPenaltyTypes</h2><span id='topic+imxPenaltyTypes'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxPenaltyTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 3.
</p>


<h3>Details</h3>

<p>Types of regularization penalties.
</p>

<hr>
<h2 id='imxPPML'>imxPPML</h2><span id='topic+imxPPML'></span>

<h3>Description</h3>

<p>Potentially enable the PPML optimization for the given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxPPML(model, flag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxPPML_+3A_model">model</code></td>
<td>
<p>the MxModel to evaluate</p>
</td></tr>
<tr><td><code id="imxPPML_+3A_flag">flag</code></td>
<td>
<p>whether to potentially enable PPML</p>
</td></tr>
</table>

<hr>
<h2 id='imxPPML.Test.Battery'>imxPPML.Test.Battery</h2><span id='topic+imxPPML.Test.Battery'></span>

<h3>Description</h3>

<p>PPML can be applied to a number of special cases.  This function will test the given model for
all of these special cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxPPML.Test.Battery(
  model,
  verbose = FALSE,
  testMissingness = TRUE,
  testPermutations = TRUE,
  testEstimates = TRUE,
  testFakeLatents = TRUE,
  tolerances = c(0.001, 0.001, 0.001)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxPPML.Test.Battery_+3A_model">model</code></td>
<td>
<p>the model to test</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_verbose">verbose</code></td>
<td>
<p>whether to print diagnostics</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_testmissingness">testMissingness</code></td>
<td>
<p>try with missingness</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_testpermutations">testPermutations</code></td>
<td>
<p>try with permutations</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_testestimates">testEstimates</code></td>
<td>
<p>examine estimates</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_testfakelatents">testFakeLatents</code></td>
<td>
<p>try with fake latents</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Battery_+3A_tolerances">tolerances</code></td>
<td>
<p>a vector of tolerances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requirements for model passed to this function:
- Path-specified
- Means vector must be present
- Covariance data (with data means vector)
- (Recommended) All error variances should be specified on the
diagonal of the S matrix, and not as a latent with a loading only
on to that manifest
</p>
<p>Function will test across all permutations of:
- Covariance vs Raw data
- Means vector present vs Means vector absent
- Path versus Matrix specification
- All orders of permutations of latents with manifests
</p>

<hr>
<h2 id='imxPPML.Test.Test'>imxPPML.Test.Test</h2><span id='topic+imxPPML.Test.Test'></span>

<h3>Description</h3>

<p>Test that PPML solutions match non-PPML solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxPPML.Test.Test(
  model,
  checkLL = TRUE,
  checkByName = FALSE,
  tolerance = 0.5,
  testEstimates = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxPPML.Test.Test_+3A_model">model</code></td>
<td>
<p>the MxModel to evaluate</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Test_+3A_checkll">checkLL</code></td>
<td>
<p>whether to check log likelihood</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Test_+3A_checkbyname">checkByName</code></td>
<td>
<p>check values using their names</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Test_+3A_tolerance">tolerance</code></td>
<td>
<p>closeness tolerance for check</p>
</td></tr>
<tr><td><code id="imxPPML.Test.Test_+3A_testestimates">testEstimates</code></td>
<td>
<p>whether to test for the same parameter estimates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used for comparing PPML and non-PPML solutions.
Generally, non-developers will not use this function.
</p>

<hr>
<h2 id='imxPreprocessModel'>imxPreprocessModel</h2><span id='topic+imxPreprocessModel'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxPreprocessModel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxPreprocessModel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxReplaceMethod'>imxReplaceMethod</h2><span id='topic+imxReplaceMethod'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReplaceMethod(x, name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxReplaceMethod_+3A_x">x</code></td>
<td>
<p>the thing</p>
</td></tr>
<tr><td><code id="imxReplaceMethod_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxReplaceMethod_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>

<hr>
<h2 id='imxReplaceModels'>Replace parts of a model</h2><span id='topic+imxReplaceModels'></span>

<h3>Description</h3>

<p>Replace parts of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReplaceModels(model, replacements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxReplaceModels_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxReplaceModels_+3A_replacements">replacements</code></td>
<td>
<p>replacements</p>
</td></tr>
</table>

<hr>
<h2 id='imxReplaceSlot'>imxReplaceSlot</h2><span id='topic+imxReplaceSlot'></span>

<h3>Description</h3>

<p>Checks for and replaces a slot from the object
This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReplaceSlot(x, name, value, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxReplaceSlot_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="imxReplaceSlot_+3A_name">name</code></td>
<td>
<p>the name of the slot</p>
</td></tr>
<tr><td><code id="imxReplaceSlot_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
<tr><td><code id="imxReplaceSlot_+3A_check">check</code></td>
<td>
<p>Check replacement value for validity (default TRUE)</p>
</td></tr>
</table>

<hr>
<h2 id='imxReportProgress'>Report backend progress</h2><span id='topic+imxReportProgress'></span>

<h3>Description</h3>

<p>Prints a show status string to the console without emitting a
newline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReportProgress(info, eraseLen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxReportProgress_+3A_info">info</code></td>
<td>
<p>the character string to print</p>
</td></tr>
<tr><td><code id="imxReportProgress_+3A_eraselen">eraseLen</code></td>
<td>
<p>the number of characters to erase</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

previousLen &lt;&lt;- 0

easyReportProcess &lt;- function(msg) {
	imxReportProgress(msg, previousLen)
	previousLen &lt;&lt;- nchar(msg)
}

demo &lt;- function() {
	easyReportProcess("abc123")
	Sys.sleep(1)
	easyReportProcess("this is much longer")
	Sys.sleep(1)
	easyReportProcess("this is short")
	Sys.sleep(1)
	easyReportProcess("almost done")
	Sys.sleep(1)
	easyReportProcess("")
	cat("DONE!", fill=TRUE)
}

demo()
</code></pre>

<hr>
<h2 id='imxReservedNames'>imxReservedNames</h2><span id='topic+imxReservedNames'></span>

<h3>Description</h3>

<p>Vector of reserved names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReservedNames
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 7.
</p>

<hr>
<h2 id='imxReverseIdentifier'>imxReverseIdentifier</h2><span id='topic+imxReverseIdentifier'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxReverseIdentifier(model, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxReverseIdentifier_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxReverseIdentifier_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
</table>

<hr>
<h2 id='imxRobustSE'>imxRobustSE</h2><span id='topic+imxRobustSE'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxRobustSE(model, details = FALSE, dependencyModels = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxRobustSE_+3A_model">model</code></td>
<td>
<p>An OpenMx model object that has been run.</p>
</td></tr>
<tr><td><code id="imxRobustSE_+3A_details">details</code></td>
<td>
<p>Logical. whether to return the full parameter
covariance matrix.</p>
</td></tr>
<tr><td><code id="imxRobustSE_+3A_dependencymodels">dependencyModels</code></td>
<td>
<p>Passed to <code>imxRowGradients()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes robust standard errors via a sandwich estimator.
The &quot;bread&quot; of the sandwich is the numerically computed inverse Hessian
of the likelihood function.  This is what is typically used for standard
errors throughout OpenMx.  The &quot;meat&quot; of the sandwich is proportional to 
the covariance matrix of the numerically computed row derivatives of the 
likelihood function (i.e. row gradients).
</p>
<p>When <code>details=FALSE</code>, only the standard errors are returned.
</p>
<p>When <code>details=TRUE</code>,
a list with five named elements is returned.  Element <code>SE</code> is the 
vector of standard errors that is also returned when <code>details=FALSE</code>.
Element <code>cov</code> is the full robust covariance matrix of the parameter 
estimates; the square root of the diagonal of <code>cov</code> gives the 
standard errors.  Element <code>bread</code> is the aforementioned 
&quot;bread&quot;&ndash;the naive (non-robust) covariance matrix of the parameter 
estimates.  Element <code>meat</code> is the aforementioned &quot;meat,&quot; proportional
to the covariance matrix of the row gradients.  Element <code>TIC</code> 
is the model's Takeuchi Information Criterion, which is a generalization 
of AIC calculated from the &quot;bread,&quot; the &quot;meat,&quot; and the loglikelihood 
at the maximum-likelihood solution.
</p>
<p>This function does not work correctly with multigroup models in which the 
groups themselves contain subgroups. This function also does not correctly handle
multilevel data.
</p>

<hr>
<h2 id='imxRowGradients'>imxRowGradients</h2><span id='topic+imxRowGradients'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxRowGradients(model, robustSE = FALSE, dependencyModels = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxRowGradients_+3A_model">model</code></td>
<td>
<p>An OpenMx model object that has been run</p>
</td></tr>
<tr><td><code id="imxRowGradients_+3A_robustse">robustSE</code></td>
<td>
<p>Logical; are the row gradients being requested to calculate robust standard errors?</p>
</td></tr>
<tr><td><code id="imxRowGradients_+3A_dependencymodels">dependencyModels</code></td>
<td>
<p>Vector of character strings naming 
submodels that do not contain data, but contain objects 
to which data-containing models make reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the gradient for each row of data.
The returned object is a matrix with the same number of rows as the data,
and the same number of columns as there are free parameters.
</p>

<hr>
<h2 id='imxSameType'>imxSameType</h2><span id='topic+imxSameType'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSameType(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxSameType_+3A_a">a</code></td>
<td>
<p>a</p>
</td></tr>
<tr><td><code id="imxSameType_+3A_b">b</code></td>
<td>
<p>b</p>
</td></tr>
</table>

<hr>
<h2 id='imxSeparatorChar'>imxSeparatorChar</h2><span id='topic+imxSeparatorChar'></span>

<h3>Description</h3>

<p>The character between the model name and the named entity inside
the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSeparatorChar
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='imxSfClient'>imxSfClient</h2><span id='topic+imxSfClient'></span>

<h3>Description</h3>

<p>As of snowfall 1.84, the snowfall supervisor process
stores an internal state information in a variable
named &quot;.sfOption&quot; that is located in the &quot;snowfall&quot; namespace.
The snowfall client processes store internal state
information in a variable named &quot;.sfOption&quot; that is located
in the global namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSfClient()
</code></pre>


<h3>Details</h3>

<p>As long as the previous statement is true, then the current
process is a snowfall client if-and-only-if exists(&quot;.sfOption&quot;).
</p>

<hr>
<h2 id='imxSimpleRAMPredicate'>imxSimpleRAMPredicate</h2><span id='topic+imxSimpleRAMPredicate'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSimpleRAMPredicate(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxSimpleRAMPredicate_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxSparseInvert'>Sparse symmetric matrix invert</h2><span id='topic+imxSparseInvert'></span>

<h3>Description</h3>

<p>This API is visible to permit testing. Please do not use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSparseInvert(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxSparseInvert_+3A_mat">mat</code></td>
<td>
<p>the matrix to invert</p>
</td></tr>
</table>

<hr>
<h2 id='imxSquareMatrix'>imxSquareMatrix</h2><span id='topic+imxSquareMatrix'></span><span id='topic+imxSquareMatrix+2CDiagMatrix-method'></span><span id='topic+imxSquareMatrix+2CIdenMatrix-method'></span><span id='topic+imxSquareMatrix+2CLowerMatrix-method'></span><span id='topic+imxSquareMatrix+2CMxMatrix-method'></span><span id='topic+imxSquareMatrix+2CSdiagMatrix-method'></span><span id='topic+imxSquareMatrix+2CStandMatrix-method'></span><span id='topic+imxSquareMatrix+2CSymmMatrix-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSquareMatrix(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxSquareMatrix_+3A_.object">.Object</code></td>
<td>
<p>.Object</p>
</td></tr>
</table>

<hr>
<h2 id='imxSymmetricMatrix'>imxSymmetricMatrix</h2><span id='topic+imxSymmetricMatrix'></span><span id='topic+imxSymmetricMatrix+2CLowerMatrix-method'></span><span id='topic+imxSymmetricMatrix+2CMxMatrix-method'></span><span id='topic+imxSymmetricMatrix+2CSdiagMatrix-method'></span><span id='topic+imxSymmetricMatrix+2CStandMatrix-method'></span><span id='topic+imxSymmetricMatrix+2CSymmMatrix-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxSymmetricMatrix(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxSymmetricMatrix_+3A_.object">.Object</code></td>
<td>
<p>.Object</p>
</td></tr>
</table>

<hr>
<h2 id='imxTypeName'>imxTypeName</h2><span id='topic+imxTypeName'></span><span id='topic+imxTypeName+2CMxLISRELModel-method'></span><span id='topic+imxTypeName+2CMxModel-method'></span><span id='topic+imxTypeName+2CMxRAMModel-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxTypeName(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxTypeName_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxUntitledName'>imxUntitledName</h2><span id='topic+imxUntitledName'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxUntitledName()
</code></pre>


<h3>Details</h3>

<p>Returns a character, the name of the next untitled entity
</p>

<hr>
<h2 id='imxUntitledNumber'>imxUntitledNumber</h2><span id='topic+imxUntitledNumber'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxUntitledNumber()
</code></pre>


<h3>Details</h3>

<p>Increments the untitled number counter and returns its value
</p>

<hr>
<h2 id='imxUntitledNumberReset'>imxUntitledNumberReset</h2><span id='topic+imxUntitledNumberReset'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxUntitledNumberReset()
</code></pre>


<h3>Details</h3>

<p>Resets the <a href="#topic+imxUntitledNumber">imxUntitledNumber</a> counter
</p>

<hr>
<h2 id='imxUpdateModelValues'>imxUpdateModelValues</h2><span id='topic+imxUpdateModelValues'></span>

<h3>Description</h3>

<p>Deprecated. This function does not handle parameters with equality
constraints. Do not use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxUpdateModelValues(model, flatModel, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxUpdateModelValues_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="imxUpdateModelValues_+3A_flatmodel">flatModel</code></td>
<td>
<p>flat model</p>
</td></tr>
<tr><td><code id="imxUpdateModelValues_+3A_values">values</code></td>
<td>
<p>values to update</p>
</td></tr>
</table>

<hr>
<h2 id='imxVariableTypes'>imxVariableTypes</h2><span id='topic+imxVariableTypes'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxVariableTypes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 2.
</p>


<h3>Details</h3>

<p>The acceptable variable types
</p>

<hr>
<h2 id='imxVerifyMatrix'>imxVerifyMatrix</h2><span id='topic+imxVerifyMatrix'></span><span id='topic+imxVerifyMatrix+2CDiagMatrix-method'></span><span id='topic+imxVerifyMatrix+2CFullMatrix-method'></span><span id='topic+imxVerifyMatrix+2CIdenMatrix-method'></span><span id='topic+imxVerifyMatrix+2CLowerMatrix-method'></span><span id='topic+imxVerifyMatrix+2CMxMatrix-method'></span><span id='topic+imxVerifyMatrix+2CSdiagMatrix-method'></span><span id='topic+imxVerifyMatrix+2CStandMatrix-method'></span><span id='topic+imxVerifyMatrix+2CSymmMatrix-method'></span><span id='topic+imxVerifyMatrix+2CUnitMatrix-method'></span><span id='topic+imxVerifyMatrix+2CZeroMatrix-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxVerifyMatrix(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxVerifyMatrix_+3A_.object">.Object</code></td>
<td>
<p>.Object</p>
</td></tr>
</table>

<hr>
<h2 id='imxVerifyModel'>imxVerifyModel</h2><span id='topic+imxVerifyModel'></span><span id='topic+imxVerifyModel+2CMxLISRELModel-method'></span><span id='topic+imxVerifyModel+2CMxModel-method'></span><span id='topic+imxVerifyModel+2CMxRAMModel-method'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxVerifyModel(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxVerifyModel_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='imxVerifyName'>imxVerifyName</h2><span id='topic+imxVerifyName'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxVerifyName(name, stackNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxVerifyName_+3A_name">name</code></td>
<td>
<p>name</p>
</td></tr>
<tr><td><code id="imxVerifyName_+3A_stacknumber">stackNumber</code></td>
<td>
<p>stackNumber</p>
</td></tr>
</table>

<hr>
<h2 id='imxVerifyReference'>imxVerifyReference</h2><span id='topic+imxVerifyReference'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxVerifyReference(reference, stackNumber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxVerifyReference_+3A_reference">reference</code></td>
<td>
<p>reference</p>
</td></tr>
<tr><td><code id="imxVerifyReference_+3A_stacknumber">stackNumber</code></td>
<td>
<p>stackNumber</p>
</td></tr>
</table>

<hr>
<h2 id='imxWlsChiSquare'>Calculate Chi Square for a WLS Model</h2><span id='topic+imxWlsChiSquare'></span>

<h3>Description</h3>

<p>This is an internal function used to calculate the Chi Square distributed fit statistic for weighted least squares models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxWlsChiSquare(model, J=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxWlsChiSquare_+3A_model">model</code></td>
<td>
<p>An MxModel object with acov (WLS) data</p>
</td></tr>
<tr><td><code id="imxWlsChiSquare_+3A_j">J</code></td>
<td>
<p>Optional pre-computed Jacobian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Chi Square fit statistic for models fit with maximum likelihood depends on the difference in model fit in minus two log likelihood units between the saturated model and the more restricted model under investigation.  For models fit with weighted least squares a different expression is required.  If <code class="reqn">J</code> is the first derivative (Jacobian) of the mapping from the free parameters to the unique elements of the expected covariance, means, and threholds, <code class="reqn">J_c</code> is the orthogonal complement of <code class="reqn">J</code>, <code class="reqn">W</code> is the inverse of the full weight matrix, and <code class="reqn">e</code> is the difference between the sample-estimated and model-implied covariance, means, and thresholds, then the Chi Square fit statistic is
</p>
<p style="text-align: center;"><code class="reqn">\chi^2 = e' J_c (J'_c W J_c)^-1 J'_c e</code>
</p>

<p>with <code class="reqn">e'</code> indicating the transpose of <code class="reqn">e</code>.  This Equation 2.20a from Browne (1984) where he showed that this statistic is chi-square distributed with the conventional degrees of freedom.
</p>
<p>Mean and variance adjusted Chi Square statistics are also computed following Asparouhov and Muthen (2006).
</p>


<h3>Value</h3>

<p>A named list with components
</p>

<dl>
<dt>Chi</dt><dd><p>numeric value of the Chi Square fit statistic.</p>
</dd>
<dt>ChiDoF</dt><dd><p>degrees of freedom for the Chi Square fit statistic.</p>
</dd>
<dt>ChiM</dt><dd><p>numeric value of the mean adjusted Chi Square fit statistic</p>
</dd>
<dt>ChiMV</dt><dd><p>numeric value of the mean and variance adjusted Chi Square fit statistic</p>
</dd>
<dt>mAdjust</dt><dd><p>numeric value of the mean adjustment</p>
</dd>
<dt>mvAdjust</dt><dd><p>numeric value of the mean and variance adjustment</p>
</dd>
<dt>dstar</dt><dd><p>adjusted degrees of freedom for the mean and variance adjusted Chi Square fit statistic</p>
</dd>
</dl>



<h3>References</h3>

<p>M. W. Browne. (1984).  Asymptotically Distribution-Free Methods for the Analysis of Covariance Structures. <em>British Journal of Mathematical and Statistical Psychology</em>, <strong>37</strong>, 62-83.
</p>
<p>T. Asparouhov and B. O. Muthen.  (2006).  Robust Chi Square Difference Testing with Mean and Variance Adjusted Test Statistics.  <em>Mplus Web Notes: No. 10</em>.
</p>

<hr>
<h2 id='imxWlsStandardErrors'>Calculate Standard Errors for a WLS Model</h2><span id='topic+imxWlsStandardErrors'></span>

<h3>Description</h3>

<p>This is an internal function used to calculate standard errors for weighted least squares models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imxWlsStandardErrors(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imxWlsStandardErrors_+3A_model">model</code></td>
<td>
<p>An MxModel object with acov (WLS) data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard errors for models fit with maximum likelihood are related to the second derivative (Hessian) of the likelihood function with respect to the free parameters.  For models fit with weighted least squares a different expression is required.  If <code class="reqn">J</code> is the first derivative (Jacobian) of the mapping from the free parameters to the unique elements of the expected covariance, means, and thresholds, <code class="reqn">V</code> is the weight matrix used, <code class="reqn">W</code> is the inverse of the full weight matrix, and <code class="reqn">U= V J (J' V J)^{-1}</code>, then the asymptotic covariance matrix of the free parameters is
</p>
<p style="text-align: center;"><code class="reqn">Acov(\theta) = U' W U</code>
</p>

<p>with <code class="reqn">U'</code> indicating the transpose of <code class="reqn">U</code>.
</p>


<h3>Value</h3>

<p>A named list with components 
</p>

<dl>
<dt>SE</dt><dd><p>The standard errors of the free parameters</p>
</dd>
<dt>Cov</dt><dd><p>The full covariance matrix of the free parameters.  The square root of the diagonal elements of Cov equals SE.</p>
</dd>
<dt>Jac</dt><dd><p>The Jacobian computed to obtain the standard errors.</p>
</dd>
</dl>



<h3>References</h3>

<p>M. W. Browne. (1984).  Asymptotically Distribution-Free Methods for the Analysis of Covariance Structures. <em>British Journal of Mathematical and Statistical Psychology</em>, <strong>37</strong>, 62-83.
</p>
<p>F. Yang-Wallentin, K. G. J&ouml;reskog, &amp; H. Luo.  (2010).   Confirmatory Factor Analysis of Ordinal Variables with Misspecified Models.  <em>Structural Equation Modeling</em>, <strong>17</strong>, 392-423.
</p>

<hr>
<h2 id='jointdata'>
Joint Ordinal and continuous variables to be modeled together
</h2><span id='topic+jointdata'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("jointdata")</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following variables.
</p>

<dl>
<dt><code>z1</code></dt><dd><p>Continuous variable</p>
</dd>
<dt><code>z2</code></dt><dd><p>Ordinal variable with 2 levels (0, 1)</p>
</dd>
<dt><code>z3</code></dt><dd><p>Continuous variable</p>
</dd>
<dt><code>z4</code></dt><dd><p>Ordinal variable with 4 levels (0, 1, 2, 3)</p>
</dd>
<dt><code>z5</code></dt><dd><p>Ordinal variable with 3 levels (0, 1, 3)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data generated to test the joint ML algorithm thoroughly.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jointdata)
head(jointdata)
</code></pre>

<hr>
<h2 id='latentMultipleRegExample1'>
Example data for multiple regression among latent variables
</h2><span id='topic+latentMultipleRegExample1'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("latentMultipleRegExample1")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following variables.
</p>

<dl>
<dt><code>X1</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X2</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X3</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X4</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X5</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X6</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X7</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X8</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X9</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X10</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X11</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X12</code></dt><dd><p>Factor 3 indicator</p>
</dd>
</dl>



<h3>Details</h3>

<p>Factor 1 strongly predicts factor 3.  Factor 2 weakly predicts factor 3.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latentMultipleRegExample1)
round(cor(latentMultipleRegExample1), 2)
</code></pre>

<hr>
<h2 id='latentMultipleRegExample2'>
Example data for multiple regression among latent variables
</h2><span id='topic+latentMultipleRegExample2'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("latentMultipleRegExample2")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following variables.
</p>

<dl>
<dt><code>X1</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X2</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X3</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X4</code></dt><dd><p>Factor 1 indicator</p>
</dd>
<dt><code>X5</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X6</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X7</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X8</code></dt><dd><p>Factor 2 indicator</p>
</dd>
<dt><code>X9</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X10</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X11</code></dt><dd><p>Factor 3 indicator</p>
</dd>
<dt><code>X12</code></dt><dd><p>Factor 3 indicator</p>
</dd>
</dl>



<h3>Details</h3>

<p>Factor 1 strongly predicts factor 3.  Factor 2 weakly predicts factor 3.  Very similar to <a href="#topic+latentMultipleRegExample1">latentMultipleRegExample1</a>.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(latentMultipleRegExample2)
round(cor(latentMultipleRegExample2), 2)
</code></pre>

<hr>
<h2 id='lazarsfeld'>
Respondent-soldiers on four dichotomous items
</h2><span id='topic+lazarsfeld'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lazarsfeld")</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on four dichotomous items.
</p>

<dl>
<dt><code>armyrun</code></dt><dd><p>In general how do you feel the Army is run?</p>
</dd>
<dt><code>favatt</code></dt><dd><p>Do you think when you are discharged you will [have] a favorable attitude toward the Army?</p>
</dd>
<dt><code>squaredeal</code></dt><dd><p>In general do you feel you yourself have gotten a square deal from the Army?</p>
</dd>
<dt><code>welfare</code></dt><dd><p>Do you feel that the Army is trying its best to look out for the welfare of enlisted men?</p>
</dd>
<dt><code>frequency</code></dt><dd><p>Frequency of response pattern.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A straightforward descriptive analysis of these data shows that negative responses are more numerous except on item 1; and that there is a positive association between each pair of items. A soldier who responds positively to any one item is more likely to respond positively to a second item. Lazarsfeld's analysis is based on the assumption that each soldier can be thought of as belong to one of two latent classes. The probability of positive response to an item is different in one group than in the other. Most importantly, he is willing to assume that for an individual respondent the responses to items are statistically independent.
</p>


<h3>Source</h3>

<p>Lazarsfeld, Paul F. (1950b) &quot;Some Latent Structures&quot;, Chapter 11 in Stouffer (1950).
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>http://www.people.vcu.edu/~nhenry/LSA50.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lazarsfeld)

</code></pre>

<hr>
<h2 id='logm'>Matrix logarithm</h2><span id='topic+logm'></span>

<h3>Description</h3>

<p>Matrix logarithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logm(x, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logm_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="logm_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
</table>

<hr>
<h2 id='LongitudinalOverdispersedCounts'>
Longitudinal, Overdispersed Count Data
</h2><span id='topic+LongitudinalOverdispersedCounts'></span><span id='topic+longData'></span><span id='topic+wideData'></span>

<h3>Description</h3>

<p>Four-timepoint longitudinal data generated from an arbitrary Monte Carlo simulation, for 1000 simulees.  The response variable is a discrete count variable.  There are three time-invariant covariates.  The data are available in both &quot;wide&quot; and &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LongitudinalOverdispersedCounts")</code></pre>


<h3>Format</h3>

<p>The &quot;long&quot; format dataframe, <code>longData</code>, has 4000 rows and the following variables (columns):
</p>

<ol>
<li><p><code>id</code>: Factor; simulee ID code.
</p>
</li>
<li><p><code>tiem</code>: Numeric; represents the time metric, wave of assessment.
</p>
</li>
<li><p><code>x1</code>: Numeric; time-invariant covariate.
</p>
</li>
<li><p><code>x2</code>: Numeric; time-invariant covariate.
</p>
</li>
<li><p><code>x3</code>: Numeric; time-invariant covariate.
</p>
</li>
<li><p><code>y</code>: Numeric; the response (&quot;dependent&quot;) variable.
</p>
</li></ol>

<p>The &quot;wide&quot; format dataset, <code>wideData</code>, is a numeric 1000x12 matrix containing the following variables (columns):
</p>

<ol>
<li><p><code>id</code>: Simulee ID code.
</p>
</li>
<li><p><code>x1</code>: Time-invariant covariate.
</p>
</li>
<li><p><code>x3</code>: Time-invariant covariate.
</p>
</li>
<li><p><code>x3</code>: Time-invariant covariate.
</p>
</li>
<li><p><code>y0</code>: Response at initial wave of assessment.
</p>
</li>
<li><p><code>y1</code>: Response at first follow-up.
</p>
</li>
<li><p><code>y2</code>: Response at second follow-up.
</p>
</li>
<li><p><code>y3</code>: Response at third follow-up.
</p>
</li>
<li><p><code>t0</code>: Time variable at initial wave of assessment (in this case, 0).
</p>
</li>
<li><p><code>t1</code>: Time variable at first follow-up (in this case, 1).
</p>
</li>
<li><p><code>t2</code>: Time variable at second follow-up (in this case, 2).
</p>
</li>
<li><p><code>t3</code>: Time variable at third follow-up (in this case, 3).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data(LongitudinalOverdispersedCounts)
head(wideData)
str(longData)
#Let's try ordinary least-squares (OLS) regression:
olsmod &lt;- lm(y~tiem+x1+x2+x3, data=longData)
#We will see in the diagnostic plots that the residuals are poorly approximated by normality, 
#and are heteroskedastic.  We also know that the residuals are not independent of one another, 
#because we have repeated-measures data:
plot(olsmod)
#In the summary, it looks like all of the regression coefficients are significantly different 
#from zero, but we know that because the assumptions of OLS regression are violated that 
#we should not trust its results:
summary(olsmod)

#Let's try a generalized linear model (GLM).  We'll use the quasi-Poisson quasilikelihood 
#function to see how well the y variable is approximated by a Poisson distribution 
#(conditional on time and covariates):
glm.mod &lt;- glm(y~tiem+x1+x2+x3, data=longData, family="quasipoisson")
#The estimate of the dispersion parameter should be about 1.0 if the data are 
#conditionally Poisson.  We can see that it is actually greater than 2, 
#indicating overdispersion:
summary(glm.mod)
</code></pre>

<hr>
<h2 id='multiData1'>
Data for multiple regression
</h2><span id='topic+multiData1'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("multiData1")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd></dd>
<dt><code>x2</code></dt><dd></dd>
<dt><code>x3</code></dt><dd></dd>
<dt><code>x4</code></dt><dd></dd>
<dt><code>y</code></dt><dd></dd>
</dl>



<h3>Details</h3>

<p>x1-x4 are predictor variables, and y is the outcome.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(multiData1)
summary(lm(y ~ ., data=multiData1))
#results can be replicated in OpenMx.

</code></pre>

<hr>
<h2 id='mxAlgebra'>Create MxAlgebra Object</h2><span id='topic+mxAlgebra'></span><span id='topic+p2z'></span><span id='topic+logp2z'></span><span id='topic+lgamma1p'></span><span id='topic+omxDnbinom'></span><span id='topic+omxPnbinom'></span><span id='topic+mxRobustLog'></span><span id='topic++25+26+25'></span><span id='topic++25+5E+25'></span><span id='topic+mpinv'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxAlgebra">MxAlgebra</a>. The common use is to compute a value in a model: for instance a
standardized value of a parameter, or a parameter which is a function of other values. It is also used in
models with an  <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> objective function.
</p>
<p><strong>note</strong>: Unless needed in the model objective, algebras are only computed twice: once at the
beginning and once at the end of running a model, so adding them doesn't often add a lot of overhead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxAlgebra(expression, name = NA, dimnames = NA, ..., fixed = FALSE,
          joinKey=as.character(NA), joinModel=as.character(NA),
	verbose=0L, initial=matrix(as.numeric(NA),1,1),
        recompute=c('always','onDemand'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxAlgebra_+3A_expression">expression</code></td>
<td>
<p>An R expression of OpenMx-supported matrix operators and matrix functions.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_name">name</code></td>
<td>
<p>An optional character string indicating the name of the object.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_dimnames">dimnames</code></td>
<td>
<p>list. The dimnames attribute for the algebra: a list
of length 2 giving the row and column names respectively. An empty
list is treated as NULL, and a list of length one as row names. The
list can be named, and the list names will be used as names for the
dimensions.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_...">...</code></td>
<td>
<p>Not used.  Forces other arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_fixed">fixed</code></td>
<td>
<p>Deprecated. Use the &lsquo;recompute&rsquo; argument instead.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_joinkey">joinKey</code></td>
<td>
<p>The name of the column in current model's raw data that
is used as a foreign key to match against the primary key in
the joinModel's raw data.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_joinmodel">joinModel</code></td>
<td>
<p>The name of the model that this matrix joins against.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_verbose">verbose</code></td>
<td>
<p>For values greater than zero, enable runtime
diagnostics.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_initial">initial</code></td>
<td>
<p>a matrix. When <code>recompute='onDemand'</code>,
you must provide this initial algebra result.</p>
</td></tr>
<tr><td><code id="mxAlgebra_+3A_recompute">recompute</code></td>
<td>
<p>If &lsquo;onDemand&rsquo;, this algebra will not be recomputed
automatically when things it depends on change. <a href="#topic+mxComputeOnce">mxComputeOnce</a>
can be used to force it to recompute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxAlgebra function is used to create algebraic expressions that operate on one or more
<a href="#topic+MxMatrix">MxMatrix</a> objects. To evaluate an <a href="#topic+MxAlgebra">MxAlgebra</a> object,
it must be placed in an <a href="#topic+MxModel">MxModel</a> object, along with all referenced <code>MxMatrix</code>
objects and the <code>mxFitFunctionAlgebra</code> function.
The <code>mxFitFunctionAlgebra</code> function must reference by name the <code>MxAlgebra</code> object to be evaluated.
</p>
<p><strong>Note</strong>: f the result for an <a href="#topic+MxAlgebra">MxAlgebra</a> depends upon one or more &quot;definition variables&quot; (see <code><a href="#topic+mxMatrix">mxMatrix</a>()</code>),
then the value returned after the call to <code><a href="#topic+mxRun">mxRun</a>()</code> will be computed using the values of those definition
variables in the first (i.e., first before any automated sorting is done) row of the raw dataset.
</p>
<p>The following operators and functions are supported in mxAlgebra:
</p>
<p>Operators
</p>

<dl>
<dt><code>solve()</code></dt><dd><p>Inversion</p>
</dd>
<dt><code>t()</code></dt><dd><p>Transposition</p>
</dd>
<dt><code>^</code></dt><dd><p>Elementwise powering</p>
</dd>
<dt><code>%^%</code></dt><dd><p>Kronecker powering</p>
</dd>
<dt><code>+</code></dt><dd><p>Addition</p>
</dd>
<dt><code>-</code></dt><dd><p>Subtraction</p>
</dd>
<dt><code>%*%</code></dt><dd><p>Matrix Multiplication</p>
</dd>
<dt><code>*</code></dt><dd><p>Elementwise product</p>
</dd>
<dt><code>/</code></dt><dd><p>Elementwise division</p>
</dd>
<dt><code>%x%</code></dt><dd><p>Kronecker product</p>
</dd>
<dt><code>%&amp;%</code></dt><dd><p>Quadratic product: pre- and post-multiply B by A and its transpose t(A), i.e: A <code>%&amp;%</code> B ==  A <code>%*%</code> B <code>%*%</code> t(A)</p>
</dd>
</dl>

<p>Functions
</p>

<dl>
<dt><code>cov2cor</code></dt><dd><p>Convert covariance matrix to correlation matrix</p>
</dd>
<dt><code>chol</code></dt><dd><p>Cholesky Decomposition</p>
</dd>
<dt><code>cbind</code></dt><dd><p>Horizontal adhesion</p>
</dd>
<dt><code>rbind</code></dt><dd><p>Vertical adhesion</p>
</dd>
<dt><code>colSums</code></dt><dd><p>Matrix column sums as a column vector</p>
</dd>
<dt><code>rowSums</code></dt><dd><p>Matrix row sums as a column vector</p>
</dd>
<dt><code>det</code></dt><dd><p>Determinant</p>
</dd>
<dt><code>tr</code></dt><dd><p>Trace</p>
</dd>
<dt><code>sum</code></dt><dd><p>Sum</p>
</dd>
<dt><code>mean</code></dt><dd><p>Arithmetic mean</p>
</dd>
<dt><code>prod</code></dt><dd><p>Product</p>
</dd>
<dt><code>max</code></dt><dd><p>Maximum</p>
</dd>
<dt><code>min</code></dt><dd><p>Min</p>
</dd>
<dt><code>abs</code></dt><dd><p>Absolute value</p>
</dd>
<dt><code>sin</code></dt><dd><p>Sine</p>
</dd>
<dt><code>sinh</code></dt><dd><p>Hyperbolic sine</p>
</dd>
<dt><code>asin</code></dt><dd><p>Arcsine</p>
</dd>
<dt><code>asinh</code></dt><dd><p>Inverse hyperbolic sine</p>
</dd>
<dt><code>cos</code></dt><dd><p>Cosine</p>
</dd>
<dt><code>cosh</code></dt><dd><p>Hyperbolic cosine</p>
</dd>
<dt><code>acos</code></dt><dd><p>Arccosine</p>
</dd>
<dt><code>acosh</code></dt><dd><p>Inverse hyperbolic cosine</p>
</dd>
<dt><code>tan</code></dt><dd><p>Tangent</p>
</dd>
<dt><code>tanh</code></dt><dd><p>Hyperbolic tangent</p>
</dd>
<dt><code>atan</code></dt><dd><p>Arctangent</p>
</dd>
<dt><code>atanh</code></dt><dd><p>Inverse hyperbolic tangent</p>
</dd>
<dt><code>exp</code></dt><dd><p>Exponent</p>
</dd>
<dt><code>log</code></dt><dd><p>Natural Logarithm</p>
</dd>
<dt><code>mxRobustLog</code></dt><dd><p>Robust natural logarithm</p>
</dd>
<dt><code>sqrt</code></dt><dd><p>Square root</p>
</dd>
<dt><code>p2z</code></dt><dd><p><em>Standard</em>-normal quantile</p>
</dd>
<dt><code>logp2z</code></dt><dd><p><em>Standard</em>-normal quantile from log probabilities</p>
</dd>
<dt><code>lgamma</code></dt><dd><p>Log-gamma function</p>
</dd>
<dt><code>lgamma1p</code></dt><dd><p>Compute log(gamma(x+1)) accurately for small x</p>
</dd>
<dt><code><a href="#topic+eigenval">eigenval</a></code></dt><dd><p>Eigenvalues of a square matrix. Usage: eigenval(x); eigenvec(x); ieigenval(x); ieigenvec(x)</p>
</dd>
<dt><code><a href="#topic+rvectorize">rvectorize</a></code></dt><dd><p>Vectorize by row</p>
</dd>
<dt><code><a href="#topic+cvectorize">cvectorize</a></code></dt><dd><p>Vectorize by column</p>
</dd>
<dt><code><a href="#topic+vech">vech</a></code></dt><dd><p>Half-vectorization</p>
</dd>
<dt><code><a href="#topic+vechs">vechs</a></code></dt><dd><p>Strict half-vectorization</p>
</dd>
<dt><code><a href="#topic+vech2full">vech2full</a></code></dt><dd><p>Inverse half-vectorization</p>
</dd>
<dt><code><a href="#topic+vechs2full">vechs2full</a></code></dt><dd><p>Inverse strict half-vectorization</p>
</dd>
<dt><code><a href="#topic+vec2diag">vec2diag</a></code></dt><dd><p>Create matrix from a diagonal vector (similar to <a href="base.html#topic+diag">diag</a>) </p>
</dd>
<dt><code><a href="#topic+diag2vec">diag2vec</a></code></dt><dd><p>Extract diagonal from matrix (similar to <a href="base.html#topic+diag">diag</a>) </p>
</dd>
<dt><code><a href="#topic+expm">expm</a></code></dt><dd><p>Matrix Exponential</p>
</dd>
<dt><code><a href="#topic+logm">logm</a></code></dt><dd><p>Matrix Logarithm</p>
</dd>
<dt><code><a href="#topic+omxExponential">omxExponential</a></code></dt><dd><p>Matrix Exponential</p>
</dd>
<dt><code><a href="#topic+omxMnor">omxMnor</a></code></dt><dd><p>Multivariate Normal Integration</p>
</dd>
<dt><code><a href="#topic+omxAllInt">omxAllInt</a></code></dt><dd><p>All cells Multivariate Normal Integration</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxNot</a></code></dt><dd><p>Perform unary negation on a matrix</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxAnd</a></code></dt><dd><p>Perform binary and on two matrices</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxOr</a></code></dt><dd><p>Perform binary or on two matrices</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxGreaterThan</a></code></dt><dd><p>Perform binary greater on two matrices</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxLessThan</a></code></dt><dd><p>Perform binary less than on two matrices</p>
</dd>
<dt><code><a href="#topic+omxLogical">omxApproxEquals</a></code></dt><dd><p>Perform binary equals to (within a specified epsilon) on two matrices</p>
</dd>
<dt><code><a href="#topic+omxSelectRowsAndCols">omxSelectRows</a></code></dt><dd><p>Filter rows from a matrix</p>
</dd>
<dt><code><a href="#topic+omxSelectRowsAndCols">omxSelectCols</a></code></dt><dd><p>Filter columns from a matrix</p>
</dd>
<dt><code><a href="#topic+omxSelectRowsAndCols">omxSelectRowsAndCols</a></code></dt><dd><p>Filter rows and columns from a matrix</p>
</dd>
<dt><code><a href="#topic+mxEvaluateOnGrid">mxEvaluateOnGrid</a></code></dt><dd><p>Evaluate
an algebra on an abscissa grid and collect column results</p>
</dd>
<dt><code><a href="#topic+mpinv">mpinv</a></code></dt><dd><p>Moore-Penrose Inverse</p>
</dd>
</dl>

<p>If <code>solve</code> is used on an uninvertible square matrix in R, via
<code><a href="#topic+mxEval">mxEval()</a></code>, it will fail with an error will; if
<code>solve</code> is used on an uninvertible square matrix during
<a href="#topic+mxRun">runtime</a>, it will fail silently.
</p>
<p><code>mxRobustLog</code> is the same as <code>log</code> except that it returns -745
instead of -Inf for an argument of 0. The value -745 is less than
log(4.94066e-324), a good approximation of negative infinity because the
log of any number represented as a double will be of smaller absolute
magnitude.
</p>
<p>There are also several multi-argument functions usable in MxAlgebras, which apply themselves elementwise to the matrix provided as their first argument.  These functions have slightly different usage from their <span class="rlang"><b>R</b></span> counterparts.  Their result is always a matrix with the same dimensions as that provided for their first argument.  Values must be provided for ALL arguments of these functions, in order.  Provide zeroes as logical values of <code>FALSE</code>, and non-zero numerical values as logical values of <code>TRUE</code>.  For most of these functions, OpenMx cycles over values of arguments other than the first, by column (i.e., in column-major order), to the length of the first argument.  Notable exceptions are the <code>log</code>, <code>log.p</code>, and <code>lower.tail</code> arguments to probability-distribution-related functions, for which only the [1,1] element is used.  It is recommended that all arguments after the first be either (1) scalars, or (2) matrices with the same dimensions as the first argument.
</p>

<table>
<tr>
 <td style="text-align: center;">
Function </td><td style="text-align: center;"> Arguments </td><td style="text-align: left;"> Notes </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>besselI</code> &amp; <code>besselK</code> </td><td style="text-align: center;"> <code>x,nu,expon.scaled</code> </td><td style="text-align: left;"> Note that OpenMx <em>does</em> cycle over the elements of <code>expon.scaled</code>. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>besselJ</code> &amp; <code>besselY</code> </td><td style="text-align: center;"> <code>x,nu</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dbeta</code> </td><td style="text-align: center;"> <code>x,shape1,shape2,ncp,log</code> </td><td style="text-align: left;"> The algorithm for the non-central beta distribution is used for non-negative values of <code>ncp</code>.  Negative <code>ncp</code> values are ignored, and the algorithm for the central beta distribution is used. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pbeta</code> </td><td style="text-align: center;"> <code>q,shape1,shape2,ncp,lower.tail,log.p</code> </td><td style="text-align: left;"> Values of <code>ncp</code> are handled as with <code>dbeta()</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dbinom</code> </td><td style="text-align: center;"> <code>x,size,prob,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pbinom</code> </td><td style="text-align: center;"> <code>q,size,prob,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dcauchy</code> </td><td style="text-align: center;"> <code>x,location,scale,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pcauchy</code> </td><td style="text-align: center;"> <code>q,location,scale,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dchisq</code> </td><td style="text-align: center;"> <code>x,df,ncp,log</code> </td><td style="text-align: left;">  The algorithm for the non-central chi-square distribution is used for non-negative values of <code>ncp</code>.  Negative <code>ncp</code> values are ignored, and the algorithm for the central chi-square distribution is used. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>pchisq</code> </td><td style="text-align: center;"> <code>q,df,ncp,lower.tail,log.p</code> </td><td style="text-align: left;"> Values of <code>ncp</code> are handled as with <code>dchisq()</code>. </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>omxDnbinom</code> </td><td style="text-align: center;"> <code>x,size,prob,mu,log</code> </td><td style="text-align: left;"> Exactly one of arguments <code>size</code>, <code>prob</code>, and <code>mu</code> should be negative, and therefore ignored.  Otherwise, <code>mu</code> is ignored, possibly with a warning, and the values of <code>size</code> and <code>prob</code> are used, irrespective of whether they are in the parameter space.  If only <code>prob</code> is negative, the algorithm for the alternative <code>size</code>-<code>mu</code> parameterization is used.  If <code>size</code> is negative, a value for <code>size</code> is calculated as <code>mu*prob/(1-prob)</code>, and the algorithm for the <code>size</code>-<code>prob</code> parameterization is used (note that this approach is ill-advised when <code>prob</code> is very close to 0 or 1).</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>omxPnbinom</code> </td><td style="text-align: center;"> <code>q,size,prob,mu,lower.tail,log.p</code> </td><td style="text-align: left;"> Arguments are handled as with <code>omxDnbinom()</code>.</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>dpois</code> </td><td style="text-align: center;"> <code>x,lambda,log</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
<code>ppois</code> </td><td style="text-align: center;"> <code>q,lambda,lower.tail,log.p</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a new <a href="#topic+MxAlgebra">MxAlgebra</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+MxAlgebra">MxAlgebra</a> for the S4 class created by mxAlgebra. <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> for an objective function which takes an  MxAlgebra or MxMatrix object as the function to be minimized.
<a href="#topic+MxMatrix">MxMatrix</a> and <a href="#topic+mxMatrix">mxMatrix</a> for objects which may be entered in the <code>expression</code> argument and the function that creates them. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- mxMatrix("Full", nrow = 3, ncol = 3, values=2, name = "A")

# Simple example: algebra B simply evaluates to the matrix A
B &lt;- mxAlgebra(A, name = "B")

# Compute A + B
C &lt;- mxAlgebra(A + B, name = "C")

# Compute sin(C)
D &lt;- mxAlgebra(sin(C), name = "D")

# Make a model and evaluate the mxAlgebra object 'D'
A &lt;- mxMatrix("Full", nrow = 3, ncol = 3, values=2, name = "A")
model &lt;- mxModel(model="AlgebraExample", A, B, C, D )
fit   &lt;- mxRun(model)
mxEval(D, fit)


# Numbers in mxAlgebras are upgraded to 1x1 matrices
# Example of Kronecker powering (%^%) and multiplication (%*%)
A  &lt;- mxMatrix(type="Full", nrow=3, ncol=3, value=c(1:9), name="A")
m1 &lt;- mxModel(model="kron", A, mxAlgebra(A %^% 2, name="KroneckerPower"))
mxRun(m1)$KroneckerPower

# Running kron
# mxAlgebra 'KroneckerPower'
# $formula:  A %^% 2
# $result:
#      [,1] [,2] [,3]
# [1,]    1   16   49
# [2,]    4   25   64
# [3,]    9   36   81

</code></pre>

<hr>
<h2 id='MxAlgebra-class'>MxAlgebra Class</h2><span id='topic+MxAlgebra-class'></span><span id='topic+MxAlgebra'></span><span id='topic+print+2CMxAlgebra-method'></span><span id='topic+show+2CMxAlgebra-method'></span><span id='topic++24+2CMxAlgebra-method'></span><span id='topic++24+3C-+2CMxAlgebra-method'></span><span id='topic+dimnames+2CMxAlgebra-method'></span><span id='topic+dimnames+3C-+2CMxAlgebra-method'></span><span id='topic+dimnames+3C-+2CMxAlgebra+2CANY-method'></span>

<h3>Description</h3>

<p>MxAlgebra is an S4 class. An MxAlgebra object is a <a href="#topic+Named-entity">named entity</a>.
New instances of this class can be created using the function <a href="#topic+mxAlgebra">mxAlgebra</a>.
</p>


<h3>Details</h3>

<p>The MxAlgebra class has the following slots:
</p>

<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: center;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
    name </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The name of the object </td>
</tr>
<tr>
 <td style="text-align: right;">
    formula </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The R expression to be evaluated </td>
</tr>
<tr>
 <td style="text-align: right;"> 
    result </td><td style="text-align: center;"> - </td><td style="text-align: left;"> a matrix with the computation result
  </td>
</tr>

</table>

<p>The &lsquo;name&rsquo; slot is the name of the MxAlgebra object. Use of MxAlgebra objects in the <code><a href="#topic+mxConstraint">mxConstraint</a></code> function or an objective function requires reference by name.
</p>
<p>The &lsquo;formula&rsquo; slot is an expression containing the expression to be evaluated. These objects are operated on or related to one another using one or more operations detailed in the <code><a href="#topic+mxAlgebra">mxAlgebra</a></code> help file.
</p>
<p>The &lsquo;result&rsquo; slot is used to hold the results of computing the expression in the &lsquo;formula&rsquo; slot. If the containing model has not been executed, then the &lsquo;result&rsquo; slot will hold a 0 x 0 matrix.  Otherwise the slot will store the computed value of the algebra using the final estimates of the free parameters.
</p>
<p>Slots may be referenced with the $ symbol. See the documentation for <a href="methods.html#topic+Classes">Classes</a> and the examples in the <code><a href="#topic+mxAlgebra">mxAlgebra</a></code> document for more information.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxAlgebra">mxAlgebra</a></code>, <code><a href="#topic+mxMatrix">mxMatrix</a></code>, <code><a href="#topic+MxMatrix">MxMatrix</a></code> 
</p>

<hr>
<h2 id='MxAlgebraFormula-class'>MxAlgebraFormula</h2><span id='topic+MxAlgebraFormula-class'></span><span id='topic+MxAlgebraFormula'></span><span id='topic+print+2CMxAlgebraFormula-method'></span><span id='topic+show+2CMxAlgebraFormula-method'></span>

<h3>Description</h3>

<p>This is an internal class for the formulas used in <code><a href="#topic+mxAlgebra">mxAlgebra</a></code> calls.
</p>

<hr>
<h2 id='mxAlgebraFromString'>Create MxAlgebra object from a string</h2><span id='topic+mxAlgebraFromString'></span>

<h3>Description</h3>

<p>Create MxAlgebra object from a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxAlgebraFromString(algString, name = NA, dimnames = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxAlgebraFromString_+3A_algstring">algString</code></td>
<td>
<p>the character string to convert into an R expression</p>
</td></tr>
<tr><td><code id="mxAlgebraFromString_+3A_name">name</code></td>
<td>
<p>An optional character string indicating the name of the object.</p>
</td></tr>
<tr><td><code id="mxAlgebraFromString_+3A_dimnames">dimnames</code></td>
<td>
<p>list. The dimnames attribute for the algebra: a list of length 2 giving the row and column names respectively. An empty list is treated as NULL, and a list of length one as row names. The list can be named, and the list names will be used as names for the dimensions.</p>
</td></tr>
<tr><td><code id="mxAlgebraFromString_+3A_...">...</code></td>
<td>
<p>Forwarded verbatim to <a href="#topic+mxAlgebra">mxAlgebra</a></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mxAlgebra">mxAlgebra</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- mxMatrix(values = runif(25), nrow = 5, ncol = 5, name = 'A')
B &lt;- mxMatrix(values = runif(25), nrow = 5, ncol = 5, name = 'B')
model &lt;- mxModel(A, B, name = 'model',
  mxAlgebraFromString("A * (B + A)", name = 'test'))
model &lt;- mxRun(model)
model[['test']]$result
A$values * (B$values + A$values)
</code></pre>

<hr>
<h2 id='mxAlgebraObjective'>DEPRECATED:  Create MxAlgebraObjective Object</h2><span id='topic+mxAlgebraObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use MxFitFunctionAlgebra() instead.  As a temporary workaround, MxAlgebraObjective returns a list containing a NULL MxExpectation object and an MxFitFunctionAlgebra object.
</p>
<p>All occurrences of
</p>
<p>mxAlgebraObjective(algebra, numObs = NA, numStats = NA)
</p>
<p>Should be changed to
</p>
<p>mxFitFunctionAlgebra(algebra, numObs = NA, numStats = NA)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxAlgebraObjective_+3A_algebra">algebra</code></td>
<td>
<p>A character string indicating the name of an <a href="#topic+MxAlgebra">MxAlgebra</a> or <a href="#topic+MxMatrix">MxMatrix</a> object to use for optimization.</p>
</td></tr>
<tr><td><code id="mxAlgebraObjective_+3A_numobs">numObs</code></td>
<td>
<p>(optional) An adjustment to the total number of observations in the model.</p>
</td></tr>
<tr><td><code id="mxAlgebraObjective_+3A_numstats">numStats</code></td>
<td>
<p>(optional) An adjustment to the total number of observed statistics in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: THIS DESCRIPTION IS DEPRECATED.  Please change to using <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> as shown in the example below.
</p>
<p>Fit functions are functions for which free parameter values are chosen such that the value of the objective function is minimized. While the other fit functions in OpenMx require an expectation function for the model, the <code>mxAlgebraObjective</code> function uses the referenced <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object as the function to be minimized.
</p>
<p>If a model's primary objective function is a <code>mxAlgebraObjective</code> objective function, then the referenced algebra in the objective function must return a 1 x 1 matrix (when using OpenMx's default optimizer).  There is no restriction on the dimensions of an objective function that is not the primary, or &lsquo;topmost&rsquo;, objective function.
</p>
<p>To evaluate an algebra objective function, place the following objects in a <code><a href="#topic+MxModel">MxModel</a></code> object: a <code>MxAlgebraObjective</code>, <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> and <code><a href="#topic+MxMatrix">MxMatrix</a></code> entities referenced by the <code>MxAlgebraObjective</code>, and optional <code><a href="#topic+MxBounds">MxBounds</a></code> and <code><a href="#topic+MxConstraint">MxConstraint</a></code> entities. This model may then be evaluated using the <code><a href="#topic+mxRun">mxRun</a></code> function. The results of the optimization may be obtained using the <code><a href="#topic+mxEval">mxEval</a></code> function on the name of the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code>, after the model has been run.
</p>


<h3>Value</h3>

<p>Returns a list containing a NULL MxExpectation object and an MxFitFunctionAlgebra object.  MxFitFunctionAlgebra objects should be included with models with referenced <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> and <code><a href="#topic+MxMatrix">MxMatrix</a></code> objects.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxAlgebra">mxAlgebra</a> to create an algebra suitable as a reference function to be minimized. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a very simple model that adds two numbers using mxFitFunctionAlgebra

library(OpenMx)

# Create a matrix 'A' with no free parameters
A &lt;- mxMatrix('Full', nrow = 1, ncol = 1, values = 1, name = 'A')

# Create an algebra 'B', which defines the expression A + A
B &lt;- mxAlgebra(A + A, name = 'B')

# Define the objective function for algebra 'B'
objective &lt;- mxFitFunctionAlgebra('B')

# Place the algebra, its associated matrix and 
# its objective function in a model
tmpModel &lt;- mxModel(model="Addition", A, B, objective)

# Evalulate the algebra
tmpModelOut &lt;- mxRun(tmpModel)

# View the results
tmpModelOut$output$minimum
</code></pre>

<hr>
<h2 id='mxAutoStart'>Automatically set starting values for an MxModel</h2><span id='topic+mxAutoStart'></span>

<h3>Description</h3>

<p>Automatically set starting values for an MxModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxAutoStart(model, type = c("ULS", "DWLS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxAutoStart_+3A_model">model</code></td>
<td>
<p>The MxModel for which starting values are desired</p>
</td></tr>
<tr><td><code id="mxAutoStart_+3A_type">type</code></td>
<td>
<p>The type of starting values to obtain, currently unweighted or diagonally weighted least squares, ULS or DWLS</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically picks very good starting values for many models (RAM, LISREL, Normal), including multiple group versions of these.
It works for models with algebras. Models of continuous, ordinal, and joint ordinal-continuous variables are also acceptable.
It works for models with covariance or raw data.
However, it does not currently work for models with definition variables, state space models, item factor analysis models, or multilevel models.
</p>
<p>The method used to obtain new starting values is quite simple. The user's model is changed to an unweighted least squares (ULS) model. The ULS model is estimated and its final point estimates are returned as the new starting values. Optionally, diagonally weighted least squares (DWLS) can be used instead with the <code>type</code> argument.
</p>
<p>Please note that ULS is sensitive to the scales of your variables. For example, if you have variables with means of 20 and variances of 0.001, then ULS will &quot;weight&quot; the means 20,000 times more than the variances and might result in zero variance estimates. Likewise if one variable has a variance of 20 and another has a variance of 0.001, the same problem may arise. To avoid this, make sure your variables are scaled accordingly. You could also use <code>type='DWLS'</code> to have the function use diagonally weighted least squares to obtain starting values.  Of course, using diagonally weighted least squares will take much much longer and will usually not provide better starting values than unweighted least squares.
</p>
<p>Also note that if <code>model</code> contains a <a href="#topic+mxExpectationGREML">GREML expectation</a>, argument <code>type</code> is ignored, and the function always uses a form of ULS.
</p>


<h3>Value</h3>

<p>an MxModel with new free parameter values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the frontpage model with negative variances to show better
# starting values
library(OpenMx)
data(demoOneFactor)

latents  = c("G") # the latent factor
manifests = names(demoOneFactor) # manifest variables to be modeled

m1 &lt;- mxModel("One Factor", type = "RAM",
	manifestVars = manifests, latentVars = latents,
	mxPath(from = latents, to = manifests),
	mxPath(from = manifests, arrows = 2, values=-.2),
	mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
	mxPath(from = "one", to = manifests),
	mxData(demoOneFactor, type = "raw")
)

# Starting values imply negative variances!
mxGetExpected(m1, 'covariance')

# Use mxAutoStart to get much better starting values
m1s &lt;- mxAutoStart(m1)
mxGetExpected(m1s, 'covariance')
</code></pre>

<hr>
<h2 id='mxAvailableOptimizers'>mxAvailableOptimizers</h2><span id='topic+mxAvailableOptimizers'></span>

<h3>Description</h3>

<p>List the Optimizers available in this version, e.g. &quot;SLSQP&quot; &quot;CSOLNP&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxAvailableOptimizers()
</code></pre>


<h3>Details</h3>

<p>note for advanced users: Special-purpose optimizers like Newton-Raphson or EM are not included in this list.
</p>


<h3>Value</h3>

<p>- list of valid Optimizer names
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+mxOption">mxOption</a></code>(model, &quot;Default optimizer&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mxAvailableOptimizers()
</code></pre>

<hr>
<h2 id='MxBaseExpectation-class'>MxBaseExpectation</h2><span id='topic+MxBaseExpectation-class'></span><span id='topic++24+2CMxBaseExpectation-method'></span><span id='topic++24+3C-+2CMxBaseExpectation-method'></span>

<h3>Description</h3>

<p>The virtual base class for all expectations. Expectations contain
enough information to generate simulated data.  This is an internal
class and should not be used directly.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxExpectationNormal">mxExpectationNormal</a>, <a href="#topic+mxExpectationRAM">mxExpectationRAM</a>, <a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a>, <a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a>,
<a href="#topic+mxExpectationBA81">mxExpectationBA81</a>
</p>

<hr>
<h2 id='MxBaseFitFunction-class'>MxBaseFitFunction</h2><span id='topic+MxBaseFitFunction-class'></span><span id='topic++24+2CMxBaseFitFunction-method'></span><span id='topic++24+3C-+2CMxBaseFitFunction-method'></span>

<h3>Description</h3>

<p>The virtual base class for all fit functions. This is an internal class and should not be used directly.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a>, <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, <a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a>,
<a href="#topic+mxFitFunctionR">mxFitFunctionR</a>, <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>, <a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a>,
<a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a>
</p>

<hr>
<h2 id='MxBaseNamed-class'>MxBaseNamed</h2><span id='topic+MxBaseNamed-class'></span><span id='topic+MxBaseNamed'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.  It is the
base class for named entities.  Fit functions, expectations, and computes
contain this class.
</p>

<hr>
<h2 id='MxBaseObjectiveMetaData-class'>MxBaseObjectiveMetaData</h2><span id='topic+MxBaseObjectiveMetaData-class'></span><span id='topic+MxBaseObjectiveMetaData'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
It is the virtual base class for all objective functions meta-data
</p>

<hr>
<h2 id='mxBootstrap'>Repeatedly estimate model using resampling with replacement</h2><span id='topic+mxBootstrap'></span>

<h3>Description</h3>

<p>Bootstrapping is used to quantify the variability of parameter estimates.
A new sample is drawn from the model data (uniformly sampling the
original data with replacement). The model is re-fitted to this new
sample. This process is repeated many times. This yields a series of estimates
from these replications which can be used to assess the variability of the parameters.
</p>
<p><em>note</em>: <code>mxBootstrap</code> only bootstraps free model parameters: 
</p>
<p>To bootstrap algebras, see <code><a href="#topic+mxBootstrapEval">mxBootstrapEval</a></code>
</p>
<p>To report bootstrapped standardized paths in RAM models, <code>mxBootstrap</code> the model,
and then run through <code><a href="#topic+mxBootstrapStdizeRAMpaths">mxBootstrapStdizeRAMpaths</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxBootstrap(model, replications=200, ...,
                        data=NULL, plan=NULL, verbose=0L,
                        parallel=TRUE, only=as.integer(NA),
			OK=mxOption(model, "Status OK"), checkHess=FALSE, unsafe=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxBootstrap_+3A_model">model</code></td>
<td>
<p>The MxModel to be run.</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_replications">replications</code></td>
<td>
<p>The number of resampling replications. If
available, replications from prior mxBootstrap invocations will be reused.</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_data">data</code></td>
<td>
<p>A character vector of data or model names</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_plan">plan</code></td>
<td>
<p>Deprecated</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_verbose">verbose</code></td>
<td>
<p>For levels greater than 0, enables runtime diagnostics</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_parallel">parallel</code></td>
<td>
<p>Whether to process the replications in parallel (not yet implemented!)</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_only">only</code></td>
<td>
<p>When provided, only the given replication from a prior
run of <code>mxBootstrap</code> will be performed. See details.</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_ok">OK</code></td>
<td>
<p>The set of status code that are considered successful</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_checkhess">checkHess</code></td>
<td>
<p>Whether to approximate the Hessian in each replication</p>
</td></tr>
<tr><td><code id="mxBootstrap_+3A_unsafe">unsafe</code></td>
<td>
<p>A boolean indicating whether to ignore errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, all datasets in the given model are resampled
independently. If resampling is desired from only some of
the datasets then the models containing them can be listed in the
&lsquo;data&rsquo; parameter.
</p>
<p>The <code>frequency</code> column in the <code><a href="#topic+mxData">mxData</a></code> object is used
represent a resampled dataset. When resampling, the original row
proportions, as given by the original <code>frequency</code> column, are
respected.
</p>
<p>When the model has a default compute plan and &lsquo;checkHess&rsquo; is
kept at FALSE then the Hessian will not be approximated or checked.
On the other hand, &lsquo;checkHess&rsquo; is TRUE then the Hessian will be
approximated by finite differences. This procedure is of some value
because it can be informative to check whether the Hessian is positive
definite (see <code><a href="#topic+mxComputeHessianQuality">mxComputeHessianQuality</a></code>).  However,
approximating the Hessian is often costly in terms of CPU time. For
bootstrapping, the parameter estimates derived from the resampled data
are typically of primary interest.
</p>
<p>On occasion, replications will fail. Sometimes it can be helpful to
exactly reproduce a failed replication to attempt to pinpoint the
cause of failure. The &lsquo;only&rsquo; option facilitates this kind of
investigation. In normal operation, mxBootstrap uses the regular R
random number generator to generate a seed for each replication. This
seed is used to seed an internal pseudorandom number generator
(currently the Mersenne Twister algorithm). These
per-replication seeds are stored as part of the bootstrap output. When
&lsquo;only&rsquo; is specified, the associated stored seed is used to seed the
internal random number generator so that identical weights can be
regenerated.
</p>
<p><code>mxBootstrap</code> does not currently offer special support for nested,
multilevel, or other dependent data structures. <em><code>mxBootstrap</code>
assumes rows of data are independent.</em>  Multilevel models and state space
models violate the independence assumption employed by <code>mxBootstrap</code>.
By default the <code>unsafe</code> argument prevents multilevel and state space
models from using <code>mxBootstrap</code>; however, setting <code>unsafe=TRUE</code>
allows multilevel and state space models to use bootstrapping under the &ndash;
perhaps foolish &ndash; assumption that the user is sufficiently knowledgeable to
interpret the results.
</p>


<h3>Value</h3>

<p>The given model is returned with
the compute plan modified to consist of
<code>mxComputeBootstrap</code>. Results of the bootstrap replications are
stored inside the compute plan. <code><a href="#topic+mxSummary">mxSummary</a></code> can be used to
obtain per-parameter quantiles and standard errors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrapEval">mxBootstrapEval</a></code>, <code><a href="#topic+mxComputeBootstrap">mxComputeBootstrap</a></code>,
<code><a href="#topic+mxSummary">mxSummary</a></code>, <code><a href="#topic+mxBootstrapStdizeRAMpaths">mxBootstrapStdizeRAMpaths</a></code>,
<code><a href="#topic+as.statusCode">as.statusCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

data(multiData1)

manifests &lt;- c("x1", "x2", "y")

biRegModelRaw &lt;- mxModel(
  "Regression of y on x1 and x2",
  type="RAM",
  manifestVars=manifests,
  mxPath(from=c("x1","x2"), to="y", 
         arrows=1, 
         free=TRUE, values=.2, labels=c("b1", "b2")),
  mxPath(from=manifests, 
         arrows=2, 
         free=TRUE, values=.8, 
         labels=c("VarX1", "VarX2", "VarE")),
  mxPath(from="x1", to="x2",
         arrows=2, 
         free=TRUE, values=.2, 
         labels=c("CovX1X2")),
  mxPath(from="one", to=manifests, 
         arrows=1, free=TRUE, values=.1, 
         labels=c("MeanX1", "MeanX2", "MeanY")),
  mxData(observed=multiData1, type="raw"))

biRegModelRawOut &lt;- mxRun(biRegModelRaw)

boot &lt;- mxBootstrap(biRegModelRawOut, 10)   # start with 10
summary(boot)

# Looks good, now do the rest
boot &lt;- mxBootstrap(boot)
summary(boot)

# examine replication 3
boot3 &lt;- mxBootstrap(boot, only=3)

print(coef(boot3))
print(boot$compute$output$raw[3,names(coef(boot3))])
</code></pre>

<hr>
<h2 id='mxBootstrapEval'>Evaluate Values in a bootstrapped MxModel</h2><span id='topic+mxBootstrapEval'></span><span id='topic+omxBootstrapEvalCov'></span><span id='topic+omxBootstrapEval'></span><span id='topic+omxBootstrapEvalByName'></span><span id='topic+mxBootstrapEvalByName'></span>

<h3>Description</h3>

<p>This function can be used to evaluate an arbitrary R expression that includes named entities from a <a href="#topic+MxModel">MxModel</a> object, or labels from a <a href="#topic+MxMatrix">MxMatrix</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxBootstrapEval(expression, model, defvar.row = 1, ...,
 bq=c(.25,.75), method=c('bcbci','quantile'))

mxBootstrapEvalByName(name, model, defvar.row = 1, ...,
 bq=c(.25,.75), method=c('bcbci','quantile'))

omxBootstrapEval(expression, model, defvar.row = 1L, ...)

omxBootstrapEvalCov(expression, model, defvar.row = 1L, ...)

omxBootstrapEvalByName(name, model, defvar.row=1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxBootstrapEval_+3A_expression">expression</code></td>
<td>
<p>An arbitrary R expression.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_name">name</code></td>
<td>
<p>The character name of an object to evaluate.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_model">model</code></td>
<td>
<p>The model in which to evaluate the expression.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_defvar.row">defvar.row</code></td>
<td>
<p>The row to use for definition variables when compute=TRUE (defaults to 1).  When compute=FALSE, values for definition variables are always taken from the first (i.e., first before any automated sorting is done) row of the raw data.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_bq">bq</code></td>
<td>
<p>numeric. A vector of bootstrap quantiles at which to summarize the bootstrap replication.</p>
</td></tr>
<tr><td><code id="mxBootstrapEval_+3A_method">method</code></td>
<td>
<p>character. One of &lsquo;quantile&rsquo; or &lsquo;bcbci&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument &lsquo;expression&rsquo; is an arbitrary R expression.  Any named entities that are used within the R expression are translated into their current value from the model. Any labels from the matrices within the model are translated into their current value from the model. Finally the expression is evaluated and the result is returned.  To enable debugging, the &lsquo;show&rsquo; argument has been provided.  The most common mistake when using this function is to include named entities in the model that are identical to R function names.  For example, if a model contains a named entity named &lsquo;c&rsquo;, then the following mxEval call will return an error: <code>mxEval(c(A, B, C), model)</code>.
</p>
<p>The <code>mxEvalByName</code> function is a wrapper around <code>mxEval</code> that takes a character instead of an R expression.
</p>
<p><em>nb</em>: &lsquo;bcbci&rsquo; stands for &lsquo;bias-corrected bootstrap confidence interval&rsquo;
</p>
<p>The default behavior is to use the &lsquo;bcbci&rsquo; <code>method</code>, due to its superior theoretical properties.
</p>


<h3>Value</h3>

<p><code>omxBootstrapEval</code> and <code>omxBootstrapEvalByName</code> return the raw matrix of
<code>cvectorize</code>'d results. <code>omxBootstrapEvalCov</code> returns the
covariance matrix of the <code>cvectorize</code>'d results.
<code>mxBootstrapEval</code> and <code>mxBootstrapEvalByName</code> return
the <code>cvectorize</code>'d results summarized by <code>method</code> at quantiles <code>bq</code>.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxAlgebra">mxAlgebra</a> to create algebraic expressions inside your model 
and <a href="#topic+mxModel">mxModel</a> for the model object mxEval looks inside when
evaluating. <a href="#topic+mxBootstrap">mxBootstrap</a> to create bootstrap data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)
# make a unit-weighted 10-row data set of values 1 thru 10
myData = mxData(data.frame(weight=1.0, value=1:10), "raw", weight = "weight")
sum(1:10)

# Model sums data$value (sum(1:10)= 55), subtracts "A", squares the result, 
# and tries to minimize this (achieved by setting A=55)
testModel = mxModel(model = "testModel1", myData,
	mxMatrix(name  = "A", "Full", nrow = 1, ncol = 1, values = 1, free=TRUE),
	# nb: filteredDataRow is an auto-generated matrix of
	# non-missing data from the present row.
	# This is placed into the "rowResults" matrix (also auto-generated)
	mxAlgebra(name = "rowAlg", data.weight * filteredDataRow),
	# Algebra to turn the rowResults into a single number
	mxAlgebra(name = "reduceAlg", (sum(rowResults) - A)^2),
	mxFitFunctionRow(
		rowAlgebra    = "rowAlg",
		reduceAlgebra = "reduceAlg",
		dimnames      = "value"
	)
	# no need for an MxExpectation object when using mxFitFunctionRow
)

testModel = mxRun(testModel) # A is estimated at 55, with SE= 1
testBoot = mxBootstrap(testModel)
summary(testBoot) # A is estimated at 55, with SE= 0

# Let's compute A^2 (55^2 = 3025)
mxBootstrapEval(A^2, testBoot)
#      SE 25.0% 75.0%
# [1,]  0  3025  3025

</code></pre>

<hr>
<h2 id='mxBootstrapStdizeRAMpaths'>Bootstrap distribution of standardized RAM path coefficients</h2><span id='topic+mxBootstrapStdizeRAMpaths'></span>

<h3>Description</h3>

<p>Uses the distribution of a bootstrapped RAM model's raw parameters to create a bootstrapped estimate of its standardized path coefficients.
</p>
<p><em>note</em>: Model must have already been run through <code><a href="#topic+mxBootstrap">mxBootstrap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxBootstrapStdizeRAMpaths(model, bq= c(.25, .75), 
	method= c('bcbci','quantile'), returnRaw= FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxBootstrapStdizeRAMpaths_+3A_model">model</code></td>
<td>
<p>An MxModel that uses <a href="#topic+mxExpectationRAM">RAM expectation</a> and has already been run through <code><a href="#topic+mxBootstrap">mxBootstrap</a></code>.</p>
</td></tr>
<tr><td><code id="mxBootstrapStdizeRAMpaths_+3A_bq">bq</code></td>
<td>
<p>vector of 2 bootstrap quantiles corresponding to the lower and upper limits of the desired confidence interval.</p>
</td></tr>
<tr><td><code id="mxBootstrapStdizeRAMpaths_+3A_method">method</code></td>
<td>
<p>One of 'bcbci' or 'quantile'.</p>
</td></tr>
<tr><td><code id="mxBootstrapStdizeRAMpaths_+3A_returnraw">returnRaw</code></td>
<td>
<p>Whether or not to return the raw bootstrapping results (Defaults to <code>FALSE</code>: returning a dataframe summarizing the results).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mxBootstrapStdizeRAMpaths</code> applies <code><a href="#topic+mxStandardizeRAMpaths">mxStandardizeRAMpaths</a></code> to each bootstrap replication, thus creating a distribution of standardized estimates for each nonzero path coefficient.
</p>
<p>The default <code>bq</code> (bootstrap quantiles) of c(.25, .75) correspond to a 50% CI. This default is chosen as many more
bootstraps are required to accurately estimate more extreme quantiles. For a 95% CI, use <code>bq=c(.025,.0975)</code>. 
</p>
<p><em>nb</em>: &lsquo;bcbci&rsquo; stands for &lsquo;bias-corrected bootstrap confidence interval&rsquo; To learn more about bcbci and quantile methods, see Efron (1982)
and Efron and Tibshirani (1994).
</p>
<p><em>note 1</em>: It is possible (though unlikely) that the number of nonzero paths (elements of the <code>A</code> and <code>S</code> RAM matrices) may vary among bootstrap replications.  This precludes a simple summary of the standardized paths' bootstrapping results. In this rare case, if <code>returnRaw=TRUE</code>, a raw list of bootstrapping results is returned, with a warning. Otherwise an error is thrown.
</p>
<p><em>note 2</em>: <code>mxBootstrapStdizeRAMpaths</code> ignores sub-models. To standardize bootstrapped sub-models, run it on the sub-models directly.
</p>


<h3>Value</h3>

<p>If <code>returnRaw=FALSE</code> (default), it returns a dataframe containing, among other things, the standardized path coefficients as estimated from the real data, their bootstrap SEs, and the lower and upper limits of a bootstrap confidence interval.  If <code>returnRaw=TRUE</code>, typically, a matrix containing the raw bootstrap results is returned; this matrix has one column per non-zero path coefficient, and one row for each successfully converged bootstrap replication or, if the number of paths varies between bootstraps, a raw list of results is returned.
</p>


<h3>References</h3>

<p>Efron B.  (1982).  <em>The Jackknife, the Bootstrap, and Other Resampling Plans</em>.  Philadelphia:  Society for Industrial and Applied Mathematics.
</p>
<p>Efron B, Tibshirani RJ.  (1994).  <em>An Introduction to the Bootstrap</em>.  Boca Raton: Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrap">mxBootstrap</a>()</code>, <code><a href="#topic+mxStandardizeRAMpaths">mxStandardizeRAMpaths</a>()</code>, <code><a href="#topic+mxBootstrapEval">mxBootstrapEval</a></code>, <code><a href="#topic+mxSummary">mxSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(OpenMx)
data(myFADataRaw)
manifests = c("x1","x2","x3","x4","x5","x6")

# Build and run 1-factor raw-data CFA
m1 = mxModel("CFA", type="RAM", manifestVars=manifests, latentVars="F1",
	# Factor loadings
	mxPath("F1", to = manifests, values=1),

	# Means and variances of F1 and manifests
	mxPath(from="F1", arrows=2, free=FALSE, values=1), # fix var  F1 @1
	mxPath("one", to= "F1", free= FALSE, values = 0),  # fix mean F1 @0

	# Freely-estimate means and residual variances of manifests
	mxPath(from = manifests, arrows=2, free=TRUE, values=1),
	mxPath("one", to= manifests, values = 1),

	mxData(myFADataRaw, type="raw")
)
m1 = mxRun(m1)
set.seed(170505) # Desirable for reproducibility

# ==========================
# = 1. Bootstrap the model =
# ==========================

m1_booted = mxBootstrap(m1)

# =================================================
# = 2. Estimate and accumulate a distribution of  =
# =    standardized values from each bootstrap.   =
# =================================================

tmp = mxBootstrapStdizeRAMpaths(m1_booted)
#          name label matrix row col Std.Value    Boot.SE     25.0%     75.0%
# 1  CFA.A[1,7]    NA      A  x1  F1 0.8049842 0.01583737 0.7899938 0.8124311
# 2  CFA.A[2,7]    NA      A  x2  F1 0.7935255 0.01373320 0.7865666 0.8045558
# 3  CFA.A[3,7]    NA      A  x3  F1 0.7772050 0.01629684 0.7698374 0.7907878
# 4  CFA.A[4,7]    NA      A  x4  F1 0.8248493 0.01315534 0.8150299 0.8351416
# 5  CFA.A[5,7]    NA      A  x5  F1 0.7995083 0.01479210 0.7869158 0.8057788
# 6  CFA.A[6,7]    NA      A  x6  F1 0.8126734 0.01527586 0.8012809 0.8218805
# 7  CFA.S[1,1]    NA      S  x1  x1 0.3520004 0.02546392 0.3399556 0.3759097
# 8  CFA.S[2,2]    NA      S  x2  x2 0.3703173 0.02171159 0.3526899 0.3813130
# 9  CFA.S[3,3]    NA      S  x3  x3 0.3959524 0.02529583 0.3746547 0.4073505
# 10 CFA.S[4,4]    NA      S  x4  x4 0.3196237 0.02163979 0.3025384 0.3357263
# 11 CFA.S[5,5]    NA      S  x5  x5 0.3607865 0.02364008 0.3507206 0.3807635
# 12 CFA.S[6,6]    NA      S  x6  x6 0.3395619 0.02476480 0.3245124 0.3579489
# 13 CFA.S[7,7]    NA      S  F1  F1 1.0000000 0.00000000 1.0000000 1.0000000
# 14 CFA.M[1,1]    NA      M   1  x1 2.9950397 0.08745209 2.9368758 3.0430917
# 15 CFA.M[1,2]    NA      M   1  x2 2.9775235 0.07719970 2.9109289 3.0197492
# 16 CFA.M[1,3]    NA      M   1  x3 3.0133665 0.08645522 2.9598062 3.0779683
# 17 CFA.M[1,4]    NA      M   1  x4 3.0505604 0.08210810 2.9952130 3.1103674
# 18 CFA.M[1,5]    NA      M   1  x5 2.9776983 0.07973619 2.9362410 3.0311999
# 19 CFA.M[1,6]    NA      M   1  x6 2.9830050 0.07632118 2.9360469 3.0416504


</code></pre>

<hr>
<h2 id='mxBounds'>Create MxBounds Object</h2><span id='topic+mxBounds'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxBounds">MxBounds</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxBounds(parameters, min = NA, max = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxBounds_+3A_parameters">parameters</code></td>
<td>
<p>A character vector indicating the names of the parameters on which to apply bounds.</p>
</td></tr>
<tr><td><code id="mxBounds_+3A_min">min</code></td>
<td>
<p>A numeric value for the lower bound. NA means use default value.</p>
</td></tr>
<tr><td><code id="mxBounds_+3A_max">max</code></td>
<td>
<p>A numeric value for the upper bound. NA means use default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a set of boundaries or limits for a parameter or set of parameters. Parameters may be any free parameter or parameters from an <a href="#topic+MxMatrix">MxMatrix</a> object. Parameters may be referenced either by name or by referring to their position in the 'spec' matrix of an <code>MxMatrix</code> object.
</p>
<p>Minima and maxima may be specified as scalar numeric values.
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxBounds">MxBounds</a> object. If used as an argument in an <a href="#topic+MxModel">MxModel</a> object, the parameters referenced in the 'parameters' argument must also be included prior to optimization.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+MxBounds">MxBounds</a> for the S4 class created by mxBounds. <a href="#topic+MxMatrix">MxMatrix</a> and <a href="#topic+mxMatrix">mxMatrix</a> for free parameter specification. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create lower and upper bounds for parameters 'A' and 'B'
bounds &lt;- mxBounds(c('A', 'B'), 3, 5)

#Create a lower bound of zero for a set of variance parameters
varianceBounds &lt;- mxBounds(c('Var1', 'Var2', 'Var3'), 0)
</code></pre>

<hr>
<h2 id='MxBounds-class'>MxBounds Class</h2><span id='topic+MxBounds-class'></span><span id='topic+MxBounds'></span>

<h3>Description</h3>

<p>MxBounds is an S4 class. New instances of this class can
be created using the function <a href="#topic+mxBounds">mxBounds</a>.
</p>


<h3>Details</h3>

<p>The MxBounds class has the following slots:
</p>

<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: center;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
    min </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The lower bound </td>
</tr>
<tr>
 <td style="text-align: right;"> 
    max </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The upper bound </td>
</tr>
<tr>
 <td style="text-align: right;">
    parameters </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The vector of parameter names </td>
</tr>
<tr>
 <td style="text-align: right;">     
  </td>
</tr>

</table>

<p>The 'min' and 'max' slots hold scalar numeric values for the lower and upper bounds on the list of parameters, respectively.
</p>
<p>Parameters may be any free parameter or parameters from an <a href="#topic+MxMatrix">MxMatrix</a> object. Parameters may be referenced either by name or by referring to their position in the 'spec' matrix of an <code>MxMatrix</code> object. To affect an estimation or optimization, an MxBounds object must be included in an <a href="#topic+MxModel">MxModel</a> object with all referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>
<p>Slots may be referenced with the $ symbol. See the documentation for <a href="methods.html#topic+Classes">Classes</a> and the examples in the <a href="#topic+mxBounds">mxBounds</a> document for more information.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxBounds">mxBounds</a> for the function that creates MxBounds objects. <a href="#topic+MxMatrix">MxMatrix</a> and <a href="#topic+mxMatrix">mxMatrix</a> for free parameter specification. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>

<hr>
<h2 id='MxCharOrList-class'>A character, list or NULL</h2><span id='topic+MxCharOrList-class'></span>

<h3>Description</h3>

<p>A character, list or NULL
</p>

<hr>
<h2 id='MxCharOrLogical-class'>A character or logical</h2><span id='topic+MxCharOrLogical-class'></span>

<h3>Description</h3>

<p>A character or logical
</p>

<hr>
<h2 id='MxCharOrNumber-class'>A character or integer</h2><span id='topic+MxCharOrNumber-class'></span>

<h3>Description</h3>

<p>A character or integer
</p>

<hr>
<h2 id='mxCheckIdentification'>Check that a model is locally identified</h2><span id='topic+mxCheckIdentification'></span>

<h3>Description</h3>

<p>Use the dimension of the null space of the Jacobian to determine whether or not a model is identified local to its current parameter values.
The output is a list of the the identification status, the Jacobian, and which parameters are not identified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxCheckIdentification(model, details=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxCheckIdentification_+3A_model">model</code></td>
<td>
<p>A MxModel object or list of MxModel objects.</p>
</td></tr>
<tr><td><code id="mxCheckIdentification_+3A_details">details</code></td>
<td>
<p>logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxCheckIdentification function is used to check that a model is identified.  That is, the function will tell you if the model has a unique solution in parameter space.  The function is most useful when applied to either (a) a model that has been run and had some NA standard errors, or (b) a model that has not been run but has reasonable starting values.  In the former situation, mxCheckIdentification is used as a diagnostic after a problem was indicated.  In the latter situation, mxCheckIdentification is used as a sanity check.
</p>
<p>The method uses the Jacobian of the model expected means and the unique elements of the expected covariance matrix with respect to the free parameters.  It is the first derivative of the mapping between the free parameters and the sufficient statistics for the Normal distribution.  The method does not depend on data, but does depend on the current values of the free parameters.  Thus, it only provides local identification, not global identification.  <em>You might get different answers about model identification depending on the free parameter values</em>.  Because the method does not depend on data, the model still could be empirically unidentified due to missing data.
</p>
<p>The Jacobian is evaluated numerically and generally takes a few seconds, but much less than a minute.
</p>
<p>The identification may not be accurate for models using definition variables.  Currently, only the first row of the definition variable is evaluated.
</p>
<p>Model identification should be accurate for models with linear or nonlinear equality and inequality constraints.  When there are constraints, mxCheckIdentification uses the Jacobian of the summary statistics with respect to the free parameters and the Jacobian of the summary statistics with respect to the constraints.  The combined extended Jacobian must have rank equal to the number of free parameters for the model to be identified.  So, a model can be identified with constraints that is not identified without constraints.
</p>
<p>When TRUE, the 'details' argument provides the names of the non-identified parameters.  Otherwise, only the status and Jacobian are returned.
</p>


<h3>Value</h3>

<p>A named list with components
</p>

<dl>
<dt>status</dt><dd><p>logical. TRUE if the model is locally identified; otherwise FALSE.</p>
</dd>
<dt>jacobian</dt><dd><p>matrix. The numerically evaluated Jacobian.</p>
</dd>
<dt>non_identified_parameters</dt><dd><p>vector. The free parameter names that are not identified</p>
</dd>
</dl>



<h3>References</h3>

<p>Bekker, P.A., Merckens, A., Wansbeek, T.J. (1994).  Identification, Equivalent Models and Computer Algebra.  Academic Press: Orlando, FL.
</p>
<p>Bollen, K. A. &amp; Bauldry, S. (2010).  Model Identification and Computer Algebra.  Sociological Methods &amp; Research, 39, p. 127-156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxModel">mxModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(OpenMx)

data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- "G1"
model2 &lt;- mxModel(model="One Factor", type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from = latents[1], to=manifests[1:5]),
      mxPath(from = manifests, arrows = 2, lbound=1e-6),
      mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
      mxData(cov(demoOneFactor), type = "cov", numObs=500)
)
fit2 &lt;- mxRun(model2)

id2 &lt;- mxCheckIdentification(fit2)
id2$status
# The model is locally identified

# Build a model from the solution of the previous one
#  but now the factor variance is also free
model2n &lt;- mxModel(fit2, name="Non Identified Two Factor",
      mxPath(from=latents[1], arrows=2, free=TRUE, values=1)
)

mid2 &lt;- mxCheckIdentification(model2n)
mid2$non_identified_parameters
# The factor loadings and factor variance
#  are not identified.

</code></pre>

<hr>
<h2 id='mxCI'>Create mxCI Object</h2><span id='topic+mxCI'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxCI">MxCI</a> object, which allows estimation of likelihood-based confidence intervals in a model
(note: to estimate SEs around arbitrary objects, see <code><a href="#topic+mxSE">mxSE</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxCI(reference, interval = 0.95, type=c("both", "lower", "upper"), ..., boundAdj=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxCI_+3A_reference">reference</code></td>
<td>
<p>A character vector of free parameters, mxMatrices, mxMatrix elements and mxAlgebras on which confidence intervals are to be estimated, listed by name.</p>
</td></tr>
<tr><td><code id="mxCI_+3A_interval">interval</code></td>
<td>
<p>A scalar numeric value indicating the confidence interval to be estimated. Must be between 0 and 1. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="mxCI_+3A_type">type</code></td>
<td>
<p>A character string indicating whether the upper, lower or both confidence limits are returned. Defaults to &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="mxCI_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by
name.</p>
</td></tr>
<tr><td><code id="mxCI_+3A_boundadj">boundAdj</code></td>
<td>
<p>Whether to correct the likelihood-based confidence
intervals for a lower or upper bound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxCI function creates <a href="#topic+MxCI">MxCI</a> objects, which can be used as arguments in <a href="#topic+MxModel">MxModel</a> objects. When models containing <a href="#topic+MxCI">MxCI</a> objects are optimized using <a href="#topic+mxRun">mxRun</a> with the &lsquo;intervals&rsquo; argument set to TRUE, likelihood-based confidence intervals are returned. The likelihood-based confidence intervals calculated by <a href="#topic+MxCI">MxCI</a> objects are symmetric with respect to the change in likelihood in either direction, and are not necessarily symmetric around the parameter estimate. Estimation of confidence intervals requires both that an <a href="#topic+MxCI">MxCI</a> object be included in the model and that the &lsquo;intervals&rsquo; argument of the <a href="#topic+mxRun">mxRun</a> function is set to TRUE. When estimated, confidence intervals can be accessed in the model output at <code>$output$confidenceIntervals</code> or by using <a href="base.html#topic+summary">summary</a> on a fitted <a href="#topic+MxModel">MxModel</a> object. 
</p>
<p>A typical use case is when a model includes non-linear constraints,
and hence, standard errors are not available.
In all cases, a two-sided hypothesis test is assumed.
Therefore, the upper bound will
exclude 2.5% (for interval=0.95) even though only one bound is
requested. To obtain a one-sided CI for a one-sided hypothesis test,
interval=0.90 will obtain a 95% confidence interval.
</p>
<p>When a confidence interval is requested for a free parameter (not an
algebra) constrained by a lower bound or an upper bound (but not both)
and <code>boundAdj=TRUE</code> then the Wu &amp; Neale (2012) correction is used.
This improves the accuracy of the confidence interval when the parameter
is estimated close to the bound. For example, this correction will be
activated when a variance with a lower bound of <code class="reqn">10^{-6}</code> and no
upper bound that is estimated close to the bound. The sample size, or
more precisely effective sample size for that particular parameter, will
determine how close the variance needs to be to the bound at
<code class="reqn">10^{-6}</code> to activate the correction.
</p>
<p>The likelihood-based confidence intervals returned using <a href="#topic+MxCI">MxCI</a> are obtained by increasing or decreasing the value of each parameter until the -2 log likelihood of the model increases by an amount corresponding to the requested interval. The confidence limit specified by the &lsquo;interval&rsquo; argument is transformed into a corresponding difference in the model -2 log likelihood based on the likelihood ratio test. Thus, a requested confidence interval for a parameter will first determine the corresponding quantile from the chi-squared distribution with one degree of freedom (a value of 3.841459 when a 95 percent confidence interval is requested). That quantile will be populated into either the &lsquo;lowerdelta&rsquo; slot, the &lsquo;upperdelta&rsquo; slot, or both in the output <a href="#topic+MxCI">MxCI</a> object. 
</p>
<p>Estimation of likelihood-based confidence intervals begins after optimization has been completed, with each parameter moved in the direction(s) specified in the &lsquo;type&rsquo; argument until the specified increase in -2 log likelihood is reached. All other free parameters are left free for this stage of optimization. This process repeats until all confidence intervals have been calculated. The calculation of likelihood-based confidence intervals can be computationally intensive, and may add a significant amount of time to model estimation when many confidence intervals are requested.
</p>
<p>Multiple parameters, <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> may be listed in the &lsquo;reference&rsquo; argument. Individual elements of <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> may be listed as well, using the syntax &ldquo;matrix[row,col]&rdquo; (see <a href="base.html#topic+Extract">Extract</a> for more information). Only scalar numeric values for the &lsquo;interval&rsquo; argument are supported. Users requesting different confidence ranges for different parameters must use separate <a href="#topic+mxCI">mxCI</a> statements. <a href="#topic+MxModel">MxModel</a> objects can hold multiple <a href="#topic+MxCI">MxCI</a> objects, but only one confidence interval may be requested per named-entity.
</p>
<p>Confidence interval estimation may result in model non-convergence at the confidence limit. Separate optimizer messages may be passed for each confidence limit. This has no impact on the parameter estimates themselves, but may indicate a problem with the referenced confidence limit. Model non-convergence for a particular confidence limit may indicate parameter interdependence or the influence of a parameter boundary. 
</p>
<p>These error messages and their meanings are listed in the help for <a href="#topic+mxSummary">mxSummary</a>
</p>
<p>The validity of a confidence limit can be checked by running a model with the appropriate parameter fixed at the confidence limit in question. If the confidence limit is valid, the -2 log likelihoods of these two models should differ by the specified chi-squared criterion (as set using the &lsquo;lowerdelta&rsquo; or &lsquo;upperdelta&rsquo; slots in the <a href="#topic+MxCI">MxCI</a> object (you can choose which of these to set via the type parameter of mxCI). 
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxCI">MxCI</a> object. If used as an argument in an <a href="#topic+MxModel">MxModel</a> object, the parameters, <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> listed in the 'reference' argument must also be included prior to optimization.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>. Additional support for mxCI() can be found on the OpenMx wiki at http://openmx.ssri.psu.edu/wiki.
</p>
<p>Neale, M. C. &amp; Miller M. B. (1997). The use of likelihood based
confidence intervals in genetic models.  <em>Behavior Genetics,
27</em>(2), 113-120.
</p>
<p>Pek, J. &amp; Wu, H. (2015). Profile likelihood-based confidence intervals
and regions for structural equation models.  <em>Psychometrika,
80</em>(4), 1123-1145.
</p>
<p>Wu, H. &amp; Neale, M. C. (2012). Adjusted confidence intervals for a
bounded parameter. <em>Behavior genetics, 42</em>(6), 886-898.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxSE">mxSE</a></code> for computing SEs around arbitrary objects.
<code><a href="#topic+mxComputeConfidenceInterval">mxComputeConfidenceInterval</a></code> is the internal compute plan that implements the algorithm.
<a href="#topic+MxMatrix">MxMatrix</a> and <a href="#topic+mxMatrix">mxMatrix</a> for free parameter specification.
<code><a href="#topic+MxCI">MxCI</a></code> for the S4 class created by mxCI.
More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

# generate data
covariance &lt;- matrix(c(1.0, 0.5, 0.5, 1.0), 
    nrow=2, 
    dimnames=list(c("a", "b"), c("a", "b")))
    
data &lt;- mxData(covariance, "cov", numObs=100)

# create an expected covariance matrix
expect &lt;- mxMatrix("Symm", 2, 2,
    free=TRUE,
    values=c(1, .5, 1),
    labels=c("var1", "cov12", "var2"),
    name="expectedCov")

# request 95 percent confidence intervals   
ci &lt;- mxCI(c("var1", "cov12", "var2"))

# specify the model
model &lt;- mxModel(model="Confidence Interval Example",
    data, expect, ci,
    mxExpectationNormal("expectedCov", dimnames=c("a", "b")),
    mxFitFunctionML())

# run the model 
results &lt;- mxRun(model, intervals=TRUE)

# view confidence intervals
print(summary(results)$CI)

# view all results
summary(results)

# remove a specific mxCI from a model
model &lt;- mxModel(model, remove=TRUE, model$intervals[['cov12']])
model$intervals

# remove all mxCI from a model
model &lt;- mxModel(model, remove=TRUE, model$intervals)
model$intervals

</code></pre>

<hr>
<h2 id='MxCI-class'>MxCI Class</h2><span id='topic+MxCI'></span><span id='topic+MxInterval'></span>

<h3>Description</h3>

<p>MxCI is an S4 class. An MxCI object is a <a href="#topic+Named-entity">named entity</a>.
New instances of this class can be created using the function <a href="#topic+mxCI">mxCI</a>.
MxCI objects may be used as arguments in the <a href="#topic+mxModel">mxModel</a> function.
</p>


<h3>Details</h3>

<p>The MxCI class has the following slots:
</p>

<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: center;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
    reference </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The name of the object </td>
</tr>
<tr>
 <td style="text-align: right;">
    lowerdelta </td><td style="text-align: center;"> - </td><td style="text-align: left;"> Either a matrix or a data frame </td>
</tr>
<tr>
 <td style="text-align: right;">
    upperdelta </td><td style="text-align: center;"> - </td><td style="text-align: left;"> A vector for means, or NA if missing </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>The reference slot contains a character vector of named free parameters, <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> on which confidence intervals are desired. Individual elements of <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> may be listed as well, using the syntax &ldquo;matrix[row,col]&rdquo; (see <a href="base.html#topic+Extract">Extract</a> for more information).
</p>
<p>The lowerdelta and upperdelta slots give the changes in likelihoods used to define the confidence interval. The upper bound of the likelihood-based confidence interval is estimated by increasing the parameter estimate, leaving all other parameters free, until the model -2 log likelihood increased by &lsquo;upperdelta&rsquo;. The lower bound of the confidence interval is estimated by decreasing the parameter estimate, leaving all other parameters free, until the model -2 log likelihood increased by &lsquo;lowerdata&rsquo;.
</p>
<p>Likelihood-based confidence intervals may be specified by including one or more MxCI objects in an <a href="#topic+MxModel">MxModel</a> object. Estimation of confidence intervals requires model optimization using the <a href="#topic+mxRun">mxRun</a> function with the &lsquo;intervals&rsquo; argument set to TRUE. The calculation of likelihood-based confidence intervals can be computationally intensive, and may add a significant amount of time to model estimation when many confidence intervals are requested.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxCI">mxCI</a> for creating MxCI objects. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>

<hr>
<h2 id='mxCompare'>Likelihood ratio test</h2><span id='topic+mxCompare'></span><span id='topic+mxCompareMatrix'></span>

<h3>Description</h3>

<p>Compare the fit of one or more models to that of a reference (base) model or set of reference models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxCompare(base, comparison, ..., all = FALSE,
  boot=FALSE, replications=400, previousRun=NULL, checkHess=FALSE)
mxCompareMatrix(models,
			    diag=c('minus2LL','ep','df','AIC'),
			    stat=c('p', 'diffLL','diffdf'), ...,
  boot=FALSE, replications=400, previousRun=NULL,
 checkHess=FALSE, wholeTable=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxCompare_+3A_base">base</code></td>
<td>
<p>A MxModel object or list of MxModel objects.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_comparison">comparison</code></td>
<td>
<p>A MxModel object or list of MxModel objects.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_models">models</code></td>
<td>
<p>A MxModel object or list of MxModel objects.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_diag">diag</code></td>
<td>
<p>statistic used for diagonal entries</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_stat">stat</code></td>
<td>
<p>statistic used for off-diagonal entries</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_all">all</code></td>
<td>
<p>Boolean. Whether to compare all base models with all comparison models. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_boot">boot</code></td>
<td>
<p>Whether to use the bootstrap distribution to compute the p-value.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_replications">replications</code></td>
<td>
<p>How many replications to use to approximate the bootstrap distribution.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_previousrun">previousRun</code></td>
<td>
<p>Results to re-use from a previous bootstrap.</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_checkhess">checkHess</code></td>
<td>
<p>Whether to approximate the Hessian in each replication</p>
</td></tr>
<tr><td><code id="mxCompare_+3A_wholetable">wholeTable</code></td>
<td>
<p>Return the whole table instead of a matrix shaped summary</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mxCompare</code> is used to compare the fit of one or more <a href="#topic+mxModel">mxModel</a>s to one or more comparison models. <code>mxCompareMatrix</code> compares all the models provided against each other.
</p>
<p>Model comparisons are made by subtracting the fit statistics for the comparison model from the fit statistics for the base model. Raw fit statistics of each &lsquo;base&rsquo; model are also listed in the output table.
</p>
<p>The fit statistics compared depend on the kinds of models compared.  Models fit with maximum likelihood are compared based on their minus two log likelihood values.  Under certain regularity conditions, the difference in minus two log likelihood values from nested models is chi-squared distributed and forms a likelihood ratio test statistic.  Models fit with weighted least squares are compared based on their Satorra-Bentler (2001) scaled difference chi-squared test statistics.  Under full weighted least squares, the Satorra-Bentler chi-squared value is equal to the difference in the model chi-squared values; however, for unweighted and diagonally weighted least squares, the two are no longer equal.  Satorra and Bentler (2001) showed that that their test statistic behaved well under a variety of conditions, including small sample sizes.  By contrast the much simpler difference in the chi-squared statistics only behaved well under large sample sizes (e.g., greater than or equal to 300 rows of data).
</p>
<p>Specific to weighted least squares, researchers sometimes use mean-adjusted chi-squared statistics and mean-and-variance scaled chi-squared statistics.  Some programs call these WLSM and WLSMV statistics.  In some cases, it is fine to evaluate the total fit of a model using adjusted and scaled chi-squared statistics.  However, never, ever, ever, ..., ever take differences in mean-adjusted chi-squared statistics, and use them for nested model comparisons.  Similarly, never, ever, ever, ..., ever, ever take differences in mean-and-variance scaled chi-squared statistics, and use them for nested model comparisons.  The differences in these adjusted and scaled chi-squared statistics are not chi-squared distributed and do not form a valid basis for model comparison.  So, just don't do it.
</p>
<p>Although not always checked by <code>mxCompare</code>, you should never compare models with different data sets or that use different variables from the same data set.  <code>mxCompare</code> might not stop you from doing this, so be thoughtful when comparing models.  Make sure your models are nested and use the same data.  Weighted least squares models are one case of comparing different data sets that requires particular care.  <em>When comparing WLS models, make sure you are using the same exogenous covariates for all compared models.</em>  Because WLS is a multi-stage estimation approach, exogenous covariates residualize and change the data fitted in WLS.  Consequently, WLS models with different exogenous covariates actually have different data.  By contrast, maximum likelihood models with different exogenous covariates still use the same data and are valid to compare.
</p>
<p>The <code>mxCompare</code> function makes an effort to only make valid comparisons.
If a comparison is made where the <code>comparison</code> model has a
higher minus 2 log likelihood (-2LL) than the <code>base</code> model, then the
difference in their -2LLs will be negative. P-values for likelihood
ratio tests will not be reported when either the -2LL or degrees of
freedom for the comparison are negative. 
To ensure that the differences between models are positive and yield p-values for likelihood ratio
tests, models listed in the &lsquo;base&rsquo; argument must
be more saturated (i.e., more estimated parameters and fewer degrees of
freedom) than models listed in the &lsquo;comparison&rsquo; argument. For
<code>mxCompareMatrix</code> only the comparisons that make sense will be included.
</p>
<p>When multiple models are included in both the &lsquo;base&rsquo; and &lsquo;comparison&rsquo; arguments, then comparisons are made between the two lists of models based on the value of the &lsquo;all&rsquo; argument. If &lsquo;all&rsquo; is set to FALSE (default), then the first model in the &lsquo;base&rsquo; list is compared to the first model in the &lsquo;comparison&rsquo; list, second with second, and so on. If there are an unequal number of &lsquo;base&rsquo; and &lsquo;comparison&rsquo; models, then the shorter list of models is repeated to match the length of the longer list. For example, comparing base models &lsquo;B1&rsquo; and &lsquo;B2&rsquo; with comparison models &lsquo;C1&rsquo;, &lsquo;C2&rsquo; and &lsquo;C3&rsquo; will yield three comparisons: &lsquo;B1&rsquo; with &lsquo;C1&rsquo;, &lsquo;B2&rsquo; with &lsquo;C2&rsquo;, and &lsquo;B1&rsquo; with &lsquo;C3&rsquo;. Each of those comparisons are prefaced by a comparison between the base model and a missing comparison model to present the fit of the base model.
</p>
<p>If &lsquo;all&rsquo; is set to TRUE, all possible comparisons between base and comparison models are made, and one entry is made for each base model. All comparisons involving the first model in &lsquo;base&rsquo; are made first, followed by all comparisons with the second &lsquo;base&rsquo; model, and so on. When there are multiple models in either the &lsquo;base&rsquo; or &lsquo;comparison&rsquo; arguments but not both, then the &lsquo;all&rsquo; argument does not affect the set of comparisons made.
</p>
<p>The following columns appear in the output for maximum likelihood comparisons:
</p>

<dl>
<dt>base</dt><dd><p>Name of the base model.</p>
</dd>
<dt>comparison</dt><dd><p>Name of the comparison model. Is &lt;NA&gt; for the first </p>
</dd>
<dt>ep</dt><dd><p>Estimated parameters of the comparison model.</p>
</dd>
<dt>minus2LL</dt><dd><p>Minus 2*log-likelihood of the comparison model. If the comparison model is &lt;NA&gt;, then the minus 2*log-likelihood of the base model is given.</p>
</dd>
<dt>df</dt><dd><p>Degrees in freedom of the comparison model. If the comparison model is &lt;NA&gt;, then the degrees of freedom of the base model is given.</p>
</dd>
<dt>AIC</dt><dd><p>Akaike's Information Criterion for the comparison model. If the comparison model is &lt;NA&gt;, then the AIC of the base model is given.</p>
</dd>
<dt>diffLL</dt><dd><p>Difference in minus 2*log-likelihoods of the base and comparison models. Will be positive when base model -2LL is higher than comparison model -2LL.</p>
</dd>
<dt>diffdf</dt><dd><p>Difference in degrees of freedoms of the base and comparison models. Will be positive when base model DF is lower than comparison model DF (base model estimated parameters is higher than comparison model estimated parameters)</p>
</dd>
<dt>p</dt><dd><p>P-value for likelihood ratio test based on diffLL and diffdf values.</p>
</dd></dl>

<p>Weighted least squares reports a similar set of columns with four substitutions:
</p>

<dl>
<dt>chisq</dt><dd><p>Replaces the <code>minus2LL</code> column.  This is the comparison model's chi-squared statistic from Browne (1984, Equation 2.20a), accounting for some misspecification of the weight matrix.</p>
</dd>
<dt>AIC</dt><dd><p>Although this has the same name as that in maximum likelihood, it is really a pseudo-AIC using the comparison model chi-squared and the number of estimated parameters.  It is the chi-squared value plus two times the number of free parameters.</p>
</dd>
<dt>SBchisq</dt><dd><p>Replaces the <code>diffLL</code> column.  This is the Satorra-Bentler (2001, p. 511) scaled difference chi-squared statisic between the base model and the comparison model.  If your models use full weighted least squares, then this will be the same as the difference between the individual model chi-squared statistics.  However, for unweighted and diagonally weighted least square, the <code>SB chisq</code> will not be equal to the difference between the component model chi-squared statistics.</p>
</dd>
<dt>p</dt><dd><p>p-value for the Satorra-Bentler chi-squared statistic.</p>
</dd></dl>

<p>In addition to the particular columns for maximum likelihood and weighted least squares, there are three general columns that are not printed but are accessible via the <code>$</code> and <code>[</code> extractors.
</p>

<dl>
<dt>fit</dt><dd><p>The individual model fit value: <code>m2ll</code> for maximum likelihood models, <code>chisq</code> for WLS models.</p>
</dd>
<dt>fitUnits</dt><dd><p>The units of the fit function: <code>"-2LL"</code> for ML models, <code>"r'Wr"</code> for WLS models.</p>
</dd>
<dt>diffFit</dt><dd><p>The difference in fit values between the base and comparison models: <code>diffLL</code> for ML models, <code>SBchisq</code> for WLS models.</p>
</dd></dl>

<p><code>mxCompare</code> will give a p-value for any comparison in which
both &lsquo;diffLL&rsquo; and &lsquo;diffdf&rsquo; are non-negative. However, this
p-value is based on the assumptions of the likelihood ratio test,
specifically that the two models being compared are nested. The
likelihood ratio test and associated p-values are not valid when the
comparison model is not nested in the referenced base model. For a more
accurate p-value, the empirical bootstrap distribution can be computed
(&lsquo;boot=TRUE&rsquo;). However, &lsquo;replications&rsquo; must be set high
enough for an accurate approximation. The Monte Carlo SE of a proportion
for B replications is <code class="reqn">\sqrt(p*(1-p)/B)</code>, but this will be zero if p
is zero, which is nonsense.  Note that a parametric-bootstrap p-value of
zero must be interpreted as <code class="reqn">p &lt; 1/B</code>, which, depending on <code class="reqn">B</code>
and the desired Type I error rate, may not be &quot;statistically significant.&quot;
</p>
<p>When &lsquo;boot=TRUE&rsquo;, the model has a default compute plan, and
&lsquo;checkHess&rsquo; is kept at FALSE then the Hessian will not be
approximated or checked.  On the other hand, &lsquo;checkHess&rsquo; is TRUE
then the Hessian will be approximated by finite differences. This
procedure is of some value because it can be informative to check
whether the Hessian is positive definite (see
<code><a href="#topic+mxComputeHessianQuality">mxComputeHessianQuality</a></code>).  However, approximating the
Hessian is often costly in terms of CPU time. For bootstrapping, the
parameter estimates derived from the resampled data are typically of
primary interest.
</p>
<p><em>note</em>: The mxCompare function does not directly accept a digits argument, and depends
on the value of the 'digits' option. To set the minimum number of significant digits
printed, use options('digits' = N) (see example).
</p>


<h3>Value</h3>

<p>Returns a new <code>MxCompare</code> object.  If you want something more like a table of results, use <code>as.data.frame()</code> on the returned <code>MxCompare</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxPowerSearch">mxPowerSearch</a></code>;
<code><a href="#topic+mxModel">mxModel</a></code>;  <code><a href="base.html#topic+options">options</a></code> (use options('mxOptions') to see all the OpenMx-specific options) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- "G1"
model1 &lt;- mxModel(model="One Factor", type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from = latents, to=manifests),
      mxPath(from = manifests, arrows = 2),
      mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
      mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)

fit1 &lt;- mxRun(model1)

latents &lt;- c("G1", "G2")
model2 &lt;- mxModel(model="One factor Rasch equated", type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from = latents[1], to=manifests[1:5], labels='raschEquated'),

      mxPath(from = manifests, arrows = 2),
      mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
      mxData(cov(demoOneFactor), type = "cov", numObs=500)
)
fit2 &lt;- mxRun(model2)

mxCompare(fit1, fit2) # Rasch equated is significantly worse

# Vary precision (rounding) of the table 
oldPrecision = as.numeric(options('digits')) 
options('digits' = 1)
mxCompare(fit1, fit2)
options('digits' = oldPrecision)
</code></pre>

<hr>
<h2 id='MxCompare-class'>The MxCompare Class</h2><span id='topic+MxCompare-class'></span><span id='topic++24+2CMxCompare-method'></span><span id='topic++5B+2CMxCompare+2CANY+2CANY+2CANY-method'></span><span id='topic+as.data.frame.MxCompare'></span><span id='topic+print+2CMxCompare-method'></span><span id='topic+show+2CMxCompare-method'></span>

<h3>Description</h3>

<p>The MxCompare Class
</p>


<h3>Details</h3>

<p>This is an internal class structure.  You should not use it directly.
Use <code><a href="#topic+mxCompare">mxCompare</a></code> instead.
</p>

<hr>
<h2 id='MxCompute-class'>MxCompute</h2><span id='topic+MxCompute-class'></span><span id='topic+MxCompute'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxComputeBootstrap'>Repeatedly estimate model using resampling with replacement</h2><span id='topic+mxComputeBootstrap'></span><span id='topic+MxComputeBootstrap-class'></span>

<h3>Description</h3>

<p>This is a low-level compute plan object to perform
resampling with replacement. </p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeBootstrap(data, plan, replications=200, ...,
                        verbose=0L, parallel=TRUE, freeSet=NA_character_,
			OK=c("OK", "OK/green"), only=NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeBootstrap_+3A_data">data</code></td>
<td>
<p>A vector of dataset or model names.</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_plan">plan</code></td>
<td>
<p>The compute plan used to optimize the model for each data
set.</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_replications">replications</code></td>
<td>
<p>The number of resampling replications. If
available, replications from prior mxBootstrap invocations will be reused.</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_verbose">verbose</code></td>
<td>
<p>For levels greater than 0, enables runtime diagnostics</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_parallel">parallel</code></td>
<td>
<p>Whether to process the replications in parallel</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_ok">OK</code></td>
<td>
<p>The set of status code that are considered successful</p>
</td></tr>
<tr><td><code id="mxComputeBootstrap_+3A_only">only</code></td>
<td>
<p>When provided, only the given replication from a prior
run of <code>mxBootstrap</code> will be performed. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;only&rsquo; option facilitates investigation of a single
replication attempt. 
</p>


<h3>Value</h3>

<p>Output is stored in the compute object's <code>output</code>
slot. Specifically, <code>model$compute$output$raw</code> contains a data
frame with parameters in columns and replications in rows. In addition
to parameters, the <code>seed</code>, <code>fit</code>, and <code>statusCode</code>
of the replication is also included.
</p>
<p>When &lsquo;only&rsquo; is set to a particular replications, the weight
vectors (one per dataset) are also returned in the compute object's
<code>output</code> slot. <code>model$compute$output$weight</code> is a character
vector (by dataset name) of numeric vectors (the weights). These
weights can be used to recreate a model identical to the model used
in the given replication.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrap">mxBootstrap</a></code>,
<code><a href="#topic+as.statusCode">as.statusCode</a></code>
</p>

<hr>
<h2 id='mxComputeCheckpoint'>Log parameters and state to disk or memory</h2><span id='topic+mxComputeCheckpoint'></span><span id='topic+MxComputeCheckpoint-class'></span>

<h3>Description</h3>

<p>Captures the current state of the backend. When <code>path</code> is set, the
state is written to disk in a single row. When <code>toReturn</code> is set,
the state is recorded in memory and returned after <code>mxRun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeCheckpoint(
  what = NULL,
  ...,
  path = NULL,
  append = FALSE,
  header = TRUE,
  toReturn = FALSE,
  parameters = TRUE,
  loopIndices = TRUE,
  fit = TRUE,
  counters = TRUE,
  status = TRUE,
  standardErrors = FALSE,
  gradient = FALSE,
  vcov = FALSE,
  vcovFilter = c(),
  sampleSize = FALSE,
  vcovWLS = FALSE,
  useVcovFilter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeCheckpoint_+3A_what">what</code></td>
<td>
<p>a character vector of algebra names to include in each checkpoint</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_path">path</code></td>
<td>
<p>a character vector of where to write the checkpoint file</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_append">append</code></td>
<td>
<p>if FALSE, truncates the checkpoint file upon open. If TRUE, existing data is preserved and checkpoints are appended.</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_header">header</code></td>
<td>
<p>whether to write the header that describes the content of each column</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_toreturn">toReturn</code></td>
<td>
<p>logical. Whether to store the checkpoint in memory and return it after the model is run</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_parameters">parameters</code></td>
<td>
<p>logical. Whether to include the parameter vector</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_loopindices">loopIndices</code></td>
<td>
<p>logical. Whether to include the loop indices</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_fit">fit</code></td>
<td>
<p>logical. Whether to include the fit value</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_counters">counters</code></td>
<td>
<p>logical. Whether to include counters (number of evaluations and iterations)</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_status">status</code></td>
<td>
<p>logical. Whether to include the status code</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_standarderrors">standardErrors</code></td>
<td>
<p>logical. Whether to include the standard errors</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_gradient">gradient</code></td>
<td>
<p>logical. Whether to include the gradients</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_vcov">vcov</code></td>
<td>
<p>logical. Whether to include the vcov in half-vectorized order</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_vcovfilter">vcovFilter</code></td>
<td>
<p>character vector. Vector of parameters indicating
which parameter covariances to include. Only the variance is
included for those parameters not mentioned.</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_samplesize">sampleSize</code></td>
<td>
<p>logical. Whether to include the sample size of the mxData. <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_vcovwls">vcovWLS</code></td>
<td>
<p>logical. Whether to include the vcov from WLS residualizing regressions in half-vectorized order</p>
</td></tr>
<tr><td><code id="mxComputeCheckpoint_+3A_usevcovfilter">useVcovFilter</code></td>
<td>
<p>logical. Whether to use the vcovFilter (TRUE) or include all entries (FALSE)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mxComputeLoadData">mxComputeLoadData</a></code>, <code><a href="#topic+mxComputeLoadMatrix">mxComputeLoadMatrix</a></code>,
<code><a href="#topic+mxComputeLoadContext">mxComputeLoadContext</a></code>, <code><a href="#topic+mxComputeLoop">mxComputeLoop</a></code>
</p>
<p>Other model state: 
<code><a href="#topic+mxRestore">mxRestore</a>()</code>,
<code><a href="#topic+mxSave">mxSave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

m1 &lt;- mxModel(
  "poly22", # Eqn 22 from Tsallis &amp; Stariolo (1996)
  mxMatrix(type='Full', values=runif(4, min=-1e6, max=1e6),
           ncol=1, nrow=4, free=TRUE, name='x'),
  mxAlgebra(sum((x*x-8)^2) + 5*sum(x) + 57.3276, name="fit"),
  mxFitFunctionAlgebra('fit'))

plan &lt;- mxComputeLoop(list(
  mxComputeSetOriginalStarts(),
    mxComputeSimAnnealing(method="tsallis1996",
                          control=list(tempEnd=1)),
    mxComputeCheckpoint(path = "result.log")),
  i=1:4)

m1 &lt;- mxRun(mxModel(m1, plan)) # see the file 'result.log'
</code></pre>

<hr>
<h2 id='mxComputeConfidenceInterval'>Find likelihood-based confidence intervals</h2><span id='topic+mxComputeConfidenceInterval'></span><span id='topic+MxComputeConfidenceInterval-class'></span>

<h3>Description</h3>

<p>There are various equivalent ways to pose the optimization
problems required to estimate confidence intervals. Most accurate
solutions are achieved when the problem is posed using non-linear
constraints. However, the available optimizers (CSOLNP, SLSQP, and NPSOL) often have difficulty with non-linear
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeConfidenceInterval(
  plan,
  ...,
  freeSet = NA_character_,
  verbose = 0L,
  engine = NULL,
  fitfunction = "fitfunction",
  tolerance = NA_real_,
  constraintType = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeConfidenceInterval_+3A_plan">plan</code></td>
<td>
<p>compute plan to optimize the model</p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_engine">engine</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_fitfunction">fitfunction</code></td>
<td>
<p>the name of the deviance function</p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_tolerance">tolerance</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeConfidenceInterval_+3A_constrainttype">constraintType</code></td>
<td>
<p>one of c('ineq', 'none')</p>
</td></tr>
</table>


<h3>References</h3>

<p>Neale, M. C. &amp; Miller M. B. (1997). The use of likelihood based
confidence intervals in genetic models.  <em>Behavior Genetics,
27</em>(2), 113-120.
</p>
<p>Pek, J. &amp; Wu, H. (2015). Profile likelihood-based confidence intervals and regions for structural equation models.
<em>Psychometrika, 80</em>(4), 1123-1145.
</p>
<p>Wu, H. &amp; Neale, M. C. (2012). Adjusted confidence intervals for a
bounded parameter. <em>Behavior genetics, 42</em>(6), 886-898.
</p>

<hr>
<h2 id='mxComputeDefault'>Default compute plan</h2><span id='topic+mxComputeDefault'></span><span id='topic+MxComputeDefault-class'></span>

<h3>Description</h3>

<p>This is an empty placeholder for the default compute plan.
To create an actual plan, use <a href="#topic+omxDefaultComputePlan">omxDefaultComputePlan</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeDefault(freeSet = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeDefault_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeEM'>Fit a model using DLR's (1977) Expectation-Maximization (EM) algorithm</h2><span id='topic+mxComputeEM'></span><span id='topic+MxComputeEM-class'></span>

<h3>Description</h3>

<p>The EM algorithm constitutes the following steps: Start with an
initial parameter vector. Predict the missing data to form a
completed data model. Optimize the completed data model to obtain
a new parameter vector. Repeat these steps until convergence
criteria are met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeEM(
  expectation = NULL,
  predict = NA_character_,
  mstep,
  observedFit = "fitfunction",
  ...,
  maxIter = 500L,
  tolerance = 1e-09,
  verbose = 0L,
  freeSet = NA_character_,
  accel = "varadhan2008",
  information = NA_character_,
  infoArgs = list(),
  estep = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeEM_+3A_expectation">expectation</code></td>
<td>
<p>a vector of expectation names <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_predict">predict</code></td>
<td>
<p>what to predict from the observed data <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_mstep">mstep</code></td>
<td>
<p>a compute plan to optimize the completed data model</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_observedfit">observedFit</code></td>
<td>
<p>the name of the observed data fit function (defaults to &quot;fitfunction&quot;)</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_tolerance">tolerance</code></td>
<td>
<p>optimization is considered converged when the maximum relative change in fit is less than tolerance</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_accel">accel</code></td>
<td>
<p>name of acceleration method (&quot;varadhan2008&quot; or &quot;ramsay1975&quot;)</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_information">information</code></td>
<td>
<p>name of information matrix approximation method</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_infoargs">infoArgs</code></td>
<td>
<p>arguments to control the information matrix method</p>
</td></tr>
<tr><td><code id="mxComputeEM_+3A_estep">estep</code></td>
<td>
<p>a compute plan to perform the expectation step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments to this function have evolved.  The old style
<code>mxComputeEM(e,p,mstep=m)</code> is equivalent to the new style
<code>mxComputeEM(estep=mxComputeOnce(e,p), mstep=m)</code>. This change
allows the API to more closely match the literature on the E-M
method.  You might use <code>mxAlgebra(..., recompute='onDemand')</code> to
contain the results of the E-step and then cause this algebra to
be recomputed using <code>mxComputeOnce</code>.
</p>
<p>This compute plan does not work with any and all expectations. It
requires a special kind of expectation that can predict its
missing data to create a completed data model.
</p>
<p>The EM algorithm does not produce a parameter covariance matrix
for standard errors. The Oakes (1999) direct method and S-EM, an
implementation of Meng &amp; Rubin (1991), are included.
</p>
<p>Ramsay (1975) was recommended in Bock, Gibbons, &amp; Muraki (1988).
</p>


<h3>References</h3>

<p>Bock, R. D., Gibbons, R., &amp; Muraki, E. (1988). Full-information
item factor analysis. <em>Applied Psychological Measurement,
6</em>(4), 431-444.
</p>
<p>Dempster, A. P., Laird, N. M., &amp; Rubin, D. B. (1977). Maximum likelihood from
incomplete data via the EM algorithm. <em>Journal of the Royal Statistical Society.
Series B (Methodological)</em>, 1-38.
</p>
<p>Meng, X.-L. &amp; Rubin, D. B. (1991). Using EM to obtain asymptotic variance-covariance
matrices: The SEM algorithm. <em>Journal of the American Statistical Association,
86</em> (416), 899-909.
</p>
<p>Oakes, D. (1999). Direct calculation of the information matrix via
the EM algorithm.  <em>Journal of the Royal Statistical Society:
Series B (Statistical Methodology), 61</em>(2), 479-482.
</p>
<p>Ramsay, J. O. (1975). Solving implicit equations in psychometric data analysis.
<em>Psychometrika, 40</em> (3), 337-360.
</p>
<p>Varadhan, R. &amp; Roland, C. (2008). Simple and globally convergent
methods for accelerating the convergence of any EM
algorithm. <em>Scandinavian Journal of Statistics, 35</em>, 335-353.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxAlgebra">MxAlgebra</a>, <a href="#topic+mxComputeOnce">mxComputeOnce</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
set.seed(190127)

N &lt;- 200
x &lt;- matrix(c(rnorm(N/2,0,1),
              rnorm(N/2,3,1)),ncol=1,dimnames=list(NULL,"x"))
data4mx &lt;- mxData(observed=x,type="raw")

class1 &lt;- mxModel("Class1",
	mxMatrix(type="Full",nrow=1,ncol=1,free=TRUE,values=0,name="Mu"),
	mxMatrix(type="Full",nrow=1,ncol=1,free=TRUE,values=4,name="Sigma"),
	mxExpectationNormal(covariance="Sigma",means="Mu",dimnames="x"),
	mxFitFunctionML(vector=TRUE))

class2 &lt;- mxRename(class1, "Class2")

mm &lt;- mxModel(
	"Mixture", data4mx, class1, class2,
	mxAlgebra((1-Posteriors) * Class1.fitfunction, name="PL1"),
	mxAlgebra(Posteriors * Class2.fitfunction, name="PL2"),
	mxAlgebra(PL1 + PL2, name="PL"),
	mxAlgebra(PL2 / PL,  recompute='onDemand',
	          initial=matrix(runif(N,.4,.6), nrow=N, ncol = 1), name="Posteriors"),
	mxAlgebra(-2*sum(log(PL)), name="FF"),
	mxFitFunctionAlgebra(algebra="FF"),
	mxComputeEM(
	  estep=mxComputeOnce("Mixture.Posteriors"),
	  mstep=mxComputeGradientDescent(fitfunction="Mixture.fitfunction")))

mm &lt;- mxOption(mm, "Max minutes", 1/20)  # remove this line to find optimum
mmfit &lt;- mxRun(mm)
summary(mmfit)
</code></pre>

<hr>
<h2 id='mxComputeGenerateData'>Generate data</h2><span id='topic+mxComputeGenerateData'></span><span id='topic+MxComputeGenerateData-class'></span>

<h3>Description</h3>

<p>Generate data specified by the model expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeGenerateData(expectation = "expectation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeGenerateData_+3A_expectation">expectation</code></td>
<td>
<p>a character vector of expectations to generate data for</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeGradientDescent'>Optimize parameters using a gradient descent optimizer</h2><span id='topic+mxComputeGradientDescent'></span><span id='topic+MxComputeGradientDescent-class'></span>

<h3>Description</h3>

<p>This optimizer does not require analytic derivatives of the fit
function. The fully open-source CRAN version of OpenMx offers 2 choices,
CSOLNP and SLSQP (from the NLOPT collection).  The OpenMx Team's version of
OpenMx offers the choice of three optimizers: CSOLNP, SLSQP, and NPSOL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeGradientDescent(
  freeSet = NA_character_,
  ...,
  engine = NULL,
  fitfunction = "fitfunction",
  verbose = 0L,
  tolerance = NA_real_,
  useGradient = deprecated(),
  warmStart = NULL,
  nudgeZeroStarts = mxOption(NULL, "Nudge zero starts"),
  maxMajorIter = NULL,
  gradientAlgo = deprecated(),
  gradientIterations = deprecated(),
  gradientStepSize = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeGradientDescent_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free parameters.</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_engine">engine</code></td>
<td>
<p>specific 'CSOLNP', 'SLSQP', or 'NPSOL'</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_fitfunction">fitfunction</code></td>
<td>
<p>name of the fitfunction (defaults to 'fitfunction')</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_tolerance">tolerance</code></td>
<td>
<p>how close to the optimum is close enough (also known as the optimality tolerance)</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_usegradient">useGradient</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_warmstart">warmStart</code></td>
<td>
<p>a Cholesky factored Hessian to use as the NPSOL Hessian starting value (preconditioner)</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_nudgezerostarts">nudgeZeroStarts</code></td>
<td>
<p>whether to nudge any zero starting values prior to optimization (default TRUE)</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_maxmajoriter">maxMajorIter</code></td>
<td>
<p>maximum number of major iterations</p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_gradientalgo">gradientAlgo</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_gradientiterations">gradientIterations</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxComputeGradientDescent_+3A_gradientstepsize">gradientStepSize</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#soft-deprecated"><img src="../help/figures/lifecycle-soft-deprecated.svg" alt='[Soft-deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three optimizers can use analytic gradients, and only NPSOL
uses <code>warmStart</code>. To customize more options, see
<a href="#topic+mxOption">mxOption</a>.
</p>


<h3>References</h3>

<p>Luenberger, D. G. &amp; Ye, Y. (2008). <em>Linear and nonlinear programming.</em> Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demoOneFactor)
factorModel &lt;- mxModel(name ="One Factor",
  mxMatrix(type="Full", nrow=5, ncol=1, free=FALSE, values=0.2, name="A"),
    mxMatrix(type="Symm", nrow=1, ncol=1, free=FALSE, values=1, name="L"),
    mxMatrix(type="Diag", nrow=5, ncol=5, free=TRUE, values=1, name="U"),
    mxAlgebra(expression=A %*% L %*% t(A) + U, name="R"),
  mxExpectationNormal(covariance="R", dimnames=names(demoOneFactor)),
  mxFitFunctionML(),
    mxData(observed=cov(demoOneFactor), type="cov", numObs=500),
     mxComputeSequence(steps=list(
     mxComputeGradientDescent(),
     mxComputeNumericDeriv(),
     mxComputeStandardError(),
     mxComputeHessianQuality()
    )))
factorModelFit &lt;- mxRun(factorModel)
factorModelFit$output$conditionNumber # 29.5
</code></pre>

<hr>
<h2 id='mxComputeHessianQuality'>Compute the quality of the Hessian</h2><span id='topic+mxComputeHessianQuality'></span><span id='topic+MxComputeHessianQuality-class'></span>

<h3>Description</h3>

<p>Tests whether the Hessian is positive definite
(model$output$infoDefinite) and, if so, computes the approximate condition
number (model$output$conditionNumber). See Luenberger &amp; Ye (2008)
Second Order Test (p. 190) and Condition Number (p. 239).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeHessianQuality(freeSet = NA_character_, ..., verbose = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeHessianQuality_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeHessianQuality_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeHessianQuality_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The condition number is approximated by <code class="reqn">\mathrm{norm}(H) *
\mathrm{norm}(H^{-1})</code> where H is the
Hessian. The norm is either the 1- or infinity-norm (both obtain
the same result due to symmetry).
</p>


<h3>References</h3>

<p>Luenberger, D. G. &amp; Ye, Y. (2008). Linear and nonlinear programming. Springer.
</p>

<hr>
<h2 id='mxComputeIterate'>Repeatedly invoke a series of compute objects until change is less than tolerance</h2><span id='topic+mxComputeIterate'></span><span id='topic+MxComputeIterate-class'></span>

<h3>Description</h3>

<p>One step (typically the last) must compute the fit or maxAbsChange.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeIterate(
  steps,
  ...,
  maxIter = 500L,
  tolerance = 1e-09,
  verbose = 0L,
  freeSet = NA_character_,
  maxDuration = as.numeric(NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeIterate_+3A_steps">steps</code></td>
<td>
<p>a list of compute objects</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_maxiter">maxIter</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_tolerance">tolerance</code></td>
<td>
<p>iterates until maximum relative change is less than tolerance</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_freeset">freeSet</code></td>
<td>
<p>Names of matrices containing free variables.</p>
</td></tr>
<tr><td><code id="mxComputeIterate_+3A_maxduration">maxDuration</code></td>
<td>
<p>the maximum amount of time (in seconds) to iterate</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeJacobian'>Numerically estimate the Jacobian with respect to free parameters</h2><span id='topic+mxComputeJacobian'></span><span id='topic+MxComputeJacobian-class'></span>

<h3>Description</h3>

<p>When algebra names are given, all algebras must belong to the same
model.
</p>
<p>When expectations are given, the Jacobian is taken with respect
to the manifest model.
The manifest model excludes any latent variables or processes. For
RAM and LISREL models, the manifest model contains only the
manifest variables with free means, covariance, and thresholds.
Ordinal manifest variables are standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeJacobian(freeSet=NA_character_, ..., of = "expectation",
 defvar.row=as.integer(NA), data='data')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeJacobian_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeJacobian_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeJacobian_+3A_of">of</code></td>
<td>
<p>a character vector of expectations or algebra names</p>
</td></tr>
<tr><td><code id="mxComputeJacobian_+3A_defvar.row">defvar.row</code></td>
<td>
<p>A row index. Which row to load for definition variables.</p>
</td></tr>
<tr><td><code id="mxComputeJacobian_+3A_data">data</code></td>
<td>
<p>From which data to load definition variables.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+omxManifestModelByParameterJacobian">omxManifestModelByParameterJacobian</a>, <a href="#topic+mxGetExpected">mxGetExpected</a>
</p>

<hr>
<h2 id='mxComputeLoadContext'>Load contextual data to supplement checkpoint</h2><span id='topic+mxComputeLoadContext'></span><span id='topic+MxComputeLoadContext-class'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeLoadContext(
  method = c("csv"),
  path = c(),
  column,
  ...,
  sep = " ",
  verbose = 0L,
  header = TRUE,
  col.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeLoadContext_+3A_method">method</code></td>
<td>
<p>name of the conduit used to load the columns.</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_path">path</code></td>
<td>
<p>the path to the file containing the data</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_column">column</code></td>
<td>
<p>a character vector. The column names to log.</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Values on each line of the file are separated by this character.</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_header">header</code></td>
<td>
<p>logical. Whether the first row contains column headers.</p>
</td></tr>
<tr><td><code id="mxComputeLoadContext_+3A_col.names">col.names</code></td>
<td>
<p>character vector. Column names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, this only supports comma separated value format and no
row names. If <code>header=TRUE</code> and <code>col.names</code> are
provided, the <code>col.names</code> take precedence. If
<code>header=FALSE</code> and no <code>col.names</code> are provided then
the column names consist of the file name and column offset.
</p>
<p>An <code>originalDataIsIndexOne</code> option is not offered. You'll need to
add an extra line at the start on your file if you wish to make
use of <code>originalDataIsIndexOne</code> in <code>mxComputeLoad*</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>, <a href="#topic+mxComputeLoadData">mxComputeLoadData</a>, <a href="#topic+mxComputeLoadMatrix">mxComputeLoadMatrix</a>
</p>

<hr>
<h2 id='mxComputeLoadData'>Load columns into an MxData object</h2><span id='topic+mxComputeLoadData'></span><span id='topic+MxComputeLoadData-class'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeLoadData(
  dest,
  column,
  method = c("csv", "data.frame"),
  ...,
  path = c(),
  originalDataIsIndexOne = FALSE,
  byrow = TRUE,
  row.names = c(),
  col.names = c(),
  skip.rows = 0,
  skip.cols = 0,
  verbose = 0L,
  cacheSize = 100L,
  checkpointMetadata = TRUE,
  na.strings = c("NA"),
  observed = NULL,
  rowFilter = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeLoadData_+3A_dest">dest</code></td>
<td>
<p>the name of the model where the columns will be loaded</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_column">column</code></td>
<td>
<p>a character vector. The column names to replace.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_method">method</code></td>
<td>
<p>name of the conduit used to load the columns.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_path">path</code></td>
<td>
<p>the path to the file containing the data</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_originaldataisindexone">originalDataIsIndexOne</code></td>
<td>
<p>logical. Whether to use the initial data for index 1</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_byrow">byrow</code></td>
<td>
<p>logical. Whether the data columns are stored in rows.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_row.names">row.names</code></td>
<td>
<p>optional integer. Column containing the row names.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_col.names">col.names</code></td>
<td>
<p>optional integer. Row containing the column names.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_skip.rows">skip.rows</code></td>
<td>
<p>integer. Number of rows to skip before reading data.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_skip.cols">skip.cols</code></td>
<td>
<p>integer. Number of columns to skip before reading data.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_cachesize">cacheSize</code></td>
<td>
<p>integer. How many columns to cache per
scan through the data. Only used when byrow=FALSE.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_checkpointmetadata">checkpointMetadata</code></td>
<td>
<p>logical. Whether to add per record metadata to the checkpoint</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_na.strings">na.strings</code></td>
<td>
<p>character vector. A vector of strings that denote a missing value.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_observed">observed</code></td>
<td>
<p>data frame. The reservoir of data for <code>method='data.frame'</code>.</p>
</td></tr>
<tr><td><code id="mxComputeLoadData_+3A_rowfilter">rowFilter</code></td>
<td>
<p>logical vector. Whether to skip the source row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this compute step is to help quickly perform many
similar analyses. For example, if we are given a sample of people
with a few million SNPs (single-nucleotide polymorphism) per
person then we could fit a separate model for each SNP by iterating
over the SNP data.
</p>
<p>The column names given in the <code>column</code> parameter must already
exist in the model's MxData object. Pre-existing data is assumed to be
a placeholder and is not used unless
<code>originalDataIsIndexOne</code> is set to TRUE.
</p>
<p>For <code>method='csv'</code>, the highest performance arrangement is
<code>byrow=TRUE</code> because entire columns are stored in single
chunks (rows) on the disk and can be easily loaded. For
<code>byrow=FALSE</code>, the data requires transposition. To load a
single column of observed data, it is necessary to read through
the whole file. This can be slow for large files. To amortize the
cost of transposition, <code>cacheSize</code> columns are loaded on
every pass through the file.
</p>
<p>After <code>mxRun</code> returns, the <code>dest</code> mxData object will
contain the most recently loaded data. Hence, any single analysis
of a series can be reproduced by issuing <code>mxComputeLoadData</code>
with the single index associated with a particular dataset,
replacing the compute plan with something like
<code>omxDefaultComputePlan</code>, and then passing the model back
through <code>mxRun</code>. This can be a helpful approach when
investigating unexpected results.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxComputeLoadMatrix">mxComputeLoadMatrix</a>, <a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>, <a href="#topic+mxRun">mxRun</a>, <a href="#topic+omxDefaultComputePlan">omxDefaultComputePlan</a>
</p>

<hr>
<h2 id='mxComputeLoadMatrix'>Load data from CSV files directly into the backend</h2><span id='topic+mxComputeLoadMatrix'></span><span id='topic+MxComputeLoadMatrix-class'></span>

<h3>Description</h3>

<p>THIS INTERFACE IS EXPERIMENTAL AND SUBJECT TO CHANGE.
</p>
<p>For method='csv', the file must be formatted in a specific way.
The number of columns must match the number of entries available
in the mxMatrix. Matrix types (e.g., symmetric or diagonal) are
respected (see <a href="#topic+mxMatrix">mxMatrix</a>). For example, a <em>Full</em> 2x2
matrix will require 4 entries, but a diagonal matrix of the same size
will only require 2 entries.
CSV data must be stored space separated and without row or column
names.
The destination <code>mxMatrix</code> can have free parameters, but cannot
have square bracket populated entries.
</p>
<p>If <code>originalDataIsIndexOne</code> is TRUE then this
compute step does nothing when the loop index is 1.
The purpose of <code>originalDataIsIndexOne</code> is to
permit usage of the dataset that was initially
included with the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeLoadMatrix(dest, method=c('csv','data.frame'), ...,
 path=NULL, originalDataIsIndexOne=FALSE,
 row.names=FALSE, col.names=FALSE, observed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeLoadMatrix_+3A_dest">dest</code></td>
<td>
<p>a character vector of matrix names</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_method">method</code></td>
<td>
<p>name of the conduit used to load the data.</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_path">path</code></td>
<td>
<p>a character vector of paths</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_originaldataisindexone">originalDataIsIndexOne</code></td>
<td>
<p>logical. Whether to use the initial data
for index 1</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_row.names">row.names</code></td>
<td>
<p>logical. Whether row names are present</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_col.names">col.names</code></td>
<td>
<p>logical. Whether column names are present</p>
</td></tr>
<tr><td><code id="mxComputeLoadMatrix_+3A_observed">observed</code></td>
<td>
<p>data frame. The reservoir of data for <code>method='data.frame'</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mxComputeLoadData">mxComputeLoadData</a>, <a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

dir &lt;-tempdir()  # safe place to create files

Cov &lt;- rWishart(4, 20, toeplitz(c(2,1)/20))
write.table(t(apply(Cov, 3, vech)),
            file=file.path(dir, "cov.csv"),
            col.names=FALSE, row.names=FALSE)
Mean &lt;- matrix(rnorm(8),4,2)
write.table(Mean, file=file.path(dir, "mean.csv"),
            col.names=FALSE, row.names=FALSE)

m1 &lt;- mxModel(
  "test1",
  mxMatrix("Full", 1,2, values=0,       name="mean"),
  mxMatrix("Symm", 2,2, values=diag(2), name="cov"),
  mxMatrix("Full", 1,2, values=-1,      name="lbound"),
  mxMatrix("Full", 1,2, values=1,       name="ubound"),
  mxAlgebra(omxMnor(cov,mean,lbound,ubound), name="area"),
  mxFitFunctionAlgebra("area"),
  mxComputeLoop(list(
    mxComputeLoadMatrix(c('mean', 'cov'),
                        path=file.path(dir, c('mean.csv', 'cov.csv'))),
    mxComputeOnce('fitfunction', 'fit'),
    mxComputeCheckpoint(path=file.path(dir, "loadMatrix.csv"))
  ), i=1:4))

m1 &lt;- mxRun(m1)
</code></pre>

<hr>
<h2 id='mxComputeLoop'>Repeatedly invoke a series of compute objects</h2><span id='topic+mxComputeLoop'></span><span id='topic+MxComputeLoop-class'></span><span id='topic+mxComputeBenchmark'></span>

<h3>Description</h3>

<p>When <code>i</code> is given then these values are iterated
over instead of the sequence 1 to the number of
iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeLoop(
  steps,
  ...,
  i = NULL,
  maxIter = as.integer(NA),
  freeSet = NA_character_,
  maxDuration = as.numeric(NA),
  verbose = 0L,
  startFrom = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeLoop_+3A_steps">steps</code></td>
<td>
<p>a list of compute objects</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified
by name.</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_i">i</code></td>
<td>
<p>the values to iterate over</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_maxiter">maxIter</code></td>
<td>
<p>the maximum number of iterations</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_freeset">freeSet</code></td>
<td>
<p>Names of matrices containing free variables.</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_maxduration">maxDuration</code></td>
<td>
<p>the maximum amount of time (in seconds) to
iterate</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeLoop_+3A_startfrom">startFrom</code></td>
<td>
<p>When <code>i=NULL</code>, permits starting from an index greater than 1.</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeNelderMead'>
Optimize parameters using a variation of the Nelder-Mead algorithm.
</h2><span id='topic+mxComputeNelderMead'></span><span id='topic+MxComputeNelderMead'></span><span id='topic+MxComputeNelderMead-class'></span>

<h3>Description</h3>

<p>OpenMx includes a flexible, options-rich implementation of the Nelder-Mead algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeNelderMead(
	freeSet=NA_character_, fitfunction="fitfunction", verbose=0L, 
	nudgeZeroStarts=mxOption(NULL,"Nudge zero starts"), 
	maxIter=NULL,	...,
	alpha=1, betao=0.5, betai=0.5, gamma=2, sigma=0.5, bignum=1e35, 
	iniSimplexType=c("regular","right","smartRight","random"),
	iniSimplexEdge=1, iniSimplexMat=NULL, greedyMinimize=FALSE, 
	altContraction=FALSE, degenLimit=0, stagnCtrl=c(-1L,-1L),
	validationRestart=TRUE,
	xTolProx=1e-8, fTolProx=1e-8,
	doPseudoHessian=TRUE,
	ineqConstraintMthd=c("soft","eqMthd"), 
	eqConstraintMthd=c("GDsearch","soft","backtrack","l1p"),
	backtrackCtrl=c(0.5,5),
	centerIniSimplex=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeNelderMead_+3A_freeset">freeSet</code></td>
<td>
<p>Character-string names of <a href="#topic+MxMatrix">MxMatrices</a> containing free parameters.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_fitfunction">fitfunction</code></td>
<td>
<p>Character-string name of the fitfunction; defaults to 'fitfunction'.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_verbose">verbose</code></td>
<td>
<p>Integer level of reporting printed to terminal at <a href="#topic+mxRun">runtime</a>; defaults to 0.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_nudgezerostarts">nudgeZeroStarts</code></td>
<td>
<p>Should free parameters with start values of zero be &quot;nudged&quot; to 0.1 at <a href="#topic+mxRun">runtime</a>?  Defaults to the current global value of <a href="#topic+mxOption">mxOption</a> &quot;Nudge zero starts&quot;.  May be a logical value, or one of character strings &quot;Yes&quot; or &quot;No&quot;.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_maxiter">maxIter</code></td>
<td>
<p>Integer maximum number of iterations.  Value of <code>NULL</code> is accepted, in which case the value used at <a href="#topic+mxRun">runtime</a> will be 10 times the number of iterations specified by the effective value of <a href="#topic+mxOption">mxOption</a> &quot;Major iterations&quot;.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_alpha">alpha</code></td>
<td>
<p>Numeric reflection coefficient.  Must be positive.  Defaults to 1.0.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_betao">betao</code>, <code id="mxComputeNelderMead_+3A_betai">betai</code></td>
<td>
<p>Numeric outside- and inside-contraction coefficients, respectively.  Both must be within unit interval (0,1).  Both default to 0.5.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_gamma">gamma</code></td>
<td>
<p>Numeric expansion coefficient.  If positive, must be greater than <code>alpha</code>.  If non-positive, expansion transformations will not be carried out.  Defaults to 2.0.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_sigma">sigma</code></td>
<td>
<p>Numeric shrink coefficient.  Cannot exceed 1.0.  If non-positive, shrink transformations will not be carried out, and failed contractions will instead be followed by a simplex restart.  Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_bignum">bignum</code></td>
<td>
<p>Numeric value with which the fitfunction value is to be replaced if the fit is non-finite or is evaluated at infeasible parameter values.  Defaults to 1e35.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_inisimplextype">iniSimplexType</code></td>
<td>
<p>Character string naming the method by which to construct the initial simplex from the free-parameter start values.  Defaults to &quot;regular&quot;.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_inisimplexedge">iniSimplexEdge</code></td>
<td>
<p>Numeric edge-length of the initial simplex.  Defaults to 1.0.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_inisimplexmat">iniSimplexMat</code></td>
<td>
<p>Optional numeric matrix providing the vertices of the initial simplex.  The matrix must have as many columns as there are free parameters in the <a href="#topic+MxModel">MxModel</a>.  The matrix's number of rows must be no less than the number of free parameters minus the number of degrees-of-freedom gained from equality <a href="#topic+mxConstraint">MxConstraints</a>, if any.  If a non-<code>NULL</code> value is provided, argument <code>iniSimplexEdge</code> is ignored, and argument <code>iniSimplexType</code> is only used in the case of a restart.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_greedyminimize">greedyMinimize</code></td>
<td>
<p>Logical; should the optimizer use &quot;greedy minimization?&quot;  Defaults to <code>FALSE</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_altcontraction">altContraction</code></td>
<td>
<p>Logical; should the optimizer use an &quot;alternate contraction&quot; transformation?  Defaults to <code>FALSE</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_degenlimit">degenLimit</code></td>
<td>
<p>Numeric &quot;degeneracy limit;&quot; defaults to 0.  If positive, the simplex will be restarted if the measure of the angle between any two of its edges is within 0 or pi by less than <code>degenLimit</code>.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_stagnctrl">stagnCtrl</code></td>
<td>
<p>&quot;Stagnation control;&quot; integer vector of length 2; defaults to <code>c(-1L,-1L)</code>.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_validationrestart">validationRestart</code></td>
<td>
<p>Logical; defaults to TRUE.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_xtolprox">xTolProx</code></td>
<td>
<p>Numeric &quot;domain-convergence&quot; criterion; defaults to 1e-8.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_ftolprox">fTolProx</code></td>
<td>
<p>Numeric &quot;range-convergence&quot; criterion; defaults to 1e-8.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_dopseudohessian">doPseudoHessian</code></td>
<td>
<p>Logical; defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_ineqconstraintmthd">ineqConstraintMthd</code></td>
<td>
<p>&quot;Inequality constraint method;&quot; character string. Defaults to &quot;soft&quot;.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_eqconstraintmthd">eqConstraintMthd</code></td>
<td>
<p>&quot;Equality constraint method;&quot; character string. Defaults to &quot;GDsearch&quot;.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_backtrackctrl">backtrackCtrl</code></td>
<td>
<p>Numeric vector of length two.  See below for details.</p>
</td></tr>
<tr><td><code id="mxComputeNelderMead_+3A_centerinisimplex">centerIniSimplex</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the MxModel's start values are used as the &quot;first&quot; vertex of the initial simplex.  If <code>TRUE</code>, the initial simplex is re-centered so that the MxModel's start values are its eucentroid.  However, if <code>iniSimplexMat</code> is non-<code>NULL</code> or if <code>iniSimplexType="smartRight"</code>, a value of <code>TRUE</code> is treated as <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The state of a Nelder-Mead optimization problem is represented by a simplex (polytope) of <code class="reqn">n+1</code> vertices in the space of the free parameters, where <code class="reqn">n</code> is the number of free parameters minus the number of degrees-of-freedom gained from equality <a href="#topic+mxConstraint">MxConstraints</a>.  An iteration of the algorithm first sorts the <code class="reqn">n+1</code> vertices by their corresponding fitfunction values (i.e., the values of the fitfunction when evaluated at each vertex), in ascending order (i.e., from &quot;best&quot; fit to &quot;worst&quot; fit).  Then, the &quot;subcentroid,&quot; which is the centroid of the &quot;best&quot; <code class="reqn">n</code> vertices, is calculated.  Then, the algorithm attempts to improve upon the worst fit by transforming the simplex; see <a href="http://www.scholarpedia.org/article/Nelder-Mead_algorithm">Singer &amp; Nelder (2009)</a> for details.
</p>
<p>Argument <code>iniSimplexType</code> dictates how the initial simplex will be constructed from the start values if argument <code>iniSimplexMat</code> is <code>NULL</code>, and how the simplex will be re-initialized in the case of a restart.  In all four cases, the vector of start values constitutes the &quot;starting vertex&quot; of the initial simplex.  If <code>iniSimplexType="regular"</code>, the initial simplex is merely a regular simplex with edge length equal to <code>iniSimplexEdge</code>.  A <code>"right"</code> simplex is constructed by incrementing each free parameter by <code>iniSimplexEdge</code> from its starting value; thus, all the edges that intersect at the starting vertex do so at right angles.  A <code>"smartRight"</code> simplex is constructed similarly, except that each free parameter is both incremented <em>and</em> decremented by <code>iniSimplexEdge</code>, and of those two points the one with the smaller fitfunction value is retained as a vertex.  A <code>"random"</code> simplex is constructed by randomly perturbing the start values, in a manner similar to the default for <code><a href="#topic+mxTryHard">mxTryHard</a>()</code>, to generate the coordinates of the other vertices.  The user is advised that bounds on the free parameters may keep the initial simplex from having the requested regularity or edge-length, and that <code>iniSimplexType</code> is at best a <em>suggestion</em> in the presence of equality <a href="#topic+mxConstraint">MxConstraints</a>.
</p>
<p>Note that if argument <code>iniSimplexMat</code> has nonzero length, the actual start values of the MxModel's free parameters are not used as a vertex of the initial simplex (unless one of the rows of <code>iniSimplexMat</code> happens to contain those start values).
</p>
<p>If the simplex is restarted, a new simplex is constructed per argument <code>iniSimplexType</code>, with edge length equal to the distance between the current best and second-best vertices, and with the current best vertex used as the &quot;first&quot; vertex.
</p>
<p>If <code>greedyMinimize=FALSE</code>, &quot;greedy expansion&quot; (Singer &amp; Singer, 2004) is used: if the expansion point and reflection point both have smaller fitfunction values than the best vertex, the expansion point is accepted.  If <code>greedyMinimize=TRUE</code>, &quot;greedy minimization&quot; (Singer &amp; Singer, 2004) is used: if the expansion point and the reflection point both have smaller fitfunction values than the best vertex, the better of the two new points is accepted.
</p>
<p>If argument <code>altContraction=TRUE</code>, the &quot;modified contraction step&quot; of Gill et al. (1982, Chapter 4) is used, and the candidate point is contracted toward the best vertex instead of toward the subcentroid.
</p>
<p>If positive, the first element of argument <code>stagnCtrl</code> sets a threshold for the number of successive iterations in which the best vertex of the simplex does not change, after which the algorithm is said to be &quot;stagnant&quot; (in a sense similar to that of Kelley, 1999).  To attempt to remedy the stagnation, the simplex is restarted.  If positive, the second element of argument <code>stagnCtrl</code> sets threshold for the number of restarts conducted, beyond which stagnation no longer triggers a restart.  The rationale for the second element is that the best vertex may not change for many iterations when the optimizer is close to convergence, under which circumstances restarting would be counterproductive, and in any event would require additional fitfunction evaluations.
</p>
<p>If argument <code>validationRestart=TRUE</code>, then when the optimizer has successfully converged, it will restart the simplex and attempt to improve upon the tentative solution it already found.  This validation restart (Gill et al., 1982, Chapter 4) always re-initializes the simplex as a regular simplex, centered on the best vertex of the tentative solution, with edge-length equal to the distance between the best and worst vertices of the tentative solution.  Optimization proceeds until convergence to a solution with a better fit value, or <code class="reqn">2n</code> iterations have elapsed.
</p>
<p>The Nelder-Mead optimizer is considered to have successfully converged if (1) the largest <em>l</em>-infinity norm of the vector-differences between the best vertex and the other vertices is less than argument <code>xTolProx</code>, or (2) if the largest absolute difference in fit value between the best vertex and the other vertices is less than <code>fTolProx</code>.
</p>
<p>If argument <code>doPseudoHessian=TRUE</code>, there are no equality <a href="#topic+mxConstraint">MxConstraints</a>, and the &quot;l1p&quot; method (see below) is not in use for inequality <a href="#topic+mxConstraint">MxConstraints</a>, then OpenMx will attempt to calculate the &quot;pseudo-Hessian&quot; or &quot;curvature&quot; matrix as described in the appendix to Nelder &amp; Mead (1965).  If successful, this matrix will be stored in the 'output' slot of the post-<a href="#topic+mxRun">run</a> MxComputeNelderMead object.  Although crude, its inverse can be used as an estimate of the repeated-sampling covariance matrix of the free parameters when the usual finite-differences Hessian is unreliable.
</p>
<p>OpenMx's implementation of Nelder-Mead can handle nonlinear inequality <a href="#topic+mxConstraint">MxConstraints</a> reasonably well.  Its default method for doing so, with argument <code>ineqConstraintMthd="soft"</code>, imposes a &quot;soft&quot; feasibility constraint by assigning a fitfunction value of <code>bignum</code> to points that violate the constraints by more than <a href="#topic+mxOption">mxOption</a> 'Feasibility tolerance'.  Alternately, with argument <code>ineqConstraintMthd="eqMthd"</code>, inequality <a href="#topic+mxConstraint">MxConstraints</a> can be handled by the same method provided to argument <code>eqConstraintMthd</code>, whether or not equality <a href="#topic+mxConstraint">MxConstraints</a> are present.
</p>
<p>OpenMx's implementation of Nelder-Mead respects equality <a href="#topic+mxConstraint">MxConstraints</a>, but does not handle them especially well.  Its effectiveness at handling equalities may be improved by providing a matrix to argument <code>iniSimplexMat</code> that ensures <em>all</em> of the initial vertices are feasible.  Users are warned that this Nelder-Mead implementation will not work correctly with MxModels containing redundant equality MxConstraints, and presently has no way of detecting whether any are present.  If argument <code>eqConstraintMthd="GDsearch"</code> (the default), then whenever Nelder-Mead evaluates the fitfunction at an infeasible point, it initiates a subsidiary optimization that uses <a href="#topic+mxComputeGradientDescent">SLSQP</a> to find the nearest (in squared Euclidean distance) feasible point, and replaces that feasible point for the infeasible one.  The user should note that the function evaluations that occur during this subsidiary optimization are counted toward the total number of fitfunction evaluations during the call to <code><a href="#topic+mxRun">mxRun</a>()</code>.  The effectiveness of the 'GDsearch' method is often improved by setting <a href="#topic+mxOption">mxOption</a> 'Feasibility tolerance' to a stricter (smaller) value than the on-load default.  The method specified by <code>eqConstraintMthd="soft"</code> is described in the preceding paragraph.  If argument <code>eqConstraintMthd="backtrack"</code>, then the optimizer attempts to backtrack from an infeasible point to a feasible point in a manner similar to that of Ghiasi et al. (2008), except that it used with <em>all</em> new points, and not just those encountered via reflection, expansion and contraction.  In this case, the displacement from the prior point to the candidate point is reduced by the proportion provided as the first element of argument <code>backtrackCtrl</code>, and thus a new candidate point is considered.  This process is repeated until feasibility of the candidate point is restored, or the number of attempts exceeds the second element of argument <code>backtrackCtrl</code>.   If argument <code>eqConstraintMthd="l1p"</code>, Nelder-Mead is used as part of an <code class="reqn">l_1</code>-penalty algorithm.  When using &quot;l1p&quot;, the simplex gradient (Kelley, 1999) and &quot;pseudo-Hessian&quot; are never calculated. 
</p>


<h3>Value</h3>

<p>Returns an object of class 'MxComputeNelderMead'.
</p>


<h3>References</h3>

<p>Ghiasi, H., Pasini, D., &amp; Lessard, L.  (2008).  Constrained globalized Nelder-Mead method for simultaneous structural and manufacturing optimization of a composite bracket.  <em>Journal of Composite Materials, 42</em>(7), p. 717-736.  doi: 10.1177/0021998307088592
</p>
<p>Gill, P. E., Murray, W., &amp; Wright, M. H.  (1982).  <em>Practical Optimization</em>.  Bingley, UK: Emerald Group Publishing Ltd.
</p>
<p>Kelley, C. T.  (1999).  Detection and remediation of stagnation in the Nelder-Mead algorithm using a sufficient decrease condition.  <em>SIAM Journal of Optimization 10</em>(1), p. 43-55.
</p>
<p>Nelder, J. A., &amp; Mead, R.  (1965) .  A simplex method for function minimization.  <em>The Computer Journal, 7</em>, p. 308-313.
</p>
<p>Singer, S., &amp; Nelder, J.  (2009).  Nelder-Mead algorithm.  <em>Scholarpedia, 4</em>(7):2928., revision #91557.  http://www.scholarpedia.org/article/Nelder-Mead_algorithm .
</p>
<p>Singer, S., &amp; Singer, S.  (2004).  Efficient implementation of the Nelder-Mead search algorithm.  <em>Applied Numerical Analysis &amp; Computational Mathematics Journal, 1</em>(2), p. 524-534.  doi: 10.1002/anac.200410015
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- mxComputeNelderMead()
str(foo)
</code></pre>

<hr>
<h2 id='mxComputeNewtonRaphson'>Optimize parameters using the Newton-Raphson algorithm</h2><span id='topic+mxComputeNewtonRaphson'></span><span id='topic+MxComputeNewtonRaphson-class'></span>

<h3>Description</h3>

<p>This optimizer requires analytic 1st and 2nd derivatives of the
fit function. Box constraints are supported. Parameters can
approach box constraints but will not leave the feasible region
(even by some small epsilon&gt;0). Non-finite fit values are
interpreted as soft feasibility constraints. That is, when a
non-finite fit is encountered, line search is continued after the
step size is multiplied by 10%. Comprehensive diagnostics are
available by increasing the verbose level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeNewtonRaphson(
  freeSet = NA_character_,
  ...,
  fitfunction = "fitfunction",
  maxIter = 100L,
  tolerance = 1e-12,
  verbose = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeNewtonRaphson_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeNewtonRaphson_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeNewtonRaphson_+3A_fitfunction">fitfunction</code></td>
<td>
<p>name of the fitfunction (defaults to 'fitfunction')</p>
</td></tr>
<tr><td><code id="mxComputeNewtonRaphson_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="mxComputeNewtonRaphson_+3A_tolerance">tolerance</code></td>
<td>
<p>optimization is considered converged when the maximum relative change in fit is less than tolerance</p>
</td></tr>
<tr><td><code id="mxComputeNewtonRaphson_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
</table>


<h3>References</h3>

<p>Luenberger, D. G. &amp; Ye, Y. (2008). <em>Linear and nonlinear programming.</em> Springer.
</p>

<hr>
<h2 id='mxComputeNothing'>Compute nothing</h2><span id='topic+mxComputeNothing'></span>

<h3>Description</h3>

<p>Note that this compute plan actually does nothing whereas
<code>mxComputeOnce("expectation", "nothing")</code> may remove the
prediction of an expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeNothing()
</code></pre>

<hr>
<h2 id='mxComputeNumericDeriv'>Numerically estimate Hessian using Richardson extrapolation</h2><span id='topic+mxComputeNumericDeriv'></span><span id='topic+MxComputeNumericDeriv-class'></span>

<h3>Description</h3>

<p>For N free parameters, Richardson extrapolation requires
(iterations * (N^2 + N)) function evaluations.
The implementation is closely based on the numDeriv R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeNumericDeriv(
  freeSet = NA_character_,
  ...,
  fitfunction = "fitfunction",
  parallel = TRUE,
  stepSize = imxAutoOptionValue("Gradient step size"),
  iterations = 4L,
  verbose = 0L,
  knownHessian = NULL,
  checkGradient = TRUE,
  hessian = TRUE,
  analytic = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeNumericDeriv_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_fitfunction">fitfunction</code></td>
<td>
<p>name of the fitfunction (defaults to 'fitfunction')</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_parallel">parallel</code></td>
<td>
<p>whether to evaluate the fitfunction in parallel (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_stepsize">stepSize</code></td>
<td>
<p>starting set size (defaults to 0.0001)</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_iterations">iterations</code></td>
<td>
<p>number of Richardson extrapolation iterations (defaults to 4L)</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_knownhessian">knownHessian</code></td>
<td>
<p>an optional matrix of known Hessian entries</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_checkgradient">checkGradient</code></td>
<td>
<p>whether to check the first order convergence criterion (gradient is near zero)</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_hessian">hessian</code></td>
<td>
<p>whether to estimate the Hessian. If FALSE then only the gradient is estimated.</p>
</td></tr>
<tr><td><code id="mxComputeNumericDeriv_+3A_analytic">analytic</code></td>
<td>
<p>Use the analytic Hessian, if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to an estimate of the Hessian, forward, central, and
backward estimates of the gradient are made available in this
compute plan's output slot.
</p>
<p>When <code>checkGradient=TRUE</code>, the central difference estimate of
the gradient is used to determine whether the first order
convergence criterion is met. In addition, the forward and
backward difference estimates of the gradient are compared for
symmetry. When sufficient asymmetry is detected, the standard
error is flagged. In the case, profile likelihood confidence
intervals should be used for inference instead of standard errors
(see <code>mxComputeConfidenceInterval</code>).
</p>
<p>If provided, the square matrix <code>knownHessian</code> should have
dimnames set to the names of some subset of the free
parameters. Entries of the matrix set to NA will be estimated
numerically while entries containing finite values will be copied
to the Hessian result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
data(demoOneFactor)
factorModel &lt;- mxModel(name ="One Factor",
	mxMatrix(type = "Full", nrow = 5, ncol = 1, free = FALSE, values = .2, name = "A"),
	mxMatrix(type = "Symm", nrow = 1, ncol = 1, free = FALSE, values = 1 , name = "L"),
	mxMatrix(type = "Diag", nrow = 5, ncol = 5, free = TRUE , values = 1 , name = "U"),
	mxAlgebra(A %*% L %*% t(A) + U, name = "R"),
	mxExpectationNormal(covariance = "R", dimnames = names(demoOneFactor)),
	mxFitFunctionML(),
	mxData(cov(demoOneFactor), type = "cov", numObs = 500),
	mxComputeSequence(
		list(mxComputeNumericDeriv(), mxComputeReportDeriv())
	)
)
factorModelFit &lt;- mxRun(factorModel)
factorModelFit$output$hessian
</code></pre>

<hr>
<h2 id='mxComputeOnce'>Compute something once</h2><span id='topic+mxComputeOnce'></span><span id='topic+MxComputeOnce-class'></span>

<h3>Description</h3>

<p>Some models are optimized for a sparse Hessian. Therefore, it can
be much more efficient to compute the inverse Hessian in
comparison to computing the Hessian and then inverting it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeOnce(
  from,
  what = NULL,
  how = NULL,
  ...,
  freeSet = NA_character_,
  verbose = 0L,
  .is.bestfit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeOnce_+3A_from">from</code></td>
<td>
<p>the object to perform the computation (a vector of expectation or fit function names)</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_what">what</code></td>
<td>
<p>what to compute</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_how">how</code></td>
<td>
<p>to compute it (optional)</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeOnce_+3A_.is.bestfit">.is.bestfit</code></td>
<td>
<p>do not use; for backward compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information matrix is only valid when parameters are at the
maximum likelihood estimate. The information matrix is returned in
model$output$hessian. You cannot request both the information
matrix and the Hessian. The information matrix is invariant to the
sign of the log likelihood scale whereas the Hessian is not.
Use the <code>how</code> parameter to specify which approximation to use
(one of &quot;default&quot;, &quot;hessian&quot;, &quot;sandwich&quot;, &quot;bread&quot;, and &quot;meat&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demoOneFactor)
factorModel &lt;- mxModel(name ="One Factor",
  mxMatrix(type="Full", nrow=5, ncol=1, free=TRUE, values=0.2, name="A"),
    mxMatrix(type="Symm", nrow=1, ncol=1, free=FALSE, values=1, name="L"),
    mxMatrix(type="Diag", nrow=5, ncol=5, free=TRUE, values=1, name="U"),
    mxAlgebra(expression=A %*% L %*% t(A) + U, name="R"),
    mxFitFunctionML(),mxExpectationNormal(covariance="R", dimnames=names(demoOneFactor)),
    mxData(observed=cov(demoOneFactor), type="cov", numObs=500),
    mxComputeOnce('fitfunction', 'fit'))
factorModelFit &lt;- mxRun(factorModel)
factorModelFit$output$fit  # 972.15
</code></pre>

<hr>
<h2 id='mxComputePenaltySearch'>Regularize parameter estimates</h2><span id='topic+mxComputePenaltySearch'></span><span id='topic+MxComputePenaltySearch-class'></span>

<h3>Description</h3>

<p>Add a penalty to push some subset of the parameter estimates toward zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputePenaltySearch(
  plan,
  ...,
  freeSet = NA_character_,
  verbose = 0L,
  fitfunction = "fitfunction",
  approach = "EBIC",
  ebicGamma = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputePenaltySearch_+3A_plan">plan</code></td>
<td>
<p>compute plan to optimize the model</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_fitfunction">fitfunction</code></td>
<td>
<p>the name of the deviance function</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_approach">approach</code></td>
<td>
<p>what fit function to use to compare regularized models? Currently only EBIC is available</p>
</td></tr>
<tr><td><code id="mxComputePenaltySearch_+3A_ebicgamma">ebicGamma</code></td>
<td>
<p>what Gamma value to use for EBIC? Must be between 0 and 1</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jacobucci, R., Grimm, K. J., &amp; McArdle, J. J. (2016).
Regularized structural equation modeling.
&lt;i&gt;Structural equation modeling: a multidisciplinary journal, 23&lt;/i&gt;(4), 555-566.
</p>

<hr>
<h2 id='mxComputeReportDeriv'>Report derivatives</h2><span id='topic+mxComputeReportDeriv'></span><span id='topic+MxComputeReportDeriv-class'></span>

<h3>Description</h3>

<p>Copy the internal gradient and Hessian back to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeReportDeriv(freeSet = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeReportDeriv_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeReportExpectation'>Report expectation</h2><span id='topic+mxComputeReportExpectation'></span><span id='topic+MxComputeReportExpectation-class'></span>

<h3>Description</h3>

<p>Copy the internal model expectations back to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeReportExpectation(freeSet = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeReportExpectation_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeSequence'>Invoke a series of compute objects in sequence</h2><span id='topic+mxComputeSequence'></span><span id='topic+MxComputeSequence-class'></span>

<h3>Description</h3>

<p>Invoke a series of compute objects in sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeSequence(
  steps = list(),
  ...,
  freeSet = NA_character_,
  independent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeSequence_+3A_steps">steps</code></td>
<td>
<p>a list of compute objects</p>
</td></tr>
<tr><td><code id="mxComputeSequence_+3A_...">...</code></td>
<td>
<p>Not used; forces argument 'freeSet' to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeSequence_+3A_freeset">freeSet</code></td>
<td>
<p>Names of matrices containing free parameters.</p>
</td></tr>
<tr><td><code id="mxComputeSequence_+3A_independent">independent</code></td>
<td>
<p>Whether the steps could be executed out-of-order.</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeSetOriginalStarts'>Reset parameter starting values</h2><span id='topic+mxComputeSetOriginalStarts'></span><span id='topic+MxComputeSetOriginalStarts-class'></span>

<h3>Description</h3>

<p>Sets the current parameter vector back to the original starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeSetOriginalStarts(freeSet = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeSetOriginalStarts_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
</table>

<hr>
<h2 id='mxComputeSimAnnealing'>Optimization using generalized simulated annealing</h2><span id='topic+mxComputeSimAnnealing'></span><span id='topic+MxComputeSimAnnealing-class'></span>

<h3>Description</h3>

<p>Performs simulated annealing to minimize the fit function.
If the original starting values are outside of the feasible set,
a few attempts are made to find viable starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeSimAnnealing(freeSet=NA_character_, ..., fitfunction='fitfunction',
 plan=mxComputeOnce('fitfunction','fit'),
 verbose=0L, method=c("tsallis1996", "ingber2012"), control=list(),
 defaultGradientStepSize=imxAutoOptionValue("Gradient step size"),
 defaultFunctionPrecision=imxAutoOptionValue("Function precision"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeSimAnnealing_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_fitfunction">fitfunction</code></td>
<td>
<p>name of the fitfunction (defaults to 'fitfunction')</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_plan">plan</code></td>
<td>
<p>compute plan to optimize the model</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_verbose">verbose</code></td>
<td>
<p>level of debugging output</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_method">method</code></td>
<td>
<p>which algorithm to use</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_control">control</code></td>
<td>
<p>control parameters specific to the chosen method</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_defaultgradientstepsize">defaultGradientStepSize</code></td>
<td>
<p>the default gradient step size</p>
</td></tr>
<tr><td><code id="mxComputeSimAnnealing_+3A_defaultfunctionprecision">defaultFunctionPrecision</code></td>
<td>
<p>the default function precision</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method &lsquo;tsallis1996&rsquo;,
the number of function evaluations are determined by the
<code>tempStart</code> and <code>tempEnd</code> parameters. There is no provision to
stop early because there is no way to determine whether the algorithm
has converged. The Markov step is implemented by cycling through each
parameters in turn and considering a univariate jump (like a Gibbs sampler).
</p>
<p>Control parameters include <code>qv</code> to control the shape of the
visiting distribution, <code>qaInit</code> to control the shape of the initial
acceptance distribution, <code>lambda</code> to reduce the probability of
acceptance in time, <code>tempStart</code> to specify starting temperature,
<code>tempEnd</code> to specify ending temperature, and <code>stepsPerTemp</code> to
set the number of Markov steps per temperature step.
</p>
<p>Non-linear constraints are accommodated by a penalty function.
Inequality constraints work reasonably well, but
equality constraints do not work very well.
Constrained optimization will likely require increasing <code>stepsPerTemp</code>.
</p>
<p>Classical simulated annealing (CSA) can be obtained with
<code>qv=qa=1</code> and <code>lambda=0</code>.
Fast simulated annealing (FSA) can be obtained with
<code>qv=2</code>, <code>qa=1</code>, and <code>lambda=0</code>.
FSA is faster than CSA, but GSA is faster than FSA.
GenSA default parameters are set to those identified in 
Xiang, Sun, Fan &amp; Gong (1997).  
</p>
<p>Method &lsquo;ingber2012&rsquo; has spawned a cultural tradition over more
than 30 years that is documented in Aguiar e Oliveira et al (2012).
Options are specified using the traditional option names in the
<code>control</code> list. However, there are a few option changes to
make ASA fit better with OpenMx.
Instead of option <code>Curvature_0</code>, use <a href="#topic+mxComputeNumericDeriv">mxComputeNumericDeriv</a>.
ASA_PRINT output is directed to <code>/dev/null</code> by default.
To direct ASA_PRINT output to console use <code>control=list('Asa_Out_File'= '/dev/fd/1')</code>.
ASA's option to control the finite differences gradient step size,
<code>Delta_X</code>, defaults to <a href="#topic+mxOption">mxOption</a>'s &lsquo;Gradient step
size&rsquo; instead of ASA's traditional 0.001.
Similarly, <code>Cost_Precision</code> defaults to <a href="#topic+mxOption">mxOption</a>'s
&lsquo;Function Precision&rsquo; instead of ASA's traditional 1e-18.
</p>


<h3>References</h3>

<p>Aguiar e Oliveira, H., Ingber, L., Petraglia, A., Petraglia, M. R., &amp; Machado, M. A. S. (2012). <em>Stochastic global optimization and its applications with fuzzy adaptive simulated annealing.</em> Springer Publishing Company, Incorporated.
</p>
<p>Tsallis, C., &amp; Stariolo, D. A. (1996). Generalized simulated
annealing. <em>Physica A: Statistical Mechanics and its Applications,
233</em>(1-2), 395-406.
</p>
<p>Xiang, Y., Sun, D. Y., Fan, W., &amp; Gong, X. G. (1997). Generalized
simulated annealing algorithm and its application to the Thomson
model. <em>Physics Letters A, 233</em>(3), 216-220.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxComputeTryHard">mxComputeTryHard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
m1 &lt;- mxModel(
	"poly22", # Eqn 22 from Tsallis &amp; Stariolo (1996)
	mxMatrix(type='Full', values=runif(4, min=-1e6, max=1e6),
		ncol=1, nrow=4, free=TRUE, name='x'),
	mxAlgebra(sum((x*x-8)^2) + 5*sum(x) + 57.3276, name="fit"),
	mxFitFunctionAlgebra('fit'),
	mxComputeSimAnnealing())

m1 &lt;- mxRun(m1)
summary(m1)
</code></pre>

<hr>
<h2 id='mxComputeStandardError'>Compute standard errors</h2><span id='topic+mxComputeStandardError'></span><span id='topic+MxComputeStandardError-class'></span>

<h3>Description</h3>

<p>When the fit is in -2 log likelihood units, the SEs are derived
from the diagonal of the Hessian or inverse Hessian. The Hessian
(in some form) must already be available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeStandardError(freeSet = NA_character_, fitfunction = "fitfunction")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeStandardError_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeStandardError_+3A_fitfunction">fitfunction</code></td>
<td>
<p>name of the fitfunction (defaults to 'fitfunction')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are active MxConstraints and the fit is in -2logL units,
the SEs are derived from the Hessian and the Jacobian of the
constraint functions (see references).
</p>


<h3>References</h3>

<p>Moore T &amp; Sadler B.  (2006).  <em>Maximum-Likelihood Estimation and
Scoring Under Parametric Constraints</em>.  Army Research Laboratory
report ARL-TR-3805.
Schoenberg R.  (1997).  Constrained maximum likelihood.
<em>Computational Economics, 10</em>, p. 251-266.
</p>

<hr>
<h2 id='mxComputeTryCatch'>Execute a sub-compute plan, catching errors</h2><span id='topic+mxComputeTryCatch'></span><span id='topic+MxComputeTryCatch-class'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Any error will be recorded in a subsequent checkpoint. After
execution, the context will be reset to continue computation as if
no errors has occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeTryCatch(plan, ..., freeSet = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeTryCatch_+3A_plan">plan</code></td>
<td>
<p>compute plan to optimize the model</p>
</td></tr>
<tr><td><code id="mxComputeTryCatch_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeTryCatch_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>
</p>

<hr>
<h2 id='mxComputeTryHard'>Repeatedly attempt a compute plan until successful</h2><span id='topic+mxComputeTryHard'></span><span id='topic+MxComputeTryHard-class'></span>

<h3>Description</h3>

<p>The provided compute plan is run until the status code indicates
success (0 or 1). It gives up after a small number of retries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxComputeTryHard(
  plan,
  ...,
  freeSet = NA_character_,
  verbose = 0L,
  location = 1,
  scale = 0.25,
  maxRetries = 3L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxComputeTryHard_+3A_plan">plan</code></td>
<td>
<p>compute plan to optimize the model</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_freeset">freeSet</code></td>
<td>
<p>names of matrices containing free variables</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of run-time diagnostic output. Set to zero to disable</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_location">location</code></td>
<td>
<p>location of the perturbation distribution</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_scale">scale</code></td>
<td>
<p>scale of the perturbation distribution</p>
</td></tr>
<tr><td><code id="mxComputeTryHard_+3A_maxretries">maxRetries</code></td>
<td>
<p>maximum number of plan evaluations per invocation (including the first evaluation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Upon failure, start values are randomly perturbed.  Currently only
the uniform distribution is implemented.  The distribution is
parameterized by arguments <code>location</code> and <code>scale</code>.  The
location parameter is the distribution's median.  For the uniform
distribution, <code>scale</code> is the absolute difference between its
median and extrema (i.e., half the width of the rectangle).  Each
start value is multiplied by a random draw and then added to a
random draw from a distribution with the same <code>scale</code> but
with a median of zero.
</p>


<h3>References</h3>

<p>Shanno, D. F. (1985). On Broyden-Fletcher-Goldfarb-Shanno method. <em>Journal of
Optimization Theory and Applications, 46</em>(1), 87-94.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxTryHard">mxTryHard</a></code>
</p>

<hr>
<h2 id='mxConstraint'>Create MxConstraint Object</h2><span id='topic+mxConstraint'></span><span id='topic+mxConstraintFromString'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxConstraint">MxConstraint</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxConstraint(expression, name=NA, ..., jac=character(0), verbose=0L, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxConstraint_+3A_expression">expression</code></td>
<td>
<p>The <a href="#topic+MxAlgebra">MxAlgebra</a>-like expression representing the constraint function.</p>
</td></tr>
<tr><td><code id="mxConstraint_+3A_name">name</code></td>
<td>
<p>An optional character string indicating the name of the object.</p>
</td></tr>
<tr><td><code id="mxConstraint_+3A_...">...</code></td>
<td>
<p>Not used.  Helps OpenMx catch bad input to argument <code>expression</code>, and requires argument <code>jac</code>&ndash;meant for advanced users&ndash;to be specified by name.</p>
</td></tr>
<tr><td><code id="mxConstraint_+3A_jac">jac</code></td>
<td>
<p>An optional character string naming the <a href="#topic+MxAlgebra">MxAlgebra</a>
or <a href="#topic+MxMatrix">MxMatrix</a> representing the Jacobian for the constraint
function.</p>
</td></tr>
<tr><td><code id="mxConstraint_+3A_verbose">verbose</code></td>
<td>
<p>For values greater than zero, enable runtime
diagnostics.</p>
</td></tr>
<tr><td><code id="mxConstraint_+3A_strict">strict</code></td>
<td>
<p>Whether to require that all Jacobian entries reference
free parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mxConstraint()</code> function defines relationships between two <a href="#topic+MxAlgebra">MxAlgebra</a> or <a href="#topic+MxMatrix">MxMatrix</a> objects. They are used to affect the estimation of free parameters in the referenced objects. The constraint relation is written identically to how a <a href="#topic+MxAlgebra">MxAlgebra</a> expression would be written.  The outermost operator in this relation must be either &lsquo;&lt;&rsquo;, &lsquo;==&rsquo; or &lsquo;&gt;&rsquo;. To affect an estimation or optimization, an <a href="#topic+MxConstraint">MxConstraint</a> object must be included in an <a href="#topic+MxModel">MxModel</a> object with all referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>
<p>Usage Note: Use of <code>mxConstraint()</code> should be avoided where it is possible to achieve the constraint by equating free parameters by label or position in an <a href="#topic+MxMatrix">MxMatrix</a> or <a href="#topic+MxAlgebra">MxAlgebra</a> object. Including mxConstraints in an mxModel will disable standard errors and the calculation of the final Hessian, and thus should be avoided when standard errors are of importance. Constraints also add computational overhead. If one labels two parameters the same, the optimizer has one fewer parameter to optimize. However, if one uses mxConstraint to do the same thing, both parameters remain estimated and a Lagrangian multiplier is added to maintain the constraint. This constraint also has to have its gradients computed and the order of the Hessian grows as well.  So while both approaches should work, the mxConstraint() will take longer to do so.
</p>
<p>Alternatives to mxConstraints include using labels, lbound or ubound arguments or algebras. Free parameters in the same <a href="#topic+MxModel">MxModel</a> may be constrained to equality by giving them the same name in their respective 'labels' matrices. Similarly, parameters may be fixed to an individual element in a <a href="#topic+MxModel">MxModel</a> object or the result of an <a href="#topic+MxAlgebra">MxAlgebra</a> object through labeling. For example, assigning a label of &ldquo;name[1,1]&ldquo; fixes the value of a parameter at the value in first row and first column of the matrix or algebra &ldquo;name&ldquo;. The mxConstraint function should be used to enforce inequalities that cannot be conveyed using other methods.
</p>
<p>Note that constraints should not depend on <a href="#topic+mxMatrix">definition
variables</a>. This mode of operation is not supported.
</p>
<p>Argument <code>jac</code> is used to provide the name of an <a href="#topic+MxMatrix">MxMatrix</a> or
<a href="#topic+MxAlgebra">MxAlgebra</a> that equals the matrix of first derivatives&ndash;the
Jacobian&ndash;of the constraint function with respect to the free
parameters.  Here, the &quot;constraint function&quot; refers to the constraint
expression in canonical form: an arbitrary matrix expression on the
left-hand side of the comparator, and a matrix of zeroes with the same
dimensions on the right-hand side.  The rows of the Jacobian correspond
to elements of the matrix result of the right-hand side, in column-major
order.  Each row of the Jacobian is the vector of first partial
derivatives, with respect to the free parameters of the MxModel, of its
corresponding element.  Each column of the Jacobian corresponds to a
free parameter of the MxModel; each column must be named with the label
of the corresponding free parameter.  All the
<a href="#topic+mxComputeGradientDescent">gradient-descent</a> optimizers are able
to take advantage of user-supplied Jacobians. To verify the analytic
Jacobian against the same values estimated by finite differences, use
&lsquo;verbose=3&rsquo;.
</p>
<p>In the past, OpenMx has relied on NPSOL's finite differences algorithm
to fill in unknown Jacobian entries. When analytic Jacobians are used,
OpenMx no longer relies on NPSOL's finite differences algorithm. Any
missing entries are taken care of by OpenMx's finite differences
algorithm. Whether NPSOL or OpenMx conducts finite differences,
the results should be very similar.
</p>


<h3>Value</h3>

<p>Returns an <a href="#topic+MxConstraint">MxConstraint</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+MxConstraint">MxConstraint</a> for the S4 class created by mxConstraint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

#Create a constraint between MxMatrices 'A' and 'B'
constraint &lt;- mxConstraint(A &gt; B, name = 'AdominatesB')

# Constrain matrix 'K' to be equal to matrix 'limit'

model &lt;- mxModel(model="con_test",
    mxMatrix(type="Full", nrow=2, ncol=2, free=TRUE, name="K"),
    mxMatrix(type="Full", nrow=2, ncol=2, free=FALSE, name="limit", values=1:4),
    mxConstraint(K == limit, name = "Klimit_equality"),
    mxAlgebra(min(K), name="minK"),
    mxFitFunctionAlgebra("minK")
)

fit &lt;- mxRun(model)
fit$matrices$K$values

#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4

# Constrain both free parameters of a matrix to equality using labels (both are set to "eq")
equal &lt;- mxMatrix("Full", 2, 1, free=TRUE, values=1, labels="eq", name="D")

# Constrain a matrix element in to be equal to the result of an algebra
start &lt;- mxMatrix("Full", 1, 1, free=TRUE,  values=1, labels="param", name="F")
alg   &lt;- mxAlgebra(log(start), name="logP")

# Force the fixed parameter in matrix G to be the result of the algebra
end   &lt;- mxMatrix("Full", 1, 1, free=FALSE, values=1, labels="logP[1,1]", name="G")

</code></pre>

<hr>
<h2 id='MxConstraint-class'>Class <code>"MxConstraint"</code></h2><span id='topic+MxConstraint-class'></span><span id='topic+MxConstraint'></span><span id='topic++24+3C-+2CMxConstraint-method'></span><span id='topic++24+2CMxConstraint-method'></span><span id='topic+names+2CMxConstraint-method'></span><span id='topic+print+2CMxConstraint-method'></span><span id='topic+show+2CMxConstraint-method'></span>

<h3>Description</h3>

<p>MxConstraint is an S4 class. An MxConstraint object
is a <a href="#topic+Named-entity">named entity</a>. New instances of this class can
be created using the function <code><a href="#topic+mxConstraint">mxConstraint</a>()</code>.
</p>


<h3>Details</h3>

<p>Slots may be referenced with the $ symbol. See the documentation for <a href="methods.html#topic+Classes">Classes</a> and the examples in the <a href="#topic+mxConstraint">mxConstraint</a> document for more information.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Character string; the name of the object.</p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"MxAlgebraFormula"</code>.  The <a href="#topic+MxAlgebra">MxAlgebra</a>-like expression representing the constraint function.</p>
</dd>
<dt><code>alg1</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  For internal use.</p>
</dd>
<dt><code>alg2</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  For internal use.</p>
</dd>
<dt><code>relation</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  For internal use.</p>
</dd>
<dt><code>jac</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <a href="#topic+MxAlgebra">MxAlgebra</a> representing the Jacobian for the constraint function.</p>
</dd>
<dt><code>linear</code>:</dt><dd><p>Logical. For internal use.</p>
</dd>
<dt><code>strict</code>:</dt><dd><p>Logical. Whether to require that all Jacobian entries reference
free parameters.</p>
</dd>
<dt><code>verbose</code>:</dt><dd><p>integer. For values greater than zero, enable runtime
diagnostics.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$&lt;-</dt><dd><p><code>signature(x = "MxConstraint")</code></p>
</dd>
<dt>$</dt><dd><p><code>signature(x = "MxConstraint")</code></p>
</dd>
<dt><a href="#topic+imxDeparse">imxDeparse</a></dt><dd><p><code>signature(object = "MxConstraint")</code></p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "MxConstraint")</code></p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "MxConstraint")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MxConstraint")</code></p>
</dd>
</dl>



<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxConstraint">mxConstraint</a>()</code> for the function that creates MxConstraint objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MxConstraint")
</code></pre>

<hr>
<h2 id='mxData'>Create MxData Object</h2><span id='topic+mxData'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxData">MxData</a> object. This can be used all forms of analysis (including WLS: see <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>).
It packages observed data (e.g. a dataframe, matrix, or cov or cor matrix) into an object with additional information allowing it to be processed in an mxModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   mxData(observed=NULL, type="none", means = NA, numObs = NA, acov=NA, fullWeight=NA,
          thresholds=NA, ..., observedStats=NA, sort=NA, primaryKey = as.character(NA),
          weight = as.character(NA), frequency = as.character(NA),
          verbose = 0L, .parallel=TRUE, .noExoOptimize=TRUE,
     minVariance=sqrt(.Machine$double.eps), algebra=c(),
   warnNPDacov=TRUE, warnNPDuseWeight=TRUE, exoFree=NULL,
   naAction=c("pass","fail","omit","exclude"),
   fitTolerance=sqrt(as.numeric(mxOption(key="Optimality tolerance"))),
   gradientTolerance=1e-2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxData_+3A_observed">observed</code></td>
<td>
<p>A matrix or data.frame which provides data to the
MxData object. Can be NULL when summary data are provided via &lsquo;observedStats&rsquo;.</p>
</td></tr>
<tr><td><code id="mxData_+3A_type">type</code></td>
<td>
<p>A character string defining the type of data in the
&lsquo;observed&rsquo; argument. Must be one of &ldquo;raw&rdquo;,
&ldquo;cov&rdquo;, &ldquo;cor&rdquo;, or &ldquo;acov&rdquo;. If no observed data are
provided then use &ldquo;none&rdquo;.</p>
</td></tr>
<tr><td><code id="mxData_+3A_means">means</code></td>
<td>
<p>An optional vector of means for use when &lsquo;type&rsquo; is &ldquo;cov&rdquo;, or &ldquo;cor&rdquo;.</p>
</td></tr>
<tr><td><code id="mxData_+3A_numobs">numObs</code></td>
<td>
<p>The number of observations in the data supplied in the &lsquo;observed&rsquo; argument. Required unless &lsquo;type&rsquo; equals &ldquo;raw&rdquo;.</p>
</td></tr>
<tr><td><code id="mxData_+3A_...">...</code></td>
<td>
<p>Not used. Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxData_+3A_observedstats">observedStats</code></td>
<td>
<p>A list containing observed statistics for weighted least squares estimation. See details for contents</p>
</td></tr>
<tr><td><code id="mxData_+3A_sort">sort</code></td>
<td>
<p>Whether to sort raw data prior to use (default NA).</p>
</td></tr>
<tr><td><code id="mxData_+3A_primarykey">primaryKey</code></td>
<td>
<p>The column name of the primary key used to uniquely identify rows (default NA)</p>
</td></tr>
<tr><td><code id="mxData_+3A_weight">weight</code></td>
<td>
<p>The column name containing row weights.</p>
</td></tr>
<tr><td><code id="mxData_+3A_frequency">frequency</code></td>
<td>
<p>The column name containing row frequencies.</p>
</td></tr>
<tr><td><code id="mxData_+3A_verbose">verbose</code></td>
<td>
<p>level of diagnostic output.</p>
</td></tr>
<tr><td><code id="mxData_+3A_.parallel">.parallel</code></td>
<td>
<p>logical. Whether to compute observed summary statistics in parallel.</p>
</td></tr>
<tr><td><code id="mxData_+3A_.noexooptimize">.noExoOptimize</code></td>
<td>
<p>logical. Whether to use math short-cuts for the case of no exogenous predictors.</p>
</td></tr>
<tr><td><code id="mxData_+3A_minvariance">minVariance</code></td>
<td>
<p>numeric. The minimum acceptable variance for &lsquo;observedStats$cov&rsquo;.</p>
</td></tr>
<tr><td><code id="mxData_+3A_acov">acov</code></td>
<td>
<p>Deprecated in favor of the acov element of observedStats.</p>
</td></tr>
<tr><td><code id="mxData_+3A_fullweight">fullWeight</code></td>
<td>
<p>Deprecated in favor of the fullWeight element of observedStats.</p>
</td></tr>
<tr><td><code id="mxData_+3A_thresholds">thresholds</code></td>
<td>
<p>Deprecated in favor of the thresholds element of observedStats.</p>
</td></tr>
<tr><td><code id="mxData_+3A_algebra">algebra</code></td>
<td>
<p>character vector. Names of algebras used to fill in
calculated columns of raw data. <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
<tr><td><code id="mxData_+3A_warnnpdacov">warnNPDacov</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxData_+3A_warnnpduseweight">warnNPDuseWeight</code></td>
<td>
<p>logical. Whether to warn when the asymptotic
covariance matrix is non-positive definite.</p>
</td></tr>
<tr><td><code id="mxData_+3A_exofree">exoFree</code></td>
<td>
<p>logical matrix of observed manifests by
exogenous predictors. Defaults to all TRUE, but you can fix some
regression coefficients in the <code>observedStats</code> <code>slope</code>
matrix to zero by setting entries to FALSE. <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
<tr><td><code id="mxData_+3A_naaction">naAction</code></td>
<td>
<p>Specify treatment of missing data. See details. <a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a></p>
</td></tr>
<tr><td><code id="mxData_+3A_fittolerance">fitTolerance</code></td>
<td>
<p>fit tolerance used for WLS summary statistics <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
<tr><td><code id="mxData_+3A_gradienttolerance">gradientTolerance</code></td>
<td>
<p>gradient tolerance used for WLS summary statistics <a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxData function creates <a href="#topic+MxData">MxData</a> objects used in <a href="#topic+mxModel">mxModel</a>s.
The &lsquo;observed&rsquo; argument may take either a data frame or a matrix, which is then described with the
&lsquo;type&rsquo; argument. Data types describe compatibility and usage with expectation functions in MxModel
objects. Three data types are supported (acov is deprecated).
</p>

<dl>
<dt>raw</dt><dd><p>The contents of the &lsquo;observed&rsquo; argument are treated as raw data. Missing values are permitted and must be
designated as the system missing value. The &lsquo;means&rsquo; and &lsquo;numObs&rsquo; arguments cannot be specified, as the
&lsquo;means&rsquo; argument is not relevant and the &lsquo;numObs&rsquo; argument is automatically populated with the number of rows
in the data. Data of this type may use fit functions such as <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> or <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>.
<a href="#topic+mxFitFunctionML">mxFitFunctionML</a> will automatically use use full-information maximum likelihood for raw data.</p>
</dd>
<dt>cov</dt><dd><p>The contents of the &lsquo;observed&rsquo; argument are treated as a covariance matrix. The &lsquo;means&rsquo; argument is
not required, but may be included for estimations involving means. The &lsquo;numObs&rsquo; argument is required, which should
reflect the number of observations or rows in the data described by the covariance matrix. Cov data typically use the
<a href="#topic+mxFitFunctionML">mxFitFunctionML</a> fit function, depending on the specified model.</p>
</dd>
<dt>acov</dt><dd><p> This type was used for WLS data as created by <a href="#topic+mxDataWLS">mxDataWLS</a>. Unless you are using summary data, its use is deprecated.
Instead, use type =&lsquo;raw&rsquo; and an <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>. If type &lsquo;acov&rsquo; is set, the &lsquo;observed&rsquo; argument will
(usually) contain raw data and the &lsquo;observedStats&rsquo; slot contain a list of observed statistics.</p>
</dd>
<dt>cor</dt><dd><p>The contents of the &lsquo;observed&rsquo; argument are treated as a correlation matrix. The &lsquo;means&rsquo; argument is
not required, but may be included for estimations involving means. The &lsquo;numObs&rsquo; argument is required, which should
reflect the number of observations or rows in the data described by the covariance matrix. Models with cor data typically use
the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> fit function.</p>
</dd>
</dl>

<p><em>Note on data handling</em>: OpenMx uses the names of variables to map them onto other elements of your model, such as expectation functions.
Thus for data provided as a data.frame, ensure the columns have appropriate <code><a href="base.html#topic+names">names</a></code>.
Covariance and correlation matrices need to have both the row and column names set and these must be
identical, for instance by using <code>dimnames = list(varNames, varNames)</code>.
</p>
<p><strong>Correlation data</strong>
</p>
<p>To obtain accurate parameter estimates and standard errors,
it is necessary to constrain the model implied covariance matrix to have
unit variances. This constraint is added automatically if you use an
<code><a href="#topic+mxModel">mxModel</a></code> with <code>type='RAM'</code> or <code>type='LISREL'</code>.
Otherwise, you will need to add this constraint yourself.
</p>
<p><strong>WLS data</strong>
</p>
<p>The <code>observedStats</code> contains the following named objects: cov, slope, means, asymCov, useWeight, and thresholds.
</p>
<p>&lsquo;cov&rsquo; The (polychoric) covariance matrix of raw data variables. An error is raised if any variance is smaller <code>minVariance</code>.
</p>
<p>&lsquo;slope&rsquo; The regression coefficients from all exogenous predictors to all observed variables. Required for exogenous predictors.
</p>
<p>&lsquo;means&rsquo; The means of the data variables. Required for estimations involving means.
</p>
<p>&lsquo;thresholds&rsquo; Thresholds of ordinal variables. Required for models including ordinal variables.
</p>
<p>&lsquo;asymCov&rsquo; The asymptotic covariance matrix (all entries
non-zero). This matrix is sample size independent. Lavaan's <code>NACOV</code> is
comparable to <code>asymCov</code> multiplied by N^2.
</p>
<p>&lsquo;useWeight&rsquo; (optional) The weight matrix used in the
<a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>. Can be dense or diagonal for diagonally
weighted least squares. This matrix is scaled by the sample size.
Lavaan's <code>WLS.V</code> is comparable to <code>useWeight</code>.
</p>
<p>A simple Newton Raphson optimizer is used to obtain the summary
statistics from the raw data. There are two parameters that control the
accuracy of the optimization. In a first pass, the fit function is
optimized to &lsquo;fitTolerance&rsquo;. However, fit function becomes
imprecise as the amount of data increases due to catastrophic
cancellation. To fine-tune the fit, the gradient is optimized to
&lsquo;gradientTolerance&rsquo;.
</p>
<p><em>note</em>: WLS data typically use the <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a> function.
</p>
<p><em>IMPORTANT</em>: The WLS interface is under heavy development to support both very fast backend processing of raw data while
continuing to support modeling applications which require direct access to the object in the front end. Some user-interface
changes should be expected as we optimize both these workflows.
</p>
<p><strong>Missing values</strong>
</p>
<p>For raw data, the &lsquo;naAction&rsquo; option controls the treatment of missing values.
When set to &lsquo;pass&rsquo;, the data is passed as-is.
When set to &lsquo;fail&rsquo;, the presence of any missing value will
trigger an error.
When set to &lsquo;omit&rsquo;, missing data will be discarded row-wise.
For example, a single missing value in a row will cause the whole row to
be discarded.
When set to &lsquo;exclude&rsquo;, rows with missing data are retained
but their &lsquo;frequency&rsquo; is set to zero.
</p>
<p><strong>Weights</strong>
</p>
<p>In the case of raw data, the optional &lsquo;weight&rsquo; argument names a column in the data that contains per-row weights.
Similarly, the optional &lsquo;frequency&rsquo; argument names a column in the &lsquo;observed&rsquo; data that contains per-row
frequencies. Frequencies must be integers but weights can be arbitrary real numbers. For data with many repeated response
patterns, organizing the data into unique patterns and frequencies can reduce model evaluation time.
</p>
<p>In some cases, the fit function can be evaluated more efficiently when data are sorted. When a primary key is provided,
sorting is disabled. Otherwise, sort defaults to TRUE.
</p>
<p>The mxData function does not currently place restrictions on the size, shape, or symmetry of matrices input into the
&lsquo;observed&rsquo; argument. While it is possible to specify MxData objects as covariance or correlation matrices that do not
have the properties commonly associated with these matrices, failure to correctly specify these matrices will likely lead to
problems in model estimation.
</p>
<p><em>note</em>: MxData objects may not be included in <a href="#topic+mxAlgebra">mxAlgebra</a>s nor in the <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> function. To
reference data in these functions, use a <a href="#topic+mxMatrix">mxMatrix</a> or a definition variable (data.var) label.
</p>
<p>Also, while column names are stored in the &lsquo;observed&rsquo; slot of MxData objects, these names are not automatically
recognized as variable names in <a href="#topic+MxPath-class">mxPaths</a> in RAM models. These models use the &lsquo;manifestVars&rsquo; of
the <a href="#topic+mxModel">mxModel</a> function to explicitly identify used variables used in the model.
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxData">MxData</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>To generate data, see <code><a href="#topic+mxGenerateData">mxGenerateData</a></code>; For objects which may be entered as arguments in the
&lsquo;observed&rsquo; slot, see <a href="base.html#topic+matrix">matrix</a> and <a href="base.html#topic+data.frame">data.frame</a>. See <a href="#topic+MxData">MxData</a> for the S4 class created by mxData.
For WLS data, see <a href="#topic+mxDataWLS">mxDataWLS</a> (deprecated). More information about the OpenMx package may be found
<a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

# Simple covariance model. See other mxFitFunctions for examples with different data types

# 1. Create a covariance matrix x and y
covMatrix &lt;- matrix(nrow = 2, ncol = 2, byrow = TRUE,
	c(0.77642931, 0.39590663,
      0.39590663, 0.49115615)
)
covNames &lt;- c("x", "y")
dimList &lt;- list(covNames, covNames)
dimnames(covMatrix) &lt;- dimList

# 2. Create an MxData object from covMatrix
testData &lt;- mxData(observed=covMatrix, type="cov", numObs = 100)

testModel &lt;- mxModel(model="testModel2",
	mxMatrix(name="expCov", type="Symm", nrow=2, ncol=2,
                 values=c(.2,.1,.2), free=TRUE, dimnames=dimList),
    mxExpectationNormal("expCov", dimnames=covNames),
    mxFitFunctionML(),
	testData
)

outModel &lt;- mxRun(testModel)

summary(outModel)

</code></pre>

<hr>
<h2 id='MxData-class'>MxData Class</h2><span id='topic+MxData-class'></span><span id='topic+MxData'></span><span id='topic++24+2CMxData-method'></span><span id='topic++24+3C-+2CMxData-method'></span><span id='topic+MxNonNullData-class'></span><span id='topic+print+2CMxNonNullData-method'></span><span id='topic+show+2CMxNonNullData-method'></span>

<h3>Description</h3>

<p>MxData is an S4 class. An MxData object is a <a href="#topic+Named-entity">named entity</a>.
New instances of this class can be created using the function <a href="#topic+mxData">mxData</a>.
MxData is an S4 class union. An MxData object is either <a href="base.html#topic+NULL">NULL</a> or a 
MxNonNullData object.
</p>


<h3>Details</h3>

<p>The MxNonNullData class has the following slots:
</p>

<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: center;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
    name </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The name of the object </td>
</tr>
<tr>
 <td style="text-align: right;">
    observed </td><td style="text-align: center;"> - </td><td style="text-align: left;"> Either a matrix or a data frame </td>
</tr>
<tr>
 <td style="text-align: right;">
    vector </td><td style="text-align: center;"> - </td><td style="text-align: left;"> A vector for means, or NA if missing </td>
</tr>
<tr>
 <td style="text-align: right;">
    type </td><td style="text-align: center;"> - </td><td style="text-align: left;"> Either 'raw', 'cov', or  'cor' </td>
</tr>
<tr>
 <td style="text-align: right;">
    numObs </td><td style="text-align: center;"> - </td><td style="text-align: left;"> The number of observations </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>The 'name' slot is the name of the MxData object. 
</p>
<p>The &lsquo;observed&rsquo; slot is used to contain data, either as a matrix or as a data frame. Use of the data in this slot by other functions depends on the value of the 'type' slot. When 'type' is equal to 'cov' or 'cor', the data input into the 'matrix' slot should be a symmetric matrix or data frame.
</p>
<p>The 'vector' slot is used to contain a vector of numeric values, which is used as a vector of means for MxData objects with 'type' equal to 'cov' or 'cor'. This slot may be used in estimation using the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> function. 
</p>
<p>The 'type' slot may take one of four supported values:
</p>

<dl>
<dt>raw</dt><dd><p>The contents of the &lsquo;observed&rsquo; slot are treated as raw data. Missing values are permitted and must be designated as the system missing value. The 'vector' and 'numObs' slots cannot be specified, as the 'vector' argument is not relevant and the 'numObs' argument is automatically populated with the number of rows in the data. Data of this type may use the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> function as its fit function in MxModel objects, which can deal with covariance estimation under full-information maximum likelihood.</p>
</dd>
<dt>cov</dt><dd><p>The contents of the &lsquo;observed&rsquo; slot are treated as a covariance matrix. The 'vector' argument is not required, but may be included for estimations involving means. The 'numObs' slot is required. Data of this type may use fit functions such as the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, depending on the specified model.</p>
</dd>
<dt>cor</dt><dd><p>The contents of the &lsquo;observed&rsquo; slot are treated as a correlation matrix. The 'vector' argument is not required, but may be included for estimations involving means. The 'numObs' slot is required.  Data of this type may use fit functions such as the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, depending on the specified model.</p>
</dd>
</dl>

<p>The 'numObs' slot describes the number of observations in the data. If 'type' equals 'raw', then 'numObs' is automatically populated as the number of rows in the matrix or data frame in the &lsquo;observed&rsquo; slot. If 'type' equals 'cov' or 'cor', then this slot must be input using the 'numObs' argument in the <a href="#topic+mxData">mxData</a> function when the MxData argument is created.
</p>
<p>MxData objects may not be included in <a href="#topic+MxAlgebra">MxAlgebra</a> objects or use the <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> function. If these capabilities are desired, data should be appropriately input or transformed using the <a href="#topic+mxMatrix">mxMatrix</a> and <a href="#topic+mxAlgebra">mxAlgebra</a> functions.
</p>
<p>While column names are stored in the &lsquo;observed&rsquo; slot of MxData objects, these names are not recognized as variable names in <a href="#topic+MxPath-class">MxPath</a> objects. Variable names must be specified using the 'manifestVars' argument of the <a href="#topic+mxModel">mxModel</a> function prior to use in <a href="#topic+MxPath-class">MxPath</a> objects.
</p>
<p>The mxData function does not currently place restrictions on the size, shape, or symmetry of matrices input into the &lsquo;observed&rsquo; argument. While it is possible to specify MxData objects as covariance or correlation matrices that do not have the properties commonly associated with these matrices, failure to correctly specify these matrices will likely lead to problems in model estimation.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxData">mxData</a> for creating MxData objects, <a href="base.html#topic+matrix">matrix</a> and <a href="base.html#topic+data.frame">data.frame</a> for objects which may be entered as arguments in the 'matrix' slot. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>

<hr>
<h2 id='mxDataDynamic'>Create dynamic data</h2><span id='topic+mxDataDynamic'></span><span id='topic+MxDataDynamic-class'></span><span id='topic+print+2CMxDataDynamic-method'></span><span id='topic+show+2CMxDataDynamic-method'></span>

<h3>Description</h3>

<p>Create dynamic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxDataDynamic(type, ..., expectation, verbose = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxDataDynamic_+3A_type">type</code></td>
<td>
<p>type of data</p>
</td></tr>
<tr><td><code id="mxDataDynamic_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxDataDynamic_+3A_expectation">expectation</code></td>
<td>
<p>the name of the expectation to provide the data</p>
</td></tr>
<tr><td><code id="mxDataDynamic_+3A_verbose">verbose</code></td>
<td>
<p>Increase runtime debugging output</p>
</td></tr>
</table>

<hr>
<h2 id='MxDataStatic-class'>Create static data</h2><span id='topic+MxDataStatic-class'></span><span id='topic+MxDataStatic'></span><span id='topic+print+2CMxDataStatic-method'></span><span id='topic+show+2CMxDataStatic-method'></span>

<h3>Description</h3>

<p>Internal static data class.
</p>


<h3>Details</h3>

<p>Not to be used.
</p>

<hr>
<h2 id='mxDataWLS'>Create legacy MxData Object for Least Squares (WLS, DWLS, ULS) Analyses</h2><span id='topic+mxDataWLS'></span><span id='topic+MxDataLegacyWLS-class'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxData">MxData</a> object of type 
&ldquo;ULS&rdquo; (unweighted least squares), &ldquo;WLS&rdquo; (weighted least squares) 
or &ldquo;DWLS&rdquo; (diagonally-weighted least squares). The appropriate
fit function to include with these models is <code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>
</p>
<p><em>note</em>: This function continues to work, but is deprecated. Use <a href="#topic+mxData">mxData</a> and <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   mxDataWLS(data, type = "WLS", useMinusTwo = TRUE, returnInverted = TRUE, 
    fullWeight = TRUE, suppressWarnings = TRUE, allContinuousMethod =
   c("cumulants", "marginals"), silent=!interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxDataWLS_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame which provides raw data to be used for WLS.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_type">type</code></td>
<td>
<p>A character string 'WLS' (default), 'DWLS', or 'ULS' for
weighted, diagonally weighted, or unweighted least squares, respectively</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_useminustwo">useMinusTwo</code></td>
<td>
<p>Logical indicating whether to use -2LL (default) or -LL.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_returninverted">returnInverted</code></td>
<td>
<p>Logical indicating whether to return the information matrix (default) or the covariance matrix.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_fullweight">fullWeight</code></td>
<td>
<p>Logical determining if the full weight matrix is
returned (default). Needed for standard error and quasi-chi-squared
calculation.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>Logical that determines whether to suppress
diagnostic warnings. These warnings are likely only helpful to developers.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_allcontinuousmethod">allContinuousMethod</code></td>
<td>
<p>A character string 'cumulants' (default) or
'marginals'. See mxFitFunctionWLS.</p>
</td></tr>
<tr><td><code id="mxDataWLS_+3A_silent">silent</code></td>
<td>
<p>Whether to report progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxDataWLS function creates an <a href="#topic+MxData">MxData</a> object, which can be used in
<a href="#topic+MxModel">MxModel</a> objects.  This function takes raw data and returns an <code>MxData</code> object to be used in a model to fit with weighted least squares.
</p>
<p><em>note</em>: This function continues to work, but is deprecated. Use <a href="#topic+mxData">mxData</a> and <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a> instead.
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxData">MxData</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>
<p>Browne, M. W. (1984).  Asymptotically Distribution-Free Methods for the Analysis of Covariance Structures. <em>British Journal of Mathematical and Statistical Psychology</em>, <strong>37</strong>, 62-83.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>.  <a href="#topic+MxData">MxData</a> for the S4 class created by mxData. <a href="base.html#topic+matrix">matrix</a> and <a href="base.html#topic+data.frame">data.frame</a> for objects which may be entered as arguments in the &lsquo;observed&rsquo; slot. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra, mxExpectationNormal, and mxFitFunctionWLS

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)
wdata &lt;- mxDataWLS(tmpFrame)

# Define the matrices


S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1), 
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA), name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Define the expectation

expCov &lt;- mxAlgebra(solve(I-A) %*% S %*% t(solve(I-A)), name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", dimnames=tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionWLS()

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", S, A, I, expCov, expFunction, fitFunction, 
                    wdata)

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)
</code></pre>

<hr>
<h2 id='mxDescribeDataWLS'>Determine whether a dataset will have weights and summary statistics for the means if used with mxFitFunctionWLS</h2><span id='topic+mxDescribeDataWLS'></span>

<h3>Description</h3>

<p>Given either a data.frame or an mxData of type raw, this function determines whether <code>mxFitFunctionWLS</code>
will generate expectations for means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxDescribeDataWLS(
  data,
  allContinuousMethod = c("cumulants", "marginals"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxDescribeDataWLS_+3A_data">data</code></td>
<td>
<p>the (currently raw) data being used in a <code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code> model.</p>
</td></tr>
<tr><td><code id="mxDescribeDataWLS_+3A_allcontinuousmethod">allContinuousMethod</code></td>
<td>
<p>the method used to process data when all columns are continuous.</p>
</td></tr>
<tr><td><code id="mxDescribeDataWLS_+3A_verbose">verbose</code></td>
<td>
<p>logical. Whether to report diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All-continuous data processed using the &quot;cumulants&quot; method lack means, while
all continuous data processed with allContinuousMethod = &quot;marginals&quot; will have means.
</p>
<p>When data are not all continuous, allContinuousMethod is ignored, and means are modelled.
</p>


<h3>Value</h3>

<p>- list describing the data.
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+omxAugmentDataWithWLSSummary">omxAugmentDataWithWLSSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ====================================
# = All continuous, data.frame input =
# ====================================

tmp = mxDescribeDataWLS(mtcars, allContinuousMethod= "cumulants", verbose = TRUE)
tmp$hasMeans # FALSE - no means with cumulants
tmp = mxDescribeDataWLS(mtcars, allContinuousMethod= "marginals")
tmp$hasMeans # TRUE we get means with marginals

# ==========================
# = mxData object as input =
# ==========================
tmp = mxData(mtcars, type="raw")
mxDescribeDataWLS(tmp, allContinuousMethod= "cumulants", verbose = TRUE)$hasMeans # FALSE
mxDescribeDataWLS(tmp, allContinuousMethod= "marginals")$hasMeans  # TRUE

# =======================================
# = One var is a factor: Means modelled =
# =======================================
tmp = mtcars
tmp$cyl = factor(tmp$cyl)
mxDescribeDataWLS(tmp, allContinuousMethod= "cumulants")$hasMeans # TRUE - always has means
mxDescribeDataWLS(tmp, allContinuousMethod= "marginals")$hasMeans # TRUE

</code></pre>

<hr>
<h2 id='MxDirectedGraph-class'>MxDirectedGraph</h2><span id='topic+MxDirectedGraph-class'></span><span id='topic+MxDirectedGraph'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
It is a class for directed graphs.
</p>

<hr>
<h2 id='mxEval'>Evaluate Values in MxModel</h2><span id='topic+mxEval'></span><span id='topic+mxEvalByName'></span>

<h3>Description</h3>

<p>This function can be used to evaluate an arbitrary R expression that includes named entities from a <a href="#topic+MxModel">MxModel</a> object, or labels from a <a href="#topic+MxMatrix">MxMatrix</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxEval(expression, model, compute = FALSE, show = FALSE, defvar.row = 1,
    cache = new.env(parent = emptyenv()), cacheBack = FALSE, .extraBack=0L)

mxEvalByName(name, model, compute = FALSE, show = FALSE, defvar.row = 1,
    cache = new.env(parent = emptyenv()), cacheBack = FALSE, .extraBack=0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxEval_+3A_expression">expression</code></td>
<td>
<p>An arbitrary R expression.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_model">model</code></td>
<td>
<p>The model in which to evaluate the expression.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_compute">compute</code></td>
<td>
<p>If TRUE then compute the value of algebra expressions
and populate square bracket substitutions.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_show">show</code></td>
<td>
<p>If TRUE then print the translated expression.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_defvar.row">defvar.row</code></td>
<td>
<p>The row number for definition variables when compute=TRUE; defaults to 1.  When compute=FALSE, values for definition variables are always taken from the first (i.e., first before any automated sorting is done) row of the raw data.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_cache">cache</code></td>
<td>
<p>An R environment of matrix values used to speedup computation.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_cacheback">cacheBack</code></td>
<td>
<p>If TRUE then return the list pair (value, cache).</p>
</td></tr>
<tr><td><code id="mxEval_+3A_name">name</code></td>
<td>
<p>The character name of an object to evaluate.</p>
</td></tr>
<tr><td><code id="mxEval_+3A_.extraback">.extraBack</code></td>
<td>
<p>Depth of original caller in count of stack frames (environments).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
The argument &lsquo;expression&rsquo; is an arbitrary R expression.  Any named entities that are used within the R expression are translated into their current value from the model. Any labels from the matrices within the model are translated into their current value from the model. Finally the expression is evaluated and the result is returned.  To enable debugging, the &lsquo;show&rsquo; argument has been provided.  The most common mistake when using this function is to include named entities in the model that are identical to R function names.  For example, if a model contains a named entity named &lsquo;c&rsquo;, then the following mxEval call will return an error: <code>mxEval(c(A, B, C), model)</code>.
</p>
<p>The <code>mxEvalByName</code> function is a wrapper around <code>mxEval</code> that takes a character instead of an R expression.
</p>
<p>If &lsquo;compute&rsquo; is FALSE, then MxAlgebra expressions return their
current values as they have been computed by the optimization call
(using <a href="#topic+mxRun">mxRun</a>). If the &lsquo;compute&rsquo; argument is TRUE, then
MxAlgebra expressions will be calculated in R and square bracket
substitutions will be performed.  Any references to an objective
function that has not yet been calculated will return a 1 x 1 matrix
with a value of NA.
</p>
<p>The &lsquo;cache&rsquo; is used to speedup calculation by storing previously computing values. The cache is a list of matrices, such that names(cache) must all be of the form &ldquo;modelname.entityname&rdquo;. Setting &lsquo;cacheBack&rsquo; 
to TRUE will return the pair list(value, cache) where value is the result of the mxEval() computation and cache is the updated cache.</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxAlgebra">mxAlgebra</a> to create algebraic expressions inside your model 
and <a href="#topic+mxModel">mxModel</a> for the model object mxEval looks inside when evaluating. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

# Set up a 1x1 matrix
matrixA &lt;- mxMatrix("Full", nrow = 1, ncol = 1, values = 1, name = "A")

# Set up an algebra
algebraB &lt;- mxAlgebra(A + A, name = "B")

# Put them both in a model
testModel &lt;- mxModel(model="testModel3", matrixA, algebraB)

# Even though the model has not been run, we can evaluate the algebra
#   given the starting values in matrixA.
mxEval(B, testModel, compute=TRUE)

# If we just print the algebra, we can see it has not been evaluated
testModel$B


</code></pre>

<hr>
<h2 id='mxEvaluateOnGrid'>Evaluate an algebra on an abscissa grid and collect column results</h2><span id='topic+mxEvaluateOnGrid'></span>

<h3>Description</h3>

<p>This function evaluates an algebra on a grid of points provided in
an auxiliary abscissa matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxEvaluateOnGrid(algebra, abscissa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxEvaluateOnGrid_+3A_algebra">algebra</code></td>
<td>
<p>the name of the single column matrix to be evaluated.</p>
</td></tr>
<tr><td><code id="mxEvaluateOnGrid_+3A_abscissa">abscissa</code></td>
<td>
<p>the name of the abscissa matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The abscissa matrix must be in a specific format.
The variables are in the rows. Abscissa row names must match names of
free variables.
The grid points are in columns.
For each point (column), the free variables are set to the given
values and the algebra is re-evaluated. The resulting columns are
collected as the result.
</p>


<h3>Value</h3>

<p>Returns the collected columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

test2 &lt;- mxModel("test2",
	mxMatrix(values=1.1, nrow=1, ncol=1, free=TRUE, name="thang"),
	mxMatrix(nrow=1, ncol=1, labels="abscissa1", free=TRUE, name="currentAbscissa"),
	mxMatrix(values=-2:2, nrow=1, ncol=5, name="abscissa",
		 dimnames=list(c('abscissa1'), NULL)),
	mxAlgebra(rbind(currentAbscissa + thang, currentAbscissa * thang), name="stuff"),
	mxAlgebra(mxEvaluateOnGrid(stuff, abscissa), name="grid"))
	
test2 &lt;- mxRun(test2)
omxCheckCloseEnough(test2$grid$result, matrix(c(-1:3 + .1, -2:2 * 1.1), ncol=5, nrow=2,byrow=TRUE))
</code></pre>

<hr>
<h2 id='MxExpectation-class'>MxExpectation</h2><span id='topic+MxExpectation-class'></span><span id='topic+MxExpectation'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxExpectationBA81'>Create a Bock &amp; Aitkin (1981) expectation</h2><span id='topic+mxExpectationBA81'></span><span id='topic+MxExpectationBA81-class'></span><span id='topic+show+2CMxExpectationBA81-method'></span><span id='topic+print+2CMxExpectationBA81-method'></span>

<h3>Description</h3>

<p>Used in conjunction with <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, this expectation
models ordinal data with a modest number of latent dimensions.
Currently, only a multivariate Normal latent distribution is
supported.  An equal-interval quadrature is used to integrate over
the latent distribution.  When all items use the graded response
model and items are assumed conditionally independent then item
factor analysis is equivalent to a factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationBA81(
  ItemSpec,
  item = "item",
  ...,
  qpoints = 49L,
  qwidth = 6,
  mean = "mean",
  cov = "cov",
  verbose = 0L,
  weightColumn = NA_integer_,
  EstepItem = NULL,
  debugInternal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationBA81_+3A_itemspec">ItemSpec</code></td>
<td>
<p>a single item model (to replicate) or a list of
item models in the same order as the column of <code>ItemParam</code></p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_item">item</code></td>
<td>
<p>the name of the mxMatrix holding item parameters
with one column for each item model with parameters starting at
row 1 and extra rows filled with NA</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_qpoints">qpoints</code></td>
<td>
<p>number of points to use for equal interval quadrature integration (default 49L)</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_qwidth">qwidth</code></td>
<td>
<p>the width of the quadrature as a positive Z score (default 6.0)</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_mean">mean</code></td>
<td>
<p>the name of the mxMatrix holding the mean vector</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_cov">cov</code></td>
<td>
<p>the name of the mxMatrix holding the covariance matrix</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_verbose">verbose</code></td>
<td>
<p>the level of runtime diagnostics (default 0L)</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_weightcolumn">weightColumn</code></td>
<td>
<p>the name of the column in the data containing the row weights (DEPRECATED)</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_estepitem">EstepItem</code></td>
<td>
<p>a simple matrix of item parameters for the
E-step. This option is mainly of use for debugging derivatives.</p>
</td></tr>
<tr><td><code id="mxExpectationBA81_+3A_debuginternal">debugInternal</code></td>
<td>
<p>when enabled, some of the internal tables are
returned in $debug. This is mainly of use to developers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional likelihood of response <code class="reqn">x_{ij}</code> to
item <code class="reqn">j</code> from person <code class="reqn">i</code> with item parameters
<code class="reqn">\xi_j</code> and latent ability <code class="reqn">\theta_i</code> is
</p>
<p style="text-align: center;"><code class="reqn">L(x_i|\xi,\theta_i) = \prod_j \mathrm{Pr}(\mathrm{pick}=x_{ij} | \xi_j,\theta_i).</code>
</p>

<p>Items are assumed to be conditionally independent.
That is, the outcome of one item is assumed to not influence
another item after controlling for <code class="reqn">\xi</code> and <code class="reqn">\theta_i</code>.
</p>
<p>The unconditional likelihood is obtained by integrating over
the latent distribution <code class="reqn">\theta_i</code>,
</p>
<p style="text-align: center;"><code class="reqn">L(x_i|\xi) = \int L(x_i|\xi, \theta_i) L(\theta_i) \mathrm{d}\theta_i.</code>
</p>

<p>With an assumption that examinees are independently and identically distributed,
we can sum the individual log likelihoods,
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{L}=\sum_i \log L(x_i | \xi).</code>
</p>

<p>Response models <code class="reqn">\mathrm{Pr}(\mathrm{pick}=x_{ij} |
\xi_j,\theta_i)</code>
are not implemented in OpenMx, but are imported
from the <a href="https://cran.r-project.org/package=rpf">RPF</a>
package. You must pass a list of models obtained from the RPF
package in the &lsquo;ItemSpec&rsquo; argument. All item models must use the
same number of latent factors although some of these factor
loadings can be constrained to zero in the item parameter matrix.
The &lsquo;item&rsquo; matrix contains item parameters with one item per
column in the same order at ItemSpec.
</p>
<p>The &lsquo;qpoints&rsquo; and &lsquo;qwidth&rsquo; argument control the fineness and
width, respectively, of the equal-interval quadrature grid.  The
integer &lsquo;qpoints&rsquo; is the number of points per dimension. The
quadrature extends from negative qwidth to positive qwidth for
each dimension. Since the latent distribution defaults to standard
Normal, qwidth can be regarded as a value in Z-score units.
</p>
<p>The optional &lsquo;mean&rsquo; and &lsquo;cov&rsquo; arguments permit modeling of the
latent distribution in multigroup models (in a single group, the
latent distribution must be fixed). A separate latent covariance
model is used in combination with mxExpectationBA81. The point
mass distribution contained in the quadrature is converted into a
multivariate Normal distribution by
<a href="#topic+mxDataDynamic">mxDataDynamic</a>. Typically <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> is used
to fit a multivariate Normal model to these data. Some intricate
programming is required.  Examples are given in the manual.
mxExpectationBA81 uses a sample size of <code class="reqn">N</code> for the covariance
matrix. This differs from <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> which uses a
sample size of <code class="reqn">N-1</code>.
</p>
<p>The &lsquo;verbose&rsquo; argument enables diagnostics that are mainly of
interest to developers.
</p>
<p>When a two-tier covariance matrix is recognized, this expectation
automatically enables analytic dimension reduction (Cai, 2010).
</p>
<p>The optional &lsquo;weightColumn&rsquo; is superseded by the weight
argument in <a href="#topic+mxData">mxData</a>. For data with many repeated
response patterns, model evaluation time can be
reduced. An easy way to transform your data into this form is to
use <a href="rpf.html#topic+compressDataFrame">compressDataFrame</a>. Non-integer weights are supported except for
<a href="rpf.html#topic+EAPscores">EAPscores</a>.
</p>
<p>mxExpectationBA81 requires <a href="#topic+mxComputeEM">mxComputeEM</a>. During a typical
optimization run, latent abilities are assumed for examinees
during the E-step.  These examinee scores are implied by the
previous iteration's parameter vector. This can be overridden
using the &lsquo;EstepItem&rsquo; argument.  This is mainly of use to
developers for checking item parameter derivatives.
</p>
<p>Common univariate priors are available from
<a href="ifaTools.html#topic+univariatePrior">univariatePrior</a>.  The standard Normal
distribution of the quadrature acts like a prior distribution for
difficulty. It is not necessary to impose any additional Bayesian
prior on difficulty estimates (Baker &amp; Kim, 2004, p. 196).
</p>
<p>Many estimators are available for standard errors. Oakes is
recommended (see <a href="#topic+mxComputeEM">mxComputeEM</a>).  Also available are
Supplement EM (<a href="#topic+mxComputeEM">mxComputeEM</a>), Richardson extrapolation
(<a href="#topic+mxComputeNumericDeriv">mxComputeNumericDeriv</a>), likelihood-based confidence
intervals (<a href="#topic+mxCI">mxCI</a>), and the covariance of the rowwise
gradients.
</p>


<h3>References</h3>

<p>Bock, R. D., &amp; Aitkin, M. (1981). Marginal maximum likelihood estimation of item
parameters: Application of an EM algorithm. <em>Psychometrika, 46</em>, 443-459.
</p>
<p>Cai, L. (2010). A two-tier full-information item factor analysis
model with applications. <em>Psychometrika, 75</em>, 581-612.
</p>
<p>Pritikin, J. N., Hunter, M. D., &amp; Boker, S. M. (2015). Modular
open-source software for Item Factor Analysis. <em>Educational and
Psychological Measurement, 75</em>(3), 458-474
</p>
<p>Pritikin, J. N. &amp; Schmidt, K. M. (in press). Model builder for
Item Factor Analysis with OpenMx. <em>R Journal</em>.
</p>
<p>Seong, T. J. (1990). Sensitivity of marginal maximum likelihood
estimation of item and ability parameters to the characteristics
of the prior ability distributions. <em>Applied Psychological
Measurement, 14</em>(3), 299-311.
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=rpf">RPF</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
library(rpf)

numItems &lt;- 14

# Create item specifications
spec &lt;- list()
for (ix in 1:numItems) { spec[[ix]] &lt;- rpf.grm(outcomes=sample(2:7, 1)) }
names(spec) &lt;- paste("i", 1:numItems, sep="")

# Generate some random "true" parameter values
correct.mat &lt;- mxSimplify2Array(lapply(spec, rpf.rparam))

# Generate some example data
data &lt;- rpf.sample(500, spec, correct.mat)

# Create a matrix of item parameters with starting values
imat &lt;- mxMatrix(name="item",
                 values=mxSimplify2Array(lapply(spec, rpf.rparam)))
rownames(imat)[1] &lt;- 'f1'
imat$free[!is.na(correct.mat)] &lt;- TRUE
imat$values[!imat$free] &lt;- NA

# Create a compute plan
plan &lt;- mxComputeSequence(list(
  mxComputeEM('expectation', 'scores',
              mxComputeNewtonRaphson(), information="oakes1999",
              infoArgs=list(fitfunction='fitfunction')),
  mxComputeHessianQuality(),
  mxComputeStandardError(),
  mxComputeReportDeriv()))

# Build the OpenMx model
grmModel &lt;- mxModel(model="grm1", imat,
                    mxData(observed=data, type="raw"),
                    mxExpectationBA81(ItemSpec=spec),
                    mxFitFunctionML(),
                    plan)

grmModel &lt;- mxRun(grmModel)
summary(grmModel)
</code></pre>

<hr>
<h2 id='mxExpectationGREML'>
Create MxExpectationGREML Object
</h2><span id='topic+mxExpectationGREML'></span>

<h3>Description</h3>

<p>This function creates a new <code><a href="#topic+MxExpectationGREML">MxExpectationGREML</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationGREML(V, yvars=character(0), Xvars=list(), addOnes=TRUE, blockByPheno=TRUE, 
                  staggerZeroes=TRUE, dataset.is.yX=FALSE, casesToDropFromV=integer(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationGREML_+3A_v">V</code></td>
<td>
<p>Character string; the name of the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> to serve as the 'V' matrix (the model-expected covariance matrix).  Internally, the 'V' matrix is assumed to be symmetric, and its elements above the main diagonal are ignored.</p>
</td></tr>
<tr><td><code id="mxExpectationGREML_+3A_yvars">yvars</code>, <code id="mxExpectationGREML_+3A_xvars">Xvars</code>, <code id="mxExpectationGREML_+3A_addones">addOnes</code>, <code id="mxExpectationGREML_+3A_blockbypheno">blockByPheno</code>, <code id="mxExpectationGREML_+3A_staggerzeroes">staggerZeroes</code></td>
<td>
<p>Passed to <code><a href="#topic+mxGREMLDataHandler">mxGREMLDataHandler</a>()</code>.</p>
</td></tr>
<tr><td><code id="mxExpectationGREML_+3A_dataset.is.yx">dataset.is.yX</code></td>
<td>
<p>Logical; defaults to <code>FALSE</code>.  If <code>TRUE</code>, then the first column of the raw dataset is taken as-is to be the 'y' phenotype vector, and the remaining columns are taken as-is to be the 'X' matrix of covariates.  In this case, <code><a href="#topic+mxGREMLDataHandler">mxGREMLDataHandler</a>()</code> is never internally called at runtime, and all other arguments besides <code>V</code> and <code>casesToDropFromV</code> are ignored.</p>
</td></tr>
<tr><td><code id="mxExpectationGREML_+3A_casestodropfromv">casesToDropFromV</code></td>
<td>
<p>Integer vector.  Its elements are the numbers of the rows and columns of covariance matrix 'V' to be dropped at runtime, usually because they correspond to rows of 'y' or 'X' that contained missing observations.  By default, no cases are dropped from 'V.'  Ignored unless <code>dataset.is.yX=TRUE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;GREML&quot; stands for &quot;genomic-relatedness-matrix restricted maximum-likelihood.&quot;  In the strictest sense of the term, it refers to genetic variance-component estimation from matrices of subjects' pairwise degree of genetic relatedness, as calculated from genome-wide marker data.  It is from this original motivation that some of the terminology originates, such as calling 'y' the &quot;phenotype&quot; vector.  However, OpenMx's implementation of GREML is applicable for analyses from any subject-matter domain, and in which the following assumptions are reasonable:
</p>

<ol>
<li><p> Conditional on 'X' (the covariates), the phenotype vector (response variable) 'y' is a single realization from a multivariate-normal distribution having (in general) a dense covariance matrix, 'V.'
</p>
</li>
<li><p> The parameters of the covariance matrix, such as variance components, are of primary interest.
</p>
</li>
<li><p> The random effects are normally distributed.
</p>
</li>
<li><p> Weighted least-squares regression, using the inverse of 'V' as a weight matrix, is an adequate model for the phenotypic means.  Note that the regression coefficients are not actually free parameters to be numerically optimized.</p>
</li></ol>

<p>Computationally, the chief distinguishing feature of an OpenMx GREML analysis is that the phenotype vector, 'y,' is a single realization of a random vector that, in general, cannot be partitioned into independent subvectors.  For this reason, definition variables are not compatible (and should be unnecessary with) GREML expectation.  GREML expectation can still be used if the covariance matrix is sparse, but as of this writing, OpenMx does not take advantage of the sparseness to improve performance.  Because of the limitations of restricted maximum likelihood, GREML expectation is presently incompatible with ordinal variables.
</p>


<h3>Value</h3>

<p>Returns a new object of class <code><a href="#topic+MxExpectationGREML">MxExpectationGREML</a></code>.
</p>


<h3>References</h3>

<p>Kirkpatrick RM, Pritikin JN, Hunter MD, &amp; Neale, MC.  (2021).  Combining structural-equation modeling with genomic-relatedness matrix restricted maximum likelihood in OpenMx.  In press at Behavior Genetics.  https://doi.org/10.1007/s10519-020-10037-5
</p>
<p>One of the first uses of the acronym &quot;GREML&quot;:<br />
Benjamin DJ, Cesarini D, van der Loos MJHM, Dawes CT, Koellinger PD, et al. (2012) The genetic architecture of economic and political preferences. Proceedings of the National Academy of Sciences 109: 8026-8031. doi: 10.1073/pnas.1120666109
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+MxExpectationGREML">MxExpectationGREML</a></code> for the S4 class created by <code>mxExpectationGREML()</code>. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- cbind(rnorm(100),rep(1,100))
colnames(dat) &lt;- c("y","x")

ge &lt;- mxExpectationGREML(V="V",yvars="y",Xvars=list("X"),addOnes=FALSE)
gff &lt;- mxFitFunctionGREML(dV=c(ve="I"))
plan &lt;- mxComputeSequence(freeSet=c("Ve"),steps=list(
  mxComputeNewtonRaphson(fitfunction="fitfunction"),
  mxComputeOnce('fitfunction',
    c('fit','gradient','hessian','ihessian')),
  mxComputeStandardError(),
  mxComputeReportDeriv(),
  mxComputeReportExpectation()
))

testmod &lt;- mxModel(
  "GREMLtest",
  mxData(observed = dat, type="raw"),
  mxMatrix(type = "Full", nrow = 1, ncol=1, free=TRUE,
    values = 1, labels = "ve", lbound = 0.0001, name = "Ve"),
  mxMatrix("Iden",nrow=100,name="I",condenseSlots=TRUE),
  mxAlgebra(I %x% Ve,name="V"),
  ge,
  gff,
  plan
)
str(testmod)
</code></pre>

<hr>
<h2 id='MxExpectationGREML-class'>Class &quot;MxExpectationGREML&quot;</h2><span id='topic+MxExpectationGREML-class'></span><span id='topic+MxExpectationGREML'></span>

<h3>Description</h3>

<p><code>MxExpectationGREML</code> is a type of expectation class.  It contains the necessary elements for specifying a GREML model.  For more information, see <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form 
<code>mxExpectationGREML(V, yvars, Xvars, addOnes, blockByPheno, 
                        staggerZeroes, dataset.is.yX, casesToDropFromV)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>V</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> to serve as the 'V' matrix.</p>
</dd>
<dt><code>yvars</code>:</dt><dd><p>Character vector.  Each string names a column of the raw dataset, to be used as a phenotypes.</p>
</dd>
<dt><code>Xvars</code>:</dt><dd><p>A list of data column names, specifying the covariates to be used with each phenotype.</p>
</dd>
<dt><code>addOnes</code>:</dt><dd><p>Logical; pertains to data-handling at runtime.</p>
</dd>
<dt><code>blockByPheno</code>:</dt><dd><p>Logical; pertains to data-handling at runtime.</p>
</dd>
<dt><code>staggerZeroes</code>:</dt><dd><p>Logical; pertains to data-handling at runtime.</p>
</dd>
<dt><code>dataset.is.yX</code>:</dt><dd><p>Logical; pertains to data-handling at runtime.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"MxData"</code>.  Its <code>observed</code> slot will contain the phenotype vector, 'y.'</p>
</dd>
<dt><code>X</code>:</dt><dd><p>A matrix, to contain the 'X' matrix of covariates.</p>
</dd>
<dt><code>yXcolnames</code>:</dt><dd><p>Character vector; used to store the column names of 'y' and 'X.'</p>
</dd>
<dt><code>casesToDrop</code>:</dt><dd><p>Integer vector, specifying the rows and columns of the 'V' matrix to be removed at runtime.</p>
</dd>
<dt><code>b</code>:</dt><dd><p>A matrix, to contain the vector of regression coefficients calculated at runtime.</p>
</dd>
<dt><code>bcov</code>:</dt><dd><p>A matrix, to contain the sampling covariance matrix of the regression coefficients calculated at runtime.</p>
</dd>
<dt><code>numFixEff</code>:</dt><dd><p>Integer number of covariates in 'X.'</p>
</dd>
<dt><code>dims</code>:</dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>numStats</code>:</dt><dd><p>Numeric; number of observed statistics.</p>
</dd>
<dt><code>dataColumns</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.</p>
</dd>
<dt><code>.runDims</code>:</dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"MxBaseExpectation"</code>, directly.
Class <code>"MxBaseNamed"</code>, by class &quot;MxBaseExpectation&quot;, distance 2.
Class <code>"MxExpectation"</code>, by class &quot;MxBaseExpectation&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;MxExpectationGREML&quot; in the signature.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code> for creating MxExpectationGREML objects, and for more information generally concerning GREML analyses, including a complete example. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MxExpectationGREML")
</code></pre>

<hr>
<h2 id='mxExpectationHiddenMarkov'>Hidden Markov expectation</h2><span id='topic+MxExpectationHiddenMarkov-class'></span><span id='topic+mxExpectationHiddenMarkov'></span><span id='topic+print+2CMxExpectationHiddenMarkov-method'></span><span id='topic+show+2CMxExpectationHiddenMarkov-method'></span>

<h3>Description</h3>

<p>Used in conjunction with <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, this expectation
can express a mixture model (with the transition matrix omitted)
or a Hidden Markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationHiddenMarkov(components, initial="initial", transition=NULL,
		      ..., verbose=0L, scale=c('softmax', 'sum', 'none'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_components">components</code></td>
<td>
<p>A character vector of model names.</p>
</td></tr>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_initial">initial</code></td>
<td>
<p>The name of the matrix or algebra column that specifies
the initial probabilities.</p>
</td></tr>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_transition">transition</code></td>
<td>
<p>The name of the matrix or algebra that specifies
the left stochastic transition probabilities.</p>
</td></tr>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_verbose">verbose</code></td>
<td>
<p>the level of runtime diagnostics</p>
</td></tr>
<tr><td><code id="mxExpectationHiddenMarkov_+3A_scale">scale</code></td>
<td>
<p>How the probabilities are rescaled. For 'softmax',
the coefficient-wise exponential is taken and then each column is
divided by its column sum. For 'sum', each column is divided by its
column sum. For 'none', no scaling is done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial probabilities given in <code>initial</code> must sum to one.  So too must the <em>columns</em> of the transition matrix given in <code>transition</code>.  The transitions go from a column to a row, similar to how regression effects in the RAM structural equation models go from the column variable to the row variable.  This means <code>transition</code> is a left stochastic matrix.
</p>
<p>For ease of use the raw free parameters of these matrices are rescaled by OpenMx according to the <code>scale</code> argument.  When <code>scale</code> is set to &quot;softmax&quot; the softmax function is applied to the initial probabilities and the columns of the transition matrix.  The softmax function is also sometimes called multinomial logistic regression.  Softmax exponentiates each element in a vector and then divides each element by the sum of the exponentiated elements.  In equation form the softmax function is
</p>
<p style="text-align: center;"><code class="reqn"> softmax(x_i) = \frac{e^{x_i}}{\sum_{k=1}^{K} } e^{x_k} </code>
</p>

<p>When using the softmax scaling no free parameter bounds or constraints are needed.  However, for model identification, one element of the initial probabilities vector must be fixed.  If the softmax scaling is used, then the usual choice for the fixed parameter value is zero.  The regime (or latent class or mixture component) that has its initial probability set to zero becomes the comparison against which other probabilities are evaluated.  Likewise for model identification, one element in each column of the transition matrix must be fixed.  When the softmax scaling is used, the typical choice is to fix one element in each column to zero.  Generally, one row of the transition matrix is fixed to zero, or the diagonal elements of the transition matrix are fixed to zero.
</p>
<p>When <code>scale</code> is set to &quot;sum&quot; then each element of the initial probabilities and each column of the transition matrix is internally divided by its sum.  When using the sum scaling, the same model identification requirements are present.  In particular, one element of the initial probabilities must be fixed and one element in each column of the transition matrix must be fixed.  The typical value to fix these values at for sum scaling is one.  Additionally when using sum scaling, all free parameters in the initial and transition probabilities must have lower bounds of zero.  In equation form the sum scaling does the following:
</p>
<p style="text-align: center;"><code class="reqn"> sumscale(x_i) = \frac{x_i}{\sum_{k=1}^{K} } x_k </code>
</p>

<p>When <code>scale</code> is set to &quot;none&quot; then no re-scaling is done. The parameters of <code>initial</code> and <code>transition</code> are left &quot;as is&quot;.  This can be dangerous and is not recommended for novice users.  It might produce nonsensical results particularly for hidden Markov models.  However, some advanced users may find no scaling to be advantageous for certain applications (e.g., they are providing their own scaling), and thus it is provided as an option.
</p>
<p>Parameters are estimated in the given scale. To obtain the initial
column vector and left stochastic transition matrix in probability
units then examine the expectation's <code>output</code> slot with for example <code>yourModel$expectation$output</code>
</p>
<p>Definition variables can be used to assign a separate set of mixture
probabilities to each row of data.
Definition variables can be used in the initial column vector or in
the transition matrix, but not in both at the same time.
</p>
<p>Note that, when the transition matrix is omitted,
this expectation is the same as <a href="#topic+mxExpectationMixture">mxExpectationMixture</a>.
<a href="#topic+mxGenerateData">mxGenerateData</a> is not implemented for this type of expectation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

start_prob &lt;- c(.2,.4,.4)
transition_prob &lt;- matrix(c(.8, .1, .1,
			.3, .6, .1,
			.1, .3, .6), 3, 3)
noise &lt;- .5

  # simulate a trajectory
  state &lt;- sample.int(3, 1, prob=transition_prob %*% start_prob)
  trail &lt;- c(state)

  for (rep in 1:500) {
    state &lt;- sample.int(3, 1, prob=transition_prob[,state])
    trail &lt;- c(trail, state)
  }
  
  # add noise
  trailN &lt;- sapply(trail, function(v) rnorm(1, mean=v, sd=sqrt(noise)))

  classes &lt;- list()
  
  for (cl in 1:3) {
    classes[[cl]] &lt;- mxModel(paste0("cl", cl), type="RAM",
                             manifestVars=c("ob"),
                             mxPath("one", "ob", value=cl, free=FALSE),
                             mxPath("ob", arrows=2, value=noise, free=FALSE),
                             mxFitFunctionML(vector=TRUE))
  }

  m1 &lt;-  
    mxModel("hmm", classes,
            mxData(data.frame(ob=trailN), "raw"),
            mxMatrix(nrow=3, ncol=1,
                     labels=paste0('i',1:3), name="initial"),
            mxMatrix(nrow=length(classes), ncol=length(classes),
                     labels=paste0('t', 1:(length(classes) * length(classes))),
                     name="transition"),
            mxExpectationHiddenMarkov(
              components=sapply(classes, function(m) m$name),
              initial="initial",
              transition="transition", scale="softmax"),
            mxFitFunctionML())

  m1$transition$free[1:(length(classes)-1), 1:length(classes)] &lt;- TRUE

m1 &lt;- mxRun(m1)

summary(m1)

print(m1$expectation$output)
</code></pre>

<hr>
<h2 id='mxExpectationLISREL'>Create MxExpectationLISREL Object</h2><span id='topic+mxExpectationLISREL'></span><span id='topic+MxExpectationLISREL-class'></span><span id='topic+show+2CMxExpectationLISREL-method'></span><span id='topic+print+2CMxExpectationLISREL-method'></span>

<h3>Description</h3>

<p>This function creates a new MxExpectationLISREL object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationLISREL(LX=NA, LY=NA, BE=NA, GA=NA, PH=NA, PS=NA, TD=NA, TE=NA, TH=NA,
                    TX = NA, TY = NA, KA = NA, AL = NA,
                    dimnames = NA, thresholds = NA,
	 threshnames = deprecated(), verbose=0L, ...,
  expectedCovariance=NULL, expectedMean=NULL, discrete = as.character(NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationLISREL_+3A_lx">LX</code></td>
<td>
<p>An optional character string indicating the name of the 'LX' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ly">LY</code></td>
<td>
<p>An optional character string indicating the name of the 'LY' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_be">BE</code></td>
<td>
<p>An optional character string indicating the name of the 'BE' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ga">GA</code></td>
<td>
<p>An optional character string indicating the name of the 'GA' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ph">PH</code></td>
<td>
<p>An optional character string indicating the name of the 'PH' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ps">PS</code></td>
<td>
<p>An optional character string indicating the name of the 'PS' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_td">TD</code></td>
<td>
<p>An optional character string indicating the name of the 'TD' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_te">TE</code></td>
<td>
<p>An optional character string indicating the name of the 'TE' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_th">TH</code></td>
<td>
<p>An optional character string indicating the name of the 'TH' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_tx">TX</code></td>
<td>
<p>An optional character string indicating the name of the 'TX' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ty">TY</code></td>
<td>
<p>An optional character string indicating the name of the 'TY' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_ka">KA</code></td>
<td>
<p>An optional character string indicating the name of the 'KA' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_al">AL</code></td>
<td>
<p>An optional character string indicating the name of the 'AL' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector that is currently ignored</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_threshnames">threshnames</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of runtime diagnostic output.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_expectedcovariance">expectedCovariance</code></td>
<td>
<p>An optional character string indicating the
name of a matrix for the model implied covariance.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_expectedmean">expectedMean</code></td>
<td>
<p>An optional character string indicating the name
of a matrix for the model implied mean.</p>
</td></tr>
<tr><td><code id="mxExpectationLISREL_+3A_discrete">discrete</code></td>
<td>
<p>An optional character string indicating the name of the discrete matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expectation functions define the way that model expectations are calculated. The mxExpectationLISREL calculates the expected covariance and means of a given <a href="#topic+MxData">MxData</a> object given a LISREL model. This model is defined by LInear Structural RELations (LISREL; J&ouml;reskog &amp; S&ouml;rbom, 1982, 1996).  Arguments 'LX' through 'AL' must refer to <a href="#topic+MxMatrix">MxMatrix</a> objects with the associated properties of their respective matrices in the LISREL modeling approach.
</p>
<p>The full LISREL specification has 13 matrices and is sometimes called the extended LISREL model.  It is defined by the following equations.
</p>
<p style="text-align: center;"><code class="reqn">\eta = \alpha + B \eta + \Gamma \xi + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \tau_y + \Lambda_y \eta + \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">x = \tau_x + \Lambda_x \xi + \delta</code>
</p>

<p>The table below is provided as a quick reference to the numerous matrices in LISREL models.  Note that NX is the number of manifest exogenous (independent) variables, the number of Xs.  NY is the number of manifest endogenous (dependent) variables, the number of Ys.  NK is the number of latent exogenous variables, the number of Ksis or Xis.  NE is the number of latent endogenous variables, the number of etas.
</p>

<table>
<tr>
 <td style="text-align: center;">
Matrix </td><td style="text-align: left;"> Word </td><td style="text-align: center;"> Abbreviation </td><td style="text-align: center;"> Dimensions </td><td style="text-align: center;"> Expression</td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Lambda_x</code> </td><td style="text-align: left;"> Lambda x </td><td style="text-align: center;"> LX </td><td style="text-align: center;"> NX x NK </td><td style="text-align: center;"> </td><td style="text-align: left;"> Exogenous Factor Loading Matrix </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Lambda_y</code> </td><td style="text-align: left;"> Lambda y </td><td style="text-align: center;"> LY </td><td style="text-align: center;"> NY x NE </td><td style="text-align: center;"> </td><td style="text-align: left;"> Endogenous Factor Loading Matrix</td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">B</code> </td><td style="text-align: left;"> Beta </td><td style="text-align: center;"> BE </td><td style="text-align: center;"> NE x NE </td><td style="text-align: center;"> </td><td style="text-align: left;"> Regressions of Latent Endogenous Variables Predicting Endogenous Variables</td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Gamma</code> </td><td style="text-align: left;"> Gamma </td><td style="text-align: center;"> GA </td><td style="text-align: center;"> NE x NK </td><td style="text-align: center;"> </td><td style="text-align: left;"> Regressions of Latent Exogenous Variables Predicting Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Phi</code> </td><td style="text-align: left;"> Phi </td><td style="text-align: center;"> PH </td><td style="text-align: center;"> NK x NK </td><td style="text-align: center;"> cov(<code class="reqn">\xi</code>) </td><td style="text-align: left;"> Covariance Matrix of Latent Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Psi</code> </td><td style="text-align: left;"> Psi </td><td style="text-align: center;"> PS </td><td style="text-align: center;"> NE x NE </td><td style="text-align: center;"> cov(<code class="reqn">\zeta</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Latent Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\delta}</code> </td><td style="text-align: left;"> Theta delta </td><td style="text-align: center;"> TD </td><td style="text-align: center;"> NX x NX </td><td style="text-align: center;"> cov(<code class="reqn">\delta</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\epsilon}</code> </td><td style="text-align: left;"> Theta epsilon </td><td style="text-align: center;"> TE </td><td style="text-align: center;"> NY x NY </td><td style="text-align: center;"> cov(<code class="reqn">\epsilon</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\delta \epsilon}</code> </td><td style="text-align: left;"> Theta delta epsilson </td><td style="text-align: center;"> TH </td><td style="text-align: center;"> NX x NY </td><td style="text-align: center;"> cov(<code class="reqn">\delta, \epsilon</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Exogenous with Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\tau_x</code> </td><td style="text-align: left;"> tau x </td><td style="text-align: center;"> TX </td><td style="text-align: center;"> NX x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Manifest Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\tau_y</code> </td><td style="text-align: left;"> tau y </td><td style="text-align: center;"> TY </td><td style="text-align: center;"> NY x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Manifest Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa</code> </td><td style="text-align: left;"> kappa </td><td style="text-align: center;"> KA </td><td style="text-align: center;"> NK x 1 </td><td style="text-align: center;"> mean(<code class="reqn">\xi</code>) </td><td style="text-align: left;"> Means of Latent Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\alpha</code> </td><td style="text-align: left;"> alpha </td><td style="text-align: center;"> AL </td><td style="text-align: center;"> NE x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Latent Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>From the extended LISREL model, several submodels can be defined.  Subtypes of the LISREL model are defined by setting some of the arguments of the LISREL expectation function to NA.  Note that because the default values of each LISREL matrix is NA, setting a matrix to NA can be accomplished by simply not giving it any other value.
</p>
<p>The first submodel is the LISREL model without means.
</p>
<p style="text-align: center;"><code class="reqn">\eta = B \eta + \Gamma \xi + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \Lambda_y \eta + \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">x = \Lambda_x \xi + \delta</code>
</p>

<p>The LISREL model without means requires 9 matrices: LX, LY, BE, GA, PH, PS, TD, TE, and TH.  Hence this LISREL model has TX, TY, KA, and AL as NA.  This can be accomplished be leaving these matrices at their default values.
</p>
<p>The TX, TY, KA, and AL matrices must be specified if either the mxData type is &ldquo;cov&rdquo; or &ldquo;cor&rdquo; and a means vector is provided, or if the mxData type is &ldquo;raw&rdquo;.  Otherwise the TX, TY, KA, and AL matrices are ignored and the model without means is estimated.
</p>
<p>A second submodel involves only endogenous variables.
</p>
<p style="text-align: center;"><code class="reqn">\eta = B \eta + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \Lambda_y \eta + \epsilon</code>
</p>

<p>The endogenous-only LISREL model requires 4 matrices: LY, BE, PS, and TE.  The LX, GA, PH, TD, and TH must be NA in this case.  However, means can also be specified, allowing TY and AL if the data are raw or if observed means are provided.
</p>
<p>Another submodel involves only exogenous variables.
</p>
<p style="text-align: center;"><code class="reqn">x = \Lambda_x \xi + \delta</code>
</p>

<p>The exogenous-model model requires 3 matrices: LX, PH, and TD.  The LY, BE, GA, PS, TE, and TH matrices must be NA.  However, means can also be specified, allowing TX and KA if the data are raw or if observed means are provided.
</p>
<p>The model that is run depends on the matrices that are not NA.  If all 9 matrices are not NA, then the full model is run.  If only the 4 endogenous matrices are not NA, then the endogenous-only model is run.  If only the 3 exogenous matrices are not NA, then the exogenous-only model is run.  If some endogenous and exogenous matrices are not NA, but not all of them, then appropriate errors are thrown.  Means are included in the model whenever their matrices are provided.
</p>

<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxExpectationLISREL will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>Like the <a href="#topic+mxExpectationRAM">mxExpectationRAM</a>, the mxExpectationLISREL evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxExpectationLISREL function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxExpectationLISREL requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'cov', 'cor', or 'raw'.
</p>
<p>To evaluate, place mxExpectationLISREL objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a new MxExpectationLISREL object. One and only one MxExpectationLISREL object can be included with models using one and only one fit function object (e.g., MxFitFunctionML) and with referenced <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxData">MxData</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>


<h3>References</h3>

<p>J&ouml;reskog, K. G. &amp; S&ouml;rbom, D. (1996). LISREL 8: User's Reference Guide. Lincolnwood, IL: Scientific Software International.
</p>
<p>J&ouml;reskog, K. G. &amp; S&ouml;rbom, D. (1982). Recent developments in structural equation modeling. <em>Journal of Marketing Research, 19,</em> 404-416.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code>demo("LISRELJointFactorModel")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create and fit a model using mxExpectationLISREL, and mxFitFunctionML

library(OpenMx)

vNames &lt;- paste("v",as.character(1:6),sep="")
dimList &lt;- list(vNames, vNames)
covData &lt;- matrix(
  c(0.9223099, 0.1862938, 0.4374359, 0.8959973, 0.9928430, 0.5320662,
    0.1862938, 0.2889364, 0.3927790, 0.3321639, 0.3371594, 0.4476898,
    0.4374359, 0.3927790, 1.0069552, 0.6918755, 0.7482155, 0.9013952,
    0.8959973, 0.3321639, 0.6918755, 1.8059956, 1.6142005, 0.8040448,
    0.9928430, 0.3371594, 0.7482155, 1.6142005, 1.9223567, 0.8777786,
    0.5320662, 0.4476898, 0.9013952, 0.8040448, 0.8777786, 1.3997558
    ), nrow=6, ncol=6, byrow=TRUE, dimnames=dimList)

# Create LISREL matrices

mLX &lt;- mxMatrix("Full", values=c(.5, .6, .8, rep(0, 6), .4, .7, .5),
          name="LX", nrow=6, ncol=2,
          free=c(TRUE,TRUE,TRUE,rep(FALSE, 6),TRUE,TRUE,TRUE),
          dimnames=list(vNames, c("x1","x2")))
mTD &lt;- mxMatrix("Diag", values=c(rep(.2, 6)), 
          name="TD", nrow=6, ncol=6, free=TRUE,
          dimnames=dimList)
mPH &lt;- mxMatrix("Symm", values=c(1, .3, 1), 
          name="PH", nrow=2, ncol=2, free=c(FALSE, TRUE, FALSE),
          dimnames=list(c("x1","x2"),c("x1","x2")))

# Create a LISREL expectation with LX, TD, and PH matrix names

expFunction &lt;- mxExpectationLISREL(LX="LX", TD="TD", PH="PH")

# Create fit function and data

tmpData &lt;- mxData(observed=covData, type="cov", numObs=100)
fitFunction &lt;- mxFitFunctionML()

# Create the model, fit it, and print a summary.

tmpModel &lt;- mxModel(model="exampleModel",
                    mLX, mTD, mPH, expFunction, fitFunction, tmpData)
tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)


#--------------------------------------
# Fit factor model with means

require(OpenMx)

data(demoOneFactor)
nvar &lt;- ncol(demoOneFactor)
varnames &lt;- colnames(demoOneFactor)

factorMeans &lt;- mxMatrix("Zero", 1, 1, name="Kappa",
                        dimnames=list("F1", NA))
xIntercepts &lt;- mxMatrix("Full", nvar, 1, free=TRUE, name="TauX",
                        dimnames=list(varnames, NA))
factorLoadings &lt;- mxMatrix("Full", nvar, 1, TRUE, .6, name="LambdaX",
                           labels=paste("lambda", 1:nvar, sep=""),
                           dimnames=list(varnames, "F1"))
factorCovariance &lt;- mxMatrix("Diag", 1, 1, FALSE, 1, name="Phi")
xResidualVariance &lt;- mxMatrix("Diag", nvar, nvar, TRUE, .2, name="ThetaDelta",
                              labels=paste("theta", 1:nvar, sep=""))

liModel &lt;- mxModel(model="LISREL Factor Model",
	factorMeans, xIntercepts, factorLoadings,
	factorCovariance, xResidualVariance,
	mxExpectationLISREL(LX="LambdaX", PH="Phi",
		TD="ThetaDelta", TX="TauX", KA="Kappa"),
	mxFitFunctionML(),
	mxData(cov(demoOneFactor), "cov",
		means=colMeans(demoOneFactor), numObs=nrow(demoOneFactor))
)

liRun &lt;- mxRun(liModel)

summary(liRun)
</code></pre>

<hr>
<h2 id='mxExpectationMixture'>Mixture expectation</h2><span id='topic+MxExpectationMixture-class'></span><span id='topic+mxExpectationMixture'></span><span id='topic+print+2CMxExpectationMixture-method'></span><span id='topic+show+2CMxExpectationMixture-method'></span>

<h3>Description</h3>

<p>Used in conjunction with <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, this expectation
can express a mixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationMixture(components, weights="weights",
		      ..., verbose=0L, scale=c('softmax', 'sum', 'none'))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationMixture_+3A_components">components</code></td>
<td>
<p>A character vector of model names.</p>
</td></tr>
<tr><td><code id="mxExpectationMixture_+3A_weights">weights</code></td>
<td>
<p>The name of the matrix or algebra column that specifies
the component weights.</p>
</td></tr>
<tr><td><code id="mxExpectationMixture_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationMixture_+3A_verbose">verbose</code></td>
<td>
<p>the level of runtime diagnostics</p>
</td></tr>
<tr><td><code id="mxExpectationMixture_+3A_scale">scale</code></td>
<td>
<p>How the probabilities are rescaled. For 'softmax',
the coefficient-wise exponential is taken and then each column is
divided by its column sum. For 'sum', each column is divided by its
column sum. For 'none', no scaling is done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixture probabilities given in <code>weights</code> must sum to one.  As such for <code class="reqn">K</code> mixture components, only <code class="reqn">K-1</code> of the elements of <code>weights</code> can be estimated. The mixture probabilities in <code>weights</code> should be a column vector (i.e., a <code class="reqn">K</code> by 1 matrix, or algebra with a <code class="reqn">K</code> by 1 result).
</p>
<p>For ease of use the raw free parameters of weights can be rescaled by OpenMx according to the <code>scale</code> argument.  When <code>scale</code> is set to &quot;softmax&quot; the softmax function is applied to the weights.  The softmax function is also sometimes called multinomial logistic regression.  Softmax exponentiates each element in a vector and then divides each element by the sum of the exponentiated elements.  In equation form the softmax function is
</p>
<p style="text-align: center;"><code class="reqn"> softmax(x_i) = \frac{e^{x_i}}{\sum_{k=1}^{K} } e^{x_k} </code>
</p>

<p>When using the softmax scaling no free parameter bounds or constraints are needed.  However, for model identification, one element of the weights vector must be fixed.  If the softmax scaling is used, then the usual choice for the fixed parameter value is zero.  The latent class or mixture component that has its raw weight set to zero becomes the comparison against which other probabilities are evaluated.
</p>
<p>When <code>scale</code> is set to &quot;sum&quot; then each element of the weights matrix is internally divided by its sum.  When using the sum scaling, the same model identification requirements are present.  In particular, one element of the weights must be fixed.  The typical value to fix this value at for sum scaling is one.  Additionally when using sum scaling, all free parameters in the weights must have lower bounds of zero.  In equation form the sum scaling does the following:
</p>
<p style="text-align: center;"><code class="reqn"> sumscale(x_i) = \frac{x_i}{\sum_{k=1}^{K} } x_k </code>
</p>

<p>When <code>scale</code> is set to &quot;none&quot; then no re-scaling is done. The weights are left &quot;as is&quot;.  This can be dangerous and is not recommended for novice users.  However, some advanced users may find no scaling to be advantageous for certain applications (e.g., they are providing their own scaling), and thus it is provided as an option.
</p>
<p>Parameters are estimated in the given scale. To obtain the weights
column vector, examine the expectation's <code>output</code> slot with for example <code>yourModel$expectation$output</code>
</p>
<p>An extension of this expectation to a Hidden Markov model
is available with <a href="#topic+mxExpectationHiddenMarkov">mxExpectationHiddenMarkov</a>.
<a href="#topic+mxGenerateData">mxGenerateData</a> is not implemented for this type of expectation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

set.seed(1)

trail &lt;- c(rep(1,480), rep(2,520))
trailN &lt;- sapply(trail, function(v) rnorm(1, mean=v))

classes &lt;- list()

for (cl in 1:2) {
  classes[[cl]] &lt;- mxModel(paste0("class", cl), type="RAM",
                           manifestVars=c("ob"),
                           mxPath("one", "ob", value=cl, free=FALSE),
                           mxPath("ob", arrows=2, value=1, free=FALSE),
                           mxFitFunctionML(vector=TRUE))
}

mix1 &lt;- mxModel(
  "mix1", classes,
  mxData(data.frame(ob=trailN), "raw"),
  mxMatrix(values=1, nrow=1, ncol=2, free=c(FALSE,TRUE), name="weights"),
  mxExpectationMixture(paste0("class",1:2), scale="softmax"),
  mxFitFunctionML())

mix1Fit &lt;- mxRun(mix1)
</code></pre>

<hr>
<h2 id='mxExpectationNormal'>Create MxExpectationNormal Object</h2><span id='topic+mxExpectationNormal'></span><span id='topic+MxExpectationNormal-class'></span><span id='topic+show+2CMxExpectationNormal-method'></span><span id='topic+print+2CMxExpectationNormal-method'></span>

<h3>Description</h3>

<p>This function creates an MxExpectationNormal object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationNormal(covariance, means=NA, dimnames = NA, thresholds = NA,
                    threshnames = dimnames, ...,
  discrete = as.character(NA), discreteSpec=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationNormal_+3A_covariance">covariance</code></td>
<td>
<p>A character string indicating the name of the expected covariance algebra.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_means">means</code></td>
<td>
<p>A character string indicating the name of the expected means algebra.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the dimnames of the covariance and means algebras.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_threshnames">threshnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_discrete">discrete</code></td>
<td>
<p>An optional character string indicating the name of the discrete matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationNormal_+3A_discretespec">discreteSpec</code></td>
<td>
<p>An optional matrix containing maximum counts and
model IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expectation functions define the way that model expectations are calculated. The mxExpectationNormal function uses the algebra defined by the 'covariance' and 'means' arguments to define the expected covariance and means under the assumption of multivariate normality. The 'covariance' argument takes an <a href="#topic+MxAlgebra">MxAlgebra</a> object, which defines the expected covariance of an associated <a href="#topic+MxData">MxData</a> object. The 'means' argument takes an <a href="#topic+MxAlgebra">MxAlgebra</a> object, which defines the expected means of an associated <a href="#topic+MxData">MxData</a> object. The 'dimnames' arguments takes an optional character vector.  If this argument is not a single NA, then this vector is used to assign the dimnames of the means vector as well as the row and columns dimnames of the covariance matrix.
</p>
<p>thresholds: The name of the thresholds matrix. When needed (for modelling ordinal data), this matrix should be created using  <a href="#topic+mxMatrix">mxMatrix</a>(). The thresholds matrix must have as many columns as there are ordinal variables in the model, and number of rows equal to one fewer than the maximum number of levels found in the ordinal variables. The starting values  of this matrix must also be set to reasonable values. Fill each column with a set of ordered start thresholds, one for each level of this column's factor levels minus 1. These thresholds may be free if you wish them to be estimated, or fixed. The unused rows in each column, if any, can be set to any value including NA.
</p>
<p>threshnames: A character vector consisting of the variables in the thresholds matrix, i.e., the names of ordinal variables in a model. This is necessary for OpenMx to map the thresholds matrix columns onto the variables in your data. If you set the <a href="base.html#topic+dimnames">dimnames</a> of the columns in the thresholds matrix then threshnames is not needed.
</p>
<p>Usage Notes:
dimnames must be supplied where the matrices referenced by the covariance and means algebras are not themselves labeled. Failure to do so leads to an error noting that the covariance or means matrix associated with the FIML objective does not contain dimnames.
</p>
<p>mxExpectationNormal evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxExpectationNormal function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. When the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object is equal to 'raw', missing values are permitted in the associated <a href="#topic+MxData">MxData</a> object.
</p>
<p>To evaluate, place an mxExpectationNormal object, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, optional <a href="#topic+MxBounds">MxBounds</a> or <a href="#topic+MxConstraint">MxConstraint</a> objects, and an mxFitFunction such as <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>The results of the optimization can be reported using the <a href="base.html#topic+summary">summary</a> function, or accessed directly in the 'output' slot of the resulting model (i.e., modelName$output). Components of the output may be referenced using the <a href="base.html#topic+Extract">Extract</a> functionality.
</p>


<h3>Value</h3>

<p>Returns an MxExpectationNormal object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra,
#  mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

M &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=c(0,0),
              free=c(TRUE,TRUE), labels=c("Mx", "My"), name = "M")
S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1),
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"),
              name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0),
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA),
              name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Define the expectation

expCov &lt;- mxAlgebra(solve(I-A) %*% S %*% t(solve(I-A)), name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", means="M",
	dimnames=tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML()

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", M, S, A, I,
                    expCov, expFunction, fitFunction,
                    mxData(observed=tmpFrame, type="raw"))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)


</code></pre>

<hr>
<h2 id='mxExpectationRAM'>Create an MxExpectationRAM Object</h2><span id='topic+mxExpectationRAM'></span><span id='topic+MxExpectationRAM-class'></span><span id='topic+show+2CMxExpectationRAM-method'></span><span id='topic+print+2CMxExpectationRAM-method'></span>

<h3>Description</h3>

<p>This function creates an MxExpectationRAM object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationRAM(A="A", S="S", F="F", M = NA, dimnames = NA, thresholds = NA,
                 threshnames = dimnames, ..., between=NULL, verbose=0L,
  .useSparse=NA, expectedCovariance=NULL, expectedMean=NULL,
  discrete = as.character(NA), selectionVector = as.character(NA),
  expectedFullCovariance=NULL, expectedFullMean=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationRAM_+3A_a">A</code></td>
<td>
<p>A character string indicating the name of the 'A' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_s">S</code></td>
<td>
<p>A character string indicating the name of the 'S' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_f">F</code></td>
<td>
<p>A character string indicating the name of the 'F' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_m">M</code></td>
<td>
<p>An optional character string indicating the name of the 'M' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the 'F' and 'M' matrices.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_threshnames">threshnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_between">between</code></td>
<td>
<p>A character vector of matrices that specify cross model relationships.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_verbose">verbose</code></td>
<td>
<p>integer. Level of runtime diagnostic output.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_.usesparse">.useSparse</code></td>
<td>
<p>logical. Whether to use sparse matrices to compute
the expectation. The default <code>NA</code> allows the backend to decide.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_expectedcovariance">expectedCovariance</code></td>
<td>
<p>An optional character string indicating the
name of a matrix for the observed model implied covariance.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_expectedmean">expectedMean</code></td>
<td>
<p>An optional character string indicating the name
of a matrix for the observed model implied mean.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_discrete">discrete</code></td>
<td>
<p>An optional character string indicating the name of
the discrete matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_selectionvector">selectionVector</code></td>
<td>
<p>An optional character string indicating the name of
the Pearson selection vector matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_expectedfullcovariance">expectedFullCovariance</code></td>
<td>
<p>An optional character string indicating the
name of a matrix for the full model implied covariance. Both latent
and observed variables are included.</p>
</td></tr>
<tr><td><code id="mxExpectationRAM_+3A_expectedfullmean">expectedFullMean</code></td>
<td>
<p>An optional character string indicating the name
of a matrix for the full model implied mean. Both latent
and observed variables are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expectation functions define the way that model expectations are calculated. The mxExpectationRAM calculates the expected covariance and means of a given <a href="#topic+MxData">MxData</a> object given a RAM model. This model is defined by reticular action modeling (McArdle and McDonald, 1984). The 'A', 'S', and 'F' arguments refer to <a href="#topic+MxMatrix">MxMatrix</a> objects with the associated properties of the A, S, and F matrices in the RAM modeling approach. <em>Note for advanced users</em>: these matrices may be replaced by mxAlgebras. Such a model will lack properties (labels, free, bounds) that other functions may be expecting.
</p>
<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxExpectationRAM will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>The 'A' argument refers to the A or asymmetric matrix in the RAM approach. This matrix consists of all of the asymmetric paths (one-headed arrows) in the model. A free parameter in any row and column describes a regression of the variable represented by that row regressed on the variable represented in that column.
</p>
<p>The 'S' argument refers to the S or symmetric matrix in the RAM approach, and as such must be square. This matrix consists of all of the symmetric paths (two-headed arrows) in the model. A free parameter in any row and column describes a covariance between the variable represented by that row and the variable represented by that column. Variances are covariances between any variable at itself, which occur on the diagonal of the specified matrix.
</p>
<p>The 'F' argument refers to the F or filter matrix in the RAM approach. If no latent variables are included in the model (i.e., the A and S matrices are of both of the same dimension as the data matrix), then the 'F' should refer to an identity matrix. If latent variables are included (i.e., the A and S matrices are not of the same dimension as the data matrix), then the 'F' argument should consist of a horizontal adhesion of an identity matrix and a matrix of zeros.
</p>
<p>The 'M' argument refers to the M or means matrix in the RAM approach.  It is a 1 x n matrix, where n is the number of manifest variables + the number of latent variables. The M matrix must be specified if either the mxData type is &ldquo;cov&rdquo; or &ldquo;cor&rdquo; and a means vector is provided, or if the mxData type is &ldquo;raw&rdquo;.  Otherwise the M matrix is ignored.
</p>
<p>The 'dimnames' arguments takes an optional character vector.  If this argument is not a single NA, then this vector be assigned to be the column names of the 'F' matrix and optionally to the 'M' matrix, if the 'M' matrix exists.
</p>
<p>mxExpectationRAM evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxExpectationRAM function, but must be included in the <a href="#topic+MxModel">MxModel</a> object.
</p>
<p>To evaluate an mxExpectationRAM object, place it, the <a href="#topic+mxData">mxData</a>
object which the expected covariance approximates, any referenced
<a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional
<a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a>
object and evaluate it using <a href="#topic+mxRun">mxRun</a>. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a new MxExpectationRAM object. mxExpectationRAM objects should be included in a model, along with referenced <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxData">MxData</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>


<h3>References</h3>

<p>McArdle, J. J. and MacDonald, R. P. (1984). Some algebraic properties of the Reticular Action Model for moment structures. <em>British Journal of Mathematical and Statistical Psychology, 37,</em> 234-251.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra,
#  mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

matrixS &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1),
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"),
              name = "S")
matrixA &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0),
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA),
              name = "A")
matrixF &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="F")
matrixM &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=c(0,0),
              free=c(TRUE,TRUE), labels=c("Mx", "My"), name = "M")

# Define the expectation

expFunction &lt;- mxExpectationRAM(M="M", dimnames = tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML()

# Define the model

tmpModel &lt;- mxModel(model="exampleRAMModel",
                    matrixA, matrixS, matrixF, matrixM,
                    expFunction, fitFunction,
                    mxData(observed=tmpFrame, type="raw"))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)
</code></pre>

<hr>
<h2 id='mxExpectationStateSpace'>Create an MxExpectationStateSpace Object</h2><span id='topic+mxExpectationStateSpace'></span><span id='topic+MxExpectationStateSpace-class'></span><span id='topic+show+2CMxExpectationStateSpace-method'></span><span id='topic+print+2CMxExpectationStateSpace-method'></span>

<h3>Description</h3>

<p>This function creates a new MxExpectationStateSpace object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationStateSpace(A, B, C, D, Q, R, x0, P0, u,
                        dimnames = NA, thresholds = deprecated(),
                        threshnames = deprecated(),
                        ..., t = NA, scores=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationStateSpace_+3A_a">A</code></td>
<td>
<p>A character string indicating the name of the 'A' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_b">B</code></td>
<td>
<p>A character string indicating the name of the 'B' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_c">C</code></td>
<td>
<p>A character string indicating the name of the 'C' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_d">D</code></td>
<td>
<p>A character string indicating the name of the 'D' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_q">Q</code></td>
<td>
<p>A character string indicating the name of the 'Q' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_r">R</code></td>
<td>
<p>A character string indicating the name of the 'R' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_x0">x0</code></td>
<td>
<p>A character string indicating the name of the 'x0' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_p0">P0</code></td>
<td>
<p>A character string indicating the name of the 'P0' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_u">u</code></td>
<td>
<p>A character string indicating the name of the 'u' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the row names of the 'C' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_thresholds">thresholds</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_threshnames">threshnames</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_...">...</code></td>
<td>
<p>Unused.  Requires further arguments to be named.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_t">t</code></td>
<td>
<p>Not to be used</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpace_+3A_scores">scores</code></td>
<td>
<p>Not to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This page presents details for both the <code>mxExpectationStateSpace</code> function and for state space modeling generally; however, for much more information on state space modeling see the paper by Hunter (2018) listed under references.  Authors using state space modeling in OpenMx should cite Hunter (2018).
</p>
<p>Expectation functions define the way that model expectations are calculated. When used in conjunction with the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, the mxExpectationStateSpace uses maximum likelihood prediction error decomposition (PED) to obtain estimates of free parameters in a model of the raw <a href="#topic+MxData">MxData</a> object. State space expectations treat the raw data as a multivariate time series of equally spaced times with each row corresponding to a single occasion.  This is not a model of the block Toeplitz lagged autocovariance matrix.  State space expectations implement a classical Kalman filter to produce expectations.
</p>
<p>The hybrid Kalman filter (combination of classical Kalman and Kalman-Bucy filters) for continuous latent time with discrete observations is implemented and is available as <a href="#topic+mxExpectationStateSpaceContinuousTime">mxExpectationStateSpaceContinuousTime</a>.  The following alternative filters are not yet implemented: square root Kalman filter (in Cholesky or singular value decomposition form), extended Kalman filter for linear approximations to nonlinear state space models, unscented Kalman filter for highly nonlinear state space models, and Rauch-Tung-Striebel smoother for updating forecast state estimates after a complete forward pass through the data has been made.
</p>
<p>Missing data handling is implemented in the same fashion as full information maximum likelihood for partially missing rows of data.  Additionally, completely missing rows of data are handled by only using the prediction step from the Kalman filter and omitting the update step.
</p>
<p>This model uses notation for the model matrices commonly found in engineering and control theory.
</p>
<p>The 'A', 'B', 'C', 'D', 'Q', 'R', 'x0', and 'P0' arguments must be the names of <a href="#topic+MxMatrix">MxMatrix</a> or <a href="#topic+MxAlgebra">MxAlgebra</a>objects with the associated properties of the A, B, C, D, Q, R, x0, and P0 matrices in the state space modeling approach.
</p>
<p>The state space expectation is defined by the following model equations.
</p>
<p style="text-align: center;"><code class="reqn">x_t = A x_{t-1} + B u_t + q_t</code>
</p>

<p style="text-align: center;"><code class="reqn">y_t = C x_t + D u_t + r_t</code>
</p>

<p>with <code class="reqn">q_t</code> and <code class="reqn">r_t</code> both independently and identically distributed random Gaussian (normal) variables with mean zero and covariance matrices <code class="reqn">Q</code> and <code class="reqn">R</code>, respectively.
</p>
<p>The first equation is called the state equation.  It describes how the latent states change over time.  Also, the state equation in state space modeling is directly analogous to the structural model in LISREL structural equation modeling.
</p>
<p>The second equation is called the output equation.  It describes how the latent states relate to the observed states at a single point in time.  The output equation shows how the observed output is produced by the latent states.  Also, the output equation in state space modeling is directly analogous to the measurement model in LISREL structural equation modeling.
</p>
<p>Note that the covariates, <code class="reqn">u</code>, have &quot;instantaneous&quot; effects on both the state and output equations.  If lagged effects are desired, then the user must create a lagged covariate by shifting their observed variable to the desired lag.
</p>
<p>The state and output equations, together with some minimal assumptions and the Kalman filter, imply a new expected covariance matrix and means vector for every row of data.  The expected covariance matrix of row <code class="reqn">t</code> is
</p>
<p style="text-align: center;"><code class="reqn">S_{t} = C ( A P_{t-1} A^{\sf T} + Q ) C^{\sf T} + R</code>
</p>

<p>The expected means vector of row <code class="reqn">t</code> is
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_{t} = C x_{t} + D u_{t}</code>
</p>

<p>The 'dimnames' arguments takes an optional character vector.  

</p>
<p>The 'A' argument refers to the <code class="reqn">A</code> matrix in the State Space approach. This matrix consists of time regressive coefficients from the latent variable in column <code class="reqn">j</code> at time <code class="reqn">t-1</code> to the latent variable in row <code class="reqn">i</code> at time <code class="reqn">t</code>.  Entries in the diagonal are autoregressive coefficients.  Entries in the off-diagonal are cross-lagged regressive coefficients.  If the <code class="reqn">A</code> and <code class="reqn">B</code> matrices are zero matrices, then the state space model reduces to a factor analysis.  The <code class="reqn">A</code> matrix is sometimes called the state-transition model.
</p>
<p>The 'B' argument refers to the <code class="reqn">B</code> matrix in the State Space approach. This matrix consists of regressive coefficients from the input (manifest covariate) variable <code class="reqn">j</code> at time <code class="reqn">t</code> to the latent variable in row <code class="reqn">i</code> at time <code class="reqn">t</code>.  Note that the covariate effect is contemporaneous: the covariate at time <code class="reqn">t</code> has influence on the latent state also at time <code class="reqn">t</code>.  A lagged effect can be created by lagged the observed variable.  The <code class="reqn">B</code> matrix is sometimes called the control-input model.
</p>
<p>The 'C' argument refers to the <code class="reqn">C</code> matrix in the State Space approach. This matrix consists of contemporaneous regression coefficients from the latent variable in column <code class="reqn">j</code> to the observed variable in row <code class="reqn">i</code>.  This matrix is directly analogous to the factor loadings matrix in LISREL and Mplus models.  The <code class="reqn">C</code> matrix is sometimes called the observation model.
</p>
<p>The 'D' argument refers to the <code class="reqn">D</code> matrix in the State Space approach. This matrix consists of contemporaneous regressive coefficients from the input (manifest covariate) variable <code class="reqn">j</code> to the observed variable in row <code class="reqn">i</code>. The <code class="reqn">D</code> matrix is sometimes called the feedthrough or feedforward matrix.
</p>
<p>The 'Q' argument refers to the <code class="reqn">Q</code> matrix in the State Space approach. This matrix consists of residual covariances among the latent variables.  This matrix must be symmetric.  As a special case, it is often diagonal. The <code class="reqn">Q</code> matrix is the covariance of the process noise.  Just as in factor analysis and general structural equation modeling, the scale of the latent variables is usually set by fixing some factor loadings in the <code class="reqn">C</code> matrix, or fixing some factor variances in the <code class="reqn">Q</code> matrix.
</p>
<p>The 'R' argument refers to the <code class="reqn">R</code> matrix in the State Space approach. This matrix consists of residual covariances among the observed (manifest) variables. This matrix must be symmetric  As a special case, it is often diagonal.  The <code class="reqn">R</code> matrix is the covariance of the observation noise.
</p>
<p>The 'x0' argument refers to the <code class="reqn">x_0</code> matrix in the State Space approach. This matrix consists of the column vector of the initial values for the latent variables. The state space expectation uses the <code class="reqn">x_0</code> matrix as the starting point to recursively estimate the latent variables' values at each time.  These starting values can be difficult to pick, however, for sufficiently long time series they often do not greatly impact the estimation.
</p>
<p>The 'P0' argument refers to the <code class="reqn">P_0</code> matrix in the State Space approach. This matrix consists of the initial values of the covariances of the error in the initial latent variable estimates given in <code class="reqn">x_0</code>. That is, the <code class="reqn">P_0</code> matrix gives the covariance of <code class="reqn">x_0 - xtrue_0</code> where <code class="reqn">xtrue_0</code> is the vector of true initial values.  <code class="reqn">P_0</code> is a measure of the accuracy of the initial latent state estimates. The Kalman filter uses this initial covariance to recursively generated a new covariance for each time point based on the previous time point.  The Kalman filter updates this covariance so that it is as small as possible (minimum trace). Similar to the <code class="reqn">x_0</code> matrix, these starting values are often difficult to choose.
</p>
<p>The 'u' argument refers to the <code class="reqn">u</code> matrix in the State Space approach. This matrix consists of the inputs or manifest covariates of the state space expectation.  The <code class="reqn">u</code> matrix must be a column vector with the same number of rows as the <code class="reqn">B</code> and <code class="reqn">D</code> matrices have columns.  If no inputs are desired, <code class="reqn">u</code> can be a zero matrix.  If time-varying inputs are desired, then they should be included as columns in the <a href="#topic+MxData">MxData</a> object and referred to in the labels of the <code class="reqn">u</code> matrix as definition variables.  There is an example of this below.
</p>
<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxExpectationStateSpace will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>mxExpectationStateSpace evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxExpectationStateSpace function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxExpectationStateSpace requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'raw'.  Neighboring rows of the <a href="#topic+MxData">MxData</a> object are treated as adjacent, equidistant time points increasing from the first to the last row.
</p>
<p>To evaluate, place mxExpectationStateSpace objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a new MxExpectationStateSpace object. mxExpectationStateSpace objects should be included with models with referenced <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxData">MxData</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>


<h3>References</h3>

<p>K.J. &Aring;str&ouml;m and R.M. Murray  (2010).  <em> Feedback Systems: An Introduction for Scientists and Engineers</em>. Princeton University Press.
</p>
<p>J. Durbin and S.J. Koopman.  (2001).  <em>Time Series Analysis by State Space Methods</em>. Oxford University Press.
</p>
<p>Hunter, M.D.  (2018).  State Space Modeling in an Open Source, Modular, Structural Equation Modeling Environment.  <em>Structural Equation Modeling: A Multidisciplinary Journal, 25(2)</em>, 307-324.  DOI: 10.1080/10705511.2017.1369354
</p>
<p>R.E. Kalman  (1960).  A New Approach to Linear Filtering and Prediction Problems.  <em>Basic Engineering, 82</em>, 35-45.
</p>
<p>G. Petris  (2010).  An R Package for Dynamic Linear Models.  <em>Journal of Statistical Software, 36</em>, 1-16.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxExpectationStateSpaceContinuousTime">mxExpectationStateSpaceContinuousTime</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Create and fit a model using mxMatrix, mxExpectationStateSpace, and mxFitFunctionML
require(OpenMx)
data(demoOneFactor)
nvar &lt;- ncol(demoOneFactor)
varnames &lt;- colnames(demoOneFactor)
ssModel &lt;- mxModel(model="State Space Manual Example",
    mxMatrix("Full", 1, 1, TRUE, .3, name="A"),
    mxMatrix("Zero", 1, 1, name="B"),
    mxMatrix("Full", nvar, 1, TRUE, .6, name="C", dimnames=list(varnames, "F1")),
    mxMatrix("Zero", nvar, 1, name="D"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="Q"),
    mxMatrix("Diag", nvar, nvar, TRUE, .2, name="R"),
    mxMatrix("Zero", 1, 1, name="x0"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="P0"),
    mxMatrix("Zero", 1, 1, name="u"),
    mxData(observed=demoOneFactor[1:100,], type="raw"),#fewer rows = fast
    mxExpectationStateSpace("A", "B", "C", "D", "Q", "R", "x0", "P0", "u"),
    mxFitFunctionML()
)
ssRun &lt;- mxRun(ssModel)
summary(ssRun)
# Note the freely estimated Autoregressive parameter (A matrix)
#  is near zero as it should be for the independent rows of data
#  from the factor model.

# Create and fit a model with INPUTS using mxMatrix, mxExpectationStateSpace, and mxFitFunctionML
require(OpenMx)
data(demoOneFactor)
nvar &lt;- ncol(demoOneFactor)
varnames &lt;- colnames(demoOneFactor)
#demoOneFactorInputs &lt;- cbind(demoOneFactor, V1=rep(1, nrow(demoOneFactor)))
demoOneFactorInputs &lt;- cbind(demoOneFactor, V1=rnorm(nrow(demoOneFactor)))
ssModel &lt;- mxModel(model="State Space Inputs Manual Example",
    mxMatrix("Full", 1, 1, TRUE, .3, name="A"),
    mxMatrix("Full", 1, 1, TRUE, values=1, name="B"),
    mxMatrix("Full", nvar, 1, TRUE, .6, name="C", dimnames=list(varnames, "F1")),
    mxMatrix("Zero", nvar, 1, name="D"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="Q"),
    mxMatrix("Diag", nvar, nvar, TRUE, .2, name="R"),
    mxMatrix("Zero", 1, 1, name="x0"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="P0"),
    mxMatrix("Full", 1, 1, FALSE, labels="data.V1", name="u"),
    mxData(observed=demoOneFactorInputs[1:100,], type="raw"),#fewer rows = fast
    mxExpectationStateSpace("A", "B", "C", "D", "Q", "R", "x0", "P0", u="u"),
    mxFitFunctionML()
)
ssRun &lt;- mxRun(ssModel)
summary(ssRun)
# Note the freely estimated Autoregressive parameter (A matrix)
#  and the freely estimated Control-Input parameter (B matrix)
#  are both near zero as they should be for the independent rows of data
#  from the factor model that does not have inputs, covariates,
#  or exogenous variables.



</code></pre>

<hr>
<h2 id='mxExpectationStateSpaceContinuousTime'>Create an MxExpectationStateSpace Object</h2><span id='topic+mxExpectationStateSpaceContinuousTime'></span><span id='topic+mxExpectationSSCT'></span>

<h3>Description</h3>

<p>This function creates a new MxExpectationStateSpace object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxExpectationStateSpaceContinuousTime(A, B, C, D, Q, R, x0, P0, u, t = NA,
                        dimnames = NA, thresholds = deprecated(),
      threshnames = deprecated(),  ..., scores=FALSE)
mxExpectationSSCT(A, B, C, D, Q, R, x0, P0, u, t = NA,
                        dimnames = NA, thresholds = deprecated(),
      threshnames = deprecated(),
                        ..., scores=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_a">A</code></td>
<td>
<p>A character string indicating the name of the 'A' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_b">B</code></td>
<td>
<p>A character string indicating the name of the 'B' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_c">C</code></td>
<td>
<p>A character string indicating the name of the 'C' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_d">D</code></td>
<td>
<p>A character string indicating the name of the 'D' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_q">Q</code></td>
<td>
<p>A character string indicating the name of the 'Q' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_r">R</code></td>
<td>
<p>A character string indicating the name of the 'R' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_x0">x0</code></td>
<td>
<p>A character string indicating the name of the 'x0' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_p0">P0</code></td>
<td>
<p>A character string indicating the name of the 'P0' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_u">u</code></td>
<td>
<p>A character string indicating the name of the 'u' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_t">t</code></td>
<td>
<p>A character string indicating the name of the 't' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the row names of the 'C' matrix.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_thresholds">thresholds</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_threshnames">threshnames</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_...">...</code></td>
<td>
<p>Unused.  Requires further arguments to be named.</p>
</td></tr>
<tr><td><code id="mxExpectationStateSpaceContinuousTime_+3A_scores">scores</code></td>
<td>
<p>Not to be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mxExpectationStateSpaceContinuousTime</code> and <code>mxExpectationSSCT</code> functions are identical.  The latter is simply an abbreviated name.  When using the former, tab completion is strongly encouraged to save tedious typing.  Both of these functions are wrappers for the <a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a> function, which could be used for both discrete and continuous time modeling.  However, there is a strong possibility of misunderstanding the model parameters when switching between discrete time and continuous time.  The expectation matrices have the same names, but mean importantly different things so caution is warranted.  The best practice is to use <code>mxExpectationStateSpace</code> for discrete time models, and <code>mxExpectationStateSpaceContinuousTime</code> for continuous time models.
</p>
<p>Expectation functions define the way that model expectations are calculated. That is to say, expectation functions define how a set of model matrices get turned into expectations for the data.  When used in conjunction with the <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, the mxExpectationStateSpace uses maximum likelihood prediction error decomposition (PED) to obtain estimates of free parameters in a model of the raw <a href="#topic+MxData">MxData</a> object. Continuous time state space expectations treat the raw data as a multivariate time series of possibly unevenly spaced times with each row corresponding to a single occasion.  Continuous time state space expectations implement a hybrid Kalman filter to produce expectations.  The hybrid Kalman filter uses a Kalman-Bucy filter for the prediction step and the classical Kalman filter for the update step.  It is a hybrid between the classical Kalman filter used for the discrete (but possibly unequally spaced) measurement occasions and the continuous time Kalman-Bucy filter for latent variable predictions.
</p>
<p>Missing data handling is implemented in the same fashion as full information maximum likelihood for partially missing rows of data.  Additionally, completely missing rows of data are handled by only using the prediction step from the Kalman-Bucy filter and omitting the update step.
</p>
<p>This model uses notation for the model matrices commonly found in engineering and control theory.
</p>
<p>The 'A', 'B', 'C', 'D', 'Q', 'R', 'x0', and 'P0' arguments must be the names of <a href="#topic+MxMatrix">MxMatrix</a> or <a href="#topic+MxAlgebra">MxAlgebra</a>objects with the associated properties of the A, B, C, D, Q, R, x0, and P0 matrices in the state space modeling approach.  The 't' matrix must be a 1x1 matrix using definition variables that gives the times at which measurements occurred.
</p>
<p>The state space expectation is defined by the following model equations.
</p>
<p style="text-align: center;"><code class="reqn">\frac{d}{dt} x(t) = A x(t) + B u_t + q(t)</code>
</p>

<p style="text-align: center;"><code class="reqn">y_t = C x_t + D u_t + r_t</code>
</p>

<p>with <code class="reqn">q(t)</code> and <code class="reqn">r_t</code> both independently and identically distributed random Gaussian (normal) variables with mean zero and covariance matrices <code class="reqn">Q</code> and <code class="reqn">R</code>, respectively.  Subscripts or square brackets indicate discrete indices; parentheses indicate continuous indices.  The derivative of <code class="reqn">x(t)</code> with respect to <code class="reqn">t</code> is <code class="reqn">\frac{d}{dt} x(t)</code>.
</p>
<p>The first equation is called the state equation.  It describes how the latent states change over time with a first-order linear differential equation. Unlike some other programs, we do not require that the continuous time <code class="reqn">A</code> matrix has an inverse. This allows zero dynamics (i.e. no growth models) and many other important kinds of processes.
</p>
<p>The second equation is called the output equation.  It describes how the latent states relate to the observed states at a single point in time.  The output equation shows how the observed output is produced by the latent states.  Also, the output equation in state space modeling is directly analogous to the measurement model in LISREL structural equation modeling.
</p>
<p>Note that the covariates, <code class="reqn">u</code>, have &quot;instantaneous&quot; effects on both the state and output equations.  If lagged effects are desired, then the user must create a lagged covariate by shifting their observed variable to the desired lag.
</p>
<p>The state and output equations, together with some minimal assumptions and the Kalman filter, imply a new expected covariance matrix and means vector for every row of data.  The expected covariance matrix of row <code class="reqn">t</code> is
</p>
<p style="text-align: center;"><code class="reqn">S_{t} = C ( A P_{t-1} A^{\sf T} + Q ) C^{\sf T} + R</code>
</p>

<p>The expected means vector of row <code class="reqn">t</code> is
</p>
<p style="text-align: center;"><code class="reqn">\hat{y}_{t} = C x_{t} + D u_{t}</code>
</p>

<p>The 'dimnames' arguments takes an optional character vector.  

</p>
<p>The 'A' argument refers to the <code class="reqn">A</code> matrix in the State Space approach. This matrix gives the dynamics.  Entries in the diagonal give the strength of the influence of a variable's position on its slope.  Entries in the off-diagonal give the coupling strength from one variable to another.  The <code class="reqn">A</code> matrix is sometimes called the state-transition model.
</p>
<p>The 'B' argument refers to the <code class="reqn">B</code> matrix in the State Space approach. This matrix consists of exogenous forces that influence the dynamics. Note that the covariate effect is contemporaneous: the covariate at time <code class="reqn">t</code> has influence on the slope of the latent state also at time <code class="reqn">t</code>.  A lagged effect can be created by lagged the observed variable.  The <code class="reqn">B</code> matrix is sometimes called the control-input model.
</p>
<p>The 'C' argument refers to the <code class="reqn">C</code> matrix in the State Space approach. This matrix consists of contemporaneous regression coefficients from the latent variable in column <code class="reqn">j</code> to the observed variable in row <code class="reqn">i</code>.  This matrix is directly analogous to the factor loadings matrix in LISREL and Mplus models.  The <code class="reqn">C</code> matrix is sometimes called the observation model.
</p>
<p>The 'D' argument refers to the <code class="reqn">D</code> matrix in the State Space approach. This matrix consists of contemporaneous regressive coefficients from the input (manifest covariate) variable <code class="reqn">j</code> to the observed variable in row <code class="reqn">i</code>. The <code class="reqn">D</code> matrix is sometimes called the feedthrough or feedforward matrix.
</p>
<p>The 'Q' argument refers to the <code class="reqn">Q</code> matrix in the State Space approach. This matrix gives the covariance of the dynamic noise.  The dynamic noise can be thought of as unmeasured covariate inputs active at all times.  This matrix must be symmetric, diagonal, or zero.  As a special case, it is often diagonal. The <code class="reqn">Q</code> matrix is the covariance of the process noise.  Just as in factor analysis and general structural equation modeling, the scale of the latent variables is usually set by fixing some factor loadings in the <code class="reqn">C</code> matrix, or fixing some factor variances in the <code class="reqn">Q</code> matrix.
</p>
<p>The 'R' argument refers to the <code class="reqn">R</code> matrix in the State Space approach. This matrix consists of residual covariances among the observed (manifest) variables. This matrix must be symmetric  As a special case, it is often diagonal.  The <code class="reqn">R</code> matrix is the covariance of the observation noise.
</p>
<p>The 'x0' argument refers to the <code class="reqn">x_0</code> matrix in the State Space approach. This matrix consists of the column vector of the initial values for the latent variables. The state space expectation uses the <code class="reqn">x_0</code> matrix as the starting point to recursively estimate the latent variables' values at each time.  These starting values can be difficult to pick, however, for sufficiently long time series they often do not greatly impact the estimation.
</p>
<p>The 'P0' argument refers to the <code class="reqn">P_0</code> matrix in the State Space approach. This matrix consists of the initial values of the covariances of the error in the initial latent variable estimates given in <code class="reqn">x_0</code>. That is, the <code class="reqn">P_0</code> matrix gives the covariance of <code class="reqn">x_0 - xtrue_0</code> where <code class="reqn">xtrue_0</code> is the vector of true initial values.  <code class="reqn">P_0</code> is a measure of the accuracy of the initial latent state estimates. The Kalman filter uses this initial covariance to recursively generated a new covariance for each time point based on the previous time point.  The Kalman filter updates this covariance so that it is as small as possible (minimum trace). Similar to the <code class="reqn">x_0</code> matrix, these starting values are often difficult to choose.
</p>
<p>The 'u' argument refers to the <code class="reqn">u</code> matrix in the State Space approach. This matrix consists of the inputs or manifest covariates of the state space expectation.  The <code class="reqn">u</code> matrix must be a column vector with the same number of rows as the <code class="reqn">B</code> and <code class="reqn">D</code> matrices have columns.  If no inputs are desired, <code class="reqn">u</code> can be a zero matrix.  If time-varying inputs are desired, then they should be included as columns in the <a href="#topic+MxData">MxData</a> object and referred to in the labels of the <code class="reqn">u</code> matrix as definition variables.  There is an example of this below.
</p>
<p>The 't' argument refers to the <code class="reqn">t</code> matrix in the State Space approach.  This matrix should be 1x1 (1 row and 1 column) and not free.  The label for the element of this matrix should be 'data.YourTimeVariable'.  The 'data' part does not change, but 'YourTimeVariable' should be a name in your data set that gives the times at which measurement happened.  The units of time are up to you.  Your choice of time units will influence of the values of the parameters you estimate.  Also, recall that the model is given <code class="reqn">x_0</code> and <code class="reqn">P_0</code>.  These always happen at <code class="reqn">t=0</code>.  So the first row of data happens some amount of time after zero.
</p>
<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxExpectationStateSpace will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>mxExpectationStateSpaceContinuousTime evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxExpectationStateSpace function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxExpectationStateSpace requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'raw'.  Neighboring rows of the <a href="#topic+MxData">MxData</a> object are treated as adjacent, equidistant time points increasing from the first to the last row.
</p>
<p>To evaluate, place an mxExpectationStateSpaceContinuousTime object, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a new MxExpectationStateSpace object. mxExpectationStateSpace objects should be included with models with referenced <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxData">MxData</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>


<h3>References</h3>

<p>K.J. &Aring;str&ouml;m and R.M. Murray  (2010).  <em> Feedback Systems: An Introduction for Scientists and Engineers</em>. Princeton University Press.
</p>
<p>J. Durbin and S.J. Koopman.  (2001).  <em>Time Series Analysis by State Space Methods</em>. Oxford University Press.
</p>
<p>R.E. Kalman  (1960).  A New Approach to Linear Filtering and Prediction Problems.  <em>Basic Engineering, 82</em>, 35-45.
</p>
<p>R.E. Kalman and R.S. Bucy  (1961).  New Results in Linear Filtering and Prediction Theory.  <em>Transactions of the ASME, Series D, Journal of Basic Engineering, 83</em>, 95-108.
</p>
<p>G. Petris  (2010).  An R Package for Dynamic Linear Models.  <em>Journal of Statistical Software, 36</em>, 1-16.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------------------------------------
# Example 1
# Undamped linear oscillator, i.e. a noisy sine wave.
#	Measurement error, but no dynamic error, single indicator.
#	This example works great.

#--------------------------------------
# Data Generation

require(OpenMx)

# Limit to 2 cores for CRAN
mxOption(key="Number of Threads",
 value=min(2,parallel::detectCores()))

set.seed(405)
tlen &lt;- 200
t &lt;- seq(1.2, 50, length.out=tlen)

freqParam &lt;- .5
initialCond &lt;- matrix(c(2.5, 0))
x &lt;- initialCond[1,1]*cos(freqParam*t)
plot(t, x, type='l')

measVar &lt;- 1.5
y &lt;- cbind(obs=x+rnorm(tlen, sd=sqrt(measVar)), tim=t)

plot(t, y[,1], type='l')

#--------------------------------------
# Model Specification

#Note: the bounds are here only to keep SLSQP from
# stepping too far off a cliff.  With the bounds in
# place, SLSQP finds the right solution.  Without
# the bounds, SLSQP goes crazy.


cdim &lt;- list('obs', c('ksi', 'ksiDot'))

amat &lt;- mxMatrix('Full', 2, 2, c(FALSE, TRUE, FALSE, TRUE), c(0, -.1, 1, -.2),
	name='A', lbound=-10)
bmat &lt;- mxMatrix('Zero', 2, 1, name='B')
cmat &lt;- mxMatrix('Full', 1, 2, FALSE, c(1, 0), name='C', dimnames=cdim)
dmat &lt;- mxMatrix('Zero', 1, 1, name='D')
qmat &lt;- mxMatrix('Zero', 2, 2, name='Q')
rmat &lt;- mxMatrix('Diag', 1, 1, TRUE, .4, name='R', lbound=1e-6)
xmat &lt;- mxMatrix('Full', 2, 1, TRUE, c(0, 0), name='x0', lbound=-10, ubound=10)
pmat &lt;- mxMatrix('Diag', 2, 2, FALSE, 1, name='P0')
umat &lt;- mxMatrix('Zero', 1, 1, name='u')
tmat &lt;- mxMatrix('Full', 1, 1, name='time', labels='data.tim')

osc &lt;- mxModel("LinearOscillator", 
	amat, bmat, cmat, dmat, qmat, rmat, xmat, pmat, umat, tmat,
	mxExpectationSSCT('A', 'B', 'C', 'D', 'Q', 'R', 'x0', 'P0', 'u', 'time'),
	mxFitFunctionML(),
	mxData(y, 'raw'))


oscr &lt;- mxRun(osc)


#--------------------------------------
# Results Examination

summary(oscr)


(ssFreqParam &lt;- mxEval(sqrt(-A[2,1]), oscr))
freqParam


(ssMeasVar &lt;- mxEval(R, oscr))
measVar


dampingParam &lt;- 0
(ssDampingParam &lt;- mxEval(-A[2,2], oscr))
dampingParam

</code></pre>

<hr>
<h2 id='mxFactor'>Fail-safe Factors</h2><span id='topic+mxFactor'></span>

<h3>Description</h3>

<p>This is a wrapper for the R function <code><a href="base.html#topic+factor">factor</a></code>. 
</p>
<p>OpenMx requires ordinal data to be ordered. R's <code>factor</code> function doesn't enforce this, hence this wrapper exists to throw an error should you accidentally try and run with ordered = FALSE.
</p>
<p>Also, the &lsquo;levels&rsquo; parameter is optional in R's <code>factor</code> function. However, relying on the data to specify the data is foolhardy for the following reasons: The <code>factor</code> function will skip levels missing from the data: Specifying these in levels leaves the list of levels complete. Data will often not explore the min and max level that the user knows are possible. For these reasons this function forces you to write out all possible levels explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFactor(x = character(), levels, labels = levels, 
    exclude = NA, ordered = TRUE, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFactor_+3A_x">x</code></td>
<td>
<p>either a vector of data or a data.frame object.</p>
</td></tr>
<tr><td><code id="mxFactor_+3A_levels">levels</code></td>
<td>
<p>a mandatory vector of the values that 'x' might have taken.</p>
</td></tr>
<tr><td><code id="mxFactor_+3A_labels">labels</code></td>
<td>
<p>_either_ an optional vector of labels for the levels, _or_ a character string of length 1.</p>
</td></tr>
<tr><td><code id="mxFactor_+3A_exclude">exclude</code></td>
<td>
<p>a vector of values to be excluded from the set of levels.</p>
</td></tr>
<tr><td><code id="mxFactor_+3A_ordered">ordered</code></td>
<td>
<p>logical flag to determine if the levels should be regarded as ordered (in the order given).  Required to be TRUE.</p>
</td></tr>
<tr><td><code id="mxFactor_+3A_collapse">collapse</code></td>
<td>
<p>logical flag to determine if duplicate labels should
collapsed into a single level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &lsquo;x&rsquo; is a data.frame, then all of the columns of &lsquo;x&rsquo; are converted into ordered factors. If &lsquo;x&rsquo; is a data.frame, then &lsquo;levels&rsquo; and &lsquo;labels&rsquo; may be either a list or a vector. When &lsquo;levels&rsquo; is a list, then different levels are assigned to different columns of the constructed data.frame object. When &lsquo;levels&rsquo; is a vector, then the same levels are assigned to all the columns of the data.frame object. The function will throw an error if &lsquo;ordered&rsquo; is not TRUE or if &lsquo;levels&rsquo; is missing.  See <code><a href="base.html#topic+factor">factor</a></code> for more information on creating ordered factors. 
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myVar &lt;- c("s", "t", "a", "t", "i", "s", "t", "i", "c", "s")
ff    &lt;- mxFactor(myVar, levels=letters)
# Note: letters is a built in list of all lowercase letters of the alphabet
ff
# [1] s t a t i s t i c s
# Levels: a &lt; b &lt; c &lt; d &lt; e &lt; f &lt; g &lt; h &lt; i &lt; j &lt; k &lt; l &lt; m &lt; n &lt; o &lt; p &lt; q &lt;
#  r &lt; s &lt; t &lt; u &lt; v &lt; w &lt; x &lt; y &lt; z

as.integer(ff)  # the internal codes

factor(ff)      # NOTE: drops the levels that do not occur.
                # mxFactor prevents you doing this unintentionally.

# This example works on a dataframe
foo &lt;- data.frame(x=c(1:3),y=c(4:6),z=c(7:9))

# Applys one set of levels to all three columns
mxFactor(foo, c(1:9))

# Apply unique sets of levels to each variable
mxFactor(foo, list(c(1:3), c(4:6), c(7:9)))


mxFactor(foo, c(1:9), labels=c(1,1,1,2,2,2,3,3,3), collapse=TRUE)

</code></pre>

<hr>
<h2 id='mxFactorScores'>Estimate factor scores and standard errors</h2><span id='topic+mxFactorScores'></span>

<h3>Description</h3>

<p>This function creates the factor scores and their standard errors under different methods for an MxModel object that has either a RAM or LISREL expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFactorScores(model, type=c('ML', 'WeightedML', 'Regression'),
 minManifests=as.integer(NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFactorScores_+3A_model">model</code></td>
<td>
<p>An MxModel object with either an MxExpectationLISREL or MxExpectationRAM</p>
</td></tr>
<tr><td><code id="mxFactorScores_+3A_type">type</code></td>
<td>
<p>The type of factor scores to compute</p>
</td></tr>
<tr><td><code id="mxFactorScores_+3A_minmanifests">minManifests</code></td>
<td>
<p>Set scores to NA when there are less than
minManifests non-NA manifest variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to compute or estimate factor scores along with their standard errors.  The two maximum likelihood methods create a new model for each data row.  They then estimate the factor scores as free parameters in a model with a single data row.  For 'ML', the conditional likelihood of the data given the factor scores is optimized: </p>
<p style="text-align: center;"><code class="reqn">L(D|F)</code>
</p>
<p>.  For 'WeightedML', the joint likelihood of the data and the factor scores is optimized: </p>
<p style="text-align: center;"><code class="reqn">L(D, F) = L(D|F) L(F)</code>
</p>
<p>.  The WeightedML scores are akin to the empirical Bayes random effects estimates from mixed effects modeling.  They display the same kind of shrinkage as random effects estimates, and for the same reason: they account for the latent variable distribution in their estimation.
</p>
<p>In many cases, especially for ordinal data or missing data, the weighted ML scores are to be preferred over alternatives (Estabrook &amp; Neale, 2013). For example, when using ordinal data, a person whose observations are all in the highest ordinal category theoretically has an 'ML' factor score of positive infinity. A similar situation arises for a person whose observations are all in the lowest ordinal category: their 'ML' factor score is theoretically negative infinity. Weighted ML factor scores in these cases remain reasonable.
</p>
<p>For type='Regression', with LISREL expectation, factor scores are computed based on a simple formula.  This formula is equivalent to the formula for the Kalman updated scores in a state space model with zero dynamics (Priestly &amp; Subba Rao, 1975).  Thus, to compute the regression factor scores, the appropriate state space model is set-up and the <a href="#topic+mxKalmanScores">mxKalmanScores</a> function is used to produce the factor scores and their standard errors.  With RAM expectation, factor scores are predicted from the non-missing manifest variables for each row of the raw data, using a general linear prediction formula analytically equivalent to that used with LISREL expectation.  The standard errors for regression-predicted RAM factor scores are the square roots of the indeterminate variances of the latent variables, given the data row's missing-data pattern and the values of any relevant definition variables.  The RAM and LISREL methods for computing regression factor scores with their standard errors are analytically identical. They produce the same score and standard error estimates.
</p>
<p>If you have missing data then you must specify <code>minManifests</code>.
This option will set scores to NA when there are too few items to make an accurate score estimate.
If you are using the scores as point estimates without considering the standard error then you should set minManifests as high as you can tolerate.
This will increase the amount of missing data but scores will be more accurate.
If you are carefully considering the standard errors of the scores then
you can set minManifests to 0.
When set to 0, all NA rows are scored to the prior distribution.
</p>
<p>Note that for compatibility with <code><a href="stats.html#topic+factanal">factanal</a></code>, type='regression' is also acceptable.
</p>


<h3>Value</h3>

<p>An array with dimensions (Number of Rows of Data, Number of Latent Variables, 2).  The third dimension has the scores in the first slot and the standard errors in the second slot.  The rows are in the order of the <em>unsorted</em> data.  Multigroup models are an exception, in that the returned value is instead a list of such arrays, containing one per group. 
</p>


<h3>References</h3>

<p>Estabrook, R. &amp; Neale, M. C.  (2013).  A Comparison of Factor Score Estimation Methods in the Presence of Missing Data: Reliability and an Application to Nicotine Dependence.  <em>Multivariate Behavioral Research, 48,</em> 1-27.
</p>
<p>Priestley, M. &amp; Subba Rao, T.  (1975).  The estimation of factor scores and Kalman filtering for discrete parameter stationary processes.  <em>International Journal of Control, 21</em>, 971-975.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxKalmanScores">mxKalmanScores</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and estimate a factor model
require(OpenMx)
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("OneFactor", 
                       type="LISREL",
                       manifestVars=list(exo=manifests), 
                       latentVars=list(exo=latents),
                       mxPath(from=latents, to=manifests),
                       mxPath(from=manifests, arrows=2),
                       mxPath(from=latents, arrows=2, free=FALSE, values=1.0),
                       mxPath(from='one', to=manifests),
                       mxData(observed=cov(demoOneFactor), type="cov", numObs=500,
                              means = colMeans(demoOneFactor)))
summary(factorRun &lt;- mxRun(factorModel))

# Swap in raw data in place of summary data
factorRun &lt;- mxModel(factorRun, mxData(observed=demoOneFactor[1:50,], type="raw"))

# Estimate factor scores for the model
r1 &lt;- mxFactorScores(factorRun, 'Regression')


</code></pre>

<hr>
<h2 id='mxFIMLObjective'>DEPRECATED: Create MxFIMLObjective Object</h2><span id='topic+mxFIMLObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use mxExpectationNormal() and mxFitFunctionML() instead.  As a temporary workaround, mxFIMLObjective returns a list containing an MxExpectationNormal object and an MxFitFunctionML object.
</p>
<p>All occurrences of
</p>
<p>mxFIMLObjective(covariance, means, dimnames = NA, thresholds = NA, vector = FALSE, threshnames = dimnames)
</p>
<p>Should be changed to
</p>
<p>mxExpectationNormal(covariance, means, dimnames = NA, thresholds = NA, threshnames = dimnames)
mxFitFunctionML(vector = FALSE)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFIMLObjective_+3A_covariance">covariance</code></td>
<td>
<p>A character string indicating the name of the expected covariance algebra.</p>
</td></tr>
<tr><td><code id="mxFIMLObjective_+3A_means">means</code></td>
<td>
<p>A character string indicating the name of the expected means algebra.</p>
</td></tr>
<tr><td><code id="mxFIMLObjective_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the dimnames of the covariance and means algebras.</p>
</td></tr>
<tr><td><code id="mxFIMLObjective_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxFIMLObjective_+3A_vector">vector</code></td>
<td>
<p>A logical value indicating whether the objective function result is the likelihood vector.</p>
</td></tr>
<tr><td><code id="mxFIMLObjective_+3A_threshnames">threshnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the thresholds matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: THIS DESCRIPTION IS DEPRECATED.  Please change to using <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> and <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> as shown in the example below.
</p>
<p>Objective functions were functions for which free parameter values are chosen such that the value of the objective function is minimized. The mxFIMLObjective function used full-information maximum likelihood to provide maximum likelihood estimates of free parameters in the algebra defined by the 'covariance' and 'means' arguments. The 'covariance' argument takes an <a href="#topic+MxAlgebra">MxAlgebra</a> object, which defines the expected covariance of an associated <a href="#topic+MxData">MxData</a> object. The 'means' argument takes an <a href="#topic+MxAlgebra">MxAlgebra</a> object, which defines the expected means of an associated <a href="#topic+MxData">MxData</a> object. The 'dimnames' arguments takes an optional character vector.  If this argument is not a single NA, then this vector is used to assign the dimnames of the means vector as well as the row and columns dimnames of the covariance matrix.
</p>
<p>The 'vector' argument is either TRUE or FALSE, and determines whether the objective function returns a column vector of the likelihoods, or a single -2*(log likelihood) value.
</p>
<p>thresholds: The name of the thresholds matrix. When needed (for modelling ordinal data), this matrix should be created using  <a href="#topic+mxMatrix">mxMatrix</a>(). The thresholds matrix must have as many columns as there are ordinal variables in the model, and number of rows equal to one fewer than the maximum number of levels found in the ordinal variables. The starting values  of this matrix must also be set to reasonable values. Fill each column with a set of ordered start thresholds, one for each level of this column's factor levels minus 1. These thresholds may be free if you wish them to be estimated, or fixed. The unused rows in each column, if any, can be set to any value including NA.
</p>
<p>threshnames: A character vector consisting of the variables in the thresholds matrix, i.e., the names of ordinal variables in a model. This is necessary for OpenMx to map the thresholds matrix columns onto the variables in your data. If you set the <a href="base.html#topic+dimnames">dimnames</a> of the columns in the thresholds matrix then threshnames is not needed.
</p>
<p>Usage Notes: 
dimnames must be supplied where the matrices referenced by the covariance and means algebras are not themselves labeled. Failure to do so leads to an error noting that the covariance or means matrix associated with the FIML objective does not contain dimnames.
</p>
<p>mxFIMLObjective evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxFIMLObjective function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxFIMLObjective requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'raw'. Missing values are permitted in the associated <a href="#topic+MxData">MxData</a> object.
</p>
<p>To evaluate, place MxFIMLObjective objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. 
</p>
<p>The results of the optimization can be reported using the <a href="base.html#topic+summary">summary</a> function, or accessed directly in the 'output' slot of the resulting model (i.e., modelName$output). Components of the output may be referenced using the <a href="base.html#topic+Extract">Extract</a> functionality.
</p>


<h3>Value</h3>

<p>Returns a list containing an MxExpectationNormal object and an MxFitFunctionML object. 
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra, mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

M &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=c(0,0), 
              free=c(TRUE,TRUE), labels=c("Mx", "My"), name = "M")
S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1), 
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA), name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Define the expectation

expCov &lt;- mxAlgebra(solve(I-A) %*% S %*% t(solve(I-A)), name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", means="M", dimnames=tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML()

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", M, S, A, I, expCov, expFunction, fitFunction, 
                    mxData(observed=tmpFrame, type="raw"))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)


</code></pre>

<hr>
<h2 id='MxFitFunction-class'>MxFitFunction</h2><span id='topic+MxFitFunction-class'></span><span id='topic+MxFitFunction'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxFitFunctionAlgebra'>Create MxFitFunctionAlgebra Object</h2><span id='topic+mxFitFunctionAlgebra'></span><span id='topic+MxFitFunctionAlgebra-class'></span><span id='topic+print+2CMxFitFunctionAlgebra-method'></span><span id='topic+show+2CMxFitFunctionAlgebra-method'></span>

<h3>Description</h3>

<p>mxFitFunctionAlgebra returns an MxFitFunctionAlgebra object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionAlgebra(algebra, numObs = NA, numStats = NA, ..., gradient =
                 NA_character_, hessian = NA_character_, verbose = 0L,
   units="-2lnL", strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionAlgebra_+3A_algebra">algebra</code></td>
<td>
<p>A character string indicating the name of an <a href="#topic+MxAlgebra">MxAlgebra</a> or <a href="#topic+MxMatrix">MxMatrix</a> object to use for optimization.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_numobs">numObs</code></td>
<td>
<p>(optional) An adjustment to the total number of observations in the model.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_numstats">numStats</code></td>
<td>
<p>(optional) An adjustment to the total number of
observed statistics in the model.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_gradient">gradient</code></td>
<td>
<p>(optional) A character string indicating the name of
an <a href="#topic+MxAlgebra">MxAlgebra</a> object.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_hessian">hessian</code></td>
<td>
<p>(optional) A character string indicating the name of
an <a href="#topic+MxAlgebra">MxAlgebra</a> object.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_verbose">verbose</code></td>
<td>
<p>(optional An integer to increase the level of runtime
log output.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_units">units</code></td>
<td>
<p>(optional) The units of the fit statistic.</p>
</td></tr>
<tr><td><code id="mxFitFunctionAlgebra_+3A_strict">strict</code></td>
<td>
<p>Whether to require that all derivative entries reference
free parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to fit a multigroup model, the preferred way is to use <code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>.
</p>
<p>Fit functions are functions for which free parameter values are chosen such that the value of the objective function is minimized. While the other fit functions in OpenMx require an expectation function for the model, the <code>mxAlgebraObjective</code> function uses the referenced <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object as the function to be minimized.
</p>
<p>If a model's  fit function is an <code>mxFitFunctionAlgebra</code> objective function, then the referenced algebra in the objective function must return a 1 x 1 matrix (when using OpenMx's default optimizer).  There is no restriction on the dimensions of an fit function that is not the primary, or &lsquo;topmost&rsquo;, objective function.
</p>
<p>To evaluate an algebra fit function, place the following objects in a <code><a href="#topic+MxModel">MxModel</a></code> object: a <code>mxFitFunctionAlgebra</code>, <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> and <code><a href="#topic+MxMatrix">MxMatrix</a></code> entities referenced by the <code>MxAlgebraObjective</code>, and optional <code><a href="#topic+MxBounds">MxBounds</a></code> and <code><a href="#topic+MxConstraint">MxConstraint</a></code> objects. This model may then be evaluated using the <code><a href="#topic+mxRun">mxRun</a></code> function. The results of the optimization may be obtained using the <code><a href="#topic+mxEval">mxEval</a></code> function on the name of the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code>, after the model has been run.
</p>
<p>First and second derivatives can be provided with the algebra fit
function. The dimnames on the gradient and hessian MxAlgebras are
matched against names of free variables. Names that do not match are
ignored. The fit is assumed to be in deviance units (-2 log
likelihood units). If you are working in log likelihood units, the -2
scaling factor is not applied automatically. You have to
multiply by -2 yourself.
</p>


<h3>Value</h3>

<p>Returns an MxFitFunctionAlgebra object.  MxFitFunctionAlgebra objects should be included with models with referenced <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> and <code><a href="#topic+MxMatrix">MxMatrix</a></code> objects.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>, <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>,
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>,
<code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code>, <code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>To create an algebra suitable as a reference function to be minimized see: <a href="#topic+mxAlgebra">mxAlgebra</a>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a very simple model that adds two numbers using mxFitFunctionAlgebra

library(OpenMx)

# Create a matrix 'A' with no free parameters
A &lt;- mxMatrix('Full', nrow = 1, ncol = 1, values = 1, name = 'A')

# Create an algebra 'B', which defines the expression A + A
B &lt;- mxAlgebra(A + A, name = 'B')

# Define the objective function for algebra 'B'
objective &lt;- mxFitFunctionAlgebra('B')

# Place the algebra, its associated matrix and
# its objective function in a model
tmpModel &lt;- mxModel(model="Addition", A, B, objective)

# Evalulate the algebra
tmpModelOut &lt;- mxRun(tmpModel)

# View the results
tmpModelOut$output$minimum

</code></pre>

<hr>
<h2 id='mxFitFunctionGREML'>
Create MxFitFunctionGREML Object
</h2><span id='topic+mxFitFunctionGREML'></span>

<h3>Description</h3>

<p>This function creates a new <code><a href="#topic+MxFitFunctionGREML">MxFitFunctionGREML</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionGREML(dV=character(0), aug=character(0),
   augGrad=character(0), augHess=character(0), 
   autoDerivType=c("semiAnalyt","numeric"),infoMatType=c("average","expected"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionGREML_+3A_dv">dV</code></td>
<td>
<p>Vector of character strings; defaults to a character vector of length zero.  If a value of non-zero length is provided, it must be a <em>named</em> character vector.  This vector's names must be the labels of each free parameter in the model.  The vector's elements (i.e., the character strings themselves) must be the names of <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object(s), each of which equals the first partial derivative of the 'V' matrix with respect to the corresponding free parameter.</p>
</td></tr>
<tr><td><code id="mxFitFunctionGREML_+3A_aug">aug</code></td>
<td>
<p>Character string; defaults to a character vector of length zero.  Any elements after the first are ignored.  The string should name a 1x1 <code><a href="#topic+MxMatrix">MxMatrix</a></code> or an <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> that evaluates to a 1x1 matrix.  The named object will be used as an &quot;augmentation&quot; to the GREML fitfunction&ndash;specifically, the [1,1] value of the object named by <code>aug</code> will be added to the GREML fitfunction value at each function evaluation during optimization.  The augmentation can be used to regularize estimation with a prior likelihood, or to use penalty functions to approximate constraints.</p>
</td></tr>
<tr><td><code id="mxFitFunctionGREML_+3A_auggrad">augGrad</code></td>
<td>
<p>Character string; defaults to a character vector of length zero.  Any elements after the first are ignored.  The string should name a <code><a href="#topic+MxMatrix">MxMatrix</a></code> or an <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> that evaluates to the gradient of <code>aug</code> with respect to free parameters.  The gradient can be either a column or row vector.  The free parameters corresponding to the elements of the gradient vector are taken from the names of argument <code>dV</code>, e.g. if the third name of <code>dV</code> is <code>'va'</code>, then the third element of the gradient vector should be the first partial derivative of the augmentation function with respect to <code>'va'</code>.  Ignored unless both <code>dV</code> and <code>aug</code> have nonzero length.</p>
</td></tr>
<tr><td><code id="mxFitFunctionGREML_+3A_aughess">augHess</code></td>
<td>
<p>Character string; defaults to a character vector of length zero.  Any elements after the first are ignored.  The string should name a <code><a href="#topic+MxMatrix">MxMatrix</a></code> or an <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> that evaluates to the Hessian of <code>aug</code> with respect to free parameters.  The free parameters corresponding to each row and column of this matrix are dictated by the names of argument <code>dV</code>, in the same manner as for the elements of <code>augGrad</code>.  Ignored unless both <code>dV</code> and <code>aug</code> have nonzero length.  Providing a nonzero-length value for <code>augHess</code> but not <code>augGrad</code> will result in an error at runtime.</p>
</td></tr>
<tr><td><code id="mxFitFunctionGREML_+3A_autoderivtype">autoDerivType</code></td>
<td>
<p>&quot;Automatic derivative type.&quot;  Character string, either &quot;semiAnalyt&quot; (default) or &quot;numeric&quot;.  See details below.</p>
</td></tr>
<tr><td><code id="mxFitFunctionGREML_+3A_infomattype">infoMatType</code></td>
<td>
<p>&quot;Information matrix type.&quot;  Character string, either &quot;average&quot; (default) or &quot;expected&quot;.  See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Making effective use of arguments <code>dV</code>, <code>augGrad</code>, and <code>augHess</code> will usually require a custom <code><a href="#topic+mxComputeSequence">mxComputeSequence</a>()</code>.  The derivatives of the REML loglikelihood function with respect to parameters can be internally computed from the derivatives of the 'V' matrix supplied via <code>dV</code>.  The loglikelihood's first derivatives thus computed will always be exact, but its matrix of second partial derivatives (i.e., its Hessian matrix) will be approximated by either the average or expected information matrix, per the value of argument <code>infoMatType</code>.  The average information matrix is faster to compute, but may not provide a good approximation to the Hessian if 'V' is not linear in the model's free parameters.  The expected information matrix is slower to compute, but does not assume that 'V' is linear in the free parameters.  Neither information matrix will be a good approximation to the Hessian unless the derivatives of 'V' evaluate to symmetric matrices the same size as 'V'.  Note also that these loglikelihood derivatives do not reflect the influence of any parameter bounds or <code><a href="#topic+MxConstraint">MxConstraint</a></code>s. Internally, the derivatives of the 'V' matrix are assumed to be symmetric, and the elements above their main diagonals are ignored.
</p>
<p>Formerly, if any derivatives were provided via <code>dV</code>, then derivatives had to be provided for <em>every</em> free parameter in the MxModel.  Currently, users may provide derivatives of 'V' via <code>dV</code> with respect to some or all free parameters.  Note that the gradient and Hessian of the augmentation must be complete, i.e. contain derivatives of the augmentation with respect to every parameter or pair of parameters respectively.
</p>
<p>If there are any free parameters with respect to which the user did not provide an analytic derivative of 'V', OpenMx will automatically calculate the necessary loglikelihood derivatives according to <code>autoDerivType</code>.  If <code>autoDerivType="semiAnalyt"</code>, the GREML fitfunction backend will calculate the missing derivatives in a &quot;semi-analytic&quot; fashion.  Specifically, the backend will numerically differentiate 'V' with respect to the relevant parameter(s), and use those numeric matrix derivatives to analytically calculate the needed loglikelihood derivatives.  If <code>autoDerivType="numeric"</code>, the needed loglikelihood derivatives will be calculated numerically, via finite-differences.
</p>
<p>Argument <code>aug</code> is intended to allow users to provide penalty functions or prior likelihoods in order to approximate constraints or to regularize optimization.  The user is warned that careless use of this augmentation feature may undermine the validity of his/her statistical inferences.
</p>


<h3>Value</h3>

<p>Returns a new object of class <code><a href="#topic+MxFitFunctionGREML">MxFitFunctionGREML</a></code>.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+MxFitFunctionGREML">MxFitFunctionGREML</a></code> for the S4 class created by <code>mxFitFunctionGREML()</code>.  For more information generally concerning GREML analyses, including a complete example, see <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.
</p>
<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>, <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>, 
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>, 
<code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code>, <code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gff &lt;- mxFitFunctionGREML()
str(gff)
</code></pre>

<hr>
<h2 id='MxFitFunctionGREML-class'>Class <code>"MxFitFunctionGREML"</code></h2><span id='topic+MxFitFunctionGREML-class'></span><span id='topic+MxFitFunctionGREML'></span>

<h3>Description</h3>

<p><code>MxFitFunctionGREML</code> is the fitfunction class for GREML analyses.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>mxFitFunctionGREML(dV)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dV</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object(s) to serve as the derivatives of 'V' with respect to free parameters.</p>
</dd>
<dt><code>dVnames</code>:</dt><dd><p>Vector of character strings; names of the free parameters corresponding to slot <code>dV</code>.</p>
</dd>
<dt><code>MLfit</code>:</dt><dd><p>Object of class <code>"numeric"</code>, equal to the maximum-likelihood fitfunction value (as opposed to the restricted maximum-likelihood value).</p>
</dd>
<dt><code>numObsAdjust</code>:</dt><dd><p>Object of class <code>"integer"</code>.
Number of observations adjustment.</p>
</dd>
<dt><code>aug</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object used to &quot;augment&quot; the fitfunction value at each function evaluation during optimization.</p>
</dd>
<dt><code>augGrad</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object(s) to serve as the first derivatives of <code>aug</code> with respect to free parameters.</p>
</dd>
<dt><code>augHess</code>:</dt><dd><p>Object of class <code>"MxCharOrNumber"</code>.  Identifies the <code><a href="#topic+MxAlgebra">MxAlgebra</a></code> or <code><a href="#topic+MxMatrix">MxMatrix</a></code> object(s) to serve as the second derivatives of <code>aug</code> with respect to free parameters.</p>
</dd>
<dt><code>autoDerivType</code>:</dt><dd><p>Object of class <code>"character"</code>.  Dictates whether fitfunction derivatives automatically calculated by OpenMx should be numeric or &quot;semi-analytic.&quot;</p>
</dd>
<dt><code>infoMatType</code>:</dt><dd><p>Object of class <code>"character"</code>.  Dictates whether to calculate the average or expected information matrix.</p>
</dd>
<dt><code>info</code>:</dt><dd><p>Object of class <code>"list"</code>.</p>
</dd>
<dt><code>dependencies</code>:</dt><dd><p>Object of class <code>"integer"</code>.</p>
</dd>
<dt><code>expectation</code>:</dt><dd><p>Object of class <code>"integer"</code>.</p>
</dd>
<dt><code>vector</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>rowDiagnostics</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>result</code>:</dt><dd><p>Object of class <code>"matrix"</code>.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"MxBaseFitFunction"</code>, directly.
Class <code>"MxBaseNamed"</code>, by class &quot;MxBaseFitFunction&quot;, distance 2.
Class <code>"MxFitFunction"</code>, by class &quot;MxBaseFitFunction&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;MxFitFunctionGREML&quot; in the signature.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a>()</code> for creating MxFitFunctionGREML objects.  See <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code> for creating MxExpectationGREML objects, and for more information generally concerning GREML analyses, including a complete example. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MxFitFunctionGREML")
</code></pre>

<hr>
<h2 id='mxFitFunctionML'>Create MxFitFunctionML Object</h2><span id='topic+mxFitFunctionML'></span><span id='topic+MxFitFunctionML-class'></span><span id='topic+print+2CMxFitFunctionML-method'></span><span id='topic+show+2CMxFitFunctionML-method'></span>

<h3>Description</h3>

<p>This function creates a new MxFitFunctionML object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionML(vector = FALSE, rowDiagnostics = FALSE, ..., fellner =
  as.logical(NA), verbose=0L, profileOut=c(),
  rowwiseParallel=as.logical(NA), jointConditionOn = c("auto", "ordinal", "continuous"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionML_+3A_vector">vector</code></td>
<td>
<p>A logical value indicating whether the objective function result is the likelihood vector.</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_rowdiagnostics">rowDiagnostics</code></td>
<td>
<p>A logical value indicating whether the row-wise
results of the objective function should be returned as an attribute
of the fit function.</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_fellner">fellner</code></td>
<td>
<p>Whether to fully expand the covariance matrix for
maximum flexibility.</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_verbose">verbose</code></td>
<td>
<p>Level of diagnostic output</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_profileout">profileOut</code></td>
<td>
<p>Character vector naming constant coefficients to
profile out of the likelihood (sometimes known as REML)</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_rowwiseparallel">rowwiseParallel</code></td>
<td>
<p>For raw data only, whether to use OpenMP to parallelize the
evaluation of rows</p>
</td></tr>
<tr><td><code id="mxFitFunctionML_+3A_jointconditionon">jointConditionOn</code></td>
<td>
<p>The evaluation strategy when both continuous
and ordinal data are present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit functions are functions for which free parameter values are optimized such that the value of a cost function is minimized. The mxFitFunctionML function computes -2*(log likelihood) of the data given the current values of the free parameters and the expectation function (e.g., <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> or <a href="#topic+mxExpectationRAM">mxExpectationRAM</a>)  selected for the model. 
</p>
<p>The 'vector' argument is either TRUE or FALSE, and determines whether the objective function returns a column vector of the likelihoods, or a single -2*(log likelihood) value.
</p>
<p>The 'rowDiagnostics' argument is either TRUE or FALSE, and determines whether the row likelihoods are returned as an attribute of the fit function.  Additionally, the squared Mahalanobis distance and the number of observed (non-missing) variables) for each row are returned under the names <code>rowDist</code> and <code>rowObs</code>, respectively.  It is sometimes useful to inspect the likelihoods for outliers, diagnostics, or other anomalies.  Each rowwise squared Mahalanobis distance should be chi-squared distributed with degrees of freedom equal to the number of observed variables.  In the case of no missing data, all of the rowwise squared Mahalanobis distances should theoretically be chi-squared distributed with the same degrees of freedom.  In the case of some missing data, the rowwise squared Mahalanobis distances should theoretically be a mixture of chi-squared distributions with mixing proportions equal to the proportions of each number of observed variables.
</p>
<p>If there are ordinal data, then only the row likelihoods are returned among the row diagnostics.
</p>
<p>When <code>vector=FALSE</code> and <code>rowDiagnostics=TRUE</code>, the fit function can be referenced in the model and included in algebras as a scalar. The row likelihoods, row distances, and row observations are then an attribute of the fit function but are not accessible in the model during optimization.  The row likelihoods and other diagnostics are accessible to the user after the model has been run.
</p>
<p>By default, <code>jointConditionOn='auto'</code> and a heuristic will be used
to select the fastest algorithm. Conditioning the continuous data on
ordinal will be superior when there are relatively few unique ordinal
patterns. Otherwise, conditioning the ordinal data on continuous will
perform better when there are relatively many ordinal patterns.
</p>
<p>Usage Notes: 
</p>
<p>The results of the optimization can be reported using the <a href="base.html#topic+summary">summary</a> function, or accessed directly in the 'output' slot of the resulting model (i.e., modelName$output). Components of the output may be referenced using the <a href="base.html#topic+Extract">Extract</a> functionality.
</p>


<h3>Value</h3>

<p>Returns a new MxFitFunctionML object. One and only one MxFitFunctionML object should be included in each model along  with an associated <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> or <a href="#topic+mxExpectationRAM">mxExpectationRAM</a> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>,  
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>, 
<code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>, <code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code>, 
<code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra, mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

M &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=c(0,0), 
              free=c(TRUE,TRUE), labels=c("Mx", "My"), name = "M")
S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1), 
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA), name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Define the expectation

expCov &lt;- mxAlgebra(solve(I-A) %*% S %*% t(solve(I-A)), name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", means="M", dimnames=tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML(rowDiagnostics=TRUE)
# also return row likelihoods, even though the fit function
#  value is still 1x1

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", M, S, A, I, expCov, expFunction, fitFunction, 
                    mxData(observed=tmpFrame, type="raw"))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)

fitResOnly &lt;- mxEval(fitfunction, tmpModelOut)
attributes(fitResOnly) &lt;- NULL
fitResOnly

# Look at the row likelihoods alone
fitLikeOnly &lt;- attr(mxEval(fitfunction, tmpModelOut), 'likelihoods')
head(fitLikeOnly)

</code></pre>

<hr>
<h2 id='mxFitFunctionMultigroup'>Create a fit function used to fit multiple-group models</h2><span id='topic+MxFitFunctionMultigroup-class'></span><span id='topic+mxFitFunctionMultigroup'></span>

<h3>Description</h3>

<p><code>mxFitFunctionMultigroup</code> creates a fit function consisting of the sum of the fit statistics
from a list of submodels provided. Thus, it aggregates fit statistics from multiple submodels.
</p>
<p>This total provides the optimization target for fitting a multi-group model.
</p>
<p>In addition to being more compact and readable, using <code>mxFitFunctionMultigroup</code> has
additional side effects which are valuable for multi-group modeling.
</p>
<p>First, it aggregates analytic derivative calculations.
</p>
<p>Second, it allows <code><a href="#topic+mxRefModels">mxRefModels</a></code> to compute saturated models for raw data, as this function can learn which are the constituent submodels.
</p>
<p>Third, and finally, it allows <code><a href="#topic+mxCheckIdentification">mxCheckIdentification</a></code> to evaluate the local identification of the multigroup model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionMultigroup(groups, ..., verbose = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionMultigroup_+3A_groups">groups</code></td>
<td>
<p>vector of submodel names (strings)</p>
</td></tr>
<tr><td><code id="mxFitFunctionMultigroup_+3A_...">...</code></td>
<td>
<p>Not used. Forces subsequent arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxFitFunctionMultigroup_+3A_verbose">verbose</code></td>
<td>
<p>the level of debugging output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conceptually, <code>mxFitFunctionMultigroup</code> is equivalent to summing the subModel objectives in an <a href="#topic+mxAlgebra">mxAlgebra</a>,
and using an <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a> to optimize the model based on this summed likelihood.
</p>
<p>e.g. this 1-line call to mxFitFunctionMultigroup:
</p>
<p><code>mxFitFunctionMultigroup(c("model1", "model2"))</code>
</p>
<p>is equivalent to the following pair of statements:
</p>
<p><code>mxAlgebra(name = "myAlgebra", model1.objective + model2.objective)</code>
</p>
<p><code>mxFitFunctionAlgebra("myAlgebra")</code>
</p>
<p><em>Note</em>: If needed, you can refer to the algebra generated by <code>mxFitFunctionMultigroup</code> as:
</p>
<p><code>modelName.fitfunction</code>
</p>
<p>Where &quot;modelName&quot; is the name of the container or supermodel.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>,
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>,
<code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>, <code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code>,
<code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#------------------------------------------------
# Brief non-running example
require("OpenMx")
mxFitFunctionMultigroup(c("model1", "model2")) # names of sub-models to be jointly optimised



# ===========================================
# = Longer, fully featured, running example =
# ===========================================

# Create and fit a model using mxMatrix, mxExpectationRAM, mxFitFunctionML,
# and mxFitFunctionMultigroup.
# The model is multiple group regression.
# Only the residual variances are allowed to differ across groups.


library(OpenMx)

# Simulate some data

# Group 1
N1 = 100
x = rnorm(N1, mean= 0, sd= 1)
y = 0.5*x + rnorm(N1, mean= 0, sd= 1)
ds1 &lt;- data.frame(x, y)
dsNames &lt;- names(ds1)

# Group 2: y has greater variance; x &amp; y slightly lower correlation...
N2= 150
x= rnorm(N2, mean= 0, sd= 1)
y= 0.5*x + rnorm(N2, mean= 0, sd= sqrt(1.5))
ds2 &lt;- data.frame(x, y)


# Define the matrices (A matrix implementation of 2 RAM models)

I &lt;- mxMatrix(name="I", type="Iden", nrow=2, ncol=2)
M &lt;- mxMatrix(name = "M", type = "Full", nrow = 1, ncol = 2, values=0,
              free=TRUE, labels=c("Mean_x", "Mean_y"))
# A matrix containing a path "b" of x on y
A &lt;- mxMatrix(name = "A", type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0),
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA))

S1 &lt;- mxMatrix(name = "S", type = "Diag", nrow = 2, ncol = 2, values=1,
              free=TRUE, labels=c("Var_x", "Resid_y_group1"))
S2 &lt;- mxMatrix(name = "S", type = "Diag", nrow = 2, ncol = 2, values=1,
              free=TRUE, labels=c("Var_x", "Resid_y_group2"))

# Define the expectation
expect &lt;- mxExpectationRAM('A', 'S', 'I', 'M', dimnames= dsNames)


# Choose a fit function
fitFunction &lt;- mxFitFunctionML(rowDiagnostics=TRUE)
# Also return row likelihoods (the fit function value is still 1x1)

# Multiple-group fit function sums the model likelihoods
# from its component models
mgFitFun &lt;- mxFitFunctionMultigroup(c('g1model', 'g2model'))


# Define model 1 and model 2
m1 = mxModel(model="g1model",
	M, S1, A, I, expect, fitFunction,
    mxData(cov(ds1), type="cov", numObs=N1, means=colMeans(ds1))
)
m2 = mxModel(model="g2model",
	M, S2, A, I, expect, fitFunction,
    mxData(cov(ds2), type="cov", numObs=N2, means=colMeans(ds2))
)

mg &lt;- mxModel(model='multipleGroup', m1, m2, mgFitFun)
# note!: Paths with the same name in both submodels are
# constrained to the same value across models. i.e.,
# b has only 1 value, as does Var_x. But Resid_y can take distinct
# values in the two groups.

# Fit the model and print a summary
mg &lt;- mxRun(mg)
summary(mg)

# Examine fit function results
# Fit in -2lnL units)
mxEval(fitfunction, mg)

# Fit function results for each submodel:
mxEval(g1model.fitfunction, mg)
mxEval(g2model.fitfunction, mg)

mg2 = omxSetParameters(mg,
  labels = c("Resid_y_group1", "Resid_y_group2"),
  newlabels = "Resid_y", name = "equated")
mg2 = omxAssignFirstParameters(mg2)
mg2 = mxRun(mg2)

mxCompare(mg, mg2)
# ouch... that was a significant loss in fit: the residuals definately are larger in group2!

</code></pre>

<hr>
<h2 id='mxFitFunctionR'>Create MxFitFunctionR Object</h2><span id='topic+mxFitFunctionR'></span><span id='topic+MxFitFunctionR-class'></span><span id='topic+print+2CMxFitFunctionR-method'></span><span id='topic+show+2CMxFitFunctionR-method'></span>

<h3>Description</h3>

<p>mxFitFunctionR returns an MxFitFunctionR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionR(fitfun, ..., units="-2lnL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionR_+3A_fitfun">fitfun</code></td>
<td>
<p>A function that accepts two arguments.</p>
</td></tr>
<tr><td><code id="mxFitFunctionR_+3A_...">...</code></td>
<td>
<p>The initial state information to the objective function.</p>
</td></tr>
<tr><td><code id="mxFitFunctionR_+3A_units">units</code></td>
<td>
<p>(optional) The units of the fit statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxFitFunctionR function evaluates a user-defined R function called the 'fitfun'.  mxFitFunctionR is useful in defining new mxFitFunctions, since any calculation that can be performed in R can be treated as an mxFitFunction.
</p>
<p>The 'fitfun' argument must be a function that accepts two arguments. The first argument
is the mxModel that should be evaluated, and the second argument is some persistent 
state information that can be stored between one iteration of optimization to the next
iteration. It is valid for the function to simply ignore the second argument.
</p>
<p>The function must return either a single numeric value, or a list of exactly two elements.
If the function returns a list, the first argument must be a single numeric value and the 
second element will be the new persistent state information to be passed into this function
at the next iteration. The single numeric value will be used by the optimizer to perform
optimization.
</p>
<p>The initial default value for the persistent state information is NA.
</p>
<p>Throwing an exception (via stop) from inside fitfun may result
in unpredictable behavior. You may want to wrap your code in
tryCatch while experimenting.
</p>
<p>fitfun should not call R functions that use OpenMx's compiled backend, including (but not limited to) <code><a href="#topic+omxMnor">omxMnor</a>()</code>, because doing so can crash R.
</p>


<h3>Value</h3>

<p>Returns an MxFitFunctionR object. 
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>, <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>, 
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>, 
<code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>, 
<code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxFitFunctionR

library(OpenMx)

A &lt;- mxMatrix(nrow = 2, ncol = 2, values = c(1:4), free = TRUE, name = 'A')
squared &lt;- function(x) { x ^ 2 }

# Define the objective function in R

objFunction &lt;- function(model, state) {
    values &lt;- model$A$values 
    return(squared(values[1,1] - 4) + squared(values[1,2] - 3) +
        squared(values[2,1] - 2) + squared(values[2,2] - 1))
}

# Define the expectation function

fitFunction &lt;- mxFitFunctionR(objFunction)

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", A, fitFunction)

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)

</code></pre>

<hr>
<h2 id='mxFitFunctionRow'>Create an MxFitFunctionRow Object</h2><span id='topic+mxFitFunctionRow'></span><span id='topic+MxFitFunctionRow-class'></span><span id='topic+print+2CMxFitFunctionRow-method'></span><span id='topic+show+2CMxFitFunctionRow-method'></span>

<h3>Description</h3>

<p>mxFitFunctionRow returns an MxFitFunctionRow object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionRow(rowAlgebra, reduceAlgebra, dimnames,
   rowResults = "rowResults", filteredDataRow = "filteredDataRow",
   existenceVector = "existenceVector", units="-2lnL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionRow_+3A_rowalgebra">rowAlgebra</code></td>
<td>
<p>A character string indicating the name of the algebra to be evaluated row-wise.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_reducealgebra">reduceAlgebra</code></td>
<td>
<p>A character string indicating the name of the algebra that collapses the row results into a single number which is then optimized.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_dimnames">dimnames</code></td>
<td>
<p>A character vector of names corresponding to columns be extracted from the data set.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_rowresults">rowResults</code></td>
<td>
<p>The name of the auto-generated &quot;rowResults&quot; matrix.  See details.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_filtereddatarow">filteredDataRow</code></td>
<td>
<p>The name of the auto-generated &quot;filteredDataRow&quot; matrix. See details.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_existencevector">existenceVector</code></td>
<td>
<p>The name of the auto-generated &quot;existenceVector&quot; matrix. See details.</p>
</td></tr>
<tr><td><code id="mxFitFunctionRow_+3A_units">units</code></td>
<td>
<p>(optional) The units of the fit statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit functions are functions for which free parameter values are optimized such that the value of a cost function is minimized.  The mxFitFunctionRow function evaluates a user-defined <a href="#topic+MxAlgebra">MxAlgebra</a> object called the &lsquo;rowAlgebra&rsquo; in a row-wise fashion.  It then stores results of the row-wise evaluation in another <a href="#topic+MxAlgebra">MxAlgebra</a> object called the &lsquo;rowResults&rsquo;.  Finally, the mxFitFunctionRow function collapses the row results into a single number which is then used for optimization.  The <a href="#topic+MxAlgebra">MxAlgebra</a> object named by the &lsquo;reduceAlgebra&rsquo; collapses the row results into a single number.
</p>
<p>The &lsquo;filteredDataRow&rsquo; is populated in a row-by-row fashion with all the non-missing data from the current row.  You cannot assume that the length of the filteredDataRow matrix remains constant (unless you have no missing data). The &lsquo;existenceVector&rsquo; is populated in a row-by-row fashion with a value of 1.0 in column j if a non-missing value is present in the data set in column j, and a value of 0.0 otherwise. Use the functions <a href="#topic+omxSelectRows">omxSelectRows</a>, <a href="#topic+omxSelectCols">omxSelectCols</a>, and <a href="#topic+omxSelectRowsAndCols">omxSelectRowsAndCols</a> to shrink other matrices so that their dimensions will be conformable to the size of &lsquo;filteredDataRow&rsquo;. 
</p>


<h3>Value</h3>

<p>Returns a new MxFitFunctionRow object. Only one MxFitFunction object should be included in each model.  There is no need for an MxExpectation object when using mxFitFunctionRow.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>, <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>, 
<code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code>, <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>, 
<code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>, <code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code> 
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Model that adds two data columns row-wise, then sums that column
# Notice no optimization is performed here.

library(OpenMx)

xdat &lt;- data.frame(a=rnorm(10), b=1:10) # Make data set
amod &lt;- mxModel(model="example1",
            mxData(observed=xdat, type='raw'),
            mxAlgebra(sum(filteredDataRow), name = 'rowAlgebra'),
            mxAlgebra(sum(rowResults), name = 'reduceAlgebra'),
            mxFitFunctionRow(
                rowAlgebra='rowAlgebra',
                reduceAlgebra='reduceAlgebra',
                dimnames=c('a','b'))
)
amodOut &lt;- mxRun(amod)
mxEval(rowResults, model=amodOut)
mxEval(reduceAlgebra, model=amodOut)

# Model that find the parameter that minimizes the sum of the
#  squared difference between the parameter and a data row.

bmod &lt;- mxModel(model="example2",
            mxData(observed=xdat, type='raw'),
            mxMatrix(values=.75, ncol=1, nrow=1, free=TRUE, name='B'),
            mxAlgebra((filteredDataRow - B) ^ 2, name='rowAlgebra'),
            mxAlgebra(sum(rowResults), name='reduceAlgebra'),
            mxFitFunctionRow(
                rowAlgebra='rowAlgebra',
                reduceAlgebra='reduceAlgebra',
                dimnames=c('a'))
)
bmodOut &lt;- mxRun(bmod)
mxEval(B, model=bmodOut)
mxEval(reduceAlgebra, model=bmodOut)
mxEval(rowResults, model=bmodOut)
</code></pre>

<hr>
<h2 id='mxFitFunctionWLS'>Create MxFitFunctionWLS Object</h2><span id='topic+mxFitFunctionWLS'></span><span id='topic+MxFitFunctionWLS-class'></span><span id='topic+print+2CMxFitFunctionWLS-method'></span><span id='topic+show+2CMxFitFunctionWLS-method'></span>

<h3>Description</h3>

<p>This function creates a new MxFitFunctionWLS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxFitFunctionWLS(type=c('WLS','DWLS','ULS'),
			     allContinuousMethod=c("cumulants", "marginals"),
			     fullWeight=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxFitFunctionWLS_+3A_type">type</code></td>
<td>
<p>A character string 'WLS' (default), 'DWLS', or 'ULS' for weighted, diagonally weighted, or unweighted least squares, respectively</p>
</td></tr>
<tr><td><code id="mxFitFunctionWLS_+3A_allcontinuousmethod">allContinuousMethod</code></td>
<td>
<p>A character string 'cumulants' (default) or 'marginals'. See Details.</p>
</td></tr>
<tr><td><code id="mxFitFunctionWLS_+3A_fullweight">fullWeight</code></td>
<td>
<p>Logical determining if the full weight matrix is returned (default). Needed for standard error and quasi-chi-squared calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with other fit functions, <code>mxFitFunctionWLS</code> optimizes free parameter values such that the value of a cost function is minimized. For <code>mxFitFunctionWLS</code>, this cost function is the weighted least squares difference between the data and the model-implied expectations for the data based on the free parameters and the expectation function (e.g., <code><a href="#topic+mxExpectationNormal">mxExpectationNormal</a></code> or <code><a href="#topic+mxExpectationRAM">mxExpectationRAM</a></code>) selected for the model.
</p>
<p><strong>Bias and sensitivity to model misspecification</strong>
Both ordinal and continuous data are supported, as well as combinations of these data types. All three methods ('WLS', 'ULS' and 'DWLS') are unbiased when the model is correct. Full 'WLS' is highly sensitive to model misspecification  it can heavily weight the fourth-order moments of the distribution, so small deviations between the observed fourth-order moments and those implied by the model can lead to poor estimates.
</p>
<p><strong>Behavior with all-continuous data</strong>
When only continuous variables are present, the argument <code>allContinuousMethod</code> dictates how to process the data.
</p>
<p>The default, <em>cumulants</em> is a good choice for non-normal data. This uses the asymptotically distribution free (ADF) method of Browne (1984) and computes the fourth order <em>cumulants</em> for the weight matrix: thus, the name. It is generally fast and ADF up to elliptical distributions. Data computed using cumulants should also be more accurate than via marginals (because the whole covariance is a single analytic expression, with no estimation involved).
</p>
<p><em>note</em>: The <em>cumulants</em> method does not handle missing data. It also does not return weights or summary statistics for the means.
</p>
<p>The alternative option, 'marginals', uses methods similar to those used in processing ordinal and joint ordinal-continuous data.  By contrast with cumulants, marginals returns weights and summary statistics for the means.
</p>
<p>When data are not all continuous, <code>allContinuousMethod</code> is ignored, and means are modelled.
</p>
<p><em>Usage Notes</em>:
</p>
<p>Model results can be reported using the <a href="base.html#topic+summary">summary</a> function, or accessed directly in the 'output' slot of the model (i.e., <code>model$output</code>). Components of the output may also be accessed and used in the same way, i.e., via the <code>$</code> and <code>[]</code> <code><a href="base.html#topic+Extract">Extract</a></code> functions.
</p>
<p>Summary statistics are returned in the MxData object in an
<code>observedStats</code> list. If <code>observedStats</code> are already present
and in the appropriate shape then they are reused. It is also possible
to provide your own arbitrary user supplied observed statistics using
this same approach.
</p>


<h3>Value</h3>

<p>Returns a new MxFitFunctionWLS object. One and only one fit function object should be included in each model, along with an associated <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> or <code><a href="#topic+mxExpectationRAM">mxExpectationRAM</a></code> object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>
<p>Browne, M. W. (1984). Asymptotically distribution-free methods for the analysis of covariance structures. <em>British Journal of Mathematical and Statistical Psychology</em>, <strong>37</strong>, 62-83.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>, <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>,
<code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>, <code><a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a></code>,
<code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code>, <code><a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a></code>
</p>
<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a WLS model using RAM, and then using matrices.

library(OpenMx)

# Simulate some data where y = .5x + error

x = rnorm(1000, mean = 0, sd = 1)
y = 0.5*x + rnorm(1000, mean = 0, sd = 1)
tmpFrame = data.frame(x, y)
varNames = names(tmpFrame)

# =======================
# = A RAM model example =
# =======================

m1 = mxModel("my_first_WLS", type = "RAM",
	manifestVars = c("x", "y"),
	mxPath(c("x", "y"), arrows = 2, values = 1, labels = c("xVar", "yVar")),
	mxPath("x", to = "y", labels = "x_to_y"),
	mxFitFunctionWLS(),
	mxData(tmpFrame, 'raw')
)

m1 = mxRun(m1)
summary(m1)$parameters

# Here are the cov, acov and Weight matrices:
print(m1$data$observedStats)

# Use a different weight matrix
m2 = m1
os &lt;- m1$data$observedStats
os$asymCov &lt;- solve(rWishart(n=1, df= nrow(tmpFrame), Sigma= diag(3))[,,1])
os$useWeight &lt;- solve(os$asymCov * nrow(tmpFrame))
m2$data$observedStats &lt;- os

# Set verbose to check if our new weights are used
m2$data$verbose &lt;- 1L

# Run model
m2 &lt;- mxRun(m2)

# SE indeed changed due to new weights
print(m2$output$standardErrors - m1$output$standardErrors)

# ==========================
# = A matrix-based example =
# ==========================

# Define matrices for Symmetric (S) and Asymmetric (A) paths and an Identity matrix.

S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1),
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0),
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA), name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Build the model

tmpModel &lt;- mxModel(model="exampleModel",
	# Add the S, A, and I matrices constructed above
	S, A, I,

	# Define the expectation
	mxAlgebra(name="expCov", solve(I-A) %*% S %*% t(solve(I-A))),

	# Choose a normal expectation and WLS as the fit function
	mxExpectationNormal(covariance= "expCov", dimnames= varNames),
	mxFitFunctionWLS(),

   # Add the data
	mxData(tmpFrame, 'raw')
)

# Fit the model and print a summary
tmpModel &lt;- mxRun(tmpModel)
summary(tmpModel)

</code></pre>

<hr>
<h2 id='MxFlatModel-class'>MxFlatModel</h2><span id='topic+MxFlatModel-class'></span><span id='topic++24+2CMxFlatModel-method'></span><span id='topic++24+3C-+2CMxFlatModel-method'></span><span id='topic++5B+5B+2CMxFlatModel-method'></span><span id='topic++5B+5B+3C-+2CMxFlatModel-method'></span><span id='topic+print+2CMxFlatModel-method'></span><span id='topic+show+2CMxFlatModel-method'></span><span id='topic+names+2CMxFlatModel-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used.
</p>

<hr>
<h2 id='mxGenerateData'>Generate data based on an mxModel (or a data.frame)</h2><span id='topic+mxGenerateData'></span>

<h3>Description</h3>

<p>This function returns a new (simulated) data set based on either the model-implied distribution if
a model is provided, OR saturated model if a data.frame is given in the model parameter.
</p>
<p>See below for important details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxGenerateData(model, nrows, returnModel=FALSE, use.miss = TRUE,
 ..., .backend=TRUE, subname=NULL, empirical=FALSE, nrowsProportion,
 silent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxGenerateData_+3A_model">model</code></td>
<td>
<p>A data.frame or MxModel object upon which the data are generated.</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_nrows">nrows</code></td>
<td>
<p>Numeric. The number of rows of data to generate (default = same as in the original data)</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_returnmodel">returnModel</code></td>
<td>
<p> Whether to return the model with new data, or just return the new data.frames (default)</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_use.miss">use.miss</code></td>
<td>
<p> Whether to approximate the missingness pattern of the original data (TRUE by default).</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_...">...</code></td>
<td>
<p>Not used; forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_.backend">.backend</code></td>
<td>
<p>Whether to use the backend to generate data (TRUE by default for speed)</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_subname">subname</code></td>
<td>
<p>If given, limits data generation to this sub model.</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_empirical">empirical</code></td>
<td>
<p>Whether the generate data should match the distribution
of the current data exactly. Uses <a href="MASS.html#topic+mvrnorm">mvrnorm</a> instead of
<a href="mvtnorm.html#topic+rmvnorm">rmvnorm</a></p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_nrowsproportion">nrowsProportion</code></td>
<td>
<p>Numeric. The number of rows of data to generate
expressed as a proportion of the current number of rows.</p>
</td></tr>
<tr><td><code id="mxGenerateData_+3A_silent">silent</code></td>
<td>
<p>Logical. Whether to report progress during time consuming
data generation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When given a data.frame as a model, the model is assumed to be
saturated multivariate Gaussian and the expected distribution
is obtained using <a href="#topic+mxDataWLS">mxDataWLS</a>.  In this case, the default number of rows is assumed to be the number of rows in the original data.frame, but any other number of rows can also be requested.
</p>
<p>When given an MxModel,
the model-implied means and covariance are extracted.  It then generates data with the same mean and covariance.  Data can be generated based on Normal (<a href="#topic+mxExpectationNormal">mxExpectationNormal</a>), RAM (<a href="#topic+mxExpectationRAM">mxExpectationRAM</a>), LISREL (<a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a>), and state space (<a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a>) models.
</p>
<p>Please note that this function samples data from the model-implied distribution(s); it does not sample from the data object in the model.  That is, this function generates new data rather than pulling data that already exist from the model.
</p>
<p>Thresholds and ordinal data are implemented by generating continuous data and then using <a href="base.html#topic+cut">cut</a> and <a href="#topic+mxFactor">mxFactor</a> to break the continuous data at the thresholds into an ordered factor.
</p>
<p>If the model has definition variables, then a data set must be included in the model object and the number of rows requested must match the number of rows in the model data.  In this case the means, covariance, and thresholds are reevaluated for each row of data, potentially creating a a different mean, covariance, and threshold structure for every generated row of data.
</p>
<p>For state space models (i.e. models with an <a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a> or <a href="#topic+mxExpectationStateSpaceContinuousTime">mxExpectationStateSpaceContinuousTime</a> expectation), the data are generated based on the autoregressive structure of the model.  The rows of data in a state space model are not independent replicates of a stationary process.  Rather, they are the result of a latent (possibly non-stationary) autoregressive process.  For state space models different rows of data often correspond to different times.  As alluded to above, data generation works for discrete time state space models and hybrid continuous-discrete time state space models.  The latter have a continuous process that is measured as discrete times.
</p>
<p>The <code>subname</code> parameter is used to limit data generation to
the given submodel. The reason you wouldn't pass the submodel in
the <code>model</code> argument is that some parts of the submodel might
depend on objects in other submodels that are part of the model.
</p>


<h3>Value</h3>

<p>A data.frame, list of data.frames, or model populated with the new data
(depending on the <code>returnModel</code> parameter).
Raw data is always returned even if the original model contained
covariance or some other non-raw data.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ====================================
# = Demonstration for empirical=TRUE =
# ====================================
popCov &lt;- cov(Bollen[, 1:8])*(nrow(Bollen)-1)/nrow(Bollen)
got &lt;- mxGenerateData(Bollen[, 1:8], nrows=nrow(Bollen), empirical = TRUE)
cov(got) - popCov  # pretty close, given 8 variables to juggle!
round(cov2cor(cov(got)) - cov2cor(popCov), 4)

# ===========================================
# = Create data based on state space model. =
# ===========================================

require(OpenMx)
nvar &lt;- 5
varnames &lt;- paste("x", 1:nvar, sep="")
ssModel &lt;- mxModel(model="State Space Manual Example",
    mxMatrix("Full", 1, 1, TRUE, .3, name="A"),
    mxMatrix("Zero", 1, 1, name="B"),
    mxMatrix("Full", nvar, 1, TRUE, .6, name="C", dimnames=list(varnames, "F1")),
    mxMatrix("Zero", nvar, 1, name="D"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="Q"),
    mxMatrix("Diag", nvar, nvar, TRUE, .2, name="R"),
    mxMatrix("Zero", 1, 1, name="x0"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="P0"),
    mxMatrix("Zero", 1, 1, name="u"),
    mxExpectationStateSpace("A", "B", "C", "D", "Q", "R", "x0", "P0", "u"),
    mxFitFunctionML()
)

ssData &lt;- mxGenerateData(ssModel, 200) # 200 time points

# Add simulated data to model and run
ssModel &lt;- mxModel(ssModel, mxData(ssData, 'raw'))
ssRun &lt;- mxRun(ssModel)

# Compare parameters from random data to the generating model
cbind(Rand = omxGetParameters(ssRun), Gen = omxGetParameters(ssModel))

# Note the parameters should be "close" (up to sampling error)
# to the generating values


# =========================================
# = Demo generating new data from a model =
# =========================================
require(OpenMx)
manifests &lt;- paste0("x", 1:5)
originalModel &lt;- mxModel("One Factor", type="RAM",
      manifestVars = manifests,
      latentVars = "G",
      mxPath(from="G", to=manifests, values=.8),
      mxPath(from=manifests, arrows=2, values=.2),
      mxPath(from="G"  , arrows=2, free=FALSE, values=1.0),
      mxPath(from = 'one', to = manifests)
)

factorData &lt;- mxGenerateData(originalModel, 1000)
newData = mxData(cov(factorData), type="cov",
	numObs=nrow(factorData), means = colMeans(factorData)
)
newModel &lt;- mxModel(originalModel, newData)
newModel &lt;- mxRun(newModel)
cbind(
	Original = omxGetParameters(originalModel),
	Generated = round(omxGetParameters(newModel), 4),
	Delta = round(
		omxGetParameters(originalModel) -
		omxGetParameters(newModel), 3)
)

# And again with empirical = TRUE

factorData &lt;- mxGenerateData(originalModel, 1000, empirical = TRUE)
newData = mxData(cov(factorData),
	type = "cov",
	numObs = nrow(factorData),
	means = colMeans(factorData)
)

newModel &lt;- mxModel(originalModel, newData)
newModel &lt;- mxRun(newModel)

cbind(
	Original  = omxGetParameters(originalModel),
	Generated = round(omxGetParameters(newModel), 4),
	Delta     = omxGetParameters(originalModel) -
		 	    omxGetParameters(newModel)
)

</code></pre>

<hr>
<h2 id='mxGetExpected'>Extract the component from a model's expectation</h2><span id='topic+mxGetExpected'></span><span id='topic+imxGetExpectationComponent'></span>

<h3>Description</h3>

<p>This function extracts the expected means, covariance, or thresholds from a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxGetExpected(model, component, defvar.row=1, subname=model$name)
imxGetExpectationComponent(model, component, defvar.row=1, subname=model$name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxGetExpected_+3A_model">model</code></td>
<td>
<p>MxModel object from which to extract the expectation component.</p>
</td></tr>
<tr><td><code id="mxGetExpected_+3A_component">component</code></td>
<td>
<p>Character vector. The name(s) of the component(s) to extract.  Recognized names are &ldquo;covariance&rdquo;, &ldquo;means&rdquo;, and &ldquo;thresholds&rdquo;.</p>
</td></tr>
<tr><td><code id="mxGetExpected_+3A_defvar.row">defvar.row</code></td>
<td>
<p>A row index. Which row to load for definition variables.</p>
</td></tr>
<tr><td><code id="mxGetExpected_+3A_subname">subname</code></td>
<td>
<p>Name of the submodel to evaluate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected means, covariance, or thresholds can be extracted from
Normal (<a href="#topic+mxExpectationNormal">mxExpectationNormal</a>), RAM (<a href="#topic+mxExpectationRAM">mxExpectationRAM</a>), and
LISREL (<a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a>) models. When more than one component
is requested, the components will be returned as a list.
</p>
<p>If component 'vector' is requested then the non-redundant coefficients
of the expected manifest distribution will be returned as a vector.
</p>
<p>If component 'standVector' is requested then the same parameter structure as
'vector' is returned, but it is standardized.  For Normal expectations the covariances
are returned as correlations, the means are returned as zeros, and the
thresholds are returned as z-scores.  For the thresholds the z-scores
are computed by using the model-implied means and variances.
</p>
<p>Note that capitalization is ignored for the 'standVector' option, so 'standvector'
is also acceptable.
</p>


<h3>Value</h3>

<p>See details.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# ===============================================
# = Build a 1-factor CFA, with bad start values =
# ===============================================
require(OpenMx)
manifests = paste("x", 1:5, sep="")
latents = c("G")
factorModel = mxModel("One Factor", type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from = latents, to = manifests),
      mxPath(from = manifests, arrows = 2),
      mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
      mxPath(from = 'one', to = manifests),
	  mxData(demoOneFactor, type = "raw")
)

# ============================================================================
# = What do our starting values indicate about the expected data covariance? =
# ============================================================================
mxGetExpected(factorModel, "covariance")

# Oops. Starting values indicate an expected zero-covariance matrix.
# The model likely won't run from these start values.
# Let's adjust them:

factorModel = mxModel("One Factor", type = "RAM",
      manifestVars = manifests, latentVars = latents,
      # Reasonable start VALUES
	  mxPath(from = latents, to = manifests, values = .2),
      mxPath(from = manifests, arrows = 2),
      mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
      mxPath(from = 'one', to = manifests),
	  mxData(demoOneFactor, type = "raw")
)

mxGetExpected(factorModel, "covariance")
#      x1   x2   x3   x4   x5
# x1 0.04 0.04 0.04 0.04 0.04
# x2 0.04 0.04 0.04 0.04 0.04
# x3 0.04 0.04 0.04 0.04 0.04
# x4 0.04 0.04 0.04 0.04 0.04
# x5 0.04 0.04 0.04 0.04 0.04

# And this version will run:
factorModel = mxRun(factorModel)

</code></pre>

<hr>
<h2 id='mxGREMLDataHandler'>
Helper Function for Structuring GREML Data 
</h2><span id='topic+mxGREMLDataHandler'></span>

<h3>Description</h3>

<p>This function takes a dataframe or matrix and uses it to setup the 'y' and 'X' matrices for a GREML analysis; this includes trimming out <code>NA</code>s from 'X' and 'y.'  The result is a matrix the first column of which is the 'y' vector, and the remaining columns of which constitute 'X.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxGREMLDataHandler(data, yvars=character(0), Xvars=list(), addOnes=TRUE, 
                  blockByPheno=TRUE, staggerZeroes=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxGREMLDataHandler_+3A_data">data</code></td>
<td>
<p>Either a dataframe or matrix, with column names, containing the variables to be used as phenotypes and covariates in 'y' and 'X,' respectively.</p>
</td></tr>
<tr><td><code id="mxGREMLDataHandler_+3A_yvars">yvars</code></td>
<td>
<p>Character vector.  Each string names a column of the raw dataset, to be used as a phenotype.</p>
</td></tr>
<tr><td><code id="mxGREMLDataHandler_+3A_xvars">Xvars</code></td>
<td>
<p>A list of data column names, specifying the covariates to be used with each phenotype.  The list should have the same length as argument <code>yvars</code>.</p>
</td></tr>
<tr><td><code id="mxGREMLDataHandler_+3A_addones">addOnes</code></td>
<td>
<p>Logical; should lead columns of ones (for the regression intercepts) be adhered to the covariates when assembling the 'X' matrix?  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mxGREMLDataHandler_+3A_blockbypheno">blockByPheno</code></td>
<td>
<p>Logical; relevant to polyphenotype analyses.  If <code>TRUE</code> (default), then the resulting 'y' will contain phenotype #1 for individuals 1 thru <em>n</em>, phenotype #2 for individuals 1 thru <em>n</em>, ...  If <code>FALSE</code>, then observations are &quot;blocked by individual&quot;, and the resulting 'y' will contain individual #1's scores on phenotypes 1 thru <em>p</em>, individual #2's scores on phenotypes 1 thru <em>p</em>, ...  Note that in either case, 'X' will be structured appropriately for 'y.'</p>
</td></tr>
<tr><td><code id="mxGREMLDataHandler_+3A_staggerzeroes">staggerZeroes</code></td>
<td>
<p>Logical; relevant to polyphenotype analyses.  If <code>TRUE</code> (default), then each phenotype's covariates in 'X' are &quot;staggered,&quot; and 'X' is padded out with zeroes.  If <code>FALSE</code>, then 'X' is formed simply by stacking the phenotypes' covariates; this requires each phenotype to have the same number of covariates (i.e., each character vector in <code>Xvars</code> must be of the same length).  The default (<code>TRUE</code>) is intended for instances where the multiple phenotypes truly are different variables, whereas <code>staggerZeroes=FALSE</code> is intended for instances where the multiple &quot;phenotypes&quot; actually represent multiple observations on the same variable.  One example of the latter case is longitudinal data where the multiple &quot;phenotypes&quot; are repeated measures on a single phenotype.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a monophenotype analysis (only), argument <code>Xdata</code> can be a character vector.  In a polyphenotype analysis, if the same covariates are to be used with all phenotypes, then <code>Xdata</code> can be a list of length 1.
</p>
<p>Note the synergy between the output of <code>mxGREMLDataHandler()</code> and arguments <code>dataset.is.yX</code> and <code>casesToDropFromV</code> to <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.
</p>
<p>If the dataframe or matrix supplied for argument <code>data</code> has <em>n</em> rows, and argument <code>yvars</code> is of length <em>p</em>, then the resulting 'y' and 'X' matrices will have <em>np</em> rows.  Then, if either matrix contains any <code>NA</code>'s, the rows containing the <code>NA</code>'s are trimmed from both 'X' and 'y' before being returned in the output (in which case they will obviously have fewer than <em>np</em> rows).  Function <code>mxGREMLDataHandler()</code> reports which rows of the full-size 'X' and 'y' were trimmed out due to missing observations.  These row indices can be provided as argument <code>casesToDropFromV</code> to <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.
</p>


<h3>Value</h3>

<p>A list with these two components:
</p>
<table>
<tr><td><code>yX</code></td>
<td>
<p>Numeric matrix.  The first column is the phenotype vector, 'y,' while the remaining columns constitute the 'X' matrix of covariates.  If this matrix is used as the raw dataset for a model, then the model's GREML expectation can be constructed with <code>dataset.is.yX=TRUE</code> in <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.</p>
</td></tr>
<tr><td><code>casesToDrop</code></td>
<td>
<p>Numeric vector.  Contains the indices of the rows of the 'y' and 'X' that were dropped due to containing <code>NA</code>'s.  Can be provided as as argument <code>casesToDropFromV</code> to <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>For more information generally concerning GREML analyses, including a complete example, see <code><a href="#topic+mxExpectationGREML">mxExpectationGREML</a>()</code>.  More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- cbind(rnorm(100),rep(1,100))
colnames(dat) &lt;- c("y","x")
dat[42,1] &lt;- NA
dat[57,2] &lt;- NA
dat2 &lt;- mxGREMLDataHandler(data=dat, yvars="y", Xvars=list("x"),
  addOnes = FALSE)
str(dat2)
</code></pre>

<hr>
<h2 id='MxInterval-class'>MxInterval</h2><span id='topic+MxInterval-class'></span><span id='topic++24+2CMxInterval-method'></span><span id='topic++24+3C-+2CMxInterval-method'></span><span id='topic+print+2CMxInterval-method'></span><span id='topic+show+2CMxInterval-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxCI">mxCI</a>
</p>

<hr>
<h2 id='mxJiggle'>
Jiggle parameter values.
</h2><span id='topic+mxJiggle'></span><span id='topic+imxJiggle'></span>

<h3>Description</h3>

<p>Jiggle free parameter values, subject to box constraints.  <code>imxJiggle()</code> is called internally by <code><a href="#topic+mxTryHard">mxTryHard</a>()</code> (q.v.).  <code>mxJiggle()</code> provides a more user-friendly wrapper to <code>imxJiggle()</code>, and can alternately emulate the 'JIGGLE' behavior of classic Mx.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxJiggle(model, classic=FALSE, dsn=c("runif","rnorm","rcauchy"), loc=1, scale=0.25)
imxJiggle(params, lbounds, ubounds, dsn, loc, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxJiggle_+3A_model">model</code></td>
<td>
<p>An object of class MxModel.</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_classic">classic</code></td>
<td>
<p>Logical; should <code>mxJiggle()</code> emulate the classic-Mx behavior elicited by keyword JIGGLE?  Defaults to <code>FALSE</code>.  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_dsn">dsn</code></td>
<td>
<p>Character string naming which random-number distribution&ndash;either <a href="stats.html#topic+runif">uniform (rectangular)</a>, <a href="stats.html#topic+rnorm">normal (Gaussian)</a>, or <a href="stats.html#topic+rcauchy">Cauchy</a>&ndash;to be used to perturb free-parameter values.  Defaults to the uniform distribution (for <code>mxJiggle()</code>).</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_loc">loc</code>, <code id="mxJiggle_+3A_scale">scale</code></td>
<td>
<p>Numeric. The location and scale parameters of the distribution from which random values are drawn to perturb free-parameter values, defaulting respectively to 1 and 0.25 (for <code>mxJiggle()</code>).</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_params">params</code></td>
<td>
<p>Numeric vector of current free parameter values.</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_lbounds">lbounds</code></td>
<td>
<p>Numeric vector of lower bounds on parameters.</p>
</td></tr>
<tr><td><code id="mxJiggle_+3A_ubounds">ubounds</code></td>
<td>
<p>Numeric vector of upper bounds on parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mxJiggle()</code> argument <code>classic=FALSE</code> (the default), <code>mxJiggle()</code> calls <code>imxJiggle()</code>.  In that case, <code>mxJiggle()</code> passes <code>imxJiggle()</code> its own values for arguments <code>dsn</code>, <code>loc</code>, and <code>scale</code>, and extracts values for arguments <code>params</code>, <code>lbounds</code>, and <code>ubounds</code> from <code>model</code>.  Then, <code>model</code>'s free-parameter values are randomly perturbed before being re-assigned to it.  The distributional family from which the perturbations are randomly generated is dictated by argument <code>dsn</code>.  The distribution is parameterized by arguments <code>loc</code> and <code>scale</code>, respectively the location and scale parameters.  The location parameter is the distribution's median.  For the uniform distribution, <code>scale</code> is the absolute difference between its median and extrema (i.e., half the width of the rectangle); for the normal distribution, <code>scale</code> is its standard deviation; and for the Cauchy, <code>scale</code> is one-half its interquartile range.  Free-parameter values are first multiplied by random draws from a distribution with the provided <code>loc</code> and <code>scale</code>, then added to random draws from a distribution with the same <code>scale</code> but with a median of zero.
</p>
<p>If <code>mxJiggle()</code> argument <code>classic=TRUE</code>, then each free-parameter value <code class="reqn">x_i</code> is replaced with <code class="reqn">x_i + 0.1(x_i + 0.5)</code>; this is the same behavior elicited in classic Mx by keyword JIGGLE.
</p>


<h3>Value</h3>

<p><code>imxJiggle()</code> returns a numeric vector of randomly perturbed free-parameter values.  <code>mxJiggle()</code> returns <code>model</code>, with its free parameter values altered according to the other function arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxTryHard">mxTryHard</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel(
	"One Factor",
	type="RAM",
	manifestVars = manifests,
	latentVars = latents,
	mxPath(from=latents, to=manifests,values=0.8),
	mxPath(from=manifests, arrows=2,values=1),
	mxPath(from=latents, arrows=2,
				 free=FALSE, values=1.0),
	mxData(cov(demoOneFactor), type="cov",
				 numObs=500)
)

iniPars &lt;- coef(factorModel)
print(iniPars)

pars2 &lt;- imxJiggle(params=iniPars,lbounds=NA,ubounds=NA,dsn="runif",loc=1,scale=0.05)
print(pars2)

mod2 &lt;- mxJiggle(model=factorModel,scale=0.05)
coef(mod2)

mod3 &lt;- mxJiggle(model=factorModel,classic=TRUE)
coef(mod3)
</code></pre>

<hr>
<h2 id='mxKalmanScores'>Estimate Kalman scores and error covariance matrices</h2><span id='topic+mxKalmanScores'></span>

<h3>Description</h3>

<p>This function creates the Kalman predicted, Kalman updated, and Rauch-Tung-Striebel smoothed latent state and error covariance estimates for an MxModel object that has an MxExpectationStateSpace object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxKalmanScores(model, data=NA, frontend=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxKalmanScores_+3A_model">model</code></td>
<td>
<p>An MxModel object with an MxExpectationStateSpace.</p>
</td></tr>
<tr><td><code id="mxKalmanScores_+3A_data">data</code></td>
<td>
<p>An optional data.frame or matrix.</p>
</td></tr>
<tr><td><code id="mxKalmanScores_+3A_frontend">frontend</code></td>
<td>
<p>When TRUE, compute score in the frontend, otherwise use the backend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function that computes the results of the classical Kalman filter.  In particular, for every row of data there is a predicted latent score, an error covariance matrix for the predicted latent scores that provides an estimate of the predictions precision, an updated latent score, and an updated error covariance matrix for the updated latent scores.  Additionally, the Rauch-Tung-Striebel (RTS) smoothed latent scores and error covariance matrices are returned.
</p>


<h3>Value</h3>

<p>A list with components xPredicted, PPredicted, xUpdated, PUpdated, xSmoothed, PSmoothed, m2ll, and L.  When using backend scores, this list also has components for yPredicted and SPredicted which have the same number of time points as the other components but relate to the observed variables instead of the latent variables.  The rows of xPredicted, xUpdated, and xSmoothed correspond to different time points.  The columns are the different latent variables.  The third index of PPredicted, PUpdated, and PSmoothed corresponds to different times.  This works nicely with the R default print method for arrays.  At each time there is a covariance matrix of the latent variable scores.  For all items listed below, the first element goes with the zeroth time point (See example).
</p>

<dl>
<dt>xPredicted</dt><dd><p>matrix of Kalman predicted scores</p>
</dd>
<dt>PPredicted</dt><dd><p>array of Kalman predicted error covariances</p>
</dd>
<dt>xUpdated</dt><dd><p>matrix of Kalman updated scores</p>
</dd>
<dt>PUpdated</dt><dd><p>array of Kalman updated error covariances</p>
</dd>
<dt>xSmoothed</dt><dd><p>matrix of RTS smoothed scores</p>
</dd>
<dt>PSmoothed</dt><dd><p>array of RTS smoothed error covariances</p>
</dd>
<dt>m2ll</dt><dd><p>minus 2 log likelihood</p>
</dd>
<dt>L</dt><dd><p>likelihood, i.e., the multivariate normal probability density</p>
</dd>
<dt>yPredicted</dt><dd><p>matrix of Kalman predicted scores for the observed variables, i.e., the predicted means.  Only available for backend scores.</p>
</dd>
<dt>SPredicted</dt><dd><p>array of Kalman predicted error covariances for the observed variables, i.e., the predicted covariances.  Only available for backend scores.</p>
</dd>
</dl>



<h3>References</h3>

<p>J. Durbin and S.J. Koopman.  (2001).  <em>Time Series Analysis by State Space Methods</em>. Oxford University Press.
</p>
<p>R.E. Kalman  (1960).  A New Approach to Linear Filtering and Prediction Problems.  <em>Basic Engineering, 82</em>, 35-45.
</p>
<p>H.E. Rauch, F. Tung, C.T. Striebel.  (1965).  Maximum Likelihood Estimates of Linear Dynamic Systems.   <em>American Institute of Aeronautics and Astronautics Journal, 3</em>, 1445-1450.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# Create and fit a model using mxMatrix, mxExpectationStateSpace, and mxFitFunctionML
require(OpenMx)
data(demoOneFactor)
# Use only first 50 rows, for speed of example
data &lt;- demoOneFactor[1:50,]
nvar &lt;- ncol(demoOneFactor)
varnames &lt;- colnames(demoOneFactor)
ssModel &lt;- mxModel(model="State Space Manual Example",
    mxMatrix("Full", 1, 1, TRUE, .3, name="A"),
    mxMatrix("Zero", 1, 1, name="B"),
    mxMatrix("Full", nvar, 1, TRUE, .6, name="C", dimnames=list(varnames, "F1")),
    mxMatrix("Zero", nvar, 1, name="D"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="Q"),
    mxMatrix("Diag", nvar, nvar, TRUE, .2, name="R"),
    mxMatrix("Zero", 1, 1, name="x0"),
    mxMatrix("Diag", 1, 1, FALSE, 1, name="P0"),
    mxMatrix("Zero", 1, 1, name="u"),
    mxData(observed=data, type="raw"),
    mxExpectationStateSpace("A", "B", "C", "D", "Q", "R", "x0", "P0", "u"),
    mxFitFunctionML()
)
ssRun &lt;- mxRun(ssModel)
summary(ssRun)
# Note the freely estimated Autoregressive parameter (A matrix)
#  is near zero as it should be for the independent rows of data
#  from the factor model.

ssScores &lt;- mxKalmanScores(ssRun)

cor(cbind(ssScores$xPredicted[,1], ssScores$xUpdated[,1], ssScores$xSmoothed[,1]))
# Because the autoregressive dynamics are near zero, the predicted and updated scores
# correlate minimally, and the updated and smoothed latent state estimates
# are extremely close.

# The first few latent predicted scores
head(ssScores$xPredicted)

# The predicted latent score for time 10
ssScores$xPredicted[10+1,]

# The error covariance of the predicted score at time 10
ssScores$PPredicted[,,10+1]

</code></pre>

<hr>
<h2 id='MxLISRELModel-class'>MxLISRELModel</h2><span id='topic+MxLISRELModel-class'></span><span id='topic++24+3C-+2CMxLISRELModel-method'></span><span id='topic++5B+5B+3C-+2CMxLISRELModel-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxLISRELObjective'>Create MxLISRELObjective Object</h2><span id='topic+mxLISRELObjective'></span>

<h3>Description</h3>

<p>This function creates a new MxLISRELObjective object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxLISRELObjective(LX=NA, LY=NA, BE=NA, GA=NA, PH=NA, PS=NA, TD=NA, TE=NA, TH=NA,
   TX = NA, TY = NA, KA = NA, AL = NA,
   dimnames = NA, thresholds = NA, vector = FALSE, threshnames = dimnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxLISRELObjective_+3A_lx">LX</code></td>
<td>
<p>An optional character string indicating the name of the 'LX' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ly">LY</code></td>
<td>
<p>An optional character string indicating the name of the 'LY' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_be">BE</code></td>
<td>
<p>An optional character string indicating the name of the 'BE' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ga">GA</code></td>
<td>
<p>An optional character string indicating the name of the 'GA' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ph">PH</code></td>
<td>
<p>An optional character string indicating the name of the 'PH' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ps">PS</code></td>
<td>
<p>An optional character string indicating the name of the 'PS' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_td">TD</code></td>
<td>
<p>An optional character string indicating the name of the 'TD' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_te">TE</code></td>
<td>
<p>An optional character string indicating the name of the 'TE' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_th">TH</code></td>
<td>
<p>An optional character string indicating the name of the 'TH' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_tx">TX</code></td>
<td>
<p>An optional character string indicating the name of the 'TX' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ty">TY</code></td>
<td>
<p>An optional character string indicating the name of the 'TY' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_ka">KA</code></td>
<td>
<p>An optional character string indicating the name of the 'KA' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_al">AL</code></td>
<td>
<p>An optional character string indicating the name of the 'AL' matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector that is currently ignored</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_vector">vector</code></td>
<td>
<p>A logical value indicating whether the objective function result is the likelihood vector.</p>
</td></tr>
<tr><td><code id="mxLISRELObjective_+3A_threshnames">threshnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the thresholds matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objective functions are functions for which free parameter values are chosen such that the value of the objective function is minimized. The mxLISRELObjective provides maximum likelihood estimates of free parameters in a model of the covariance of a given <a href="#topic+MxData">MxData</a> object. This model is defined by LInear Structural RELations (LISREL; J&ouml;reskog &amp; S&ouml;rbom, 1982, 1996).  Arguments 'LX' through 'AL' must refer to <a href="#topic+MxMatrix">MxMatrix</a> objects with the associated properties of their respective matrices in the LISREL modeling approach.
</p>
<p>The full LISREL specification has 13 matrices and is sometimes called the extended LISREL model.  It is defined by the following equations.
</p>
<p style="text-align: center;"><code class="reqn">\eta = \alpha + B \eta + \Gamma \xi + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \tau_y + \Lambda_y \eta + \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">x = \tau_x + \Lambda_x \xi + \delta</code>
</p>

<p>The table below is provided as a quick reference to the numerous matrices in LISREL models.  Note that NX is the number of manifest exogenous (independent) variables, the number of Xs.  NY is the number of manifest endogenous (dependent) variables, the number of Ys.  NK is the number of latent exogenous variables, the number of Ksis or Xis.  NE is the number of latent endogenous variables, the number of etas.
</p>

<table>
<tr>
 <td style="text-align: center;">
Matrix </td><td style="text-align: left;"> Word </td><td style="text-align: center;"> Abbreviation </td><td style="text-align: center;"> Dimensions </td><td style="text-align: center;"> Expression</td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Lambda_x</code> </td><td style="text-align: left;"> Lambda x </td><td style="text-align: center;"> LX </td><td style="text-align: center;"> NX x NK </td><td style="text-align: center;"> </td><td style="text-align: left;"> Exogenous Factor Loading Matrix </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Lambda_y</code> </td><td style="text-align: left;"> Lambda y </td><td style="text-align: center;"> LY </td><td style="text-align: center;"> NY x NE </td><td style="text-align: center;"> </td><td style="text-align: left;"> Endogenous Factor Loading Matrix</td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">B</code> </td><td style="text-align: left;"> Beta </td><td style="text-align: center;"> BE </td><td style="text-align: center;"> NE x NE </td><td style="text-align: center;"> </td><td style="text-align: left;"> Regressions of Latent Endogenous Variables Predicting Endogenous Variables</td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Gamma</code> </td><td style="text-align: left;"> Gamma </td><td style="text-align: center;"> GA </td><td style="text-align: center;"> NE x NK </td><td style="text-align: center;"> </td><td style="text-align: left;"> Regressions of Latent Exogenous Variables Predicting Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Phi</code> </td><td style="text-align: left;"> Phi </td><td style="text-align: center;"> PH </td><td style="text-align: center;"> NK x NK </td><td style="text-align: center;"> cov(<code class="reqn">\xi</code>) </td><td style="text-align: left;"> Covariance Matrix of Latent Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Psi</code> </td><td style="text-align: left;"> Psi </td><td style="text-align: center;"> PS </td><td style="text-align: center;"> NE x NE </td><td style="text-align: center;"> cov(<code class="reqn">\zeta</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Latent Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\delta}</code> </td><td style="text-align: left;"> Theta delta </td><td style="text-align: center;"> TD </td><td style="text-align: center;"> NX x NX </td><td style="text-align: center;"> cov(<code class="reqn">\delta</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\epsilon}</code> </td><td style="text-align: left;"> Theta epsilon </td><td style="text-align: center;"> TE </td><td style="text-align: center;"> NY x NY </td><td style="text-align: center;"> cov(<code class="reqn">\epsilon</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\Theta_{\delta \epsilon}</code> </td><td style="text-align: left;"> Theta delta epsilson </td><td style="text-align: center;"> TH </td><td style="text-align: center;"> NX x NY </td><td style="text-align: center;"> cov(<code class="reqn">\delta, \epsilon</code>) </td><td style="text-align: left;"> Residual Covariance Matrix of Manifest Exogenous with Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\tau_x</code> </td><td style="text-align: left;"> tau x </td><td style="text-align: center;"> TX </td><td style="text-align: center;"> NX x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Manifest Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\tau_y</code> </td><td style="text-align: left;"> tau y </td><td style="text-align: center;"> TY </td><td style="text-align: center;"> NY x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Manifest Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\kappa</code> </td><td style="text-align: left;"> kappa </td><td style="text-align: center;"> KA </td><td style="text-align: center;"> NK x 1 </td><td style="text-align: center;"> mean(<code class="reqn">\xi</code>) </td><td style="text-align: left;"> Means of Latent Exogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
<code class="reqn">\alpha</code> </td><td style="text-align: left;"> alpha </td><td style="text-align: center;"> AL </td><td style="text-align: center;"> NE x 1 </td><td style="text-align: center;"> </td><td style="text-align: left;"> Residual Means of Latent Endogenous Variables </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>From the extended LISREL model, several submodels can be defined.  Subtypes of the LISREL model are defined by setting some of the arguments of the LISREL objective to NA.  Note that because the default values of each LISREL matrix is NA, setting a matrix to NA can be accomplished by simply not giving it any other value.
</p>
<p>The first submodel is the LISREL model without means.
</p>
<p style="text-align: center;"><code class="reqn">\eta = B \eta + \Gamma \xi + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \Lambda_y \eta + \epsilon</code>
</p>

<p style="text-align: center;"><code class="reqn">x = \Lambda_x \xi + \delta</code>
</p>

<p>The LISREL model without means requires 9 matrices: LX, LY, BE, GA, PH, PS, TD, TE, and TH.  Hence this LISREL model has TX, TY, KA, and AL as NA.  This can be accomplished be leaving these matrices at their default values.
</p>
<p>The TX, TY, KA, and AL matrices must be specified if either the mxData type is &ldquo;cov&rdquo; or &ldquo;cor&rdquo; and a means vector is provided, or if the mxData type is &ldquo;raw&rdquo;.  Otherwise the TX, TY, KA, and AL matrices are ignored and the model without means is estimated.
</p>
<p>A second submodel involves only endogenous variables.
</p>
<p style="text-align: center;"><code class="reqn">\eta = B \eta + \zeta</code>
</p>

<p style="text-align: center;"><code class="reqn">y = \Lambda_y \eta + \epsilon</code>
</p>

<p>The endogenous-only LISREL model requires 4 matrices: LY, BE, PS, and TE.  The LX, GA, PH, TD, and TH must be NA in this case.  However, means can also be specified, allowing TY and AL if the data are raw or if observed means are provided.
</p>
<p>Another submodel involves only exogenous variables.
</p>
<p style="text-align: center;"><code class="reqn">x = \Lambda_x \xi + \delta</code>
</p>

<p>The exogenous-model model requires 3 matrices: LX, PH, and TD.  The LY, BE, GA, PS, TE, and TH matrices must be NA.  However, means can also be specified, allowing TX and KA if the data are raw or if observed means are provided.
</p>
<p>The model that is run depends on the matrices that are not NA.  If all 9 matrices are not NA, then the full model is run.  If only the 4 endogenous matrices are not NA, then the endogenous-only model is run.  If only the 3 exogenous matrices are not NA, then the exogenous-only model is run.  If some endogenous and exogenous matrices are not NA, but not all of them, then appropriate errors are thrown.  Means are included in the model whenever their matrices are provided.
</p>

<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxLISRELObjective will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>Like the <a href="#topic+mxRAMObjective">mxRAMObjective</a>, the mxLISRELObjective evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxLISRELObjective function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxLISRELObjective requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'cov', 'cor', or 'raw'.
</p>
<p>To evaluate, place MxLISRELObjective objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a new MxLISRELObjective object. MxLISRELObjective objects should be included with models with referenced <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxData">MxData</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects.
</p>


<h3>References</h3>

<p>J&ouml;reskog, K. G. &amp; S&ouml;rbom, D. (1996). LISREL 8: User's Reference Guide. Lincolnwood, IL: Scientific Software International.
</p>
<p>J&ouml;reskog, K. G. &amp; S&ouml;rbom, D. (1982). Recent developments in structural equation modeling. <em>Journal of Marketing Research, 19,</em> 404-416.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
   #####------------------------------#####
   ##### Factor Model
   mLX &lt;- mxMatrix("Full", values=c(.5, .6, .8, rep(0, 6), .4, .7, .5),
      name="LX", nrow=6, ncol=2,
      free=c(TRUE,TRUE,TRUE,rep(FALSE, 6),TRUE,TRUE,TRUE))
   mTD &lt;- mxMatrix("Diag", values=c(rep(.2, 6)), name="TD", nrow=6, ncol=6,
      free=TRUE)
   mPH &lt;- mxMatrix("Symm", values=c(1, .3, 1), name="PH", nrow=2, ncol=2,
      free=c(FALSE, TRUE, FALSE))
   
   # Create a LISREL objective with LX, TD, and PH matrix names
   objective &lt;- mxLISRELObjective(LX="LX", TD="TD", PH="PH")
   
   testModel &lt;- mxModel(model="testModel4", mLX, mTD, mPH, objective)

</code></pre>

<hr>
<h2 id='MxListOrNull-class'>An optional list</h2><span id='topic+MxListOrNull-class'></span>

<h3>Description</h3>

<p>An optional list
</p>

<hr>
<h2 id='mxMakeNames'>mxMakeNames</h2><span id='topic+mxMakeNames'></span>

<h3>Description</h3>

<p>Adjust a character vector so that it is valid when used as MxMatrix column
or row names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxMakeNames(names, unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMakeNames_+3A_names">names</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="mxMakeNames_+3A_unique">unique</code></td>
<td>
<p>whether to pass the result through <a href="base.html#topic+make.unique">make.unique</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>note</em>: OpenMx is (much) more restrictive than base R's make.names.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+make.names">make.names</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo &lt;- c("", "103", "data", "foo.bar[3,2]", "+!", "!+")
mxMakeNames(demo, unique=TRUE)
</code></pre>

<hr>
<h2 id='mxMarginalNegativeBinomial'>Indicator with marginal Negative Binomial distribution</h2><span id='topic+mxMarginalNegativeBinomial'></span><span id='topic+MxMarginalNegativeBinomial-class'></span><span id='topic+print+2CMxMarginalNegativeBinomial-method'></span><span id='topic+show+2CMxMarginalNegativeBinomial-method'></span><span id='topic++24+2CMxMarginalNegativeBinomial-method'></span><span id='topic++24+3C-+2CMxMarginalNegativeBinomial-method'></span>

<h3>Description</h3>

<p>Indicator with marginal Negative Binomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxMarginalNegativeBinomial(
  vars,
  maxCount = NA,
  size,
  prob = c(),
  mu = c(),
  zeroInf = 0.01,
  free = TRUE,
  labels = NA,
  lbound = NA,
  ubound = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_vars">vars</code></td>
<td>
<p>character vector of manifest indicators</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_maxcount">maxCount</code></td>
<td>
<p>maximum observed count</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_size">size</code></td>
<td>
<p>positive target number of successful trials</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_zeroinf">zeroInf</code></td>
<td>
<p>zero inflation parameter in probability units</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_free">free</code></td>
<td>
<p>logical vector indicating whether paremeters are free</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_labels">labels</code></td>
<td>
<p>character vector of parameter labels</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector of lower bounds</p>
</td></tr>
<tr><td><code id="mxMarginalNegativeBinomial_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector of upper bounds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of MxMarginPoisson obects
</p>

<hr>
<h2 id='mxMarginalPoisson'>Indicator with marginal Poisson distribution</h2><span id='topic+mxMarginalPoisson'></span><span id='topic+MxMarginalPoisson-class'></span><span id='topic+print+2CMxMarginalPoisson-method'></span><span id='topic+show+2CMxMarginalPoisson-method'></span><span id='topic++24+2CMxMarginalPoisson-method'></span><span id='topic++24+3C-+2CMxMarginalPoisson-method'></span>

<h3>Description</h3>

<p>Indicator with marginal Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxMarginalPoisson(
  vars,
  maxCount = NA,
  lambda,
  zeroInf = 0.01,
  free = TRUE,
  labels = NA,
  lbound = 0,
  ubound = c(1, NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMarginalPoisson_+3A_vars">vars</code></td>
<td>
<p>character vector of manifest indicators</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_maxcount">maxCount</code></td>
<td>
<p>maximum observed count</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_lambda">lambda</code></td>
<td>
<p>non-negative means</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_zeroinf">zeroInf</code></td>
<td>
<p>zero inflation parameter in probability units</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_free">free</code></td>
<td>
<p>logical vector indicating whether paremeters are free</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_labels">labels</code></td>
<td>
<p>character vector of parameter labels</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector of lower bounds</p>
</td></tr>
<tr><td><code id="mxMarginalPoisson_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector of upper bounds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of MxMarginPoisson obects
</p>

<hr>
<h2 id='mxMatrix'>Create MxMatrix Object</h2><span id='topic+mxMatrix'></span>

<h3>Description</h3>

<p>This function creates a new <a href="#topic+MxMatrix">MxMatrix</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxMatrix(type = c('Full', 'Diag', 'Iden', 'Lower',
	'Sdiag', 'Stand', 'Symm', 'Unit', 'Zero'), nrow = NA, ncol = NA, 
    free = FALSE, values = NA, labels = NA, lbound = NA, 
    ubound = NA, byrow = getOption('mxByrow'), dimnames = NA, name = NA, 
    condenseSlots=getOption('mxCondenseMatrixSlots'),
    ..., joinKey=as.character(NA), joinModel=as.character(NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMatrix_+3A_type">type</code></td>
<td>
<p>A character string indicating the matrix type, where type indicates the range of values and equalities in the matrix. Must be one of:  &lsquo;Diag&rsquo;, &lsquo;Full&rsquo;, &lsquo;Iden&rsquo;, &lsquo;Lower&rsquo;, &lsquo;Sdiag&rsquo;, &lsquo;Stand&rsquo;, &lsquo;Symm&rsquo;, &lsquo;Unit&rsquo;, or &lsquo;Zero&rsquo;.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_nrow">nrow</code></td>
<td>
<p>Integer; the desired number of rows. One or both of &lsquo;nrow&rsquo; and &lsquo;ncol&rsquo; is required when &lsquo;values&rsquo;, &lsquo;free&rsquo;, &lsquo;labels&rsquo;, &lsquo;lbound&rsquo;, and &lsquo;ubound&rsquo; arguments are not matrices, depending on the desired <a href="#topic+MxMatrix">MxMatrix</a> type.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_ncol">ncol</code></td>
<td>
<p>Integer; the desired number of columns. One or both of &lsquo;nrow&rsquo; and &lsquo;ncol&rsquo; is required when &lsquo;values&rsquo;, &lsquo;free&rsquo;, &lsquo;labels&rsquo;, &lsquo;lbound&rsquo;, and &lsquo;ubound&rsquo; arguments are not matrices, depending on the desired <a href="#topic+MxMatrix">MxMatrix</a> type.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_free">free</code></td>
<td>
<p>A vector or matrix of logicals for free parameter specification. A single &lsquo;TRUE&rsquo; or &lsquo;FALSE&rsquo; will set all allowable variables to free or fixed, respectively.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_values">values</code></td>
<td>
<p>A vector or matrix of numeric starting values. By default, all values are set to zero.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_labels">labels</code></td>
<td>
<p>A vector or matrix of characters for variable label specification.</p>
</td></tr> 
<tr><td><code id="mxMatrix_+3A_lbound">lbound</code></td>
<td>
<p>A vector or matrix of numeric lower bounds. Default bounds are specified with an <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_ubound">ubound</code></td>
<td>
<p>A vector or matrix of numeric upper bounds. Default bounds are specified with an <code>NA</code>.</p>
</td></tr>  
<tr><td><code id="mxMatrix_+3A_byrow">byrow</code></td>
<td>
<p>Logical; defaults to value of global <a href="base.html#topic+options">option</a> 'mxByRow'. If <code>FALSE</code> (default), the &lsquo;values&rsquo;, &lsquo;free&rsquo;, &lsquo;labels&rsquo;, &lsquo;lbound&rsquo;, and &lsquo;ubound&rsquo; matrices are populated by column rather than by row. </p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_dimnames">dimnames</code></td>
<td>
<p>List. The dimnames attribute for the matrix: a list of length 2 giving the row and column names respectively. An empty list is treated as NULL, and a list of length one as row names. The list can be named, and the list names will be used as names for the dimensions.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_name">name</code></td>
<td>
<p>An optional character string indicating the name of the <a href="#topic+MxMatrix">MxMatrix</a> object.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_condenseslots">condenseSlots</code></td>
<td>
<p>Logical; defaults to value of global <a href="base.html#topic+options">option</a> 'mxCondenseMatrixSlots'.  If <code>TRUE</code>, then the resulting <a href="#topic+MxMatrix">MxMatrix</a> will &quot;condense&quot; its &lsquo;labels&rsquo;, &lsquo;free&rsquo;, &lsquo;lbound&rsquo;, and &lsquo;ubound&rsquo; down to 1x1 matrices if they contain only <code>FALSE</code> (&lsquo;free&rsquo;) or <code>NA</code> (the other three).  If <code>FALSE</code>, those four matrices and the &lsquo;values&rsquo; matrix will all be of equal dimensions.   </p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by
name.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_joinkey">joinKey</code></td>
<td>
<p>The name of the column in current model's raw data that
is used as a foreign key to match against the primary key in the
joinModel's raw data.</p>
</td></tr>
<tr><td><code id="mxMatrix_+3A_joinmodel">joinModel</code></td>
<td>
<p>The name of the model that this matrix joins against.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxMatrix function creates <a href="#topic+MxMatrix">MxMatrix</a> objects, which consist of five matrices and a &lsquo;type&rsquo; argument. The &lsquo;values&rsquo; matrix is made up of numeric elements whose usage and capabilities in other functions are defined by the &lsquo;free&rsquo; matrix. If an element is specified as a fixed parameter in the &lsquo;free&rsquo; matrix, then the element in the &lsquo;values&rsquo; matrix is treated as a constant value and cannot be altered or updated by an objective function when included in an <a href="#topic+mxRun">mxRun</a> function. If an element is specified as a free parameter in the &lsquo;free&rsquo; matrix, the element in the &lsquo;value&rsquo; matrix is considered a starting value and can be changed by an objective function when included in an <a href="#topic+mxRun">mxRun</a> function. 
</p>
<p>Element labels beginning with <code>'data.'</code> can be used if the <a href="#topic+MxMatrix">MxMatrix</a> is to be used in an <a href="#topic+MxModel">MxModel</a> object that has a raw dataset (i.e., an <a href="#topic+MxData">MxData</a> object of <code>type="raw"</code>).  Such a label instructs OpenMx to use a particular column of the raw dataset to fill in the value of that element.  For historical reasons, the variable contained in that column is called a &quot;definition variable.&quot;  For example, if an <a href="#topic+MxMatrix">MxMatrix</a> element has the label <code>'data.x'</code>, then OpenMx will use the first value of the data column named &quot;x&quot; when evaluating the fitfunction for the first row, and will use the second value of column &quot;x&quot; when evaluating the fitfunction for the second row, and so on.  After the call to <code><a href="#topic+mxRun">mxRun</a>()</code>, the values for elements labeled with <code>'data.x'</code> are returned as the value from the first (i.e., first before any automated sorting is done) element of column &quot;x&quot; in the data. 
</p>
<p>Objects created by the <code>mxMatrix()</code> function are of a specific &lsquo;type&rsquo;, which specifies the number and location of parameters in the &lsquo;labels&rsquo; matrix and the starting values in the &lsquo;values&rsquo; matrix. Input &lsquo;values&rsquo;, &lsquo;free&rsquo;, and &lsquo;labels&rsquo; matrices must be of appropriate shape and have appropriate values for the matrix type requested. Nine types of matrices are supported:
</p>

<table>
<tr>
 <td style="text-align: left;">
&lsquo;Diag&rsquo;   </td><td style="text-align: left;"> matrices must be square, and only elements on the principal diagonal may be specified as free parameters or take non-zero values. All other elements are required to be fixed parameters with a value of 0. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Full&rsquo;   </td><td style="text-align: left;"> matrices may be either rectangular or square, and all elements in the matrix may be freely estimated. This type is the default for the mxMatrix() function. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Iden&rsquo;   </td><td style="text-align: left;"> matrices must be square, and consist of no free parameters. Matrices of this type have a value of 1 for all entries on the principal diagonal and the value 0 in all off-diagonal entries. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Lower&rsquo;  </td><td style="text-align: left;"> matrices must be square, with a value of 0 for all entries in the upper triangle and no free parameters in the upper triangle. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Sdiag&rsquo;  </td><td style="text-align: left;"> matrices must be square, with a value of 0 for all entries in the upper triangle and along the diagonal. No free parameters in the upper triangle or along the diagonal. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Symm&rsquo;   </td><td style="text-align: left;"> matrices must be square, and elements in the principle diagonal and lower triangular portion of the matrix may be free parameters of any value. Elements in the upper triangular portion of the matrix are constrained to be equal to those in the lower triangular portion, such that the value and parameter specification of the element in row i and column j is identical to to the value and specification of the element in row j and column i. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Stand&rsquo;  </td><td style="text-align: left;"> matrices are symmetric matrices (see 'Symm') with 1's along the main diagonal. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Unit&rsquo;   </td><td style="text-align: left;"> matrices may be either rectangular or square, and contain no free parameters. All elements in matrices of this type have a value of 1 for all elements. </td>
</tr>
<tr>
 <td style="text-align: left;">

&lsquo;Zero&rsquo;   </td><td style="text-align: left;"> matrices may be either rectangular or square, and contain no free parameters. All elements in matrices of this type have a value of 0 for all elements. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When &lsquo;type&rsquo; is &lsquo;Lower&rsquo; or &lsquo;Symm&rsquo;, then the arguments to &lsquo;free&rsquo;, &lsquo;values&rsquo;, &lsquo;labels&rsquo;, &lsquo;lbound&rsquo;, or &lsquo;ubound&rsquo; may be vectors of length <code class="reqn">N * (N + 1) / 2</code>, where N is the number of rows and columns of the matrix. When &lsquo;type&rsquo; is &lsquo;Sdiag&rsquo; or &lsquo;Stand&rsquo;, then the arguments to &lsquo;free&rsquo;, &lsquo;values&rsquo;, &lsquo;labels&rsquo;, &lsquo;lbound&rsquo;, or &lsquo;ubound&rsquo; may be vectors of length <code class="reqn">N * (N - 1) / 2</code>. 
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxMatrix">MxMatrix</a> object, which consists of a &lsquo;values&rsquo; matrix of numeric starting values, a &lsquo;free&rsquo; matrix describing free parameter specification, a &lsquo;labels&rsquo; matrix of labels for the variable names, and &lsquo;lbound&rsquo; and &lsquo;ubound&rsquo; matrices of the lower and upper parameter bounds. This <a href="#topic+MxMatrix">MxMatrix</a> object can be used as an argument in the <code><a href="#topic+mxAlgebra">mxAlgebra</a>()</code>, <code><a href="#topic+mxBounds">mxBounds</a>()</code>, <code><a href="#topic+mxConstraint">mxConstraint</a>()</code> and <code><a href="#topic+mxModel">mxModel</a>()</code> functions.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+MxMatrix">MxMatrix</a> for the S4 class created by mxMatrix. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 3 x 3 identity matrix

idenMatrix &lt;- mxMatrix(type = "Iden", nrow = 3, 
    ncol = 3, name = "I")

# Create a full 4 x 2 matrix from existing 
# value matrix with all free parameters

vals &lt;- matrix(1:8, nrow = 4)
fullMatrix &lt;- mxMatrix(type = "Full", values = vals, 
    free = TRUE, name = "foo")
 
# Create a 3 x 3 symmetric matrix with free off-
# diagonal parameters and starting values

symmMatrix &lt;- mxMatrix(type = "Symm", nrow = 3, ncol = 3,
    free = c(FALSE, TRUE, TRUE, FALSE, TRUE, FALSE),
    values = c(1, .8, .8, 1, .8, 1),
    labels = c(NA, "free1", "free2", NA, "free3", NA),
    name = "bar")

# Create an mxMatrix from a character matrix.  All numbers are
# interpreted as fixed and non-numbers are interpreted as free
# parameters.

matrixFromChar &lt;- function(inputm, name=NA) {
  inputmFixed &lt;- suppressWarnings(matrix(
    as.numeric(inputm),nrow = nrow(inputm), ncol = ncol(inputm)))
  inputmCharacter &lt;- inputm
  inputmCharacter[!is.na(inputmFixed)] &lt;- NA
  mxMatrix(nrow=nrow(inputm), ncol=ncol(inputm),
           free=!is.na(inputmCharacter),
           values=inputmFixed,
           labels=inputmCharacter,
           dimnames=dimnames(inputm), name=name)
}


# Demonstrate some of the behavior of the condensed slots
# Create a 3x3 matrix with condensed slots

a &lt;- mxMatrix('Full', 3, 3, values=1, condenseSlots=TRUE)
a@free # at operator returns the stored 1x1 matrix
a$free # dollar operator constructs full matrix for printing

# assignment with the dollar operator
#  de-condenses the slots to create the
#  full 3x3 matrix
a$free[1,1] &lt;- TRUE
a@free



</code></pre>

<hr>
<h2 id='MxMatrix-class'>MxMatrix Class</h2><span id='topic+MxMatrix-class'></span><span id='topic+MxMatrix'></span><span id='topic++24+2CMxMatrix-method'></span><span id='topic++24+3C-+2CMxMatrix-method'></span><span id='topic++5B+2CMxMatrix-method'></span><span id='topic++5B+3C-+2CMxMatrix-method'></span><span id='topic++5B+2CMxMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CMxMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CMxMatrix-method'></span><span id='topic++5B+5B+3C-+2CMxMatrix-method'></span><span id='topic+dim+2CMxMatrix-method'></span><span id='topic+dimnames+2CMxMatrix-method'></span><span id='topic+dimnames+3C-+2CMxMatrix-method'></span><span id='topic+dimnames+2CMxMatrix+2CANY-method'></span><span id='topic+dimnames+3C-+2CMxMatrix+2CANY-method'></span><span id='topic+DiagMatrix-class'></span><span id='topic+FullMatrix-class'></span><span id='topic+IdenMatrix-class'></span><span id='topic+LowerMatrix-class'></span><span id='topic+SdiagMatrix-class'></span><span id='topic+StandMatrix-class'></span><span id='topic+SymmMatrix-class'></span><span id='topic+UnitMatrix-class'></span><span id='topic+ZeroMatrix-class'></span><span id='topic+length+2CMxMatrix-method'></span><span id='topic+names+2CMxMatrix-method'></span><span id='topic+ncol+2CMxMatrix-method'></span><span id='topic+nrow+2CMxMatrix-method'></span><span id='topic+print+2CMxMatrix-method'></span><span id='topic+show+2CMxMatrix-method'></span>

<h3>Description</h3>

<p>MxMatrix is a virtual S4 class that comprises the nine types of matrix objects used by OpenMx (see <code><a href="#topic+mxMatrix">mxMatrix</a>()</code> for details).  An MxMatrix object is a <a href="#topic+Named-entity">named entity</a>.  New instances of this class can be created using the function <code><a href="#topic+mxMatrix">mxMatrix</a>()</code>.  MxMatrix objects may be used as arguments in other functions from the OpenMx package, including <code><a href="#topic+mxAlgebra">mxAlgebra</a>()</code>, <code><a href="#topic+mxConstraint">mxConstraint</a>()</code>, and <code><a href="#topic+mxModel">mxModel</a>()</code>.
</p>


<h3>Objects from the Class</h3>

<p>All nine types of object that the class comprises can be created via <code><a href="#topic+mxMatrix">mxMatrix</a>()</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Character string; the name of the MxMatrix object.  Note that this is the object's &quot;Mx name&quot; (so to speak), which identifies it in OpenMx's internal namespace, rather than the symbol identifying it in <span class="rlang"><b>R</b></span>'s workspace.  Use of MxMatrix objects in an <a href="#topic+mxAlgebra">mxAlgebra</a> or <a href="#topic+mxConstraint">mxConstraint</a> function requires reference by name.</p>
</dd>
<dt><code>values</code>:</dt><dd><p>Numeric matrix of values.  If an element is specified as a fixed parameter in the 'free' matrix, then the element in the 'values' matrix is treated as a constant value and cannot be altered or updated by an objective function when included in an <code><a href="#topic+mxRun">mxRun</a>()</code> function. If an element is specified as a free parameter in the 'free' matrix, the element in the 'value' matrix is considered a starting value and can be changed by an objective function when included in an <code><a href="#topic+mxRun">mxRun</a>()</code> function.</p>
</dd>
<dt><code>labels</code>:</dt><dd><p>Matrix of character strings which provides the labels of free and fixed parameters. Fixed parameters with identical labels must have identical values.  Free parameters with identical labels impose an equality constraint. The same label cannot be applied to a free parameter and a fixed parameter. A free parameter with the label 'NA' implies a unique free parameter, that cannot be constrained to equal any other free parameter.</p>
</dd>
<dt><code>free</code>:</dt><dd><p>Logical matrix specifying whether each element is free versus fixed. An element is a free parameter if-and-only-if the corresponding value in the 'free' matrix is 'TRUE'. Free parameters are elements of an MxMatrix object whose values may be changed by a fitfunction when that MxMatrix object is included in an <a href="#topic+MxModel">MxModel</a> object and evaluated using the <code><a href="#topic+mxRun">mxRun</a>()</code> function.</p>
</dd>
<dt><code>lbound</code>:</dt><dd><p>Numeric matrix of lower bounds on free parameters.</p>
</dd>
<dt><code>ubound</code>:</dt><dd><p>Numeric matrix of upper bounds on free parameters.</p>
</dd>
<dt><code>.squareBrackets</code>:</dt><dd><p>Logical matrix; used internally by OpenMx.  Identifies which elements have labels with square brackets in them.</p>
</dd>
<dt><code>.persist</code>:</dt><dd><p>Logical; used internally by OpenMx.  Governs how <code><a href="#topic+mxRun">mxRun</a>()</code> handles the MxMatrix object when it is inside the <a href="#topic+MxModel">MxModel</a> being run.</p>
</dd>
<dt><code>.condenseSlots</code>:</dt><dd><p>Logical; used internally by OpenMx.  If <code>FALSE</code>, then the matrices in the 'values', 'labels', 'free', 'lbound', and 'ubound' slots are all of equal dimensions.  If <code>TRUE</code>, then the last four of those slots will &quot;condense&quot; a matrix consisting entirely of <code>FALSE</code> or <code>NA</code> down to 1x1.</p>
</dd>
<dt><code>display</code>:</dt><dd><p>Character string; used internally by OpenMx when parsing <a href="#topic+MxAlgebra">MxAlgebra</a>s.</p>
</dd>
<dt><code>dependencies</code>:</dt><dd><p>Integer; used internally by OpenMx when parsing <a href="#topic+MxAlgebra">MxAlgebra</a>s.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>





<dt>length</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>ncol</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>nrow</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "MxMatrix")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MxMatrix")</code>: ... </p>
</dd>
</dl>

<p>Note that some methods are documented separately (see below, under &quot;See Also&quot;).
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxMatrix">mxMatrix</a>()</code> for creating MxMatrix objects.  Note that functions <code><a href="#topic+imxCreateMatrix">imxCreateMatrix</a>()</code>, <code><a href="#topic+imxDeparse">imxDeparse</a>()</code>, <code><a href="#topic+imxSquareMatrix">imxSquareMatrix</a>()</code>, <code><a href="#topic+imxSymmetricMatrix">imxSymmetricMatrix</a>()</code>, and <code><a href="#topic+imxVerifyMatrix">imxVerifyMatrix</a>()</code> are separately documented methods for this class.  More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MxMatrix")
</code></pre>

<hr>
<h2 id='mxMI'>Estimate Modification Indices for MxModel Objects</h2><span id='topic+mxMI'></span>

<h3>Description</h3>

<p>This function estimates the change in fit function value resulting from freeing currently fixed parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxMI(model, matrices=NA, full=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMI_+3A_model">model</code></td>
<td>
<p>An MxModel for which modification indices are desired.</p>
</td></tr>
<tr><td><code id="mxMI_+3A_matrices">matrices</code></td>
<td>
<p>Character vector.  The names of the matrices in which to search for modification</p>
</td></tr>
<tr><td><code id="mxMI_+3A_full">full</code></td>
<td>
<p>Logical.  Whether or not to return the full modification index in addition to the restricted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modification indices provide an estimate of how much the fit function value would change if a parameter that is currently fixed was instead freely estimated.  There are two versions of this estimate: a restricted version and an full version.  The restricted version is reported as the MI and is much faster to compute.  The full version is reported as MI.Full.  The full version accounts for the <em>total</em> change in fit function value resulting from the newly freed parameter.  The restricted version only accounts for the change in the fit function due to the movement of the new free parameter.  In particular, the restricted version does not account for the change in fit function value due to the other free parameters moving in response to the new parameter.  In addition to the fit function value change, the expected parameter change (EPC) can be computed for each parameter that is newly freed.
</p>
<p>The algorithm respects fixed parameter labels.  That is, when a fixed parameter has a label and occurs in more than one spot, then that fixed parameter is freed in all locations in which it occurs to evaluate the modification index for that fixed parameter.
</p>
<p>When the fit function is in minus two log likelihood units (e.g. <code><a href="#topic+mxFitFunctionML">mxFitFunctionML</a></code>), then the MI will be approximately chi squared distributed with 1 degree of freedom.  Using a p-value of 0.01 has been suggested.  Hence, a MI greater than <code>qchisq(p=1-0.01, df=1)</code>, or 6.63, is suggestive of a modification.
</p>
<p>Users should be cautious in their use of modification indices.  If a model was created with the aid of MIs, then it should <em>always</em> be reported.  <em>Do not pretend that you have a theoretical reason for part of a model that was put there because it was suggested by a modification index.  This is fraud.</em>  When using modification indices there are two options for best practices.  First, you can report the analyses as exploratory.  Document all the explorations that you did, and know that your results may or may not generalize.  Second, you can use cross-validation.  Reserve part of your data for exploration, and use the remaining data to test if the exploratory model generalizes to new data.
</p>


<h3>Value</h3>

<p>A data.frame with named columns
</p>

<dl>
<dt>MI</dt><dd><p>The restricted modification index.</p>
</dd>
<dt>MI.Full</dt><dd><p>The full modification index.</p>
</dd>
<dt>plusOneParamModels</dt><dd><p>A list of models with one additional free parameter</p>
</dd>
<dt>EPC</dt><dd><p>The expected parameter change.  Only available when <code>full=TRUE</code></p>
</dd>
</dl>



<h3>References</h3>

<p>S&ouml;rbom, D.  (1989).  Model Modification.  <em>Psychometrika, 54</em>, 371-384.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a model
require(OpenMx)
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("One Factor",
      type="RAM",
      manifestVars = manifests,
      latentVars = latents,
      mxPath(from=latents, to=manifests),
      mxPath(from=manifests, arrows=2),
      mxPath(from=latents, arrows=2,
            free=FALSE, values=1.0),
      mxPath(from = 'one', to = manifests),
      mxData(observed=cov(demoOneFactor), type="cov", numObs=500,
             means = colMeans(demoOneFactor)))
#No SEs for speed
factorModel &lt;- mxOption(factorModel, 'Standard Errors', 'No')
factorRun &lt;- mxRun(factorModel)

# See if it should be modified
# Notes
#  Using full=FALSE for faster performance
#  Using matrices= 'A' and 'S' to not get MIs for
#    the F matrix which is always fixed.
fim &lt;- mxMI(factorRun, matrices=c('A', 'S'), full=FALSE)
round(fim$MI, 3)
plot(fim$MI, ylim=c(0, 10))
abline(h=qchisq(p=1-0.01, df=1)) # line of "significance"

</code></pre>

<hr>
<h2 id='mxMLObjective'>DEPRECATED: Create MxMLObjective Object</h2><span id='topic+mxMLObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use mxExpectationNormal() and mxFitFunctionML() instead.  As a temporary workaround, mxMLObjective returns a list containing an MxExpectationNormal object and an MxFitFunctionML object.
</p>
<p>mxMLObjective(covariance, means = NA, dimnames = NA, thresholds = NA)
All occurrences of
</p>
<p>mxMLObjective(covariance, means = NA, dimnames = NA, thresholds = NA)
</p>
<p>Should be changed to
</p>
<p>mxExpectationNormal(covariance, means = NA, dimnames = NA, thresholds = NA, threshnames = dimnames)
mxFitFunctionML(vector = FALSE)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxMLObjective_+3A_covariance">covariance</code></td>
<td>
<p>A character string indicating the name of the expected covariance algebra.</p>
</td></tr>
<tr><td><code id="mxMLObjective_+3A_means">means</code></td>
<td>
<p>An optional character string indicating the name of the expected means algebra.</p>
</td></tr>
<tr><td><code id="mxMLObjective_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the dimnames of the covariance and means algebras.</p>
</td></tr>   
<tr><td><code id="mxMLObjective_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: THIS DESCRIPTION IS DEPRECATED.  Please change to using <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> and <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> as shown in the example below.
</p>
<p>Objective functions are functions for which free parameter values are chosen such that the value of the objective function is minimized. The mxMLObjective function uses full-information maximum likelihood to provide maximum likelihood estimates of free parameters in the algebra defined by the 'covariance' argument given the covariance of an <a href="#topic+MxData">MxData</a> object. The 'covariance' argument takes an <a href="#topic+MxAlgebra">MxAlgebra</a> object, which defines the expected covariance of an associated <a href="#topic+MxData">MxData</a> object. The 'dimnames' arguments takes an optional character vector.  If this argument is not a single NA, then this vector be assigned to be the dimnames of the means vector, and the row and columns dimnames of the covariance matrix.
</p>
<p>mxMLObjective evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxMLObjective function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxMLObjective requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'cov' or 'cov'. The 'covariance' argument of this function evaluates with respect to the 'matrix' argument of the associated <a href="#topic+MxData">MxData</a> object, while the 'means' argument of this function evaluates with respect to the 'vector' argument of the associated <a href="#topic+MxData">MxData</a> object. The 'means' and 'vector' arguments are optional in both functions. If the 'means' argument is not specified (NA), the optional 'vector' argument of the <a href="#topic+MxData">MxData</a> object is ignored. If the 'means' argument is specified, the associated <a href="#topic+MxData">MxData</a> object should specify a 'means' argument of equivalent dimension as the 'means' algebra.
</p>
<p>dimnames must be supplied where the matrices referenced by the covariance and means algebras are not themselves labeled. Failure to do so leads to an error noting that the covariance or means matrix associated with the ML objective does not contain dimnames.
</p>
<p>To evaluate, place MxMLObjective objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, or using the <a href="#topic+mxEval">mxEval</a> function.
</p>


<h3>Value</h3>

<p>Returns a list containing an MxExpectationNormal object and an MxFitFunctionML object. 
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxMatrix, mxAlgebra, mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

S &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1), 
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"), name = "S")
A &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA), name = "A")
I &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="I")

# Define the expectation

expCov &lt;- mxAlgebra(solve(I-A) %*% S %*% t(solve(I-A)), name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", dimnames=tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML()

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", S, A, I, expCov, expFunction, fitFunction, 
                    mxData(observed=cov(tmpFrame), type="cov", numObs=dim(tmpFrame)[1]))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)


</code></pre>

<hr>
<h2 id='mxModel'>Create MxModel Object</h2><span id='topic+mxModel'></span>

<h3>Description</h3>

<p>Create or modify an <a href="#topic+MxModel">MxModel</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxModel(model = NA, ..., manifestVars = NA, latentVars = NA,
          remove = FALSE, independent = NA, type = NA, name = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxModel_+3A_model">model</code></td>
<td>
<p>This argument is either an <a href="#topic+MxModel">MxModel</a> object or a string. If 'model' is an MxModel object, then all elements of that model are placed in the resulting MxModel object. If 'model' is a string, then a new model is created with the string as its name. If 'model' is either unspecified or 'model' is a named entity, data source, or MxPath object, then a new model is created.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_...">...</code></td>
<td>
<p>An arbitrary number of <a href="#topic+mxMatrix">mxMatrix</a>, <a href="#topic+mxPath">mxPath</a>, <a href="#topic+mxData">mxData</a>, and other functions such as <a href="#topic+mxConstraint">mxConstraint</a>s and <a href="#topic+mxCI">mxCI</a>. These will all be added or removed from the model as specified in the 'model' argument, based on the 'remove' argument.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_manifestvars">manifestVars</code></td>
<td>
<p>For RAM-type models, A list of manifest variables to be included in the model.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_latentvars">latentVars</code></td>
<td>
<p>For RAM-type models, A list of latent variables to be included in the model.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_remove">remove</code></td>
<td>
<p>logical. If TRUE, elements listed in this statement are removed from the original model. If FALSE, elements listed in this statement are added to the original model.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_independent">independent</code></td>
<td>
<p>logical. If TRUE then the model is evaluated independently of other models.</p>
</td></tr>
<tr><td><code id="mxModel_+3A_type">type</code></td>
<td>
<p>character vector. The model type to assign to this model. Defaults to options(&quot;mxDefaultType&quot;). See below for valid types</p>
</td></tr>
<tr><td><code id="mxModel_+3A_name">name</code></td>
<td>
<p>An optional character vector indicating the name of the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxModel function is used to create <a href="#topic+MxModel">MxModel</a>s. Models created by this function may be new, or may be modified versions of existing <a href="#topic+MxModel">MxModel</a> objects. By default a new <a href="#topic+MxModel">MxModel</a> object will be created: To create a modified version of an existing <a href="#topic+MxModel">MxModel</a> object, include this model in the 'model' argument.
</p>
<p>Other <a href="#topic+named-entities">named-entities</a> may be added as arguments to the mxModel function, which are then added to or removed from the model specified in the &lsquo;model&rsquo; argument. Functions you can use to add objects to the model to this way include <a href="#topic+mxPath">mxPath</a>, <a href="#topic+mxCI">mxCI</a>, <a href="#topic+mxAlgebra">mxAlgebra</a>, <a href="#topic+mxBounds">mxBounds</a>, <a href="#topic+mxConstraint">mxConstraint</a>, <a href="#topic+mxData">mxData</a>, and <a href="#topic+mxMatrix">mxMatrix</a> objects, as well as fit functions and expectations (see below). You can also include sub-models as components of a model. These sub-models may be estimated separately or jointly depending on shared parameters and the &lsquo;independent&rsquo; flag (see below). Only one <a href="#topic+MxData">MxData</a> object and one fit function and expectation may be included per model, but there are no restrictions on the number of other <a href="#topic+named-entities">named-entities</a> included in an mxModel statement.
</p>
<p>All other arguments must be named (i.e. &lsquo;latentVars = names&rsquo;), or they will be interpreted as elements of the ellipsis list. The &lsquo;manifestVars&rsquo; and &lsquo;latentVars&rsquo; arguments specify the names of the manifest and latent variables, respectively, for use with the <a href="#topic+mxPath">mxPath</a> function.
</p>
<p>The &lsquo;remove&rsquo; argument may be used when mxModel is used to create a modified version of an existing <a href="#topic+MxMatrix">MxMatrix</a> object. When &lsquo;remove&rsquo; is set to TRUE, the listed objects are removed from the model specified in the &lsquo;model&rsquo; argument. When &lsquo;remove&rsquo; is set to FALSE, the listed objects are added to the model specified in the &lsquo;model&rsquo; argument. 
</p>
<p>Model independence may be specified with the &lsquo;independent&rsquo; argument. If a model is independent (&lsquo;independent = TRUE&rsquo;), then the parameters of this model are not shared with any other model. An independent model may be estimated with no dependency on any other model. If a model is not independent (&lsquo;independent = FALSE&rsquo;), then this model shares parameters with one or more other models such that these models must be jointly estimated. These dependent models must be entered as arguments in another model, so that they are simultaneously optimized.
</p>
<p>The model type is determined by a character vector supplied to the &lsquo;type&rsquo; argument. The type of a model is a dynamic property, ie. it is allowed to change during the lifetime of the model. To see a list of available types, use the <a href="#topic+mxTypes">mxTypes</a> command.  When a new model is created and no type is specified, the type specified by <code>options("mxDefaultType")</code> is used.
</p>
<p><strong>Expectations and Fit functions</strong>
</p>
<p>To be estimated, <a href="#topic+MxModel">MxModel</a> objects must include fit functions and expectations as arguments.  Fit functions include <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, <a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a>, <a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>, <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a>, <a href="#topic+mxFitFunctionGREML">mxFitFunctionGREML</a>, <a href="#topic+mxFitFunctionR">mxFitFunctionR</a>, and <a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a>. Expectations include 
<a href="#topic+mxExpectationBA81">mxExpectationBA81</a>, <a href="#topic+mxExpectationGREML">mxExpectationGREML</a>, <a href="#topic+mxExpectationHiddenMarkov">mxExpectationHiddenMarkov</a>
<a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a>, <a href="#topic+mxExpectationMixture">mxExpectationMixture</a>, <a href="#topic+mxExpectationNormal">mxExpectationNormal</a>, <a href="#topic+mxExpectationRAM">mxExpectationRAM</a>, <a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a>, <a href="#topic+mxExpectationStateSpaceContinuousTime">mxExpectationStateSpaceContinuousTime</a>. The 'type' of the model may imply a certain fit function or expectation (e.g. type = &quot;RAM&quot; implies mxExpectationRAM). The model data may also constrain which fit and expectation are appropriate.
</p>
<p>The model, complete with fit function and expectation can then be executed using <a href="#topic+mxRun">mxRun</a>. 
</p>
<p><strong>Accessing model components</strong>
</p>
<p>You can view a model summary with summary. You can also access <a href="#topic+Named-entity">Named entities</a> in <a href="#topic+MxModel">MxModel</a> directly via the $ symbol.  For instance, for an MxModel named &quot;yourModel&quot; containing an MxMatrix named &quot;yourMatrix&quot;, the contents of &quot;yourMatrix&quot; can be accessed as yourModel$yourMatrix. Slots (i.e., matrices, algebras, etc.) in an mxMatrix may also be referenced with the $ symbol (e.g., yourModel$matrices or yourModel$algebras). See the documentation for <a href="methods.html#topic+Classes">Classes</a> and the examples in <a href="methods.html#topic+Classes">Classes</a> for more information.
</p>


<h3>Value</h3>

<p>Returns a new <a href="#topic+MxModel">MxModel</a> object. To be run, <a href="#topic+MxModel">MxModel</a> object must include a fit function and expectation.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+mxCI">mxCI</a> for information about adding Confidence Interval calculations to a model. 
See <a href="#topic+mxPath">mxPath</a> for information about adding paths to RAM-type models.
See <a href="#topic+mxMatrix">mxMatrix</a> for information about adding matrices to models.
See <a href="#topic+mxData">mxData</a> for specifying the data a model is to be evaluated against.
Many advanced options can be set via <a href="#topic+mxOption">mxOption</a>. 
More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

# At the simplest, you can create an empty model,
#  placing it in an object, and add to it later
emptyModel &lt;- mxModel(model="IAmEmpty")

# Create a model named 'firstdraft' with one matrix 'A'
firstModel &lt;- mxModel(model='firstdraft', 
                 mxMatrix(type='Full', nrow = 3, ncol = 3, name = "A"))

# Update 'firstdraft', and rename the model 'finaldraft'
finalModel &lt;- mxModel(model=firstModel,
                 mxMatrix(type='Symm', nrow = 3, ncol = 3, name = "S"),
                 mxMatrix(type='Iden', nrow = 3, name = "F"),
                 name= "finaldraft")

# Add data to the model from an existing data frame in object 'data'
data(twinData)  # load some data
finalModel &lt;- mxModel(model=finalModel, mxData(twinData, type='raw'))

# Two ways to view the matrix named "A" in MxModel object 'model'

finalModel$A

finalModel$matrices$A

# A working example using OpenMx Path Syntax
data(HS.ability.data)  # load the data

# The manifest variables loading on each proposed latent variable
Spatial   &lt;- c("visual", "cubes", "paper")
Verbal    &lt;- c("general", "paragrap", "sentence")
Math      &lt;- c("numeric", "series", "arithmet")

latents   &lt;- c("vis", "math", "text")
manifests &lt;-  c(Spatial, Math, Verbal)

HSModel &lt;- mxModel(model="Holzinger_and_Swineford_1939", type="RAM", 
    manifestVars = manifests, # list the measured variables (boxes)
    latentVars   = latents,   # list the latent variables (circles)
    # factor loadings from latents to  manifests
    mxPath(from="vis",  to=Spatial),# factor loadings
    mxPath(from="math", to=Math),   # factor loadings
    mxPath(from="text", to=Verbal), # factor loadings

    # Allow latent variables to covary 
    mxPath(from="vis" , to="math", arrows=2, free=TRUE),
    mxPath(from="vis" , to="text", arrows=2, free=TRUE),
    mxPath(from="math", to="text", arrows=2, free=TRUE),

    # Allow latent variables to have variance
    mxPath(from=latents, arrows=2, free=FALSE, values=1.0),
    # Manifest have residual variance
    mxPath(from=manifests, arrows=2),   
    # the data to be analysed
    mxData(cov(HS.ability.data[,manifests]), type = "cov", numObs = 301))
    
fitModel &lt;- mxRun(HSModel) # run the model
summary(fitModel) # examine the output: Fit statistics and path loadings

</code></pre>

<hr>
<h2 id='MxModel-class'>MxModel Class</h2><span id='topic+MxModel-class'></span><span id='topic+MxModel'></span><span id='topic++24+2CMxModel-method'></span><span id='topic++24+3C-+2CMxModel-method'></span><span id='topic++5B+5B+2CMxModel-method'></span><span id='topic++5B+5B+3C-+2CMxModel-method'></span><span id='topic+names+2CMxModel-method'></span><span id='topic+print+2CMxModel-method'></span><span id='topic+show+2CMxModel-method'></span>

<h3>Description</h3>

<p>MxModel is an S4 class. An MxModel object is a <a href="#topic+Named-entity">named entity</a>.
</p>


<h3>Details</h3>

<p>The &lsquo;matrices&rsquo; slot contains a list of the <a href="#topic+MxMatrix">MxMatrix</a> objects included in the model. These objects are listed by name. Two objects may not share the same name. If a new <a href="#topic+MxMatrix">MxMatrix</a> is added to an MxModel object with the same name as an <a href="#topic+MxMatrix">MxMatrix</a> object in that model, the added version replaces the previous version. There is no imposed limit on the number of <a href="#topic+MxMatrix">MxMatrix</a> objects that may be added here.
</p>
<p>The &lsquo;algebras&rsquo; slot contains a list of the <a href="#topic+MxAlgebra">MxAlgebra</a> objects included in the model. These objects are listed by name. Two objects may not share the same name. If a new <a href="#topic+MxAlgebra">MxAlgebra</a> is added to an MxModel object with the same name as an <a href="#topic+MxAlgebra">MxAlgebra</a> object in that model, the added version replaces the previous version. All <a href="#topic+MxMatrix">MxMatrix</a> objects referenced in the included <a href="#topic+MxAlgebra">MxAlgebra</a> objects must be included in the &lsquo;matrices&rsquo; slot prior to estimation. There is no imposed limit on the number of <a href="#topic+MxAlgebra">MxAlgebra</a> objects that may be added here.
</p>
<p>The &lsquo;constraints&rsquo; slot contains a list of the <a href="#topic+MxConstraint">MxConstraint</a> objects included in the model. These objects are listed by name. Two objects may not share the same name. If a new <a href="#topic+MxConstraint">MxConstraint</a> is added to an MxModel object with the same name as an <a href="#topic+MxConstraint">MxConstraint</a> object in that model, the added version replaces the previous version. All <a href="#topic+MxMatrix">MxMatrix</a> objects referenced in the included <a href="#topic+MxConstraint">MxConstraint</a> objects must be included in the &lsquo;matrices&rsquo; slot prior to estimation. There is no imposed limit on the number of <a href="#topic+MxConstraint">MxConstraint</a> objects that may be added here.
</p>
<p>The &lsquo;intervals&rsquo; slot contains a list of the confidence intervals requested by included <a href="#topic+MxCI">MxCI</a> objects. These objects are listed by the free parameters, <a href="#topic+MxMatrix">MxMatrices</a> and <a href="#topic+MxAlgebra">MxAlgebras</a> referenced in the <a href="#topic+MxCI">MxCI</a> objects, not the list of <a href="#topic+MxCI">MxCI</a> objects themselves. If a new <a href="#topic+MxCI">MxCI</a> object is added to an MxModel object referencing one or more free parameters <a href="#topic+MxMatrix">MxMatrices</a> or <a href="#topic+MxAlgebra">MxAlgebras</a> previously listed in the &lsquo;intervals&rsquo; slot, the new confidence interval(s) replace the existing ones. All listed confidence intervals must refer to free parameters <a href="#topic+MxMatrix">MxMatrices</a> or <a href="#topic+MxAlgebra">MxAlgebras</a> in the model.
</p>
<p>The &lsquo;latentVars&rsquo; slot contains a list of latent variable names,
which may be referenced by <a href="#topic+MxPath-class">MxPath</a> objects. This
slot defaults to 'NA', and is only used when the <a href="#topic+mxPath">mxPath</a> function
is used. In the context of a RAM model, this slot accepts a character
vector of variable names. However, the LISREL model is partitioned into
exogenous and endogenous parts. Both exogenous and endogenous variables
can be specified using a list like, <code>list(endo='a',  exo='b')</code>.
If a character vector is passed to a LISREL model then those
variables will be assumed endogenous.
</p>
<p>The &lsquo;manifestVars&rsquo; slot contains a list of latent variable names,
which may be referenced by <a href="#topic+MxPath-class">MxPath</a> objects. This
slot defaults to 'NA', and is only used when the <a href="#topic+mxPath">mxPath</a> function
is used. In the context of a RAM model, this slot accepts a character
vector of variable names. However, the LISREL model is partitioned into
exogenous and endogenous parts. Both exogenous and endogenous variables
can be specified using a list like, <code>list(endo='a',  exo='b')</code>.
If a character vector is passed to a LISREL model then those
variables will be assumed endogenous.
</p>
<p>The &lsquo;data&rsquo; slot contains an <a href="#topic+MxData">MxData</a> object. This slot must be filled prior to execution when a fitfunction referencing data is used. Only one <a href="#topic+MxData">MxData</a> object may be included per model, but submodels may have their own data in their own &lsquo;data&rsquo; slots. If an <a href="#topic+MxData">MxData</a> object is added to an MxModel which already contains an <a href="#topic+MxData">MxData</a> object, the new object replaces the existing one.
</p>
<p>The &lsquo;submodels&rsquo; slot contains references to all of the MxModel objects included as submodels of this MxModel object. Models held as arguments in other models are considered to be submodels. These objects are listed by name. Two objects may not share the same name. If a new submodel is added to an MxModel object with the same name as an existing submodel, the added version replaces the previous version. When a model containing other models is executed using <a href="#topic+mxRun">mxRun</a>, all included submodels are executed as well. If the submodels are dependent on one another, they are treated as one larger model for purposes of estimation.
</p>
<p>The &lsquo;independent&rsquo; slot contains a logical value indicating whether or not the model is independent. If a model is independent (independent=TRUE), then the parameters of this model are not shared with any other model. An independent model may be estimated with no dependency on any other model. If a model is not independent (independent=FALSE), then this model shares parameters with one or more other models such that these models must be jointly estimated. These dependent models must be entered as submodels of another MxModel objects, so that they are simultaneously optimized.
</p>
<p>The &lsquo;options&rsquo; slot contains a list of options for the model. The name of each entry in the list is the option name to be used at runtime. The values in this list are the values of the optimizer options. The standard interface for updating options is through the <a href="#topic+mxOption">mxOption</a> function.
</p>
<p>The &lsquo;output&rsquo; slot contains a list of output added to the model by the <a href="#topic+mxRun">mxRun</a> function. Output includes parameter estimates, optimization information, model fit, and other information.  If a model has not been optimized using the <a href="#topic+mxRun">mxRun</a> function, the 'output' slot will be 'NULL'.
</p>
<p><a href="#topic+Named-entity">Named entities</a> in <a href="#topic+MxModel">MxModel</a> objects may be viewed and referenced by name using the $ symbol.  For instance, for an MxModel named &quot;yourModel&quot; containing an MxMatrix named &quot;yourMatrix&quot;, the contents of &quot;yourMatrix&quot; can be accessed as yourModel$yourMatrix. Slots (i.e., matrices, algebras, etc.) in an mxMatrix may also be referenced with the $ symbol (e.g., yourModel$matrices or yourModel$algebras). See the documentation for <a href="methods.html#topic+Classes">Classes</a> and the examples in <a href="#topic+mxModel">mxModel</a> for more information.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code><a href="#topic+mxModel">mxModel</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Character string.  The name of the model object. </p>
</dd>
<dt><code>matrices</code>:</dt><dd><p>List of the model's <a href="#topic+MxMatrix">MxMatrix</a> objects.</p>
</dd>
<dt><code>algebras</code>:</dt><dd><p>List of the model's <a href="#topic+MxAlgebra">MxAlgebra</a> objects.</p>
</dd>
<dt><code>constraints</code>:</dt><dd><p>List of the model's <a href="#topic+MxConstraint">MxConstraint</a> objects.</p>
</dd>
<dt><code>intervals</code>:</dt><dd><p>List of the model's <a href="#topic+MxInterval">MxInterval</a>
objects, requested via <code><a href="#topic+mxCI">mxCI</a>()</code>.</p>
</dd>
<dt><code>penalties</code>:</dt><dd><p>List of the model's <a href="#topic+MxPenalty-class">MxPenalty</a>
objects.</p>
</dd>
<dt><code>latentVars</code>:</dt><dd><p>&quot;Latent variables;&quot; object of class <code>"MxCharOrList"</code>.</p>
</dd>
<dt><code>manifestVars</code>:</dt><dd><p>&quot;Manifest variables;&quot; object of class <code>"MxCharOrList"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <a href="#topic+MxData">MxData</a>.</p>
</dd>
<dt><code>submodels</code>:</dt><dd><p>List of MxModel objects.</p>
</dd>
<dt><code>expectation</code>:</dt><dd><p>Object of class <a href="#topic+MxExpectation">MxExpectation</a>; dictates the model's specification.</p>
</dd>
<dt><code>fitfunction</code>:</dt><dd><p>Object of class <a href="#topic+MxFitFunction">MxFitFunction</a>; dictates the cost function to be minimized when fitting the model.</p>
</dd>
<dt><code>compute</code>:</dt><dd><p>Object of class <a href="#topic+MxCompute">MxCompute</a>&ndash;the model's compute plan, which contains instructions on what the model is to compute and how to do so.</p>
</dd>
<dt><code>independent</code>:</dt><dd><p>Logical; is the model to be run independently from other submodels?</p>
</dd>
<dt><code>options</code>:</dt><dd><p>List of model-specific options, set by <code><a href="#topic+mxOption">mxOption</a>()</code>.</p>
</dd>
<dt><code>output</code>:</dt><dd><p>List of model output produced during a call to <code><a href="#topic+mxRun">mxRun</a>()</code>.</p>
</dd>
<dt><code>.newobjects</code>:</dt><dd><p>Logical; for internal use.</p>
</dd>
<dt><code>.resetdata</code>:</dt><dd><p>Logical; for internal use.</p>
</dd>
<dt><code>.wasRun</code>:</dt><dd><p>Logical; for internal use.</p>
</dd>
<dt><code>.modifiedSinceRun</code>:</dt><dd><p>Logical; for internal use.</p>
</dd>
<dt><code>.version</code>:</dt><dd><p>Object of class <code>"package_version"</code>; for internal use.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "MxModel")</code>: Accessor.  Accesses slots by slot-name.  Also accesses constituent <a href="#topic+Named-entity">named entities</a>, by name.</p>
</dd>
<dt>$&lt;-</dt><dd><p><code>signature(x = "MxModel")</code>: Assignment.  Generally, this method will not allow the user to make unsafe changes to the MxModel object.</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "MxModel")</code>: Accessor for constituent <a href="#topic+Named-entity">named entities</a>.</p>
</dd>
<dt>[[&lt;-</dt><dd><p><code>signature(x = "MxModel")</code>: Assignment for a <a href="#topic+Named-entity">named entity</a>.</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "MxModel")</code>: Returns names of slots and <a href="#topic+Named-entity">named entities</a>.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "MxModel")</code>: &quot;Print&quot; method. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MxModel")</code>: &quot;Show&quot; method. </p>
</dd>
</dl>

<p>Note that <code><a href="#topic+imxInitModel">imxInitModel</a>()</code>, <code><a href="#topic+imxModelBuilder">imxModelBuilder</a>()</code>, <code><a href="#topic+imxTypeName">imxTypeName</a>()</code>, and <code><a href="#topic+imxVerifyModel">imxVerifyModel</a>()</code> are separately documented methods for class &quot;MxModel&quot;.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxExpectationRAM">mxExpectationRAM</a>, <a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a>, <a href="#topic+mxModel">mxModel</a> for creating MxModel objects. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>

<hr>
<h2 id='mxModelAverage'>
Information-Theoretic Model-Averaging and Multimodel Inference
</h2><span id='topic+mxModelAverage'></span><span id='topic+omxAkaikeWeights'></span><span id='topic+omxAICWeights'></span>

<h3>Description</h3>

<p><code>omxAkaikeWeights()</code> orders a list of <a href="#topic+MxModel">MxModels</a> (hereinafter, the &quot;candidate set&quot; of models) from best to worst AIC, reports their Akaike weights, and indicates which are in the confidence set for best-approximating model.  <code>mxModelAverage()</code> calls <code>omxAkaikeWeights()</code> and includes its output, and also reports model-average point estimates and (if requested) their standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxModelAverage(reference=character(0), models=list(),
include=c("onlyFree","all"), SE=NULL, refAsBlock=FALSE, covariances=list(), 
type=c("AIC","AICc"), conf.level=0.95)

omxAkaikeWeights(models=list(), type=c("AIC","AICc"), conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxModelAverage_+3A_reference">reference</code></td>
<td>
<p>Vector of character strings referring to <a href="#topic+omxGetParameters">parameters</a>, <a href="#topic+MxMatrix">MxMatrices</a>, or <a href="#topic+MxAlgebra">MxAlgebras</a> for which model-average estimates are to be computed. Defaults to <code>NULL</code>.  If a zero-length value is provided, only the output of <code>omxAkaikeWeights()</code> is returned, with a warning.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_models">models</code></td>
<td>
<p>The candidate set of models: a list of at least two <a href="#topic+MxModel">MxModel</a> objects, each of which must be uniquely identified by the value of its <code>name</code> slot.  Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_include">include</code></td>
<td>
<p>Character string, either <code>"onlyFree"</code> (default) or <code>"all"</code>.  When calculating model-average estimates for a given reference quantity, should all the MxModels in the candidate set be included in the calculations, or only those in which the quantity is freely estimated?  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_se">SE</code></td>
<td>
<p>Logical; should standard errors be reported for the model-average point estimates?  Defaults to <code>NULL</code>, in which case standard errors are reported if argument <code>include="onlyFree"</code>, and not reported otherwise.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_refasblock">refAsBlock</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), <code>mxModelAverage()</code> will include a matrix of model-conditional sampling variances for the reference quantities in its output, and model-average results may be based on different subsets of the candidate set if <code>include="onlyFree"</code>.  If <code>TRUE</code>, <code>mxModelAverage()</code> will instead include a joint sampling covariance matrix for all reference quantities, and will throw an error if <code>include="onlyFree"</code> and if it is not the case that all reference quantities are freely estimated in all models in the candidate set.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_covariances">covariances</code></td>
<td>
<p>Optional list of repeated-sampling covariance matrices of free parameter estimates (possibly from bootstrapping or the sandwich estimator); defaults to an empty list.  A non-empty list must either be of the same length as <code>models</code>, or have named elements corresponding to names of MxModels in the candidate set.  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_type">type</code></td>
<td>
<p>Character string specifying which information criterion to use: either <code>"AIC"</code> for the ordinary AIC (default), or <code>"AICc"</code> for Hurvich &amp; Tsai's (1989) sample-size corrected AIC.</p>
</td></tr>
<tr><td><code id="mxModelAverage_+3A_conf.level">conf.level</code></td>
<td>
<p>Numeric proportion specifying the desired coverage probability of the confidence set for best-approximating model among the candidate set (Burnham &amp; Anderson, 2002).  Defaults to 0.95.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If statistical inferences (hypothesis tests and confidence intervals) are the motivation for calculating model-average point estimates and their standard errors, then <code>include="onlyFree"</code> (the default) is recommended.  Note that, if models in which a quantity is held fixed are included in calculating the quantity's model-average estimate, then that estimate cannot even asymptotically be normally distributed (Bartels, 1997).
</p>
<p>If argument <code>covariances</code> is non-empty, then either it must be of the same length as argument <code>models</code>, or all of its elements must be named after an MxModel in <code>models</code> (an MxModel's name is the character string in its <code>name</code> slot).  If <code>covariances</code> is of the same length as <code>models</code> but lacks element names, <code>mxModelAverage()</code> will assume that they are ordered so that the first element of <code>covariances</code> is to be used with the first MxModel, the second element is to be used with the second MxModel, and so on.  Otherwise, <code>mxModelAverage()</code> assigns the elements of <code>covariances</code> to the MxModels by matching element names to MxModel names.  If <code>covariances</code> doesn't provide a covariance matrix for a given MxModel&ndash;perhaps because it is empty, or only provides matrices for a nonempty proper subset of the candidate set&ndash;<code>mxModelAverage()</code> will fall back to its default behavior of calculating a covariance matrix from the Hessian matrix in the MxModel's output slot.  If a covariance matrix cannot be thus calculated and <code>SE=TRUE</code>, <code>SE</code> is coerced to <code>FALSE</code>, with a warning.
</p>
<p>The matrices in <code>covariances</code> must have complete row and column names, equal to the free parameter labels of the corresponding MxModel.  These names indicate to which free parameter a given row or column corresponds.
</p>


<h3>Value</h3>

<p><code>omxAkaikeWeights()</code> returns a dataframe, with one row for each element of <code>models</code>.  The rows are sorted by their MxModel's AIC (or AICc), from best to worst.  The dataframe has five columns:
</p>

<ol>
<li> <p><code>"model"</code>: Character string. The name of the MxModel.
</p>
</li>
<li> <p><code>"AIC"</code> or <code>"AICc"</code>: Numeric.  The MxModel's AIC or AICc.
</p>
</li>
<li> <p><code>"delta"</code>: Numeric.  The MxModel's AIC (or AICc) minus the best (smallest) AIC (or AICc) in the candidate set.
</p>
</li>
<li> <p><code>"AkaikeWeight"</code>: Numeric.  The MxModel's Akaike weight.  This column will sum to unity.
</p>
</li>
<li> <p><code>"inConfidenceSet"</code>: Character.  Will contain an asterisk if the MxModel is in the confidence set for best-approximating model.
</p>
</li></ol>

<p>The dataframe also has an attribute, <code>"unsortedModelNames"</code>, which contains the names of the MxModels in the same order as they appear in <code>models</code> (i.e., without sorting them by their AIC). 
</p>
<p>If a zero-length value is provided for argument <code>reference</code>, then <code>mxModelAverage()</code> returns only the output of <code>omxAkaikeWeights()</code>, with a warning.  Otherwise, for the default values of its arguments, <code>mxModelAverage()</code> returns a list with four elements:
</p>

<ol>
<li> <p><code>"Model-Average Estimates"</code>: A numeric matrix with one row for each distinct quantity specified by <code>reference</code>, and as many as two columns.  Its rows are named for the corresponding reference quantities.  Its first column, <code>"Estimate"</code>, contains the model-average point estimates.  If standard errors are being calculated, then its second column, <code>"SE"</code>, contains the &quot;model-unconditional&quot; standard errors of the model-average point estimates.  Otherwise, there is no second column.
</p>
</li>
<li> <p><code>"Model-wise Estimates"</code>: A numeric matrix with one row for each distinct quantity specified by <code>reference</code> (indicated by row name), and one column for each MxModel (indicated by column name).  Each element is an estimate of the given reference quantity, from the given MxModel.  Quantities that cannot be evaluated for a given MxModel are reported as <code>NA</code>.
</p>
</li>
<li> <p><code>"Model-wise Sampling Variances"</code>: A numeric matrix just like the one in list element 2, except that its elements are the estimated sampling variances of the corresponding model-conditional point estimates in list element 2.  Variances for fixed quantities are reported as 0 if <code>include="all"</code>, and as <code>NA</code> if <code>include="onlyFree"</code>; however, if no covariance matrix is available for a model, all of that model's sampling variances will be reported as <code>NA</code>.
</p>
</li>
<li> <p><code>"Akaike-Weights Table"</code>: The output from <code>omxAkaikeWeights()</code>.
</p>
</li></ol>

<p>If <code>refAsBlock=TRUE</code>, list element 3 will instead contain be named <code>"Joint Covariance Matrix"</code>, and if <code>SE=TRUE</code>, it will contain the joint sampling covariance matrix for the model-average point estimates.
</p>


<h3>Note</h3>

<p>The &quot;best-approximating model&quot; is defined as the model that truly (&quot;in the population,&quot; so to speak) has the smallest Kullback-Leibler divergence from full reality, among the models in the candidate set (Burnham &amp; Anderson, 2002).
</p>
<p>A model's Akaike weight is interpretable as the relative weight-of-evidence for that model being the best-approximating model, given the observed data and the candidate set.  It has a Bayesian interpretation as the posterior probability that the given model is the best-approximating model in the candidate set, assuming a &quot;savvy&quot; prior probability that depends upon sample size and the number of free parameters in the model (Burnham &amp; Anderson, 2002).
</p>
<p>The confidence set for best-approximating model serves to reflect sampling error in the AICs.  When fitting the candidate set to data over repeated sampling, the confidence set is expected to contain the best-approximating model with probability equal to its confidence level.
</p>
<p>The sampling variances and covariances of the model-average point estimates are calculated from Equations (4) and (5) in Burnham &amp; Anderson (2004).  The standard errors reported by <code>mxModelAverage()</code> are the square roots of those sampling variances.
</p>
<p>For an example of model-averaging and multimodel inference applied to structural equation modeling using OpenMx v1.3 (i.e., well before the functions documented here were implemented), see Kirkpatrick, McGue, &amp; Iacono (2015).
</p>


<h3>References</h3>

<p>Bartels, L. M. (1997).  Specification uncertainty and model averaging.  <em>American Journal of Political Science, 41</em>(2), 641-674.
</p>
<p>Burnham, K. P., &amp; Anderson, D. R.  (2002).  <em>Model Selection and Multimodel Inference: A Practical Information-Theoretic Approach (2nd ed.)</em>.  New York: Springer.
</p>
<p>Burnham, K. P., &amp; Anderson, D. R.  (2004).  Multimodel inference: Understanding AIC and BIC in model selection.  <em>Sociological Methods &amp; Research, 33</em>(2), 261-304.  doi:10.1177/0049124104268644
</p>
<p>Hurvich, C. M., &amp; Tsai, C-L.  (1989).  Regression and time series model selection in small samples.  <em>Biometrika, 76</em>(2), 297-307.
</p>
<p>Kirkpatrick, R. M., McGue, M., &amp; Iacono, W. G.  (2015).  Replication of a gene-environment interaction via multimodel inference: Additive-genetic variance in adolescents' general cognitive ability increases with family-of-origin socioeconomic status.  <em>Behavior Genetics, 45</em>, 200-214.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxCompare">mxCompare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(OpenMx)
data(demoOneFactor)
factorModel1 &lt;- mxModel(
	"OneFactor1",
	mxMatrix(
		"Full", 5, 1, values=0.8, 
		labels=paste("a",1:5,sep=""),
		free=TRUE, name="A"),
	mxMatrix(
		"Full", 5, 1, values=1,
		labels=paste("u",1:5,sep=""),
		free=TRUE, name="Udiag"),
	mxMatrix(
		"Symm", 1, 1, values=1,
		free=FALSE, name="L"),
	mxAlgebra(vec2diag(Udiag),name="U"),
	mxAlgebra(A %*% L %*% t(A) + U, name="R"),
	mxExpectationNormal(
		covariance = "R",
		dimnames = names(demoOneFactor)),
	mxFitFunctionML(),
	mxData(cov(demoOneFactor), type="cov", numObs=500))
factorFit1 &lt;- mxRun(factorModel1)
#Constrain unique variances equal:
factorModel2 &lt;- omxSetParameters(
	model=factorModel1,labels=paste("u",1:5,sep=""),
	newlabels="u",name="OneFactor2")
factorFit2 &lt;- mxRun(factorModel2)
omxAkaikeWeights(models=list(factorFit1,factorFit2))

mxModelAverage(
	reference=c("A","Udiag"), include="all",
	models=list(factorFit1,factorFit2))

</code></pre>

<hr>
<h2 id='mxNormalQuantiles'>mxNormalQuantiles</h2><span id='topic+mxNormalQuantiles'></span><span id='topic+omxNormalQuantiles'></span>

<h3>Description</h3>

<p>Get quantiles from a normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxNormalQuantiles(nBreaks, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxNormalQuantiles_+3A_nbreaks">nBreaks</code></td>
<td>
<p>the number of thresholds, or a vector of the number of thresholds</p>
</td></tr>
<tr><td><code id="mxNormalQuantiles_+3A_mean">mean</code></td>
<td>
<p>the mean of the underlying normal distribution</p>
</td></tr>
<tr><td><code id="mxNormalQuantiles_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the underlying normal distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of quantiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mxNormalQuantiles(3)
mxNormalQuantiles(3, mean=7)
mxNormalQuantiles(2, mean=1, sd=3)
</code></pre>

<hr>
<h2 id='mxOption'>Set or Clear an Optimizer Option</h2><span id='topic+mxOption'></span>

<h3>Description</h3>

<p>The function sets, shows, or clears an option that is specific to the optimizer in the back-end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxOption(model=NULL, key=NULL, value, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxOption_+3A_model">model</code></td>
<td>
<p>An <a href="#topic+MxModel">MxModel</a> object or NULL</p>
</td></tr>
<tr><td><code id="mxOption_+3A_key">key</code></td>
<td>
<p>The name of the option.</p>
</td></tr>
<tr><td><code id="mxOption_+3A_value">value</code></td>
<td>
<p>The value of the option.</p>
</td></tr>
<tr><td><code id="mxOption_+3A_reset">reset</code></td>
<td>
<p>If TRUE then reset all options to their defaults.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mxOption is used to set, clear, or query an option (given in the &lsquo;key&rsquo; argument)
in the back-end optimizer. Valid option keys are listed below.
</p>
<p>Use value = NULL to remove an existing option. Leaving value blank will return
the current value of the option specified by &lsquo;key&rsquo;.
</p>
<p>To reset all options to their default values, use &lsquo;reset = TRUE&rsquo;.
When reset = TRUE, &lsquo;key&rsquo; and &lsquo;value&rsquo; are ignored.
</p>
<p>If the &lsquo;model&rsquo; argument is set to NULL, the default optimizer option (i.e
those applying to all models by default) will be set.
</p>
<p>To see the defaults, use <code>getOption('mxOptions')</code>.
</p>
<p>Before the model is submitted to the back-end, all keys and values are converted into
strings using the <a href="base.html#topic+as.character">as.character</a> function.
</p>
<p><strong>Optimizer specific options</strong>
</p>
<p>The &ldquo;Default optimizer&rdquo; option can only be set globally (i.e., with <code>model=NULL</code>), and not locally (i.e., specifically to a given MxModel).  Although the checkpointing options may be set globally, OpenMx's behavior is only affected by locally set checkpointing options (that is, global checkpointing options are ignored at <a href="#topic+mxRun">runtime</a>).
</p>
<p>Gradient-based optimizers require the gradient of the fit
function. When analytic derivatives are not available,
the gradient is estimated numerically. There are a variety
of options to control the numerical estimation of the
gradient. One option for CSOLNP and SLSQP is
the gradient algorithm. CSOLNP uses the <code>forward</code> method
by default, while SLSQP uses the <code>central</code> method. The
<code>forward</code> method requires 1 time &ldquo;Gradient iterations&rdquo;
function evaluation per parameter
per gradient, while <code>central</code> method requires 2 times
&ldquo;Gradient iterations&rdquo; function evaluations per parameter
per gradient. Users can change the default methods for either of these
optimizers by setting the &ldquo;Gradient algorithm&rdquo; option.
NPSOL usually uses the <code>forward</code> method, but
adaptively switches to <code>central</code> under certain circumstances.
</p>
<p>Options &ldquo;Gradient step size&rdquo;, &ldquo;Gradient iterations&rdquo;, and &ldquo;Function precision&rdquo; have on-load global defaults of <code>"Auto"</code>.  If value <code>"Auto"</code> is in effect for any of these three options at <a href="#topic+mxRun">runtime</a>, then OpenMx selects a reasonable numerical value in its place.  These automated numerical values are intended to (1) adjust for the limited precision of the algorithm for computing multivariate-normal probability integrals, and (2) calculate accurate numeric derivatives at the optimizer's solution.  If the user replaces <code>"Auto"</code> with a valid numerical value, then OpenMx uses that value as-is.
</p>
<p>By default, CSOLNP uses a step size of 10^-7 whereas SLSQP uses
10^-5. The purpose of this difference is to obtain roughly the same
accuracy given other differences in numerical procedure.
If you set a non-default &ldquo;Gradient step size&rdquo;,
it will be used as-is. NPSOL ignores
&ldquo;Gradient step size&rdquo;, and instead uses a function of
<a href="#topic+mxOption">mxOption</a> &ldquo;Function precision&rdquo; to determine its gradient
step size.
</p>
<p>Option &ldquo;Analytic Gradients&rdquo; affects all three optimizers, but some options only affect certain optimizers. Option &ldquo;Gradient algorithm&rdquo; is used by CSOLNP and SLSQP, and ignored by NPSOL. Option &ldquo;Gradient iterations&rdquo; only affects SLSQP. Option &ldquo;Gradient step size&rdquo; is used slightly differently by SLSQP and CSOLNP, and is ignored by NPSOL (see <code><a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>()</code> for details).
</p>
<p>If an mxModel contains <a href="#topic+MxConstraint">mxConstraints</a>, NPSOL is given .4 times the value of the option &ldquo;Feasibility tolerance&rdquo;. If there are no constraints, NPSOL is given a hard-coded value of 1e-5 (its own native default).
</p>
<p><em>Note</em>: Where constraints are present, NPSOL is given 0.4 times the value of the mxOption &ldquo;Feasibility Tolerance&rdquo;, and this is about a million times bigger than NPSOL's own native default. Values of &ldquo;Feasibility Tolerance&rdquo; around 1e-5 may be needed to get constraint performance similar to NPSOL's default. Note also that NPSOL's criterion for returning a status code of 0 versus 1 for a given solution depends partly on &ldquo;Optimality tolerance&rdquo;.
</p>
<p>For a block of <code>n</code> ordinal variables, the maximum number of integration points that OpenMx may use to calculate multivariate-normal probability integrals is given by
<code>mvnMaxPointsA + mvnMaxPointsB*n + mvnMaxPointsC*n*n +
  exp(mvnMaxPointsD + mvnMaxPointsE * n * log(mvnRelEps))</code>.
Integral approximation is stopped once either &lsquo;mvnAbsEps&rsquo; or
&lsquo;mvnRelEps&rsquo; is satisfied.
Use of &lsquo;mvnAbsEps&rsquo; is deprecated.
</p>
<p>The maximum number of major iterations (the option  &ldquo;Major iterations&rdquo;)
for optimization for NPSOL  can be specified either by using a
numeric value (such as 50, 1000, etc) or by specifying a user-defined function.
The user-defined function should accept two arguments as input, the number of
parameters and the number of constraints, and return a numeric value as output.
</p>
<p>OpenMx options
</p>

<table>
<tr>
 <td style="text-align: right;">
Calculate Hessian </td><td style="text-align: center;"> [Yes | No]       </td><td style="text-align: left;"> calculate the Hessian explicitly after optimization. </td>
</tr>
<tr>
 <td style="text-align: right;">
Standard Errors   </td><td style="text-align: center;"> [Yes | No]       </td><td style="text-align: left;"> return standard error estimates from the explicitly calculate hessian. </td>
</tr>
<tr>
 <td style="text-align: right;">
Default optimizer </td><td style="text-align: center;"> [NPSOL | SLSQP | CSOLNP] </td><td style="text-align: left;"> the gradient-descent optimizer to use </td>
</tr>
<tr>
 <td style="text-align: right;">
Number of Threads </td><td style="text-align: center;"> [0|1|2|...|10|...] </td><td style="text-align: left;"> number of threads used
for optimization. Default value is taken from the environment variable
OMP_NUM_THREADS or, if that is not set, 2. </td>
</tr>
<tr>
 <td style="text-align: right;">
Feasibility tolerance </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> the maximum acceptable absolute violations in linear and nonlinear constraints. </td>
</tr>
<tr>
 <td style="text-align: right;">
Optimality tolerance </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> the accuracy with which the final iterate approximates a solution to the optimization problem; roughly, the number of reliable significant figures that the fitfunction value should have at the solution. </td>
</tr>
<tr>
 <td style="text-align: right;">
Gradient algorithm </td><td style="text-align: center;"> see list </td><td style="text-align: left;"> finite difference method, either 'forward' or 'central'. </td>
</tr>
<tr>
 <td style="text-align: right;">
Gradient iterations </td><td style="text-align: center;"> 1:4 </td><td style="text-align: left;"> the number of Richardson extrapolation iterations</td>
</tr>
<tr>
 <td style="text-align: right;">
Gradient step size </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> amount of change made to free parameters when numerically calculating gradient</td>
</tr>
<tr>
 <td style="text-align: right;">
Analytic Gradients </td><td style="text-align: center;"> [Yes | No] </td><td style="text-align: left;"> should the optimizer use analytic gradients (if available)?</td>
</tr>
<tr>
 <td style="text-align: right;">
loglikelihoodScale </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> factor by which the loglikelihood is scaled. </td>
</tr>
<tr>
 <td style="text-align: right;">
Parallel diagnostics </td><td style="text-align: center;"> [Yes | No] </td><td style="text-align: left;"> whether to issue diagnostic
messages about use of multiple threads </td>
</tr>
<tr>
 <td style="text-align: right;">
Nudge zero starts </td><td style="text-align: center;"> [TRUE | FALSE] </td><td style="text-align: left;"> Should OpenMx
"nudge" starting values of zero to 0.1 at runtime? </td>
</tr>
<tr>
 <td style="text-align: right;">
Status OK </td><td style="text-align: center;"> character vector </td><td style="text-align: left;"> Status codes that are considered to indicate a successful optimization </td>
</tr>
<tr>
 <td style="text-align: right;">
Max minutes </td><td style="text-align: center;"> numeric </td><td style="text-align: left;"> Maximum backend elapsed time, in minutes
</td>
</tr>

</table>

<p>NPSOL-specific options
</p>

<table>
<tr>
 <td style="text-align: right;">
Nolist                </td><td style="text-align: center;">         </td><td style="text-align: left;"> this option suppresses printing of the options </td>
</tr>
<tr>
 <td style="text-align: right;">
Print level           </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> the value of <var>i</var> controls the amount of printout produced by the major iterations </td>
</tr>
<tr>
 <td style="text-align: right;">
Minor print level     </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> the value of <var>i</var> controls the amount of printout produced by the minor iterations </td>
</tr>
<tr>
 <td style="text-align: right;">
Print file            </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> for <var>i</var> &gt; 0 a full log is sent to the file with logical unit number <var>i</var>. </td>
</tr>
<tr>
 <td style="text-align: right;">
Summary file          </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> for <var>i</var> &gt; 0 a brief log will be output to file <var>i</var>. </td>
</tr>
<tr>
 <td style="text-align: right;">
Function precision    </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> a measure of accuracy with which the fitfunction and constraint functions can be computed. </td>
</tr>
<tr>
 <td style="text-align: right;">
Infinite bound size   </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> if <var>r</var> &gt; 0 defines the "infinite" bound bigbnd. </td>
</tr>
<tr>
 <td style="text-align: right;">
Major iterations      </td><td style="text-align: center;"> <var>i</var> or a function </td><td style="text-align: left;"> the maximum number of major iterations before termination. </td>
</tr>
<tr>
 <td style="text-align: right;">
Verify level          </td><td style="text-align: center;"> [-1:3 | Yes | No]     </td><td style="text-align: left;"> see NPSOL manual. </td>
</tr>
<tr>
 <td style="text-align: right;">
Line search tolerance </td><td style="text-align: center;"> <var>r</var>    </td><td style="text-align: left;"> controls the accuracy with which a step is taken. </td>
</tr>
<tr>
 <td style="text-align: right;">
Derivative level      </td><td style="text-align: center;"> [0-3]      </td><td style="text-align: left;"> see NPSOL manual. </td>
</tr>
<tr>
 <td style="text-align: right;">
Hessian               </td><td style="text-align: center;"> [Yes | No] </td><td style="text-align: left;"> return the Hessian (Yes) or the transformed Hessian (No). </td>
</tr>
<tr>
 <td style="text-align: right;">
Step Limit            </td><td style="text-align: center;"> <var>r</var> </td><td style="text-align: left;"> maximum change in free parameters at first step of linesearch. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Checkpointing options
</p>

<table>
<tr>
 <td style="text-align: right;">
Always Checkpoint    </td><td style="text-align: center;"> [Yes | No]    </td><td style="text-align: left;"> whether to checkpoint all models during optimization.</td>
</tr>
<tr>
 <td style="text-align: right;">
Checkpoint Directory </td><td style="text-align: center;">    path       </td><td style="text-align: left;"> the directory into which checkpoint files are written. </td>
</tr>
<tr>
 <td style="text-align: right;">
Checkpoint Prefix    </td><td style="text-align: center;">    string     </td><td style="text-align: left;"> the string prefix to add to all checkpoint filenames. </td>
</tr>
<tr>
 <td style="text-align: right;">
Checkpoint Fullpath  </td><td style="text-align: center;">    path       </td><td style="text-align: left;"> overrides the directory and prefix (useful to output to /dev/fd/2) </td>
</tr>
<tr>
 <td style="text-align: right;">
Checkpoint Units     </td><td style="text-align: center;">    see list   </td><td style="text-align: left;"> the type of units for checkpointing: 'minutes', 'iterations', or 'evaluations'. </td>
</tr>
<tr>
 <td style="text-align: right;">
Checkpoint Count     </td><td style="text-align: center;">    <var>i</var>    </td><td style="text-align: left;"> the number of units between checkpoint intervals. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Model transformation options
</p>

<table>
<tr>
 <td style="text-align: right;">
Error Checking           </td><td style="text-align: center;"> [Yes | No] </td><td style="text-align: left;"> whether model consistency checks are performed in the OpenMx front-end </td>
</tr>
<tr>
 <td style="text-align: right;">
No Sort Data             </td><td style="text-align: center;">            </td><td style="text-align: left;"> character vector of model names for which FIML data sorting is not performed </td>
</tr>
<tr>
 <td style="text-align: right;">
RAM Inverse Optimization </td><td style="text-align: center;"> [Yes | No] </td><td style="text-align: left;"> whether to enable solve(I - A) optimization </td>
</tr>
<tr>
 <td style="text-align: right;">
RAM Max Depth            </td><td style="text-align: center;"> <var>i</var>    </td><td style="text-align: left;"> the maximum depth to be used when solve(I - A) optimization is enabled </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Multivariate normal integration parameters
</p>

<table>
<tr>
 <td style="text-align: right;">
maxOrdinalPerBlock </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> maximum number of ordinal variables
to evaluate together </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnMaxPointsA </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> base number of integration points </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnMaxPointsB </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> number of integration points per ordinal variable </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnMaxPointsC </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> number of integration points per squared ordinal variables </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnMaxPointsD </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> see details </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnMaxPointsE </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> see details </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnAbsEps     </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> absolute error tolerance </td>
</tr>
<tr>
 <td style="text-align: right;">
mvnRelEps     </td><td style="text-align: center;"> <var>i</var> </td><td style="text-align: left;"> relative error tolerance </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>If a model is provided, it is returned with the optimizer option either set
or cleared. If value is empty, the current value is returned.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+mxModel">mxModel</a>()</code>, as almost all uses of <code>mxOption()</code> are via an mxModel whose options are set or cleared.  See <code><a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>()</code> for details on how different optimizers are affected by different options. See <a href="#topic+as.statusCode">as.statusCode</a> for information about the <code>Status OK</code> option.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set the Numbder of Threads (cores to use)
mxOption(key="Number of Threads", value=imxGetNumThreads())

testModel &lt;- mxModel(model = "testModel5") # make a model to use for example
testModel$options   # show the model options (none yet)
options()$mxOptions # list all mxOptions (global settings)

testModel &lt;- mxOption(testModel, "Function precision", 1e-5) # set precision
testModel &lt;- mxOption(testModel, "Function precision", NULL) # clear precision
# N.B. This is model-specific precision (defaults to global setting)

# may optimize for speed
# at cost of not getting standard errors
testModel &lt;- mxOption(testModel, "Calculate Hessian", "No")
testModel &lt;- mxOption(testModel, "Standard Errors"  , "No")

testModel$options # see the list of options you set

</code></pre>

<hr>
<h2 id='MxOptionalChar-class'>An optional character</h2><span id='topic+MxOptionalChar-class'></span>

<h3>Description</h3>

<p>An optional character
</p>

<hr>
<h2 id='MxOptionalCharOrNumber-class'>A character, integer, or NULL</h2><span id='topic+MxOptionalCharOrNumber-class'></span>

<h3>Description</h3>

<p>A character, integer, or NULL
</p>

<hr>
<h2 id='MxOptionalDataFrame-class'>An optional data.frame</h2><span id='topic+MxOptionalDataFrame-class'></span>

<h3>Description</h3>

<p>An optional data.frame
</p>

<hr>
<h2 id='MxOptionalDataFrameOrMatrix-class'>An optional data.frame or matrix</h2><span id='topic+MxOptionalDataFrameOrMatrix-class'></span>

<h3>Description</h3>

<p>An optional data.frame or matrix
</p>

<hr>
<h2 id='MxOptionalInteger-class'>An optional integer</h2><span id='topic+MxOptionalInteger-class'></span>

<h3>Description</h3>

<p>An optional integer
</p>

<hr>
<h2 id='MxOptionalLogical-class'>An optional logical</h2><span id='topic+MxOptionalLogical-class'></span>

<h3>Description</h3>

<p>This is an internal class, the union of NULL and logical.
</p>

<hr>
<h2 id='MxOptionalMatrix-class'>An optional matrix</h2><span id='topic+MxOptionalMatrix-class'></span>

<h3>Description</h3>

<p>An optional matrix
</p>

<hr>
<h2 id='MxOptionalNumeric-class'>An optional numeric</h2><span id='topic+MxOptionalNumeric-class'></span>

<h3>Description</h3>

<p>An optional numeric
</p>

<hr>
<h2 id='mxParametricBootstrap'>Assess whether potential parameters should be freed using
parametric bootstrap</h2><span id='topic+mxParametricBootstrap'></span>

<h3>Description</h3>

<p>Data is simulated from &lsquo;nullModel&rsquo;. The parameters named by
&lsquo;labels&rsquo; are freed to obtain the alternative model. The
alternative model is fit against each simulated data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxParametricBootstrap(nullModel, labels,
   alternative=c("two.sided", "greater", "less"),
   ..., alpha=0.05, correction=p.adjust.methods,
   previousRun=NULL, replications=400, checkHess=FALSE,
   signif.stars = getOption("show.signif.stars"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxParametricBootstrap_+3A_nullmodel">nullModel</code></td>
<td>
<p>The model specifying the null distribution</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_labels">labels</code></td>
<td>
<p>A character vector of parameters to free to obtain
the alternative model</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by
name.</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_alpha">alpha</code></td>
<td>
<p>The false positive rate</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_correction">correction</code></td>
<td>
<p>How to adjust the p values for multiple tests.</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_replications">replications</code></td>
<td>
<p>The number of resampling replications. If
available, replications from prior invocation will be reused.</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_previousrun">previousRun</code></td>
<td>
<p>Results to re-use from a previous bootstrap.</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_checkhess">checkHess</code></td>
<td>
<p>Whether to approximate the Hessian in each
replication</p>
</td></tr>
<tr><td><code id="mxParametricBootstrap_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If TRUE, &lsquo;significance stars&rsquo; are
printed for each coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the model has a default compute plan and &lsquo;checkHess&rsquo; is
kept at FALSE then the Hessian will not be approximated or checked.
On the other hand, &lsquo;checkHess&rsquo; is TRUE then the Hessian will be
approximated by finite differences. This procedure is of some value
because it can be informative to check whether the Hessian is positive
definite (see <code><a href="#topic+mxComputeHessianQuality">mxComputeHessianQuality</a></code>).  However,
approximating the Hessian is often costly in terms of CPU time. For
bootstrapping, the parameter estimates derived from the resampled data
are typically of primary interest.
</p>


<h3>Value</h3>

<p>A data frame is returned containing the test results.
Details of the bootstrap replications are stored in the
&lsquo;bootData&rsquo; attribute on the data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(OpenMx)

data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")

base &lt;- mxModel(
  "OneFactorCov", type="RAM",
  manifestVars = manifests,
  latentVars = latents,
  mxPath(from=latents, to=manifests, values=0,  free=FALSE, labels=paste0('l',1:length(manifests))),
  mxPath(from=manifests, arrows=2, values=rlnorm(length(manifests)), lbound=.01),
  mxPath(from=latents, arrows=2, free=FALSE, values=1.0),
  mxPath(from = 'one', to = manifests, values=0, free=TRUE, labels=paste0('m',1:length(manifests))),
  mxData(demoOneFactor, type="raw"))

base &lt;- mxRun(base)

# use more replications, 8 is for demonstration purpose only
mxParametricBootstrap(base, paste0('l', 1:length(manifests)),
                      "two.sided", replications=8)


</code></pre>

<hr>
<h2 id='mxPath'>Create List of Paths</h2><span id='topic+mxPath'></span><span id='topic+MxPath-class'></span><span id='topic+print+2CMxPath-method'></span><span id='topic+show+2CMxPath-method'></span><span id='topic++24+2CMxPath-method'></span><span id='topic++24+3C-+2CMxPath-method'></span>

<h3>Description</h3>

<p>This function creates a list of paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPath(from, to = NA, connect = c("single", "all.pairs", "unique.pairs",
    "all.bivariate", "unique.bivariate"), arrows = 1,
    free = TRUE, values = NA, labels = NA,
    lbound = NA, ubound = NA, ..., joinKey = as.character(NA), step = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPath_+3A_from">from</code></td>
<td>
<p>character vector. These are the sources of the new paths.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_to">to</code></td>
<td>
<p>character vector. These are the sinks of the new paths.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_connect">connect</code></td>
<td>
<p>String. Specifies the type of source to sink connection: &quot;single&quot;, &quot;all.pairs&quot;, &quot;all.bivariate&quot;, &quot;unique.pairs&quot;, &quot;unique.bivariate&quot;. Default value is &quot;single&quot;.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_arrows">arrows</code></td>
<td>
<p>numeric value. Must be either 0 (for Pearson selection), 1 (for single-headed), or 2 (for double-headed arrows).</p>
</td></tr>
<tr><td><code id="mxPath_+3A_free">free</code></td>
<td>
<p>boolean vector. Indicates whether paths are free or fixed.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values of the parameters.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_labels">labels</code></td>
<td>
<p>character vector. The names of the paths.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector. The lower bounds of free parameters.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector. The upper bounds of free parameters.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_...">...</code></td>
<td>
<p>Not used.  Allows OpenMx to catch the use of the
deprecated &lsquo;all&rsquo; argument.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_joinkey">joinKey</code></td>
<td>
<p>character vector. The name of the foreign key to join
against some other model to create a cross model path (regression or
factor loading.</p>
</td></tr>
<tr><td><code id="mxPath_+3A_step">step</code></td>
<td>
<p>numeric vector. The priority for processing arrows=0
paths. For example, step 1 is processed before step 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxPath function creates <a href="#topic+MxPath-class">MxPath</a> objects. These consist of a list of paths describing the relationships between variables in a model using the RAM modeling approach (McArdle and MacDonald, 1984). Variables are referenced by name, and these names must appear in the &lsquo;manifestVars&rsquo; and &lsquo;latentVars&rsquo; arguments of the <a href="#topic+mxModel">mxModel</a> function.
</p>
<p>Paths are specified as going &quot;from&quot; one variable (or set of variables) &quot;to&quot; another variable or set of variables using the &lsquo;from&rsquo; and &lsquo;to&rsquo; arguments, respectively. If &lsquo;to&rsquo; is left empty, it will be set to the value of &lsquo;from&rsquo;.
</p>
<p>&lsquo;connect&rsquo; has five possible connection types: &quot;single&quot;, &quot;all.pairs&quot;, &quot;all.bivariate&quot;, &quot;unique.pairs&quot;, &quot;unique.bivariate&quot;. The default value is &quot;single&quot;. Assuming the values c(&lsquo;a&rsquo;,&lsquo;b&rsquo;,&lsquo;c&rsquo;) for the &lsquo;to&rsquo; and &lsquo;from&rsquo; fields the paths produced by each connection type are as follows:
</p>

<dl>
<dt>&quot;all.pairs&quot;:</dt><dd><p>(a,a), (a,b), (a,c), (b,a), (b,b), (b,c), (c,a), (c,b), (c,c).</p>
</dd>
<dt>&quot;unique.pairs&quot;:</dt><dd><p>(a,a), (a,b), (a,c), (b,b), (b,c), (c,c). </p>
</dd>
<dt>&quot;all.bivariate&quot;:</dt><dd><p>(a,b), (a,c), (b,a), (b,c), (c,a), (c,b).</p>
</dd>
<dt>&quot;unique.bivariate&quot;:</dt><dd><p>(a,b), (a,c), (b,c).</p>
</dd>
<dt>&quot;single&quot;:</dt><dd><p>(a,a), (b,b), (c,c).</p>
</dd>
</dl>

<p>Multiple variables may be input as a vector of variable names. If the &lsquo;connect&rsquo; argument is set to &quot;single&quot;, then paths are created going from each entry in the &lsquo;from&rsquo; vector to the corresponding entry in the &lsquo;to&rsquo; vector. If the &lsquo;to&rsquo; and &lsquo;from&rsquo; vectors are of different lengths when the &lsquo;connect&rsquo; argument is set to &quot;single&quot;, the shorter vector is repeated to make the vectors of equal length.
</p>
<p>The &lsquo;free&rsquo; argument specifies whether the paths created by the mxPath function are free or fixed parameters. This argument may take either TRUE for free parameters, FALSE for fixed parameters, or a vector of TRUEs and FALSEs to be applied in order to the created paths.
</p>
<p>The &lsquo;arrows&rsquo; argument specifies the type of paths created. A value of 1 indicates a one-headed arrow representing regression. This path represents a regression of the &lsquo;to&rsquo; variable on the &lsquo;from&rsquo; variable, such that the arrow points to the &lsquo;to&rsquo; variable in a path diagram. A value of 2 indicates a two-headed arrow, representing a covariance or variance. If multiple paths are created in the same mxPath function, then the &lsquo;arrows&rsquo; argument may take a vector of 1s and 2s to be applied to the set of created paths.
</p>
<p>The &lsquo;values&rsquo; is a numeric vectors containing the starting values of the created paths. &lsquo;values&rsquo; gives a starting value for estimation. The &lsquo;labels&rsquo; argument specifies the names of the resulting <a href="#topic+MxPath-class">MxPath</a> object.  The &lsquo;lbound&rsquo; and &lsquo;ubound&rsquo; arguments specify lower and upper bounds for the created paths.
</p>


<h3>Value</h3>

<p>Returns a list of paths.
</p>


<h3>Note</h3>

<p>The previous implementation of &lsquo;all&rsquo; had unsafe features. Its use is now deprecated, and has been replaced by the new mechanism &lsquo;connect&rsquo; which supports safe and controlled generation of desired combinations of paths.
</p>


<h3>References</h3>

<p>McArdle, J. J. and MacDonald, R. P. (1984). Some algebraic properties of the Reticular Action Model for moment structures. <em>British Journal of Mathematical and Statistical Psychology, 37,</em> 234-251.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxMatrix">mxMatrix</a> for a matrix-based approach to path specification; <a href="#topic+mxModel">mxModel</a> for the container in which mxPaths are embedded. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple Example: 1 factor Confirmatory Factor Analysis

library(OpenMx)

data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents   &lt;- c("G")
factorModel &lt;- mxModel(model="One Factor", type="RAM",
      manifestVars = manifests,
      latentVars   = latents,
      mxPath(from=latents, to=manifests),
      mxPath(from=manifests, arrows=2),
      mxPath(from=latents, arrows=2,free=FALSE, values=1.0),
      mxData(cov(demoOneFactor), type="cov",numObs=500)
)
factorFit &lt;-mxRun(factorModel)
summary(factorFit)

# A more complex example using features of R to compress
#  what would otherwise be a long and error-prone script

# list of 100 variable names: "01"  "02"  "03"...
myManifest &lt;- sprintf("%02d", c(1:100))

# the latent variables for the model
myLatent &lt;- c("G1", "G2", "G3", "G4", "G5")


# Start building the model:
#  Define its type, and add the manifest and latent variable name lists
testModel &lt;- mxModel(model="testModel6", type = "RAM",
                     manifestVars = myManifest, latentVars = myLatent)

# Create covariances between the latent variables and add to the model
# Here we use combn to create the covariances
# nb: To create the variances and covariances in one operation you could use
# expand.grid(myLatent,myLatent) to specify from and to

uniquePairs &lt;- combn(myLatent,2)
covariances &lt;- mxPath(from = uniquePairs[1,],
                      to=uniquePairs[2,], arrows = 2, free = TRUE, values = 1)
testModel &lt;- mxModel(model=testModel, covariances)

# Create variances for the latent variables
variances &lt;- mxPath(from = myLatent,
                    to=myLatent, arrows = 2, free = TRUE, values = 1)
testModel &lt;- mxModel(model=testModel, variances) # add variances to the model

# Make a list of paths from each packet of 20 manifests
#  to one of the 5 latent variables
# nb: The first loading to each latent is fixed to 1 to scale its variance.
singles &lt;- list()
for (i in 1:5) {
    j &lt;- i*20
    singles &lt;- append(singles, mxPath(
                        from = myLatent[i], to = myManifest[(j - 19):j],
                        arrows = 1,
                        free   = c(FALSE, rep(TRUE, 19)),
                        values = c(1, rep(0.75, 19))))
}

# add single-headed paths to the model
testModel &lt;- mxModel(model=testModel, singles)

</code></pre>

<hr>
<h2 id='mxPearsonSelCov'>Perform Pearson Aitken selection</h2><span id='topic+mxPearsonSelCov'></span><span id='topic+mxPearsonSelMean'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
These functions implement the Pearson Aitken selection formulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPearsonSelCov(origCov, newCov)
mxPearsonSelMean(origCov, newCov, origMean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPearsonSelCov_+3A_origcov">origCov</code></td>
<td>
<p>covariance matrix. The covariance prior to selection.</p>
</td></tr>
<tr><td><code id="mxPearsonSelCov_+3A_newcov">newCov</code></td>
<td>
<p>covariance matrix. A subset of <code>origCov</code> to replace.</p>
</td></tr>
<tr><td><code id="mxPearsonSelCov_+3A_origmean">origMean</code></td>
<td>
<p>column vector. A mean vector to adjust.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which dimensions to condition on can be communicated in one
of two ways: (1) <code>newCov</code> is a submatrix of <code>origCov</code>.
The dimnames are matched to determine which
partition of <code>origCov</code> to replace with <code>newCov</code>.
Or (2) <code>newCov</code> is the same dimension as <code>origCov</code>.
The matrix entries are inspected to determine which entries have
changed. The changed entries determine which partition of
<code>origCov</code> to replace with <code>newCov</code>.
</p>
<p>Let the <code class="reqn">n \times n</code> covariance matrix R (<code>origCov</code>) be partitioned into non-empty,
disjoint sets p and q.
Let <code class="reqn">R_{ij}</code> denote the covariance matrix between the p
and q variables where the subscripts denote the variable subsets (e.g. <code class="reqn">R_{pq}</code>).
Let column vectors <code class="reqn">\mu_p</code> and <code class="reqn">\mu_q</code> contain the means of p and q
variables, respectively.
We wish to compute the conditional covariances of the variables in q
for a subset of the population where <code class="reqn">R_{pp}</code> and <code class="reqn">\mu_p</code> are known (or partially known)&mdash;that is, we wish
to <em>condition</em> the covariances and means of q on those of p.
Let <code class="reqn">V_{pp}</code> (<code>newCov</code>) be an arbitrary covariance matrix of the same
dimension as <code class="reqn">R_{pp}</code>.
If we replace <code class="reqn">R_{pp}</code> by <code class="reqn">V_{pp}</code> then the mean
of q (<code>origMean</code>) is transformed as
</p>
<p style="text-align: center;"><code class="reqn">\mu_q \to \mu_q + R_{qp} R_{pp}^{-1} \mu_p</code>
</p>

<p>and the covariance of p and q are transformed as
</p>
<p style="text-align: center;"><code class="reqn">\left[
\begin{array}{c|c}
R_{pp} &amp; R_{pq} \\
\hline
R_{qp} &amp; R_{qq}
\end{array}
\right] \to
\left[
\begin{array}{c|c}
V_{pp} &amp; V_{pp}R_{pp}^{-1}R_{pq} \\
\hline
R_{qp}R_{pp}^{-1}V_{pp} &amp; R_{qq}-R_{qp} (R_{pp}^{-1} - R_{pp}^{-1} V_{pp} R_{pp}^{-1}) R_{pq}
\end{array}
\right]</code>
</p>



<h3>References</h3>

<p>Aitken, A. (1935). Note on selection from a multivariate normal population. <em>Proceedings of
the Edinburgh Mathematical Society (Series 2), 4</em>(2), 106-110.
doi:10.1017/S0013091500008063
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

m1 &lt;- mxModel(
  'selectionTest',
  mxMatrix('Full', 10, 10, values=rWishart(1, 20, toeplitz((10:1)/10))[,,1],
           dimnames=list(paste0('c',1:10),paste0('c',1:10)), name="m1"),
  mxMatrix('Full', 2, 2, values=diag(2),
           dimnames=list(paste0('c',1:2),paste0('c',1:2)), name="m2"),
  mxMatrix('Full', 10, 1, values=runif(10),
           dimnames=list(paste0('c',1:10),c('v')), name="u1"),
  mxAlgebra(mxPearsonSelCov(m1, m2), name="c1"),
  mxAlgebra(mxPearsonSelMean(m1, m2, u1), name="u2")
)

m1 &lt;- mxRun(m1)
</code></pre>

<hr>
<h2 id='mxPenalty'>This function creates a penalty object</h2><span id='topic+mxPenalty'></span>

<h3>Description</h3>

<p>This function creates a penalty object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenalty(
  what,
  epsilon = 1e-05,
  scale = 1,
  how = imxPenaltyTypes,
  smoothProportion = 0.05,
  hyperparams = c(),
  hpranges = list(),
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenalty_+3A_what">what</code></td>
<td>
<p>A character vector of parameters to regularize</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_epsilon">epsilon</code></td>
<td>
<p>how close to zero is zero?</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_scale">scale</code></td>
<td>
<p>a given parameter is divided by <code>scale</code> before comparison with <code>epsilon</code></p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_how">how</code></td>
<td>
<p>what kind of function to use</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_smoothproportion">smoothProportion</code></td>
<td>
<p>what proportion of the region between <code>epsilon</code> and zero should be used to smooth the penalty function</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_hyperparams">hyperparams</code></td>
<td>
<p>a character vector of hyperparameter names</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_hpranges">hpranges</code></td>
<td>
<p>a named list of hyperparameter ranges. Used in search if no ranges are specified.</p>
</td></tr>
<tr><td><code id="mxPenalty_+3A_name">name</code></td>
<td>
<p>Name of the regularizer object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mxPenalty</code> expects to find an <a href="#topic+mxMatrix">mxMatrix</a> with
free parameters that correspond to all named hyperparameters.
</p>
<p>Gradient descent optimizers are designed for and work best on
smooth functions.  All of the regularization penalties implemented
traditionally contain discontinuities.  By default, OpenMx uses
smoothed versions of these functions. Smoothing is controlled by
<code>smoothProportion</code>. If <code>smoothProportion</code> is zero then
the traditional discontinuous functions are used. Otherwise,
<code>smoothProportion</code> of the region between <code>epsilon</code> and
zero is used for smoothing.
</p>

<hr>
<h2 id='MxPenalty-class'>MxPenalty</h2><span id='topic+MxPenalty-class'></span><span id='topic++24+2CMxPenalty-method'></span><span id='topic++24+3C-+2CMxPenalty-method'></span><span id='topic++5B+5B+3C-+2CMxPenalty-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxPenaltyElasticNet'>mxPenaltyElasticNet</h2><span id='topic+mxPenaltyElasticNet'></span>

<h3>Description</h3>

<p>Elastic net regularization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenaltyElasticNet(
  what,
  name,
  alpha = 0,
  alpha.step = 0.1,
  alpha.max = 1,
  lambda = 0,
  lambda.step = 0.1,
  lambda.max = 0.4,
  alpha.min = NA,
  lambda.min = NA,
  epsilon = 1e-05,
  scale = 1,
  ...,
  hyperparams = c("alpha", "lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenaltyElasticNet_+3A_what">what</code></td>
<td>
<p>A character vector of parameters to regularize</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_name">name</code></td>
<td>
<p>Name of the regularizer object</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_alpha">alpha</code></td>
<td>
<p>strength of the mixing parameter to be applied at start (default 0.5).  Note that 0 indicates a ridge regression with penalty </p>
<p style="text-align: center;"><code class="reqn">\frac{lambda}{2}</code>
</p>
<p>, and 1 indicates a LASSO regression with penalty lambda.</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_alpha.step">alpha.step</code></td>
<td>
<p>alpha step during penalty search (default 0.1)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_alpha.max">alpha.max</code></td>
<td>
<p>when to end the alpha search (default 1)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_lambda">lambda</code></td>
<td>
<p>strength of the penalty to be applied at starting values (default 0)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_lambda.step">lambda.step</code></td>
<td>
<p>step function for lambda step (default .01)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_lambda.max">lambda.max</code></td>
<td>
<p>end of lambda range (default .4)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_alpha.min">alpha.min</code></td>
<td>
<p>beginning of the alpha range (default 0)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_lambda.min">lambda.min</code></td>
<td>
<p>beginning of the lambda range (default lambda)</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_epsilon">epsilon</code></td>
<td>
<p>how close to zero is zero?</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_scale">scale</code></td>
<td>
<p>a given parameter is divided by <code>scale</code> before comparison with <code>epsilon</code></p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name</p>
</td></tr>
<tr><td><code id="mxPenaltyElasticNet_+3A_hyperparams">hyperparams</code></td>
<td>
<p>a character vector of hyperparameter names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies elastic net regularization.  Elastic net is a weighted combination of ridge and LASSO penalties.
</p>

<hr>
<h2 id='mxPenaltyLASSO'>mxPenaltyLASSO</h2><span id='topic+mxPenaltyLASSO'></span>

<h3>Description</h3>

<p>Least Absolute Selection and Shrinkage Operator regularization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenaltyLASSO(
  what,
  name,
  lambda = 0,
  lambda.step = 0.01,
  lambda.max = NA,
  lambda.min = NA,
  epsilon = 1e-05,
  scale = 1,
  ...,
  hyperparams = c("lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenaltyLASSO_+3A_what">what</code></td>
<td>
<p>A character vector of parameters to regularize</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_name">name</code></td>
<td>
<p>Name of the regularizer object</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_lambda">lambda</code></td>
<td>
<p>strength of the penalty to be applied at starting values (default 0)</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_lambda.step">lambda.step</code></td>
<td>
<p>step function for lambda step (default .01)</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_lambda.max">lambda.max</code></td>
<td>
<p>end of lambda range (default .4)</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_lambda.min">lambda.min</code></td>
<td>
<p>minimum lambda value (default lambda)</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_epsilon">epsilon</code></td>
<td>
<p>how close to zero is zero?</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_scale">scale</code></td>
<td>
<p>a given parameter is divided by <code>scale</code> before comparison with <code>epsilon</code></p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name</p>
</td></tr>
<tr><td><code id="mxPenaltyLASSO_+3A_hyperparams">hyperparams</code></td>
<td>
<p>a character vector of hyperparameter names</p>
</td></tr>
</table>

<hr>
<h2 id='mxPenaltyRidge'>mxPenaltyRidge</h2><span id='topic+mxPenaltyRidge'></span>

<h3>Description</h3>

<p>Ridge regression regularization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenaltyRidge(
  what,
  name,
  lambda = 0,
  lambda.step = 0.01,
  lambda.max = 0.4,
  lambda.min = NA,
  epsilon = 1e-05,
  scale = 1,
  ...,
  hyperparams = c("lambda")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenaltyRidge_+3A_what">what</code></td>
<td>
<p>A character vector of parameters to regularize</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_name">name</code></td>
<td>
<p>Name of the regularizer object</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_lambda">lambda</code></td>
<td>
<p>strength of the penalty to be applied at start (default 0)</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_lambda.step">lambda.step</code></td>
<td>
<p>lambda step during penalty search (default 0.01)</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_lambda.max">lambda.max</code></td>
<td>
<p>when to end the lambda search (default 0.4)</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_lambda.min">lambda.min</code></td>
<td>
<p>minimum lambda value (default lambda)</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_epsilon">epsilon</code></td>
<td>
<p>how close to zero is zero?</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_scale">scale</code></td>
<td>
<p>a given parameter is divided by <code>scale</code> before comparison with <code>epsilon</code></p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name</p>
</td></tr>
<tr><td><code id="mxPenaltyRidge_+3A_hyperparams">hyperparams</code></td>
<td>
<p>a character vector of hyperparameter names</p>
</td></tr>
</table>

<hr>
<h2 id='mxPenaltySearch'>mxPenaltySearch</h2><span id='topic+mxPenaltySearch'></span>

<h3>Description</h3>

<p>Grid search for the best <a href="#topic+MxPenalty-class">MxPenalty</a> hyperparameters. Uses
<a href="#topic+omxDefaultComputePlan">omxDefaultComputePlan</a> with
<code>penaltySearch=TRUE</code>. Specifically, wraps
<a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a> with <a href="#topic+mxComputePenaltySearch">mxComputePenaltySearch</a>
and passes the model to the backend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenaltySearch(
  model,
  ...,
  silent = FALSE,
  suppressWarnings = FALSE,
  unsafe = FALSE,
  checkpoint = FALSE,
  useSocket = FALSE,
  onlyFrontend = FALSE,
  beginMessage = !silent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenaltySearch_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+MxModel">MxModel</a> object to be optimized.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_silent">silent</code></td>
<td>
<p>A boolean indicating whether to print status to terminal.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>A boolean indicating whether to suppress warnings.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_unsafe">unsafe</code></td>
<td>
<p>A boolean indicating whether to ignore errors.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_checkpoint">checkpoint</code></td>
<td>
<p>A boolean indicating whether to periodically write parameter values to a file.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_usesocket">useSocket</code></td>
<td>
<p>A boolean indicating whether to periodically write parameter values to a socket.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_onlyfrontend">onlyFrontend</code></td>
<td>
<p>A boolean indicating whether to run only front-end model transformations.</p>
</td></tr>
<tr><td><code id="mxPenaltySearch_+3A_beginmessage">beginMessage</code></td>
<td>
<p>A boolean indicating whether to print the number of parameters before invoking the backend.</p>
</td></tr>
</table>

<hr>
<h2 id='mxPenaltyZap'>mxPenaltyZap</h2><span id='topic+mxPenaltyZap'></span>

<h3>Description</h3>

<p>Fix any free parameters within <code>epsilon</code> of zero to
zero. These parameters are no longer estimated. Remove all
<a href="#topic+MxPenalty-class">MxPenalty</a> objects from the model.  This is envisioned to be
used after using <a href="#topic+mxPenaltySearch">mxPenaltySearch</a> to locate the best penalty
hyperparameters and apply penalties to model estimation. While
penalties can simplify a model, they also bias parameters toward
zero. By re-estimating the model after using <code>mxPenaltyZap</code>,
parameters that remain free are likely to exhibit less bias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPenaltyZap(model, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPenaltyZap_+3A_model">model</code></td>
<td>
<p>an <a href="#topic+MxModel">MxModel</a></p>
</td></tr>
<tr><td><code id="mxPenaltyZap_+3A_silent">silent</code></td>
<td>
<p>whether to suppress diagnostic output</p>
</td></tr>
</table>

<hr>
<h2 id='mxPowerSearch'>Power curve</h2><span id='topic+mxPowerSearch'></span><span id='topic+mxPower'></span>

<h3>Description</h3>

<p><code>mxPower</code> is used to evaluate the power to distinguish between a hypothesized effect (<code>trueModel</code>)
and a model where this effect is set to the value of the null hypothesis (<code>falseModel</code>).
</p>
<p><code>mxPowerSearch</code> evaluates power across a range of sample sizes or effect sizes,
choosing intelligent values of, for example, sample size to explore.
</p>
<p>Both functions are flexible, with multiple options to control <em>n</em>, <code>sig.level</code>, <code>method</code>, and 
other factors. Several parameters can take a vector as input. These options are described in detail below.
</p>
<p>Evaluation can either use the non-centrality parameter (which can be very quick) or conduct an empirical evaluation.
</p>
<p><em>note</em>: During longer evaluations, the functions printout helpful progress consisting of a note about what
task is being conducted, e.g. &quot;Search n:power relationship for 'A11'&quot; and, beneath that, an update on the
run, the model being evaluated, and the current candidate value being considered, e.g. &quot;R 15 1p N 79&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxPowerSearch(trueModel, falseModel, n=NULL, sig.level=0.05, ...,
        probes=300L, previousRun=NULL,
        gdFun=mxGenerateData,
        method=c('empirical', 'ncp'),
        grid=NULL,
        statistic=c('LRT','AIC','BIC'),
		OK=mxOption(trueModel, "Status OK"),
		checkHess=FALSE,
		silent=!interactive())

mxPower(trueModel, falseModel, n=NULL, sig.level=0.05, power=0.8, ...,
        probes=300L, gdFun=mxGenerateData,
        method=c('empirical', 'ncp'),
        statistic=c('LRT','AIC','BIC'),
        OK=mxOption(trueModel, "Status OK"), checkHess=FALSE,
        silent=!interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxPowerSearch_+3A_truemodel">trueModel</code></td>
<td>
<p>The true generating model for the data.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_falsemodel">falseModel</code></td>
<td>
<p>Model representing the null hypothesis that we wish to reject.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_n">n</code></td>
<td>
<p>Total rows summing across all submodels proportioned as given in the trueModel. Default = NULL.
If provided, result (power or alpha) solved-for at the given
total sample size.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_sig.level">sig.level</code></td>
<td>
<p>A single value for the p-value (aka false positive or type-1 error rate). Default = .05.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_power">power</code></td>
<td>
<p>One or values for power (a.k.a. 1 - type 2 error) to evaluate. Default = .80</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_probes">probes</code></td>
<td>
<p>The number of probes to use when method = &lsquo;empirical&rsquo;.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_previousrun">previousRun</code></td>
<td>
<p>Output from a prior run of &lsquo;mxPowerSearch&rsquo; to build on.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_gdfun">gdFun</code></td>
<td>
<p>The function invoked to generate new data for each Monte Carlo probe. Default = <code>mxGenerateData</code></p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_method">method</code></td>
<td>
<p>To estimate power: &lsquo;empirical&rsquo; (Monte Carlo method) or &lsquo;ncp&rsquo; (average non-centrality method).</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_grid">grid</code></td>
<td>
<p>A vector of locations at which to evaluate the power. If not provided, a reasonable default will be chosen.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_statistic">statistic</code></td>
<td>
<p>Which test to use to compare models (Default = 'LRT').</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_ok">OK</code></td>
<td>
<p>The set of status codes that are considered successful.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_checkhess">checkHess</code></td>
<td>
<p>Whether to approximate the Hessian in each replication.</p>
</td></tr>
<tr><td><code id="mxPowerSearch_+3A_silent">silent</code></td>
<td>
<p>Whether to show a progress indicator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Power is the chance of obtaining a significant difference when there
is a true difference, i.e., (1 - false negative rate).
The likelihood ratio test is used by default. There are two
methods available to produce a power curve. The default,
<code>method = empirical</code>, works for any model where the likelihood
ratio test works. For example, definition variables and missing data
are fine, but parameters estimated at upper or lower bounds will cause
problems. The <code>method = empirical</code> can require a lot of time
because the models need to be fit 100s of times. An alternate
approach, <code>method = ncp</code>, is much more efficient and takes
advantage of the fact that the non-null distribution of likelihood
ratio test statistic is often <code class="reqn">\chi^2(df_1 - df_0, N \lambda)</code>.
That is, the non-centrality parameter, <code class="reqn">\lambda (lambda)</code>, 
can be assumed, on average, to contribute equally per row. This permits essentially
instant power curves without the burden of tedious simulation. However, definition
variables, missing data, or unconventional models (e.g., mixture distributions) can
violate this assumption. Therefore, we recommend verifying that the output from
<code>method = empirical</code> roughly matches <code>method = ncp</code> on the model of interest
before relying on <code>method = ncp</code>.
</p>
<p><em>note</em>: Unlike <code>method = empirical</code>, <code>method = ncp</code> does not use the
<code>gdFun</code> argument and can be used with models that have summary statistics rather than raw data.
</p>
<p>When <code>method = ncp</code>, parameters of both &lsquo;trueModel&rsquo; and
&lsquo;falseModel&rsquo; are assumed to be converged to their desired values.
In contrast, when <code>method = empirical</code>, &lsquo;trueModel&rsquo;
need not be run or even contain data. On each replication,
data are generated from &lsquo;trueModel&rsquo; at the given parameter
vector. Then both &lsquo;trueModel&rsquo; and &lsquo;falseModel&rsquo; are
fit against these data.
</p>
<p>When <code>statistic = 'LRT'</code> then the models must be nested and
<code>sig.level</code> is used to determine whether the test is rejected.
For &lsquo;AIC&rsquo; and &lsquo;BIC&rsquo;, the test is regarded as rejected
when the &lsquo;trueModel&rsquo; obtains a lower score than the
&lsquo;falseModel&rsquo;. In contrast to <code>statistic='LRT'</code>, there is
no nesting requirement. For example, &lsquo;AIC&rsquo; can be used to
compare a &lsquo;trueModel&rsquo; against its corresponding saturated
model.
</p>

<p><code>mxPower</code> operates in many modes.
When power is passed as <code>NULL</code> then power is calculated and returned.
When power (as a scalar or vector) is given then sample or effect size is (are) returned.
If you pass a list of models for &lsquo;falseModel&rsquo;, each model
will be checked in turn and the results returned as a vector.
If you pass a vector of sample sizes, each sample size will
be checked in turn and the results returns as a vector.
</p>
<p><strong>mxPowerSearch</strong>
</p>
<p>In contrast to <code>mxPower</code>, <code>mxPowerSearch</code> attempts to model
the whole relationship between sample size or effect size and power.
A naive Monte Carlo estimate of power examines a single candidate
sample size at a time.  To obtain the whole curve, and simultaneously,
to reduce the number of simulation probes, <code>mxPowerSearch</code>
employs a binomial family generalized linear model with a logit link
to predict the power curve across the sample sizes of interest
(similar to Schoemann et al, 2014).
</p>
<p>The <code>mxPowerSearch</code> algorithm works in 3
stages. Without loss of generality, our description will use the
sample size to power relationship, but a similar process is used when evaluating
the relationship of parameter value to power. In the first stage, a crude
binary search is used to find the range reasonable values for N. This
stage is complete once we have at least two rejections and at least two
non-rejections. At this point, the binomial intercept and slope model
is fit to these data. If the <em>p</em>-value for the slope is less than
0.25 then we jump to stage 3. Otherwise, we fit an intercept only
binomial model. Our goal is to nail down the intercept (where
power=0.5) because this is the easiest point to find and is a
necessary prerequisite to estimate the variance (a.k.a. slope).
Therefore, we probe at the median of previous probes stepping by 10%
in the direction of the model's predicted intercept. Eventually, after enough
probes, we reach stage 3 where the <em>p</em>-value for the slope is
less than 0.25. At stage 3, our goal is to nail down the interesting
part of the power curve. Therefore, we cycle serially through probes
at 0, 1, and 2 logits from the intercept. This process is continued
for the permitted number of <code>probes</code>.
Occasionally, the <em>p</em>-value for the slope in the stage 3 model
grows larger than 0.25. In this case, we switch back to stage 2
(intercept only) until the stage 3 model start working again.
There are no other convergence criteria. Accuracy continues to improves until the probe
limit is reached.
</p>
<p><em>note</em>: After <code>mxPowerSearch</code> returns, you might find you wanted to run 
additional probes (i.e., bounds are wider than you'd like). You can run more probes
without starting from scratch by passing the previous result back into the function using the
<code>previousRun</code> argument.
</p>
<p>When &lsquo;n&rsquo; is fixed then <code>mxPowerSearch</code> helps answer the
question, &ldquo;how small of a true effect is likely to be detected
at a particular sample size?&rdquo; Only one parameter can be considered at
a time.  The way the simulation works is that a candidate value for
the parameter of interest is loaded into the <code>trueModel</code>, data
are generated, then both the true and false model are fit to the data to
obtain the difference in fit. The candidate parameter is initially set
to halfway between the <code>trueModel</code> and <code>falseModel</code>.  The
power curve will reflect the smallest distance, relative to the false
model, required to have a good chance to reject the false model
according to the chosen statistic.
</p>
<p>Note that the default <code>grid</code> is chosen to show the interesting
part of the power curve (from 0.25 to 0.97).
Especially for <code>method=ncp</code>, this curve is practically
identical for any pair of models (but located at a different range of
sample sizes). However, if you wish to align power curves from more than one 
power analysis, you should select your own <code>grid</code> points (perhaps pass in the
power array from the first to subsequent using <code>grid = </code>).
</p>
<p><em>Note</em>: CI is not given for method=ncp: The estimates are exact
(to the precision of the true and null/false model solutions provided by the user).
</p>


<h3>Value</h3>

<p><code>mxPower</code> returns a vector of sample sizes, powers, or effect sizes.
</p>
<p><code>mxPowerSearch</code> returns a data.frame with one row for each &lsquo;grid&rsquo; point. The
first column is either the sample size &lsquo;N&rsquo; (given as the
proportion of rows provided in <code>trueModel</code>) or the parameter
label. The second column is the power. If <code>method=empirical</code>, <code>lower</code> 
and <code>upper</code> provide a +/-2 SE confidence interval (CI95) 
for the power (as estimated by the binomial logit linear model).
When <code>method=empirical</code> then the &lsquo;probes&rsquo; attribute
contains a data.frame record of the power estimation process.
</p>


<h3>References</h3>

<p>Schoemann, A. M., Miller, P., Pornprasertmanit, S. &amp; Wu, W. (2014). 
Using Monte Carlo simulations to determine power and sample size for planned missing designs. 
<em>International Journal of Behavioral Development</em>, <strong>38</strong>, 471-479.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxCompare">mxCompare</a></code>, <code><a href="#topic+mxRefModels">mxRefModels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

# Make a 1-factor model of 5 correlated variables
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("One Factor", type="RAM",
   manifestVars = manifests,
   latentVars = latents,
   mxPath(from= latents, to= manifests, values= 0.8),
   mxPath(from= manifests, arrows= 2,values= 1),
   mxPath(from= latents, arrows= 2, free= FALSE, values= 1),
   mxPath(from= "one", to= manifests),
   mxData(demoOneFactor, type= "raw")
)
factorModelFit &lt;- mxRun(factorModel)

# The loading of x1 on G is estimated ~ 0.39
# Let's test fixing it to .3
indModel &lt;- factorModelFit
indModel$A$values['x1','G'] &lt;- 0.3
indModel$A$free['x1','G'] &lt;- FALSE
indModel &lt;- mxRun(indModel)

# What power do we have at different sample sizes
# to detect that the G to x1 factor loading is
# really 0.3 instead of 0.39?
mxPowerSearch(factorModelFit, indModel, method='ncp')

# If we want to conduct a study with 80% power to
# find that  the G to x1 factor loading is
# really 0.3 instead of 0.39, what sample size
# should we use?
mxPower(factorModelFit, indModel, method='ncp')
</code></pre>

<hr>
<h2 id='MxRAMGraph-class'>MxRAMGraph</h2><span id='topic+MxRAMGraph-class'></span><span id='topic+MxRAMGraph'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
It is a class for RAM directed graphs.
</p>

<hr>
<h2 id='MxRAMModel-class'>MxRAMModel</h2><span id='topic+MxRAMModel-class'></span><span id='topic++24+3C-+2CMxRAMModel-method'></span><span id='topic++5B+5B+3C-+2CMxRAMModel-method'></span>

<h3>Description</h3>

<p>This is an internal class and should not be used directly.
</p>

<hr>
<h2 id='mxRAMObjective'>DEPRECATED: Create MxRAMObjective Object</h2><span id='topic+mxRAMObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use mxExpectationRAM() and mxFitFunctionML() instead.  As a temporary workaround, mxRAMObjective returns a list containing an MxExpectationNormal object and an MxFitFunctionML object.
</p>
<p>All occurrences of
</p>
<p>mxRAMObjective(A, S, F, M = NA, dimnames = NA, thresholds = NA, vector = FALSE, threshnames = dimnames)
</p>
<p>Should be changed to
</p>
<p>mxExpectationRAM(A, S, F, M = NA, dimnames = NA, thresholds = NA, threshnames = dimnames)
mxFitFunctionML(vector = FALSE)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRAMObjective_+3A_a">A</code></td>
<td>
<p>A character string indicating the name of the 'A' matrix.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_s">S</code></td>
<td>
<p>A character string indicating the name of the 'S' matrix.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_f">F</code></td>
<td>
<p>A character string indicating the name of the 'F' matrix.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_m">M</code></td>
<td>
<p>An optional character string indicating the name of the 'M' matrix.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_dimnames">dimnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the 'F' and 'M' matrices.</p>
</td></tr>   
<tr><td><code id="mxRAMObjective_+3A_thresholds">thresholds</code></td>
<td>
<p>An optional character string indicating the name of the thresholds matrix.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_vector">vector</code></td>
<td>
<p>A logical value indicating whether the objective function result is the likelihood vector.</p>
</td></tr>
<tr><td><code id="mxRAMObjective_+3A_threshnames">threshnames</code></td>
<td>
<p>An optional character vector to be assigned to the column names of the thresholds matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: THIS DESCRIPTION IS DEPRECATED.  Please change to using <a href="#topic+mxExpectationRAM">mxExpectationRAM</a> and <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> as shown in the example below.
</p>
<p>Objective functions were functions for which free parameter values are chosen such that the value of the objective function was minimized. The mxRAMObjective provided maximum likelihood estimates of free parameters in a model of the covariance of a given <a href="#topic+MxData">MxData</a> object. This model is defined by reticular action modeling (McArdle and McDonald, 1984). The 'A', 'S', and 'F' arguments must refer to <a href="#topic+MxMatrix">MxMatrix</a> objects with the associated properties of the A, S, and F matrices in the RAM modeling approach.
</p>
<p>The 'dimnames' arguments takes an optional character vector.  If this argument is not a single NA, then this vector be assigned to be the column names of the 'F' matrix and optionally to the 'M' matrix, if the 'M' matrix exists.
</p>
<p>The 'A' argument refers to the A or asymmetric matrix in the RAM approach. This matrix consists of all of the asymmetric paths (one-headed arrows) in the model. A free parameter in any row and column describes a regression of the variable represented by that row regressed on the variable represented in that column. 
</p>
<p>The 'S' argument refers to the S or symmetric matrix in the RAM approach, and as such must be square. This matrix consists of all of the symmetric paths (two-headed arrows) in the model. A free parameter in any row and column describes a covariance between the variable represented by that row and the variable represented by that column. Variances are covariances between any variable at itself, which occur on the diagonal of the specified matrix.
</p>
<p>The 'F' argument refers to the F or filter matrix in the RAM approach. If no latent variables are included in the model (i.e., the A and S matrices are of both of the same dimension as the data matrix), then the 'F' should refer to an identity matrix. If latent variables are included (i.e., the A and S matrices are not of the same dimension as the data matrix), then the 'F' argument should consist of a horizontal adhesion of an identity matrix and a matrix of zeros. 
</p>
<p>The 'M' argument refers to the M or means matrix in the RAM approach.  It is a 1 x n matrix, where n is the number of manifest variables + the number of latent variables. The M matrix must be specified if either the mxData type is &ldquo;cov&rdquo; or &ldquo;cor&rdquo; and a means vector is provided, or if the mxData type is &ldquo;raw&rdquo;.  Otherwise the M matrix is ignored.
</p>
<p>The <a href="#topic+MxMatrix">MxMatrix</a> objects included as arguments may be of any type, but should have the properties described above. The mxRAMObjective will not return an error for incorrect specification, but incorrect specification will likely lead to estimation problems or errors in the <a href="#topic+mxRun">mxRun</a> function.
</p>
<p>mxRAMObjective evaluates with respect to an <a href="#topic+MxData">MxData</a> object. The <a href="#topic+MxData">MxData</a> object need not be referenced in the mxRAMObjective function, but must be included in the <a href="#topic+MxModel">MxModel</a> object. mxRAMObjective requires that the 'type' argument in the associated <a href="#topic+MxData">MxData</a> object be equal to 'cov' or 'cor'.
</p>
<p>To evaluate, place MxRAMObjective objects, the <a href="#topic+mxData">mxData</a> object for which the expected covariance approximates, referenced <a href="#topic+MxAlgebra">MxAlgebra</a> and <a href="#topic+MxMatrix">MxMatrix</a> objects, and optional <a href="#topic+MxBounds">MxBounds</a> and <a href="#topic+MxConstraint">MxConstraint</a> objects in an <a href="#topic+MxModel">MxModel</a> object. This model may then be evaluated using the <a href="#topic+mxRun">mxRun</a> function. The results of the optimization can be found in the 'output' slot of the resulting model, and may be obtained using the <a href="#topic+mxEval">mxEval</a> function..
</p>


<h3>Value</h3>

<p>Returns a list containing an MxExpectationRAM object and an MxFitFunctionML object. 
</p>


<h3>References</h3>

<p>McArdle, J. J. and MacDonald, R. P. (1984). Some algebraic properties of the Reticular Action Model for moment structures. <em>British Journal of Mathematical and Statistical Psychology, 37,</em> 234-251.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   

# Create and fit a model using mxMatrix, mxAlgebra,
#  mxExpectationNormal, and mxFitFunctionML

library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

# Define the matrices

matrixS &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(1,0,0,1), 
              free=c(TRUE,FALSE,FALSE,TRUE), labels=c("Vx", NA, NA, "Vy"),
              name = "S")
matrixA &lt;- mxMatrix(type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0), 
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA),
              name = "A")
matrixF &lt;- mxMatrix(type="Iden", nrow=2, ncol=2, name="F")
matrixM &lt;- mxMatrix(type = "Full", nrow = 1, ncol = 2, values=c(0,0), 
              free=c(TRUE,TRUE), labels=c("Mx", "My"), name = "M")

# Define the expectation

expFunction &lt;- mxExpectationRAM(M="M", dimnames = tmpNames)

# Choose a fit function

fitFunction &lt;- mxFitFunctionML()

# Define the model

tmpModel &lt;- mxModel(model="exampleRAMModel",
                    matrixA, matrixS, matrixF, matrixM,
                    expFunction, fitFunction,
                    mxData(observed=cov(tmpFrame), type="cov", numObs=nrow(tmpFrame),
                              means = colMeans(tmpFrame)))

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)
</code></pre>

<hr>
<h2 id='mxRename'>Rename a model or submodel</h2><span id='topic+mxRename'></span>

<h3>Description</h3>

<p>This function re-names a model. By default, the top model will be renamed. To rename a specific model, set oldname (see examples).
Importantly, all internal references to the old model name (e.g. in algebras) will be updated to reference the new name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxRename(model, newname, oldname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRename_+3A_model">model</code></td>
<td>
<p>a MxModel object.</p>
</td></tr>
<tr><td><code id="mxRename_+3A_newname">newname</code></td>
<td>
<p>the new name of the model.</p>
</td></tr>
<tr><td><code id="mxRename_+3A_oldname">oldname</code></td>
<td>
<p>the name of the target model to rename. If NA then rename top model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a <a href="#topic+mxModel">mxModel</a> object with the target model renamed.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

# Create a parent model with two submodels:
modelC &lt;- mxModel(model= 'modelC', 
	mxModel(model= 'modelA'),
	mxModel(model= 'modelB')
)

# Rename modelC (the top model) to "model1"
model1 &lt;- mxRename(modelC, 'model_1')

# Rename submodel "modelB" to "model_2"
model1 &lt;- mxRename(model1, oldname = 'modelB', newname = 'model_2')

model1

</code></pre>

<hr>
<h2 id='mxRestore'>Restore model state from a checkpoint file</h2><span id='topic+mxRestore'></span><span id='topic+mxRestoreFromDataFrame'></span>

<h3>Description</h3>

<p>Restore model state from a checkpoint file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxRestore(
  model,
  chkpt.directory = mxOption(model, "Checkpoint directory"),
  chkpt.prefix = mxOption(model, "Checkpoint Prefix"),
  line = NULL,
  strict = FALSE
)

mxRestoreFromDataFrame(model, checkpoint, line = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRestore_+3A_model">model</code></td>
<td>
<p>an <a href="#topic+MxModel">MxModel</a> object</p>
</td></tr>
<tr><td><code id="mxRestore_+3A_chkpt.directory">chkpt.directory</code></td>
<td>
<p>character. Directory where the checkpoint file is located</p>
</td></tr>
<tr><td><code id="mxRestore_+3A_chkpt.prefix">chkpt.prefix</code></td>
<td>
<p>character. Prefix of the checkpoint file</p>
</td></tr>
<tr><td><code id="mxRestore_+3A_line">line</code></td>
<td>
<p>integer. Which line from the checkpoint file to restore (defaults to the last line)</p>
</td></tr>
<tr><td><code id="mxRestore_+3A_strict">strict</code></td>
<td>
<p>logical. Require that the checkpoint name and model name match</p>
</td></tr>
<tr><td><code id="mxRestore_+3A_checkpoint">checkpoint</code></td>
<td>
<p>a data.frame containing the model state</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the arguments &lsquo;chkpt.directory&rsquo; and &lsquo;chkpt.prefix&rsquo; should be identical to the <code><a href="#topic+mxOption">mxOption</a></code>: &lsquo;Checkpoint Directory&rsquo; and &lsquo;Checkpoint Prefix&rsquo; that were specified on the model before execution.
</p>
<p>Alternatively, the checkpoint file can be manually loaded as a data.frame in R and passed to <code><a href="#topic+mxRestoreFromDataFrame">mxRestoreFromDataFrame</a></code>.
Use <code><a href="utils.html#topic+read.table">read.table</a></code> with the options <code>header=TRUE, sep="\t", stringsAsFactors=FALSE, check.names=FALSE</code>.
</p>


<h3>Value</h3>

<p>Returns an MxModel object with free parameters updated to the last
saved values. When &lsquo;line&rsquo; is provided, the MxModel is updated
to the values on that line within the checkpoint file.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>
</p>


<h3>See Also</h3>

<p>Other model state: 
<code><a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>()</code>,
<code><a href="#topic+mxSave">mxSave</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

dir &lt;- tempdir()  # safe place to create files
mxOption(key="Checkpoint Directory", value=dir)

# Create a model that includes an expected covariance matrix,
# an expectation function, a fit function, and an observed covariance matrix

data &lt;- mxData(cov(tmpFrame), type="cov", numObs = 1000)
expCov &lt;- mxMatrix(type="Symm", nrow=2, ncol=2, values=c(.2,.1,.2), free=TRUE, name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", dimnames=tmpNames)
fitFunction &lt;- mxFitFunctionML()
testModel &lt;- mxModel(model="testModel", expCov, data, expFunction, fitFunction)

#Use mxRun to optimize the free parameters in the expected covariance matrix
modelOut &lt;- mxRun(testModel, checkpoint = TRUE)
modelOut$expCov

#Use mxRestore to load the last checkpoint saved state of the model
modelRestore &lt;- mxRestore(testModel)
modelRestore$expCov
</code></pre>

<hr>
<h2 id='mxRetro'>Return random classic Mx error message</h2><span id='topic+mxRetro'></span>

<h3>Description</h3>

<p>This function allows you to obtain a classic Mx error message.
The message returned is random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxRetro()
</code></pre>


<h3>Details</h3>

<p>If you're a nostalgic old sod and you miss the warm, fuzzy
feelings you got from reading one of Mike Neale's patented error messages,
then this function is here to save you from the depths of dire depression.
All credit for this function is due to Sarah Medland, but of course the wisdom
is from Mike Neale.
</p>


<h3>References</h3>

<p>- <a href="https://en.wikipedia.org/wiki/OpenMx">https://en.wikipedia.org/wiki/OpenMx</a>
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+omxBrownie">omxBrownie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(OpenMx)
mxRetro()
</code></pre>

<hr>
<h2 id='mxRObjective'>DEPRECATED: Create MxRObjective Object</h2><span id='topic+mxRObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use mxFitFunctionR() instead.  As a temporary workaround, mxRObjective returns a list containing a NULL MxExpectation object and an MxFitFunctionR object.
</p>
<p>All occurrences of
</p>
<p>mxRObjective(fitfun, ...)
</p>
<p>Should be changed to
</p>
<p>mxFitFunctionR(fitfun, ...)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRObjective_+3A_objfun">objfun</code></td>
<td>
<p>A function that accepts two arguments.</p>
</td></tr>
<tr><td><code id="mxRObjective_+3A_...">...</code></td>
<td>
<p>The initial state information to the objective function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: THIS DESCRIPTION IS DEPRECATED.  Please change to using <a href="#topic+mxExpectationNormal">mxExpectationNormal</a> and <a href="#topic+mxFitFunctionML">mxFitFunctionML</a> as shown in the example below.
</p>
<p>The fitfun argument must be a function that accepts two arguments. The first argument
is the mxModel that should be evaluated, and the second argument is some persistent 
state information that can be stored between one iteration of optimization to the next
iteration. It is valid for the function to simply ignore the second argument.
</p>
<p>The function must return either a single numeric value, or a list of exactly two elements.
If the function returns a list, the first argument must be a single numeric value and the 
second element will be the new persistent state information to be passed into this function
at the next iteration. The single numeric value will be used by the optimizer to perform
optimization.
</p>
<p>The initial default value for the persistent state information is NA.
</p>
<p>Throwing an exception (via stop) from inside fitfun may result
in unpredictable behavior. You may want to wrap your code in
tryCatch while experimenting.
</p>


<h3>Value</h3>

<p>Returns a list containing a NULL mxExpectation object and an MxFitFunctionR object. 
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create and fit a model using mxFitFunctionR

library(OpenMx)

A &lt;- mxMatrix(nrow = 2, ncol = 2, values = c(1:4), free = TRUE, name = 'A')
squared &lt;- function(x) { x ^ 2 }

# Define the objective function in R

objFunction &lt;- function(model, state) {
    values &lt;- model$A$values 
    return(squared(values[1,1] - 4) + squared(values[1,2] - 3) +
        squared(values[2,1] - 2) + squared(values[2,2] - 1))
}

# Define the expectation function

fitFunction &lt;- mxFitFunctionR(objFunction)

# Define the model

tmpModel &lt;- mxModel(model="exampleModel", A, fitFunction)

# Fit the model and print a summary

tmpModelOut &lt;- mxRun(tmpModel)
summary(tmpModelOut)

</code></pre>

<hr>
<h2 id='mxRowObjective'>DEPRECATED: Create MxRowObjective Object</h2><span id='topic+mxRowObjective'></span>

<h3>Description</h3>

<p>WARNING: Objective functions have been deprecated as of OpenMx 2.0.  
</p>
<p>Please use mxFitFunctionRow() instead.  As a temporary workaround, mxRowObjective returns a list containing a NULL MxExpectation object and an MxFitFunctionRow object.
</p>
<p>All occurrences of
</p>
<p>mxRowObjective(rowAlgebra, reduceAlgebra, dimnames,
rowResults = &quot;rowResults&quot;, filteredDataRow = &quot;filteredDataRow&quot;,
existenceVector = &quot;existenceVector&quot;)
</p>
<p>Should be changed to
</p>
<p>mxFitFunctionRow(rowAlgebra, reduceAlgebra, dimnames,
rowResults = &quot;rowResults&quot;, filteredDataRow = &quot;filteredDataRow&quot;,
existenceVector = &quot;existenceVector&quot;)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRowObjective_+3A_rowalgebra">rowAlgebra</code></td>
<td>
<p>A character string indicating the name of the algebra to be evaluated row-wise.</p>
</td></tr>
<tr><td><code id="mxRowObjective_+3A_reducealgebra">reduceAlgebra</code></td>
<td>
<p>A character string indicating the name of the algebra that collapses the row results into a single number which is then optimized.</p>
</td></tr>
<tr><td><code id="mxRowObjective_+3A_dimnames">dimnames</code></td>
<td>
<p>A character vector of names corresponding to columns be extracted from the data set.</p>
</td></tr>
<tr><td><code id="mxRowObjective_+3A_rowresults">rowResults</code></td>
<td>
<p>The name of the auto-generated &quot;rowResults&quot; matrix.  See details.</p>
</td></tr>
<tr><td><code id="mxRowObjective_+3A_filtereddatarow">filteredDataRow</code></td>
<td>
<p>The name of the auto-generated &quot;filteredDataRow&quot; matrix. See details.</p>
</td></tr>
<tr><td><code id="mxRowObjective_+3A_existencevector">existenceVector</code></td>
<td>
<p>The name of the auto-generated &quot;existenceVector&quot; matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objective functions are functions for which free parameter values are chosen such that the value of the objective function is minimized. The mxRowObjective function evaluates a user-defined <a href="#topic+MxAlgebra">MxAlgebra</a> object called the &lsquo;rowAlgebra&rsquo; in a row-wise fashion.  It then stores results of the row-wise evaluation in another <a href="#topic+MxAlgebra">MxAlgebra</a> object called the &lsquo;rowResults&rsquo;.  Finally, the mxRowObjective function collapses the row results into a single number which is then used for optimization.  The <a href="#topic+MxAlgebra">MxAlgebra</a> object named by the &lsquo;reduceAlgebra&rsquo; collapses the row results into a single number.
</p>
<p>The &lsquo;filteredDataRow&rsquo; is populated in a row-by-row fashion with all the non-missing data from the current row.  You cannot assume that the length of the filteredDataRow matrix remains constant (unless you have no missing data). The &lsquo;existenceVector&rsquo; is populated in a row-by-row fashion with a value of 1.0 in column j if a non-missing value is present in the data set in column j, and a value of 0.0 otherwise. Use the functions <a href="#topic+omxSelectRows">omxSelectRows</a>, <a href="#topic+omxSelectCols">omxSelectCols</a>, and <a href="#topic+omxSelectRowsAndCols">omxSelectRowsAndCols</a> to shrink other matrices so that their dimensions will be conformable to the size of &lsquo;filteredDataRow&rsquo;. 
</p>


<h3>Value</h3>

<p>Please use mxFitFunctionRow() instead.  As a temporary workaround, mxRowObjective returns a list containing a NULL MxExpectation object and an MxFitFunctionRow object.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Model that adds two data columns row-wise, then sums that column
# Notice no optimization is performed here.

library(OpenMx)

xdat &lt;- data.frame(a=rnorm(10), b=1:10) # Make data set
amod &lt;- mxModel(model="example1",
            mxData(observed=xdat, type='raw'),
            mxAlgebra(sum(filteredDataRow), name = 'rowAlgebra'),
            mxAlgebra(sum(rowResults), name = 'reduceAlgebra'),
            mxFitFunctionRow(
                rowAlgebra='rowAlgebra',
                reduceAlgebra='reduceAlgebra',
                dimnames=c('a','b'))
)
amodOut &lt;- mxRun(amod)
mxEval(rowResults, model=amodOut)
mxEval(reduceAlgebra, model=amodOut)

# Model that find the parameter that minimizes the sum of the
#  squared difference between the parameter and a data row.

bmod &lt;- mxModel(model="example2",
            mxData(observed=xdat, type='raw'),
            mxMatrix(values=.75, ncol=1, nrow=1, free=TRUE, name='B'),
            mxAlgebra((filteredDataRow - B) ^ 2, name='rowAlgebra'),
            mxAlgebra(sum(rowResults), name='reduceAlgebra'),
            mxFitFunctionRow(
                rowAlgebra='rowAlgebra',
                reduceAlgebra='reduceAlgebra',
                dimnames=c('a'))
)
bmodOut &lt;- mxRun(bmod)
mxEval(B, model=bmodOut)
mxEval(reduceAlgebra, model=bmodOut)
mxEval(rowResults, model=bmodOut)
</code></pre>

<hr>
<h2 id='mxRun'>Run an OpenMx model</h2><span id='topic+mxRun'></span>

<h3>Description</h3>

<p>This function sends &lsquo;model&rsquo; to the optimizer, and returns the optimized model if it ran without error.
</p>
<p>If  <code>intervals = TRUE</code>, then confidence intervals will be computed on
any <code><a href="#topic+mxCI">mxCI</a></code>s added to the model.
</p>
<p>During a run, &lsquo;mxRun&rsquo; will print the context (e.g. optimizer name or step in the analysis 
e.g. MxComputeNumericDeriv ), followed by the current evaluation count, fit value, and the change 
in fit compared to the last status report. e.g.: 
</p>
<p><code>MxComputeGradientDescent(CSOLNP) evaluations 1258 fit 37702.6 change -0.05861</code>
</p>
<p>This may be followed by progress on the numeric derivative
</p>
<p><code>MxComputeNumericDeriv 313/528</code>
</p>
<p><em>note</em>: For models that prove difficult to run, you might try using <code><a href="#topic+mxTryHard">mxTryHard</a></code> in place of mxRun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxRun(model, ..., intervals = NULL, silent = FALSE, suppressWarnings = FALSE, 
    unsafe = FALSE, checkpoint = FALSE, useSocket = FALSE, onlyFrontend = FALSE, 
    useOptimizer = TRUE, beginMessage=!silent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxRun_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+MxModel">MxModel</a> object to be optimized.</p>
</td></tr>    
<tr><td><code id="mxRun_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_intervals">intervals</code></td>
<td>
<p>A boolean indicating whether to compute the specified confidence intervals.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_silent">silent</code></td>
<td>
<p>A boolean indicating whether to print status to terminal.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>A boolean indicating whether to suppress warnings.</p>
</td></tr>    
<tr><td><code id="mxRun_+3A_unsafe">unsafe</code></td>
<td>
<p>A boolean indicating whether to ignore errors.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_checkpoint">checkpoint</code></td>
<td>
<p>A boolean indicating whether to periodically write parameter values to a file.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_usesocket">useSocket</code></td>
<td>
<p>A boolean indicating whether to periodically write parameter values to a socket.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_onlyfrontend">onlyFrontend</code></td>
<td>
<p>A boolean indicating whether to run only front-end model transformations.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_useoptimizer">useOptimizer</code></td>
<td>
<p>A boolean indicating whether to run only the
log-likelihood of the current free parameter values but not move any
of the free parameters.</p>
</td></tr>
<tr><td><code id="mxRun_+3A_beginmessage">beginMessage</code></td>
<td>
<p>A boolean indicating whether to print the
number of parameters before invoking the backend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mxRun function is used to optimize free parameters in <a href="#topic+MxModel">MxModel</a> objects based on an expectation function and fit function. MxModel objects included in the mxRun function must include an appropriate expectation and fit functions.
</p>
<p>If the &lsquo;silent&rsquo; flag is TRUE, then model execution will not print any status messages to the terminal.
</p>
<p>If the &lsquo;suppressWarnings&rsquo; flag is TRUE, then model execution will not issue a warning if NPSOL returns a non-zero status code.
</p>
<p>If the &lsquo;unsafe&rsquo; flag is TRUE, then many error conditions will not
be detected. Any error condition detected will be downgraded to warnings.  It is strongly recommended to use this feature only for debugging purposes.
</p>
<p>Free parameters are estimated or updated based on the expectation and fit functions. These estimated values, along with estimation information and model fit, can be found in the 'output' slot of MxModel objects after mxRun has been used.
</p>
<p>If a model is dependent on or shares parameters with another model, both models must be included as arguments in another MxModel object. This top-level MxModel object must include expectation and fit functions in both submodels, as well as an additional fit function describing how the results of the first two should be combined (e.g. <code><a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a></code>).
</p>


<h3>Value</h3>

<p>Returns an MxModel object with free parameters updated to their final values.
The return value contains an &quot;output&quot; slot with the results of 
optimization.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+mxTryHard">mxTryHard</a> for running models which prove difficult to optimize; <a href="base.html#topic+summary">summary</a> to print a summary of a run model; <a href="#topic+mxModel">mxModel</a> for more on the model itself; More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create and run the 1-factor CFA on the openmx.ssri.psu.edu front page

# 1. Load OpenMx and the demoOneFactor dataframe

library(OpenMx)
data(demoOneFactor)  

# 2. Define the manifests (5 demo variables) and latents for use in the model

manifests &lt;- names(demoOneFactor) 
latents   &lt;- c("G")

# 3. Build the model, adding paths and data
model &lt;- mxModel(model="One Factor", type="RAM",
    manifestVars = manifests,
    latentVars   = latents,
    mxPath(from=latents, to=manifests, labels=paste("b", 1:5, sep="")),
    mxPath(from=manifests, arrows=2, labels=paste("u", 1:5, sep="")),
    mxPath(from=latents  , arrows=2, free=FALSE, values=1.0),
    mxData(cov(demoOneFactor), type="cov", numObs=500)
)

# 4. Run the model, returning the result into model
model &lt;- mxRun(model) 

# 5. Show a summary of the fitted model and parameter values
summary(model) 

# 6. Print SE-based CIs for the fitted parameter values

confint(model)

# 7. Add likelihood-based CIs to the model and run these

model = mxModel(model, mxCI(paste0("b", 1:5))) 
model &lt;- mxRun(model, intervals = TRUE) 
summary(model)$CI

#       lbound  estimate    ubound note
# b1 0.3675940 0.3967545 0.4285895     
# b2 0.4690663 0.5031569 0.5405838     
# b3 0.5384588 0.5766635 0.6186705     
# b4 0.6572678 0.7020702 0.7514609     
# b5 0.7457231 0.7954529 0.8503486     

# 8. Demonstrate mxTryHard

model &lt;- mxTryHard(model, intervals = TRUE) 

</code></pre>

<hr>
<h2 id='mxSave'>Save model state to a checkpoint file</h2><span id='topic+mxSave'></span>

<h3>Description</h3>

<p>The function saves the last state of a model to a checkpoint file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxSave(model, chkpt.directory = ".", chkpt.prefix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxSave_+3A_model">model</code></td>
<td>
<p>an <a href="#topic+MxModel">MxModel</a> object</p>
</td></tr>
<tr><td><code id="mxSave_+3A_chkpt.directory">chkpt.directory</code></td>
<td>
<p>character. Directory where the checkpoint file is located</p>
</td></tr>
<tr><td><code id="mxSave_+3A_chkpt.prefix">chkpt.prefix</code></td>
<td>
<p>character. Prefix of the checkpoint file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, the arguments &lsquo;chkpt.directory&rsquo; and &lsquo;chkpt.prefix&rsquo; should be identical to the <code><a href="#topic+mxOption">mxOption</a></code>: &lsquo;Checkpoint Directory&rsquo; and &lsquo;Checkpoint Prefix&rsquo; that were specified on the model before execution.
</p>
<p>Alternatively, the checkpoint file can be manually loaded as a data.frame in R.  Use <code><a href="utils.html#topic+read.table">read.table</a></code> with the options <code>header=TRUE, sep="\t", stringsAsFactors=FALSE, check.names=FALSE</code>.
</p>


<h3>Value</h3>

<p>Returns a logical indicating the success of writing the checkpoint file to the checkpoint directory.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>
</p>


<h3>See Also</h3>

<p>Other model state: 
<code><a href="#topic+mxComputeCheckpoint">mxComputeCheckpoint</a>()</code>,
<code><a href="#topic+mxRestore">mxRestore</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)

# Simulate some data

x=rnorm(1000, mean=0, sd=1)
y= 0.5*x + rnorm(1000, mean=0, sd=1)
tmpFrame &lt;- data.frame(x, y)
tmpNames &lt;- names(tmpFrame)

dir &lt;- tempdir()  # safe place to create files
mxOption(key="Checkpoint Directory", value=dir)

# Create a model that includes an expected covariance matrix,
# an expectation function, a fit function, and an observed covariance matrix

data &lt;- mxData(cov(tmpFrame), type="cov", numObs = 1000)
expCov &lt;- mxMatrix(type="Symm", nrow=2, ncol=2, values=c(.2,.1,.2), free=TRUE, name="expCov")
expFunction &lt;- mxExpectationNormal(covariance="expCov", dimnames=tmpNames)
fitFunction &lt;- mxFitFunctionML()
testModel &lt;- mxModel(model="testModel", expCov, data, expFunction, fitFunction)

#Use mxRun to optimize the free parameters in the expected covariance matrix
modelOut &lt;- mxRun(testModel)
modelOut$expCov

# Save the ending state of modelOut in a checkpoint file
mxSave(modelOut)

# Restore the saved model from the checkpoint file
modelSaved &lt;- mxRestore(testModel)
modelSaved$expCov
</code></pre>

<hr>
<h2 id='mxSE'>Compute standard errors in OpenMx</h2><span id='topic+mxSE'></span>

<h3>Description</h3>

<p>This function allows you to obtain standard errors for arbitrary
expressions, named entities, and algebras.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxSE(
  x,
  model,
  details = FALSE,
  cov,
  forceName = FALSE,
  silent = FALSE,
  ...,
  defvar.row = as.integer(NA),
  data = "data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxSE_+3A_x">x</code></td>
<td>
<p>the parameter to get SEs on (reference or expression)</p>
</td></tr>
<tr><td><code id="mxSE_+3A_model">model</code></td>
<td>
<p>the <code><a href="#topic+mxModel">mxModel</a></code> to use.</p>
</td></tr>
<tr><td><code id="mxSE_+3A_details">details</code></td>
<td>
<p>logical. Whether to provide further details, e.g. the full
sampling covariance matrix of x.</p>
</td></tr>
<tr><td><code id="mxSE_+3A_cov">cov</code></td>
<td>
<p>optional matrix of covariances among the free parameters. If 
missing, the inverse Hessian from the fitted model is used.</p>
</td></tr>
<tr><td><code id="mxSE_+3A_forcename">forceName</code></td>
<td>
<p>logical; defaults to <code>FALSE</code>.  Set to <code>TRUE</code>
if <code>x</code> is an R symbol that refers to a character string.</p>
</td></tr>
<tr><td><code id="mxSE_+3A_silent">silent</code></td>
<td>
<p>logical; defaults to <code>FALSE</code>.  If <code>TRUE</code>,
message-printing is suppressed.</p>
</td></tr>
<tr><td><code id="mxSE_+3A_...">...</code></td>
<td>
<p>further named arguments passed to <code><a href="#topic+mxEval">mxEval</a></code></p>
</td></tr>
<tr><td><code id="mxSE_+3A_defvar.row">defvar.row</code></td>
<td>
<p>which row to load for any definition variables</p>
</td></tr>
<tr><td><code id="mxSE_+3A_data">data</code></td>
<td>
<p>name of data from which to load definition variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>x can be the name of an algebra, a bracket address, named entity
or arbitrary expression.
When the <code>details</code> argument is TRUE, the full
sampling covariance matrix of <code>x</code> is also returned as part of a list.
The square root of the diagonals of this sampling covariance matrix are
the standard errors.
</p>
<p>When supplying the <code>cov</code> argument, take care that the free parameter
covariance matrix is given, not the information matrix.  These 
two are inverses of one another.
</p>
<p>This function uses the delta method to compute the standard error of arbitrary
and possibly nonlinear functions of the free parameters.  The delta method
makes a first-order Taylor approximation of the nonlinear function.  The
nonlinear function is a map from all the free parameters to some transformed
subset of parameters: the linearization of this map is given by the Jacobian
<code class="reqn">J</code>.  In equation form, the delta method computes standard errors by the following:
</p>
<p style="text-align: center;"><code class="reqn">J^T C J</code>
</p>

<p>where <code class="reqn">J</code> is the Jacobian of the nonlinear parameter transformation
and <code class="reqn">C</code> is the covariance matrix of the free parameters (e.g., two
times the inverse of the Hessian of the minus two log likelihood function).
</p>


<h3>Value</h3>

<p>SE value(s) returned as a matrix when <code>details</code> is FALSE.
When <code>details</code> is TRUE, a list of the SE value(s) and the full 
sampling covariance matrix.
</p>


<h3>References</h3>

<p>- <a href="https://en.wikipedia.org/wiki/Standard_error">https://en.wikipedia.org/wiki/Standard_error</a>
</p>


<h3>See Also</h3>

<p>- <code><a href="#topic+mxCI">mxCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
data(demoOneFactor)
# ===============================
# = Make and run a 1-factor CFA =
# ===============================

latents  = c("G") # the latent factor
manifests = names(demoOneFactor) # manifest variables to be modeled
# ===========================
# = Make and run the model! =
# ===========================
m1 &lt;- mxModel("One Factor", type = "RAM", 
	manifestVars = manifests, latentVars = latents, 
	mxPath(from = latents, to = manifests, labels=paste0('lambda', 1:5)),
	mxPath(from = manifests, arrows = 2),
	mxPath(from = latents, arrows = 2, free = FALSE, values = 1),
	mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)
m1 = mxRun(m1)
mxSE(lambda5, model = m1)
mxSE(lambda1^2, model = m1)
</code></pre>

<hr>
<h2 id='mxSetDefaultOptions'>Reset global options to the default</h2><span id='topic+mxSetDefaultOptions'></span>

<h3>Description</h3>

<p>Reset global options to the default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxSetDefaultOptions()
</code></pre>

<hr>
<h2 id='mxSimplify2Array'>Like simplify2array but works with vectors of different lengths</h2><span id='topic+mxSimplify2Array'></span>

<h3>Description</h3>

<p>Vectors are filled column-by-column into a matrix. Shorter vectors
are padded with NAs to fill whole columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxSimplify2Array(x, higher = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxSimplify2Array_+3A_x">x</code></td>
<td>
<p>a list of vectors</p>
</td></tr>
<tr><td><code id="mxSimplify2Array_+3A_higher">higher</code></td>
<td>
<p>whether to produce a higher rank array (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- 1:3
v2 &lt;- 4:5
v3 &lt;- 6:10
mxSimplify2Array(list(v1,v2,v3))

#     [,1] [,2] [,3]
# [1,]    1    4    6
# [2,]    2    5    7
# [3,]    3   NA    8
# [4,]   NA   NA    9
# [5,]   NA   NA   10
</code></pre>

<hr>
<h2 id='mxStandardizeRAMpaths'>Standardize RAM models' path coefficients</h2><span id='topic+mxStandardizeRAMpaths'></span><span id='topic+mxStandardizeRAMPaths'></span>

<h3>Description</h3>

<p>Provides a dataframe containing the standardized values of all nonzero path coefficients appearing in the <code>A</code> and <code>S</code> matrices of models that use RAM expectation (either of <code>type="RAM"</code> or containing an explicit <code><a href="#topic+mxExpectationRAM">mxExpectationRAM</a>()</code> statement).  These standardized values are what the path coefficients would be if all variables in the analysis&ndash;both manifest and latent&ndash;were standardized to zero mean and unit variance.  If the means are being modeled in addition to the covariance structure, then the dataframe will also contain values of the nonzero elements of the <code>M</code> matrix after they have been re-scaled to standard deviation units.  Can optionally include asymptotic standard errors for the standardized and re-scaled coefficients, computed via the delta method.  Not intended for use with models that contain definition variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxStandardizeRAMpaths(model,SE=FALSE,cov=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxStandardizeRAMpaths_+3A_model">model</code></td>
<td>

<p>An <code><a href="#topic+mxModel">mxModel</a></code> object, that either uses RAM expectation or contains at least one submodel that does.
</p>
</td></tr>
<tr><td><code id="mxStandardizeRAMpaths_+3A_se">SE</code></td>
<td>

<p>Logical.  Should standard errors be included with the standardized point estimates?  Defaults to <code>FALSE</code>.  Certain conditions are required for use of <code>SE=TRUE</code>; see &quot;Details&quot; below.
</p>
</td></tr>
<tr><td><code id="mxStandardizeRAMpaths_+3A_cov">cov</code></td>
<td>

<p>A repeated-sampling covariance matrix for the free-parameter estimates&ndash;say, from the robust &quot;sandwich estimator,&quot; or from bootstrapping&ndash;used to calculate SEs for the standardized path coefficients.  Defaults to <code>NULL</code>, in which case twice the inverse of the Hessian matrix at the ML solution is used.  See below for details concerning concerning cases when <code>model</code> contains independent RAM submodels.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrix <code>A</code> contains the <em>A</em>symmetric paths, i.e. the single-headed arrows.  Matrix <code>S</code> contains the <em>S</em>ymmetric paths, i.e. the double-headed arrows.  The function will work even if <code><a href="#topic+mxMatrix">mxMatrix</a></code> objects named &quot;A&quot; and &quot;S&quot; are absent from the model, since it identifies which matrices in the model have been assigned the roles of <code>A</code> and <code>S</code> in the <code><a href="#topic+mxExpectationRAM">mxExpectationRAM</a></code> statement.  Note that, in models of <code>type="RAM"</code>, the necessary matrices and expectation statement are automatically assembled from the <code><a href="#topic+mxPath">mxPath</a></code> objects.  If present, the <code>M</code> matrix will contain the means of exogenous variables and the intercepts of endogenous variables.
</p>
<p>If <code>model</code> contains any submodels with <code>independent=TRUE</code> that use RAM expectation, <code><a href="#topic+mxStandardizeRAMpaths">mxStandardizeRAMpaths</a>()</code> automatically applies itself recursively over those submodels.  However, if a non-<code>NULL</code> matrix has been supplied for argument <code>cov</code>, that matrix is only used for the &quot;container&quot; model, and is not passed as argument to the recursive calls of the function.  To provide a covariance matrix for calculating SEs in an independent submodel, use <code>mxStandardizeRAMpaths()</code> directly on that submodel.
</p>
<p>Use of <code>SE=TRUE</code> requires that package <code>numDeriv</code> be installed. It also requires that <code>model</code> contain no <code><a href="#topic+mxConstraint">mxConstraint</a></code> statements.  Finally, if <code>cov=NULL</code>, it requires <code>model</code> to have a nonempty <code>hessian</code> element in its output slot.  There are three common reasons why the latter condition may not be met.  First, the model may not have been run yet, i.e. it was not output by <code><a href="#topic+mxRun">mxRun</a>()</code>.  Second, <code><a href="#topic+mxOption">mxOption</a></code> <code>"Hessian"</code> might be set to <code>"No"</code>.  Third, computing the Hessian matrix might possibly have been skipped per a user-defined <code>mxCompute*</code> statement (if any are present in the model).  If <code>model</code> contains RAM-expectation submodels with <code>independent=TRUE</code>, these conditions are checked separately for each such submodel.
</p>
<p>In any event, using these standard errors for hypothesis-testing or forming confidence intervals is <em>not</em> generally advised.  Instead, it is considered best practice to conduct likelihood-ratio tests or compute likelihood-based confidence intervals (from <code><a href="#topic+mxCI">mxCI</a>()</code>), as in examples below.
</p>
<p>The user should note that <code>mxStandardizeRAMpaths()</code> only cares whether an element of <code>A</code> or <code>S</code> (or <code>M</code>) is nonzero, and not whether it is a fixed or free parameter. So, for instance, if the function is used on a model not yet run, any free parameters in <code>A</code> or <code>S</code> initialized at zero will not appear in the function's output.
</p>
<p><strong>The user is warned</strong> to interpret the output of <code>mxStandardizeRAMpaths()</code> cautiously if any elements of <code>A</code> or <code>S</code> depend upon &quot;definition variables&quot; (you have definition variables in your model if the <code>labels</code> of any <code><a href="#topic+mxPath">MxPath</a></code> or <code><a href="#topic+mxMatrix">MxMatrix</a></code> begin with <code>"data."</code>).  Typically, either <code>mxStandardizeRAMpaths()</code>'s results will be valid only for the first row of the raw dataset (and any rows identical to it), or some of the standardized coefficients will be incorrectly reported as zero.
</p>


<h3>Value</h3>

<p>If argument <code>model</code> is a single-group model that uses RAM expecation, then <code>mxStandardizeRAMpaths()</code> returns a dataframe, with one row for each nonzero path coefficient in <code>A</code> and <code>S</code> (and <code>M</code>, if present), and with the following columns:
</p>
<table>
<tr><td><code>name</code></td>
<td>

<p>Character strings that uniquely identify each nonzero path coefficient in terms of the model name, the matrix (&quot;A&quot;, &quot;S&quot;, or &quot;M&quot;), the row number, and the column number.
</p>
</td></tr>
<tr><td><code>label</code></td>
<td>

<p>Character labels for those path coefficients that are labeled elements of an <code><a href="#topic+mxMatrix">mxMatrix</a></code> object, and <code>NA</code> for those that are not.  Note that path coefficients having the same label (and therefore the same UNstandardized value) can have different standardized values, and therefore the same label may appear more than once in this dataframe.
</p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>

<p>Character strings of &quot;A&quot;, &quot;S&quot;, or &quot;M&quot;, depending on which matrix contains the given path coefficient.
</p>
</td></tr>
<tr><td><code>row</code></td>
<td>

<p>Character.  The rownames of the matrix containing each path coefficient; row numbers are used instead if the matrix has no rownames.
</p>
</td></tr>
<tr><td><code>col</code></td>
<td>

<p>Character.  The colnames of the matrix containing each path coefficient; column numbers are used instead if the matrix has no colnames.
</p>
</td></tr>
<tr><td><code>Raw.Value</code></td>
<td>

<p>Numeric values of the raw (i.e., UNstandardized) path coefficients.
</p>
</td></tr>
<tr><td><code>Raw.SE</code></td>
<td>

<p>Numeric values of the asymptotic standard errors of the raw path coefficients if if <code>SE=TRUE</code>, or &quot;not_requested&quot; otherwise. 
</p>
</td></tr>
<tr><td><code>Std.Value</code></td>
<td>

<p>Numeric values of the standardized path coefficients.
</p>
</td></tr>
<tr><td><code>Std.SE</code></td>
<td>

<p>Numeric values of the asymptotic standard errors of the standardized path coefficients if <code>SE=TRUE</code>, or &quot;not_requested&quot; otherwise.
</p>
</td></tr>
</table>
<p>If <code>model</code> is a multi-group model containing at least one submodel with RAM expectation, then <code>mxStandardizeRAMpaths()</code> returns a list.  The list has a number of elements equal to the number of submodels that either have RAM expectation or contain a submodel that does.  List elements corresponding to RAM-expectation submodels contain a dataframe, as described above.  List elements corresponding to &quot;container&quot; submodels are themselves lists, of the kind described here.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrapStdizeRAMpaths">mxBootstrapStdizeRAMpaths</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents   &lt;- c("G")
factorModel &lt;- mxModel(model="One Factor", type="RAM",
      manifestVars = manifests,
      latentVars   = latents,
      mxPath(from=latents, to=manifests),
      mxPath(from=manifests, arrows=2, values=0.1),
      mxPath(from=latents, arrows=2,free=FALSE, values=1.0),
      mxData(cov(demoOneFactor), type="cov",numObs=500)
)
factorFit &lt;-mxRun(factorModel)
summary(factorFit)$parameters
mxStandardizeRAMpaths(model=factorFit,SE=FALSE)

## Likelihood ratio test of variable x1's factor loading:
factorModelNull &lt;- omxSetParameters(factorModel,labels="One Factor.A[1,6]",
                    values=0,free=FALSE)
factorFitNull &lt;- mxRun(factorModelNull)
mxCompare(factorFit,factorFitNull)[2,"p"] #&lt;--p-value

## Confidence intervals for all standardized paths:
factorModel2 &lt;- mxModel(model=factorModel,
                        mxMatrix(type="Iden",nrow=nrow(factorModel$A),name="I"),
                        mxAlgebra( vec2diag(diag2vec( solve(I-A)%*%S%*%t(solve(I-A)) )%^%-0.5) ,
                                   name="InvSD"),
                        mxAlgebra( InvSD %*% A %*% solve(InvSD),
                                   name="Az",dimnames=dimnames(factorModel$A)),
                        mxAlgebra( InvSD %*% S %*% InvSD, 
                                   name="Sz",dimnames=dimnames(factorModel$S)),
                        mxCI(c("Az","Sz"))
)

factorFit2 &lt;- mxRun(factorModel2,intervals=TRUE)
## Contains point values and confidence limits for all paths:
summary(factorFit2)$CI

</code></pre>

<hr>
<h2 id='mxThreshold'>Create List of Thresholds</h2><span id='topic+mxThreshold'></span><span id='topic+mxMarginalProbit'></span><span id='topic+MxThreshold-class'></span><span id='topic+print+2CMxThreshold-method'></span><span id='topic+show+2CMxThreshold-method'></span><span id='topic++24+2CMxThreshold-method'></span><span id='topic++24+3C-+2CMxThreshold-method'></span>

<h3>Description</h3>

<p>This function creates a list of thresholds which mxModel can use to set up a thresholds matrix for a RAM model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxThreshold(vars, nThresh=NA,
	free=FALSE, values=mxNormalQuantiles(nThresh), labels=NA,
	lbound=NA, ubound=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxThreshold_+3A_vars">vars</code></td>
<td>
<p>character vector. These are the variables for which thresholds are to be specified.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_nthresh">nThresh</code></td>
<td>
<p>numeric vector. These are the number of thresholds for each variables listed in &lsquo;vars&rsquo;.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_free">free</code></td>
<td>
<p>boolean vector. Indicates whether threshold parameters are free or fixed.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_values">values</code></td>
<td>
<p>numeric vector. The starting values of the parameters.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_labels">labels</code></td>
<td>
<p>character vector. The names of the parameters.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_lbound">lbound</code></td>
<td>
<p>numeric vector. The lower bounds of free parameters.</p>
</td></tr>
<tr><td><code id="mxThreshold_+3A_ubound">ubound</code></td>
<td>
<p>numeric vector. The upper bounds of free parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you are new to ordinal data modeling and just want something quick to make your ordinal data work, we recommend you try the <code><a href="umx.html#topic+umxThresholdMatrix">umxThresholdMatrix</a></code> function in the <code>umx</code> package.
</p>
<p>The mxPath function creates <a href="#topic+MxThreshold-class">MxThreshold</a> objects. These consist of a list of ordinal variables and the thresholds that define the relationship between the observed ordinal variable and the continuous latent variable assumed to underlie it. This function directly mirrors the usage of <a href="#topic+mxPath">mxPath</a>, but is used to specify thresholds rather than means, variances and bivariate relationships.
</p>
<p>The &lsquo;vars&rsquo; argument specifies which variables you wish to specify thresholds for. Variables are referenced by name, and these names must appear in the &lsquo;manifestVar&rsquo; argument of the <a href="#topic+mxModel">mxModel</a> function if thresholds are to be correctly processed. Additionally, variables for which thresholds are specified must be specified as ordinal factors in whatever data is included in the model.
</p>
<p>The &lsquo;nThresh&rsquo; argument specifies how many thresholds are to be specified for the variable or variables included in the &lsquo;vars&rsquo; argument. The number of thresholds for a particular variable should be one fewer than the number of categories specified for that variable.
</p>
<p>The &lsquo;free&rsquo; argument specifies whether the thresholds created by the mxThreshold function are free or fixed parameters. This argument may take either TRUE for free parameters, FALSE for fixed parameters, or a vector of TRUEs and FALSEs to be applied in order to the created thresholds.
</p>
<p>&lsquo;values&rsquo; is a numeric vector containing the starting values of the created thresholds. This gives a starting point for estimation. The &lsquo;labels&rsquo; argument specifies the names of the parameters in the resulting <a href="#topic+MxThreshold-class">MxThreshold</a> object.  The &lsquo;lbound&rsquo; and &lsquo;ubound&rsquo; arguments specify lower and upper bounds for the created threshold parameters.
</p>
<p>Thresholds for multiple variables may be specified simultaneously by including a vector of variable names to the &lsquo;vars&rsquo; argument. When multiple variables are included in the &lsquo;vars&rsquo; argument, the length of the &lsquo;vars&rsquo; argument must be evenly divisable by the length of the &lsquo;nThresh&rsquo; argument. All subsequent arguments (&lsquo;free&rsquo; through &lsquo;ubound&rsquo;) should have their lengths be a factor of the total number of thresholds specified for all variables.
</p>
<p>If four variables are included in the &lsquo;vars&rsquo; argument, then the &lsquo;nThresh&rsquo; argument should contain either one, two or four elements. If the &lsquo;nThresh&rsquo; argument specifies two thresholds for each variable, then &lsquo;free&rsquo;, &lsquo;values&rsquo;, and all subsequent arguments should specify eight values by including one, two, four or eight elements. Whenever fewer values are specified than are required (e.g., specify two values for eight thresholds), then the entire vector of values is repeated until the required number of values is reached, and will return an error if the correct number of values cannot be achieved by repeating the entire vector.
</p>


<h3>Value</h3>

<p>Returns a list of thresholds.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="umx.html#topic+umxThresholdMatrix">umxThresholdMatrix</a></code> 
<code>demo("mxThreshold")</code>
<a href="#topic+mxPath">mxPath</a> for comparable specification of paths. <a href="#topic+mxMatrix">mxMatrix</a> for a matrix-based approach to thresholds specification; <a href="#topic+mxModel">mxModel</a> for the container in which mxThresholds are embedded. More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
# threshold objects for three variables: 2 binary, and one ordinal.
mxThreshold(vars = c("z1", "z2", "z3"), nThresh = c(1,1,2),
  free = TRUE, values = c(-1, 0, -.5, 1.2) )
</code></pre>

<hr>
<h2 id='mxTryHard'>Make multiple attempts to run a model</h2><span id='topic+mxTryHard'></span><span id='topic+mxTryHardOrig'></span><span id='topic+mxTryHardctsem'></span><span id='topic+mxTryHardWideSearch'></span><span id='topic+mxTryHardOrdinal'></span><span id='topic+THard'></span>

<h3>Description</h3>

<p>Makes multiple attempts to fit an MxModel object with <code><a href="#topic+mxRun">mxRun</a>()</code> until the optimizer yields an acceptable solution or the maximum number of attempts (set by <code>extraTries</code>) is reached.  Between attempts, start values are perturbed by random numbers (see details). Optimization-control parameters may also be altered.  From among its attempts, the function returns the fitted model with the best fit (smallest fit-function value). If <code>bestInitsOutput</code> is TRUE, then in addition the start values used for the best-fitting model will be printed to the console.
</p>
<p><em>note</em>: If the model contains <code><a href="#topic+mxConstraint">mxConstraint</a></code>s, or if <code><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a></code> is being used, the Hessian cannot be checked, and so <code>checkHess</code> will be coerced to FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxTryHard(model, extraTries = 10, greenOK = FALSE, loc = 1, scale = 0.25,
initialGradientStepSize = imxAutoOptionValue("Gradient step size"),
initialGradientIterations = imxAutoOptionValue('Gradient iterations'),
initialTolerance=as.numeric(mxOption(NULL,'Optimality tolerance')), 
checkHess = TRUE, fit2beat = Inf, paste = TRUE,	iterationSummary=FALSE, 
bestInitsOutput=TRUE, showInits=FALSE, verbose=0, intervals = FALSE,
finetuneGradient=TRUE, jitterDistrib=c("runif","rnorm","rcauchy"), exhaustive=FALSE,
maxMajorIter=3000, OKstatuscodes, wtgcsv=c("prev","best","initial"), silent=interactive())

mxTryHardOrig(model, finetuneGradient=FALSE, maxMajorIter=NA, 
wtgcsv=c("prev","best"), silent=FALSE, ...)

mxTryHardctsem(model, initialGradientStepSize = .00001, 
initialGradientIterations = 1,
initialTolerance=1e-12,	jitterDistrib="rnorm", ...)

mxTryHardWideSearch(model, finetuneGradient=FALSE, jitterDistrib="rcauchy", 
exhaustive=TRUE, wtgcsv="prev", ...)

mxTryHardOrdinal(model, greenOK = TRUE,	checkHess = FALSE, 
finetuneGradient=FALSE, exhaustive=TRUE,
OKstatuscodes=c(0,1,5,6), wtgcsv=c("prev","best"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxTryHard_+3A_model">model</code></td>
<td>
<p>The MxModel to be run.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_extratries">extraTries</code></td>
<td>
<p>The number of attempts to run the model <em>in addition to the first</em>.  In effect, is the maximum number of attempts <code>mxTryHard()</code> will make, since the function will stop once an acceptable solution is reached.  Defaults to 10 (for <code>mxTryHard()</code>), in which case a maximum of 11 total attempts will be made.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_greenok">greenOK</code></td>
<td>
<p>Logical; is a solution with Mx status GREEN (optimizer status code 1) acceptable?  Defaults to <code>FALSE</code> (for <code>mxTryHard()</code>).  Ignored if a value is provided for <code>OKstatuscodes</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_loc">loc</code>, <code id="mxTryHard_+3A_scale">scale</code></td>
<td>
<p>Numeric. The location and scale parameters of the distribution from which random values are drawn to perturb start values between attempts, defaulting respectively to 1 and 0.25.  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_initialgradientstepsize">initialGradientStepSize</code>, <code id="mxTryHard_+3A_initialgradientiterations">initialGradientIterations</code>, <code id="mxTryHard_+3A_initialtolerance">initialTolerance</code></td>
<td>
<p>Numeric.  Initial values of optimization-control parameters passed to <code><a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>()</code> if <code>model</code> is using the default compute plan.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_checkhess">checkHess</code></td>
<td>
<p>Logical; is a positive-definite Hessian a requirement for an acceptable solution?  Defaults to <code>TRUE</code> (for <code>mxTryHard()</code>).  If <code>TRUE</code>, the Hessian and standard errors are calculated with each fit attempt, irrespective of the value of relevant <a href="#topic+mxOption">options</a>.  The exception is if <code>model</code> or any of its submodels contains <code><a href="#topic+MxConstraint">MxConstraint</a>s</code>, in which case <code>checkHess</code> is coerced to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_fit2beat">fit2beat</code></td>
<td>
<p>Numeric upper limit to the fitfunction value that an acceptable solution may have.  Useful if a nested submodel of <code>model</code> has already been fitted, since <code>model</code>, with its additional free parameters, should not yield a fitfunction value any greater than that of the submodel.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_paste">paste</code></td>
<td>
<p>Logical.  If <code>TRUE</code> (default), start values for the returned fitted model are printed to console as a comma-separated string.  This is useful if the user wants to copy-paste these values into an <span class="rlang"><b>R</b></span> script, say, in an <code><a href="#topic+omxSetParameters">omxSetParameters</a>()</code> statement. If <code>FALSE</code>, the vector of start values is printed as-is.  Note that this vector, from <code><a href="#topic+omxGetParameters">omxGetParameters</a>()</code>, has names corresponding to the free parameters; these names are not displayed when <code>paste=TRUE</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_iterationsummary">iterationSummary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, displays parameter estimates and fit values for every fit attempt, even if <code>silent=TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_bestinitsoutput">bestInitsOutput</code></td>
<td>
<p>Logical. If <code>TRUE</code> and if <code>silent=FALSE</code>, <code>mxTryHard()</code> displays the starting values that resulted in the best fit, according to format specified by <code>paste</code> argument. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_showinits">showInits</code></td>
<td>
<p>Logical. If <code>TRUE</code>, displays starting values for every fit attempt, even if <code>silent=TRUE</code>.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_verbose">verbose</code></td>
<td>
<p>If <code>model</code> is using the default compute plan, is passed to <code><a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>()</code> to specify level of output printed to console during optimization.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_intervals">intervals</code></td>
<td>
<p>Logical. If TRUE, OpenMx will estimate any specified confidence intervals.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_finetunegradient">finetuneGradient</code></td>
<td>
<p>Logical.  If <code>TRUE</code> (default for <code>mxTryHard()</code>), then as repeated fit attempts appear to be improving, <code>mxTryHard()</code> will adjust optimization-control parameters <code><a href="#topic+mxComputeGradientDescent">gradientStepSize</a></code>, <code><a href="#topic+mxComputeGradientDescent">gradientIterations</a></code>, and <code><a href="#topic+mxComputeGradientDescent">tolerance</a></code>, as well as argument <code>scale</code>, to &quot;fine-tune&quot; its convergence toward an optimal solution.  <code>finetuneGradient=FALSE</code> is recommended for analyses involving thresholds.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_jitterdistrib">jitterDistrib</code></td>
<td>
<p>Character string naming which random-number distribution&ndash;either <a href="stats.html#topic+runif">uniform (rectangular)</a>, <a href="stats.html#topic+rnorm">normal (Gaussian)</a>, or <a href="stats.html#topic+rcauchy">Cauchy</a>&ndash;to be used to perturb start values.  Defaults to the uniform distribution (for <code>mxTryHard()</code>).  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_exhaustive">exhaustive</code></td>
<td>
<p>Logical.  If <code>FALSE</code> (default for <code>mxTryHard()</code>), <code>mxTryHard()</code> stops making additional attempts once it reaches an acceptable solution.  If <code>TRUE</code>, the function instead continues until it reaches its maximum number of attempts (as per <code>extraTries</code>), and returns the best solution it found.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_maxmajoriter">maxMajorIter</code></td>
<td>
<p>Integer; passed to <code><a href="#topic+mxComputeGradientDescent">mxComputeGradientDescent</a>()</code>.  Defaults to 3000, which was the internally hard-coded value <code>mxTryHard()</code> used in a prior version of OpenMx.  Value of <code>NA</code> is permitted, in which case <code>mxTryHard()</code> will calculate a value via the on-load default formula for the &quot;Major iterations&quot; <a href="#topic+mxOption">option</a>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_okstatuscodes">OKstatuscodes</code></td>
<td>
<p>Optional integer vector containing optimizer status codes that an acceptable solution is permitted to have.  <code>mxTryHard()</code> always considers a status code of 0 to be acceptable, this argument notwithstanding. By default, <code>mxTryHard()</code> will consider status code 0 acceptable, and, if <code>greenOK=TRUE</code>, status code 1 as well.  If a value is supplied for <code>OKstatuscodes</code> that conflicts with <code>greenOK</code>, <code>OKstatuscodes</code> controls.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_wtgcsv">wtgcsv</code></td>
<td>
<p>Character vector.  &quot;Where to get current start values.&quot;  See below, under &quot;Details,&quot; for additional information.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_silent">silent</code></td>
<td>
<p>Logical; for <code>mxTryHard()</code>, defaults to <code>TRUE</code> if running interactively, and to <code>FALSE</code> otherwise.  If <code>TRUE</code>, persistent <a href="base.html#topic+message">message-printing</a> during execution of <code>mxTryHard()</code> is suppressed, and non-persistent printing is used instead. The two exceptions are the persistent printing requested by <code>TRUE</code> values of <code>iterationSummary</code> and <code>showInits</code>.</p>
</td></tr>
<tr><td><code id="mxTryHard_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>mxTryHard()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mxTryHardOrig()</code>, <code>mxTryHardctsem()</code>, <code>mxTryHardWideSearch()</code>, and <code>mxTryHardOrdinal()</code> are wrapper functions to the main workhorse function <code>mxTryHard()</code>.  Each wrapper function has default values for certain arguments that are tailored toward a specific purpose.  <code>mxTryHardOrig()</code> imitates the functionality of the earliest implementations of <code>mxTryHard()</code> in OpenMx's history; its chief purpose is to find good start values that lead to an acceptable solution.  <code>mxTryHardctsem()</code> uses <code>mxTryHard()</code> to &quot;zero in&quot; on an acceptable solution with models that can be difficult to optimize, such as continuous-time state-space models.  <code>mxTryHardWideSearch()</code> uses <code>mxTryHard()</code> to search a wide region of the parameter space, in hope of avoiding local fitfunction minima.  <code>mxTryHardOrdinal()</code> attempts to use <code>mxTryHard()</code> as well as it can be used with models involving ordinal data.
</p>
<p>Argument <code>wtgcsv</code> dictates where <code>mxTryHard()</code> is permitted to find free-parameter values, at the start of each fit attempt after the first, before randomly perturbing them to create the current fit attempt's start values.  If <code>"prev"</code> is included, then <code>mxTryHard()</code> is permitted to use the parameter estimates of the most recent non-error fit attempt.  If <code>"best"</code> is included, then <code>mxTryHard()</code> is permitted to use the parameter estimates at the best solution so far.  If <code>"initial"</code> is included, then <code>mxTryHard()</code> is permitted to use the initial start values in <code>model</code>, as provided by the user.  The default is to permit all three, in which case <code>mxTryHard()</code> is written to use the best solution's values if available, and otherwise to use the most recent solution's values,  but to periodically revert to the initial values if recent fit attempts have not improved on the best solution.
</p>
<p>Once the start values are located for the current fit attempt, they are randomly perturbed before being assigned to the MxModel.  The distributional family from which the perturbations are randomly generated is dictated by argument <code>jitterDistrib</code>.  The distribution is parameterized by arguments <code>loc</code> and <code>scale</code>, respectively the location and scale parameters.  The location parameter is the distribution's median.  For the uniform distribution, <code>scale</code> is the absolute difference between its median and extrema (i.e., half the width of the rectangle); for the normal distribution, <code>scale</code> is its standard deviation; and for the Cauchy, <code>scale</code> is one-half its interquartile range.  Start values are first multiplied by random draws from a distribution with the provided <code>loc</code> and <code>scale</code>, then added to random draws from a distribution with the same <code>scale</code> but with a median of zero.
</p>


<h3>Value</h3>

<p>Usually, <code>mxTryHard()</code> returns a post-<code><a href="#topic+mxRun">mxRun</a>()</code> <code><a href="#topic+MxModel">MxModel</a></code> object.  Specifically, this will be the fitted model having the smallest fit-function value found by <code>mxTryHard()</code> during its attempts.  The start values used to obtain this fitted model are printed to console if <code>bestInitsOutput=TRUE</code>.  
</p>
<p>If every attempt at running <code>model</code> fails, <code>mxTryHard()</code> returns an object of class 'try-error'.
</p>
<p><code>mxTryHard()</code> throws a warning if the returned <code><a href="#topic+MxModel">MxModel</a></code> object has a nonzero status code (unless nonzero status codes are considered acceptable per argument <code>greenOK</code> or <code>OKstatuscodes</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxRun">mxRun</a>()</code>, <code><a href="#topic+mxComputeTryHard">mxComputeTryHard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(OpenMx)

data(demoOneFactor)  # load the demoOneFactor dataframe

manifests &lt;- names(demoOneFactor) # set the manifest to the 5 demo variables
latents   &lt;- c("G")  # define 1 latent variable
model &lt;- mxModel(model="One Factor", type="RAM",
    manifestVars = manifests,
    latentVars   = latents,
    mxPath(from=latents, to=manifests, labels=paste("b", 1:5, sep="")),
    mxPath(from=manifests, arrows=2, labels=paste("u", 1:5, sep="")),
    mxPath(from=latents  , arrows=2, free=FALSE, values=1.0),
    mxData(cov(demoOneFactor), type="cov", numObs=500)
)
model &lt;- mxTryHard(model) # Run the model, returning the result into model
summary(model) # Show summary of the fitted model

</code></pre>

<hr>
<h2 id='mxTypes'>List Currently Available Model Types</h2><span id='topic+mxTypes'></span>

<h3>Description</h3>

<p>This function returns a vector of the currently available type names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxTypes()
</code></pre>


<h3>Value</h3>

<p>Returns a character vector of type names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    mxTypes()
</code></pre>

<hr>
<h2 id='mxVersion'>Returns Current Version String</h2><span id='topic+mxVersion'></span>

<h3>Description</h3>

<p>This function returns a string with the current version number of OpenMx.
Optionally (with verbose = TRUE (the default)), it prints a message containing
the version of R, the platform, and the optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxVersion(model = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mxVersion_+3A_model">model</code></td>
<td>
<p> optional <code><a href="#topic+MxModel">MxModel</a></code> to request optimizer from (default = NULL)</p>
</td></tr>
<tr><td><code id="mxVersion_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print version information to the console (default = TRUE)</p>
</td></tr>
</table>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Print useful version information.
mxVersion()
# If you just want the version, use this call.
x = mxVersion(verbose=FALSE)

library(OpenMx)
data(demoOneFactor)  # load the demoOneFactor dataframe
manifests &lt;- names(demoOneFactor) # set the manifest to the 5 demo variables
latents   &lt;- c("G")  # define 1 latent variable
model &lt;- mxModel(model = "One Factor", type = "RAM",
    manifestVars = manifests,
    latentVars   = latents,
    mxPath(from = latents, to = manifests, labels = paste("b", 1:5, sep = "")), 
    mxPath(from = manifests, arrows = 2  , labels = paste("u", 1:5, sep = "")), 
    mxPath(from = latents  , arrows = 2  , free = FALSE, values = 1.0), 
    mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)
mxVersion(model, verbose = TRUE)

</code></pre>

<hr>
<h2 id='MxVersionType-class'>A package_version or character</h2><span id='topic+MxVersionType-class'></span>

<h3>Description</h3>

<p>A package_version or character
</p>

<hr>
<h2 id='myAutoregressiveData'>
Example data with autoregressively related columns
</h2><span id='topic+myAutoregressiveData'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myAutoregressiveData")</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>x variable and time 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>x variable and time 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>x variable and time 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>x variable and time 4</p>
</dd>
<dt><code>x5</code></dt><dd><p>x variable and time 5</p>
</dd>
</dl>



<h3>Details</h3>

<p>The rows are independently and identically distributed, but the columns are and auto-correlation structure.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myAutoregressiveData)
round(cor(myAutoregressiveData), 2)
# note the sub-diagonal correlations (lag 1)
#  x1-x2, x2-x3, x3-x4, x4-x5
# and the second sub-diagonal correlations (lag 2)
#  x1-x3, x2-x4, x3-x5

</code></pre>

<hr>
<h2 id='myFADataRaw'>Example 500-row dataset with 12 generated variables</h2><span id='topic+myFADataRaw'></span>

<h3>Description</h3>

<p>Twelve columns of generated numeric data: x1 x2 x3 x4 x5 x6 y1 y2 y3 z1 z2 z3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(myFADataRaw)</code></pre>


<h3>Details</h3>

<p>The x variables intercorrelate around .6 with each other.
</p>
<p>The y variables intercorrelate around .5 with each other, and correlate around .3 with the X vars.
</p>
<p>There are three ordinal variables, z1, z2, and z3.
</p>
<p>The data are used in some OpenMx examples, especially confirmatory factor analysis.
</p>
<p>There are no missing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myFADataRaw)
str(myFADataRaw)
</code></pre>

<hr>
<h2 id='myGrowthKnownClassData'>
Data for a growth mixture model with the true class membership
</h2><span id='topic+myGrowthKnownClassData'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myGrowthKnownClassData")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>x variable and time 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>x variable and time 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>x variable and time 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>x variable and time 4</p>
</dd>
<dt><code>x5</code></dt><dd><p>x variable and time 5</p>
</dd>
<dt><code>c</code></dt><dd><p>Known class membership variable</p>
</dd>
</dl>



<h3>Details</h3>

<p>The same as <a href="#topic+myGrowthMixtureData">myGrowthMixtureData</a>, but with the class membership variable.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myGrowthKnownClassData)

#plot the observed trajectories
# blue lines are class 1, green lines are class 2
colSel &lt;-c('blue', 'green')[myGrowthKnownClassData$c]
matplot(t(myGrowthKnownClassData[,-6]), type='l', lty=1, col=colSel)

</code></pre>

<hr>
<h2 id='myGrowthMixtureData'>
Data for a growth mixture model
</h2><span id='topic+myGrowthMixtureData'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myGrowthMixtureData")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>x variable and time 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>x variable and time 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>x variable and time 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>x variable and time 4</p>
</dd>
<dt><code>x5</code></dt><dd><p>x variable and time 5</p>
</dd>
</dl>



<h3>Details</h3>

<p>The same as <a href="#topic+myGrowthKnownClassData">myGrowthKnownClassData</a>, but without the class membership variable.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myGrowthMixtureData)

matplot(t(myGrowthMixtureData), type='l', lty=1)

data(myGrowthKnownClassData)
all(myGrowthKnownClassData[,-6]==myGrowthMixtureData)
</code></pre>

<hr>
<h2 id='myLongitudinalData'>
Data for a linear latent growth curve model
</h2><span id='topic+myLongitudinalData'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myLongitudinalData")</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>x variable and time 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>x variable and time 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>x variable and time 3</p>
</dd>
<dt><code>x4</code></dt><dd><p>x variable and time 4</p>
</dd>
<dt><code>x5</code></dt><dd><p>x variable and time 5</p>
</dd>
</dl>



<h3>Details</h3>

<p>Linear growth model with mean intercept around 10, and slope of about 1.5.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myLongitudinalData)

matplot(t(myLongitudinalData), type='l', lty=1)
</code></pre>

<hr>
<h2 id='myRegData'>
Example regression data with correlated predictors
</h2><span id='topic+myRegData'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myRegData")</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following variables.
</p>

<dl>
<dt><code>w</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>x</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>y</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>z</code></dt><dd><p>Outcome variable</p>
</dd>
</dl>



<h3>Details</h3>

<p>w, x, and y are predictors of z.  x and y are correlated.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myRegData)
summary(lm(z ~ ., data=myRegData))

</code></pre>

<hr>
<h2 id='myRegDataRaw'>
Example regression data with correlated predictors
</h2><span id='topic+myRegDataRaw'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myRegDataRaw")</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following variables.
</p>

<dl>
<dt><code>w</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>x</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>y</code></dt><dd><p>Predictor variable</p>
</dd>
<dt><code>z</code></dt><dd><p>Outcome variable</p>
</dd>
</dl>



<h3>Details</h3>

<p>w, x, and y are predictors of z.  x and y are correlated.  Equal to <a href="#topic+myRegData">myRegData</a>.
</p>


<h3>Source</h3>

<p>Simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myRegData)
data(myRegDataRaw)

all(myRegDataRaw == myRegData)

</code></pre>

<hr>
<h2 id='myTwinData'>
Duplicate of twinData
</h2><span id='topic+myTwinData'></span>

<h3>Description</h3>

<p>Legacy dataset from early teaching examples. See <code><a href="#topic+twinData">twinData</a></code> for a more current file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("myTwinData")</code></pre>


<h3>Format</h3>

<p>A data frame with 3808 observations on the following variables.
</p>

<dl>
<dt><code>fam</code></dt><dd><p>Family ID variable</p>
</dd>
<dt><code>age</code></dt><dd><p>Age of the twin pair.  Range: 17 to 88.</p>
</dd>
<dt><code>zyg</code></dt><dd><p>Integer codes for zygosity and gender combinations</p>
</dd>
<dt><code>part</code></dt><dd><p>Cohort</p>
</dd>
<dt><code>wt1</code></dt><dd><p>Weight in kilograms for twin 1</p>
</dd>
<dt><code>wt2</code></dt><dd><p>Weight in kilograms for twin 2</p>
</dd>
<dt><code>ht1</code></dt><dd><p>Height in meters for twin 1</p>
</dd>
<dt><code>ht2</code></dt><dd><p>Height in meters for twin 2</p>
</dd>
<dt><code>htwt1</code></dt><dd><p>Product of ht and wt for twin 1</p>
</dd>
<dt><code>htwt2</code></dt><dd><p>Product of ht and wt for twin 2</p>
</dd>
<dt><code>bmi1</code></dt><dd><p>Body Mass Index for twin 1</p>
</dd>
<dt><code>bmi2</code></dt><dd><p>Body Mass Index for twin 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>Height and weight are highly correlated, and each individually highly heritable.  These data present and opportunity for multivariate behavior genetics modeling.
</p>


<h3>Source</h3>

<p>Timothy Bates
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myTwinData)

plot( ht1 ~ wt1, myTwinData)

</code></pre>

<hr>
<h2 id='mzfData'>
Example twin extended kinship data: MZ female twins
</h2><span id='topic+mzfData'></span>

<h3>Description</h3>

<p>Data for extended twin example ETC88.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mzfData")</code></pre>


<h3>Format</h3>

<p>A data frame with 3099 observations on the following 37 variables.
</p>

<dl>
<dt><code>famid</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a18</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(mzfData)
str(mzfData)
</code></pre>

<hr>
<h2 id='mzmData'>
Example twin extended kinship data: MZ Male data
</h2><span id='topic+mzmData'></span>

<h3>Description</h3>

<p>Data for extended twin example ETC88.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("mzmData")</code></pre>


<h3>Format</h3>

<p>A data frame with 3019 observations on the following 37 variables.
</p>

<dl>
<dt><code>famid</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>e18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>a18</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(mzmData)
str(mzmData)
</code></pre>

<hr>
<h2 id='Named-entity'>Named Entities</h2><span id='topic+Named-entity'></span><span id='topic+Named-entities'></span><span id='topic+named-entity'></span><span id='topic+named-entities'></span>

<h3>Description</h3>

<p>A named entity is an S4 object that can be referenced by name.
</p>


<h3>Details</h3>

<p>Every named entity is guaranteed to have a slot called &quot;name&quot;. Within a model, the named entities of that model can be accessed using the $ operator.  Access is limited to one nesting depth, such that if 'B' is a submodel of 'A', and 'C' is a matrix of 'B', then 'C' must be accessed using A$B$C. 
</p>
<p>The following S4 classes are named entities in the OpenMx library: <a href="#topic+MxAlgebra">MxAlgebra</a>, <a href="#topic+MxConstraint">MxConstraint</a>,  <a href="#topic+MxMatrix">MxMatrix</a>, <a href="#topic+MxModel">MxModel</a>, <a href="#topic+MxData">MxData</a>, and MxObjective.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

# Create a model, add a matrix to it, and then access the matrix by name.

testModel &lt;- mxModel(model="anEmptyModel")

testMatrix &lt;- mxMatrix(type="Full", nrow=2, ncol=2, values=c(1,2,3,4), name="yourMatrix")

yourModel &lt;- mxModel(testModel, testMatrix, name="noLongerEmpty")

yourModel$yourMatrix



</code></pre>

<hr>
<h2 id='nhanesDemo'>
Modified National Health and Nutrition Examination Survey demographic data
</h2><span id='topic+nhanesDemo'></span>

<h3>Description</h3>

<p>This is a national survey run by CDC from 2015-16. More information at: https://wwwn.cdc.gov/Nchs/Nhanes/analyticguidelines.aspx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nhanesDemo")</code></pre>


<h3>Format</h3>

<p>A data frame with 9971 observations and 53 variables.
</p>


<h3>Source</h3>

<p>https://wwwn.cdc.gov/Nchs/Nhanes/2015-2016/DEMO_I.XPT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nhanesDemo)
</code></pre>

<hr>
<h2 id='nuclear_twin_design_data'>
Twin data from a nuclear family design
</h2><span id='topic+nuclear_twin_design_data'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nuclear_twin_design_data")</code></pre>


<h3>Format</h3>

<p>A data frame with 1743 observations on the following variables.
</p>

<dl>
<dt><code>Twin1</code></dt><dd></dd>
<dt><code>Twin2</code></dt><dd></dd>
<dt><code>Father</code></dt><dd></dd>
<dt><code>Mother</code></dt><dd></dd>
<dt><code>zyg</code></dt><dd><p>Zygosity of the twin pair</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a wide format data set.  A single variable has values for different member of the same nuclear family.
</p>


<h3>Source</h3>

<p>Likely simulated.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclear_twin_design_data)

cor(nuclear_twin_design_data[,-5], use="pairwise.complete.obs")

</code></pre>

<hr>
<h2 id='numHess1'>
numeric Hessian data 1
</h2><span id='topic+numHess1'></span>

<h3>Description</h3>

<p>data file used by the HessianTest.R script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("numHess1")</code></pre>


<h3>Format</h3>

<p>A 12 by 12 data frame containing Hessian (numeric variables a-l)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(numHess1)
str(numHess1)
</code></pre>

<hr>
<h2 id='numHess2'>
numeric Hessian data 2
</h2><span id='topic+numHess2'></span>

<h3>Description</h3>

<p>data file used by the HessianTest.R script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("numHess2")</code></pre>


<h3>Format</h3>

<p>A 12 by 12 data frame containing Hessian matrix (numeric variables a-l)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(numHess2)
str(numHess2)
</code></pre>

<hr>
<h2 id='omxAllInt'>All Interval Multivariate Normal Integration</h2><span id='topic+omxAllInt'></span>

<h3>Description</h3>

<p><code>omxAllInt</code> computes the probabilities of a large number of cells of a multivariate normal distribution that has been sliced by a varying number of thresholds in each dimension.  While the same functionality can be achieved by repeated calls to <code><a href="#topic+omxMnor">omxMnor</a></code>, <code>omxAllInt</code> is more efficient for repeated operations on a single covariance matrix.
<code>omxAllInt</code> returns an nx1 matrix of probabilities cycling from lowest to highest thresholds in each column with the rightmost variable in <var>covariance</var> changing most rapidly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxAllInt(covariance, means, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxAllInt_+3A_covariance">covariance</code></td>
<td>
<p>the covariance matrix describing the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="omxAllInt_+3A_means">means</code></td>
<td>
<p>a row vector containing means of the variables of the underlying distribution.</p>
</td></tr>
<tr><td><code id="omxAllInt_+3A_...">...</code></td>
<td>
<p>a matrix or set of matrices containing one column of thresholds for each column of <code>covariance</code>.  Each column must contain a strictly increasing set of thresholds for the corresponding variable of the underlying distribution.  <code>NA</code> values in these thresholds indicate that the list of thresholds in that column has ended.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><var>covariance</var> and <var>means</var> contain the covariances and means of the multivariate distribution from which probabilities are to be calculated.  
</p>
<p><var>covariance</var> must be a square covariance or correlation matrix with one row and column for each variable.  
</p>
<p><var>means</var> must be a vector of length <code>nrows(covariance)</code> that contains the mean for each corresponding variable.
</p>
<p>All further arguments are considered threshold matrices.  
</p>
<p>Threshold matrices contain locations of the hyperplanes delineating the intervals to be calculated.  The first column of the first matrix corresponds to the thresholds for the first variable represented by the covariance matrix.  Subsequent columns of the same matrix correspond to thresholds for subsequent variables in the covariance matrix. If more variables exist in the covariance matrix than in the first threshold matrix, the first column of the second threshold matrix will be used, and so on.  That is, if <var>covariance</var> is a 4x4 matrix, and the three threshold matrices are specified, one with a single column and the others with two columns each, the first column of the first matrix will contain thresholds for the first variable in <var>covariance</var>, the two columns of the second matrix will correspond to the second and third variables of <var>covariance</var>, respectively, and the first column of the third threshold matrix will correspond to the fourth variable.  Any extra columns will be ignored.
</p>
<p>Each column in the threshold matrices must contain some number of strictly increasing thresholds, delineating the boundaries of a cell of integration.  That is, if the integral from -1 to 0 and 0 to 1 are required for a given variable, the corresponding threshold column should contain the values -1, 0, and 1, in that order. Thresholds may be set to Inf or -Inf if a boundary at positive or negative infinity is desired.
</p>
<p>Within a threshold column, a value of +Inf, if it exists, is assumed to be the largest threshold, and any rows after it are ignored in that column.  A value of NA, if it exists, indicates that there are no further thresholds in that column, and is otherwise ignored. A threshold column consisting of only +Inf or NA values will cause an error.
</p>
<p>For all i&gt;1, the value in row i must be strictly larger than the value in row i-1 in the same column.
</p>
<p>The return value of <code>omxAllInt</code> is a matrix consisting of a single column with one row for each combination of threshold levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxMnor">omxMnor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(myFADataRaw)

covariance &lt;- cov(myFADataRaw[,1:5])
means &lt;- colMeans(myFADataRaw[,1:5])

# Integrate from -Infinity to 0 and 0 to 1 on first variable
thresholdForColumn1 &lt;- cbind(c(-Inf, 0,   1))
# Note: The first variable will never be calculated from 1 to +Infinity.

# These columns will be integrated from -Inf to -1, -1 to 0, etc.
thresholdsForColumn2 &lt;- cbind(c(-Inf, -1, 0, 1, Inf))
thresholdsForColumns3and4 &lt;- cbind(c(-Inf, 1.96, 2.326, Inf),
                                   c(-Inf, -1.96, 2.326, Inf))

# The integration
omxAllInt(covariance, means,
  thresholdForColumn1, thresholdsForColumn2,
  thresholdsForColumns3and4, thresholdsForColumn2)
# Notice that columns 2 and 5 are assigned identical thresholds.

#-------------------------------------------------------------
# An alternative specification of the same calculation follows
covariance &lt;- cov(myFADataRaw[,1:5])
means &lt;- colMeans(myFADataRaw[,1:5])

# Note NAs to indicate the end of the sequence of thresholds.
thresholds &lt;- cbind(c(-Inf,     0,     1,  NA,  NA),
                    c(-Inf,    -1,     0,   1, Inf),
                    c(-Inf,  1.96,  2.32, Inf,  NA),
                    c(-Inf, -1.96,  2.32, Inf,  NA),
                    c(-Inf,    -1,     0,   1, Inf))
omxAllInt(covariance, means, thresholds)

</code></pre>

<hr>
<h2 id='omxApply'>On-Demand Parallel Apply</h2><span id='topic+omxApply'></span>

<h3>Description</h3>

<p>If the snowfall library is loaded, then this function calls <code><a href="snowfall.html#topic+sfApply">sfApply</a></code>.  Otherwise it invokes <code><a href="base.html#topic+apply">apply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxApply(x, margin, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxApply_+3A_x">x</code></td>
<td>
<p>a vector (atomic or list) or an expressions vector. Other objects (including classed objects) will be coerced by <code><a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="omxApply_+3A_margin">margin</code></td>
<td>
<p>a vector giving the subscripts which the function will be applied over.</p>
</td></tr>
<tr><td><code id="omxApply_+3A_fun">fun</code></td>
<td>
<p>the function to be applied to each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="omxApply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>fun</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+omxLapply">omxLapply</a></code>, <code><a href="#topic+omxSapply">omxSapply</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- cbind(x1 = 3, x2 = c(4:1, 2:5))
dimnames(x)[[1]] &lt;- letters[1:8]
omxApply(x, 2, mean, trim = .2)

</code></pre>

<hr>
<h2 id='omxAssignFirstParameters'>Assign First Available Values to Model Parameters</h2><span id='topic+omxAssignFirstParameters'></span>

<h3>Description</h3>

<p>Sometimes you may have a free parameter with two different starting values in your model. OpenMx will not run a model until all instances of a free parameter have the same starting value. It is often sufficient to arbitrarily select one of those starting values for optimization. 
</p>
<p>This function accomplishes that task of assigning valid starting values to the free parameters of a model. It selects an arbitrary current value (the &quot;first&quot; value it finds, where &quot;first&quot; is not defined) for each free parameter and uses that value for all instances of that parameter in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxAssignFirstParameters(model, indep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxAssignFirstParameters_+3A_model">model</code></td>
<td>
<p>a MxModel object.</p>
</td></tr>
<tr><td><code id="omxAssignFirstParameters_+3A_indep">indep</code></td>
<td>
<p>assign parameters to independent submodels.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+omxGetParameters">omxGetParameters</a></code>, <code><a href="#topic+omxSetParameters">omxSetParameters</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A     &lt;- mxMatrix('Full', 3, 3, values = c(1:9), labels = c('a','b', NA),
                  free = TRUE, name = 'A')
model &lt;- mxModel(model=A, name = 'model')
model &lt;- omxAssignFirstParameters(model)

# Note: All cells with the same label now have the same start value.
# Note also that NAs are untouched.

model$matrices$A

# $labels
#      [,1] [,2] [,3]
# [1,] "a"  "a"  "a" 
# [2,] "b"  "b"  "b" 
# [3,] NA   NA   NA  
# 
# $values
#      [,1] [,2] [,3]
# [1,]    1    1    1
# [2,]    2    2    2
# [3,]    3    6    9

</code></pre>

<hr>
<h2 id='omxAugmentDataWithWLSSummary'>Estimate summary statistics used by the WLS fit function</h2><span id='topic+omxAugmentDataWithWLSSummary'></span>

<h3>Description</h3>

<p>The summary statistics are returned in the observedStats slot of
the MxData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxAugmentDataWithWLSSummary(
  mxd,
  type = c("WLS", "DWLS", "ULS"),
  allContinuousMethod = c("cumulants", "marginals"),
  ...,
  exogenous = c(),
  fullWeight = TRUE,
  returnModel = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_mxd">mxd</code></td>
<td>
<p>an MxData object containing raw data</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_type">type</code></td>
<td>
<p>the type of WLS weight matrix</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_allcontinuousmethod">allContinuousMethod</code></td>
<td>
<p>which method to use when all indicators are continuous</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_exogenous">exogenous</code></td>
<td>
<p>names variables to be modelled as exogenous</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_fullweight">fullWeight</code></td>
<td>
<p>whether to produce a fullWeight matrix</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_returnmodel">returnModel</code></td>
<td>
<p>whether to return the whole mxModel (TRUE) or just the mxData (FALSE)</p>
</td></tr>
<tr><td><code id="omxAugmentDataWithWLSSummary_+3A_silent">silent</code></td>
<td>
<p>logical. Whether to print status to terminal.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+mxFitFunctionWLS">mxFitFunctionWLS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omxAugmentDataWithWLSSummary(mxData(Bollen[,1:8], 'raw'))
</code></pre>

<hr>
<h2 id='omxBrownie'>Make Brownies in OpenMx</h2><span id='topic+omxBrownie'></span>

<h3>Description</h3>

<p>This function returns a brownie recipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxBrownie(quantity=1, walnuts=TRUE, wfpb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxBrownie_+3A_quantity">quantity</code></td>
<td>
<p>Number of batches of brownies desired. Defaults to one.</p>
</td></tr>
<tr><td><code id="omxBrownie_+3A_walnuts">walnuts</code></td>
<td>
<p>Logical. Indicates whether walnuts are to be included in the brownies. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="omxBrownie_+3A_wfpb">wfpb</code></td>
<td>
<p>Logical. Indicates whether to display the whole food plant based version.  Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a brownie recipe. Alter the 'quantity' variable to make more
pans of brownies. Ingredients, equipment and procedure are listed,
but neither ingredients nor equipment are provided.
</p>
<p>Raw cocoa powder can be used instead of Dutch processed cocoa
for approximately double the antioxidants and flavonols. However,
raw cocoa powder is not as smooth and delicious in taste.
</p>
<p>For the whole food plant based (wfpb) version of the recipe,
we substitute coconut butter for dairy butter because dairy butter
contains a large proportion of saturated fat that raises deadly LDL
cholesterol (Trumbo &amp; Shimakawa, 2011). In contrast, coconut butter
has so much fiber that the considerable saturated fat that it
contains is mostly not absorbed (Padmakumaran, Rajamohan &amp; Kurup,
1999).
You can substitute erythritol (den Hartog et al, 2010) for sucanat
(Lustig, Schmidt, &amp; Brindis, 2012) to improve the glycemic index and
reduce calorie density. We substitute whole wheat flour for all-purpose
wheat flour because whole grains are associated with improvement in
blood pressure (Tighe et al, 2010).  </p>


<h3>Value</h3>

<p>Returns a brownie recipe. 
</p>


<h3>References</h3>

<p>Padmakumaran Nair K.G, Rajamohan T, Kurup P.A. (1999). Coconut kernel protein
modifies the effect of coconut oil on serum lipids. Plant Foods Hum
Nutr. 53(2):133-44.
</p>
<p>Tighe P, Duthie G, Vaughan N, Brittenden J, Simpson W.G, Duthie S, Mutch
W, Wahle K, Horgan G, Thies F. (2010). Effect of increased consumption of
whole-grain foods on blood pressure and other cardiovascular risk
markers in healthy middle-aged persons: a randomized controlled
trial. Am. J. Clin. Nutr. 92(4), 733-40.
</p>
<p>R H Lustig, L A Schmidt, C D Brindis. (2012). Public health: The toxic truth
about sugar. Nature. 482 27-29.
</p>
<p>den Hartog G.J, Boots A.W, Adam-Perrot A, Brouns F, Verkooijen I.W, Weseler
A.R, Haenen G.R, Bast A. (2010). Erythritol is a sweet 
antioxidant. Nutrition. 26(4), 449-58.
</p>
<p>Trumbo P.R, Shimakawa T. (2011). Tolerable upper intake levels for trans
fat, saturated fat, and cholesterol. Nutr. Rev. 69(5), 270-8. doi:
10.1111/j.1753-4887.2011.00389.x.
</p>
<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p>More information about the OpenMx package may be found <a href="#topic+OpenMx">here</a>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return a brownie recipe
omxBrownie()
</code></pre>

<hr>
<h2 id='omxBuildAutoStartModel'>Build the model used for mxAutoStart</h2><span id='topic+omxBuildAutoStartModel'></span>

<h3>Description</h3>

<p>Build the model used for mxAutoStart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxBuildAutoStartModel(model, type = c("ULS", "DWLS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxBuildAutoStartModel_+3A_model">model</code></td>
<td>
<p>The MxModel for which starting values are desired</p>
</td></tr>
<tr><td><code id="omxBuildAutoStartModel_+3A_type">type</code></td>
<td>
<p>The type of starting values to obtain, currently unweighted or diagonally weighted least squares, ULS or DWLS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an MxModel that can be run to obtain starting values
</p>


<h3>See Also</h3>

<p><a href="#topic+mxAutoStart">mxAutoStart</a>
</p>

<hr>
<h2 id='omxCheckCloseEnough'>Approximate Equality Testing Function</h2><span id='topic+omxCheckCloseEnough'></span>

<h3>Description</h3>

<p>This function tests whether two numeric vectors or matrixes are
approximately equal to one another, within a specified threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckCloseEnough(a, b, epsilon = 10^(-15))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckCloseEnough_+3A_a">a</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="omxCheckCloseEnough_+3A_b">b</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
<tr><td><code id="omxCheckCloseEnough_+3A_epsilon">epsilon</code></td>
<td>
<p>a non-negative tolerance threshold</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments &lsquo;a&rsquo; and &lsquo;b&rsquo; must be of the same type,
ie. they must be either vectors of equal dimension or matrices of
equal dimension. The two arguments are compared element-wise for
approximate equality.  If the absolute value of the difference of
any two values is greater than the threshold, then an error will
be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at &lt;https://openmx.ssri.psu.edu/documentation&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>,
<code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>,
<code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omxCheckCloseEnough(c(1, 2, 3), c(1.1, 1.9 ,3.0), epsilon = 0.5)
omxCheckCloseEnough(matrix(3, 3, 3), matrix(4, 3, 3), epsilon = 2)
# Throws an error
try(omxCheckCloseEnough(c(1, 2, 3), c(1.1, 1.9 ,3.0), epsilon = 0.01))
</code></pre>

<hr>
<h2 id='omxCheckEquals'>Equality Testing Function</h2><span id='topic+omxCheckEquals'></span>

<h3>Description</h3>

<p>This function tests whether two objects are equal using the &lsquo;==&rsquo; operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckEquals(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckEquals_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <a href="testthat.html#topic+equality-expectations">expect_equivalent</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the &lsquo;==&rsquo; comparison on the two arguments. If the two arguments are not equal, then an error will be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckCloseEnough">omxCheckCloseEnough</a></code>, <code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>, <code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omxCheckEquals(c(1, 2, 3), c(1, 2, 3))

omxCheckEquals(FALSE, FALSE)

# Throws an error
try(omxCheckEquals(c(1, 2, 3), c(2, 1, 3)))

</code></pre>

<hr>
<h2 id='omxCheckError'>Correct Error Message Function</h2><span id='topic+omxCheckError'></span>

<h3>Description</h3>

<p>This function tests whether the correct error message is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckError(expression, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckError_+3A_expression">expression</code></td>
<td>
<p>an R expression that produces an error</p>
</td></tr>
<tr><td><code id="omxCheckError_+3A_message">message</code></td>
<td>
<p>a character string with the desired error message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments &lsquo;expression&rsquo; and &lsquo;message&rsquo; give the expression
that generates the error and the message that is supposed to be generated, respectively.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at &lt;https://openmx.ssri.psu.edu/documentation&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckWarning">omxCheckWarning</a></code>
<code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>,
<code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>,
<code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>

<hr>
<h2 id='omxCheckIdentical'>Exact Equality Testing Function</h2><span id='topic+omxCheckIdentical'></span>

<h3>Description</h3>

<p>This function tests whether two objects are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckIdentical(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckIdentical_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <a href="testthat.html#topic+equality-expectations">expect_identical</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the &lsquo;identical&rsquo; comparison on the two arguments. If the two arguments are not equal, then an error will be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckCloseEnough">omxCheckCloseEnough</a></code>, <code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>, <code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omxCheckIdentical(c(1, 2, 3), c(1, 2, 3))

omxCheckIdentical(FALSE, FALSE)

# Throws an error
try(omxCheckIdentical(c(1, 2, 3), c(2, 1, 3)))

</code></pre>

<hr>
<h2 id='omxCheckNamespace'>omxCheckNamespace</h2><span id='topic+omxCheckNamespace'></span>

<h3>Description</h3>

<p>This is an internal function exported for those people who know
what they are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckNamespace(model, namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckNamespace_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="omxCheckNamespace_+3A_namespace">namespace</code></td>
<td>
<p>namespace</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks that the named entities in the model are valid.
</p>

<hr>
<h2 id='omxCheckSetEquals'>Set Equality Testing Function</h2><span id='topic+omxCheckSetEquals'></span>

<h3>Description</h3>

<p>This function tests whether two vectors contain the same elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckSetEquals(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckSetEquals_+3A_...">...</code></td>
<td>
<p>arguments forwarded to <a href="testthat.html#topic+equality-expectations">expect_setequal</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the &lsquo;setequal&rsquo; function on the two arguments. If the two arguments do not contain the same elements, then an error will be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckCloseEnough">omxCheckCloseEnough</a></code>, <code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>, <code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omxCheckSetEquals(c(1, 1, 2, 2, 3), c(3, 2, 1))

omxCheckSetEquals(matrix(1, 1, 1), matrix(1, 3, 3))

# Throws an error
try(omxCheckSetEquals(c(1, 2, 3, 4), c(2, 1, 3)))

</code></pre>

<hr>
<h2 id='omxCheckTrue'>Boolean Equality Testing Function</h2><span id='topic+omxCheckTrue'></span>

<h3>Description</h3>

<p>This function tests whether an object is equal to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckTrue(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckTrue_+3A_a">a</code></td>
<td>
<p>the value to test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks element-wise whether an object is equal to TRUE. If any of the elements are false, then an error will be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckCloseEnough">omxCheckCloseEnough</a></code>, <code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>, <code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omxCheckTrue(1 + 1 == 2)

omxCheckTrue(matrix(TRUE, 3, 3))

# Throws an error
try(omxCheckTrue(FALSE))

</code></pre>

<hr>
<h2 id='omxCheckWarning'>Correct Warning Message Function</h2><span id='topic+omxCheckWarning'></span>

<h3>Description</h3>

<p>This function tests whether the correct warning message is thrown.
Arguments &lsquo;expression&rsquo; and &lsquo;message&rsquo; give the expression
that generates the warning and the message that is supposed to be generated, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckWarning(expression, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckWarning_+3A_expression">expression</code></td>
<td>
<p>an R expression that produces a warning</p>
</td></tr>
<tr><td><code id="omxCheckWarning_+3A_message">message</code></td>
<td>
<p>a character string with the desired warning message</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>note</em>: to test for no warning, set <code>message = NA</code>.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at &lt;https://openmx.ssri.psu.edu/documentation&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckError">omxCheckError</a></code>
<code><a href="#topic+omxCheckWithinPercentError">omxCheckWithinPercentError</a></code>,
<code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>,
<code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- omxCheckWarning(mxFIMLObjective('cov', 'mean'), "deprecated")

# Test for no warning
omxCheckWarning(2+2, message = NA)

</code></pre>

<hr>
<h2 id='omxCheckWithinPercentError'>Approximate Percent Equality Testing Function</h2><span id='topic+omxCheckWithinPercentError'></span>

<h3>Description</h3>

<p>This function tests whether two numeric vectors or matrixes are approximately equal to one another, within a specified percentage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxCheckWithinPercentError(a, b, percent = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxCheckWithinPercentError_+3A_a">a</code></td>
<td>
<p>a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="omxCheckWithinPercentError_+3A_b">b</code></td>
<td>
<p>a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="omxCheckWithinPercentError_+3A_percent">percent</code></td>
<td>
<p>a non-negative percentage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments &lsquo;a&rsquo; and &lsquo;b&rsquo; must be of the same type, ie. they must be either vectors of equal dimension or matrices of equal dimension. The two arguments are compared element-wise for approximate equality.  If the absolute value of the difference of any two values is greater than the percentage difference of &lsquo;a&rsquo;, then an error will be thrown.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxCheckCloseEnough">omxCheckCloseEnough</a></code>, <code><a href="#topic+omxCheckIdentical">omxCheckIdentical</a></code>, <code><a href="#topic+omxCheckSetEquals">omxCheckSetEquals</a></code>, <code><a href="#topic+omxCheckTrue">omxCheckTrue</a></code>, <code><a href="#topic+omxCheckEquals">omxCheckEquals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
omxCheckWithinPercentError(c(1, 2, 3), c(1.1, 1.9 ,3.0), percent = 50)

omxCheckWithinPercentError(matrix(3, 3, 3), matrix(4, 3, 3), percent = 150)

# Throws an error
try(omxCheckWithinPercentError(c(1, 2, 3), c(1.1, 1.9 ,3.0), percent = 0.01))

</code></pre>

<hr>
<h2 id='omxConstrainMLThresholds'>omxConstrainMLThresholds</h2><span id='topic+omxConstrainMLThresholds'></span>

<h3>Description</h3>

<p>Add constraint to ML model to keep thresholds in order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxConstrainMLThresholds(model, dist = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxConstrainMLThresholds_+3A_model">model</code></td>
<td>
<p>the MxModel to which constraints should be added</p>
</td></tr>
<tr><td><code id="omxConstrainMLThresholds_+3A_dist">dist</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds a nonlinear constraint to an ML model.  The constraint
keeps the thresholds in order.  Constraints often slow model estimation,
however, keeping the thresholds in increasing order helps ensure the likelihood
function is well-defined.  If you're having problems with ordinal data, this is
one of the things to try.
</p>


<h3>Value</h3>

<p>a new MxModel object with the constraints added
</p>


<h3>See Also</h3>

<p><code>demo("omxConstrainMLThresholds")</code>
</p>

<hr>
<h2 id='omxDefaultComputePlan'>
Construct default compute plan
</h2><span id='topic+omxDefaultComputePlan'></span>

<h3>Description</h3>

<p>This function generates a default compute plan, where &quot;default compute plan&quot; refers to an object of class <a href="#topic+mxComputeSequence">MxComputeSequence</a> which is appropriate for use in a wide variety of cases.  The exact specification of the plan will depend upon the arguments provided to <code>omxDefaultComputePlan()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxDefaultComputePlan(modelName=NULL, intervals=FALSE,
  useOptimizer=TRUE, optionList=options()$mxOption, penaltySearch=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxDefaultComputePlan_+3A_modelname">modelName</code></td>
<td>
<p>Optional (defaults to <code>NULL</code>) character string, providing the name of the <a href="#topic+MxModel">MxModel</a> the fitfunction of which is to be evaluated, and usually, optimized.</p>
</td></tr>
<tr><td><code id="omxDefaultComputePlan_+3A_intervals">intervals</code></td>
<td>
<p>Logical; will <a href="#topic+mxCI">confidence intervals</a> be computed? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="omxDefaultComputePlan_+3A_useoptimizer">useOptimizer</code></td>
<td>
<p>Logical; will a fitfunction be minimized?  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="omxDefaultComputePlan_+3A_optionlist">optionList</code></td>
<td>
<p>List of <a href="#topic+mxOption">mxOption</a>s.  Defaults to the current
list of global <a href="#topic+mxOption">mxOption</a>s.</p>
</td></tr>
<tr><td><code id="omxDefaultComputePlan_+3A_penaltysearch">penaltySearch</code></td>
<td>
<p>Logical; whether to wrap the optimizer step with <a href="#topic+mxComputePenaltySearch">mxComputePenaltySearch</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At minimum, argument <code>optionList</code> must include &ldquo;Gradient algorithm&rdquo;, &ldquo;Gradient iterations&rdquo;, &ldquo;Gradient step size&rdquo;, &ldquo;Calculate Hessian&rdquo;, and &ldquo;Standard Errors&rdquo;.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+mxComputeSequence">MxComputeSequence</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- omxDefaultComputePlan(modelName="bar")
str(foo)
</code></pre>

<hr>
<h2 id='omxDetectCores'>omxDetectCores</h2><span id='topic+omxDetectCores'></span>

<h3>Description</h3>

<p>Detects the number of cores on the local machine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxDetectCores(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxDetectCores_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>omxDetectCores()
</code></pre>

<hr>
<h2 id='omxGetBootstrapReplications'>omxGetBootstrapReplications</h2><span id='topic+omxGetBootstrapReplications'></span><span id='topic+omxBootstrapCov'></span>

<h3>Description</h3>

<p>Checks a variety of conditions to ensure that bootstrap replications are
available and valid. Throws exception if things go wrong. Otherwise,
replications are returned to the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxGetBootstrapReplications(model)
omxBootstrapCov(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxGetBootstrapReplications_+3A_model">model</code></td>
<td>
<p>an MxModel object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or covariance matrix of bootstrap parameter estimates
</p>

<hr>
<h2 id='omxGetNPSOL'>omxGetNPSOL</h2><span id='topic+omxGetNPSOL'></span>

<h3>Description</h3>

<p>Get the non-CRAN version of OpenMx from the OpenMx website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxGetNPSOL()
</code></pre>


<h3>Details</h3>

<p>This function
</p>


<h3>Value</h3>

<p>Invisible NULL
</p>

<hr>
<h2 id='omxGetParameters'>Fetch Model Parameters</h2><span id='topic+omxGetParameters'></span>

<h3>Description</h3>

<p>Return a vector of the chosen parameters from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxGetParameters(model, indep = FALSE, free = c(TRUE, FALSE, NA),
    fetch = c('values', 'free', 'lbound', 'ubound', 'all'),
    labels = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxGetParameters_+3A_model">model</code></td>
<td>
<p>a MxModel object</p>
</td></tr>
<tr><td><code id="omxGetParameters_+3A_indep">indep</code></td>
<td>
<p>fetch parameters from independent submodels.</p>
</td></tr>
<tr><td><code id="omxGetParameters_+3A_free">free</code></td>
<td>
<p>fetch either free parameters (TRUE), or fixed parameters or both types. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="omxGetParameters_+3A_fetch">fetch</code></td>
<td>
<p>which attribute of the parameters to fetch. Default choice is &lsquo;values&rsquo;.</p>
</td></tr>
<tr><td><code id="omxGetParameters_+3A_labels">labels</code></td>
<td>
<p>additional labels to fetch</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument &lsquo;free&rsquo; dictates whether to return only free
parameters or only fixed parameters or both free and fixed
parameters. The function can return unlabeled free parameters
(parameters with a label of NA). These anonymous free parameters will
be identified as &lsquo;modelname.matrixname[row,col]&rsquo;.  It will not
return fixed parameters that have a label of NA.
</p>
<p>If provided, the argument &lsquo;labels&rsquo; takes precedent over the
selection criteria specified by &lsquo;free&rsquo;. Any labels mentioned in
&lsquo;labels&rsquo;, including those of the form
&lsquo;modelname.matrixname[row,col]&rsquo;, will be returned.
</p>
<p>No distinction is made between ordinary labels, definition variables, and square bracket constraints. The function will return either a vector of parameter values, or free/fixed designations, or lower bounds, or upper bounds, depending on the &lsquo;fetch&rsquo; argument. Using fetch with &lsquo;all&rsquo; returns a data frame that is populated with all of the attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxSetParameters">omxSetParameters</a></code>, <code><a href="#topic+omxLocateParameters">omxLocateParameters</a></code>, <code><a href="#topic+omxAssignFirstParameters">omxAssignFirstParameters</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

A &lt;- mxMatrix('Full', 2, 2, labels = c("A11", "A12", "A21", NA), values= 1:4, 
    free = c(TRUE,TRUE,FALSE,TRUE), byrow=TRUE, name = 'A')
model &lt;- mxModel(A, name = 'model')

# Request all free parameters in model
omxGetParameters(model)

# A11  A12 model.A[2,2] 
#   1    2    4 

# Request fixed parameters from model
omxGetParameters(model, free = FALSE)
# A21 
#   3

A$labels
#      [,1]  [,2] 
# [1,] "A11" "A12"
# [2,] "A21" NA   

A$free
#       [,1] [,2]
# [1,]  TRUE TRUE
# [2,] FALSE TRUE

A$values
#      [,1] [,2]
# [1,]    1    2
# [2,]    3    4

# Example using un-labelled parameters

# Read in some demo data
data(demoOneFactor)
# Grab the names for manifestVars 
manifestVars &lt;- names(demoOneFactor)
nVar = length(manifestVars) # 5 variables
factorModel &lt;- mxModel("One Factor",
    mxMatrix(name="A", type="Full", nrow=nVar, ncol=1, values=0.2, free=TRUE, 
        lbound = 0.0, labels=letters[1:nVar]),
    mxMatrix(name="L", type="Symm", nrow=1, ncol=1, values=1, free=FALSE),
    # the "U" matrix has nVar (5) anonymous free parameters
    mxMatrix(name="U", type="Diag", nrow=nVar, ncol=nVar, values=1, free=TRUE),
    mxAlgebra(expression=A %&amp;% L + U, name="R"),
    mxExpectationNormal(covariance="R", dimnames=manifestVars),
    mxFitFunctionML(),
    mxData(observed=cov(demoOneFactor), type="cov", numObs=500)
)

# Get all free parameters
params         &lt;- omxGetParameters(factorModel)
lbound         &lt;- omxGetParameters(factorModel, fetch="lbound")
# Set new values for these params, saving them in a new model
newFactorModel &lt;- omxSetParameters(factorModel, names(params), values = 1:10)
# Read out the values from the new model
newParams      &lt;- omxGetParameters(newFactorModel)

</code></pre>

<hr>
<h2 id='omxGetRAMDepth'>omxGetRAMDepth</h2><span id='topic+omxGetRAMDepth'></span>

<h3>Description</h3>

<p>Get the potency of a matrix for inversion speed-up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxGetRAMDepth(A, maxdepth = nrow(A) - 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxGetRAMDepth_+3A_a">A</code></td>
<td>
<p>MxMatrix object</p>
</td></tr>
<tr><td><code id="omxGetRAMDepth_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Numeric. maximum depth to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by the <a href="#topic+mxExpectationRAM">mxExpectationRAM</a> function
to determine how far to expand <code class="reqn">(I-A)^{-1} = I + A + A^2 + A^3 + ...</code>.  It is
similarly used by <a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a> in expanding <code class="reqn">(I-B)^{-1} = I + B + B^2 + B^3 + ...</code>.
In many situations <code class="reqn">A^2</code> is a zero matrix (nilpotent of order 2).  So when <code class="reqn">A</code> has large
dimension it is much faster to compute <code class="reqn">I+A</code> than <code class="reqn">(I-A)^{-1}</code>.
</p>

<hr>
<h2 id='omxGraphviz'>Show RAM Model in Graphviz Format</h2><span id='topic+omxGraphviz'></span>

<h3>Description</h3>

<p>The function accepts a RAM style model and outputs a visual representation
of the model in Graphviz format. The function will output either to a file or 
to the console. The recommended file extension for an output file is &quot;.dot&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxGraphviz(model, dotFilename = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxGraphviz_+3A_model">model</code></td>
<td>
<p>An RAM-type model.</p>
</td></tr>
<tr><td><code id="omxGraphviz_+3A_dotfilename">dotFilename</code></td>
<td>
<p>The name of the output file.  Use &quot;&quot; to write to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a string containing the model description in Graphviz format.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>

<hr>
<h2 id='omxHasDefaultComputePlan'>omxHasDefaultComputePlan</h2><span id='topic+omxHasDefaultComputePlan'></span>

<h3>Description</h3>

<p>Determine whether the model has a default complete plan (i.e., not custom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxHasDefaultComputePlan(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxHasDefaultComputePlan_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
</table>

<hr>
<h2 id='omxLapply'>On-Demand Parallel Lapply</h2><span id='topic+omxLapply'></span>

<h3>Description</h3>

<p>If the snowfall library is loaded, then this function calls <code><a href="snowfall.html#topic+sfLapply">sfLapply</a></code>.  Otherwise it invokes <code><a href="base.html#topic+lapply">lapply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxLapply(x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxLapply_+3A_x">x</code></td>
<td>
<p>a vector (atomic or list) or an expressions vector. Other objects (including classed objects) will be coerced by <code><a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="omxLapply_+3A_fun">fun</code></td>
<td>
<p>the function to be applied to each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="omxLapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>fun</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+omxApply">omxApply</a></code>, <code><a href="#topic+omxSapply">omxSapply</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
# compute the list mean for each list element
omxLapply(x,mean)

</code></pre>

<hr>
<h2 id='omxLocateParameters'>Get the location (model, matrix, row, column) and other info for a parameter</h2><span id='topic+omxLocateParameters'></span>

<h3>Description</h3>

<p>Returns a data.frame summarizing the <em>free</em> parameters in a model,
possibly filtered using &lsquo;labels&rsquo;.
</p>
<p>For each located parameter, the label, model, matrix, row, col, value,
and lbound &amp; ubound are given as a row in the dataframe.
</p>
<p>Duplicated labels return a row for each location in which they are found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxLocateParameters(model, labels = NULL, indep = FALSE, free = c(TRUE, FALSE, NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxLocateParameters_+3A_model">model</code></td>
<td>
<p>a MxModel object</p>
</td></tr>
<tr><td><code id="omxLocateParameters_+3A_labels">labels</code></td>
<td>
<p>optionally specify which free parameters to retrieve.</p>
</td></tr>
<tr><td><code id="omxLocateParameters_+3A_indep">indep</code></td>
<td>
<p>fetch parameters from independent submodels.</p>
</td></tr>
<tr><td><code id="omxLocateParameters_+3A_free">free</code></td>
<td>
<p>fetch either free parameters (TRUE), or fixed parameters or both types. Default value is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Invoking the function with the default value for the &lsquo;labels&rsquo;
argument retrieves all the free parameters.  The &lsquo;labels&rsquo;
argument can be used to select a subset of the free parameters.
Note that &lsquo;NA&rsquo; is a valid input to &lsquo;labels&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+omxGetParameters">omxGetParameters</a></code>, <code><a href="#topic+omxSetParameters">omxSetParameters</a></code>, <code><a href="#topic+omxAssignFirstParameters">omxAssignFirstParameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- mxMatrix('Full', 2, 2, labels = c("A11", "A12", NA, "A11"), values= 1:4,
   free = TRUE, byrow = TRUE, name = 'A')

model &lt;- mxModel(A, name = 'model')

# Request all free parameters in model
omxLocateParameters(model)

# Request free parameters "A11" and all NAs
omxLocateParameters(model, c("A11", NA))

# Works with submodel
B = mxMatrix(name = 'B', 'Full', 1, 2, labels = c("B11", "notme"),
  free = c(TRUE, FALSE), values= pi)
model &lt;- mxModel(model, mxModel(B, name = 'subB'))

# nb: only returns free parameters ('notme' not shown)
omxLocateParameters(model)

</code></pre>

<hr>
<h2 id='omxLogical'>Logical mxAlgebra() operators</h2><span id='topic+omxLogical'></span><span id='topic+omxNot'></span><span id='topic+omxAnd'></span><span id='topic+omxOr'></span><span id='topic+omxGreaterThan'></span><span id='topic+omxLessThan'></span><span id='topic+omxApproxEquals'></span>

<h3>Description</h3>

<p><code>omxNot</code> computes the unary negation of the values of a matrix.
<code>omxAnd</code> computes the binary and of two matrices.
<code>omxOr</code> computes the binary or of two matrices.
<code>omxGreaterThan</code> computes a binary greater than of two matrices.
<code>omxLessThan</code> computes the binary less than of two matrices.
<code>omxApproxEquals</code> computes a binary equals within a specified epsilon of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxNot(x)
omxAnd(x, y)
omxOr(x, y)
omxGreaterThan(x, y)
omxLessThan(x, y)
omxApproxEquals(x, y, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxLogical_+3A_x">x</code></td>
<td>
<p>the first argument, the matrix which the logical operation will be applied to.</p>
</td></tr>
<tr><td><code id="omxLogical_+3A_y">y</code></td>
<td>
<p>the second argument, applicable to binary functions.</p>
</td></tr>
<tr><td><code id="omxLogical_+3A_epsilon">epsilon</code></td>
<td>
<p>the third argument, specifies the error threshold for omxApproxEquals. Abs(x[i][j]-y[i][j]) must be less than epsilon[i][j].</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- mxMatrix(values = runif(25), nrow = 5, ncol = 5, name = 'A')
B &lt;- mxMatrix(values = runif(25), nrow = 5, ncol = 5, name = 'B')
EPSILON &lt;- mxMatrix(values = 0.04*1:25, nrow = 5, ncol = 5, name = "EPSILON")

model &lt;- mxModel(A, B, EPSILON, name = 'model')

mxEval(omxNot(A), model)
mxEval(omxGreaterThan(A,B), model)
mxEval(omxLessThan(B,A), model)
mxEval(omxOr(omxNot(A),B), model)
mxEval(omxAnd(omxNot(B), A), model)
mxEval(omxApproxEquals(A,B, EPSILON), model)
</code></pre>

<hr>
<h2 id='omxManifestModelByParameterJacobian'>Estimate the Jacobian of manifest model with respect to parameters</h2><span id='topic+omxManifestModelByParameterJacobian'></span>

<h3>Description</h3>

<p>The manifest model excludes any latent variables or processes. For
RAM and LISREL models, the manifest model contains only the
manifest variables with free means, covariance, and thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxManifestModelByParameterJacobian(model, defvar.row = 1, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxManifestModelByParameterJacobian_+3A_model">model</code></td>
<td>
<p>an mxModel</p>
</td></tr>
<tr><td><code id="omxManifestModelByParameterJacobian_+3A_defvar.row">defvar.row</code></td>
<td>
<p>which row to use for definition variables</p>
</td></tr>
<tr><td><code id="omxManifestModelByParameterJacobian_+3A_standardize">standardize</code></td>
<td>
<p>logical, whether or not to standardize the parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jacobian is estimated by the central finite difference.
</p>
<p>If the <code>standardize</code> argument is TRUE, then the Jacobian is for the standardized model.
For Normal expectations the standardized manifest model has the covariances returned as correlations, the variances returned as ones, the means returned as zeros, and the thresholds are returned as z-scores.
For the thresholds the z-scores are computed by using the model-implied means and variances.
</p>


<h3>Value</h3>

<p>a matrix with manifests in the rows and original parameters in the columns
</p>


<h3>See Also</h3>

<p><a href="#topic+mxGetExpected">mxGetExpected</a>
</p>

<hr>
<h2 id='omxMatrixOperations'>MxMatrix operations</h2><span id='topic+omxMatrixOperations'></span><span id='topic+omxCbind'></span><span id='topic+omxRbind'></span><span id='topic+omxTranspose'></span>

<h3>Description</h3>

<p><code>omxCbind</code> columnwise binding of two or more MxMatrices.
<code>omxRbind</code> rowwise binding of two or more MxMatrices.
<code>omxTranspose</code> transpose of MxMatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
omxCbind(..., allowUnlabeled = 
    getOption("mxOptions")[["Allow Unlabeled"]], 
    dimnames = NA, name = NA)
omxRbind(..., allowUnlabeled = 
    getOption("mxOptions")[["Allow Unlabeled"]], 
    dimnames = NA, name = NA)
omxTranspose(matrix, allowUnlabeled = 
    getOption("mxOptions")[["Allow Unlabeled"]], 
    dimnames = NA, name = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxMatrixOperations_+3A_...">...</code></td>
<td>
<p>two or more MxMatrix objects</p>
</td></tr>
<tr><td><code id="omxMatrixOperations_+3A_matrix">matrix</code></td>
<td>
<p>MxMatrix input</p>
</td></tr>
<tr><td><code id="omxMatrixOperations_+3A_allowunlabeled">allowUnlabeled</code></td>
<td>
<p>whether or not to accept free parameters with NA labels</p>
</td></tr>
<tr><td><code id="omxMatrixOperations_+3A_dimnames">dimnames</code></td>
<td>
<p>list. The dimnames attribute for the matrix: a list of length 2 giving the row and column names respectively. An empty list is treated as NULL, and a list of length one as row names. The list can be named, and the list names will be used as names for the dimensions.</p>
</td></tr>
<tr><td><code id="omxMatrixOperations_+3A_name">name</code></td>
<td>
<p>an optional character string indicating the name of the MxMatrix object</p>
</td></tr>
</table>

<hr>
<h2 id='omxMnor'>Multivariate Normal Integration</h2><span id='topic+omxMnor'></span>

<h3>Description</h3>

<p>Given a covariance matrix, a means vector, and vectors of lower and upper bounds, returns the multivariate normal integral across the space between bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxMnor(covariance, means, lbound, ubound)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxMnor_+3A_covariance">covariance</code></td>
<td>
<p>the covariance matrix describing the multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="omxMnor_+3A_means">means</code></td>
<td>
<p>a row vector containing means of the variables of the underlying distribution.</p>
</td></tr>
<tr><td><code id="omxMnor_+3A_lbound">lbound</code></td>
<td>
<p>a row vector containing the lower bounds of the integration in each variable.</p>
</td></tr>
<tr><td><code id="omxMnor_+3A_ubound">ubound</code></td>
<td>
<p>a row vector containing the upper bounds of the integration in each variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of columns in the &lsquo;means&rsquo;, &lsquo;lbound&rsquo;, and &lsquo;ubound&rsquo; vectors are assumed to be the same as that of the covariance matrix.  That is, means[i] is considered to be the mean of the variable whose variance is in covariance[i,i].  That variable will be integrated from lbound[i] to ubound[i] as part of the integration.
</p>
<p>The value of ubound[i] or lbound[i] may be set to Inf or -Inf if a boundary at positive or negative infinity is desired.
</p>
<p>For all i, ubound[i] must be strictly greater than lbound[i].
</p>
<p>The algorithm for multivariate normal integration we use is Alan Genz's FORTRAN implementation of the SADMVN routine described by Genz (1992).
</p>


<h3>References</h3>

<p>Genz, A.  (1992).  Numerical Computation of Multivariate Normal Probabilities.  <em>Journal of Computational Graphical Statistics, 1,</em>  141-149.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(myFADataRaw)

covariance &lt;- cov(myFADataRaw[,1:3])
means &lt;- colMeans(myFADataRaw[,1:3])
lbound &lt;- c(-Inf, 0,   1)    # Integrate from -Infinity to 0 on first variable 
ubound &lt;- c(0,    Inf, 2.5)  # From 0 to +Infinity on second, and from 1 to 2.5 on third
omxMnor(covariance, means, lbound, ubound)
# 0.0005995

# An alternative specification of the bounds follows
# Integrate from -Infinity to 0 on first variable 
v1bound = c(-Inf, 0)
# From 0 to +Infinity on second
v2bound = c(0, Inf)
# and from 1 to 2.5 on third
v3bound = c(1, 2.5)
bounds &lt;- cbind(v1bound, v2bound, v3bound)
lbound &lt;- bounds[1,]  
ubound &lt;- bounds[2,]  
omxMnor(covariance, means, lbound, ubound)

</code></pre>

<hr>
<h2 id='omxModelDeleteData'>Remove all instances of data from a model</h2><span id='topic+omxModelDeleteData'></span>

<h3>Description</h3>

<p>For very large data, it can be desirable to discard data after the model
is run. That is what the purpose of this function.
</p>
<p>Data is discarded from the model and all submodels recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxModelDeleteData(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxModelDeleteData_+3A_model">model</code></td>
<td>
<p>a MxModel object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)

data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents   &lt;- c("G")
factorModel &lt;- mxModel(model="One Factor", type="RAM",
      manifestVars = manifests,
      latentVars   = latents,
      mxPath(from=latents, to=manifests),
      mxPath(from=manifests, arrows=2),
      mxPath(from=latents, arrows=2,free=FALSE, values=1.0),
      mxData(cov(demoOneFactor), type="cov",numObs=500)
)
factorFit &lt;-mxRun(factorModel)
object.size(factorFit)
factorFit &lt;- omxModelDeleteData(factorFit)
object.size(factorFit)
factorFit$data

</code></pre>

<hr>
<h2 id='omxNameAnonymousParameters'>omxNameAnonymousParameters</h2><span id='topic+omxNameAnonymousParameters'></span>

<h3>Description</h3>

<p>Assign new names to the unnamed parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxNameAnonymousParameters(model, indep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxNameAnonymousParameters_+3A_model">model</code></td>
<td>
<p>the MxModel</p>
</td></tr>
<tr><td><code id="omxNameAnonymousParameters_+3A_indep">indep</code></td>
<td>
<p>whether models are independent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for the new MxModel with named parameters, and the new names.
</p>

<hr>
<h2 id='omxParallelCI'>
Calculate confidence intervals without re-doing the primary optimization.
</h2><span id='topic+omxParallelCI'></span><span id='topic+omxRunCI'></span>

<h3>Description</h3>

<p>OpenMx provides two functions to calculate confidence intervals for already-<a href="#topic+mxRun">run</a> <a href="#topic+MxModel">MxModel</a> objects that contain an <a href="#topic+MxInterval">MxInterval</a> object (i.e., an <code><a href="#topic+mxCI">mxCI</a>()</code> statement), without recalculating point estimates, fitfunction derivatives, or expectations.
</p>
<p>The primary function is <code>omxRunCI()</code>. This is a wrapper for <code>omxParallelCI()</code> with arguments <code>run=TRUE</code> and <code>independentSubmodels=FALSE</code>, and is the recommended interface.
</p>
<p><code>omxParallelCI()</code> does the work of calculating confidence intervals. The &quot;parallel&quot; in the function's name refers to the not-yet-implemented feature of running independent <a href="#topic+mxModel">submodels</a> in parallel.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxRunCI(model, verbose = 0, optimizer = "SLSQP")

omxParallelCI(model, run = TRUE, verbose = 0, independentSubmodels = TRUE,
optimizer = mxOption(NULL, "Default optimizer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxParallelCI_+3A_model">model</code></td>
<td>
<p>An <a href="#topic+MxModel">MxModel</a> object that contains an <a href="#topic+MxInterval">MxInterval</a> object (i.e., an <code><a href="#topic+mxCI">mxCI</a>()</code> statement).</p>
</td></tr>
<tr><td><code id="omxParallelCI_+3A_run">run</code></td>
<td>
<p>Logical; For <code>omxParallelCI()</code>, determines if the model with its new compute plan is <code><a href="#topic+mxRun">mxRun</a>()</code> before being returned. Hard-coded <code>TRUE</code> for omxRunCI.</p>
</td></tr>
<tr><td><code id="omxParallelCI_+3A_verbose">verbose</code></td>
<td>
<p>Integer; defaults to zero; verbosity level passed to MxCompute* objects.</p>
</td></tr>
<tr><td><code id="omxParallelCI_+3A_independentsubmodels">independentSubmodels</code></td>
<td>
<p>Logical; For <code>omxParallelCI()</code> defaults to <code>TRUE</code>. Hard coded FALSE for <code>omxRunCI()</code>. Also see &quot;Details.&quot;</p>
</td></tr>
<tr><td><code id="omxParallelCI_+3A_optimizer">optimizer</code></td>
<td>
<p>Character string selecting the gradient-descent optimizer to be used to find confidence limits; one of &quot;NPSOL&quot;, &quot;CSOLNP&quot;, or &quot;SLSQP&quot;.  The default for <code>omxParallelCI()</code> is the current value of <a href="#topic+mxOption">mxOption</a> &quot;Default optimizer&quot;, and for <code>omxRunCI()</code>, is &quot;SLSQP&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>independentSubmodels=TRUE</code>, <code>omxParallelCI()</code> creates an independent MxModel object for each quantity specified in the 'reference' slot of <code>model</code>'s <a href="#topic+MxInterval">MxInterval</a> object, and places these independent MxModels inside <code>model</code>.  Each of these independent submodels calculates the confidence limits of its own quantity when the container model is run.  When <code>independentSubmodels=FALSE</code>, no submodels are added to <code>model</code>.  Instead, <code>model</code> is provided with a dedicated <a href="#topic+mxComputeSequence">compute plan</a> consisting only of an <a href="#topic+mxComputeConfidenceInterval">MxComputeConfidenceInterval</a> step.  Note that using <code>independentSubmodels=FALSE</code> will overwrite any compute plan already inside <code>model</code>.
</p>


<h3>Value</h3>

<p>The functions return <code>model</code>, augmented with independent submodels (if <code>independentSubmodels=TRUE</code>) or with a non-default compute plan (if <code>independentSubmodels=FALSE</code>), and possibly having been passed through <code><a href="#topic+mxRun">mxRun</a>()</code> (if <code>run=TRUE</code>).  Naturally, if <code>run=FALSE</code>, the user can subsequently <a href="#topic+mxRun">run</a> the returned model to obtain confidence intervals.  Users are cautioned that the returned model may not be very amenable to being further modified and re-fitted (e.g., having some free parameters fixed via <code><a href="#topic+omxSetParameters">omxSetParameters</a>()</code> and passed through <code><a href="#topic+mxRun">mxRun</a>()</code> to get new point estimates) unless the added submodels or the non-default compute plan are eliminated.  The exception is if <code>run=TRUE</code> and <code>independentSubmodels=TRUE</code> (which is always the case with <code>omxRunCI()</code>), since the non-default compute plan is set to be non-persistent, and will automatically be replaced with a default compute plan the next time the model is passed to <code><a href="#topic+mxRun">mxRun</a>()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxCI">mxCI</a>()</code>, <a href="#topic+MxInterval">MxInterval</a>, <code><a href="#topic+mxComputeConfidenceInterval">mxComputeConfidenceInterval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(OpenMx)
# 1. Build and run a model, don't compute intervals yet
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("One Factor", type="RAM",
	manifestVars=manifests, 
	latentVars=latents,
	mxPath(from=latents, to=manifests),
 	mxPath(from=manifests, arrows=2),
	mxPath(from=latents, arrows=2, free=FALSE, values=1.0),
	mxData(observed=cov(demoOneFactor), type="cov", numObs=500),
	# Add confidence intervals for (free) params in A and S matrices.
	mxCI(c('A', 'S'))
)
factorRun &lt;- mxRun(factorModel)

# 2. Compute the CIs on factorRun, and view summary
factorCI1 &lt;- omxRunCI(factorRun)
summary(factorCI1)$CI

# 3. Use low-level omxParallelCI interface
factorCI2 &lt;- omxParallelCI(factorRun) 

# 4. Build, but don't run the newly-created model
factorCI3 &lt;- omxParallelCI(factorRun, run= FALSE)  
</code></pre>

<hr>
<h2 id='omxQuotes'>omxQuotes</h2><span id='topic+omxQuotes'></span>

<h3>Description</h3>

<p>Quote helper function, often for error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxQuotes(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxQuotes_+3A_name">name</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function for creating a nicely
put together formatted string.
</p>


<h3>Value</h3>

<p>a character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omxQuotes(c("Oh", "blah", "dee", "Oh", "blah", "da"))
omxQuotes(c("A", "S", "F"))
omxQuotes("Hello World")
</code></pre>

<hr>
<h2 id='omxRAMtoML'>omxRAMtoML</h2><span id='topic+omxRAMtoML'></span>

<h3>Description</h3>

<p>Convert a RAM model to an ML model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxRAMtoML(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxRAMtoML_+3A_model">model</code></td>
<td>
<p>the MxModel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a legacy function that was once used to convert RAM models to ML models
in the old (1.0 release of OpenMx) objective function style.
</p>


<h3>Value</h3>

<p>an ML model with an ML objective
</p>

<hr>
<h2 id='omxReadGRMBin'>
Read a GCTA-Format Binary GRM into R.
</h2><span id='topic+omxReadGRMBin'></span>

<h3>Description</h3>

<p>This simple function is adapted from syntax in the GCTA User Manual.  It loads a binary genomic-relatedness matrix (GRM) from disk into R's workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxReadGRMBin(prefix, AllN=FALSE, size=4, returnList=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxReadGRMBin_+3A_prefix">prefix</code></td>
<td>
<p>Character string: everything in the path, relative to <span class="rlang"><b>R</b></span>'s working directory, and filenames of the GRM files preceding '.grm.*'.  See below, under &quot;Details&quot;</p>
</td></tr>
<tr><td><code id="omxReadGRMBin_+3A_alln">AllN</code></td>
<td>
<p>Logical.  If <code>FALSE</code> (default), then when <code>omxReadGRMBin()</code> calls <code><a href="base.html#topic+readBin">readBin</a>()</code>, it passes a value of 1 for argument <code>n</code>.  if <code>TRUE</code>, then it instead passes a value equal to the number of nonredundant elements in the GRM.</p>
</td></tr>
<tr><td><code id="omxReadGRMBin_+3A_size">size</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+readBin">readBin</a>()</code>.</p>
</td></tr>
<tr><td><code id="omxReadGRMBin_+3A_returnlist">returnList</code></td>
<td>
<p>Logical.  If <code>FALSE</code> (default), <code>omxReadGRMBin</code> returns the GRM.  If <code>TRUE</code>, then <code>omxReadGRMBin</code> returns a list as described below, under &quot;Value&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GRM calculated in GCTA that is saved to disk in binary format comprises three files, the filenames of which have the same stem but different extensions.  The first, with extension &quot;grm.bin&quot;, is the actual binary file containing the GRM elements.  The second, with extension &quot;grm.N.bin&quot;, contains information about how many genetic markers were used to calculate the GRM.  The third, with extension &quot;grm.id&quot;, is a text file containing two columns of data, respectively, the participant family and individual IDs.  <code>omxReadGRMBin()</code> is meant to be used with all three files together in the same directory.  Thus, argument <code>prefix</code> should be everything in the path (relative to <span class="rlang"><b>R</b></span>'s working directory) and filenames of those GRM files, up to the first period in their extensions.  In practice, it is simplest to set <span class="rlang"><b>R</b></span>'s working directory to whichever directory contains the files, and simply provide the filename stem for argument <code>prefix</code>.
</p>
<p><code>omxReadGRMBin()</code> opens three file connections, one for each file.
</p>


<h3>Value</h3>

<p>If <code>returnList=FALSE</code> (the default), then the GRM itself is returned as a numeric matrix, with each row and column named as the sum of the corresponding participant's family ID and individual ID.  Otherwise, a list of the following four elements is returned:
</p>

<ol>
<li> <p><code>"diag"</code>: Numeric vector containing the GRM's diagonal elements.
</p>
</li>
<li> <p><code>"off"</code>: Numeric vector containing the GRM's off-diagonal elements.
</p>
</li>
<li> <p><code>"id"</code>: Dataframe containing the family and individual IDs corresponding to the rows and columns of the GRM.
</p>
</li>
<li> <p><code>"N"</code>: Numeric; number of markers used to calculate the GRM.
</p>
</li></ol>



<h3>References</h3>

<p>Yang J, Lee SH, Goddard ME, Visscher, PM. GCTA: A tool for genome-wide complex trait analysis. American Journal of Human Genetics 2011;88:76-82. doi: 10.1016/j.ajhg.2010.11.011.
</p>
<p>Yang J, Lee SH, Goddard ME, Visscher, PM. Genome-wide complex trait analysis (GCTA): Methods, data analyses, and interpretations. In Gondro, C et al. (Eds.), <em>Genome-Wide Association Studies and Genomic Prediction</em>. New York: Springer;2013. p. 215-236.
</p>
<p>GCTA website:  <a href="https://cnsgenomics.com/software/gcta/#Overview">https://cnsgenomics.com/software/gcta/#Overview</a>.
</p>
<p>Code for <code>omxReadGRMBin()</code> was adapted from syntax by Jiang Yang in the GCTA User Manual, version 1.24, dated 28 July 2014, retrieved from http://cnsgenomics.com/software/gcta/GCTA_UserManual_v1.24.pdf .</p>

<hr>
<h2 id='omxRMSEA'>Get the RMSEA with confidence intervals from model</h2><span id='topic+omxRMSEA'></span>

<h3>Description</h3>

<p>This function calculates the Root Mean Square Error of the Approximation (RMSEA) for a model and computes confidence intervals for that fit statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxRMSEA(model, lower=.025, upper=.975, null=.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxRMSEA_+3A_model">model</code></td>
<td>
<p>An MxModel object for which the RMSEA is desired</p>
</td></tr>
<tr><td><code id="omxRMSEA_+3A_lower">lower</code></td>
<td>
<p>The lower confidence bound for the confidence interval</p>
</td></tr>
<tr><td><code id="omxRMSEA_+3A_upper">upper</code></td>
<td>
<p>The upper confidence bound for the confidence interval</p>
</td></tr>
<tr><td><code id="omxRMSEA_+3A_null">null</code></td>
<td>
<p>Value of RMSEA used to test for close fit</p>
</td></tr>
<tr><td><code id="omxRMSEA_+3A_...">...</code></td>
<td>
<p>Further named arguments passed to summary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To help users obtain fit statistics related to the RMSEA, this function confidence intervals and a test for close fit.  The user determines how close the fit is required to be by setting the <code>null</code> argument to the value desired for comparison.
</p>


<h3>Value</h3>

<p>A named vector with elements lower, est.rmsea, upper, null, and 'Prob(x &lt;= null)'.
</p>


<h3>References</h3>

<p>Browne, M. W. &amp; Cudeck, R. (1992).  Alternative Ways of Assessing Model Fit. <em>Sociological Methods and Research</em>, <strong>21</strong>, 230-258.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(OpenMx)
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("One Factor", 
                       type="RAM",
                       manifestVars=manifests, 
                       latentVars=latents,
                       mxPath(from=latents, to=manifests),
                       mxPath(from=manifests, arrows=2),
                       mxPath(from=latents, arrows=2, free=FALSE, values=1.0),
                       mxData(observed=cov(demoOneFactor), type="cov", numObs=500))
factorRun &lt;- mxRun(factorModel)
factorSat &lt;- mxRefModels(factorRun, run=TRUE)
summary(factorRun, refModels=factorSat)
# Gives RMSEA with 95% confidence interval

omxRMSEA(factorRun, .05, .95, refModels=factorSat)
# Gives RMSEA with 90% confidence interval
#  and probability of 'close enough' fit
</code></pre>

<hr>
<h2 id='omxSapply'>On-Demand Parallel Sapply</h2><span id='topic+omxSapply'></span>

<h3>Description</h3>

<p>If the snowfall library is loaded, then this function calls <code><a href="snowfall.html#topic+sfSapply">sfSapply</a></code>.  Otherwise it invokes <code><a href="base.html#topic+sapply">sapply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxSapply(x, fun, ..., simplify = TRUE, USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxSapply_+3A_x">x</code></td>
<td>
<p>a vector (atomic or list) or an expressions vector. Other objects (including classed objects) will be coerced by <code><a href="base.html#topic+as.list">as.list</a></code>.</p>
</td></tr>
<tr><td><code id="omxSapply_+3A_fun">fun</code></td>
<td>
<p>the function to be applied to each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="omxSapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="omxSapply_+3A_simplify">simplify</code></td>
<td>
<p>logical; should the result be simplified to a vector or matrix if possible?</p>
</td></tr>
<tr><td><code id="omxSapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; if <code>TRUE</code> and if <code>x</code> is a character, use <code>x</code> as <code><a href="base.html#topic+names">names</a></code> for the result unless it had names already.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+omxApply">omxApply</a></code>, <code><a href="#topic+omxLapply">omxLapply</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
# compute the list mean for each list element
omxSapply(x, quantile)

</code></pre>

<hr>
<h2 id='omxSaturatedModel'>Create Reference (Saturated and Independence) Models</h2><span id='topic+omxSaturatedModel'></span><span id='topic+mxRefModels'></span>

<h3>Description</h3>

<p>This function creates and, optionally, runs saturated and independence (null) models of a base model or data set for use with <a href="#topic+mxSummary">mxSummary</a> to enable fit indices that depend on these models.  Note that there are cases where this function is not valid for use, or should be used with caution (see below, under &quot;Warnings&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mxRefModels(x, run=FALSE, ..., distribution="default", equateThresholds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxSaturatedModel_+3A_x">x</code></td>
<td>
<p>A MxModel object, data frame, or matrix.</p>
</td></tr>
<tr><td><code id="omxSaturatedModel_+3A_run">run</code></td>
<td>
<p>logical. If TRUE, runs the models before returning;
otherwise returns built models without running.</p>
</td></tr>
<tr><td><code id="omxSaturatedModel_+3A_...">...</code></td>
<td>
<p>Not used.  Forces remaining arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="omxSaturatedModel_+3A_distribution">distribution</code></td>
<td>
<p>character. Which distribution to assume.</p>
</td></tr>
<tr><td><code id="omxSaturatedModel_+3A_equatethresholds">equateThresholds</code></td>
<td>
<p>logical. Whether ordinal thresholds should be
constrained equal across groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For typical structural equation models the saturated model is the free-est possible model.  Not only all variances (and, when possible, all means) are estimated, but also all covariances.  In the case of ordinal data, the ordinal means are fixed to zero and the thresholds are estimated.  For binary variables, those variances are also constrained to one.  This is the free-est possible model that is identified.  The saturated model is used in calculating fit statistics such as the RMSEA, and Chi-squared fit indices.
</p>
<p>The independence model, sometimes called the null model, is a model in which each variable is treated as being completely independent of every other variable.  As such, all the variances and, when possible, all means are estimated.  However, covariances are set to zero.  Ordinal variables are handled the same for the independence and saturated models.  The independence model is used, along with the saturated model, to create CFI and TLI fit indices.
</p>
<p>The saturated and independence models could be used to create further fit indices.  However, OpenMx does not recommend using GFI, AGFI, NFI (aka Bentler-Bonett), or SRMR.  The page for <code><a href="#topic+mxSummary">mxSummary</a></code> has information about why.
</p>
<p>When the <a href="#topic+mxFitFunctionMultigroup">mxFitFunctionMultigroup</a> fit function is used, <code>mxRefModels</code> creates the appropriate multi-group saturated and independence models.  Saturated and independence models are created separately for each group.  Each group has its own saturated and independence model.  The multi-group saturated model is a multi-group model where each group has its own saturated model, and similarly for the independence model.
</p>
<p>When an MxModel has been run, some effort is made to make the reference models for only the variables used in the model.  For covariance data, all variables are modeled by default.  For raw data when the model has been run, only the modeled variables are used in the reference models.  This matches the behavior of <a href="#topic+mxModel">mxModel</a>.
</p>
<p>In general, it is best practice to give <code>mxRefModels</code> a model that has already been run.
</p>
<p>Multivariate normal models with all ordinal data and no missing values
can use the saturated multinomial distribution. This is much faster than
estimation of the saturated multivariate normal model. Use
<code>distribution='multinomial'</code> to avail this option.
</p>


<h3>Warnings</h3>

<p>One potentially important limitation of the <code>mxRefModels</code> function is for behavior-genetic models.  If variables 'x', 'y', and 'z' are measured on twins 1 and 2 creating the modeled variables 'x1', 'y1', 'z1', 'x2', 'y2', 'z2', then this function may not create the intended saturated or independence models.  In particular, the means of 'x1' and 'x2' are estimated separately.  Similarly, the covariance of 'x1' with 'y1' and 'x2' with 'y2' are allowed be be distinct: <code class="reqn">cov(x1, y1) != cov{x2, y2}</code>.  Moreover, the cross-twin covariances are estimated: e.g. <code class="reqn">cov(x1, y2) != 0</code>.
</p>
<p>Another potential misuse of this function is for models with definition variables.  If definition variables are used, the saturated and independence model may not be correct because they do not account for the definition variables.
</p>
<p>The are a few considerations specific to IFA models
(<a href="#topic+mxExpectationBA81">mxExpectationBA81</a>).
The independence model preserves equality constraints among item
parameters from the original model.
The saturated model is a multinomial distribution with the proportions
equal to the proportions in your data. For example, if you have 2
dichotomous items then there are 4 possible response patterns: 00, 01, 10, 11.
A multinomial distribution for these 2 items is fully specified by 3
proportions or 3 parameters: a, b, c, <code class="reqn">1.0-(a+b+c)</code>.
Hence, there is no need to optimize the saturated model.
When there is no missing data,
the deviance is immediately known as <code class="reqn">-2 * sum(log proportions)</code>.
Typical Bayesian priors involve latent
factors (various densities on the pseudo-guessing lower bound, log norm
on loading, and uniqueness prior). These priors cannot be included
in the independence model because there are no latent factors.
Therefore, exercise caution when comparing the independence model
to a model that includes Bayesian priors.
</p>
<p><code>mxRefModels()</code> is not compatible with
<a href="#topic+mxExpectationGREML">GREML expectation</a>, as there is no
sensible general definition for a saturated GREML-type model.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(OpenMx)
data(demoOneFactor)
manifests &lt;- names(demoOneFactor)
latents &lt;- c("G")
factorModel &lt;- mxModel("OneFactor", type = "RAM",
    manifestVars = manifests, latentVars = latents,
    mxPath(from = latents, to=manifests, values = diag(var(demoOneFactor))*.2),
    mxPath(from = manifests, arrows = 2, values = diag(var(demoOneFactor))*.8),
    mxPath(from = latents, arrows = 2, free = FALSE, values = 1),
    mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)
factorRun &lt;- mxRun(factorModel)
factorSat &lt;- mxRefModels(factorRun, run=TRUE)
summary(factorRun)
summary(factorRun, refModels=factorSat)

# A raw-data example where using mxRefModels adds fit indices

m1 &lt;- mxModel("OneFactor", type = "RAM",
    manifestVars = manifests, latentVars = latents,
    mxPath(latents, to=manifests, values = diag(var(demoOneFactor))*.2),
    mxPath(manifests, arrows = 2, values = diag(var(demoOneFactor))*.8),
    mxPath(latents, arrows = 2, free = FALSE, values = 1),
    mxPath("one", to = latents, free = FALSE, values = 0),
    mxPath("one", to = manifests, values = 0),
    mxData(demoOneFactor, type = "raw")
)
m1 &lt;- mxRun(m1)
summary(m1) # CFI, TLI, RMSEA missing
summary(m1, refModels=mxRefModels(m1, run = TRUE))


</code></pre>

<hr>
<h2 id='omxSelectRowsAndCols'>Filter rows and columns from an mxMatrix</h2><span id='topic+omxSelectRowsAndCols'></span><span id='topic+omxSelectRows'></span><span id='topic+omxSelectCols'></span>

<h3>Description</h3>

<p>This function filters rows and columns from a matrix using a single row or column R matrix as a selector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxSelectRowsAndCols(x, selector)
omxSelectRows(x, selector)
omxSelectCols(x, selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxSelectRowsAndCols_+3A_x">x</code></td>
<td>
<p>the matrix to be filtered</p>
</td></tr>
<tr><td><code id="omxSelectRowsAndCols_+3A_selector">selector</code></td>
<td>
<p>A single row or single column R matrix indicating which values should be filtered from the mxMatrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>omxSelectRowsAndCols, omxSelectRows, and omxSelectCols returns the filtered entries in a target matrix specified by a single row or single column selector matrix. Each entry in the selector matrix is treated as a logical data indicating if the corresponding entry in the target matrix should be excluded (0 or FALSE) or included (not 0 or TRUE). Typically the function is used to filter data from a target matrix using an existence vector which specifies what data entries are missing. This can be seen in the demo: RowObjectiveFIMLBivariateSaturated. 
</p>


<h3>Value</h3>

<p>Returns a new matrix with the filtered data.
</p>


<h3>References</h3>

<p>The function is most often used when filtering data for missingness. This can be seen in the demo: RowObjectiveFIMLBivariateSaturated. The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>. The omxSelect* functions share some similarity to the Extract function in the R programming language.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadings &lt;- matrix(1:9, 3, 3, byrow= TRUE)
existenceList &lt;- c(1, 0, 1)
existenceList &lt;- matrix(existenceList, 1, 3, byrow= TRUE)
rowsAndCols &lt;- omxSelectRowsAndCols(loadings, existenceList)
rows &lt;- omxSelectRows(loadings, existenceList)
cols &lt;- omxSelectCols(loadings, existenceList)
</code></pre>

<hr>
<h2 id='omxSetParameters'>Assign Model Parameters</h2><span id='topic+omxSetParameters'></span>

<h3>Description</h3>

<p>Modify the attributes of parameters in a model.  This function cannot modify parameters that have NA labels.
Often you will want to call <code><a href="#topic+omxAssignFirstParameters">omxAssignFirstParameters</a></code> after using this, to force the starting
values of equated parameters to the same value (otherwise the model cannot begin to be evaluated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omxSetParameters(model, labels=names(coef(model)), free = NULL, values = NULL,
    newlabels = NULL, lbound = NULL, ubound = NULL, indep = FALSE,
    strict = TRUE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omxSetParameters_+3A_model">model</code></td>
<td>
<p>an MxModel object.</p>
</td></tr>
<tr><td><code id="omxSetParameters_+3A_labels">labels</code></td>
<td>
<p>a character vector of target parameter names.</p>
</td></tr>
<tr><td><code id="omxSetParameters_+3A_free">free</code></td>
<td>
<p>a boolean vector of parameter free/fixed designations.</p>
</td></tr> 
<tr><td><code id="omxSetParameters_+3A_values">values</code></td>
<td>
<p>a numeric vector of parameter values.</p>
</td></tr>
<tr><td><code id="omxSetParameters_+3A_newlabels">newlabels</code></td>
<td>
<p>a character vector of new parameter names.</p>
</td></tr> 
<tr><td><code id="omxSetParameters_+3A_lbound">lbound</code></td>
<td>
<p>a numeric vector of lower bound values.</p>
</td></tr> 
<tr><td><code id="omxSetParameters_+3A_ubound">ubound</code></td>
<td>
<p>a numeric vector of upper bound values.</p>
</td></tr> 
<tr><td><code id="omxSetParameters_+3A_indep">indep</code></td>
<td>
<p>boolean. set parameters in independent submodels.</p>
</td></tr>
<tr><td><code id="omxSetParameters_+3A_strict">strict</code></td>
<td>
<p>boolean. If TRUE then throw an error when a label does not appear in the model.</p>
</td></tr>
<tr><td><code id="omxSetParameters_+3A_name">name</code></td>
<td>
<p>character string. (optional) a new name for the model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+omxGetParameters">omxGetParameters</a></code>, <code><a href="#topic+omxAssignFirstParameters">omxAssignFirstParameters</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- mxMatrix('Full', 3, 3, labels = c('a','b', NA), free = TRUE, name = 'A')
model &lt;- mxModel(model="testModel7", A, name = 'model')

# set value of cells labelled "a" and "b" to 1 and 2 respectively
model &lt;- omxSetParameters(model, c('a', 'b'), values = c(1, 2))

# set label of cell labelled "a" to "b" and vice versa
model &lt;- omxSetParameters(model, c('a', 'b'), newlabels = c('b', 'a'))

# set label of cells labelled "a" to "b"
model &lt;- omxSetParameters(model, c('a'), newlabels = 'b')

# ensure initial values are the same for each instance of a labeled parameter
model &lt;- omxAssignFirstParameters(model)
</code></pre>

<hr>
<h2 id='omxSymbolTable'>
Internal OpenMx algebra operations
</h2><span id='topic+omxSymbolTable'></span>

<h3>Description</h3>

<p>This is an internal table used in the OpenMx backend.
</p>

<hr>
<h2 id='OpenMx'>OpenMx: An package for Structural Equation Modeling and Matrix Algebra Optimization</h2><span id='topic+OpenMx'></span><span id='topic+OpenMx-package'></span>

<h3>Description</h3>

<p>OpenMx is a package for structural equation modeling, matrix algebra optimization and other statistical estimation problems. 
Try the example below. We try and have useful help files: for instance help(<code><a href="#topic+mxRun">mxRun</a></code>) to learn more. Also the reference manual
</p>


<h3>Details</h3>

<p>OpenMx solves algebra optimization and statistical estimation problems using matrix algebra. 
Most users use it for Structural equation modeling.
</p>
<p>The core function is <code><a href="#topic+mxModel">mxModel</a></code>, which makes a model. Models are containers for <code><a href="#topic+mxData">mxData</a></code>, <code><a href="#topic+mxMatrix">matrices</a></code>, <code><a href="#topic+mxPath">mxPath</a></code>s
<code><a href="#topic+mxAlgebra">algebras</a></code>, <a href="#topic+mxBounds">mxBounds</a>, <code><a href="#topic+mxCI">confidence intervals</a></code>, and <code><a href="#topic+mxConstraint">mxConstraints</a></code>.
Most models require an expectation (see the list below) to calculate the expectations for the model.
Models also need a fit function, several of which are built-in (see below).
OpenMx also allows user-defined fit functions for purposes not covered by the built-in functions. (e.g., <code><a href="#topic+mxFitFunctionR">mxFitFunctionR</a></code> or <code><a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a></code>).
</p>
<p><em>Note</em>, for mxModels of <code>type="RAM"</code>, the expectation and fit-function are set for you automatically.
</p>
<p><strong>Running and summarizing a model</strong>
</p>
<p>Once built, the resulting mxModel can be run (i.e., optimized) using  <code><a href="#topic+mxRun">mxRun</a></code>. This returns the fitted model.
</p>
<p>You can summarize the results of the model using <code><a href="#topic+summary.MxModel">summary</a></code>(yourModel)
</p>
<p><strong>Additional overview of model making and getting started</strong>
</p>
<p>The OpenMx manual is online (see references below). However, <code><a href="#topic+mxRun">mxRun</a></code>, <code><a href="#topic+mxModel">mxModel</a></code>, <code><a href="#topic+mxMatrix">mxMatrix</a></code>
all have working examples that will help get you started as well.
</p>
<p>The main OpenMx functions are: <code><a href="#topic+mxAlgebra">mxAlgebra</a></code>, <code><a href="#topic+mxBounds">mxBounds</a></code>, <code><a href="#topic+mxCI">mxCI</a></code>, <code><a href="#topic+mxConstraint">mxConstraint</a></code>, <code><a href="#topic+mxData">mxData</a></code>, 
<code><a href="#topic+mxMatrix">mxMatrix</a></code>, <code><a href="#topic+mxModel">mxModel</a></code>, and <code><a href="#topic+mxPath">mxPath</a></code>.
</p>
<p>Expectation functions include <code><a href="#topic+mxExpectationNormal">mxExpectationNormal</a></code>, <code><a href="#topic+mxExpectationRAM">mxExpectationRAM</a></code>, <code><a href="#topic+mxExpectationLISREL">mxExpectationLISREL</a></code>, and <code><a href="#topic+mxExpectationStateSpace">mxExpectationStateSpace</a></code>;
</p>
<p>Fit functions include <a href="#topic+mxFitFunctionML">mxFitFunctionML</a>, <a href="#topic+mxFitFunctionAlgebra">mxFitFunctionAlgebra</a>, <a href="#topic+mxFitFunctionRow">mxFitFunctionRow</a> and <a href="#topic+mxFitFunctionR">mxFitFunctionR</a>.
</p>
<p><strong>Datasets built into OpenMx</strong>
</p>
<p><code>OpenMx</code> comes with over a dozen useful datasets built-in. Discover them using <code>data(package="OpenMx")</code>, and open them with, 
for example, <code>data("jointdata", package ="OpenMx", verbose= TRUE)</code>
</p>
<p>Please cite the 'OpenMx' package in any publications that make use of it:
</p>
<p>Michael C. Neale, Michael D. Hunter, Joshua N. Pritikin, Mahsa Zahery, Timothy R. Brick Robert M.
Kirkpatrick, Ryne Estabrook, Timothy C. Bates, Hermine H. Maes, Steven M. Boker. (2016).
OpenMx 2.0: Extended structural equation and statistical modeling. <em>Psychometrika</em>, <strong>81</strong>, 535549. 
DOI: 10.1007/s11336-014-9435-8
</p>
<p>Steven M. Boker, Michael C. Neale, Hermine H. Maes, Michael J. Wilde, Michael Spiegel, Timothy R. Brick,
Jeffrey Spies, Ryne Estabrook, Sarah Kenny, Timothy C. Bates, Paras Mehta, and John Fox. (2011)
OpenMx: An Open Source Extended Structural Equation Modeling Framework. 
<em>Psychometrika</em>, 306-317. DOI:10.1007/s11336-010-9200-6
</p>
<p>Steven M. Boker, Michael C. Neale, Hermine H. Maes, Michael J. Wilde, Michael Spiegel, Timothy R. Brick, Ryne
Estabrook, Timothy C. Bates, Paras Mehta, Timo von Oertzen, Ross J. Gore, Michael D. Hunter, Daniel C.
Hackett, Julian Karch, Andreas M. Brandmaier, Joshua N. Pritikin, Mahsa Zahery, Robert M. Kirkpatrick, 
Yang Wang, and Charles Driver. (2016) OpenMx 2 User Guide. 
http://openmx.ssri.psu.edu/docs/OpenMx/latest/OpenMxUserGuide.pdf
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation">https://openmx.ssri.psu.edu/documentation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(OpenMx)
data(demoOneFactor)
# ===============================
# = Make and run a 1-factor CFA =
# ===============================

latents  = c("G") # the latent factor
manifests = names(demoOneFactor) # manifest variables to be modeled
# ====================
# = Make the MxModel =
# ====================
m1 &lt;- mxModel("One Factor", type = "RAM", 
	manifestVars = manifests, latentVars = latents, 
	mxPath(from = latents, to = manifests),
	mxPath(from = manifests, arrows = 2),
	mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
	mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)

# ===============================
# = mxRun it and get a summary! =
# ===============================

m1 = mxRun(m1)
summary(m1)

</code></pre>

<hr>
<h2 id='ordinalTwinData'>
Data for ordinal twin model
</h2><span id='topic+ordinalTwinData'></span>

<h3>Description</h3>

<p>Example data for ordinal twin-data modelling. Three variables measured in each twin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ordinalTwinData")</code></pre>


<h3>Format</h3>

<p>A data frame with 139 observations on the following 7 variables.
</p>

<dl>
<dt><code>zyg</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var1_twin1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var2_twin1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var3_twin1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var1_twin2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var2_twin2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>var3_twin2</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ordinalTwinData)
str(ordinalTwinData)
</code></pre>

<hr>
<h2 id='Oscillator'>
Oscillator Data for Latent Differential Equations
</h2><span id='topic+Oscillator'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples, for instance the LDE demo. The data were simulated by Steven M. Boker according to a noisy oscillator model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Oscillator")</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 1 numeric variable.
</p>

<dl>
<dt><code>x</code></dt><dd><p>Noisy oscillator value</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data appear to be sinusoidal with exponential decay on the amplitude.  The rows of data are different times.  The column is the variable.</p>


<h3>Source</h3>

<p>Simulated.  Pulled from <a href="https://openmx.ssri.psu.edu/thread/144">https://openmx.ssri.psu.edu/thread/144</a></p>


<h3>References</h3>

<p>Boker, S., Neale, M., &amp; Rausch, J. (2004). Latent differential equation modeling with multivariate multi-occasion indicators. In <em>Recent developments on structural equation models</em> van Montfort, K., Oud, H, and Satorra, A. (Eds.). 151-174. Springer, Dordrecht.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Oscillator)
plot(Oscillator$x, type='l')
</code></pre>

<hr>
<h2 id='predict.MxModel'><code>predict</code> method for <code>MxModel</code> objects</h2><span id='topic+predict.MxModel'></span>

<h3>Description</h3>

<p><code>predict</code> method for <code>MxModel</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MxModel'
predict(
  object,
  newdata = NULL,
  interval = c("none", "confidence", "prediction"),
  method = c("ML", "WeightedML", "Regression", "Kalman"),
  level = 0.95,
  type = c("latent", "observed"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MxModel_+3A_object">object</code></td>
<td>
<p>an MxModel object from which predictions are desired</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code> object. See details.</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_interval">interval</code></td>
<td>
<p>character indicating what kind of intervals are desired.  'none' gives no intervals, 'confidence', gives confidence intervals, 'prediction' gives prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_method">method</code></td>
<td>
<p>character the method used to create the predictions.  See details.</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_level">level</code></td>
<td>
<p>the confidence or predictions level, ignored if not using intervals</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_type">type</code></td>
<td>
<p>character the type of thing you want predicted: latent variables or manifest variables.</p>
</td></tr>
<tr><td><code id="predict.MxModel_+3A_...">...</code></td>
<td>
<p>further named arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>newdata</code> argument is either a <code>data.frame</code> or <code>MxData</code> object.  In the latter case is replaces the data in the top level model.  In the former case, it is passed as the <code>observed</code> argument of <code>mxData</code> with <code>type='raw'</code> and must accept the same further arguments as the data in the model passed in the <code>object</code> argument.
</p>
<p>The available methods for prediction are 'ML', 'WeightedML', 'Regression', and 'Kalman'.  See the help page for <code><a href="#topic+mxFactorScores">mxFactorScores</a></code> for details on the first three of these.  The 'Kalman' method uses the Kalman filter to create predictions for state space models.
</p>

<hr>
<h2 id='rvectorize'>Vectorize By Row</h2><span id='topic+rvectorize'></span>

<h3>Description</h3>

<p>This function returns the vectorization of an input matrix in a row by row traversal of the matrix.  The output is returned as a column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvectorize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvectorize_+3A_x">x</code></td>
<td>
<p>an input matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cvectorize">cvectorize</a></code>, <code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+vechs">vechs</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rvectorize(matrix(1:9, 3, 3))
rvectorize(matrix(1:12, 3, 4))


</code></pre>

<hr>
<h2 id='summary.MxModel'>Model Summary</h2><span id='topic+summary.MxModel'></span><span id='topic+mxSummary'></span>

<h3>Description</h3>

<p>This function returns summary statistics of a model. These include model statistics (parameters, degrees of freedom and likelihood),
fit statistics such as AIC, parameter estimates and standard errors (when available), as well as version and timing information
and possible warnings about estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MxModel'
summary(object, ..., verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.MxModel_+3A_object">object</code></td>
<td>
<p>A MxModel object.</p>
</td></tr>
<tr><td><code id="summary.MxModel_+3A_...">...</code></td>
<td>
<p>Any number of named arguments (see below).</p>
</td></tr>
<tr><td><code id="summary.MxModel_+3A_verbose">verbose</code></td>
<td>
<p>Whether to include extra diagnostic information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mxSummary allows the user to set or override the following parameters of the model:
</p>

<dl>
<dt>numObs</dt><dd><p>Numeric. Specify the total number of observations for the model.</p>
</dd>
<dt>numStats</dt><dd><p>Numeric. Specify the total number of observed statistics for the model.</p>
</dd>
<dt>refModels</dt><dd><p>List of MxModel objects. Specify a saturated and independence likelihoods in single argument for testing.</p>
</dd>
<dt>SaturatedLikelihood</dt><dd><p>Numeric or MxModel object. Specify a saturated likelihood for testing.</p>
</dd>
<dt>SaturatedDoF</dt><dd><p>Numeric. Specify the degrees of freedom of the saturated likelihood for testing.</p>
</dd>
<dt>IndependenceLikelihood</dt><dd><p>Numeric or MxModel object. Specify an independence likelihood for testing.</p>
</dd>
<dt>IndependenceDoF</dt><dd><p>Numeric. Specify the degrees of freedom of the independence likelihood for testing.</p>
</dd>
<dt>indep</dt><dd><p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</dd>
<dt>verbose</dt><dd><p>logical. Changes the printing style for summary (see Details)</p>
</dd>
<dt>boot.quantile</dt><dd><p>numeric. A vector of quantiles to be used to
summarize bootstrap replication.</p>
</dd>
<dt>boot.SummaryType</dt><dd><p>character. One of &lsquo;quantile&rsquo; or &lsquo;bcbci&rsquo;.</p>
</dd>
</dl>

<p><strong>Standard Output</strong>
</p>
<p>The standard output consists of a table of free parameters, tables of model and fit statistics, information on the time taken to run the model, the optimizer used, and the version of OpenMx.
</p>
<p><strong>Table of free parameters</strong>
</p>
<p>Free parameters in the model are reported in a table with columns for the name (label) of the parameter, the matrix, row and col containing the parameter, the parameter estimate itself, and any lower or upper bounds set for the parameter.
</p>
<p><strong>Additional columns: standard errors, exclamation marks (&quot;!&quot;), and the 'A' (asymmetry) warning column</strong>
</p>
<p>When the information matrix is available, either approximated by the Hessian or from bootstrap resampling, standard errors are reported in the column &quot;Std.Error&quot;.
</p>
<p>An exclamation mark (&quot;!&quot;) can appear in two places: after a lower or upper bound, and in the 'A' column.  When an exclamation mark appears after a bound in the lbound or ubound columns, it indicates that the solution was sufficiently close to the bound that the optimizer could not ignore the bound during its last few iterations.
</p>
<p>An exclamation mark may also appear under the 'A' column, but in this case it has a different meaning.  If the information matrix was estimated using finite differences then an additional diagnostic column 'A' is displayed. An exclamation point in the 'A' column indicates that the gradient appears to be asymmetric and the standard error might not accurately reflect the sampling variability of that parameter.  As a precaution, it is recommended that you compare the SEs with profile likelihood-based confidence intervals (<a href="#topic+mxCI">mxCI</a>) or bootstrap confidence intervals.
</p>
<p><strong>Fit statistics</strong>
</p>
<p>AIC and BIC <code>Information Criteria</code> are reported in a table showing different versions of the information criteria obtained using different penalties. AIC is reported with both a Parameters Penalty and a Degrees of Freedom Penalty version.  AIC generally takes the form <code class="reqn">Fit + 2*k</code>.  With the Parameters Penalty version, <code class="reqn">k</code> is the number of free parameters:  <code class="reqn">AIC.param = Fit + 2*param</code>.  With the Degrees of Freedom Penalty, <code class="reqn">k</code> is minus one times the model degrees of freedom.  So the penalty is subtracted instead of added: <code class="reqn">AIC.param = Fit - 2*df</code>.  The Degrees of Freedom penalty was used in Classic Mx.  BIC is defined similarly: <code class="reqn">Fit + k*log(N)</code> where <code class="reqn">k</code> is either the number of free parameters or minus one times the model degrees of freedom.  The Sample-Size-Adjusted BIC is only defined for the parameters penalty: <code class="reqn">Fit + k*log((N+2)/24)</code>.  Similarly, the Sample-Size-Adjusted AIC is <code class="reqn">Fit + 2*k + 2*k*(k+1)/(N-k-1)</code>.  For raw data models, <code class="reqn">Fit</code> is the minus 2 log likelihood, <code class="reqn">-2LL</code>.  For covariance data, <code class="reqn">Fit</code> is the Chi-squared statistic.  The <code class="reqn">-2LL</code> and saturated likelihood values reported under covariance data are not necessarily meaningful on their own, but their difference yields the Chi-squared value.
</p>
<p><strong>Additional fit statistics</strong>
</p>
<p>When the model has a saturated likelihood, several additional fit indices are printed, including Chi-Squared, CFI, TLI, RMSEA and p RMSEA &lt;= 0.05. For covariance data, saturated and independence models are fitted automatically so all fit indices are reported.
</p>
<p>For raw data (to save computational time), the reference models needed to compute these absolute statistics are <strong>not estimated</strong> by default. They are available once you fit reference models.
</p>
<p>The <code>refModels</code>, <code>SaturatedLikelihood</code>, <code>SaturatedDoF</code>, <code>IndependenceLikelihood</code>, and <code>IndependenceDoF</code> arguments can be used to obtain these additional fit statistics.   An easy way to make reference models for most cases is provided by the <a href="#topic+mxRefModels">mxRefModels</a> function (see the example given in <a href="#topic+mxRefModels">mxRefModels</a>).
</p>
<p>When the <code>SaturatedLikelihood</code> or <code>IndependenceLikelihood</code> arguments are used, OpenMx attempts to calculate the appropriate degrees of freedom.  However, depending on the model, it may sometimes be necessary for the user to also explicitly provide the corresponding <code>SaturatedDoF</code> and/or <code>IndependenceDoF</code>.  Again, for the vast majority of cases, the <a href="#topic+mxRefModels">mxRefModels</a> function handles these situations effectively and conveniently.
</p>
<p><strong>Notes on fit statistics</strong>
</p>
<p>With regard to RMSEA, it is important to note that OpenMx does not currently make a multigroup adjustment that some other structural equation modeling programs make.  In particular, we do not multiply the single-group RMSEA by the square root of the number of groups as suggested by Steiger (1998).  The RMSEA we use is based on the model likelihood (and degrees of freedom) as compared to the saturated model likelihood (and degrees of freedom), and we do not feel the adjustment is appropriate in this case.
</p>
<p>OpenMx does not recommend (and does not compute) some fit indices including GFI, AGFI, NFI, and SRMR.  The Goodness of Fit Index (GFI) and Adjusted Goodness of Fit Index (AGFI) are not recommended because they are strongly influenced by sample size and have rather high Type I error rates (Sharma, Mukherjee, Kumar, &amp; Dillon, 2005).  The Normed Fit Index (NFI) has no penalty for model complexity.  That is, adding more parameters to a model always improves the NFI, regardless of how useful those parameters are.  Because the Non-Normed Fit Index (NNFI), also known as the Tucker-Lewis Index (TLI), does adjust for model complexity it is used instead.  Lastly, the Standardized Root Mean Square Residual (SRMR) is not reported because it (1) only applies to covariance models, having no direct extension to missing data, (2) has no penalty for model complexity, similar to the NFI, and (3) is positively biased (Hu &amp; Bentler, 1999).
</p>
<p><strong>verbose</strong>
</p>
<p>The <code>verbose</code> argument changes the printing style for the <code>summary</code> of a model.  When <code>verbose=FALSE</code>, a relatively minimal amount of information is printed: the free parameters, the likelihood, and a few fit indices. When <code>verbose=TRUE</code>, the compute plan, data summary, and additional timing information are always printed.  Moreover, available fit indices are printed regardless of whether or not they are defined.  The undefined fit indices are printed as <code>NA</code>. In addition, the condition number of the information matrix,  and the maximum absolute gradient may also be shown.
</p>
<p><em>note:</em> The <code>verbose</code> argument only changes the printing style, all of the same information is calculated and exists in the output of <code>summary</code>.  More information is displayed when <code>verbose=TRUE</code>, and less when <code>verbose=FALSE</code>.
</p>
<p><strong>Summary for bootstrap replications</strong>
</p>
<p>Summarization of bootstrap replications is controlled by two options: &lsquo;boot.quantile&rsquo; and &lsquo;boot.SummaryType&rsquo;. To obtain a two-sided 95% width confidence interval, use <code>boot.quantile=c(.025,.975)</code>. Options for &lsquo;boot.SummaryType&rsquo; are &lsquo;quantile&rsquo; (using R's standard <code>stats::quantile</code> function) and &lsquo;bcbci&rsquo; for bias-corrected bootstrap confidence intervals.  The latter, &lsquo;bcbci&rsquo;, is the default due to its superior theoretical properties.
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>
<p>Hu, L., &amp; Bentler, P. M. (1999). Cutoff criteria for fit indexes in covariance structure analysis: Conventional criteria versus new alternatives. <em>Structural Equation Modeling, 6,</em> 1-55.
</p>
<p>Savalei, V. (2012). The relationship between root mean square error of approximation and model misspecification in confirmatory factor analysis models. <em>Educational and Psychological Measurement, 72</em>(6), 910-932.
</p>
<p>Sharma, S., Mukherjee, S., Kumar, A., &amp; Dillon, W.R. (2005). A simulation study to investigate the use of cutoff values for assessing model fit in covariance structure models. <em>Journal of Business Research, 58,</em> 935-43.
</p>
<p>Steiger, J. H. (1998). A note on multiple sample extensions of the RMSEA fit index. <em>Structural Equation Modeling: A Multidisciplinary Journal, 5(4)</em>, 411-419. DOI: 10.1080/10705519809540115
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mxBootstrap">mxBootstrap</a></code>
<code><a href="#topic+mxCI">mxCI</a></code>
<code><a href="#topic+as.statusCode">as.statusCode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)
data(demoOneFactor)  # load the demoOneFactor dataframe
manifests &lt;- names(demoOneFactor) # set the manifest to the 5 demo variables
latents &lt;- c("G")  # define 1 latent variable
model &lt;- mxModel(model="One Factor", type="RAM",
    manifestVars = manifests,
    latentVars = latents,
    mxPath(from = latents, to=manifests, labels = paste("b", 1:5, sep = "")),
    mxPath(from = manifests, arrows = 2, labels = paste("u", 1:5, sep = "")),
    mxPath(from = latents, arrows = 2, free = FALSE, values = 1.0),
    mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)
model &lt;- mxRun(model) # Run the model, returning the result into model

# Show summary of the fitted model
summary(model)

# Compute the summary and store in the variable "statistics"
statistics &lt;- summary(model)

# Access components of the summary
statistics$parameters
statistics$SaturatedLikelihood

# Specify a saturated likelihood for testing
summary(model, SaturatedLikelihood = -3000)

# Add a CI and view it in the summary
model = mxRun(mxModel(model=model, mxCI("b5")), intervals = TRUE)
summary(model)

</code></pre>

<hr>
<h2 id='tr'>trace</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>This function returns the trace of an n-by-n square matrix x,  defined to be the sum of the elements
on the main diagonal (the diagonal from the upper left to the lower right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">x</code></td>
<td>
<p>an input matrix. Must be square</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input matrix must be square.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+cvectorize">cvectorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr(matrix(1:9, 3, 3))
tr(matrix(1:12, 3, 4))


</code></pre>

<hr>
<h2 id='twin_NA_dot'>
Twin biometric data (Practice cleaning: &quot;.&quot; for missing data, wrong data types etc.)
</h2><span id='topic+twin_NA_dot'></span>

<h3>Description</h3>

<p>Data set used in some of OpenMx's examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("twin_NA_dot")</code></pre>


<h3>Format</h3>

<p>A data frame with 3808 observations on the following variables.
</p>

<dl>
<dt><code>fam</code></dt><dd><p>Family ID variable</p>
</dd>
<dt><code>age</code></dt><dd><p>Age of the twin pair.  Range: 17 to 88, coded as factor</p>
</dd>
<dt><code>zyg</code></dt><dd><p>Integer codes for zygosity and gender combinations</p>
</dd>
<dt><code>part</code></dt><dd><p>Cohort</p>
</dd>
<dt><code>wt1</code></dt><dd><p>Weight in kilograms for twin 1 (this and following have &quot;.&quot; embedded as NA...)</p>
</dd>
<dt><code>wt2</code></dt><dd><p>Weight in kilograms for twin 2</p>
</dd>
<dt><code>ht1</code></dt><dd><p>Height in meters for twin 1</p>
</dd>
<dt><code>ht2</code></dt><dd><p>Height in meters for twin 2</p>
</dd>
<dt><code>htwt1</code></dt><dd><p>Product of ht and wt for twin 1</p>
</dd>
<dt><code>htwt2</code></dt><dd><p>Product of ht and wt for twin 2</p>
</dd>
<dt><code>bmi1</code></dt><dd><p>Body Mass Index for twin 1</p>
</dd>
<dt><code>bmi2</code></dt><dd><p>Body Mass Index for twin 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>Same as <a href="#topic+myTwinData">myTwinData</a> but has . as the missing data value instead of NA. 
</p>


<h3>Source</h3>

<p>Timothy Bates
</p>


<h3>References</h3>

<p>The OpenMx User's guide can be found at <a href="https://openmx.ssri.psu.edu/documentation/">https://openmx.ssri.psu.edu/documentation/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(twin_NA_dot)
summary(twin_NA_dot)
# Note that all variables are treated as factors because of the missing data coding.


</code></pre>

<hr>
<h2 id='twinData'>Australian twin sample biometric data.</h2><span id='topic+twinData'></span>

<h3>Description</h3>

<p>Australian twin data with 3,808 observations on the 12 variables including body mass index (BMI) assessed in both MZ and DZ twins.
</p>
<p>Questionnaires were mailed to 5,967 pairs age 18 years and over. These data consist of completed questionnaires returned by both members of 3,808 (64 percent) pairs. There are two cohort blocks in the data: a younger group (zyg 1:5), and an older group (zyg 6:10)
</p>
<p>It is a wide dataset, with two individuals per line. Families are identified by the variable &ldquo;fam&rdquo;.
</p>
<p>Data include zygosity (zyg), along with heights in meters, weights in
kg, and the derived variables BMI in kg/m^2 (stored as &ldquo;htwt1&rdquo;
and &ldquo;htwt2&rdquo;), as well as the 7 times the natural log of this variable,
stored as bmi1 and bmi2. The logged values are more closely
normally distributed while scaling by 7 places them into a similar range
to the original variable.
</p>
<p>For convenience, zyg is broken out into separate &ldquo;zygosity&rdquo; and &ldquo;cohort&rdquo; factors. &ldquo;zygosity&rdquo; is
coded as a factor with 5-levels: MZFF, MZMM, DZFF, DZMM, DZOS. DZOS are in Female/Male wide order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(twinData)</code></pre>


<h3>Format</h3>

<p>A data frame with 3808 observations on the following 12 variables.
</p>

<dl>
<dt><code>fam</code></dt><dd><p>The family ID</p>
</dd>
<dt><code>age</code></dt><dd><p>Age in years (of both twins)</p>
</dd>
<dt><code>zyg</code></dt><dd><p>Code for zygosity and cohort (see details)</p>
</dd>
<dt><code>part</code></dt><dd><p>A numeric vector</p>
</dd>
<dt><code>wt1</code></dt><dd><p>Weight of twin 1 (kg)</p>
</dd>
<dt><code>wt2</code></dt><dd><p>Weight of twin 2 (kg)</p>
</dd>
<dt><code>ht1</code></dt><dd><p>Height of twin 1 (m)</p>
</dd>
<dt><code>ht2</code></dt><dd><p>Height of twin 2 (m)</p>
</dd>
<dt><code>htwt1</code></dt><dd><p>Raw BMI of twin 1 (kg/m^2)</p>
</dd>
<dt><code>htwt2</code></dt><dd><p>Raw BMI of twin 2 (kg/m^2)</p>
</dd>
<dt><code>bmi1</code></dt><dd><p>7*log(BMI) of twin 1</p>
</dd>
<dt><code>bmi2</code></dt><dd><p>7*log(BMI) of twin 2</p>
</dd>
<dt><code>cohort</code></dt><dd><p>Either &ldquo;younger&rdquo; or &ldquo;older&rdquo;</p>
</dd>
<dt><code>zygosity</code></dt><dd><p>Zygosity factor with levels: MZFF, MZMM, DZFF, DZMM, DZOS</p>
</dd>
<dt><code>age1</code></dt><dd><p>Age of Twin 1</p>
</dd>
<dt><code>age2</code></dt><dd><p>Age of Twin 2</p>
</dd>
</dl>



<h3>Details</h3>

<p>&ldquo;zyg&rdquo; codes twin-zygosity as follows:
1 == MZFF (i.e MZ females)
2 == MZMM (i.e MZ males)
3 == DZFF
4 == DZMM
5 == DZOS opposite sex pairs
</p>
<p>Note: zyg 6:10 are for an older cohort in the sample. So:
6 == MZFF (i.e MZ females)
7 == MZMM (i.e MZ males)
8 == DZFF
9 == DZMM
10 == DZOS opposite sex pairs
</p>
<p>The &ldquo;zygosity&rdquo; and &ldquo;cohort&rdquo; variables take care of this for you (conventions differ).
</p>


<h3>References</h3>

<p>Martin, N. G. &amp; Jardine, R. (1986). Eysenck's contribution to behavior genetics. In S. Modgil &amp; C. Modgil (Eds.), <em>Hans Eysenck: Consensus and Controversy.</em> Falmer Press: Lewes, Sussex.
</p>
<p>Martin, N. G., Eaves, L. J., Heath, A. C., Jardine, R., Feingold, L. M., &amp; Eysenck, H. J. (1986). Transmission of social attitudes. <em>Proceedings of the National Academy of Science</em>, <b>83</b>, 4364-4368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(twinData)
str(twinData)
plot(wt1 ~ wt2, data = twinData)
selVars = c("bmi1", "bmi2")
mzData &lt;- subset(twinData, zyg == 1, selVars)
dzData &lt;- subset(twinData, zyg == 3, selVars)

# equivalently
mzData &lt;- subset(twinData, zygosity == "MZFF", selVars)

# Disregard sex, pick older cohort
mz &lt;- subset(twinData, zygosity %in% c("MZFF","MZMM") &amp; cohort == "older", selVars)

</code></pre>

<hr>
<h2 id='vec2diag'>Create Diagonal Matrix From Vector</h2><span id='topic+vec2diag'></span>

<h3>Description</h3>

<p>Given an input row or column vector, <code>vec2diag</code> returns a diagonal matrix with the input argument along the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2diag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2diag_+3A_x">x</code></td>
<td>
<p>a row or column vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the function <code><a href="base.html#topic+diag">diag</a></code>, except that the input argument is always
treated as a vector of elements to place along the diagonal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diag2vec">diag2vec</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec2diag(matrix(1:4, 1, 4))
vec2diag(matrix(1:4, 4, 1))


</code></pre>

<hr>
<h2 id='vech'>Half-vectorization</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>This function returns the half-vectorization of an input matrix as a column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p>an input matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The half-vectorization of an input matrix consists of the elements in the lower triangle of the matrix, including the elements along the diagonal of the matrix, as a column vector.  The column vector is created by traversing the matrix in column-major order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech2full">vech2full</a></code>, <code><a href="#topic+vechs">vechs</a></code>, <code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+cvectorize">cvectorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vech(matrix(1:9, 3, 3))
vech(matrix(1:12, 3, 4))


</code></pre>

<hr>
<h2 id='vech2full'>Inverse Half-vectorization</h2><span id='topic+vech2full'></span>

<h3>Description</h3>

<p>This function returns the symmetric matrix constructed from a half-vectorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech2full(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech2full_+3A_x">x</code></td>
<td>
<p>an input single column or single row matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The half-vectorization of an input matrix consists of the elements in the lower triangle of the matrix, including the elements along the diagonal of the matrix, as a column vector.  The column vector is created by traversing the matrix in column-major order.  The inverse half-vectorization takes a vector and reconstructs a symmetric matrix such that <code>vech2full(vech(x))</code> is identical to <code>x</code> if <code>x</code> is symmetric.
</p>
<p>Note that very few vectors have the correct number of elements to construct a symmetric matrix.  For example, vectors with 1, 3, 6, 10, and 15 elements can be used to make a symmetric matrix, but none of the other numbers between 1 and 15 can.  An error is thrown if the number of elements in <code>x</code> cannot be used to make a symmetric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vechs2full">vechs2full</a></code>, <code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+vechs">vechs</a></code>, <code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+cvectorize">cvectorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vech2full(1:10)

matrix(1:16, 4, 4)
vech(matrix(1:16, 4, 4))
vech2full(vech(matrix(1:16, 4, 4)))



</code></pre>

<hr>
<h2 id='vechs'>Strict Half-vectorization</h2><span id='topic+vechs'></span><span id='topic+vechs+3C-'></span>

<h3>Description</h3>

<p>This function returns the strict half-vectorization of an input matrix as a column vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vechs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vechs_+3A_x">x</code></td>
<td>
<p>an input matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The half-vectorization of an input matrix consists of the elements in the lower triangle of the matrix, excluding the elements along the diagonal of the matrix, as a column vector.  The column vector is created by traversing the matrix in column-major order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+cvectorize">cvectorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vechs(matrix(1:9, 3, 3))
vechs(matrix(1:12, 3, 4))


</code></pre>

<hr>
<h2 id='vechs2full'>Inverse Strict Half-vectorization</h2><span id='topic+vechs2full'></span>

<h3>Description</h3>

<p>This function returns the symmetric matrix constructed from a strict half-vectorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vechs2full(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vechs2full_+3A_x">x</code></td>
<td>
<p>an input single column or single row matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strict half-vectorization of an input matrix consists of the elements in the lower triangle of the matrix, excluding the elements along the diagonal of the matrix, as a column vector.  The column vector is created by traversing the matrix in column-major order.  The inverse strict half-vectorization takes a vector and reconstructs a symmetric matrix such that <code>vechs2full(vechs(x))</code> is equal to <code>x</code> with zero along the diagonal if <code>x</code> is symmetric.
</p>
<p>Note that very few vectors have the correct number of elements to construct a symmetric matrix.  For example, vectors with 1, 3, 6, 10, and 15 elements can be used to make a symmetric matrix, but none of the other numbers between 1 and 15 can.  An error is thrown if the number of elements in <code>x</code> cannot be used to make a symmetric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vech2full">vech2full</a></code>, <code><a href="#topic+vech">vech</a></code>, <code><a href="#topic+vechs">vechs</a></code>, <code><a href="#topic+rvectorize">rvectorize</a></code>, <code><a href="#topic+cvectorize">cvectorize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vechs2full(1:10)

matrix(1:16, 4, 4)
vechs(matrix(1:16, 4, 4))
vechs2full(vechs(matrix(1:16, 4, 4)))



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
