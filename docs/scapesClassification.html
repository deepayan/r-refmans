<!DOCTYPE html><html><head><title>Help for package scapesClassification</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scapesClassification}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anchor.cell'><p>Cell numbers to class vector</p></a></li>
<li><a href='#anchor.seed'><p>Identify seed cells</p></a></li>
<li><a href='#anchor.svo'><p>Anchor cells from spatial vector objects</p></a></li>
<li><a href='#attTbl'><p>Attribute table</p></a></li>
<li><a href='#classify.all'><p>Classify All Unclassified Cells</p></a></li>
<li><a href='#cond.4.all'><p>Test conditions for all cells</p></a></li>
<li><a href='#cond.4.nofn'><p>Test conditions for neighbors and neighbors of neighbors</p></a></li>
<li><a href='#cond.parse'><p>Parse conditions</p></a></li>
<li><a href='#cond.reclass'><p>Test conditions and reclassify</p></a></li>
<li><a href='#conditions'><p>scapesClassification conditions</p></a></li>
<li><a href='#cv.2.rast'><p>Class vector to raster</p></a></li>
<li><a href='#ngb8'><p>Eight neighbors</p></a></li>
<li><a href='#ngbList'><p>List of neighborhoods</p></a></li>
<li><a href='#obj.border'><p>Borders of raster objects</p></a></li>
<li><a href='#obj.nbs'><p>Shared borders of raster objects</p></a></li>
<li><a href='#peak.cell'><p>Identify local maxima or minima</p></a></li>
<li><a href='#pi.add'><p>Position index addition</p></a></li>
<li><a href='#pi.sgm'><p>Position index segmentation</p></a></li>
<li><a href='#reclass.nbs'><p>Reclassify neighbors</p></a></li>
<li><a href='#rel.pi'><p>Relative position index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>User-Defined Classification of Raster Surfaces</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Series of algorithms to translate  users' mental models of seascapes, 
  landscapes and, more generally, of geographic features into computer representations 
  (classifications). Spaces and geographic objects are classified with user-defined 
  rules taking into account spatial data as well as spatial relationships among 
  different classes and objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gifski, knitr, leafem, leaflet, leafpop, mapview, raster,
spelling, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra, methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ghTaranto/scapesClassification">https://github.com/ghTaranto/scapesClassification</a>,
<a href="https://ghtaranto.github.io/scapesClassification/">https://ghtaranto.github.io/scapesClassification/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ghTaranto/scapesClassification/issues">https://github.com/ghTaranto/scapesClassification/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-15 15:24:07 UTC; VideoLab</td>
</tr>
<tr>
<td>Author:</td>
<td>Gerald H. Taranto <a href="https://orcid.org/0000-0002-7968-1982"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gerald H. Taranto &lt;gh.taranto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-16 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anchor.cell'>Cell numbers to class vector</h2><span id='topic+anchor.cell'></span>

<h3>Description</h3>

<p>Converts a vector of cell numbers into a class vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor.cell(
  attTbl,
  r,
  anchor,
  class,
  classVector = NULL,
  class2cell = TRUE,
  class2nbs = TRUE,
  overwrite_class = FALSE,
  plot = FALSE,
  writeRaster = NULL,
  overWrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchor.cell_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>) used to compute the <code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_anchor">anchor</code></td>
<td>
<p>integer vector of raster cell numbers.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_class">class</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, if provided, it defines the cells in the
attribute table that have already been classified and that have to be
ignored by the function (unless the argument <code>overwrite_class =
  TRUE</code>).</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_class2cell">class2cell</code></td>
<td>
<p>logic, attribute the classification number to the cells of
the argument <code>anchor</code>. If there is a <code>classVector</code> input, the
classification number is only assigned to <code>classVector</code> NA-cells.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_class2nbs">class2nbs</code></td>
<td>
<p>logic, attribute the classification number to cells adjacent
to the ones of the argument <code>anchor</code>. If there is a <code>classVector</code>
input, the classification number is only assigned to <code>classVector</code>
NA-cells.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_overwrite_class">overwrite_class</code></td>
<td>
<p>logic, if there is a <code>classVector</code> input,
reclassify cells that were already classified and that meet the function
conditions.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_plot">plot</code></td>
<td>
<p>logic, plot the class vector output.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_writeraster">writeRaster</code></td>
<td>
<p>filename, if a raster name is provided, save the class
vector in a raster file.</p>
</td></tr>
<tr><td><code id="anchor.cell_+3A_overwrite">overWrite</code></td>
<td>
<p>logic, if the raster names already exist, the existing file
is overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a vector of cell numbers into a class vector. If there is a
<code>classVector</code> input, then the class vector is updated assigning a
classification number to all cells that meet the function conditions.
</p>


<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. If there is no <code>classVector</code> input, the function returns
a new class vector. See <code><a href="#topic+conditions">conditions</a></code> for more details about
class vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+anchor.svo">anchor.svo()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
################################################################################
# LOAD LIBRARIES AND DATA
library(scapesClassification)
library(terra)

# CELL NUMBERS OF A DUMMY RASTER (7X7)
r_cn &lt;- terra::rast(matrix(1:49, nrow = 7, byrow = TRUE), extent=c(0,1,0,1))

# COMPUTE ATTRIBUTE TABLE AND LIST OF NEIGHBORHOODS
at  &lt;- attTbl(r_cn, "dummy_var")
nbs &lt;- ngbList(r_cn)
################################################################################

################################################################################
# ANCHOR.CELL
################################################################################
cv1  &lt;- anchor.cell(attTbl = at, r = r_cn, anchor = 1:7, class  = 10,
                    class2cell = TRUE, class2nbs  = FALSE)

cv2 &lt;- anchor.cell(attTbl = at, r = r_cn, anchor = 1:7, class  = 10,
                   class2cell = FALSE, class2nbs  = TRUE)

cv3 &lt;- anchor.cell(attTbl = at, r = r_cn, anchor = 1:7, class  = 10,
                   class2cell = TRUE, class2nbs  = TRUE)

# Convert class vectors to rasters
r_cv1 &lt;- cv.2.rast(r = r_cn, index = at$Cell, classVector = cv1)
r_cv2 &lt;- cv.2.rast(r = r_cn, index = at$Cell, classVector = cv2)
r_cv3 &lt;- cv.2.rast(r = r_cn, index = at$Cell, classVector = cv3)
################################################################################

################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(2,2))
m = c(1, 3.5, 2.5, 3.5)

# 1)
plot(r_cv1,type="classes",axes=FALSE,legend=FALSE,asp=NA,colNA="#818792",col="#78b2c4",mar=m)
text(r_cn)
mtext(side=3, line=1, adj=0, cex=1, font=2, "ANCHOR.CELL")
mtext(side=3, line=0, adj=0, cex=0.9, "anchor cells '1:7'")
mtext(side=1, line=0, cex=0.9, adj=0, "class2cell = TRUE; class2nbs = FALSE")
legend("bottomright", ncol = 1, bg = "white", fill = c("#78b2c4", "#818792"),
       legend = c("Classified cells","Unclassified cells"))

# 2)
plot(r_cv2,type="classes",axes=FALSE,legend=FALSE,asp=NA,colNA="#818792",col="#78b2c4",mar=m)
text(r_cn)
mtext(side=3, line=1, adj=0, cex=1, font=2, "ANCHOR.CELL")
mtext(side=3, line=0, adj=0, cex=0.9, "anchor cells '1:7'")
mtext(side=1, line=0, cex=0.9, adj=0, "class2cell = FALSE; class2nbs = TRUE")
legend("bottomright", ncol = 1, bg = "white", fill = c("#78b2c4", "#818792"),
       legend = c("Classified cells","Unclassified cells"))

# 3)
plot(r_cv3,type="classes",axes=FALSE,legend=FALSE,asp=NA,colNA="#818792",col="#78b2c4",mar=m)
text(r_cn)
mtext(side=3, line=1, adj=0, cex=1, font=2, "ANCHOR.CELL")
mtext(side=3, line=0, adj=0, cex=0.9, "anchor cells '1:7'")
mtext(side=1, line=0, cex=0.9, adj=0, "class2cell = TRUE; class2nbs = TRUE")
legend("bottomright", ncol = 1, bg = "white", fill = c("#78b2c4", "#818792"),
       legend = c("Classified cells","Unclassified cells"))
par(oldpar)
</code></pre>

<hr>
<h2 id='anchor.seed'>Identify seed cells</h2><span id='topic+anchor.seed'></span>

<h3>Description</h3>

<p>Returns a vector of cell numbers at the locations of seed cells and growth
buffers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor.seed(
  attTbl,
  ngbList,
  rNumb = FALSE,
  class = NULL,
  cond.filter = NULL,
  cond.seed,
  cond.growth = NULL,
  lag.growth = Inf,
  cond.isol = NULL,
  lag.isol = 1,
  sort.col = NULL,
  sort.seed = "max",
  saveRDS = NULL,
  overWrite = FALSE,
  isol.buff = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchor.seed_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_class">class</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions. If <code>NULL</code>, a new class number is
assigned every time a new seed cell is identified. Growth buffers have the
same classification number as the seed cell to which they refer.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_cond.filter">cond.filter</code></td>
<td>
<p>character string, defines for what cells the arguments
<code>cond.seed</code>, <code>cond.growth</code> and <code>cond.isol</code> have to be
evaluated. It can be <code>NULL</code>. Absolute conditions can be used (see
<code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_cond.seed">cond.seed</code></td>
<td>
<p>character string, the conditions to identify seed cells.
Absolute conditions can be used (see <code><a href="#topic+conditions">conditions</a></code>). It cannot
be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_cond.growth">cond.growth</code></td>
<td>
<p>character string, the conditions to define a growth buffer
around seed cells. It can be <code>NULL</code>. Absolute and focal cell
conditions can be used (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_lag.growth">lag.growth</code></td>
<td>
<p>0 or Inf, defines the evaluation lag of <em>focal cell
conditions</em> in <code>cond.growth</code>.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_cond.isol">cond.isol</code></td>
<td>
<p>character string, the conditions to define an isolation
buffer around seed cells and growth buffers. It can be <code>NULL</code>.
Absolute and focal cell conditions can be used (see
<code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_lag.isol">lag.isol</code></td>
<td>
<p>0 or Inf, defines the evaluation lag of <em>focal cell
conditions</em> in <code>cond.isol</code>.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_sort.col">sort.col</code></td>
<td>
<p>character, the column name in the <code>attTbl</code> on which the
<code>sort.seed</code> is based on. It determines in what order seed buffers are
computed.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_sort.seed">sort.seed</code></td>
<td>
<p>character, the order seed buffers are computed is based on
the value seed cells have in the column of attribute table column named
<code>sort.col</code>. If <code>sort.seed="max"</code>, buffers are computed from the
seed cell having the maximum value to the seed cell having the minimum
value. If <code>sort.seed="min"</code>, buffers are computed in the opposite
order.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_saverds">saveRDS</code></td>
<td>
<p>filename, if a file name is provided save the class vector as
an RDS file.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_overwrite">overWrite</code></td>
<td>
<p>logic, if the RDS names already exist, existing files are
overwritten.</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_isol.buff">isol.buff</code></td>
<td>
<p>logic, return the isolation buffer (class = -999).</p>
</td></tr>
<tr><td><code id="anchor.seed_+3A_silent">silent</code></td>
<td>
<p>logic, progress is not printed on the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements an algorithm to identify seed cells, growth
buffers and isolation buffers.<br />
</p>
<p><strong>Condition arguments</strong>
</p>
<p>The function takes as inputs four sets of conditions with
<code>cond.growth</code> and <code>cond.isol</code> taking into account class
contiguity and continuity (see <code><a href="#topic+conditions">conditions</a></code>):
</p>

<ol>
<li> <p><strong><code>cond.filter</code></strong>, the conditions to define what cells have to be
evaluated by the function.
</p>
</li>
<li> <p><strong><code>cond.seed</code></strong>, the conditions to identify, at each iteration, the
seed cell. The seed cell is the cell around which growth and isolation
conditions are applied.
</p>
</li>
<li> <p><strong><code>cond.growth</code></strong>, the conditions to define a buffer around the
seed cell.
</p>
</li>
<li> <p><strong><code>cond.isol</code></strong>, the conditions to isolate one seed cell (and its
growth buffer) from another.<br />
</p>
</li></ol>

<p><strong>Iterations</strong>
</p>
<p>The argument <code>cond.filter</code> defines the set of cells to be considered
by the function.
</p>

<ol>
<li><p> A seed cell is identified based on <code>cond.seed</code> and receives a
classification number as specified by the argument <code>class</code>. If
<code>class=NULL</code>, then a new class is assigned to every new seed cell.
</p>
</li>
<li><p> Cells connected with the seed cell meeting the conditions of
<code>cond.growth</code> are assigned to the same class of the seed cell (growth
buffer). The rule evaluation take into account class continuity (see
<code><a href="#topic+conditions">conditions</a></code>).
</p>
</li>
<li><p> Cells connected with the seed cell (or with its growth buffer) meeting
the conditions of <code>cond.isol</code> are assigned to the isolation buffer
(<code>class = -999</code>). The rule evaluation take into account class
continuity (see <code><a href="#topic+conditions">conditions</a></code>).
</p>
</li>
<li><p> A new seed cell is identified based on <code>cond.seed</code> which is now
only evaluated for cells that were not identified as seed, growth or
isolation cells in previous iterations.
</p>
</li>
<li><p> A new iteration starts. Seed, growth and isolation cells identified in
previous iteration are ignored in successive iterations.
</p>
</li>
<li><p> The function stops when it cannot identify any new seed cell.<br />
</p>
</li></ol>

<p><strong>Relative focal cell conditions and evaluation lag</strong>
</p>

<ul>
<li><p> The arguments <code>lag.growth</code> and <code>lag.isol</code> control the
evaluation lag of <em>relative focal cell conditions</em> (see
<code><a href="#topic+conditions">conditions</a></code>).
</p>
</li>
<li><p> When <code>lag.*</code> are set to <code>0</code>, <em>relative focal cell conditions</em>
have a standard behavior and compare the values of the <code>test cells</code>
against the value of the <code>focal cell</code>.
</p>
</li>
<li><p> When <code>lag.*</code> are set to <code>Inf</code>, <em>relative focal cell conditions</em>
compare the values of the <code>test cells</code> against the value of the
<code>seed cell</code> identified at the start of the iteration.
</p>
</li></ul>



<h3>Value</h3>

<p>Class vector. See <code><a href="#topic+conditions">conditions</a></code> for more details about
class vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
############################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

############################################################################
# EXAMPLE PLOTS
############################################################################
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4.5, 0.5, 2, 3.2)

# 1a. Do not show isol.buff
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var&lt;dummy_var[] &amp; dummy_var&gt;2",
                  cond.isol = "dummy_var&lt;dummy_var[]")

plot(cv.2.rast(r,classVector=as), type="classes", mar=m, col=c("#00A600", "#E6E600"),
     axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "1a. Do not show 'isol.buff'")
mtext(side=1, line=0, cex=1, font=2, adj=1, "cond.filter:")
mtext(side=1, line=1, cex=1, font=2, adj=1, "cond.seed:")
mtext(side=1, line=2, cex=1, font=2, adj=1, "cond.growth:")
mtext(side=1, line=3, cex=1, font=2, adj=1, "cond.isol:")
text(xFromCell(r,c(20,43)),yFromCell(r,c(20,43))-0.05,"SEED",col="red",cex=0.80)

# 1b. Show isol.buff
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var&lt;dummy_var[] &amp; dummy_var&gt;2",
                  cond.isol = "dummy_var&lt;dummy_var[]", isol.buff = TRUE)

plot(cv.2.rast(r,classVector=as), type="classes", col=c("#00000040", "#00A600", "#E6E600"),
     mar=m, axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "1b. Show 'isol.buff' (class=-999)")
mtext(side=1, line=0, cex=1, adj=0, "dummy_var &gt; 1")
mtext(side=1, line=1, cex=1, adj=0, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=1, adj=0, "dummy_var&lt;dummy_var[] &amp; dummy_var&gt;2")
mtext(side=1, line=3, cex=1, adj=0, "dummy_var&lt;dummy_var[]")
text(xFromCell(r,c(20,43)),yFromCell(r,c(20,43))-0.05,"SEED",col="red",cex=0.80)

# 2a. Lag.growth = Inf
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                 cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var&lt;dummy_var[]", lag.growth = Inf)

plot(cv.2.rast(r,classVector=as), type="classes", mar=m, col=c("#00A600"),
     axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "2a. Lag.growth* = Inf")
mtext(side=1, line=0, cex=1, font=2, adj=1, "cond.filter:")
mtext(side=1, line=1, cex=1, font=2, adj=1, "cond.seed:")
mtext(side=1, line=2, cex=1, font=2, adj=1, "cond.growth*:")
mtext(side=1, line=3, cex=1, font=2, adj=1, "cond.isol:")
text(xFromCell(r,c(20)),yFromCell(r,c(20))-0.05,"SEED",col="red",cex=0.80)

# 2b. Lag.growth = 0
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var&lt;dummy_var[]", lag.growth = 0)

plot(cv.2.rast(r,classVector=as), type="classes", mar=m, col=c("#00A600", "#E6E600"),
     axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "2b. Lag.growth* = 0")
mtext(side=1, line=0, cex=1, adj=0, "dummy_var &gt; 1")
mtext(side=1, line=1, cex=1, adj=0, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=1, adj=0, "dummy_var &lt; dummy_var[]")
mtext(side=1, line=3, cex=1, adj=0, "NULL")
text(xFromCell(r,c(20,43)),yFromCell(r,c(20,43))-0.05,"SEED",col="red",cex=0.80)

# 3a. Without sorting
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var &gt;= 5",
                  cond.isol = "dummy_var&lt;dummy_var[]", isol.buff = TRUE)

seeds &lt;- which(!is.na(as) &amp; as !=-999)
cc    &lt;- c("#00000040", terrain.colors(8)[8:1])
plot(cv.2.rast(r,classVector=as), type="classes", mar=m, col=cc,
     axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "3a. Without sorting")
mtext(side=1, line=0, cex=1, font=2, adj=1, "cond.filter:")
mtext(side=1, line=1, cex=1, font=2, adj=1, "cond.seed:")
mtext(side=1, line=2, cex=1, font=2, adj=1, "cond.growth:")
mtext(side=1, line=3, cex=1, font=2, adj=1, "cond.isol:")
text(xFromCell(r,seeds),yFromCell(r,seeds)-0.05,"SEED",col="red",cex=0.80)

# 3b. Sort buffer evaluation based on 'dummy_var' values
as &lt;- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var &gt; 1", cond.seed = "dummy_var &gt;= 5",
                  cond.isol = "dummy_var&lt;dummy_var[]", isol.buff = TRUE,
                  sort.col = "dummy_var", sort.seed = "max")

seeds &lt;- which(!is.na(as) &amp; as !=-999)
plot(cv.2.rast(r,classVector=as), type="classes",col=c("#00000040", "#00A600", "#E6E600"),
     mar=m, axes=FALSE, plg=list(x=1, y=1, cex=.80, title="Classes"))
text(r); lines(r)
mtext(side=3, line=0, cex=1, font=2, adj=0, "3b. Sort.col='dummy_var'; Sort.seed='max'")
mtext(side=1, line=0, cex=1, adj=0, "dummy_var &gt; 1")
mtext(side=1, line=1, cex=1, adj=0, "dummy_var &gt;= 5")
mtext(side=1, line=2, cex=1, adj=0, "NULL")
mtext(side=1, line=3, cex=1, adj=0, "dummy_var &lt; dummy_var[]; isol.buff = -999")
text(xFromCell(r,seeds),yFromCell(r,seeds)-0.05,"SEED",col="red",cex=0.80)
par(oldpar)
</code></pre>

<hr>
<h2 id='anchor.svo'>Anchor cells from spatial vector objects</h2><span id='topic+anchor.svo'></span>

<h3>Description</h3>

<p>Returns a vector of raster cell numbers extracted at the locations of a
spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor.svo(
  r,
  dsn,
  only_NAs = FALSE,
  fill_NAs = FALSE,
  plot = FALSE,
  saveRDS = NULL,
  writeRaster = NULL,
  overWrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anchor.svo_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>).</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_dsn">dsn</code></td>
<td>
<p>data source name (filename) or an <code>sf</code>, a <code>Spatial</code> or a
<code>SpatVector</code> object.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_only_nas">only_NAs</code></td>
<td>
<p>logic, cell numbers extracted only for incomplete cases at
the locations of a spatial object. Incomplete cases are cells having an
NA-value in one or more layers of the raster object.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_fill_nas">fill_NAs</code></td>
<td>
<p>logic, cell numbers extracted at the locations of a spatial
object <em>and</em> at contiguous locations that are incomplete cases.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_plot">plot</code></td>
<td>
<p>logic, plot anchor cells.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_saverds">saveRDS</code></td>
<td>
<p>filename, if a file name is provided save the anchor cell
vector as an RDS file.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_writeraster">writeRaster</code></td>
<td>
<p>filename, if a raster name is provided save the anchor
cell vector as a raster file.</p>
</td></tr>
<tr><td><code id="anchor.svo_+3A_overwrite">overWrite</code></td>
<td>
<p>logic, if RDS and raster names already exist, existing files
are overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the arguments <code>only_NA</code> and <code>fill_NAs</code> are FALSE the
numeric output is equivalent to the output of the function
<code>terra::extract(r, dsn, cells = TRUE)[["cell"]]</code>.
</p>


<h3>Value</h3>

<p>Numeric vector of raster cell numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
################################################################################
# LOAD LIBRARIES AND DATA
library(scapesClassification)
library(terra)

# CELL NUMBERS OF A DUMMY RASTER (7X7)
r_cn &lt;- terra::rast(matrix(1:49, nrow = 7, byrow = TRUE), extent=c(0,1,0,1))

# SET SOME NA-VALUE
r_cn[c(9, 10, 11, 17, 18)] &lt;- NA

# BULD A DUMMY POLYGON
pol &lt;- rbind(c(0,0.95), c(0.28,1), c(0.24, 0.72), c(0.05,0.72), c(0,0.95))
pol &lt;- terra::vect(pol, type="polygons")
################################################################################

################################################################################
# ANCHOR.SVO
################################################################################
ac1 &lt;- anchor.svo(r_cn, pol, only_NAs = FALSE, fill_NAs = FALSE)
ac2 &lt;- anchor.svo(r_cn, pol, only_NAs = TRUE,  fill_NAs = FALSE)
ac3 &lt;- anchor.svo(r_cn, pol, only_NAs = FALSE, fill_NAs = TRUE)
ac4 &lt;- anchor.svo(r_cn, pol, only_NAs = TRUE,  fill_NAs = TRUE)

# RASTER CELL NUMBERS 2 RASTER
r1 &lt;- r_cn; r1[] &lt;- NA; r1[ac1] &lt;- 1
r2 &lt;- r_cn; r2[] &lt;- NA; r2[ac2] &lt;- 1
r3 &lt;- r_cn; r3[] &lt;- NA; r3[ac3] &lt;- 1
r4 &lt;- r_cn; r4[] &lt;- NA; r4[ac4] &lt;- 1
################################################################################

################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(2,2))
m = c(1, 3.5, 2.5, 3.5)

# 1)
plot(r1, type="classes", col="#78b2c4", colNA="grey", axes=FALSE, legend=FALSE, asp=NA, mar=m)
plot(pol, add = TRUE, lwd = 2.5, border = "red")
text(r_cn)
mtext(side=3, line=1, cex=0.9, adj=0, "only_NAs = FALSE")
mtext(side=3, line=0, cex=0.9, adj=0, "fill_NAs = FALSE")
ac1 &lt;- paste("ac =", paste0(sort(ac1), collapse = ","))
mtext(side=1, line=0, cex=0.9, adj=0, ac1)
legend("bottomleft", ncol = 1, bg = "white",
       legend = c("Anchor cell (ac)", "Polygon"), fill = c("#78b2c4", "red"))

# 2)
plot(r2, type="classes", col="#78b2c4", colNA="grey", axes=FALSE,legend=FALSE, asp=NA, mar=m)
plot(pol, add = TRUE, lwd = 2.5, border = "red")
text(r_cn)
mtext(side=3, line=1, cex=0.9, adj=0, "only_NAs = TRUE")
mtext(side=3, line=0, cex=0.9, adj=0, "fill_NAs = FALSE")
ac2 &lt;- paste("ac =", paste0(sort(ac2), collapse = ","))
mtext(side=1, line=0, cex=0.9, adj=0, ac2)
legend("bottomleft", ncol = 1, bg = "white",
       legend = c("Anchor cell (ac)", "Polygon"), fill = c("#78b2c4", "red"))

# 3)
plot(r3, type="classes", col="#78b2c4", colNA="grey", axes=FALSE, legend=FALSE, asp=NA, mar=m)
plot(pol, add = TRUE, lwd = 2.5, border = "red")
text(r_cn)
mtext(side=3, line=1, cex=0.9, adj=0, "only_NAs = FALSE")
mtext(side=3, line=0, cex=0.9, adj=0, "fill_NAs = TRUE")
ac3 &lt;- paste("ac =", paste0(sort(ac3), collapse = ","))
mtext(side=1, line=0, cex=0.9, adj=0, ac3)
legend("bottomleft", ncol = 1, bg = "white",
       legend = c("Anchor cell (ac)", "Polygon"), fill = c("#78b2c4", "red"))

# 4)
plot(r4, type="classes", col="#78b2c4", colNA="grey", axes=FALSE, legend=FALSE, asp=NA, mar=m)
plot(pol, add = TRUE, lwd = 2.5, border = "red")
text(r_cn)
mtext(side=3, line=1, cex=0.9, adj=0, "only_NAs = TRUE")
mtext(side=3, line=0, cex=0.9, adj=0, "fill_NAs = TRUE")
ac4 &lt;- paste("ac =", paste0(sort(ac4), collapse = ","))
mtext(side=1, line=0, cex=0.9, adj=0, ac4)
legend("bottomleft", ncol = 1, bg = "white",
       legend = c("Anchor cell (ac)", "Polygon"), fill = c("#78b2c4", "red"))
par(oldpar)
</code></pre>

<hr>
<h2 id='attTbl'>Attribute table</h2><span id='topic+attTbl'></span>

<h3>Description</h3>

<p>Converts a single or a multi-layer raster into an attribute table
(<code>data.frame</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attTbl(r, var_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attTbl_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>).</p>
</td></tr>
<tr><td><code id="attTbl_+3A_var_names">var_names</code></td>
<td>
<p>character vector, raster layers' names in the attribute
table. If <code>NULL</code>, then the original layers' names are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attribute tables come with a column named <strong><code>"Cell"</code></strong> which
stores raster cell numbers and associate each row of the attribute table
with a cell of the raster object. The remaining columns of the attribute
table store the data contained in the raster layers. Note that only raster
cells having no missing value in no layer (<strong>complete cases</strong>) are included
in the attribute table.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Note</h3>

<p><strong>Attribute table contains only complete cases</strong>, i.e., raster cells
having a value for every layer of the stack.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scapesClassification)
library(terra)

## CREATE A DUMMY RASTER ##
r &lt;- terra::rast(matrix(c(NA,100,100,NA,100,100,0,0,0),
                        nrow = 3,
                        ncol = 3,
                        byrow = TRUE))

## RASTER CELL NUMBERS ##
rcn &lt;- r; rcn[] &lt;- 1:9

## PLOT DATA AND CELL NUMBERS ##
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4, 1, 4, 1)

plot(r, col="grey90", colNA="red3", mar=m, asp = NA, axes=FALSE, legend=FALSE)
text(r)
lines(r)
mtext(side=3, line=0.2, adj=0, cex=1.5, font=2, "Dummy_var")
legend("bottomright", ncol=1, bg="white", fill=c("red3"),
       legend = c("NA cells (1 and 4)"))

plot(rcn, col="grey90", mar=m, asp=NA, axes=FALSE, legend=FALSE)
text(rcn)
lines(rcn)
mtext(side=3, line=0.2, adj=0, cex=1.5, font=2, "Cell numbers")
par(oldpar)

## VISUALIZE ATTRIBUTE TABLE ##

at &lt;- attTbl(r, var_names = c("dummy_var"))
at

# Note that cells 1 and 4 have missing values and therefore are not included in the table
any(at$Cell %in% c(1,4))
</code></pre>

<hr>
<h2 id='classify.all'>Classify All Unclassified Cells</h2><span id='topic+classify.all'></span>

<h3>Description</h3>

<p>Classify all cells in <code>classVector</code> that have not yet been classified
based on contiguity and continuity conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify.all(attTbl, ngbList, rNumb = FALSE, classVector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify.all_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="classify.all_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="classify.all_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="classify.all_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, defines the cells in the attribute table
that have already been classified. See <code><a href="#topic+conditions">conditions</a></code> for more
information about class vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The neighborhood of unclassified cells is considered. Among
neighbors, the class with the highest number of members is assigned to the
unclassified cell. If two or more classes have the same number of members,
then one of these classes is assigned randomly to the unclassified cell.
The function considers <em>class continuity</em>, thus, even cells that at first
were not contiguous to any class will be classified if continuous with at
least one cell having a class (see <code><a href="#topic+conditions">conditions</a></code>).
</p>


<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. See <code><a href="#topic+conditions">conditions</a></code> for more details about class
vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+conditions">conditions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
############################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

################################################################################
# CLASSIFY.ALL
################################################################################
# compute example class vector
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &lt;= 1", class = 1)
# update example calss vector
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &lt;= 3", class = 2,
                 classVector = cv) # input previous class vector

# classify all unclassified cells
ca &lt;- classify.all(attTbl = at, ngbList = nbs, rNumb = TRUE, classVector = cv)


# Convert class vectors into rasters
r_cv &lt;- cv.2.rast(r, at$Cell, classVector = cv)
r_ca &lt;- cv.2.rast(r, at$Cell,classVector = ca)
################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(3, 1, 5, 1)

# 1)
plot(r_cv, type="classes", axes=FALSE, legend=FALSE, asp=NA, mar=m,
     colNA="#818792", col=c("#78b2c4", "#cfc1af"))
text(r)
mtext(side=3, line=2, adj=0, cex=1, font=2, "COND.4.ALL")
mtext(side=3, line=1, adj=0, cex=0.9, "Step1: 'dummy_var&lt;=1', Class: 1")
mtext(side=3, line=0, adj=0, cex=0.9, "Step2: 'dummy_var&lt;=3', Class: 2")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfc1af", "#818792"),
       legend = c("Class 1", "Class 2", "Unclassified cells"))

# 2)
plot(r_ca, type="classes", axes=FALSE, legend=FALSE, asp=NA,  mar=m,
     colNA="#818792", col=c("#78b2c4", "#cfc1af"))
text(r)
mtext(side=3, line=2, adj=0, cex=1, font=2, "CLASSIFY.ALL")
mtext(side=3, line=1, adj=0, cex=0.9, "Classify all unclassified cells")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfc1af", "#818792"),
       legend = c("Class 1", "Class 2"))
par(oldpar)
</code></pre>

<hr>
<h2 id='cond.4.all'>Test conditions for all cells</h2><span id='topic+cond.4.all'></span>

<h3>Description</h3>

<p>Evaluate conditions for unclassified cells and classify them if conditions
are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.4.all(attTbl, cond, classVector = NULL, class, ovw_class = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.4.all_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="cond.4.all_+3A_cond">cond</code></td>
<td>
<p>character string, the conditions a cell have to meet to be
classified as indicated by the argument <code>class</code>. If there is a
<code>classVector</code> input, the classification number is only assigned to
unclassified cells unless the argument <code>ovw_class = TRUE</code>. See
<code><a href="#topic+conditions">conditions</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cond.4.all_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, if provided, it defines the cells in the
attribute table that have already been classified. See
<code><a href="#topic+conditions">conditions</a></code> for more information about class vectors.</p>
</td></tr>
<tr><td><code id="cond.4.all_+3A_class">class</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions.</p>
</td></tr>
<tr><td><code id="cond.4.all_+3A_ovw_class">ovw_class</code></td>
<td>
<p>logic, if there is a <code>classVector</code> input,
reclassify cells that were already classified and that meet the function
conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The function evaluates the conditions of the
argument <code>conditions</code> for all unclassified cells (i.e.,
<code>classVector</code> NA-cells).
</p>
</li>
<li><p> Cells that meet the function conditions are classified as indicted by
the argument <code>class</code>.
</p>
</li>
<li> <p><em>Absolute test cell conditions</em> can be used (see
<code><a href="#topic+conditions">conditions</a></code>).</p>
</li></ul>



<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. If there is no <code>classVector</code> input, the function returns
a new class vector. See <code><a href="#topic+conditions">conditions</a></code> for more details about
class vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+cond.4.nofn">cond.4.nofn()</a></code>, <code><a href="#topic+cond.reclass">cond.reclass()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
################################################################################
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

################################################################################
# COND.4.ALL
################################################################################
# compute new class vector
# conditions: "dummy_var == 1"
cv1 &lt;- cond.4.all(attTbl = at, cond = "dummy_var &lt;= 1", class = 1)

unique(cv1) # one class (class 1)

# update class vector `cv1`
# conditions: "dummy_var &lt;= 3"
cv2   &lt;- cond.4.all(attTbl = at, cond = "dummy_var &lt;= 3", class = 2,
                    classVector = cv1) # input previous class vector

unique(cv2) # two classes (class 1 and class 2)

# convert class vector 2 raster
r_cv1 &lt;- cv.2.rast(r, at$Cell, classVector = cv1)
r_cv2 &lt;- cv.2.rast(r, at$Cell, classVector = cv2)

################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4.5, 0.5, 2, 3.2)

# 1.
r_cv1[which(is.na(values(r_cv1)))] &lt;- 10
plot(r_cv1, type="classes", mar=m, col=c("#78b2c4","#818792"), axes=FALSE,
     plg=list(x=1, y=1, cex=.80, title="Classes",legend=c("1", "NA")))
text(r); lines(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "1. COND.4.ALL")
mtext(side=3, line=0, adj=0, cex=0.9, "New class vector")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &lt;= 1'")
mtext(side=1, line=1, cex=0.9, adj=0, "Class: 1")

# 2.
r_cv2[which(is.na(values(r_cv2)))] &lt;- 10
plot(r_cv2, type="classes", mar=m, col=c("#78b2c4","#cfad89","#818792"), axes=FALSE,
     plg=list(x=1, y=1, cex=.80, title="Classes",legend=c("1", "2", "NA")))
text(r); lines(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "2. COND.4.ALL")
mtext(side=3, line=0, adj=0, cex=0.9, "Update class vector (class 1 not overwritten)")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &lt;= 3'")
mtext(side=1, line=1, cex=0.9, adj=0, "Class: 2")
par(oldpar)
</code></pre>

<hr>
<h2 id='cond.4.nofn'>Test conditions for neighbors and neighbors of neighbors</h2><span id='topic+cond.4.nofn'></span>

<h3>Description</h3>

<p>Evaluate conditions for cells neighboring specific classes and classify them
if conditions are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.4.nofn(
  attTbl,
  ngbList,
  rNumb = FALSE,
  classVector,
  class,
  nbs_of,
  cond,
  min.bord = NULL,
  max.iter = +Inf,
  peval = 1,
  directional = FALSE,
  ovw_class = FALSE,
  hgrowth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.4.nofn_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, defines the cells in the attribute table
that have already been classified. See <code><a href="#topic+conditions">conditions</a></code> for more
information about class vectors.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_class">class</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_nbs_of">nbs_of</code></td>
<td>
<p>numeric or numeric vector, indicates the class(es) of focal and
anchor cells. Conditions are only evaluated at positions adjacent to anchor
and focal cells. If the classification number assigned with the argument
<code>class</code> is also included in the argument <code>nbs_of</code>, the function
takes into account <em>class continuity</em> (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_cond">cond</code></td>
<td>
<p>character string, the conditions a cell have to meet to be
classified as indicated by the argument <code>class</code>. The classification
number is only assigned to unclassified cells unless the argument
<code>ovw_class = TRUE</code>. See <code><a href="#topic+conditions">conditions</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_min.bord">min.bord</code></td>
<td>
<p>numeric value between 0 and 1. A test cell is classified if
conditions are true and if among its bordering cells a percentage equal
or greater than <code>min.bord</code> belong to one of the classes of
<code>nbs_of</code>. Percentages are computed counting only valid neighbors
(i.e., neighbors with complete cases).</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_max.iter">max.iter</code></td>
<td>
<p>integer, the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_peval">peval</code></td>
<td>
<p>numeric value between 0 and 1. If <em>absolute or relative
neighborhood conditions</em> are considered, test cells are classified if the
number of positive evaluations is equal or greater than the percentage
specified by the argument <code>peval</code> (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_directional">directional</code></td>
<td>
<p>logic, absolute or relative neighborhood conditions are
tested using the <em>directional neighborhood</em> (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_ovw_class">ovw_class</code></td>
<td>
<p>logic, reclassify cells that were already classified and
that meet the function conditions.</p>
</td></tr>
<tr><td><code id="cond.4.nofn_+3A_hgrowth">hgrowth</code></td>
<td>
<p>logic, if true the classes in <code>nbs_of</code> are treated as
discrete raster objects and the argument <code>class</code> is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The function evaluates the conditions of the
argument <code>cond</code> for all unclassified cells in the neighborhood of
focal and anchor cells (specified by the argument <code>nbs_of</code>).
Unclassified cells are NA-cells in <code>classVector</code>.
</p>
</li>
<li><p> Cells that meet the function conditions are classified as indicted by
the argument <code>class</code>.
</p>
</li>
<li> <p><em>Class continuity</em> is considered if the classification number
assigned with the argument <code>class</code> is also included in the argument
<code>nbs_of</code>. This means that, at each iteration, newly classified cells
become focal cells and conditions are tested in their neighborhood.
</p>
</li>
<li><p> All types of conditions can be used. The condition string can only
include one neighborhood condition (<code>'{}'</code>) (see
<code><a href="#topic+conditions">conditions</a></code>).</p>
</li></ul>

<p><strong>Homogeneous growth (<code>hgrowth</code>)</strong>
</p>
<p>If the argument <code>hgrowth</code> is true the classes in <code>nbs_of</code> are
treated as discrete raster objects and the argument <code>class</code> is
ignored. Iterations proceed as follow:
</p>

<ul>
<li><p> cells contiguous to the first element of <code>nbs_of</code> are evaluated
against the classification rules and, when evaluations are true, cells are
assigned to that element;
</p>
</li>
<li><p> the same process is repeated for cells contiguous to the second element
of <code>nbs_of</code>, then for cells contiguous to the third element and so on
until the last element of <code>nbs_of</code>;
</p>
</li>
<li><p> once cells contiguous to the last element of <code>nbs_of</code> are evaluated
the iteration is complete;
</p>
</li>
<li><p> cells classified in one iteration become focal cells in the next
iteration;
</p>
</li>
<li><p> a new iteration starts as long as new cells were classified in the
previous iteration and if the iteration number &lt; <code>max.iter</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. See <code><a href="#topic+conditions">conditions</a></code> for more details about class
vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

# SET A DUMMY FOCAL CELL (CELL #25)
at$cv[at$Cell == 25] &lt;- 0

# SET FIGURE MARGINS
m &lt;- c(2, 8, 2.5, 8)

######################################################################################
# ABSOLUTE TEST CELL CONDITION - NO CLASS CONTINUITY
######################################################################################

# conditions: "dummy_var &gt;= 3"
cv1 &lt;- cond.4.nofn(attTbl = at, ngbList = nbs,

                   # CLASS VECTOR - INPUT
                   classVector = at$cv,

                   # CLASSIFICATION NUMBER
                   class = 1,

                   # FOCAL CELL CLASS
                   nbs_of = 0,

                   # ABSOLUTE TEST CELL CONDITION
                   cond = "dummy_var &gt;= 3")

# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv1 &lt;- cv.2.rast(r, at$Cell,classVector = cv1, plot = FALSE)

# PLOT
plot(r_cv1, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "CONDITION: ABSOLUTE TEST CELL")
mtext(side=3, line=0, adj=0, cex=1, "Class continuity: NO")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &gt;= 3'")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfad89", "#818792"),
       legend = c("Focal cell", "Classified cells", "Unclassified cells"))

######################################################################################
# ABSOLUTE TEST CELL CONDITION - WITH CLASS CONTINUITY
######################################################################################

# conditions: "dummy_var &gt;= 3"
cv2 &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = at$cv,

                  # CLASSIFICATION NUMBER
                   class = 1,

                   nbs_of = c(0,  # FOCAL CELL CLASS
                              1), # CLASSIFICATION NUMBER

                   # ABSOLUTE CONDITION
                   cond = "dummy_var &gt;= 3")

# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv2 &lt;- cv.2.rast(r, at$Cell,classVector = cv2, plot = FALSE)

# PLOT
plot(r_cv2, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "CONDITION: ABSOLUTE TEST CELL")
mtext(side=3, line=0, adj=0, cex=1, "Class continuity: YES")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &gt;= 3'")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfad89", "#818792"),
       legend = c("Focal cell", "Classified cells", "Unclassified cells"))

######################################################################################
# ABSOLUTE NEIGHBORHOOD CONDITION
######################################################################################

# conditions: "dummy_var{} &gt;= 3"
cv3 &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = at$cv, nbs_of = c(0,1), class = 1,

                   # ABSOLUTE NEIGHBORHOOD CONDITION
                   cond = "dummy_var{} &gt;= 3",

                   # RULE HAS TO BE TRUE FOR 100% OF THE EVALUATIONS
                   peval = 1)

# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv3 &lt;- cv.2.rast(r, at$Cell,classVector = cv3, plot = FALSE)

#PLOT
plot(r_cv3, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "CONDITION: ABSOLUTE NEIGHBORHOOD")
mtext(side=3, line=0, adj=0, cex=1, "Class continuity: YES")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var{ } &gt;= 3'")
mtext(side=1, line=0, cex=0.9, adj=1, "('{ }' cell neighborhood)")
mtext(side=1, line=1, cex=0.9, adj=0, "Fn_perc: 1 (100%)")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfad89", "#818792"),
       legend = c("Focal cell", "Classified cells", "Unclassified cells"))

######################################################################################
# RELATIVE NEIGHBORHOOD CONDITION
######################################################################################

# conditions: "dummy_var &gt; dummy_var{}"
cv4 &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = at$cv, nbs_of = c(0,1), class = 1,

                   # RELATIVE NEIGHBORHOOD CONDITION
                   cond = "dummy_var &gt; dummy_var{}",

                   # RULE HAS TO BE TRUE FOR AT LEAST 60% OF THE EVALUATIONS
                   peval = 0.6)


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv4 &lt;- cv.2.rast(r, at$Cell, classVector = cv4, plot = FALSE)

#PLOT
plot(r_cv4, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "CONDITION: RELATIVE NEIGHBORHOOD")
mtext(side=3, line=0, adj=0, cex=1, "Class continuity: YES")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &gt; dummy_var{ }'")
mtext(side=1, line=0, cex=0.9, adj=1, "('{ }' cell neighborhood)")
mtext(side=1, line=1, cex=0.9, adj=0, "Fn_perc: 0.6 (60%)")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfad89", "#818792"),
       legend = c("Focal cell", "Classified cells", "Unclassified cells"))

######################################################################################
# RELATIVE FOCAL CELL CONDITION
######################################################################################

# conditions: "dummy_var &gt; dummy_var[]"
cv5 &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = at$cv, nbs_of = c(0,1), class = 1,

                   # RELATIVE FOCAL CELL CONDITION
                   cond = "dummy_var &gt; dummy_var[]")


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv5 &lt;- cv.2.rast(r, at$Cell,classVector = cv5, plot = FALSE)

#PLOT
plot(r_cv5, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "CONDITION: RELATIVE FOCAL CELL")
mtext(side=3, line=0, adj=0, cex=1, "Class continuity: YES")
mtext(side=1, line=0, cex=0.9, adj=0, "Rule: 'dummy_var &gt; dummy_var[ ]'")
mtext(side=1, line=0, cex=0.9, adj=1, "('[ ]' focal cell)")
legend("bottomright", bg = "white", fill = c("#78b2c4", "#cfad89", "#818792"),
       legend = c("Focal cell", "Classified cells", "Unclassified cells"))

######################################################################################
# HOMOGENEOUS GROWTH
######################################################################################

# Dummy raster objects 1 and 2
ro &lt;- as.numeric(rep(NA, NROW(at)))
ro[which(at$dummy_var == 10)] &lt;- 1
ro[which(at$dummy_var == 8)] &lt;- 2

# Not homogeneous growth
nhg &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = ro,
                   nbs_of = 1, class = 1, # GROWTH ROBJ 1
                   cond = "dummy_var &lt;= dummy_var[] &amp; dummy_var != 1")

nhg &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = nhg, # UPDATE nhg
                   nbs_of = 2, class = 2, # GROWTH ROBJ 2
                   cond = "dummy_var &lt;= dummy_var[] &amp; dummy_var != 1")


# Homogeneous growth
hg &lt;- cond.4.nofn(attTbl = at, ngbList = nbs, classVector = ro,
                  nbs_of = c(1, 2), class = NULL,
                  cond = "dummy_var &lt;= dummy_var[] &amp; dummy_var != 1",
                  hgrowth = TRUE) # HOMOGENEOUS GROWTH

# Convert class vectors into rasters
r_nhg &lt;- cv.2.rast(r, at$Cell,classVector = nhg, plot = FALSE)
r_hg  &lt;- cv.2.rast(r, at$Cell,classVector = hg, plot = FALSE)

# Plots
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(3, 1, 5, 1)

# Original raster objects (for plotting)
r_nhg[at$dummy_var == 10] &lt;- 3
r_nhg[at$dummy_var == 8]  &lt;- 4

r_hg[at$dummy_var == 10] &lt;- 3
r_hg[at$dummy_var == 8]  &lt;- 4
#t
# 1)
plot(r_nhg, type="classes", axes=FALSE, legend=FALSE, asp=NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfc1af", "#1088a0", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "RASTER OBJECTS GROWTH")
mtext(side=3, line=0, adj=0, cex=0.9, "Not homogeneous (hgrowth = FALSE)")
mtext(side=1, line=0, cex=0.9, adj=0, "Growth rule:")
mtext(side=1, line=1, cex=0.9, adj=0, "'dummy_var&lt;=dummy_var[ ] &amp; dummy_var!=1''")
legend("topleft", bg = "white", y.intersp= 1.3,
       fill = c("#1088a0", "#cfc1af", "#78b2c4", "#cfc1af", "#818792"),
       legend = c("RO1", "RO2", "RO1 - growth", "RO2 - growth", "Unclassified cells"))
# 2)
plot(r_hg, type="classes", axes=FALSE, legend=FALSE, asp=NA, mar = m,
     colNA="#818792", col=c("#78b2c4", "#cfc1af", "#1088a0", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "RASTER OBJECTS GROWTH")
mtext(side=3, line=0, adj=0, cex=0.9, "Homogeneous (hgrowth = TRUE)")
mtext(side=1, line=0, cex=0.9, adj=0, "Growth rule:")
mtext(side=1, line=1, cex=0.9, adj=0, "'dummy_var&lt;=dummy_var[ ] &amp; dummy_var!=1''")
legend("topleft", bg = "white", y.intersp= 1.3,
       fill = c("#1088a0", "#cfc1af", "#78b2c4", "#cfc1af", "#818792"),
       legend = c("RO1", "RO2", "RO1 - growth", "RO2 - growth", "Unclassified cells"))
par(oldpar)
</code></pre>

<hr>
<h2 id='cond.parse'>Parse conditions</h2><span id='topic+cond.parse'></span>

<h3>Description</h3>

<p>Parse the condition string so that it can be evaluated by the <code style="white-space: pre;">&#8288;cond.*&#8288;</code>
functions. Intended for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.parse(names_attTbl, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.parse_+3A_names_atttbl">names_attTbl</code></td>
<td>
<p>character vector, the column (i.e. variable) names of the
attribute table returned by the function <code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="cond.parse_+3A_cond">cond</code></td>
<td>
<p>character string, the condition string used by the <code>cond.*</code>
functions to classify raster cells (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a two-element list. The first element contains
the parsed conditions to be evaluated by the <code>cond.*</code> functions. The
second element defines the condition type each variable refers to.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.4.all">cond.4.all()</a></code>, <code><a href="#topic+cond.4.nofn">cond.4.nofn()</a></code>, <code><a href="#topic+anchor.seed">anchor.seed()</a></code>, <code><a href="#topic+cond.reclass">cond.reclass()</a></code>,
<code><a href="#topic+conditions">conditions()</a></code>
</p>

<hr>
<h2 id='cond.reclass'>Test conditions and reclassify</h2><span id='topic+cond.reclass'></span>

<h3>Description</h3>

<p>Evaluate conditions for cells of a class and reclassify them if conditions
are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond.reclass(
  attTbl,
  ngbList = NULL,
  rNumb = FALSE,
  classVector,
  class,
  cond,
  reclass,
  peval = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond.reclass_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>. Only necessary if using an <em>absolute neighborhood
condition</em> (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, defines the cells in the attribute table
that have already been classified. See <code><a href="#topic+conditions">conditions</a></code> for more
information about class vectors.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_class">class</code></td>
<td>
<p>numeric or numeric vector, indicates the class(es) for which
conditions have to be evaluated.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_cond">cond</code></td>
<td>
<p>character string, the conditions a cell have to meet to be
classified as indicated by the argument <code>reclass</code>. See
<code><a href="#topic+conditions">conditions</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_reclass">reclass</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions.</p>
</td></tr>
<tr><td><code id="cond.reclass_+3A_peval">peval</code></td>
<td>
<p>numeric value between 0 and 1. If <em>absolute neighborhood
conditions</em> are considered, test cells are classified if the number of
positive evaluations is equal or greater than the percentage specified by
the argument <code>peval</code> (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The function evaluates the conditions of the
argument <code>cond</code> for all cells in the classes of the
argument <code>class</code>.
</p>
</li>
<li><p> Cells that meet the function conditions are re-classified as indicted
by the argument <code>reclass</code>.
</p>
</li>
<li><p> Absolute test cell and neighborhood conditions can be used. The
condition string can only include one neighborhood condition (<code>'{}'</code>)
(see <code><a href="#topic+conditions">conditions</a></code>).</p>
</li></ul>



<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. See <code><a href="#topic+conditions">conditions</a></code> for more information about class
vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

################################################################################
# RECLASS.NBS
################################################################################

# Compute an example class vector
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &gt; 1", class = 1)

# Reclassify cells
cr &lt;- cond.reclass(attTbl = at, ngbList = nbs,

                   # CLASS VECTOR COMPUTED WITH THE RULE "dummy_var &gt; 1"
                   classVector = cv,

                   # CELLS TO RECLASSIFY HAVE THIS CLASS
                   class = 1,

                   # ABSOLUTE NEIGHBORHOOD CONDITION
                   cond = "dummy_var{} &gt;= 5", peval = 1,

                   # NEW CLASSIFICATION NUMBER
                   reclass = 2)

# Convert class vectors to rasters
r_cv &lt;- cv.2.rast(r, cv)
r_cr &lt;- cv.2.rast(r, cr)

################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(3, 1, 5, 4)

# 1.
r_cv[which(is.na(values(r_cv)))] &lt;- 10
plot(r_cv, type="classes", mar=m, col=c("#78b2c4","#818792"), axes=FALSE,
     plg=list(x=1, y=1, cex=.80, title="Classes",legend=c("1", "NA")))
text(r); lines(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "1. COND.4.ALL")
mtext(side=3, line=0, adj=0, cex=0.9, "New class vector")
mtext(side=1, line=0, cex=1, adj=0, "Class: 1")
mtext(side=1, line=1, cex=1, adj=0, "Rule: 'dummy_var &gt; 1'")

# 2.
r_cr[which(is.na(values(r_cr)))] &lt;- 10
plot(r_cr, type="classes", mar=m, col=c("#78b2c4","#cfad89","#818792"), axes=FALSE,
     plg=list(x=1, y=1, cex=.80, title="Classes",legend=c("1", "reclass", "NA")))
text(r); lines(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "2. COND.RECLASS")
mtext(side=3, line=0, adj=0, cex=0.9, "Reclassify cells meeting conditions")
mtext(side=1, line=0, cex=1, adj=0, "Class: 2")
mtext(side=1, line=1, cex=1, adj=0, "Rule: 'dummy_var{ } &gt;= 5'; peval = 1")
par(oldpar)
</code></pre>

<hr>
<h2 id='conditions'>scapesClassification conditions</h2><span id='topic+conditions'></span>

<h3>Description</h3>

<p>Check for spelling and syntax errors in conditions (<code>cond</code> argument) and
detect the type of conditions being used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditions(names_attTbl, cond, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditions_+3A_names_atttbl">names_attTbl</code></td>
<td>
<p>character vector, the column (i.e. variable) names of the
attribute table returned by the function <code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="conditions_+3A_cond">cond</code></td>
<td>
<p>character string, the condition string used by the <code>cond.*</code>
functions to classify raster cells (see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="conditions_+3A_silent">silent</code></td>
<td>
<p>logic, when true, the function returns only error messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Conditions (alias classification rules)</strong>
</p>

<ul>
<li><p> Classification rules evaluate either to true or false and determine what
raster cells have to be classified.
</p>
</li>
<li><p> Conditions are passed to <code>scapesClassification</code> functions as a
single character string. They can consist of combination of variables names
(as named in the attribute table, see <code><a href="#topic+attTbl">attTbl</a></code>), arithmetic
<code>(+|-|*|/|^|%%|%/%)</code>, relational <code>(&gt;|&lt;|&gt;=|&lt;=|==|!=|%/%)</code> and
logic operators <code>(&amp;||)</code> and base R functions (e.g.,
<code>abs(variable_name)</code>).
</p>
</li>
<li><p> All variables included in an attribute table (see <code><a href="#topic+attTbl">attTbl</a></code>)
can be included in a condition string by name (e.g., var name =
<code>"dummy_var"</code>; condition = <code>"dummy_var &gt; 1"</code>).<br />
</p>
</li></ul>

<p><strong>Class vectors</strong>
</p>

<ul>
<li><p> Class vectors map raster cells to numeric classes.
</p>
</li>
<li><p> The n^th^ element of a class vector stores the class of the raster cell
stored in the n^th^ row of the corresponding attribute table (see
<code><a href="#topic+attTbl">attTbl</a></code>).
</p>
</li>
<li><p> Class vectors can serve also as a function input. As inputs, they provide
information about the groups of cells that have already been classified.
</p>
</li>
<li><p> Every time a class vector is provided as a function input, it is
<em>updated</em> by assigning a numeric class to <em>unclassified cells</em> that meet
function conditions.
</p>
</li>
<li><p> Unclassified cells are represented as NA values.<br />
</p>
</li></ul>

<p><strong>Rule evaluation: Global evaluation</strong>
</p>

<ul>
<li><p> Classification rules are applied to all unclassified raster
cells.
</p>
</li>
<li><p> Function using <em>global evaluation</em>: <code><a href="#topic+cond.4.all">cond.4.all</a></code>.
</p>
</li></ul>

<p><strong>Rule evaluation: Focal evaluation</strong>
</p>

<ul>
<li><p> Classification rules are applied only to raster cells at specific
locations and are based on class (dis)contiguity and class continuity.
</p>
</li>
<li> <p><strong>Class contiguity:</strong> <br /> classification rules are applied only to raster
cells contiguous to focal cells (identified in the <code>cond.*</code> functions
by the argument <code>nbs_of</code>).
</p>
</li>
<li> <p><strong>Class continuity:</strong> <br /> join into the same class cells that respect the
same rules and that are connected to the same focal cells. This means that,
at each iteration, newly classified cells become focal cells and conditions
are tested in their neighborhood.
</p>
</li>
<li><p> Function using <em>focal evaluation</em>: <code><a href="#topic+anchor.seed">anchor.seed</a></code>,
<code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code>, <code><a href="#topic+cond.reclass">cond.reclass</a></code>,
<code><a href="#topic+reclass.nbs">reclass.nbs</a></code> and <code><a href="#topic+classify.all">classify.all</a></code>.<br />
</p>
</li></ul>

<p><strong>Focal evaluation: Definitions</strong>
</p>

<ul>
<li> <p><strong>Cell neighborhood:</strong> a cell with coordinates <code>(x, y)</code> has 8
neighbors with coordinates: <code>(x1, y)</code>,  <code>(x, y1)</code> and
<code>(x1, y1)</code>. Cells on the edge of a raster have less than 8
neighbors. See <code><a href="#topic+ngbList">ngbList</a></code>.
</p>
</li>
<li> <p><strong>Focal cell:</strong> cells whose neighbors are evaluated against the
classification rule(s). In the classification functions <em>focal cells</em> are
identified by the argument <code>nbs_of</code>.
</p>
</li>
<li> <p><strong>Test cell:</strong> the cell in the neighborhood of the focal cell that is
being tested. At turns all cells in the neighborhood of a focal cell are
tested against the classification rule(s).
</p>
</li>
<li> <p><strong>Directional neighborhood:</strong> it consists of the intersection between the
focal and the test cell neighborhoods.<br />
</p>
</li></ul>

<p><strong>Condition type: Absolute conditions</strong>
</p>
<p><strong>1) Absolute test cell condition:</strong> compares cell values against a
threshold value.
</p>

<ul>
<li><p> This type of condition applies to all functions with a <code>conditions</code>
argument.
</p>
</li>
<li><p> In global evaluations all cells meeting absolute conditions receive a
classification number. In focal evaluations all <code>test cells</code> meeting
absolute conditions receive a classification number.
</p>
</li>
<li> <p><em>Examples of valid conditions:</em> <code>"variable_A &gt; 1 &amp; variable_B !=
  0"</code>; <code>"(variable_A^2 &lt; 50 &amp; variable_B == 0) | abs(variable_C) &gt; 50"</code>.<br />
<em>Functions:</em> <code><a href="#topic+anchor.seed">anchor.seed</a></code>, <code><a href="#topic+cond.4.all">cond.4.all</a></code>,
<code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code> and <code><a href="#topic+cond.reclass">cond.reclass</a></code>.<br />
</p>
</li></ul>

<p><strong>2) Absolute neighborhood condition:</strong> compares the values of the
<code>test cell</code> and of its <code>neighborhood</code> against a threshold value.
</p>

<ul>
<li><p> An absolute neighborhood condition is identified by a variable name
followed by curly brackets (e.g., <code>"variable_name{}"</code>).
</p>
</li>
<li><p> A maximum of 9 evaluations are performed for each test cell (the test
cell itself and the cells of its neighborhood are compared against a
threshold value).
</p>
</li>
<li><p> Test cells receive a classification number if the rule is true for at
least as many evaluations as the ones specified by the argument
<code>peval</code>. The argument <code>peval</code> ranges from 0 to 1. When 9
evaluations are performed, <code>peval = 1</code> means that all <code>9</code>
evaluations have to be true; <code>peval = 0.5</code> means that at least
<code>4.5</code> (rounded to <code>5</code>) evaluations have to be true.
</p>
</li>
<li><p> Only one neighborhood rule is allowed for each condition string (e.g., it
is not possible to have a condition string like <code>"variable_A{} &gt; 0 &amp;
  variable_B{} &gt; 1"</code>).
</p>
</li>
<li><p> The function <code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code> can consider a <code>directional
  neighborhood</code> instead of the test cell neighborhood by setting the argument
<code>directional = TRUE</code>.
</p>
</li>
<li> <p><em>Example of valid conditions:</em> <code>"variable_A{} &gt; 1 &amp; abs(variable_B)
  != 0"</code>. <br /> <em>Functions:</em> <code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code> and
<code><a href="#topic+cond.reclass">cond.reclass</a></code>.<br />
</p>
</li></ul>

<p><strong>Condition type: Relative conditions</strong>
</p>
<p><strong>1) Relative focal cell condition:</strong> compares the <code>test cell</code> value
against the <code>focal cell</code> value.
</p>

<ul>
<li><p> A relative focal cell condition is identified by a variable name followed
by square brackets (e.g., <code>"variable_name[]"</code>).
</p>
</li>
<li><p> Rules are defined repeating twice the same variable name, once with
square brackets and once without. Square brackets indicate the focal cell
value. As an example, the rule <code>"dummy_var &lt; dummy_var[]"</code> compares
the value of the the test cell (<code>"dummy_var"</code>) against the value of
the focal cell (<code>"dummy_var[]"</code>).
</p>
</li>
<li><p> Test cells are classified if the rule is true.
</p>
</li>
<li> <p><em>Examples of valid conditions:</em> <code>"variable_A &gt; variable_A[]"</code>;
<code>"(variable_A &gt; variable_A[] &amp; variable_B{} &lt; 10) | variable_C &gt; 1"</code>.
Note that the last example is a combination of absolute and focal cell
conditions. <br /> <em>Functions:</em> <code><a href="#topic+anchor.seed">anchor.seed</a></code> and
<code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code>.
</p>
</li></ul>

<p><strong>2) Relative neighborhood condition:</strong> compares the values of the <code>test
  cell</code> against the values of the <code>test cell neighborhood</code>.
</p>

<ul>
<li><p> A relative neighborhood condition is identified by a variable name
followed by curly brackets (e.g., <code>"variable_name{}"</code>).
</p>
</li>
<li><p> Rules are defined repeating twice the same variable name, once with curly
brackets and once without. Curly brackets indicate the test cell
neighborhood. As an example, the rule <code>'dummy_var &lt; dummy_var{}'</code>
compares the value of the the test cell (<code>dummy_var</code>) against the
values of cells included in the test cell neighborhood
(<code>dummy_var{}</code>).
</p>
</li>
<li><p> A maximum of 8 evaluations are performed for each test cell (the test
cell is compared against each cell included in its neighborhood).
</p>
</li>
<li><p> Test cells receive a classification number if the rule is true for at
least as many evaluations as the ones specified by the argument
<code>peval</code>. The argument <code>peval</code> ranges from 0 to 1. When 8
evaluations are performed, <code>peval = 1</code> means that all <code>8</code>
evaluations have to be true; <code>peval = 0.5</code> means that at least
<code>4</code> evaluations have to be true.
</p>
</li>
<li><p> Only one neighborhood rule is allowed for each condition string (e.g., it
is not possible to have a condition string like <code>"variable_A{} &gt; 0 &amp;
  variable_B{} &gt; variable_B"</code>).
</p>
</li>
<li><p> The function <code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code> can consider a <code>directional
  neighborhood</code> instead of the test cell neighborhood by setting the argument
<code>directional = TRUE</code>.
</p>
</li>
<li> <p><em>Example of valid conditions:</em> <code>"variable_A &gt; variable_A{}"</code>;
<code>"(variable_A &gt; variable_A{} &amp; variable_B != variable_B[]) |
  variable_C &gt; 1"</code>. Note that the last example is a combination of absolute
and relative conditions. <br /> <em>Functions:</em> <code><a href="#topic+cond.4.nofn">cond.4.nofn</a></code> and
<code><a href="#topic+cond.reclass">cond.reclass</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An error message if the function finds spelling or syntax errors or a
string with the types of rules detected in the condition string.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cond.4.all">cond.4.all()</a></code>, <code><a href="#topic+cond.4.nofn">cond.4.nofn()</a></code>, <code><a href="#topic+anchor.seed">anchor.seed()</a></code>, <code><a href="#topic+cond.reclass">cond.reclass()</a></code>,
<code><a href="#topic+conditions">conditions()</a></code>
</p>
<p><code><a href="#topic+anchor.seed">anchor.seed()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+cond.4.all">cond.4.all()</a></code>, <code><a href="#topic+cond.4.nofn">cond.4.nofn()</a></code>,
<code><a href="#topic+cond.reclass">cond.reclass()</a></code>, <code><a href="#topic+classify.all">classify.all()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># LOAD LIBRARIES
library(scapesClassification)
library(terra)

################################################################################
# TYPES OF CONDITIONS
################################################################################

# As an example consider an attribute with the following columns
names_attTbl &lt;- c("bathymetry", "slope")

# And the following conditions
cond &lt;- "bathymetry&gt;10"
conditions(names_attTbl, cond)

cond &lt;- "bathymetry[]&gt;bathymetry | abs(slope{}) &lt; 5"
conditions(names_attTbl, cond)

cond &lt;- "bathymetry[]&gt;bathymetry | abs(slope{}) &lt; slope"
conditions(names_attTbl, cond)

################################################################################
# FOCAL EVALUATION DEFINITIONS
################################################################################

# CELL NUMBERS OF A DUMMY RASTER (7X7)
r   &lt;- terra::rast(matrix(1:49, nrow = 7, byrow = TRUE), extent=c(0,7,0,7))
nbs &lt;- ngbList(r)

# CLASS VECTOR WITH ONE TEST AND ONE FOCAL CELL
cv &lt;- as.numeric(rep(NA, 49))
cv[c(32, 25)] &lt;- c(1, 2) # tc (class 1), fc (class 2)
r_cv &lt;- cv.2.rast(r, classVector = cv)

# POLYGONS REPRESENTING NEIGHBORHOODS
fcn &lt;- rbind(c(2,5), c(5,5), c(5,2), c(2,2), c(2,5))
fcn &lt;- terra::vect(fcn, type="polygons")

tcn &lt;- rbind(c(2,4), c(5,4), c(5,1), c(2,1), c(2,4))
tcn &lt;- terra::vect(tcn, type="polygons")

# PLOT - FOCAL EVALUATION DEFINITIONS
m &lt;- c(3.5, 8, 1.2, 8)
plot(r_cv, type = "class", asp = NA, legend = FALSE, axes = FALSE, mar = m,
     col = c("goldenrod3","#1088a0"), colNA= "grey90")
text(r)
mtext(side=3, line=0, adj=0, cex=1, font=2, "FOCAL EVALUATION")
mtext(side=1, line=0, adj=0, cex=0.9,
      "Focal cell neighborhood: 17, 18, 19, 24, 26, 31, 32, 33")
mtext(side=1, line=1, cex=0.9, adj=0,
      "Test cell neighborhood: 24, 25, 26, 31, 33, 38, 39, 40")
mtext(side=1, line=2, cex=0.9, adj=0,
     "Directional neighborhood: 24, 25, 26, 31, 32, 33")
lines(fcn, col="#1088a0", lwd=2)
lines(tcn, col="#cfad8999", lwd=2)
legend("bottomleft", ncol = 1, bg = "white", y.intersp= 1.3,
       legend = c("Focal cell", "Test cell"), fill = c("#1088a0", "goldenrod3"))
</code></pre>

<hr>
<h2 id='cv.2.rast'>Class vector to raster</h2><span id='topic+cv.2.rast'></span>

<h3>Description</h3>

<p>Transform a class vector or a generic vector into a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.2.rast(
  r,
  classVector,
  index = NULL,
  plot = FALSE,
  type = "classes",
  writeRaster = NULL,
  overWrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.2.rast_+3A_r">r</code></td>
<td>
<p>raster object.</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, the values to be assigned to the cell
numbers indicated by <code>index</code>.</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_index">index</code></td>
<td>
<p>numeric vector, the cell numbers of the argument <code>r</code> to
which assign the values of the argument <code>classVector</code>. If <code>NULL</code>,
the column <code>Cell</code> of the attribute table <code>attTbl(r)</code> is used (see
<code><a href="#topic+attTbl">attTbl</a></code>).</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_plot">plot</code></td>
<td>
<p>logic, plot the raster.</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_type">type</code></td>
<td>
<p>character, type of map/legend. One of &quot;continuous&quot;, &quot;classes&quot;, or
&quot;interval&quot;.</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_writeraster">writeRaster</code></td>
<td>
<p>filename, if a raster name is provided save the raster to
a file.</p>
</td></tr>
<tr><td><code id="cv.2.rast_+3A_overwrite">overWrite</code></td>
<td>
<p>logic, if the raster names already exist, the existing file
is overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>index</code> and <code>vector</code> need to have the same
length. The function assign the values of <code>vector</code> at the positions of
<code>index</code> to an empty raster having the same spatial properties of the
raster <code>r</code>.
</p>


<h3>Value</h3>

<p>A class vector or a generic vector transformed into a raster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

# Compute an example class vector
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &gt; 1", class = 1)

# Class vector to raster
cv.2.rast(r, cv, plot = TRUE)
text(r) # add raster values
</code></pre>

<hr>
<h2 id='ngb8'>Eight neighbors</h2><span id='topic+ngb8'></span>

<h3>Description</h3>

<p>Return the 8 neighbors, as cell numbers, of each cell on a raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngb8(n_row, n_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngb8_+3A_n_row">n_row</code></td>
<td>
<p>Integer. The number of rows of a Raster or object.</p>
</td></tr>
<tr><td><code id="ngb8_+3A_n_col">n_col</code></td>
<td>
<p>Integer. The number of columns of a Raster object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cell with coordinates <code>(x, y)</code> has 8 neighbors with
coordinates: <code>(x1, y)</code>,  <code>(x, y1)</code> and <code>(x1, y1)</code>. Cells
on the edge of a raster have less than 8 neighbors. The function identifies
the neighbors of a cell as cell numbers.
</p>


<h3>Value</h3>

<p>Named list, the <code>nth</code> element of the list corresponds to the 8
adjacent cell numbers of the <code>nth</code> cell on the <code>Raster*</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ngbList">ngbList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Matrix m mocking a raster of 3 rows and 4 columns
m &lt;- matrix(1:12, nrow = 3, ncol = 4, byrow = TRUE)
m

nbs &lt;- ngb8(3, 4)
nbs
</code></pre>

<hr>
<h2 id='ngbList'>List of neighborhoods</h2><span id='topic+ngbList'></span>

<h3>Description</h3>

<p>Computes the neighborhoods of the cells of a raster. Neighborhoods are not
computed for cells with missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngbList(r, rNumb = FALSE, attTbl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngbList_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>).</p>
</td></tr>
<tr><td><code id="ngbList_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighbors of a raster cell are identified by <strong>cell
numbers (<code>rNumb=FALSE</code>)</strong> or by <strong>row numbers (<code>rNumb=TRUE</code>)</strong>.
If true, the argument <code>attTbl</code> cannot be NULL.</p>
</td></tr>
<tr><td><code id="ngbList_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code> (see <code><a href="#topic+attTbl">attTbl</a></code>). It is required only if the
argument <code>rNumb=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Definition of neighborhood</strong>
</p>

<ul>
<li><p> A cell with coordinates <code>(x, y)</code> has 8 neighbors with coordinates:
<code>(x1, y)</code>,  <code>(x, y1)</code> and <code>(x1, y1)</code>. Cells on the edge
of a raster have less than 8 neighbors.
</p>
</li></ul>

<p><strong>Neighborhoods (<code>rNumb=FALSE</code>)</strong>
</p>

<ul>
<li><p> Neighbors are identified by their cell numbers if the argument
<code>rNumb=FALSE</code>.
</p>
</li></ul>

<p><strong>Neighborhoods (<code>rNumb=TRUE</code>)</strong>
</p>

<ul>
<li><p> Neighbors are identified by their positions in the attribute table (i.e.
row numbers) if the argument <code>rNumb=TRUE</code>;
</p>
</li>
<li><p> When the argument <code>rNumb = TRUE</code>, neighbors with missing values are
omitted;
</p>
</li>
<li> <p><code>(scapes)Classifications</code> are faster when the list of neighborhoods
uses row numbers.
</p>
</li></ul>

<p><strong>Neighborhood names</strong>
</p>
<p>The list of neighborhoods is named.
</p>

<ul>
<li><p> When <code>rNumb = FALSE</code>, the element name identifies the raster cell to
which the neighborhood refers. For instance, the element with name
<code>"n"</code> stores the neighborhood of the raster cell <code>n</code>.
</p>
</li>
<li><p> When <code>rNumb = TRUE</code>, the element name identifies the row number to
which the neighborhood refers. For instance, the element with name
<code>"n"</code> stores the neighborhood of the raster cell located in the
<code>nth</code> row of the attribute table (<code>attTbl$Cell[n]</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>Named list of integer vectors.
</p>


<h3>Note</h3>


<ul>
<li><p> There is always a correspondence between the indices of the attribute
table (<code><a href="#topic+attTbl">attTbl</a></code>) and the indices of the list of neighborhoods:
the 1st element of the list corresponds to the neighbors of the cell stored
in the 1st row of the attribute table; the 2nd element corresponds to the
2nd row; etc.
</p>
</li>
<li><p> There is a correspondence between the raster cell number and the indices
of the list of neighborhoods only when no missing value is present in the
raster.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ngb8">ngb8()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scapesClassification)
library(terra)

## CREATE A DUMMY RASTER AND COMPUTE ATTRIBUTE TABLE ##
r &lt;- terra::rast(matrix(c(NA,100,100,NA,100,100,0,0,0),
                        nrow = 3,
                        ncol = 3,
                        byrow = TRUE))

at &lt;- attTbl(r, var_names = c("dummy_var"))

## RASTER CELL NUMBERS ##
rcn &lt;- r; rcn[] &lt;- 1:9

## PLOT DATA AND CELL NUMBERS ##
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4, 1, 4, 1)

plot(r, col="grey90", colNA="red3", mar=m, asp=NA, axes=FALSE, legend=FALSE)
text(r)
lines(r)
mtext(side=3, line=0.2, adj=0, cex=1.5, font=2, "Dummy_var")
legend("bottomright", ncol = 1, bg = "white", fill = c("red3"),
       legend = c("NA cells (1 and 4)"))

plot(rcn, col="grey90", mar=m, asp = NA, axes=FALSE, legend=FALSE)
text(rcn)
lines(rcn)
mtext(side=3, line=0.2, adj=0, cex=1.5, font=2, "Cell numbers")
par(oldpar)

## NEIGHBORHOODS - CELL NUMBERS ##

# Cells 1 and 4 are omitted because they are NAs
nbs_CELL &lt;- ngbList(r, rNumb = FALSE)
nbs_CELL


## NEIGHBORHOODS - ROW NUMBERS ##

# Cells 1 and 4 are omitted because they are NAs
nbs_ROW &lt;- ngbList(r, rNumb = TRUE, attTbl = at)
nbs_ROW

# Numbers in 'nbs_ROW' refer to row numbers
# (e.g. number 1 refers to the cell #2)
at$Cell[1]

# (e.g. number 2 refers to the cell #3)
at$Cell[2]

# (e.g. number 5 refers to the cell #7)
at$Cell[5]


## CONSIDER THE NEIGHBORHOOD OF CELL #2 ##

# Cell #2 corresponds to the 1st element of both 'nbs_CELL' and 'nbs_ROW'
# because raster cell 1 is an NA-cell
r[1]

# Neighborhood cell #2 corresponds to cells:
nbs_CELL[1]

# Neighborhood cell #2 corresponds to rows:
nbs_ROW[1]

# Rows can be converted to cell numbers
at$Cell[ nbs_ROW[[1]] ]

# Note that 'at$Cell[ nbs_ROW[[1]] ]' is not equal to 'nbs_CELL'
identical( at$Cell[ nbs_ROW[[1]] ] , nbs_CELL[[1]] )

# This is because raster cells 1 and 4 (NA-cells) are omitted in 'nbs_ROW'
setdiff(nbs_CELL[[1]], at$Cell[ nbs_ROW[[1]] ])
r[c(1,4)]
</code></pre>

<hr>
<h2 id='obj.border'>Borders of raster objects</h2><span id='topic+obj.border'></span>

<h3>Description</h3>

<p>Identify the borders of raster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.border(group, ngbList, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.border_+3A_group">group</code></td>
<td>
<p>named list, each element represents a raster object composed of
several raster cells. If there are NA values on the raster surface, raster
cells must be identified by attribute table row indices (each corresponding
to a raster cell) (see <code><a href="#topic+attTbl">attTbl</a></code>).</p>
</td></tr>
<tr><td><code id="obj.border_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>. The list of neighborhoods has to be computed setting
the argument <code>rNumb=TRUE</code>.</p>
</td></tr>
<tr><td><code id="obj.border_+3A_silent">silent</code></td>
<td>
<p>logic, progress bar is not printed on the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a named list of object borders. List names
identify the objects; list element values identify the raster cells
comprising the borders.
</p>


<h3>Note</h3>

 <ul>
<li><p> Note that <code>group</code> has to be a <strong>named</strong> list whose
names correspond to raster object IDs.
</p>
</li>
<li><p> If there are NA values on the raster surface, raster cells must be
identified by attribute table row indices (each corresponding to a raster
cell). Row indices can be converted into raster cells using the <code>Cell</code>
column of the attribute table (e.g. <code>attTbl$Cell[indices]</code>) (see
<code><a href="#topic+attTbl">attTbl</a></code>).</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+obj.nbs">obj.nbs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# ADD NA-VALUE
r[11] &lt;- NA

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r, rNumb=TRUE, attTbl=at) # rnumb MUST be true to use obj.border

################################################################################
# COMPUTE RASTER OBJECTS
################################################################################
at$cv &lt;- anchor.seed(at, nbs, silent=TRUE, class = NULL, rNumb=TRUE,
                     cond.filter = "dummy_var &gt; 1",
                     cond.seed   = "dummy_var==max(dummy_var)",
                     cond.growth = "dummy_var&lt;dummy_var[]",
                     lag.growth  = 0)

# Raster objects
RO &lt;- split(1:NROW(at), at$cv)

print(RO) # values are attribute table row indices

################################################################################
# COMPUTE BORDERS
################################################################################
RO_bd &lt;- obj.border(RO, nbs, silent = TRUE)

RO_bd1 &lt;- at$Cell[RO_bd[["1"]]] # Convert row numbers to cell numbers
RO_bd2 &lt;- at$Cell[RO_bd[["2"]]] # Convert row numbers to cell numbers

print(RO_bd)  # attribute table row indices
print(RO_bd1) # cell numbers
print(RO_bd2) # cell numbers

################################################################################
# PLOT BORDERS
################################################################################
plot(cv.2.rast(r,at$cv), type="classes", col=c("#E6E600","#00A600"),
     main="Borders")
points(terra::xyFromCell(r, RO_bd1), pch=20, col="blue")
points(terra::xyFromCell(r, RO_bd2), pch=20, col="red")
text(xyFromCell(r, 11), "NA\nvalue")
</code></pre>

<hr>
<h2 id='obj.nbs'>Shared borders of raster objects</h2><span id='topic+obj.nbs'></span>

<h3>Description</h3>

<p>Identify the shared borders of neighboring raster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.nbs(grp.bord, ngbList, only_grp = NULL, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.nbs_+3A_grp.bord">grp.bord</code></td>
<td>
<p>named list, the list of borders returned by the function
<code><a href="#topic+obj.border">obj.border</a></code>.</p>
</td></tr>
<tr><td><code id="obj.nbs_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>. The list of neighborhoods has to be computed setting
the argument <code>rNumb=TRUE</code>.</p>
</td></tr>
<tr><td><code id="obj.nbs_+3A_only_grp">only_grp</code></td>
<td>
<p>character vector. If <code>NULL</code>, all IDs in <code>grp.bord</code>
are considered. If IDs are provided, then they are the only ones
considered.</p>
</td></tr>
<tr><td><code id="obj.nbs_+3A_silent">silent</code></td>
<td>
<p>logic, progress bar is not printed on the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a named list. Each element represents a raster
object as identified by the list names and contains a nested named list.
The names of the nested lists are the IDs of neighboring raster objects and
their values identify the raster cells comprising the shared borders.
</p>


<h3>Note</h3>

<p>If there are NA values on the raster surface, raster cells are
identified by attribute table row indices (each corresponding to a raster
cell). Row indices can be converted into raster cells using the <code>Cell</code>
column of the attribute table (e.g. <code>attTbl$Cell[indices]</code>) (see
<code><a href="#topic+attTbl">attTbl</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+obj.border">obj.border()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# ADD ONE NA VALUE
r[11] &lt;- NA

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r, rNumb=TRUE, attTbl=at) # rnumb MUST be true to use obj.nbs

################################################################################
# COMPUTE RASTER OBJECTS
################################################################################
at$cv &lt;- anchor.seed(at, nbs, silent=TRUE, class = NULL, rNumb=TRUE,
                     cond.filter = "dummy_var &gt; 1",
                     cond.seed   = "dummy_var==max(dummy_var)",
                     cond.growth = "dummy_var&lt;dummy_var[]",
                     lag.growth  = 0)

RO &lt;- split(1:NROW(at), at$cv)

print(RO)

################################################################################
# COMPUTE BORDERS
################################################################################
RO_bd &lt;- obj.border(RO, nbs, silent = TRUE)

################################################################################
# COMPUTE SHARED BORDERS
################################################################################
RO_sbd &lt;- obj.nbs(RO_bd, nbs, silent = TRUE)

# Convert row indices to cell numbers
RO_sbd1 &lt;- RO_sbd[["1"]]
RO_sbd1 &lt;- at$Cell[unlist(RO_sbd1)]

RO_sbd2 &lt;- RO_sbd[["2"]]
RO_sbd2 &lt;- at$Cell[unlist(RO_sbd2)]

# Borders in `RO_sbd` are identified by row indices
print(RO_sbd[["1"]]) # Row indices
print(RO_sbd1) # Cell numbers

print(RO_sbd[["2"]])  # Row indices
print(RO_sbd2) # Cell numbers

# Neighbor objects
names(RO_sbd[["1"]]) # RO1 has one neighbor, RO2
names(RO_sbd[["2"]]) # RO2 has one neighbor, RO1

################################################################################
# PLOT BORDERS
################################################################################
plot(cv.2.rast(r,at$cv), type="classes", col=c("#E6E600","#00A600"),
     main="Shared borders")
points(terra::xyFromCell(r, RO_sbd1), pch=20, col="blue")
points(terra::xyFromCell(r, RO_sbd2), pch=20, col="red")
text(xyFromCell(r, 11), "NA\nvalue")
</code></pre>

<hr>
<h2 id='peak.cell'>Identify local maxima or minima</h2><span id='topic+peak.cell'></span>

<h3>Description</h3>

<p>Identify local maxima or minima on a raster surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak.cell(attTbl, ngbList, rNumb = FALSE, p_col, p_fun = "max", p_edge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak.cell_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="peak.cell_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="peak.cell_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="peak.cell_+3A_p_col">p_col</code></td>
<td>
<p>character, the column of the attribute table over which maxima
or minima are searched.</p>
</td></tr>
<tr><td><code id="peak.cell_+3A_p_fun">p_fun</code></td>
<td>
<p>character, if 'max' the function searches for local maxima; if
'min' the function searches for local minima.</p>
</td></tr>
<tr><td><code id="peak.cell_+3A_p_edge">p_edge</code></td>
<td>
<p>logic, if false local maxima or minima are not searched on edge
cells. Edge cells are considered cells on the edge of the raster and cell
neighboring NA-cells.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> A cell constitutes a <em>local maximum</em> if its
elevation value is larger than the values of all the cells in its
neighborhood (see <code><a href="#topic+ngbList">ngbList</a></code>).
</p>
</li>
<li><p> A cell constitutes a <em>local minimum</em> if its elevation value is
smaller than the values of all the cells in its neighborhood (see
<code><a href="#topic+ngbList">ngbList</a></code>).</p>
</li></ul>



<h3>Value</h3>

<p>A <code>classVector</code> with peak cells identified by the numeric class
<code>1</code>. See <code><a href="#topic+conditions">conditions</a></code> for more details about class
vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditions">conditions()</a></code>, <code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)
################################################################################

# PEAK.CELL
################################################################################
# p_edge = FALSE
pc_a &lt;- peak.cell(attTbl = at, ngbList = nbs, rNumb = FALSE,
                  p_col = "dummy_var", p_fun = "max", p_edge = FALSE)

# p_edge = TRUE
pc_b &lt;- peak.cell(attTbl = at, ngbList = nbs, rNumb = FALSE,
                  p_col = "dummy_var", p_fun = "max", p_edge = TRUE)

# CONVERT THE CLASS VECTORS INTO RASTERS
r_pca &lt;- cv.2.rast(r, at$Cell, classVector = pc_a, plot = FALSE)
r_pcb &lt;- cv.2.rast(r, at$Cell, classVector = pc_b, plot = FALSE)
################################################################################

#PLOTS
###############################################################################
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4, 1, 4, 1)

# PLOT 1 - p_edge = FALSE
plot(r_pca, axes=FALSE, legend=FALSE, asp=NA, mar=m,
     colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "PEAK.CELL")
mtext(side=3, line=0, adj=0, cex=0.9, "p_edge = FALSE")
legend("bottomright", bg = "white",
       legend = c("Peak cell", "Unclassified cells"),
       fill = c("#cfad89", "#818792"))

# PLOT 2 - p_edge = TRUE
plot(r_pcb, axes=FALSE, legend=FALSE, asp=NA, mar=m,
    colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=1, adj=0, cex=1, font=2, "PEAK.CELL")
mtext(side=3, line=0, adj=0, cex=0.9, "p_edge = TRUE")
legend("bottomright", bg = "white",
       legend = c("Peak cell", "Unclassified cells"),
       fill = c("#cfad89", "#818792"))
par(oldpar)
</code></pre>

<hr>
<h2 id='pi.add'>Position index addition</h2><span id='topic+pi.add'></span>

<h3>Description</h3>

<p>Add new raster objects based on position index values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.add(
  attTbl,
  ngbList,
  rNumb = FALSE,
  RO,
  mainPI = NULL,
  secPI = NULL,
  add.mPI = NULL,
  add.sPI = NULL,
  cond.filter = NULL,
  min.N = NULL,
  plot = FALSE,
  r = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.add_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_ro">RO</code></td>
<td>
<p>column name, the name of the column with the raster object IDs.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_mainpi">mainPI</code></td>
<td>
<p>column name, the name of the column with main position index
values.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_secpi">secPI</code></td>
<td>
<p>column name, the name of the column with secondary position
index values.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_add.mpi">add.mPI</code></td>
<td>
<p>numeric, threshold of main position index values. Cells with
values above the threshold are flagged as cells potentially being part of
new raster objects.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_add.spi">add.sPI</code></td>
<td>
<p>numeric, threshold of secondary position index values. Cells
with values above the threshold flagged as cells potentially being part of
new raster objects.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_cond.filter">cond.filter</code></td>
<td>
<p>character string, defines what cells have to be considered
by the function the arguments. Test cell absolute conditions can be used
(see <code><a href="#topic+conditions">conditions</a></code>).</p>
</td></tr>
<tr><td><code id="pi.add_+3A_min.n">min.N</code></td>
<td>
<p>numeric, the minimum number of cells a raster object has to have
to be included in the function output.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_plot">plot</code></td>
<td>
<p>logic, plot the results.</p>
</td></tr>
<tr><td><code id="pi.add_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>) used to compute the attribute table. Required
only if <code>plot = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New raster objects are added based on position index values. Two
different position indices can be passed to the function (<code>mainPI</code> and
<code>secPI</code>).
</p>

<ul>
<li><p> Input raster objects are assigned to the same class to flag cells that
are part of raster objects;
</p>
</li>
<li><p> Cells with values above <code>mainPI</code> <strong>OR</strong> above <code>mainPI</code> are
flagged as cells potentially being part of new raster objects;
</p>
</li>
<li><p> If not connected to any of the existing raster objects, the groups of
cells above position index values are assigned to new raster objects.
</p>
</li>
<li><p> Only raster objects with at least as many cells as specified by the
argument <code>min.N</code> are included in the function output.
</p>
</li>
<li><p> If both <code>mainPI</code> and <code>secPI</code> are equal to <code>NULL</code>, the
function will exclusively filter raster objects based on their size
(<code>min.N</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>The function returns a class vector with raster objects IDs. The
vector has length equal to the number of rows of the attribute table. NA
values are assigned to cells that do not belong to any raster object.
</p>


<h3>Note</h3>

<p>Raster objects are added only if they do not share any border with
input raster objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+rel.pi">rel.pi()</a></code>, <code><a href="#topic+pi.sgm">pi.sgm()</a></code>, <code><a href="#topic+conditions">conditions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r, attTbl=at)

################################################################################
# COMPUTE RASTER OBJECTS
################################################################################
at$RO[at$dummy_var==8] &lt;- 1
at$RO &lt;- cond.4.nofn(at, nbs, classVector = at$RO, class=1, nbs_of = 1,
                     cond = "dummy_var &lt; dummy_var[] &amp; dummy_var &gt; 2")

# One raster object
unique(at$RO)

################################################################################
# POSITION INDEX
################################################################################
at$PI &lt;- (at$dummy_var - mean(at$dummy_var))/stats::sd(at$dummy_var)

################################################################################
# POSITION INDEX ADDITION
################################################################################
RO1 &lt;- pi.add(at, nbs,
              RO = "RO",     # Raster objects
              mainPI = "PI", # PI addition layer
              add.mPI = 1,   # add disjoint objects with PI values &gt; 1
              plot = FALSE, r = r)

################################################################################
# PLOT
################################################################################
# Convert class vectors to raster
r_RO  &lt;- cv.2.rast(r = r, classVector = at$RO)
r_RO1 &lt;- cv.2.rast(r = r, classVector = RO1)

# Plot
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4.5, 0.5, 2, 3.2)

terra::plot(r_RO, type="classes", main="Raster objects - Input", mar=m,
            plg=list(x=1, y=1, cex=0.9))

terra::plot(r_RO1, type="classes", main="Raster objects - Output", mar=m,
            plg=list(x=1, y=1, cex=0.9))
text(xyFromCell(r,at$Cell), as.character(round(at$PI,2)),
cex = 0.8) # visualize relPI
text(0.01, 1, "Add on PI &gt;= 1", adj=c(0,0), cex = 0.8)
par(oldpar)

# Two raster object
unique(RO1)
</code></pre>

<hr>
<h2 id='pi.sgm'>Position index segmentation</h2><span id='topic+pi.sgm'></span>

<h3>Description</h3>

<p>Segment raster objects based on position index values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.sgm(
  attTbl,
  ngbList,
  rNumb = FALSE,
  RO,
  mainPI = NULL,
  secPI = NULL,
  cut.mPI = NULL,
  cut.sPI = NULL,
  min.N = NULL,
  plot = FALSE,
  r = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.sgm_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_ro">RO</code></td>
<td>
<p>column name, the name of the column with the raster object IDs.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_mainpi">mainPI</code></td>
<td>
<p>column name, the name of the column with main position index
values.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_secpi">secPI</code></td>
<td>
<p>column name, the name of the column with secondary position
index values.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_cut.mpi">cut.mPI</code></td>
<td>
<p>numeric, threshold of main position index values. Cells with
values below the threshold are excluded from raster objects.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_cut.spi">cut.sPI</code></td>
<td>
<p>numeric, threshold of secondary position index values. Cells
with values below the threshold are excluded from raster objects.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_min.n">min.N</code></td>
<td>
<p>numeric, the minimum number of cells a raster object has to have
to be included in the function output.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_plot">plot</code></td>
<td>
<p>logic, plot the results.</p>
</td></tr>
<tr><td><code id="pi.sgm_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>) used to compute the attribute table. Required
only if <code>plot = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Raster objects are segmented based on position index values. Two
different position indices can be passed to the function (<code>mainPI</code> and
<code>secPI</code>).
</p>

<ul>
<li><p> Input raster objects are assigned to the same class to flag cells that
are part of raster objects;
</p>
</li>
<li><p> Cells with values below <code>mainPI</code> <strong>OR</strong> below <code>mainPI</code> are
flagged as not being part of any raster object;
</p>
</li>
<li><p> Each non-continuous group of raster object cells will identify an output
raster object.
</p>
</li>
<li><p> Only raster objects with at least as many cells as specified by the
argument <code>min.N</code> are included in the function output.
</p>
</li>
<li><p> If both <code>mainPI</code> and <code>secPI</code> are equal to <code>NULL</code>, the
function will exclusively filter raster objects based on their size
(<code>min.N</code>).
</p>
</li></ul>



<h3>Value</h3>

<p>The function returns a class vector with raster objects IDs. The
vector has length equal to the number of rows of the attribute table. NA
values are assigned to cells that do not belong to any raster object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+rel.pi">rel.pi()</a></code>, <code><a href="#topic+pi.add">pi.add()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r, attTbl=at)

################################################################################
# COMPUTE RASTER OBJECTS
################################################################################
at$RO &lt;- anchor.seed(at, nbs, silent=TRUE, class = NULL, rNumb=TRUE,
                     cond.filter = "dummy_var &gt; 1",
                     cond.seed   = "dummy_var==max(dummy_var)",
                     cond.growth = "dummy_var&lt;dummy_var[]",
                     lag.growth  = Inf)

# One input raster object
unique(at$RO)

################################################################################
# NORMALIZED RELATIVE POSITION INDEX
################################################################################
at$relPI &lt;- rel.pi(attTbl = at, RO = "RO", el = "dummy_var", type = "n")

################################################################################
# POSITION INDEX SEGMENTATION
################################################################################
RO1 &lt;- pi.sgm(at, nbs,
              RO = "RO",        # Raster objects
              mainPI = "relPI", # PI segmentation layer
              cut.mPI = 0,      # segment on relPI values &lt;= 0
              plot = FALSE, r = r)

################################################################################
# PLOT
################################################################################
# Convert class vectors to raster
r_RO  &lt;- cv.2.rast(r = r, classVector = at$RO)
r_RO1 &lt;- cv.2.rast(r = r, classVector = RO1)

# Plot
oldpar &lt;- par(mfrow = c(1,2))
m &lt;- c(4.5, 0.5, 2, 3.2)

terra::plot(r_RO, type="classes", main="Raster objects - Input", mar=m,
plg=list(x=1, y=1, cex=0.9))

terra::plot(r_RO1, type="classes", main="Raster objects - Output", mar=m,
            plg=list(x=1, y=1, cex=0.9))
text(xyFromCell(r,at$Cell), as.character(round(at$relPI,2))) # visualize relPI
text(0.01, 1, "Cut on relPI &lt;= 0", adj=c(0,1), cex = 0.8)
par(oldpar)

# Two output raster objects
unique(RO1)
</code></pre>

<hr>
<h2 id='reclass.nbs'>Reclassify neighbors</h2><span id='topic+reclass.nbs'></span>

<h3>Description</h3>

<p>Evaluate if members of two classes are contiguous and, if they are, one of
them is reclassified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass.nbs(
  attTbl,
  ngbList,
  rNumb = FALSE,
  classVector,
  nbs_of,
  class,
  reclass,
  reclass_all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclass.nbs_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_ngblist">ngbList</code></td>
<td>
<p>list, the list of neighborhoods returned by the function
<code><a href="#topic+ngbList">ngbList</a></code>.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_rnumb">rNumb</code></td>
<td>
<p>logic, the neighborhoods of the argument <code>ngbList</code> are
identified by cell numbers (<code>rNumb=FALSE</code>) or by row numbers
(<code>rNumb=TRUE</code>) (see <code><a href="#topic+ngbList">ngbList</a></code>). It is advised to use row
numbers for large rasters.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_classvector">classVector</code></td>
<td>
<p>numeric vector, defines the cells in the attribute table
that have already been classified. See <code><a href="#topic+conditions">conditions</a></code> for more
information about class vectors.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_nbs_of">nbs_of</code></td>
<td>
<p>numeric or numeric vector, indicates the class(es) of focal and
anchor cells.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_class">class</code></td>
<td>
<p>numeric or numeric vector, cells of classes <code>class</code>
adjacent to cells belonging to one of the classes of <code>nbs_of</code> are
reclassified as indicated by the argument <code>reclass</code>.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_reclass">reclass</code></td>
<td>
<p>numeric, the classification number to assign to all cells that
meet the function conditions.</p>
</td></tr>
<tr><td><code id="reclass.nbs_+3A_reclass_all">reclass_all</code></td>
<td>
<p>logic, all cells of class <code>class</code> are also
reclassified if they are connected to a reclassified cell.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The function evaluates if a cell of class
<code>class</code> is adjacent to a cell of class <code>nbs_of</code> and, if it is, it
is reclassifies as indicated by the argument <code>reclass</code>.
</p>
</li>
<li><p> If the argument <code>reclass_all = TRUE</code>, all cells of class
<code>class</code> are also reclassified if they are connected to a reclassified
cell.</p>
</li></ul>



<h3>Value</h3>

<p>Update <code>classVector</code> with the new cells that were classified by
the function. See <code><a href="#topic+conditions">conditions</a></code> for more information about class
vectors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+cond.reclass">cond.reclass()</a></code>, <code><a href="#topic+classify.all">classify.all()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r)

################################################################################
# RECLASS.NBS
################################################################################

# Compute an inital class vector with `cond.4.all`
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &gt; 5", class = 1)

# Update the class vector with a second class
cv &lt;- cond.4.all(attTbl = at, cond = "dummy_var &gt;= 2", class = 2,
                 classVector = cv)


# Reclassify cells of class 2 adjacent to cells of class 1

# reclass_all = FALSE
rc1 &lt;- reclass.nbs(attTbl = at, ngbList = nbs,

                   # CLASS VECTOR `cv`
                   classVector = cv,

                   # CELLS OF CLASS...
                   class = 2,

                   # ...ADJACENT TO CELLS OF ANOTHER CLASS...
                   nbs_of = 1,

                   # ...WILL BE RECLASSIFIED...
                   reclass = 3,

                   # NO MORE RECLASSIFICATIONS
                   reclass_all = FALSE)

# reclass_all = TRUE
rc2 &lt;- reclass.nbs(attTbl = at, ngbList = nbs,

                   # CLASS VECTOR `cv`
                   classVector = cv,

                   # CELLS OF CLASS...
                   class = 2,

                   # ...ADJACENT TO CELLS OF ANOTHER CLASS...
                   nbs_of = 1,

                   # ...WILL BE RECLASSIFIED...
                   reclass = 3,

                   # ...AND SO ALL CELLS OF CLASS 1 CONNECTED TO A RECLASSIFIED CELL
                   reclass_all = TRUE)

# Convert class vectors to rasters
r_cv  &lt;- cv.2.rast(r, at$Cell,classVector = cv, plot = FALSE)
r_rc1 &lt;- cv.2.rast(r, at$Cell,classVector = rc1, plot = FALSE)
r_rc2 &lt;- cv.2.rast(r, at$Cell,classVector = rc2, plot = FALSE)

################################################################################
# PLOTS
################################################################################
oldpar &lt;- par(mfrow = c(2,2))
m = c(0.1, 3.5, 3.2, 3.5)


# 1)
plot(r_cv, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar=m,
     colNA="#818792", col=c("#1088a0", "#78b2c4"))
text(r)
mtext(side=3, line=2, adj=0, cex=1, font=2, "COND.4.ALL")
mtext(side=3, line=1, adj=0, cex=0.9, "Step1: 'dummy_var &gt; 5', class: 1")
mtext(side=3, line=0, adj=0, cex=0.9, "Step2: 'dummy_var &gt; 3', class: 2")
legend("bottomright", ncol = 1, bg = "white", y.intersp= 1.2,
       legend = c("Class 1", "Class 2", "Unclassified cells"),
      fill = c("#1088a0", "#78b2c4", "#818792"))

# 2)
plot(r_rc1, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar=m,
     colNA="#818792", col=c("#1088a0", "#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=2, adj=0, cex=1, font=2, "RECLASS.NBS")
mtext(side=3, line=1, adj=0, cex=0.9, "Reclass: class 2 adjacent to class 1")
mtext(side=3, line=0, adj=0, cex=0.9, "reclass_all = FALSE")
legend("bottomright", ncol = 1, bg = "white", y.intersp= 1.2,
       legend = c("Reclassified cells"), fill = c("#cfad89"))

# 3)
plot(r_rc2, type="classes", axes=FALSE, legend = FALSE, asp = NA, mar=m,
     colNA="#818792", col=c("#1088a0", "#78b2c4", "#cfad89"))
text(r)
mtext(side=3, line=2, adj=0, cex=1, font=2, "RECLASS.NBS")
mtext(side=3, line=1, adj=0, cex=0.9, "Reclass: class 2 adjacent to class 1")
mtext(side=3, line=0, adj=0, cex=0.9, "reclass_all = TRUE")
legend("bottomright", ncol = 1, bg = "white", y.intersp= 1.2,
       legend = c("Reclassified cells"), fill = c("#cfad89"))
par(oldpar)
</code></pre>

<hr>
<h2 id='rel.pi'>Relative position index</h2><span id='topic+rel.pi'></span>

<h3>Description</h3>

<p>Compute the relative position index of raster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.pi(attTbl, RO, el, type = "s", plot = FALSE, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.pi_+3A_atttbl">attTbl</code></td>
<td>
<p>data.frame, the attribute table returned by the function
<code><a href="#topic+attTbl">attTbl</a></code>.</p>
</td></tr>
<tr><td><code id="rel.pi_+3A_ro">RO</code></td>
<td>
<p>column name, the name of the column with the raster object IDs.</p>
</td></tr>
<tr><td><code id="rel.pi_+3A_el">el</code></td>
<td>
<p>column name, the name of column with the elevation values on
which the relative position index is computed.</p>
</td></tr>
<tr><td><code id="rel.pi_+3A_type">type</code></td>
<td>
<p>character, defines if position index values are <em>standardized</em>
(<code>"s"</code>) or <em>normalized</em> (<code>"n"</code>).</p>
</td></tr>
<tr><td><code id="rel.pi_+3A_plot">plot</code></td>
<td>
<p>logic, plot the results.</p>
</td></tr>
<tr><td><code id="rel.pi_+3A_r">r</code></td>
<td>
<p>single or multi-layer raster of the class <code>SpatRaster</code> (see
<code>help("rast", terra)</code>) used to compute the attribute table. Required
only if <code>plot = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Position index values are computed only for cells that belong to a
raster object.
</p>

<ul>
<li> <p><em>Standardized position index values</em> (<code>type="s"</code>) are computed with
the formula <code>( x - mean(x) ) / sd(x)</code>;
</p>
</li>
<li> <p><em>Normalized position index values</em> (<code>type="n"</code>) are computed with
the formula <code>( x - min(x) ) / ( max(x) - min(x) )</code>;
</p>
</li>
<li><p> Variable <code>x</code> represents the elevation values
of individual raster object.
</p>
</li></ul>



<h3>Value</h3>

<p>The function returns a vector with relative position index values.
The vector has length equal to the number of rows of the attribute table.
NA values are assigned to cells that do not belong to any raster object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attTbl">attTbl()</a></code>, <code><a href="#topic+ngbList">ngbList()</a></code>, <code><a href="#topic+pi.add">pi.add()</a></code>, <code><a href="#topic+pi.sgm">pi.sgm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DUMMY DATA
######################################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r &lt;- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\.tif", full.names = TRUE)
r &lt;- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at &lt;- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs &lt;- ngbList(r, rNumb=TRUE, attTbl=at) # rnumb MUST be true to use obj.nbs

################################################################################
# COMPUTE RASTER OBJECTS
################################################################################
at$RO &lt;- anchor.seed(at, nbs, silent=TRUE, class = NULL, rNumb=TRUE,
                     cond.filter = "dummy_var &gt; 1",
                     cond.seed   = "dummy_var==max(dummy_var)",
                     cond.growth = "dummy_var&lt;dummy_var[]",
                     lag.growth  = 0)

# Convert class vector at$RO to raster and plot
r_RO  &lt;- cv.2.rast(r = r, classVector = at$RO)
terra::plot(r_RO, type="classes", main="Raster objects",
            plg=list(x=1, y=1, cex=0.9))

################################################################################
# STANDARDIZED RELATIVE POSITION INDEX
################################################################################
relPI &lt;- rel.pi(attTbl = at, RO = "RO", el = "dummy_var",
                type = "s",
                plot = TRUE, r = r)

# Annotate relPI
points(terra::xFromCell(r, at$Cell[which(at$RO==1)]),
       terra::yFromCell(r, at$Cell[which(at$RO==1)]) - 0.04,
       pch=20, col="yellow")
points(terra::xFromCell(r, at$Cell[which(at$RO==2)]),
       terra::yFromCell(r, at$Cell[which(at$RO==2)]) - 0.04,
       pch=20, col="darkgreen")
text(xyFromCell(r,at$Cell), as.character(round(relPI,2)))
legend(1.02, 0.4, legend=c("1", "2"), bty = "n", title="RO:", xpd=TRUE,
col=c("#E6E600", "#00A600"), pch=20, cex=0.9, pt.cex = 1.5)

################################################################################
# NORMALIZED RELATIVE POSITION INDEX
################################################################################
# Compute normalized relative position index
relPI &lt;- rel.pi(attTbl = at, RO = "RO", el = "dummy_var",
                type = "n",
                plot = TRUE, r = r)

# Annotate relPI
points(terra::xFromCell(r, at$Cell[which(at$RO==1)]),
       terra::yFromCell(r, at$Cell[which(at$RO==1)]) - 0.04,
       pch=20, col="yellow")
points(terra::xFromCell(r, at$Cell[which(at$RO==2)]),
       terra::yFromCell(r, at$Cell[which(at$RO==2)]) - 0.04,
       pch=20, col="darkgreen")
text(xyFromCell(r,at$Cell), as.character(round(relPI,2)))
legend(1.02, 0.4, legend=c("1", "2"), bty = "n", title="RO:", xpd=TRUE,
col=c("#E6E600", "#00A600"), pch=20, cex=0.9, pt.cex = 1.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
