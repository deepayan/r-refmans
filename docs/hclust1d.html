<!DOCTYPE html><html lang="en"><head><title>Help for package hclust1d</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hclust1d}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hclust1d-package'><p>hclust1d-package</p></a></li>
<li><a href='#hclust1d'><p>Hierarchical Clustering for 1D</p></a></li>
<li><a href='#supported_dist.methods'><p>Supported Distance Methods</p></a></li>
<li><a href='#supported_methods'><p>Supported Linkage Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Hierarchical Clustering of Univariate (1d) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Univariate agglomerative hierarchical clustering with a comprehensive list of choices of a linkage function in O(n*log n) time. The better algorithmic time complexity is paired with an efficient 'C++' implementation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SzymonNowakowski/hclust1d">https://github.com/SzymonNowakowski/hclust1d</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SzymonNowakowski/hclust1d/issues">https://github.com/SzymonNowakowski/hclust1d/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, utils</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-07 09:32:44 UTC; Szym</td>
</tr>
<tr>
<td>Author:</td>
<td>Szymon Nowakowski <a href="https://orcid.org/0000-0002-1939-9512"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Szymon Nowakowski &lt;s.nowakowski@mimuw.edu.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-07 13:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='hclust1d-package'>hclust1d-package</h2><span id='topic+hclust1d-package'></span>

<h3>Description</h3>

<p>Univariate agglomerative hierarchical clustering with a comprehensive list of choices of a linkage function in O(n*log n) time. The better algorithmic time complexity is paired with an efficient 'C++' implementation.
</p>


<h3>All <code>hclust1d</code> Functions</h3>

<p>Similar in use to <code>stats::hclust</code>. It consists of the following functions:
</p>
<p><code><a href="#topic+hclust1d">hclust1d</a></code> - univariate agglomerative hierarchical clustering routine.
</p>
<p><code><a href="#topic+supported_methods">supported_methods</a></code> - lists all currently supported linkage methods.
</p>
<p><code><a href="#topic+supported_dist.methods">supported_dist.methods</a></code> - lists all currently supported distance methods.
</p>
<p>For more information see a friendly &quot;Getting started&quot; vignette:
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vignette("getting-started", package="hclust1d")

## End(Not run)

</code></pre>

<hr>
<h2 id='hclust1d'>Hierarchical Clustering for 1D</h2><span id='topic+hclust1d'></span>

<h3>Description</h3>

<p>Univariate hierarchical agglomerative clustering routine with a few possible choices of a linkage function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclust1d(x, distance = FALSE, squared = FALSE, method = "complete")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclust1d_+3A_x">x</code></td>
<td>
<p>a vector of 1D points to be clustered, or a distance structure as produced by <code>dist</code>.</p>
</td></tr>
<tr><td><code id="hclust1d_+3A_distance">distance</code></td>
<td>
<p>a logical value indicating, whether <code>x</code> is a vector of 1D points to be clustered (<code>distance = FALSE</code>, the default), or a distance structure (<code>distance = TRUE</code>).</p>
</td></tr>
<tr><td><code id="hclust1d_+3A_squared">squared</code></td>
<td>
<p>a logical value indicating, whether <code>distance</code> is squared (<code>squared = TRUE</code>) or not (<code>squared = FALSE</code>, the default). Its value is irrelevant for <code>distance = FALSE</code> setting.</p>
</td></tr>
<tr><td><code id="hclust1d_+3A_method">method</code></td>
<td>
<p>linkage method, with <code>"complete"</code> as a default. See <code><a href="#topic+supported_methods">supported_methods</a></code> for the complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a distance matrix, the first step of the algorithm is computing a conforming vector of 1D points (with arbitrary shift and sign choices).
</p>
<p>Univariate hierarchical clustering is performed
for the provided or calculated vector of points: initially, each point is assigned its own <em>singleton</em> cluster, and
then the clusters get merged with their nearest neighbors, two at a time.
</p>
<p>For <code>method = "single"</code>, there is no need to recompute distances,
since the original inter-point distances are also the inter-cluster distances, so the algorithm requires
only sorting the original points and then sorting the distances.
</p>
<p>For other linkage methods, two distances (between the merged cluster and the preceding and the following clusters) get recomputed at each merge, and the resulting
distance structure gets updated in an efficiently implemented heap providing a priority queue functionality (the access to the current minimum distance) in O(log n) time at each step.
The resulting algorithm has O(n*log n) time complexity.
</p>


<h3>Value</h3>

<p>A list object with S3 class <code>"hclust"</code>, compatible with a regular <code>stats::hclust</code> output:
</p>
<table role = "presentation">
<tr><td><code>merge</code></td>
<td>
<p>a matrix with n-1 rows and 2 columns. Each i-th row of the matrix details merging performed at the i-th step of the algorithm. If the <em>singleton</em> cluster was merged
at this step, the value of the element is negative and its absolute value equals the index of this point.
Otherwise, a positive value, say j, of an element in i-th row, indicates that at the stage i a cluster created at a previous stage j was merged.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>a vector with n-1 values, with the i-th value indicating the distance between the two clusters merged at the i-th step of the algorithm.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a permutation of the input points sorting them in an increasing order. Since the sign of points computed from the distance structure can be arbitrarily chosen, in the case of a distance structure input, the order can be increasing or decreasing.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>either point names, or point values, or point indices, in the order of availability.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call which produced the results.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the linkage method used for clustering.</p>
</td></tr>
<tr><td><code>dist.method</code></td>
<td>
<p>the distance method used in building the distance matrix; or <code>"euclidean"</code>, if <code>x</code> is a vector of 1D points</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please note that in <code>stats::hclust</code>, the inter-cluster distances for ward.D, centroid and median linkages (returned as <code>height</code>)
are <em>squared</em> euclidean distances
between the relevant clusters' centroids, although that behavior is not well documented. This behavior is also in odds with other linkage methods, for which <em>unsquared</em> euclidean distances are returned.
The implementation in <code>hclust1d::hclust1d</code> follows that behavior in full.
</p>
<p>Also,
<code>stats::hclust</code> expects <em>squared</em> euclidean distance structure as input for <code>method="ward.D"</code>, <code>method="centroid"</code> and <code>method="median"</code>, although the latter is not well documented, either. Squared
distance is not a proper distance (a triangle inequality may not be maintained), so it should be considered <em>dissimilarity</em> instead.
</p>
<p>To retain compatibility, <code>hlust1d::hclust1d</code> accepts <code>x</code> in a form of a squared euclidean distance structure between points as well
(indicated by both <code>distance</code> and <code>squared</code> arguments set to <code>TRUE</code>). Also, note that
<code>hlust1d::hclust1d</code> returns the same heights for unsquared proper distances in <code>x</code> (with <code>distance=TRUE</code> setting and the default <code>squared=FALSE</code> argument)
and for <code>x</code> in a form of a vector of 1D points (with the default <code>distance=FALSE</code> argument). Please consult the <code>Examples</code> section below for further reference on that behavior.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supported_methods">supported_methods</a></code> for listing of all currently supported linkage methods, <code><a href="#topic+supported_dist.methods">supported_dist.methods</a></code> for listing of all currently supported distance methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Faster replacements for
# stats::hclust(dist(rnorm(100))) with a default complete linkage
dendrogram &lt;- hclust1d(rnorm(100))
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE)

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "average")
dendrogram &lt;- hclust1d(rnorm(100), method = "average")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "average")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "centroid")
# Note that stats::hclust expects squared euclidean distance input for centroid linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "centroid")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "centroid")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "centroid")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "median")
# Note that stats::hclust expects squared euclidean distance input for median linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "median")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "median")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "median")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "mcquitty")
dendrogram &lt;- hclust1d(rnorm(100), method = "mcquitty")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "mcquitty")

# Faster replacements for
# stats::hclust(dist(rnorm(100))^2, method = "ward.D")
# Note that stats::hclust expects squared euclidean distance input for ward.D linkage
# While in case of hclust1d, 3 below calls result in the equivalent output
dendrogram &lt;- hclust1d(rnorm(100), method = "ward.D")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "ward.D")
dendrogram &lt;- hclust1d(dist(rnorm(100))^2, distance = TRUE, squared = TRUE, method = "ward.D")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "ward.D2")
dendrogram &lt;- hclust1d(rnorm(100), method = "ward.D2")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "ward.D2")

# Faster replacements for
# stats::hclust(dist(rnorm(100)), method = "single")
dendrogram &lt;- hclust1d(rnorm(100), method = "single")
dendrogram &lt;- hclust1d(dist(rnorm(100)), distance = TRUE, method = "single")

# A 1D-specific true median linkage
dendrogram &lt;- hclust1d(rnorm(100), method = "true_median")

# Plotting the resulting dendrogram
plot(dendrogram)

</code></pre>

<hr>
<h2 id='supported_dist.methods'>Supported Distance Methods</h2><span id='topic+supported_dist.methods'></span>

<h3>Description</h3>

<p>Lists all choices of a distance method currently supported in <code>hclust1d</code> via <code>stats::dist</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_dist.methods()
</code></pre>


<h3>Value</h3>

<p>A character vector with currently supported distance methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if ("minkowski" %in% supported_dist.methods()) {    # the condition under if evaluates to TRUE
   dendrogram &lt;- hclust1d(dist(rnorm(100), method = "minkowski", p = 3))
   plot(dendrogram)
} else {
   stop("Error: minkowski distance method not supported in hclust1d")
}

</code></pre>

<hr>
<h2 id='supported_methods'>Supported Linkage Methods</h2><span id='topic+supported_methods'></span>

<h3>Description</h3>

<p>Lists all choices of a linkage method currently supported in <code>hclust1d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_methods()
</code></pre>


<h3>Value</h3>

<p>A character vector with currently supported linkage methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if ("median" %in% supported_methods()) {    # the condition under if evaluates to TRUE
   dendrogram &lt;- hclust1d(rnorm(100), method = "median")
   plot(dendrogram)
} else {
   stop("Error: median linkage method not supported in hclust1d")
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
