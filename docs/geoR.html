<!DOCTYPE html><html><head><title>Help for package geoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.nlmP'><p>Adapts nlm for Constraints in the Parameter Values</p></a></li>
<li><a href='#as.geodata'><p>Converts an Object to the Class &quot;geodata&quot;</p></a></li>
<li><a href='#boxcox'><p>The Box-Cox Transformed Normal Distribution</p></a></li>
<li><a href='#boxcox.geodata'><p>Box-Cox transformation for geodata objects</p></a></li>
<li><a href='#boxcoxfit'><p>Parameter Estimation for the Box-Cox Transformation</p></a></li>
<li><a href='#ca20'><p>Calcium content in soil samples</p></a></li>
<li><a href='#camg'><p>Calcium and magnesium content in soil samples</p></a></li>
<li><a href='#coords.aniso'><p>Geometric Anisotropy Correction</p></a></li>
<li><a href='#coords2coords'><p>Operations on Coordinates</p></a></li>
<li><a href='#cov.spatial'><p>Computes Value of the Covariance Function</p></a></li>
<li><a href='#dup.coords'><p>Locates duplicated coordinates</p></a></li>
<li><a href='#elevation'><p>Surface Elevations</p></a></li>
<li><a href='#eyefit'><p>Interactive Variogram Estimation</p></a></li>
<li><a href='#gambia'><p>Gambia Malaria Data</p></a></li>
<li><a href='#geoR-defunct'><p>Defunct Functions in the Package geoR</p></a></li>
<li><a href='#geoR-internal'><p>geoR internal functions</p></a></li>
<li><a href='#globalvar'><p>Computes global variance</p></a></li>
<li><a href='#grf'><p>Simulation of Gaussian Random Fields</p></a></li>
<li><a href='#head'><p>Head observations in a regional confined aquifer</p></a></li>
<li><a href='#hist.krige.bayes'><p>Plots Sample from Posterior Distributions</p></a></li>
<li><a href='#hoef'><p>Data for spatial analysis of experiments</p></a></li>
<li><a href='#image.grf'><p>Image, Contour or Perspective Plot of Simulated Gaussian Random Field</p></a></li>
<li><a href='#image.krige.bayes'><p>Plots Results of the Predictive Distribution</p></a></li>
<li><a href='#image.kriging'><p>Image or Perspective Plot with Kriging Results</p></a></li>
<li><a href='#InvChisquare'><p>The (Scaled) Inverse Chi-Squared Distribution</p></a></li>
<li><a href='#isaaks'><p>Data from Isaaks and Srisvastava's book</p></a></li>
<li><a href='#jitterDupCoords'>
<p>Jitters (duplicated) coordinates.</p></a></li>
<li><a href='#kattegat'><p>Kattegat basin salinity data</p></a></li>
<li><a href='#krige.bayes'><p>Bayesian Analysis for Gaussian Geostatistical Models</p></a></li>
<li><a href='#krige.conv'><p>Spatial Prediction &ndash; Conventional Kriging</p></a></li>
<li><a href='#krweights'><p>Computes kriging weights</p></a></li>
<li><a href='#Ksat'><p>Saturated Hydraulic Conductivity</p></a></li>
<li><a href='#ksline'><p>Spatial Prediction &ndash; Conventional Kriging</p></a></li>
<li><a href='#landim1'><p>Data from Landim's book</p></a></li>
<li><a href='#legend.krige'><p>Add a legend to a image with kriging results</p></a></li>
<li><a href='#likfit'><p>Likelihood Based Parameter Estimation for Gaussian Random Fields</p></a></li>
<li><a href='#likfitBGCCM'><p>Fits the bivariate Gaussian</p>
common component geostatistical model</a></li>
<li><a href='#lines.variogram'><p>Line with a Empirical Variogram</p></a></li>
<li><a href='#lines.variogram.envelope'><p>Adds Envelopes Lines to a Variogram Plot</p></a></li>
<li><a href='#lines.variomodel'><p>Adds a Line with a Variogram Model to a Variogram Plot</p></a></li>
<li><a href='#lines.variomodel.grf'><p>Lines with True Variogram for Simulated Data</p></a></li>
<li><a href='#lines.variomodel.krige.bayes'><p>Adds a Bayesian Estimate of the Variogram to a Plot</p></a></li>
<li><a href='#lines.variomodel.likGRF'><p>Adds a Variogram Line to a Variogram Plot</p></a></li>
<li><a href='#lines.variomodel.variofit'><p>Adds a Line with a Fitted Variogram Model to a Variogram Plot</p></a></li>
<li><a href='#locations.inside'><p>Select prediction locations inside borders</p></a></li>
<li><a href='#loglik.GRF'><p>Log-Likelihood for a Gaussian Random Field</p></a></li>
<li><a href='#matern'><p>Computer Values of the Matern Correlation Function</p></a></li>
<li><a href='#names.geodata'><p>Lists names of the key elements of a geodata object</p></a></li>
<li><a href='#nearloc'><p>Near location to a point</p></a></li>
<li><a href='#output.control'><p> Defines output options for prediction functions</p></a></li>
<li><a href='#parana'><p>Rainfall Data from Parana State, Brasil</p></a></li>
<li><a href='#pars.limits'><p>Set limits for the parameter values</p></a></li>
<li><a href='#plot.geodata'><p>Exploratory Geostatistical Plots</p></a></li>
<li><a href='#plot.grf'><p>Plots Variograms for Simulated Data</p></a></li>
<li><a href='#plot.krige.bayes'><p>Plots Prior and/or Posterior Distributions</p></a></li>
<li><a href='#plot.proflik'><p>Plots Profile Likelihoods</p></a></li>
<li><a href='#plot.variog4'><p>Plot Directional Variograms</p></a></li>
<li><a href='#plot.variogram'><p>Plot Empirical Variogram</p></a></li>
<li><a href='#plot.xvalid'><p>Plot Cross-Validation Results</p></a></li>
<li><a href='#points.geodata'><p>Plots Spatial Locations and Data Values</p></a></li>
<li><a href='#polygrid'><p>Coordinates of Points Inside a Polygon</p></a></li>
<li><a href='#practicalRange'><p>Pratical range for correlation functions</p></a></li>
<li><a href='#pred_grid'><p>Generates a 2D Prediction Grid</p></a></li>
<li><a href='#predict.BGCCM'><p>Prediction for the bivariate Gaussian common component</p>
geostatistical model</a></li>
<li><a href='#print.BGCCM'><p>Prints an summary of of the output from likfitBGCCM.</p></a></li>
<li><a href='#proflik'><p>Computes Profile Likelihoods</p></a></li>
<li><a href='#read.geodata'><p>Reads and Converts Data to geoR Format</p></a></li>
<li><a href='#rongelap'><p>Radionuclide Concentrations on Rongelap Island</p></a></li>
<li><a href='#s100 and s121'><p>Simulated Data-Sets which Illustrate the Usage of the Package</p>
geoR</a></li>
<li><a href='#s256i'><p>Simulated Data-Set which Illustrate the Usage of krige.bayes</p></a></li>
<li><a href='#sample.geodata'><p>Sampling from geodata objects</p></a></li>
<li><a href='#sample.posterior'><p>Samples from the posterior distribution</p></a></li>
<li><a href='#sample.prior'><p>Sample the prior distribution</p></a></li>
<li><a href='#set.coords.lims'><p>Sets Limits to Scale Plots</p></a></li>
<li><a href='#SIC'><p>Spatial Interpolation Comparison data</p></a></li>
<li><a href='#soil250'><p>Soil chemistry properties data set</p></a></li>
<li><a href='#soja98'><p>Soya bean production and other variables in a uniformity trial</p></a></li>
<li><a href='#statistics.predictive'><p>Summary statistics from predictive distributions</p></a></li>
<li><a href='#subarea'><p>Selects a Subarea from a Geodata Object</p></a></li>
<li><a href='#subset.geodata'><p>Method for subsetting geodata objects</p></a></li>
<li><a href='#summary.geodata'><p>Summaries for geodata object</p></a></li>
<li><a href='#summary.likGRF'><p>Summarizes Parameter Estimation Results for Gaussian Random Fields</p></a></li>
<li><a href='#summary.variofit'><p>Summarize Results of Variogram Estimation</p></a></li>
<li><a href='#tce'><p>TCE concentrations in groundwater in a vertical cross section</p></a></li>
<li><a href='#trend.spatial'><p>Builds the Trend Matrix</p></a></li>
<li><a href='#varcov.spatial'><p>Computes Covariance Matrix and Related Results</p></a></li>
<li><a href='#varcovBGCCM'><p>Covariance matrix for the bivariate Gaussian</p>
common component geostatistical model</a></li>
<li><a href='#variofit'><p> Variogram Based Parameter Estimation</p></a></li>
<li><a href='#variog'><p>Compute Empirical Variograms</p></a></li>
<li><a href='#variog.mc.env'><p>Envelops for Empirical Variograms Based on Permutation</p></a></li>
<li><a href='#variog.model.env'><p>Envelops for Empirical Variograms Based on Model Parameters</p></a></li>
<li><a href='#variog4'><p>Computes Directional Variograms</p></a></li>
<li><a href='#wo'><p>Kriging example data from Webster and Oliver</p></a></li>
<li><a href='#wolfcamp'><p>Wolfcamp Aquifer Data</p></a></li>
<li><a href='#wrappers'><p>Wrappers for the C functions used in geoR</p></a></li>
<li><a href='#wrc'><p>Points of a water retention curve data set</p></a></li>
<li><a href='#xvalid'><p>Cross-validation by kriging</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.9-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Geostatistical Data</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Paulo Justiniano Ribeiro Jr [aut, cre] &lt;paulojus@ufpr.br&gt;,
        Peter Diggle [aut, cre] &lt;p.diggle@lancaster.ac.uk&gt;,
        Ole Christensen [ctb],
        Martin Schlather [ctb],
        Roger Bivand [ctb],
        Brian Ripley [ctb] </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paulo Justiniano Ribeiro Jr &lt;paulojus@ufpr.br&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), stats, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, sp, splancs, graphics, tcltk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scatterplot3d, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Geostatistical analysis including variogram-based, likelihood-based and Bayesian methods. Software companion for Diggle and Ribeiro (2007) &lt;<a href="https://doi.org/10.1007%2F978-0-387-48536-2">doi:10.1007/978-0-387-48536-2</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 21:50:33 UTC; paulojus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.nlmP'>Adapts nlm for Constraints in the Parameter Values</h2><span id='topic+.nlmP'></span>

<h3>Description</h3>

<p>This function adapts the <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+nlm">nlm</a></code> to allow for
constraints (upper and/or lower bounds) in the values of the parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.nlmP(objfunc, params, lower=rep(-Inf, length(params)),
      upper=rep(+Inf, length(params)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".nlmP_+3A_objfunc">objfunc</code></td>
<td>
<p>the function to be minimized.  </p>
</td></tr>
<tr><td><code id=".nlmP_+3A_params">params</code></td>
<td>
<p>starting values for the parameters.  </p>
</td></tr>
<tr><td><code id=".nlmP_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the variables. Defaults to <code class="reqn">-Inf</code>.  </p>
</td></tr>
<tr><td><code id=".nlmP_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the variables. Defaults to <code class="reqn">-Inf</code>.  </p>
</td></tr>
<tr><td><code id=".nlmP_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="stats.html#topic+nlm">nlm</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constraints on the parameter values are internally imposed by using
exponential, logarithmic, and logit transformation of the parameter
values.
</p>


<h3>Value</h3>

<p>The output is the same as for the function <code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Patrick E. Brown <a href="mailto:p.brown@lancaster.ac.uk">p.brown@lancaster.ac.uk</a>.<br />
Adapted and included in <span class="pkg">geoR</span> by <br />
Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>.  </p>

<hr>
<h2 id='as.geodata'>Converts an Object to the Class &quot;geodata&quot;</h2><span id='topic+as.geodata'></span><span id='topic+geodata'></span><span id='topic+as.geodata.default'></span><span id='topic+as.geodata.SpatialPointsDataFrame'></span><span id='topic+as.data.frame.geodata'></span><span id='topic+as.geodata.geodata.frame'></span><span id='topic+is.geodata'></span>

<h3>Description</h3>

<p>The default method converts a matrix or a data-frame
to an object of the
<code><a href="base.html#topic+class">class</a></code>  <code>"geodata"</code>.<br />
Objects of the class <code>"geodata"</code> are lists with two obligatory
components: <code>coords</code> and <code>data</code>.
Optional components are allowed and a typical example is a vector or
matrix with covariate(s) values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.geodata(obj, ...)

## Default S3 method:
as.geodata(obj, coords.col = 1:2, data.col = 3, data.names = NULL, 
                   covar.col = NULL, covar.names = "obj.names",
                   units.m.col = NULL, realisations = NULL,
                   na.action = c("ifany", "ifdata", "ifcovar", "none"),
                   rep.data.action, rep.covar.action, rep.units.action,
                   ...)

## S3 method for class 'geodata'
as.data.frame(x, ..., borders = TRUE)

## S3 method for class 'geodata.frame'
as.geodata(obj, ...)

## S3 method for class 'SpatialPointsDataFrame'
as.geodata(obj, data.col = 1, ...)

is.geodata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.geodata_+3A_obj">obj</code></td>
<td>
<p>a matrix or data-frame where each line corresponds to one
spatial location. It should contain values of 2D coordinates,
data and, optionally, covariate(s) value(s) at the locations.
A method for <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> is also provided.
It can also take an output of the function <code><a href="#topic+grf">grf</a></code>, see
DETAILS below. </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_coords.col">coords.col</code></td>
<td>
<p>a vector with the column numbers corresponding to the
spatial coordinates.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_data.col">data.col</code></td>
<td>
<p>a scalar or vector with column number(s) corresponding
to the data.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_data.names">data.names</code></td>
<td>
<p>optional. A string or vector of strings with names for
the data columns. Only valid if there is more than one column of
data. By default, takes the names from the original object.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_covar.col">covar.col</code></td>
<td>
<p>optional. A scalar or numeric vector
with the column number(s) corresponding to the covariate(s).
Alternativelly can be a character vector with the names of the
covariates. </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_covar.names">covar.names</code></td>
<td>
<p>optional. A string or vector of strings with the name(s) of
the covariates. By default take the names from the original object.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_units.m.col">units.m.col</code></td>
<td>
<p>optional. A scalar 
with the column number corresponding to the offset variable.
Alternativelly can be a character vector with the name of the
offset. This option is particularly relevant when using the package
<span class="pkg">geoRglm</span>. All values must be greater then zero. </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_realisations">realisations</code></td>
<td>
<p>optional. A vector indicating the realisation
number or a number indicating a column in <code>obj</code> with the
realisation indicator variable.
See <code>DETAILS</code> below.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_na.action">na.action</code></td>
<td>
<p>string defining action to be taken in the presence of
<code>NA</code>'s. The default option <code>"ifany"</code> excludes all points
for which there are <code>NA</code>'s in the data or covariates. The option <code>"ifdata"</code> excludes points
for which there are <code>NA</code>'s in the data. The default option <code>"ifcovar"</code> excludes all points
for which there are <code>NA</code>'s in the covariates. The option
<code>"none"</code> do not exclude points.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_rep.data.action">rep.data.action</code></td>
<td>
<p>a string or a function. Defines action to be taken when there is more than
one data at the same location. The default option <code>"none"</code>
keeps the repeated locations, if any. The option <code>"first"</code> retains
only the first data recorded at each location. Alternativelly a
function can be passed and it will be used. For instance if
<code>mean</code> is provided, the function will compute and return the average of
the data at coincident locations. The non-default
options will eliminate the repeated locations.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_rep.covar.action">rep.covar.action</code></td>
<td>
<p>idem to <code>rep.data.locations</code>, to be applied to
the covariates, if any. Defaults to
the same option set for <code>rep.data.locations</code>. </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_x">x</code></td>
<td>
<p>an object which is tested for the class <code>geodata</code>.</p>
</td></tr>
<tr><td><code id="as.geodata_+3A_rep.units.action">rep.units.action</code></td>
<td>
<p>a string or a function.
Defines action to be taken on the element <code>units.m</code>, if present
when there is more than
one data at the same location. The default option is the same
value set for <code>rep.data.action</code>.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_borders">borders</code></td>
<td>
<p>logical. If TRUE the element borders in the
<code>geodata</code>
object is set as an attribute of the data-frame.  </p>
</td></tr>
<tr><td><code id="as.geodata_+3A_...">...</code></td>
<td>
<p>values to be passed for the methods.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of the class <code>"geodata"</code> contain data for
geostatistical analysis using the package <span class="pkg">geoR</span>.
Storing data in this format facilitates the usage of the functions in <span class="pkg">geoR</span>.
However, conversion of objects to this class is not obligatory
to carry out the analysis.
</p>
<p><code>NA</code>'s are not allowed in the coordinates. By default the
respective rows will not be included in the output.
</p>
<p><b>Realisations</b><br />
Tipically geostatistical data correspond to a unique realisation of
the spatial process.
However, sometimes different &quot;realisations&quot; are possible.
For instance, if data are collected in the same area at different
points in time and independence between time points is assumed,
each time can be considered a different &quot;replicate&quot; or &quot;realisation&quot;
of the same process. The argument <code>realisations</code> takes a vector
indication the replication number and can be passed to other <span class="pkg">geoR</span>
functions as, for instance, <code><a href="#topic+likfit">likfit</a></code>.
</p>
<p>The data format is similar to the usual <code>geodata</code> format in
<span class="pkg">geoR</span>.
Suppose there are realisations (times) <code class="reqn">1, \ldots, J</code>
and for each realisations <code class="reqn">n_1, ..., n_j</code> observations are available.
The coordinates for different realisations
should be combined in a single <code class="reqn">n \times 2</code> object,
where <code class="reqn">n=n_1 + \ldots + n_J</code>.
Similarly for the data vector and covariates (if any).
</p>
<p><b>grf objects</b><br />
If an object of the class <code>grf</code> is provided the functions just
extracts the elements <code>coords</code> and <code>data</code> of this object. 
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>"geodata"</code> which is a list
with two obligatory components (coords and data)
and other optional components:
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code>  matrix where <code class="reqn">n</code> is the number
of spatial locations.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a vector of length <code class="reqn">n</code>, for the univariate case or,
an <code class="reqn">n \times v</code> matrix or data-frame for the multivariate case,
where <code class="reqn">v</code> is the number of variables.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>a vector of length <code class="reqn">n</code> or
an <code class="reqn">n \times p</code> matrix with covariate(s) values,
where <code class="reqn">p</code> is the number of covariates. Only returned if
covariates are provided.  </p>
</td></tr>
<tr><td><code>realisations</code></td>
<td>
<p>a vector on size <code class="reqn">n</code> with the replication
number. Only returned if argument realisations is provided.  </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.geodata">read.geodata</a></code> for reading data from an
<em>ASCII</em> file and <code><a href="base.html#topic+list">list</a></code> for general information on lists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## converting the data-set "topo" from the package MASS (VR's bundle)
## to the geodata format:
if(require(MASS)){
topo
topogeo &lt;- as.geodata(topo)
names(topogeo)
topogeo
}

## End(Not run)
</code></pre>

<hr>
<h2 id='boxcox'>The Box-Cox Transformed Normal Distribution</h2><span id='topic+rboxcox'></span><span id='topic+dboxcox'></span>

<h3>Description</h3>

<p>Functions related with the Box-Cox family of transformations.
Density and random generation for the Box-Cox transformed normal
distribution with mean
equal to <code>mean</code> and standard deviation equal to <code>sd</code>, <em>in the normal scale</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rboxcox(n, lambda, lambda2 = NULL, mean = 0, sd = 1)

dboxcox(x, lambda, lambda2 = NULL, mean = 0, sd = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox_+3A_lambda">lambda</code></td>
<td>
<p>numerical value(s) for the transformation parameter
<code class="reqn">\lambda</code>.  </p>
</td></tr>
<tr><td><code id="boxcox_+3A_lambda2">lambda2</code></td>
<td>
<p>logical or numerical value(s) of the additional transformation
(see DETAILS below). Defaults to <code>NULL</code>.  </p>
</td></tr>
<tr><td><code id="boxcox_+3A_n">n</code></td>
<td>
<p>number of observations to be generated.  </p>
</td></tr>
<tr><td><code id="boxcox_+3A_x">x</code></td>
<td>
<p>a vector of quantiles (<code>dboxcox</code>) or an output of
<code>boxcoxfit</code> (<code>print</code>, <code>plot</code>, <code>lines</code>).  </p>
</td></tr>
<tr><td><code id="boxcox_+3A_mean">mean</code></td>
<td>
<p>a vector of mean values at the normal scale.  </p>
</td></tr>
<tr><td><code id="boxcox_+3A_sd">sd</code></td>
<td>
<p>a vector of standard deviations at the normal scale.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote <code class="reqn">Y</code> the variable at the original scale and <code class="reqn">Y'</code> the
transformed variable. The Box-Cox transformation is defined by:
</p>
<p style="text-align: center;"><code class="reqn">Y' = \left\{ \begin{array}{ll}
    log(Y)
    \mbox{ , if $\lambda = 0$} \cr
    \frac{Y^\lambda - 1}{\lambda} \mbox{ ,  otherwise}
    \end{array} \right.</code>
</p>
<p>. 
</p>
<p>An additional shifting parameter <code class="reqn">\lambda_2</code> can be
included in which case the transformation is given by: 
</p>
<p style="text-align: center;"><code class="reqn">Y' = \left\{
    \begin{array}{ll}
    log(Y + \lambda_2)
    \mbox{ , $\lambda = 0$ } \cr
    \frac{(Y + \lambda_2)^\lambda - 1}{\lambda} \mbox{ ,  otherwise}
    \end{array} \right.</code>
</p>
<p>.
</p>
<p>The function <code>rboxcox</code> samples <code class="reqn">Y'</code> from the normal distribution using
the function <code><a href="stats.html#topic+rnorm">rnorm</a></code> and backtransform the values according to the
equations above to obtain values of <code class="reqn">Y</code>.
If necessary the back-transformation truncates the values such that
<code class="reqn">Y' \geq \frac{1}{\lambda}</code> results in
<code class="reqn">Y = 0</code> in the original scale.
Increasing the value of the mean and/or reducing the variance might help to avoid truncation.
</p>


<h3>Value</h3>

<p>The functions returns the following results:
</p>
<table>
<tr><td><code>rboxcox</code></td>
<td>
<p>a vector of random deviates.  </p>
</td></tr>
<tr><td><code>dboxcox</code></td>
<td>
<p>a vector of densities.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Box, G.E.P. and Cox, D.R.(1964) An analysis of transformations. JRSS B
<b>26</b>:211&ndash;246.
</p>


<h3>See Also</h3>

<p>The parameter estimation function is <code><a href="#topic+boxcoxfit">boxcoxfit</a></code>.
Other packages has BoxCox related functions such as <code><a href="MASS.html#topic+boxcox">boxcox</a></code> in the package <span class="pkg">MASS</span> and
the function <code>box.cox</code> in the package &lsquo;<span class="samp">&#8288;car&#8288;</span>&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating data
simul &lt;- rboxcox(100, lambda=0.5, mean=10, sd=2)
##
## Comparing models with different lambdas,
## zero  means and unit variances
curve(dboxcox(x, lambda=-1), 0, 8)
for(lambda in seq(-.5, 1.5, by=0.5))
  curve(dboxcox(x, lambda), 0, 8, add = TRUE)
</code></pre>

<hr>
<h2 id='boxcox.geodata'>Box-Cox transformation for geodata objects</h2><span id='topic+boxcox.geodata'></span>

<h3>Description</h3>

<p>Method for Box-Cox transformation for objects of the class
<code>geodata</code> assuming the data are independent. 
Computes and optionally plots profile log-likelihoods for the parameter of the Box-Cox simple power transformation <code class="reqn">y^lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
boxcox(object, trend = "cte", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcox.geodata_+3A_object">object</code></td>
<td>
<p>an object of the class geodata. See <code><a href="#topic+as.geodata">as.geodata</a></code>. </p>
</td></tr>
<tr><td><code id="boxcox.geodata_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model. See
<code><a href="#topic+trend.spatial">trend.spatial</a></code> for further details.
Defaults to <code>"cte"</code>.  </p>
</td></tr>
<tr><td><code id="boxcox.geodata_+3A_...">...</code></td>
<td>
<p>arguments to be passed for the function
<code><a href="MASS.html#topic+boxcox">boxcox</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper for the function <code><a href="MASS.html#topic+boxcox">boxcox</a></code>
facilitating its usage with <code>geodata</code> objects.
</p>
<p>Notice this assume independent observations which is typically
not the case for <code>geodata</code> objects.
</p>


<h3>Value</h3>

<p>A list of the <code>lambda</code> vector and the computed profile log-likelihood vector, invisibly if the result is plotted.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+boxcox">boxcox</a></code> for
parameter estimation results for independent data and
<code><a href="#topic+likfit">likfit</a></code> for parameter estimation
within the geostatistical model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(MASS)){
boxcox(wolfcamp)

data(ca20)
boxcox(ca20, trend = ~altitude)
}
</code></pre>

<hr>
<h2 id='boxcoxfit'>Parameter Estimation for the Box-Cox Transformation</h2><span id='topic+boxcoxfit'></span><span id='topic+print.boxcoxfit'></span><span id='topic+plot.boxcoxfit'></span><span id='topic+lines.boxcoxfit'></span><span id='topic+.negloglik.boxcox'></span>

<h3>Description</h3>

<p>Parameter estimation and plotting of the results for the
Box-Cox transformed normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcoxfit(object, xmat, lambda, lambda2 = NULL, add.to.data = 0, ...)

## S3 method for class 'boxcoxfit'
print(x, ...)

## S3 method for class 'boxcoxfit'
plot(x, hist = TRUE, data = eval(x$call$object), ...)

## S3 method for class 'boxcoxfit'
lines(x, data = eval(x$call$object), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxcoxfit_+3A_object">object</code></td>
<td>
<p>a vector with the data.  </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_xmat">xmat</code></td>
<td>
<p>a matrix with covariates values. Defaults to <code>rep(1,
      length(y))</code>.  </p>
</td></tr> 
<tr><td><code id="boxcoxfit_+3A_lambda">lambda</code></td>
<td>
<p>numerical value(s) for the transformation parameter
<code class="reqn">\lambda</code>. 
Used as the initial value in the function for parameter estimation.
If not provided default values are assumed. If multiple values are passed
the one with highest likelihood is used as initial value. </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_lambda2">lambda2</code></td>
<td>
<p>logical or numerical value(s) of the additional transformation
(see DETAILS below). Defaults to <code>NULL</code>.
If <code>TRUE</code> this parameter is also estimated and the initial
value is set to the absolute value of the minimum data.
A numerical value is provided it is used as the initial
value. Multiple values are allowed as for <code>lambda</code>.  </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_add.to.data">add.to.data</code></td>
<td>
<p>a constant value to be added to the data.  </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_x">x</code></td>
<td>
<p>a list, typically an output of the function
<code>boxcoxfit</code>.  </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_hist">hist</code></td>
<td>
<p>logical indicating whether histograms should to be
plotted.  </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_data">data</code></td>
<td>
<p>data values. </p>
</td></tr>
<tr><td><code id="boxcoxfit_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed to the minimization
function <code><a href="stats.html#topic+optim">optim</a></code> (<code>boxcoxfit</code>), <code><a href="graphics.html#topic+hist">hist</a></code>
(<code>plot</code>) or <code><a href="graphics.html#topic+curve">curve</a></code> (<code>lines</code>).  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions returns the following results:
</p>
<table>
<tr><td><code>boxcoxfit</code></td>
<td>
<p>a list with estimated  parameters and results on
the numerical minimization.  </p>
</td></tr>
<tr><td><code>print.boxcoxfit</code></td>
<td>
<p>print estimated parameters. No values
returned.  </p>
</td></tr>
<tr><td><code>plot.boxcoxfit</code></td>
<td>
<p>plots histogram of the data (optional) and
the model.  No values returned.  This function is only valid if
covariates are not included in <code>boxcoxfit</code>. </p>
</td></tr>
<tr><td><code>lines.boxcoxfit</code></td>
<td>
<p>adds a line with the fitted model to the
current plot. No values returned.  This function is only valid if
covariates are not included in <code>boxcoxfit</code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Box, G.E.P. and Cox, D.R.(1964) An analysis of transformations. JRSS B
<b>26</b>:211&ndash;246.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rboxcox">rboxcox</a></code> and  <code><a href="#topic+dboxcox">dboxcox</a></code> for the
expression and more on the Box-Cox transformation.
Parameter(s) are estimated using the minimization function <code><a href="stats.html#topic+optim">optim</a></code>.
Other packages have BoxCox related functions such as <code><a href="MASS.html#topic+boxcox">boxcox</a></code> in the package <span class="pkg">MASS</span> and
the function <code>box.cox</code> in the package &lsquo;<span class="samp">&#8288;car&#8288;</span>&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(384)
## Simulating data
simul &lt;- rboxcox(100, lambda=0.5, mean=10, sd=2)
## Finding the ML estimates
ml &lt;- boxcoxfit(simul)
ml
## Ploting histogram and fitted model
plot(ml)
##
## Comparing models with different lambdas,
## zero  means and unit variances
curve(dboxcox(x, lambda=-1), 0, 8)
for(lambda in seq(-.5, 1.5, by=0.5))
  curve(dboxcox(x, lambda), 0, 8, add = TRUE)
##
## Another example, now estimating lambda2
##
simul &lt;- rboxcox(100, lambda=0.5, mean=10, sd=2)
ml &lt;- boxcoxfit(simul, lambda2 = TRUE)
ml
plot(ml)
##
## An example with a regression model
##
boxcoxfit(object = trees[,3], xmat = trees[,1:2])
</code></pre>

<hr>
<h2 id='ca20'>Calcium content in soil samples</h2><span id='topic+ca20'></span>

<h3>Description</h3>

<p>This data set contains the calcium content measured in soil samples
taken from the 0-20cm layer at 178 locations within a certain study area divided in three
sub-areas. The elevation at each location was also recorded.
</p>
<p>The first region is typically flooded during the rain season and not
used as an experimental area. The calcium levels would represent
the natural content in the region. The second region has received
fertilisers a while ago and is typically occupied by rice fields.
The third region has received fertilisers recently and is frequently
used as an experimental area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ca20)</code></pre>


<h3>Format</h3>

<p>The object <code>ca20</code> belongs to the class <code>geodata</code>
and is a list
with the following elements:
</p>
    
<dl>
<dt><code>coords</code></dt><dd><p>a matrix with the coordinates of the soil samples.  </p>
</dd>
<dt><code>data</code></dt><dd><p>calcium content measured in <code class="reqn">mmol_c/dm^3</code>.  </p>
</dd>
<dt><code>covariate</code></dt><dd><p>a data-frame with the covariates
</p>

<dl>
<dt><code>altitude</code></dt><dd><p>a vector with the elevation of each
sampling location, in meters (<code class="reqn">m</code>).</p>
</dd>
<dt><code>area</code></dt><dd><p>a factor indicating the sub area to which the
locations belongs.</p>
</dd>
</dl>

</dd>
<dt><code>borders</code></dt><dd><p>a matrix with the coordinates defining the
borders of the area.  </p>
</dd>
<dt><code>reg1</code></dt><dd><p>a matrix with the coordinates of the limits of
the sub-area 1. </p>
</dd>
<dt><code>reg1</code></dt><dd><p>a matrix with the coordinates of the limits of
the sub-area 2. </p>
</dd>
<dt><code>reg1</code></dt><dd><p>a matrix with the coordinates of the limits of
the sub-area 3. </p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was collected by researchers from PESAGRO and EMBRAPA-Solos, Rio
de Janeiro, Brasil
and provided by Dra. Maria Cristina Neves de Oliveira.
</p>
<p>Capeche, C.L.; Macedo, J.R.; Manzatto, H.R.H.; Silva, E.F. (1997)
Caracterização pedológica da fazenda Angra - PESAGRO/RIO -
Estação experimental de Campos (RJ). (compact disc).
In: Congresso BRASILEIRO de Ciência do Solo. 26.,
Informação, globalização, uso do solo; Rio de Janeiro, 1997.
trabalhos. Rio de Janeiro: Embrapa/SBCS.
</p>


<h3>References</h3>

<p>Oliveira, M.C.N. (2003) <em>Métodos de estimação de parâmetros
em modelos geoestatísticos com diferentes estruturas de
covariâncias: uma aplicação ao teor de cálcio no solo.</em>
Tese de Doutorado, ESALQ/USP/Brasil. 
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>

<hr>
<h2 id='camg'>Calcium and magnesium content in soil samples</h2><span id='topic+camg'></span>

<h3>Description</h3>

<p>This data set contains the calcium content measured in soil samples
taken from the 0-20cm layer at 178 locations within a certain study area divided in three
sub-areas. The elevation at each location was also recorded.
</p>
<p>The first region is tipically flooded during the rain season and not
used as an experimental area. The calcium levels would represent
the natural content in the region. The second region has received
fertilizers a while ago and is tipically occupied by rice fields.
The third region has recieved fertilizers recently and is frequently
used as an experimental area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(camg)</code></pre>


<h3>Format</h3>

<p>A data frame with 178 observations on the following 10 variables.
</p>

<dl>
<dt>east</dt><dd><p>east-west coordinates, in meters.</p>
</dd>
<dt>north</dt><dd><p>north-south coordinates, in meters.</p>
</dd>
<dt>elevation</dt><dd><p>elevation, in meters</p>
</dd>
<dt>region</dt><dd><p>a factor where numbers indicate different sub-regions
within the area</p>
</dd>
<dt>ca020</dt><dd><p>calcium content in the 0-20cm soil layer, measured in <code class="reqn">mmol_c/dm^3</code>.  </p>
</dd>
<dt>mg020</dt><dd><p>calcium content in the 0-20cm soil layer, measured in <code class="reqn">mmol_c/dm^3</code>.  </p>
</dd>
<dt>ctc020</dt><dd><p>calcium content in the 0-20cm soil layer.  </p>
</dd>
<dt>ca2040</dt><dd><p>calcium content in the 20-40cm soil layer, measured in <code class="reqn">mmol_c/dm^3</code>.  </p>
</dd>
<dt>mg2040</dt><dd><p>calcium content in the 20-40cm soil layer, measured in <code class="reqn">mmol_c/dm^3</code>.  </p>
</dd>
<dt>ctc2040</dt><dd><p>calcium content in the 20-40cm soil layer.  </p>
</dd>
</dl>



<h3>Details</h3>

<p>More details about this data-set, including coordinates of the region
and sub-region borders
can be found in the data object <code><a href="#topic+ca20">ca20</a></code>.
</p>


<h3>Source</h3>

<p>The data was collected by researchers from PESAGRO and EMBRAPA-Solos, Rio
de Janeiro, Brasil
and provided by Dra. Maria Cristina Neves de Oliveira.
</p>
<p>Capeche, C.L.; Macedo, J.R.; Manzatto, H.R.H.; Silva, E.F. (1997)
Caracterização pedológica da fazenda Angra - PESAGRO/RIO -
Estação experimental de Campos (RJ). (compact disc).
In: Congresso BRASILEIRO de Ciência do Solo. 26.,
Informação, globalização, uso do solo; Rio de Janeiro, 1997.
trabalhos. Rio de Janeiro: Embrapa/SBCS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(camg[-(1:2),])
mg20 &lt;- as.geodata(camg, data.col=6)
plot(mg20)
points(mg20)
</code></pre>

<hr>
<h2 id='coords.aniso'>Geometric Anisotropy Correction</h2><span id='topic+coords.aniso'></span>

<h3>Description</h3>

<p>Transforms or back-transforms a set of coordinates according to
the geometric anisotropy parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords.aniso(coords, aniso.pars, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords.aniso_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the coordinates
to be transformed.  </p>
</td></tr>
<tr><td><code id="coords.aniso_+3A_aniso.pars">aniso.pars</code></td>
<td>
<p>a vector with two elements, <code class="reqn">\psi_A</code> and
<code class="reqn">\psi_R</code>,  the <em>anisotropy
angle</em> and the <em>anisotropy ratio</em>, respectively. Notice that the
parameters must be provided in this order. 
See section <code>DETAILS</code> below for more information on anisotropy parameters.  </p>
</td></tr>
<tr><td><code id="coords.aniso_+3A_reverse">reverse</code></td>
<td>
<p>logical. Defaults to <code>FALSE</code>. If <code>TRUE</code> the reverse
transformation is performed.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geometric anisotropy is defined by two parameters:
</p>

<dl>
<dt>Anisotropy angle</dt><dd><p>defined here as the azimuth angle of the
direction with greater spatial continuity, i.e. the angle between the
<em>y-axis</em> and the direction with the maximum range.  </p>
</dd>
<dt>Anisotropy ratio</dt><dd><p>defined here as the ratio between the ranges
of the directions with greater and smaller continuity, i.e. the ratio
between maximum and minimum ranges. Therefore, its value is always
greater or equal to one.  </p>
</dd>
</dl>

<p>If <code>reverse = FALSE</code> (the default) the
coordinates are transformed  from the <em>anisotropic space</em> to the <em>isotropic
space</em>.
The transformation consists in multiplying the original
coordinates by a rotation matrix <code class="reqn">R</code>
and a
shrinking matrix <code class="reqn">T</code>, as follows:
</p>
<p style="text-align: center;"><code class="reqn">X_m = X  R T , </code>
</p>

<p>where <code class="reqn">X_m</code> is a matrix with the modified coordinates (isotropic
space) , <code class="reqn">X</code> is a matrix with original coordinates (anisotropic
space), <code class="reqn">R</code> rotates coordinates according to the anisotropy angle
<code class="reqn">\psi_A</code> and <code class="reqn">T</code> shrinks the coordinates according to
the anisotropy ratio <code class="reqn">\psi_R</code>.
</p>
<p>If <code>reverse = TRUE</code>, the back-transformation is performed, i.e.
transforming the coordinates from the <em>isotropic space</em> to the
<em>anisotropic  space</em> by computing:
</p>
<p style="text-align: center;"><code class="reqn">X = X_m (R T)^{-1}</code>
</p>



<h3>Value</h3>

<p>An <code class="reqn">n \times 2</code> matrix with the transformed coordinates.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a> <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly = TRUE)
par(mfrow=c(3,2))
par(mar=c(2.5,0,0,0))
par(mgp=c(2,.5,0))
par(pty="s")
## Defining a set of coordinates
coords &lt;- expand.grid(seq(-1, 1, l=3), seq(-1, 1, l=5))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coords[,1], coords[,2], 1:nrow(coords))
## Transforming coordinates according to some anisotropy parameters
coordsA &lt;- coords.aniso(coords, aniso.pars=c(0, 2))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coordsA[,1], coordsA[,2], 1:nrow(coords))
##
coordsB &lt;- coords.aniso(coords, aniso.pars=c(pi/2, 2))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coordsB[,1], coordsB[,2], 1:nrow(coords))
##
coordsC &lt;- coords.aniso(coords, aniso.pars=c(pi/4, 2))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coordsC[,1], coordsC[,2], 1:nrow(coords))
##
coordsD &lt;- coords.aniso(coords, aniso.pars=c(3*pi/4, 2))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coordsD[,1], coordsD[,2], 1:nrow(coords))
##
coordsE &lt;- coords.aniso(coords, aniso.pars=c(0, 5))
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type="n")
text(coordsE[,1], coordsE[,2], 1:nrow(coords))
##
par(op)
</code></pre>

<hr>
<h2 id='coords2coords'>Operations on Coordinates</h2><span id='topic+coords2coords'></span><span id='topic+zoom.coords'></span><span id='topic+zoom.coords.default'></span><span id='topic+zoom.coords.geodata'></span><span id='topic+rect.coords'></span>

<h3>Description</h3>

<p>Functions for shifting, zooming and envolving rectangle of a set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords2coords(coords, xlim, ylim, xlim.ori, ylim.ori)

zoom.coords(x, ...)

## Default S3 method:
zoom.coords(x, xzoom, yzoom, xlim.ori, ylim.ori, xoff=0, yoff=0, ...)

## S3 method for class 'geodata'
zoom.coords(x, ...)

rect.coords(coords, xzoom = 1, yzoom=xzoom, add.to.plot=TRUE,
            quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords2coords_+3A_coords">coords</code>, <code id="coords2coords_+3A_x">x</code></td>
<td>
<p>two column matrix or data-frame with coordinates.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_xlim">xlim</code></td>
<td>
<p>range of the new x-coordinates. </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_ylim">ylim</code></td>
<td>
<p>range of the new y-coordinates. </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_xlim.ori">xlim.ori</code></td>
<td>
<p>optional. Range of the original x-coordinates, by
default the range of the original x-coordinates.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_ylim.ori">ylim.ori</code></td>
<td>
<p>optional. Range of the original y-coordinates, by
default the range of the original y-coordinates.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_xzoom">xzoom</code></td>
<td>
<p>scalar, expanding factor in the x-direction.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_yzoom">yzoom</code></td>
<td>
<p>scalar, expanding factor in the y-direction.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_xoff">xoff</code></td>
<td>
<p>scalar, shift in the x-direction.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_yoff">yoff</code></td>
<td>
<p>scalar, shift in the y-direction.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the retangle is added to
the current plot.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_quiet">quiet</code></td>
<td>
<p>logical, none is returned.  </p>
</td></tr>
<tr><td><code id="coords2coords_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+rect">rect</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coords2coords and zoom.coords</code></td>
<td>
<p>return an object of the same type as given in the argument
<code>coords</code> with the transformed coordinates.  </p>
</td></tr>
<tr><td><code>rect.coords</code></td>
<td>
<p>returns a matrix with the 4 coordinates of
the rectangle defined by the coordinates.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subarea">subarea</a></code>, <code><a href="graphics.html#topic+rect">rect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- matrix(c(4,6,6,4,2,2,4,4), nc=2)
foo1 &lt;- zoom.coords(foo, 2)
foo1
foo2 &lt;- coords2coords(foo, c(6,10), c(6,10))
foo2
plot(1:10, 1:10, type="n")
polygon(foo)
polygon(foo1, lty=2)
polygon(foo2, lwd=2)
arrows(foo[,1], foo[,2],foo1[,1],foo1[,2], lty=2)
arrows(foo[,1], foo[,2],foo2[,1],foo2[,2])
legend("topleft", 
       c("foo", "foo1 (zoom.coords)", "foo2 (coords2coords)"), lty=c(1,2,1), lwd=c(1,1,2))

## "zooming" part of The Gambia map
gb &lt;- gambia.borders/1000
gd &lt;- gambia[,1:2]/1000
plot(gb, ty="l", asp=1, xlab="W-E (kilometres)", ylab="N-S (kilometres)")
points(gd, pch=19, cex=0.5)
r1b &lt;- gb[gb[,1] &lt; 420,]
rc1 &lt;- rect.coords(r1b, lty=2)

r1bn &lt;- zoom.coords(r1b, 1.8, xoff=90, yoff=-90)
rc2 &lt;- rect.coords(r1bn, xz=1.05)
segments(rc1[c(1,3),1],rc1[c(1,3),2],rc2[c(1,3),1],rc2[c(1,3),2], lty=3)

lines(r1bn)
r1d &lt;- gd[gd[,1] &lt; 420,]
r1dn &lt;- zoom.coords(r1d, 1.7, xlim.o=range(r1b[,1],na.rm=TRUE), ylim.o=range(r1b[,2], na.rm=TRUE), 
                    xoff=90, yoff=-90)
points(r1dn, pch=19, cex=0.5)
text(450,1340, "Western Region", cex=1.5)
</code></pre>

<hr>
<h2 id='cov.spatial'>Computes Value of the Covariance Function</h2><span id='topic+cov.spatial'></span><span id='topic+.cor.number'></span><span id='topic+.check.cov.model'></span><span id='topic+geoRCovModels'></span>

<h3>Description</h3>

<p>Computes the covariances for pairs variables, given the separation
distance of their locations.
Options for different correlation functions are available.
The results can be seen as a change of metric,
from the <em>Euclidean distances</em> to <em>covariances</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.spatial(obj, cov.model= "matern",
            cov.pars=stop("no cov.pars argument provided"),
            kappa = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.spatial_+3A_obj">obj</code></td>
<td>
<p>a numeric object (vector or matrix), typically with values
of distances between pairs of spatial locations.  </p>
</td></tr>
<tr><td><code id="cov.spatial_+3A_cov.model">cov.model</code></td>
<td>
<p>string indicating the type of the correlation
function. Available choices are: &quot;matern&quot;, &quot;exponential&quot;, &quot;gaussian&quot;,
&quot;spherical&quot;, &quot;circular&quot;, &quot;cubic&quot;, &quot;wave&quot;,
&quot;power&quot;, &quot;powered.exponential&quot;, &quot;cauchy&quot;, &quot;gencauchy&quot;, 
&quot;gneiting&quot;, &quot;gneiting.matern&quot;, &quot;pure.nugget&quot;.
See section <code>DETAILS</code> for available options and expressions of the correlation
functions.  </p>
</td></tr>
<tr><td><code id="cov.spatial_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector with 2 elements or an <code class="reqn">ns \times 2</code> matrix with
the covariance parameters. The first element (if a vector) or first
column (if a matrix) corresponds to the variance parameter <code class="reqn">\sigma^2</code>. The second element or column corresponds to the range parameter
<code class="reqn">\phi</code> of the correlation function.
If a matrix is provided, each row corresponds to
the parameters of one <em>spatial structure</em> (see DETAILS below).
</p>
</td></tr>
<tr><td><code id="cov.spatial_+3A_kappa">kappa</code></td>
<td>
<p>numerical value for the additional smoothness parameter of the
correlation function.
Only required by the following correlation
functions: <code>"matern"</code>, <code>"powered.exponential"</code>,
<code>"cauchy"</code>, <code>"gencauchy"</code> and <code>"gneiting.matern"</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance functions return the value of the covariance
<code class="reqn">C(h)</code> between a pair variables located at points separated by the
distance <code class="reqn">h</code>.
The covariance function can be written as a product of a variance
parameter <code class="reqn">\sigma^2</code> times a positive definite
<em>correlation function</em> <code class="reqn">\rho(h)</code>:
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2 \rho(h).</code>
</p>

<p>The expressions of the covariance functions available in <span class="pkg">geoR</span>
are given below. We recommend the <em>LaTeX</em> (and/or the corresponding
<em>.dvi</em>, <em>.pdf</em> or <em>.ps</em>) version of this document for
better visualization of the formulas.
</p>
<p>Denote <code class="reqn">\phi</code> the basic parameter of the correlation
function and name it the <em>range parameter</em>.
Some of the correlation functions will have an extra parameter
<code class="reqn">\kappa</code>, the <em>smoothness parameter</em>.
<code class="reqn">K_\kappa(x)</code> denotes the modified Bessel
function of the third kind of order <code class="reqn">\kappa</code>. See
documentation of the function <code><a href="base.html#topic+besselK">besselK</a></code> for further details.
In the equations below the functions are valid for  <code class="reqn">\phi&gt;0</code> and <code class="reqn">\kappa&gt;0</code>, unless stated otherwise.
</p>
<p><b>cauchy</b> <br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = [1+(\frac{h}{\phi})^2]^{-\kappa}</code>
</p>

<p><b>gencauchy (generalised Cauchy)</b> <br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = [1+(\frac{h}{\phi})^{\kappa_{2}}]^{-{\kappa_1}/{\kappa_2}},
    \kappa_1 &gt; 0, 0 &lt; \kappa_2 \leq 2 </code>
</p>

<p><b>circular</b><br />
Let <code class="reqn">\theta = \min(\frac{h}{\phi},1)</code> and
</p>
<p style="text-align: center;"><code class="reqn">g(h)= 2\frac{(\theta\sqrt{1-\theta^2}+
      \sin^{-1}\sqrt{\theta})}{\pi}.</code>
</p>

<p>Then, the circular model is given by:
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \left\{ \begin{array}{ll}
    1 - g(h)  \mbox{ , if $h &lt; \phi$}\cr
    0    \mbox{ , otherwise}
    \end{array} \right.</code>
</p>

<p><b>cubic</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \left\{ \begin{array}{ll}
    1 - [7(\frac{h}{\phi})^2 - 8.75(\frac{h}{\phi})^3 +
    3.5(\frac{h}{\phi})^5-0.75(\frac{h}{\phi})^7] \mbox{ , if $h&lt;\phi$} \cr
    0  \mbox{ , otherwise.}
    \end{array} \right.</code>
</p>

<p><b>gaussian</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \exp[-(\frac{h}{\phi})^2]</code>
</p>
 
<p><b>exponential</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \exp(-\frac{h}{\phi})</code>
</p>

<p><b>matern</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) =
    \frac{1}{2^{\kappa-1}\Gamma(\kappa)}(\frac{h}{\phi})^\kappa
    K_{\kappa}(\frac{h}{\phi})</code>
</p>
 
<p><b>spherical</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \left\{ \begin{array}{ll}
    1 - 1.5\frac{h}{\phi} + 0.5(\frac{h}{\phi})^3
    \mbox{ , if $h$ &lt; $\phi$} \cr
    0    \mbox{ ,  otherwise}
    \end{array} \right.</code>
</p>

<p><b>power (and linear)</b><br />
The parameters of the this model
<code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code> can not be  
interpreted as <em>partial sill</em> and <em>range</em>
as for the other models.
This model implies an unlimited dispersion and,
therefore, has no sill and corresponds to a process which is only
intrinsically stationary.
The variogram function is given by:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = \sigma^2 {h}^{\phi} \mbox{ , } 0 &lt; \phi &lt; 2,
    \sigma^2 &gt; 0</code>
</p>
 
<p>Since the corresponding process is not second order stationary the
covariance and correlation functions are not defined.
For internal calculations the <em>geoR</em>
functions uses the fact the this model possesses locally
stationary representations with covariance functions of the form:
</p>
<p style="text-align: center;"><code class="reqn">C_(h) = \sigma^2 (A - h^\phi)</code>
</p>
<p> ,
where <code class="reqn">A</code> is a suitable constant as given in
Chiles &amp; Delfiner (pag. 511, eq. 7.35).
</p>
<p>The <em>linear</em> model corresponds a particular case with
<code class="reqn">\phi = 1</code>.
</p>
<p><b>powered.exponential (or stable)</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \exp[-(\frac{h}{\phi})^\kappa] \mbox{ , } 0 &lt; \kappa
    \leq 2</code>
</p>

<p><b>gneiting</b><br />
</p>
<p style="text-align: center;"><code class="reqn">C(h)=\left(1 + 8 sh + 25 (sh)^2 + 32
    (sh)^3\right)(1-sh)^8 1_{[0,1]}(sh)</code>
</p>

<p>where
<code class="reqn">s=0.301187465825</code>.
For further details see documentation of the function
<code>CovarianceFct</code> 
in the package
<code>RandomFields</code> from where we extract the following :<br />
<em>It is an alternative to the <code>gaussian</code> model since
its graph is visually hardly distinguishable from the graph of
the Gaussian model, but possesses neither the mathematical and nor the
numerical disadvantages of the Gaussian model.</em><br />
</p>
<p><b>gneiting.matern</b><br />
Let <code class="reqn">\alpha=\phi\kappa_2</code>, <code class="reqn">\rho_m(\cdot)</code> denotes the <code class="reqn">\mbox{Mat\'{e}rn}</code> model
and <code class="reqn">\rho_g(\cdot)</code> the Gneiting model. Then the
<code class="reqn">\mbox{Gneiting-Mat\'{e}rn}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \rho_g(h|\phi=\alpha) \,
    \rho_m(h|\phi=\phi,\kappa=\kappa_1)</code>
</p>
<p><br />
</p>
<p><b>wave</b><br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = \frac{\phi}{h}\sin(\frac{h}{\phi})</code>
</p>
 <p><br />
</p>
<p><b>pure.nugget</b> <br />
</p>
<p style="text-align: center;"><code class="reqn">\rho(h) = k</code>
</p>
<p><br />
where k is a constant value. This model corresponds to
no spatial correlation.
</p>
<p><b>Nested models</b>
Models with several structures
usually called <em>nested models</em>
in the geostatistical literature are also allowed.
In this case the argument <code>cov.pars</code> takes a matrix and
<code>cov.model</code> and <code>lambda</code> can either have length equal to
the number of rows of this matrix or length 1.
For the latter  cov.model and/or lambda are recycled, i.e. the same
value is used for all structures.
</p>


<h3>Value</h3>

<p>The function returns values of the covariances corresponding to  the
given distances. 
The type of output is the same as the type of the object provided in the
argument <code>obj</code>, typically a vector, matrix or array.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>For a review on correlation functions:<br />
Schlather, M. (1999) <em>An introduction to positive definite functions and to unconditional
simulation of random fields</em>. Technical report ST 99-10, Dept. of Maths and Statistics,
Lancaster University.
</p>
<p>Chilès, J.P. and Delfiner, P. (1999)
<b>Geostatistics: Modelling Spatial Uncertainty</b>, Wiley.
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern">matern</a></code> for computation of the
<code class="reqn">\mbox{Mat\'{e}rn}</code> model, <code><a href="base.html#topic+besselK">besselK</a></code> for
computation of the Bessel function  and
<code><a href="#topic+varcov.spatial">varcov.spatial</a></code> for computations related to the covariance matrix. </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Variogram models with the same "practical" range:
#
v.f &lt;- function(x, ...){1-cov.spatial(x, ...)}
#
curve(v.f(x, cov.pars=c(1, .2)), from = 0, to = 1,
      xlab = "distance", ylab = expression(gamma(h)),
      main = "variograms with equivalent \"practical range\"")
curve(v.f(x, cov.pars = c(1, .6), cov.model = "sph"), 0, 1,
      add = TRUE, lty = 2)
curve(v.f(x, cov.pars = c(1, .6/sqrt(3)), cov.model = "gau"),
      0, 1, add = TRUE, lwd = 2)
legend("topleft", c("exponential", "spherical", "gaussian"),
       lty=c(1,2,1), lwd=c(1,1,2))
#
# Matern models with equivalent "practical range"
# and varying smoothness parameter
#
curve(v.f(x, cov.pars = c(1, 0.25), kappa = 0.5),from = 0, to = 1,
      xlab = "distance", ylab = expression(gamma(h)), lty = 2,
      main = "models with equivalent \"practical\" range")
curve(v.f(x, cov.pars = c(1, 0.188), kappa = 1),from = 0, to = 1,
      add = TRUE)      
curve(v.f(x, cov.pars = c(1, 0.14), kappa = 2),from = 0, to = 1,
      add = TRUE, lwd=2, lty=2)      
curve(v.f(x, cov.pars = c(1, 0.117), kappa = 2),from = 0, to = 1,
      add = TRUE, lwd=2)      
legend("bottomright",
       expression(list(kappa == 0.5, phi == 0.250), 
         list(kappa == 1, phi == 0.188), list(kappa == 2, phi == 0.140),
         list(kappa == 3, phi == 0.117)), lty=c(2,1,2,1), lwd=c(1,1,2,2))
# plotting a nested variogram model
curve(v.f(x, cov.pars = rbind(c(.4, .2), c(.6,.3)),
          cov.model = c("sph","exp")), 0, 1, ylab='nested model')
</code></pre>

<hr>
<h2 id='dup.coords'>Locates duplicated coordinates</h2><span id='topic+dup.coords'></span><span id='topic+dup.coords.default'></span><span id='topic+dup.coords.geodata'></span><span id='topic+duplicated.geodata'></span>

<h3>Description</h3>

<p>This funtions takes an object with 2-D coordinates and returns the
positions of the duplicated coordinates. Also sets a method
for <code>duplicated</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.coords(x, ...)
## Default S3 method:
dup.coords(x, ...)
## S3 method for class 'geodata'
dup.coords(x, incomparables, ...)
## S3 method for class 'geodata'
duplicated(x, incomparables, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dup.coords_+3A_x">x</code></td>
<td>
<p>a two column numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="dup.coords_+3A_incomparables">incomparables</code></td>
<td>
<p>unused. Just for compatibility with
the generic function <code><a href="base.html#topic+duplicated">duplicated</a></code>.  </p>
</td></tr>
<tr><td><code id="dup.coords_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+sapply">sapply</a></code>. If <code>simplify = TRUE</code> (default) results
are returned as an array if possible (when the number of replicates are the same at each replicated location) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function and methods returns <code>NULL</code> if there are no duplicates
locations.
</p>
<p>Otherwise, the default method returns a
list where each component is a vector with the positions  or the
rownames, if available, of the duplicates coordinates.
</p>
<p>The method for <code>geodata</code> returns a data-frame with
rownames equals to the positions of the duplicated coordinates,
the first column is a factor indicating duplicates and
the remaning are output of <code><a href="#topic+as.data.frame.geodata">as.data.frame.geodata</a></code>.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a> <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.geodata">as.geodata</a></code> for the definition of geodata class,
<code><a href="base.html#topic+duplicated">duplicated</a></code> for the base function to identify duplicated
values and <code><a href="#topic+jitterDupCoords">jitterDupCoords</a></code> for a function which jitters
duplicated coordinates.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating data
dt &lt;- grf(30, cov.p=c(1, .3)) 
## "forcing" some duplicated locations
dt$coords[4,] &lt;- dt$coords[14,] &lt;- dt$coords[24,] &lt;- dt$coords[2,]
dt$coords[17,] &lt;- dt$coords[23,] &lt;- dt$coords[8,]
## output of the method for geodata
dup.coords(dt)
## which is the same as a method for duplicated()
duplicated(dt)
## the default method:
dup.coords(dt$coords)
</code></pre>

<hr>
<h2 id='elevation'>Surface Elevations</h2><span id='topic+elevation'></span>

<h3>Description</h3>

<p>Surface elevation data taken from Davis (1972).
An onject of the class <code>geodata</code> with elevation values at 52 locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(elevation)
</code></pre>


<h3>Format</h3>

<p>An object of the class <code>geodata</code> which is a list with the
following elements:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>x-y coordinates (multiples of 50 feet).</p>
</dd>
<dt><code>data</code></dt><dd><p>elevations (multiples of 10 feet).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Davis, J.C. (1973) <em>Statistics and Data Analysis in Geology.</em> Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(elevation)
plot(elevation)
</code></pre>

<hr>
<h2 id='eyefit'>Interactive Variogram Estimation</h2><span id='topic+eyefit'></span><span id='topic+lines.eyefit'></span><span id='topic+summary.eyefit'></span><span id='topic+print.summary.eyefit'></span><span id='topic+print.eyefit'></span><span id='topic+plot.eyefit'></span>

<h3>Description</h3>

<p>Function to fit an empirical variogram &quot;by eye&quot; using an interactive
Tcl-Tk interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eyefit(vario, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eyefit_+3A_vario">vario</code></td>
<td>
<p>An empirical variogram object as returned by the function
<code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr>
<tr><td><code id="eyefit_+3A_silent">silent</code></td>
<td>
<p>logical indicating wheather or not the fitted variogram
must be returned.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of list
with the model parameters for each of the saved fit(s).
</p>


<h3>Author(s)</h3>

<p>Andreas Kiefer <a href="mailto:andreas@inf.ufpr.br">andreas@inf.ufpr.br</a> <br />
Paulo Justiniano Ribeiro Junior <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>. </p>


<h3>See Also</h3>

<p><code><a href="#topic+variofit">variofit</a></code> for least squares variogram fit,
<code><a href="#topic+likfit">likfit</a></code> for likelihood based parameter estimation
and <code><a href="#topic+krige.bayes">krige.bayes</a></code> to obtain the posterior distribution for the model parameters. </p>

<hr>
<h2 id='gambia'>Gambia Malaria Data</h2><span id='topic+gambia'></span><span id='topic+gambia.borders'></span><span id='topic+gambia.map'></span>

<h3>Description</h3>

<p>Malaria prevalence in children recorded at villages in The Gambia, Africa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gambia)</code></pre>


<h3>Format</h3>

<p>Two objects are made available:
</p>

<ol>
<li> <p><code>gambia</code><br />
A data frame with 2035 observations on the following 8 variables.
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate of the village (UTM).  </p>
</dd>
<dt>y</dt><dd><p>y-coordinate of the village (UTM).  </p>
</dd>
<dt>pos</dt><dd><p>presence (1) or absence (0) of malaria in a blood
sample taken from the child.</p>
</dd>
<dt>age</dt><dd><p>age of the child, in days</p>
</dd>
<dt>netuse</dt><dd><p>indicator variable denoting whether (1) or not (0)
the child regularly sleeps under a bed-net.  </p>
</dd>
<dt>treated</dt><dd><p>indicator variable denoting
whether (1) or not (0) the bed-net is
treated (coded 0 if netuse=0).</p>
</dd>
<dt>green</dt><dd><p>satellite-derived measure of the green-ness of vegetation
in the immediate vicinity of the village (arbitrary units).  </p>
</dd>
<dt>phc</dt><dd><p>indicator variable denoting the presence (1) or
absence (0) of a health center in the
village.  </p>
</dd>
</dl>

</li>
<li> <p><code>gambia.borders</code><br />
A data frame with 2 variables:
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate of the country borders.  </p>
</dd>
<dt>y</dt><dd><p>y-coordinate of the country borders.  </p>
</dd>
</dl>

</li></ol>



<h3>References</h3>

<p>Thomson, M., Connor, S., D Alessandro, U., Rowlingson, B., Diggle, P., Cresswell, M. &amp; Greenwood, B.
(1999). Predicting malaria infection in Gambian children from satellite data and bednet use surveys: the
importance of spatial correlation in the interpretation of results. <em>American Journal of Tropical
Medicine and Hygiene</em> 61: 2&ndash;8.
</p>
<p>Diggle, P., Moyeed, R., Rowlingson, B. &amp; Thomson, M. (2002). Childhood
malaria in The Gambia: a case-study in model-based geostatistics,
<em>Applied Statistics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(gambia.borders, type="l", asp=1)
points(gambia[,1:2], pch=19)
# a built-in function for a zoomed map
gambia.map()
# Building a "village-level" data frame
ind &lt;- paste("x",gambia[,1], "y", gambia[,2], sep="")
village &lt;- gambia[!duplicated(ind),c(1:2,7:8)]
village$prev &lt;- as.vector(tapply(gambia$pos, ind, mean))
plot(village$green, village$prev)
</code></pre>

<hr>
<h2 id='geoR-defunct'>Defunct Functions in the Package geoR</h2><span id='topic+geoRdefunct'></span><span id='topic+olsfit'></span><span id='topic+wlsfit'></span><span id='topic+likfit.old'></span><span id='topic+likfit.nospatial'></span><span id='topic+loglik.spatial'></span><span id='topic+.proflik.nug'></span><span id='topic+.proflik.phi'></span><span id='topic+.proflik.ftau'></span><span id='topic+distdiag'></span>

<h3>Description</h3>

<p>The functions listed here are no longer part of the package <span class="pkg">geoR</span>
as they are no longer needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoRdefunct()
</code></pre>


<h3>Details</h3>

<p>The following functions are now defunct:
</p>

<dl>
<dt>olsfit</dt><dd><p>functionality incorporated by <code><a href="#topic+variofit">variofit</a></code>
starting from package version &lsquo;<span class="samp">&#8288;1.0-6&#8288;</span>&rsquo;.  </p>
</dd>
<dt>wlsfit</dt><dd><p>functionality incorporated by <code><a href="#topic+variofit">variofit</a></code>
starting from package version &lsquo;<span class="samp">&#8288;1.0-6&#8288;</span>&rsquo;.  </p>
</dd>
<dt>likfit.old</dt><dd><p>functionality incorporated by <code><a href="#topic+likfit">likfit</a></code>
starting from package version &lsquo;<span class="samp">&#8288;1.0-6&#8288;</span>&rsquo;.  
The related functions were also made defunct: <br />
<code>likfit.nospatial</code>, <code>loglik.spatial</code>,
<code>proflik.nug</code>, <code>proflik.phi</code>, <code>proflik.ftau</code>.  </p>
</dd>
<dt>distdiag</dt><dd><p>functionally is redundant with <code><a href="stats.html#topic+dist">dist</a></code>.  </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+variofit">variofit</a></code></p>

<hr>
<h2 id='geoR-internal'>geoR internal functions</h2><span id='topic+beta.sigmasq.post'></span><span id='topic+.cond.sim'></span><span id='topic+print.betavar'></span><span id='topic+backtransform.moments'></span><span id='topic+BCtransform'></span><span id='topic+rMVnorm'></span><span id='topic+.solve.geoR'></span><span id='topic+print.grf'></span><span id='topic+.check.locations'></span><span id='topic+.geoR.check.locations'></span><span id='topic+.check.borders'></span><span id='topic+.check.coords'></span><span id='topic+.geoR_inout'></span><span id='topic+.geoR_pip'></span><span id='topic+.ldots.set'></span>

<h3>Description</h3>

<p>These are functions internally called by other functions
in the package <span class="pkg">geoR</span> and not meant to be called by the user.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>

<hr>
<h2 id='globalvar'>Computes global variance </h2><span id='topic+globalvar'></span>

<h3>Description</h3>

<p>Global variance computation for a set of locations using the covarianve
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globalvar(geodata, locations, coords = geodata$coords, krige)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globalvar_+3A_geodata">geodata</code></td>
<td>
<p>an object of the class <code>geodata</code> </p>
</td></tr>
<tr><td><code id="globalvar_+3A_locations">locations</code></td>
<td>
<p>n by 2 matrix with a set of locations, typically a
prediction grid </p>
</td></tr>
<tr><td><code id="globalvar_+3A_coords">coords</code></td>
<td>
<p>data coordinates </p>
</td></tr>
<tr><td><code id="globalvar_+3A_krige">krige</code></td>
<td>
<p>a list defining the model components and the type of
kriging. It can take an output to a call to <code>krige.control</code> or
a list with elements as for the arguments in <code>krige.control</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An scalar with the value of the global variance
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Isaaks, E.S and Srivastava, R.M. (1989) An Introduction to
Applied Geostatistics, pag. 508, eq. 20.7. Oxford University Press. </p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.conv">krige.conv</a></code> for the kriging algorithm. </p>

<hr>
<h2 id='grf'>Simulation of Gaussian Random Fields</h2><span id='topic+grf'></span><span id='topic+.grf.aux1'></span><span id='topic+grfclass'></span><span id='topic+lines.grf'></span>

<h3>Description</h3>

<p><code>grf()</code> generates (unconditional)
simulations of Gaussian random fields for
given covariance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grf(n, grid = "irreg", nx, ny, xlims = c(0, 1), ylims = c(0, 1),
    borders, nsim = 1, cov.model = "matern",
    cov.pars = stop("missing covariance parameters sigmasq and phi"), 
    kappa = 0.5, nugget = 0, lambda = 1, aniso.pars,
    mean = 0, method, messages)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grf_+3A_n">n</code></td>
<td>
<p>number of points (spatial locations) in each simulations.  </p>
</td></tr>
<tr><td><code id="grf_+3A_grid">grid</code></td>
<td>
<p>optional. An <code class="reqn">n \times 2</code> matrix with coordinates of the
simulated data.  </p>
</td></tr>
<tr><td><code id="grf_+3A_nx">nx</code></td>
<td>
<p>optional. Number of points in the X direction.  </p>
</td></tr>
<tr><td><code id="grf_+3A_ny">ny</code></td>
<td>
<p>optional. Number of points in the Y direction.  </p>
</td></tr>
<tr><td><code id="grf_+3A_xlims">xlims</code></td>
<td>
<p>optional. Limits of the area in the X direction. Defaults
to <code class="reqn">[0,1]</code>.  </p>
</td></tr>
<tr><td><code id="grf_+3A_ylims">ylims</code></td>
<td>
<p>optional. Limits of the area in the Y direction.  Defaults
to <code class="reqn">[0,1]</code>.  </p>
</td></tr>
<tr><td><code id="grf_+3A_borders">borders</code></td>
<td>
<p>optional. Typically a two coluns matrix especifying a
polygon. See DETAILS below.</p>
</td></tr>
<tr><td><code id="grf_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations. Defaults to 1.</p>
</td></tr>
<tr><td><code id="grf_+3A_cov.model">cov.model</code></td>
<td>
<p>correlation function. See <code><a href="#topic+cov.spatial">cov.spatial</a></code> for
further details. Defaults to the 
<em>exponential</em> model.  </p>
</td></tr>
<tr><td><code id="grf_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector with 2 elements or an <code class="reqn">n \times 2</code>
matrix with values of  the covariance parameters
<code class="reqn">\sigma^2</code> (partial sill) and <code class="reqn">\phi</code> (range
parameter). If a vector, the elements are the values of
<code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code>, respectively.
If a matrix, corresponding to a model with several structures, the
values of <code class="reqn">\sigma^2</code> 
are in the first column and the values of <code class="reqn">\phi</code> are in the second.  </p>
</td></tr>
<tr><td><code id="grf_+3A_kappa">kappa</code></td>
<td>
<p>additional smoothness parameter required only for the
following correlation 
functions: <code>"matern"</code>, <code>"powered.exponential"</code>, <code>"cauchy"</code> 
and  <code>"gneiting.matern"</code>. More details on the documentation for the
function <code><a href="#topic+cov.spatial">cov.spatial</a></code>.  </p>
</td></tr>
<tr><td><code id="grf_+3A_nugget">nugget</code></td>
<td>
<p>the value of the nugget effect parameter <code class="reqn">\tau^2</code>.</p>
</td></tr>
<tr><td><code id="grf_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter. The value <code class="reqn">\lambda
      = 1</code> corresponds to no transformation, the default.
For any other value of <code class="reqn">\lambda</code> Gaussian data is
simulated and then transformed.  </p>
</td></tr>
<tr><td><code id="grf_+3A_aniso.pars">aniso.pars</code></td>
<td>
<p>geometric anisotropy parameters. By default an
isotropic field is assumed and this argument is ignored.
If a vector with 2 values is provided, with values for the
anisotropy angle <code class="reqn">\psi_A</code> (in
radians) and 
anisotropy ratio <code class="reqn">\psi_A</code>, the coordinates
are transformed, 
the simulation is performed on the isotropic (transformed) space
and then the coordinates are back-transformed such that the resulting
field is anisotropic. Coordinates transformation is performed 
by the function <code><a href="#topic+coords.aniso">coords.aniso</a></code>.  </p>
</td></tr>
<tr><td><code id="grf_+3A_mean">mean</code></td>
<td>
<p>a numerical vector, scalar or the same length of the
data to be simulated. Defaults to zero.</p>
</td></tr>
<tr><td><code id="grf_+3A_method">method</code></td>
<td>
<p>simulation method with options for
<code>"cholesky"</code>, <code>"svd"</code>, <code>"eigen"</code>. 
Defaults to the <em>Cholesky</em>
decomposition.  See section <code>DETAILS</code> below.  </p>
</td></tr>
<tr><td><code id="grf_+3A_messages">messages</code></td>
<td>
<p>logical,  indicating
whether or not status messages are printed on the screen (or output device)
while the function is running. Defaults to <code>TRUE</code>.  </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>For the methods <code>"cholesky"</code>, <code>"svd"</code> and <code>"eigen"</code> the
simulation consists of multiplying a vector of standardized
normal deviates by a square root of the covariance matrix.
The square root of a matrix is not uniquely defined. These 
three methods differs in the way they compute the
square root of the (positive definite) covariance matrix.
</p>
<p>The argument <code>borders</code>, if provides takes a
polygon data set following argument <code>poly</code>
for the <span class="pkg">splancs</span>' function <code><a href="splancs.html#topic+csr">csr</a></code>, in case of
<code>grid="reg"</code> or <code><a href="splancs.html#topic+gridpts">gridpts</a></code>, in case of
<code>grid="irreg"</code>. For the latter the simulation will have 
<em>approximately</em> &ldquo;n&rdquo; points.
</p>


<h3>Value</h3>

<p><code>grf</code> returns a list with the components:
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the coordinates of the
simulated data.  </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a vector (if <code>nsim = 1</code>) or a matrix with the
simulated values. For the latter each column corresponds to one
simulation.  </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>a string with the name of the correlation function.  </p>
</td></tr>
<tr><td><code>nugget</code></td>
<td>
<p>the value of the nugget parameter.</p>
</td></tr>
<tr><td><code>cov.pars</code></td>
<td>
<p>a vector with the values of <code class="reqn">\sigma^2</code>
and <code class="reqn">\phi</code>, respectively.  </p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>value of the parameter <code class="reqn">\kappa</code>.  </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter
<code class="reqn">\lambda</code>.  </p>
</td></tr>
<tr><td><code>aniso.pars</code></td>
<td>
<p>a vector with values of the anisotropy parameters, if
provided in the function call.  </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a string with the name of the simulation method used.</p>
</td></tr>
<tr><td><code>sim.dim</code></td>
<td>
<p>a string &quot;1d&quot; or &quot;2d&quot; indicating the spatial dimension of the
simulation.</p>
</td></tr>
<tr><td><code>.Random.seed</code></td>
<td>
<p>the random seed by the time the function was
called.  </p>
</td></tr>
<tr><td><code>messages</code></td>
<td>
<p>messages produced by the function describing the
simulation.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>,  <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Wood, A.T.A. and Chan, G. (1994) Simulation of stationary Gaussian
process in <code class="reqn">[0,1]^d</code>.
<em>Journal of Computatinal and Graphical Statistics</em>, <b>3</b>, 409&ndash;432.
</p>
<p>Schlather, M. (1999) <em>Introduction to positive definite functions
and to unconditional simulation of random fields</em>. Tech. Report
ST&ndash;99&ndash;10, Dept Maths and Stats, Lancaster University.
</p>
<p>Schlather, M. (2001) <em>Simulation and Analysis of Random Fields</em>. R-News <b>1</b> (2), p. 18-20.
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.grf">plot.grf</a></code> and <code><a href="#topic+image.grf">image.grf</a></code> for graphical output,
<code><a href="#topic+coords.aniso">coords.aniso</a></code> for anisotropy coordinates transformation and <code><a href="base.html#topic+chol">chol</a></code>,
<code><a href="base.html#topic+svd">svd</a></code> and <code><a href="base.html#topic+eigen">eigen</a></code> for methods of matrix
decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim1 &lt;- grf(100, cov.pars = c(1, .25))
# a display of simulated locations and values
points(sim1)   
# empirical and theoretical variograms
plot(sim1)
## alternative way
plot(variog(sim1, max.dist=1))
lines.variomodel(sim1)
#
# a "smallish" simulation
sim2 &lt;- grf(441, grid = "reg", cov.pars = c(1, .25)) 
image(sim2)
##
## 1-D simulations using the same seed and different noise/signal ratios
##
set.seed(234)
sim11 &lt;- grf(100, ny=1, cov.pars=c(1, 0.25), nug=0)
set.seed(234)
sim12 &lt;- grf(100, ny=1, cov.pars=c(0.75, 0.25), nug=0.25)
set.seed(234)
sim13 &lt;- grf(100, ny=1, cov.pars=c(0.5, 0.25), nug=0.5)
##
par.ori &lt;- par(no.readonly = TRUE)
par(mfrow=c(3,1), mar=c(3,3,.5,.5))
yl &lt;- range(c(sim11$data, sim12$data, sim13$data))
image(sim11, type="l", ylim=yl)
image(sim12, type="l", ylim=yl)
image(sim13, type="l", ylim=yl)
par(par.ori)

## simulating within borders
data(parana)
pr1 &lt;- grf(100, cov.pars=c(200, 40), borders=parana$borders, mean=500)
points(pr1)
pr1 &lt;- grf(100, grid="reg", cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
pr1 &lt;- grf(100, grid="reg", nx=10, ny=5, cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
</code></pre>

<hr>
<h2 id='head'>Head observations in a regional confined aquifer</h2><span id='topic+head'></span>

<h3>Description</h3>

<p>Measurements of potentiometric head at 29 locations in a regional
confined sandstone aquifer.  Extract from Kitanidis' book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(head)</code></pre>


<h3>Format</h3>

<p>An object of the class <code>geodata</code> which is a list with the elements:
</p>

<dl>
<dt>coords</dt><dd><p>coordinates of the data location. </p>
</dd>
<dt>data</dt><dd><p>the data vector with head measurements (feet). </p>
</dd>
</dl>



<h3>Source</h3>

<p>Kitanidis, P.K. Introduction to geostatistics - applications in
hidrology (1997). Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(head)
plot(head)
</code></pre>

<hr>
<h2 id='hist.krige.bayes'>Plots Sample from Posterior Distributions</h2><span id='topic+hist.krige.bayes'></span>

<h3>Description</h3>

<p>Plots histograms and/or density estimation with samples
from the posterior distribution of the model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'krige.bayes'
hist(x, pars, density.est = TRUE, histogram = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.krige.bayes_+3A_x">x</code></td>
<td>
<p>an object of the class <code>krige.bayes</code>, with an output of
the funtions <code><a href="#topic+krige.bayes">krige.bayes</a></code>. </p>
</td></tr>
<tr><td><code id="hist.krige.bayes_+3A_pars">pars</code></td>
<td>
<p>a vector with the names of one or more of the model parameters.
Defaults to all model parameters. Setting to -1 excludes the intercept.  </p>
</td></tr>
<tr><td><code id="hist.krige.bayes_+3A_density.est">density.est</code></td>
<td>
<p>logical indication whether a line with the density 
estimation should be added to the plot.  </p>
</td></tr>
<tr><td><code id="hist.krige.bayes_+3A_histogram">histogram</code></td>
<td>
<p>logical indicating whether the histogram is included in the 
plot.  </p>
</td></tr>
<tr><td><code id="hist.krige.bayes_+3A_...">...</code></td>
<td>
<p>further arguments for the plotting functions and or for the 
density estimation.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot in the currently graphics device.<br />
Returns a <code><a href="base.html#topic+invisible">invisible</a></code> list with the components:
</p>
<table>
<tr><td><code>histogram</code></td>
<td>
<p>with the output of the function <code><a href="graphics.html#topic+hist">hist</a></code> for 
each parameter</p>
</td></tr>
<tr><td><code>density.estimation</code></td>
<td>
<p>with the output of the function 
<code><a href="stats.html#topic+density">density</a></code> for each parameter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.bayes">krige.bayes</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See documentation for krige.bayes()
</code></pre>

<hr>
<h2 id='hoef'>Data for spatial analysis of experiments</h2><span id='topic+hoef'></span>

<h3>Description</h3>

<p>The <code>hoef</code> data frame has 25 rows and 5 columns.<br />
The data consists of a uniformity trial for which <em>artificial</em>
treatment effects were assign to the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hoef)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x1</dt><dd><p>x-coordinate of the plot.</p>
</dd>
<dt>x2</dt><dd><p>y-coordinate of the plot.</p>
</dd>
<dt>dat</dt><dd><p>the <em>artificial</em> data.</p>
</dd>
<dt>trat</dt><dd><p>the treatment number.</p>
</dd>
<dt>ut</dt><dd><p>the data from the uniformity trial, without the treatment effect.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The treatment effects assign to the plots are:
</p>

<ul>
<li><p> Treatment 1: <code class="reqn">\tau_1 = 0</code>
</p>
</li>
<li><p> Treatment 2: <code class="reqn">\tau_2 = -3</code>
</p>
</li>
<li><p> Treatment 3: <code class="reqn">\tau_3 = -5</code>
</p>
</li>
<li><p> Treatment 4: <code class="reqn">\tau_4 = 6</code>
</p>
</li>
<li><p> Treatment 5: <code class="reqn">\tau_5 = 6</code>
</p>
</li></ul>
    


<h3>Source</h3>

<p>Ver Hoef, J.M. &amp; Cressie, N. (1993) Spatial statistics: analysis of field experiments.
In Scheiner S.M. and Gurevitch, J. (Eds) <em>Design and Analysis of
Ecological Experiments</em>. Chapman and Hall. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hoef.geo &lt;- as.geodata(hoef, covar.col=4)
summary(hoef)
summary(hoef.geo)
points(hoef.geo, cex.min=2, cex.max=2, pt.div="quintiles")
</code></pre>

<hr>
<h2 id='image.grf'>Image, Contour or Perspective Plot of Simulated Gaussian Random Field</h2><span id='topic+image.grf'></span><span id='topic+contour.grf'></span><span id='topic+persp.grf'></span><span id='topic+.geoR_fullGrid'></span>

<h3>Description</h3>

<p>Methods for image, contour or perspective plot of a
realisation of a Gaussian
random field, simulated using the function <code><a href="#topic+grf">grf</a></code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grf'
image(x, sim.number = 1, borders, x.leg, y.leg, ...)
## S3 method for class 'grf'
contour(x, sim.number = 1, borders, filled = FALSE, ...)
## S3 method for class 'grf'
persp(x, sim.number = 1, borders, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.grf_+3A_x">x</code></td>
<td>
<p>an object of the class <code>grf</code>, typically an output of the function
<code><a href="#topic+grf">grf</a></code>.  </p>
</td></tr>
<tr><td><code id="image.grf_+3A_sim.number">sim.number</code></td>
<td>
<p>simulation number.
Indicates the number of the simulation top be plotted.
Only valid if the object contains more than one simulation.
Defaults to 1.  </p>
</td></tr>
<tr><td><code id="image.grf_+3A_borders">borders</code></td>
<td>
<p>optional. Typically a two coluns matrix especifying a
polygon. Points outside the borders will be set no <code>NA</code> </p>
</td></tr>
<tr><td><code id="image.grf_+3A_x.leg">x.leg</code>, <code id="image.grf_+3A_y.leg">y.leg</code></td>
<td>
<p>limits for the legend in the horizontal and vertical directions.  </p>
</td></tr>
<tr><td><code id="image.grf_+3A_filled">filled</code></td>
<td>
<p>logical. If <code>FALSE</code> the function
<code><a href="graphics.html#topic+contour">contour</a></code> is used otherwise
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="image.grf_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the functions
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code> or <code><a href="graphics.html#topic+persp">persp</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image or perspective plot is produced on the current graphics
device.
No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information about the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grf">grf</a></code> for simulation of Gaussian random fields,
<code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+persp">persp</a></code> for the generic plotting
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating 4 simulations of a Gaussian random field
sim &lt;- grf(441, grid="reg", cov.pars=c(1, .25), nsim=4)
op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=c(3,3,1,1), mgp = c(2,1,0))
for (i in 1:4)
  image(sim, sim.n=i)
par(op)
</code></pre>

<hr>
<h2 id='image.krige.bayes'>Plots Results of the Predictive Distribution</h2><span id='topic+image.krige.bayes'></span><span id='topic+contour.krige.bayes'></span><span id='topic+persp.krige.bayes'></span><span id='topic+.prepare.graph.krige.bayes'></span>

<h3>Description</h3>

<p>This function produces an image or perspective plot of a selected
element
of the predictive distribution
returned by the function <code><a href="#topic+krige.bayes">krige.bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'krige.bayes'
image(x, locations, borders,
                  values.to.plot=c("mean", "variance",
                            "mean.simulations", "variance.simulations",
                            "quantiles", "probabilities", "simulation"),
                  number.col, coords.data, x.leg, y.leg, messages, ...)
## S3 method for class 'krige.bayes'
contour(x, locations, borders, 
                  values.to.plot = c("mean", "variance",
                       "mean.simulations", "variance.simulations",
                       "quantiles", "probabilities", "simulation"),
                  filled=FALSE, number.col, coords.data,
                  x.leg, y.leg, messages, ...)
## S3 method for class 'krige.bayes'
persp(x, locations, borders,
                  values.to.plot=c("mean", "variance",
                       "mean.simulations", "variance.simulations",
                       "quantiles", "probabilities", "simulation"),
                  number.col, messages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.krige.bayes_+3A_x">x</code></td>
<td>
<p>an object of the class <code>krige.bayes</code>, typically an
output of the function <code><a href="#topic+krige.bayes">krige.bayes</a></code>.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the
coordinates of the prediction locations, which should define a
regular grid
in order to be plotted by <code><a href="graphics.html#topic+image">image</a></code> or
<code><a href="graphics.html#topic+persp">persp</a></code>. By default does not need to be provided and
evaluates the attribute &quot;prediction.locations&quot; from the input object.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_borders">borders</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the
coordinates defining the borders of a region inside the grid defined
by <code>locations</code>. Elements in the
argument <code>values</code> are assigned to locations internal to the
borders  and <code>NA</code>'s to the external ones.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_values.to.plot">values.to.plot</code></td>
<td>
<p>select the element of the predictive
distribution to be plotted. See DETAILS below.</p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_filled">filled</code></td>
<td>
<p>logical. If <code>FALSE</code> the function
<code><a href="graphics.html#topic+contour">contour</a></code> is used otherwise
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_number.col">number.col</code></td>
<td>
<p>Specifies the number of the column to be plotted.
Only used if previous argument is set to one of <code>"quantiles"</code>, 
<code>"probabilities"</code>  or <code>"simulation"</code>.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_coords.data">coords.data</code></td>
<td>
<p>optional. If an <code class="reqn">n \times 2</code>
matrix with the data coordinates is
provided, points indicating the data locations are included in the
plot.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_x.leg">x.leg</code>, <code id="image.krige.bayes_+3A_y.leg">y.leg</code></td>
<td>
<p>limits for the legend in the horizontal and vertical directions.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_messages">messages</code></td>
<td>
<p>logical, if TRUE status messages are printed while
running the function.  </p>
</td></tr>
<tr><td><code id="image.krige.bayes_+3A_...">...</code></td>
<td>
<p>extra arguments to be passed to the plotting function
<code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+persp">persp</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+krige.bayes">krige.bayes</a></code> returns
summaries and other results about the predictive distributions.
The argument <code>values.to.plot</code> specifies which result will be
plotted. It can be passed to the function in two different forms:
</p>

<ul>
<li><p> a vector with the object containing the values to be plotted, or
</p>
</li>
<li><p> one of the following options: <code>"moments.mean"</code>,
<code>"moments.variance"</code>, 
<code>"mean.simulations"</code>,
<code>"variance.simulations"</code>,
<code>"quantiles"</code>,
<code>"probability"</code> or
<code>"simulation"</code>.  </p>
</li></ul>

<p>For the last three options, if the results are stored in matrices,
a column number must be provided using the argument <code>number.col</code>.
</p>
<p>The documentation for the function <code><a href="#topic+krige.bayes">krige.bayes</a></code> provides
further details about these options.
</p>


<h3>Value</h3>

<p>An <code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+persp">persp</a></code> plot is produced on the
current graphics device. No values are returned. 
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>,
<br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.bayes">krige.bayes</a></code> for Bayesian Kriging computations and, <code><a href="graphics.html#topic+image">image</a></code> and  <code><a href="graphics.html#topic+persp">persp</a></code> for the generic plotting functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See examples in the documentation for the function krige.bayes().
</code></pre>

<hr>
<h2 id='image.kriging'>Image or Perspective Plot with Kriging Results</h2><span id='topic+image.kriging'></span><span id='topic+contour.kriging'></span><span id='topic+persp.kriging'></span><span id='topic+.prepare.graph.kriging'></span><span id='topic+plot.1d'></span>

<h3>Description</h3>

<p>Plots image or perspective plots with results of the kriging
calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kriging'
image(x, locations, borders, values = x$predict,
              coords.data, x.leg, y.leg, ...)
## S3 method for class 'kriging'
contour(x, locations, borders, values = x$predict,
              coords.data, filled=FALSE, ...)
## S3 method for class 'kriging'
persp(x, locations, borders, values = x$predict, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.kriging_+3A_x">x</code></td>
<td>
<p>an object of the  class <code>kriging</code>, typically
with the output of the functions <code><a href="#topic+krige.conv">krige.conv</a></code> or <code><a href="#topic+ksline">ksline</a></code>.  </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the
coordinates of the prediction locations, which should define a
regular grid
in order to be plotted by <code><a href="graphics.html#topic+image">image</a></code> or
<code><a href="graphics.html#topic+persp">persp</a></code>. By default does not need to be provided and
evaluates the attribute &quot;prediction.locations&quot; from the input object. </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_borders">borders</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the
coordinates defining the borders of a region inside the grid defined
by <code>locations</code>. Elements in the
argument <code>values</code> are assigned to locations internal to the
borders and <code>NA</code>'s to the external ones.
</p>
</td></tr>
<tr><td><code id="image.kriging_+3A_values">values</code></td>
<td>
<p>a vector with values to be plotted. Defaults to <code>obj$predict</code>.  </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_coords.data">coords.data</code></td>
<td>
<p>optional. If an <code class="reqn">n \times 2</code>
matrix with the data coordinates is
provided, points indicating the data locations are included in the
plot.  </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_x.leg">x.leg</code>, <code id="image.kriging_+3A_y.leg">y.leg</code></td>
<td>
<p>limits for the legend in the horizontal and vertical directions.  </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_filled">filled</code></td>
<td>
<p>logical. If <code>FALSE</code> the function
<code><a href="graphics.html#topic+contour">contour</a></code> is used otherwise
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="image.kriging_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the functions
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code> or
<code><a href="#topic+legend.krige">legend.krige</a></code>.
For instance, the
argument <code>zlim</code> can be used to set the the minimum and maximum
&lsquo;z&rsquo; values for which colors should be plotted.
See documentation for those function for
possible arguments.
</p>
</td></tr>   
</table>


<h3>Details</h3>

<p><code>plot1d</code> and <code>prepare.graph.kriging</code> are auxiliary functions
called by the others.
</p>


<h3>Value</h3>

<p>An image or perspective plot is produced o the current graphics
device.
No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.conv">krige.conv</a></code> and <code><a href="#topic+ksline">ksline</a></code> for kriging
calculations. Documentation for
<code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> and  <code><a href="graphics.html#topic+persp">persp</a></code> contain basic information
on the plotting functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>loci &lt;- expand.grid(seq(0,1,l=51), seq(0,1,l=51))
kc &lt;- krige.conv(s100, loc=loci,
                 krige=krige.control(cov.pars=c(1, .25)))
image(kc)
contour(kc)
image(kc)
contour(kc, add=TRUE, nlev=21)
persp(kc, theta=20, phi=20)
contour(kc, filled=TRUE)
contour(kc, filled=TRUE, color=terrain.colors)
contour(kc, filled=TRUE, col=gray(seq(1,0,l=21)))
# adding data locations
image(kc, coords.data=s100$coords)
contour(kc,filled=TRUE,coords.data=s100$coords,color=terrain.colors)
#
# now dealing with borders
#
bor &lt;- matrix(c(.4,.1,.3,.9,.9,.7,.9,.7,.3,.2,.5,.8),
              ncol=2)
# plotting just inside borders
image(kc, borders=bor)
contour(kc, borders=bor)
image(kc, borders=bor)
contour(kc, borders=bor, add=TRUE)
contour(kc, borders=bor, filled=TRUE, color=terrain.colors)
# kriging just inside borders
kc1 &lt;- krige.conv(s100, loc=loci,
                 krige=krige.control(cov.pars=c(1, .25)),
                 borders=bor)
image(kc1)
contour(kc1)
# avoiding the borders 
image(kc1, borders=NULL)
contour(kc1, borders=NULL)

op &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2), mar=c(3,3,0,0), mgp=c(1.5, .8,0))
image(kc)
image(kc, val=sqrt(kc$krige.var))

# different ways to add the legends and pass arguments:
image(kc, ylim=c(-0.2, 1), x.leg=c(0,1), y.leg=c(-0.2, -0.1))
image(kc, val=kc$krige.var, ylim=c(-0.2, 1))
legend.krige(y.leg=c(-0.2,-0.1), x.leg=c(0,1), val=sqrt(kc$krige.var))

image(kc, ylim=c(-0.2, 1), x.leg=c(0,1), y.leg=c(-0.2, -0.1), cex=1.5)
image(kc, ylim=c(-0.2, 1), x.leg=c(0,1), y.leg=c(-0.2, -0.1), offset.leg=0.5)

image(kc, xlim=c(0, 1.2))
legend.krige(x.leg=c(1.05,1.1), y.leg=c(0,1), kc$pred, vert=TRUE)
image(kc, xlim=c(0, 1.2))
legend.krige(x.leg=c(1.05,1.1), y.leg=c(0,1),kc$pred, vert=TRUE, off=1.5, cex=1.5)

par(op)
</code></pre>

<hr>
<h2 id='InvChisquare'>The (Scaled) Inverse Chi-Squared Distribution</h2><span id='topic+dinvchisq'></span><span id='topic+rinvchisq'></span>

<h3>Description</h3>

<p>Density and random generation for the scaled inverse chi-squared
(<code class="reqn">\chi^2_{ScI}</code>) distribution with
<code>df</code> degrees of freedom and optional non-centrality parameter
<code>scale</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvchisq(x, df, scale, log = FALSE)
rinvchisq(n, df, scale = 1/df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvChisquare_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InvChisquare_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="InvChisquare_+3A_df">df</code></td>
<td>
<p>degrees of freedom.</p>
</td></tr>
<tr><td><code id="InvChisquare_+3A_scale">scale</code></td>
<td>
<p>scale parameter.</p>
</td></tr>
<tr><td><code id="InvChisquare_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities d are given as log(d).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inverse chi-squared distribution with <code>df</code><code class="reqn">= n</code>
degrees of freedom has density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{{2}^{n/2} \Gamma (n/2)} {(1/x)}^{n/2+1} {e}^{-1/(2x)}</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>.
The mean and variance are <code class="reqn">\frac{1}{(n-2)}</code> and
<code class="reqn">\frac{2}{(n-4)(n-2)^2}</code>.
</p>
<p>The non-central chi-squared distribution with <code>df</code><code class="reqn">= n</code>
degrees of freedom and non-centrality parameter <code>scale</code>
<code class="reqn">= S^2</code> has density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{{n/2}^{n/2}}{\Gamma (n/2)} S^n {(1/x)}^{n/2+1}
    {e}^{-(n S^2)/(2x)}</code>
</p>
<p>,
for <code class="reqn">x \ge 0</code>.
The first is a particular case of the latter for <code class="reqn">\lambda = n/2</code>. 
</p>


<h3>Value</h3>

<p><code>dinvchisq</code> gives the density and <code>rinvchisq</code>
generates random deviates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rchisq">rchisq</a></code> for the chi-squared distribution which
is the basis for this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234); rinvchisq(5, df=2)
set.seed(1234); 1/rchisq(5, df=2)

set.seed(1234); rinvchisq(5, df=2, scale=5)
set.seed(1234); 5*2/rchisq(5, df=2)

## inverse Chi-squared is a particular case
x &lt;- 1:10
all.equal(dinvchisq(x, df=2), dinvchisq(x, df=2, scale=1/2))
</code></pre>

<hr>
<h2 id='isaaks'>Data from Isaaks and Srisvastava's book</h2><span id='topic+isaaks'></span>

<h3>Description</h3>

<p>Toy example used in the book <em>An Introduction to Geostatistics</em> to
illustrate the effects of different models
and parameters in the kriging results when predicting at a given point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(isaaks)</code></pre>


<h3>Format</h3>

<p>An object of the class <code>geodata</code> which is a list with the elements:
</p>

<dl>
<dt>coords</dt><dd><p>coordinates of the data location. </p>
</dd>
<dt>data</dt><dd><p>the data vector. </p>
</dd>
<dt>x0</dt><dd><p>coordinate of the prediction point. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Isaaks, E.H. &amp; Srisvastava, R.M. (1989)
An Introduction to Applied Geostatistics.
Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isaaks
summary(isaaks)
plot(isaaks$coords, asp=1, type="n")
text(isaaks$coords, as.character(isaaks$data))
points(isaaks$x0, pch="?", cex=2, col=2)
</code></pre>

<hr>
<h2 id='jitterDupCoords'>
Jitters (duplicated) coordinates.
</h2><span id='topic+jitterDupCoords'></span><span id='topic+jitterDupCoords.default'></span><span id='topic+jitterDupCoords.geodata'></span><span id='topic+jitter2d'></span>

<h3>Description</h3>

<p>Jitters 2D coordinates uniformily on a region around (duplicated) points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jitter2d(coords, max, min = 0.2 * max, fix.one = TRUE,
         which.fix = c("random", "first", "last")) 

jitterDupCoords(x, ...)

## Default S3 method:
jitterDupCoords(x, ...)

## S3 method for class 'geodata'
jitterDupCoords(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jitterDupCoords_+3A_x">x</code>, <code id="jitterDupCoords_+3A_coords">coords</code></td>
<td>
<p>a matrix or data frame with 2D coordinates or geodata
object.  </p>
</td></tr>
<tr><td><code id="jitterDupCoords_+3A_max">max</code></td>
<td>
<p>numeric scalar defining maximum jittering distance. </p>
</td></tr>
<tr><td><code id="jitterDupCoords_+3A_min">min</code></td>
<td>
<p>numeric scalar defining minimum jittering distance. </p>
</td></tr>
<tr><td><code id="jitterDupCoords_+3A_fix.one">fix.one</code></td>
<td>
<p>logical. Whether or not one of the coordinates should
not be jittered.  </p>
</td></tr>
<tr><td><code id="jitterDupCoords_+3A_which.fix">which.fix</code></td>
<td>
<p>single element vector of integer or character,
defining which coordinate won't be jittered.  Only used if <code>fix.one=TRUE</code>.  </p>
</td></tr>
<tr><td><code id="jitterDupCoords_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>jitter2d</code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>jitter2d</code> returns an object of the same type fo the input with
jittered values
</p>
<p><code>jitterDupCoords</code> returns an object of the same type fo the input with
jittered coordinate values only at the duplicated locations
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dup.coords">dup.coords</a></code>, <code><a href="#topic+duplicated.geodata">duplicated.geodata</a></code> for
functions identifying duplicated locations. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating data
dt &lt;- grf(30, cov.p=c(1, .3)) 
dt$coords &lt;- round(dt$coords, dig=2)
## "forcing" some duplicated locations
dt$coords[4,] &lt;- dt$coords[14,] &lt;- dt$coords[24,] &lt;- dt$coords[2,]
dt$coords[17,] &lt;- dt$coords[23,] &lt;- dt$coords[8,]

## jittering a matrix of duplicated coordinates
dt$coords[c(2,4,14,24),]
jitter2d(dt$coords[c(2,4,14,24),], max=0.01)

## jittering only the duplicated locations and comparing with original
cbind(dt$coords, jitterDupCoords(dt$coords, max=0.01))

## creating a now geodata object jittering the duplicated locations of the original one:
dup.coords(dt)
dt1 &lt;- jitterDupCoords(dt, max=0.01)
dup.coords(dt1)
</code></pre>

<hr>
<h2 id='kattegat'>Kattegat basin salinity data</h2><span id='topic+kattegat'></span>

<h3>Description</h3>

<p>Salinity measurements at the Kattegat basin, Denmark. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kattegat)</code></pre>


<h3>Format</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code>  <code>"geodata"</code>,
which is list with three components:  
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of the data locations. The
distance are given in kilometers.  </p>
</dd>
<dt><code>data</code></dt><dd><p>values of the piezometric head. The unit is heads
to meters.  </p>
</dd>
<dt><code>dk</code></dt><dd><p>a list with cooordinates of lines defining borders
and islands across the study area.  </p>
</dd>    
</dl>



<h3>Source</h3>

<p>National Environmental Research Institute, 
Arhus University, Denmark and the Swedish Meteorological and Hydrological Institute.
</p>


<h3>References</h3>

<p>Diggle, P. J. and Lophaven, S. (2006). Bayesian geostatistical
design. <em>Scandinavian Journal of Statistics</em>, 33: 55-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(550,770),c(6150,6420),type="n",xlab="X UTM",ylab="Y UTM")
points(kattegat, add=TRUE)
lapply(kattegat$dk, lines, lwd=2)
</code></pre>

<hr>
<h2 id='krige.bayes'>Bayesian Analysis for Gaussian Geostatistical Models</h2><span id='topic+krige.bayes'></span><span id='topic+model.control'></span><span id='topic+prior.control'></span><span id='topic+post2prior'></span><span id='topic+print.krige.bayes'></span><span id='topic+print.posterior.krige.bayes'></span>

<h3>Description</h3>

<p>The function <code>krige.bayes</code> performs Bayesian analysis of
geostatistical data allowing specifications of
different levels of uncertainty in the model parameters.<br />
It returns results on the posterior distributions for the model
parameters and on the predictive distributions for prediction
locations (if provided).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige.bayes(geodata, coords = geodata$coords, data = geodata$data,
            locations = "no", borders, model, prior, output)

model.control(trend.d = "cte", trend.l = "cte", cov.model = "matern",
              kappa = 0.5, aniso.pars = NULL, lambda = 1)

prior.control(beta.prior = c("flat", "normal", "fixed"),
              beta = NULL, beta.var.std = NULL,
              sigmasq.prior = c("reciprocal", "uniform",
                                "sc.inv.chisq", "fixed"),
              sigmasq = NULL, df.sigmasq = NULL,
              phi.prior = c("uniform", "exponential","fixed",
                            "squared.reciprocal", "reciprocal"),
              phi = NULL, phi.discrete = NULL,
              tausq.rel.prior = c("fixed", "uniform", "reciprocal"),
              tausq.rel, tausq.rel.discrete = NULL)

post2prior(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.bayes_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix where each row has the 2-D
coordinates of the <code class="reqn">n</code> data locations.
By default it takes the
component <code>coords</code> of the argument <code>geodata</code>, if provided.
</p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_data">data</code></td>
<td>
<p>a vector with <em>n</em> data values. By default it takes the
component <code>data</code> of the argument <code>geodata</code>, if provided.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">N \times 2</code> matrix or data-frame with the 2-D
coordinates of the <code class="reqn">N</code> prediction locations, or a list for which
the first two components are used. Input is internally checked by the
function <code>check.locations</code>. 
Defaults to <code>"no"</code> in which case
the function returns only results on the posterior distributions of
the model parameters.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_borders">borders</code></td>
<td>
<p>optional. If missing,
by default reads the element <code>borders</code>
from the <code>geodata</code> object, if present.
Setting to <code>NULL</code> preents this behavior.
If a two column matrix defining a polygon is
provided the prediction is performed only at locations inside this polygon. </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_model">model</code></td>
<td>
<p>a list defining the fixed components of the model.
It can take an output to a call to <code>model.control</code> or
a list with elements as for the arguments in <code>model.control</code>.
Default values are assumed for arguments not provided.
See section DETAILS below.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_prior">prior</code></td>
<td>
<p>a list with the specification of priors for the model
parameters.
It can take an output to a call to <code>prior.control</code> or
a list with elements as for the arguments in <code>prior.control</code>.
Default values are assumed for arguments not provided.
See section DETAILS below.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_output">output</code></td>
<td>
<p>a list specifying output options.
It can take an output to a call to <code>output.control</code> or
a list with elements as for the arguments in <code>output.control</code>.
Default values are assumed for arguments not provided.
See documentation for
<code><a href="#topic+output.control">output.control</a></code> for further details.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_trend.d">trend.d</code></td>
<td>
<p>specifies the trend (covariates) values at the data
locations. See documentation
of <code><a href="#topic+trend.spatial">trend.spatial</a></code> for further details.
Defaults to <code>"cte"</code>.  </p>
</td></tr>  
<tr><td><code id="krige.bayes_+3A_trend.l">trend.l</code></td>
<td>
<p>specifies the trend (covariates) at the prediction
locations. Must be of the same type as defined for <code>trend.d</code>.
Only used if prediction locations are provided in the argument
<code>locations</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_cov.model">cov.model</code></td>
<td>
<p>string indicating the name of the model for the correlation function. Further details in the
documentation for <code><a href="#topic+cov.spatial">cov.spatial</a></code>. </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_kappa">kappa</code></td>
<td>
<p>additional smoothness parameter. Only used if the
correlation function is one of: <code>"matern"</code>,
<code>"powered.exponential"</code>, <code>"cauchy"</code> or
<code>"gneiting.matern"</code>. In the current implementation this
parameter is always regarded as fixed during the Bayesian analysis.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_aniso.pars">aniso.pars</code></td>
<td>
<p>fixed parameters for geometric anisotropy
correction. If <code>aniso.pars = FALSE</code> no correction is made, otherwise
a two elements vector with values for the anisotropy parameters
must be provided. Anisotropy correction consists of a
transformation of the data and prediction coordinates performed
by the function <code><a href="#topic+coords.aniso">coords.aniso</a></code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_lambda">lambda</code></td>
<td>
<p>numerical value of the Box-Cox transformation parameter.
The value <code class="reqn">\lambda = 1</code> corresponds to
no transformation. The Box-Cox parameter <code class="reqn">\lambda</code>
is always regarded as fixed and
data transformation is 
performed before the analysis.
Prediction results are back-transformed and
returned is the same scale as for the original data.
For <code class="reqn">\lambda = 0</code> the log-transformation is performed.
If <code class="reqn">\lambda &lt; 0</code> the mean predictor doesn't make sense
(the resulting distribution has no expectation).  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_beta.prior">beta.prior</code></td>
<td>
<p>prior distribution for the mean (vector)
parameter <code class="reqn">\beta</code>. The options are &quot;flat&quot; (default),
&quot;normal&quot; or &quot;fixed&quot; (known mean).  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_beta">beta</code></td>
<td>
<p>mean hyperparameter for the distribution of the mean (vector) parameter        <code class="reqn">\beta</code>. Only used if <code>beta.prior = "normal"</code> or
<code>beta.prior = "fixed"</code>. For the later <code>beta</code> defines the value of
the known mean.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_beta.var.std">beta.var.std</code></td>
<td>
<p>standardised (co)variance hyperparameter(s)
for the prior for the mean
(vector) parameter <code class="reqn">\beta</code>.
The (co)variance matrix for<code class="reqn">\beta</code> is given by the
multiplication of this matrix by <code class="reqn">\sigma^2</code>.
Only used if <code>beta.prior = "normal"</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_sigmasq.prior">sigmasq.prior</code></td>
<td>
<p>specifies the prior for the parameter
<code class="reqn">\sigma^2</code>. If <code>"reciprocal"</code> (the default), the prior 
<code class="reqn">\frac{1}{\sigma^2}</code> is used. Otherwise the
parameter is regarded as fixed.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_sigmasq">sigmasq</code></td>
<td>
<p>fixed value of the sill parameter
<code class="reqn">\sigma^2</code>. Only used if 
<code>sigmasq.prior = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_df.sigmasq">df.sigmasq</code></td>
<td>
<p>numerical. Number of degrees of freedom for the
prior for the parameter <code class="reqn">\sigma^2</code>. Only used if
<code>sigmasq.prior = "sc.inv.chisq"</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_phi.prior">phi.prior</code></td>
<td>
<p>prior distribution for the range parameter
<code class="reqn">\phi</code>.
Options are: <code>"uniform"</code>, <code>"exponential"</code>,
<code>"reciprocal"</code> , <code>"squared.reciprocal"</code> and
<code>"fixed"</code>.
Alternativelly, a user defined discrete distribution can be
specified. In this case the argument takes a vector of numerical
values of probabilities with corresponding support points
provided in the argument <code>phi.discrete</code>. <br />     
If <code>"fixed"</code> the argument <code class="reqn">\phi</code>
must be provided and is regarded as fixed when performing predictions.<br />
For the exponential prior the argument <code>phi</code> must provide
the value for of hyperparameter <code class="reqn">\nu</code> which corresponds to the
expected value for this distribution.
</p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_phi">phi</code></td>
<td>
<p>fixed value of the range parameter <code class="reqn">\phi</code>. Only needed if
<code>phi.prior = "fixed"</code> or if <code>phi.prior = "exponential"</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_phi.discrete">phi.discrete</code></td>
<td>
<p>support points of the discrete prior
for the range parameter <code class="reqn">\phi</code>. The default is a sequence
of 51 values between 0 and 2 times the maximum distance between the
data locations.</p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_tausq.rel.prior">tausq.rel.prior</code></td>
<td>
<p>specifies a prior distribution for the
relative nugget parameter
<code class="reqn">\frac{\tau^2}{\sigma^2}</code>.
If <code>tausq.rel.prior = "fixed"</code> the relative nugget is
considered known (fixed) with value given by the argument
<code>tausq.rel</code>.
If <code>tausq.rel.prior = "uniform"</code> a discrete uniform prior is used
with support points given by the argument
<code>tausq.rel.discrete</code>.
Alternativelly, a user defined discrete distribution can be
specified. In this case the argument takes the a vector of
probabilities of a discrete distribution and the support points
should be provided in the argument <code>tausq.rel.discrete</code>.      
</p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_tausq.rel">tausq.rel</code></td>
<td>
<p>fixed value for the relative nugget parameter.
Only used if
<code>tausq.rel.prior = "fixed"</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_tausq.rel.discrete">tausq.rel.discrete</code></td>
<td>
<p>support points of the discrete prior
for the relative nugget parameter <code class="reqn">\frac{\tau^2}{\sigma^2}</code>.  </p>
</td></tr>
<tr><td><code id="krige.bayes_+3A_obj">obj</code></td>
<td>
<p>an object of the class <code>krige.bayes</code> or
<code>posterior.krige.bayes</code> with the output of a call to
<code>krige.bayes</code>. The function <code>post2prior</code> takes the
posterior distribution computed by one call to <code>krige.bayes</code>
and prepares it to be used a a prior in a subsequent call. Notice
that in this case the function <code>post2prior</code> is used instead
of <code>prior.control</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>krige.bayes</code> is a generic function for Bayesian geostatistical 
analysis of (transformed) Gaussian where predictions take into account the  parameter
uncertainty.
</p>
<p>It can be set to run conventional kriging methods which
use known parameters or <em>plug-in</em> estimates. However, the
functions <code>krige.conv</code> and <code>ksline</code> are preferable for
prediction with fixed parameters.<br />
</p>
<p><b>PRIOR SPECIFICATION</b>
</p>
<p>The basis of the Bayesian algorithm is the discretisation of the prior
distribution for the parameters <code class="reqn">\phi</code> and <code class="reqn">\tau^2_{rel}
    =\frac{\tau^2}{\sigma^2}</code>.
The Tech. Report (see <code>References</code> below)
provides details on the results used in the current implementation.<br />
The expressions of the implemented priors for the parameter <code class="reqn">\phi</code>
are:
</p>

<dl>
<dt>&quot;uniform&quot;: </dt><dd><p><code class="reqn">p(\phi) \propto 1</code>. </p>
</dd>
<dt>&quot;exponential&quot;: </dt><dd><p><code class="reqn">p(\phi) = \frac{1}{\nu}
	\exp(-\frac{1}{\nu} * \phi)</code>.  </p>
</dd>
<dt>&quot;reciprocal&quot;: </dt><dd><p><code class="reqn">p(\phi) \propto \frac{1}{\phi}</code>.  </p>
</dd>
<dt>&quot;squared.reciprocal&quot;: </dt><dd><p><code class="reqn">p(\phi) \propto
	\frac{1}{\phi^2}</code>.  </p>
</dd>
<dt>&quot;fixed&quot;: </dt><dd><p>fixed known or estimated value of <code class="reqn">\phi</code>.  </p>
</dd>
</dl>

<p>The expressions of the implemented priors for the parameter <code class="reqn">\tau^2_{rel}</code>
are:
</p>

<dl>
<dt>&quot;fixed&quot;: </dt><dd><p>fixed known or estimated value of
<code class="reqn">\tau^2_{rel}</code>. Defaults to zero. </p>
</dd>
<dt>&quot;uniform&quot;: </dt><dd><p><code class="reqn">p(\tau^2_{rel}) \propto 1</code>. </p>
</dd>
<dt>&quot;reciprocal&quot;: </dt><dd><p><code class="reqn">p(\tau^2_{rel}) \propto \frac{1}{\tau^2_{rel}}</code>.  </p>
</dd>
</dl>

<p>Apart from those a <em>user defined</em> prior can be specifyed  by
entering a vector of probabilities for a discrete distribution 
with suport points given by the argument <code>phi.discrete</code> and/or
<code>tausq.rel.discrete</code>.<br />
</p>
<p><b>CONTROL FUNCTIONS</b>
</p>
<p>The function call includes auxiliary control functions which allows
the user to specify and/or change the specification of model
components
(using <code>model.control</code>), prior
distributions (using <code>prior.control</code>) and 
output options (using <code>output.control</code>).
Default options are available in most of the cases.
</p>


<h3>Value</h3>

<p>An object with <code><a href="base.html#topic+class">class</a></code> <code>"krige.bayes"</code> and
<code>"kriging"</code>.
The attribute <code>prediction.locations</code> containing the name of the
object with the coordinates of the prediction locations (argument
<code>locations</code>) is assigned to the object.
Returns a list with the following components:  
</p>
<table>
<tr><td><code>posterior</code></td>
<td>
<p>results on on the posterior distribution of the
model parameters. A list with the following possible components:<br />  </p>
</td></tr>
</table>
   
<dl>
<dt>beta </dt><dd><p>summary information on the posterior distribution
of the mean parameter <code class="reqn">\beta</code>.  </p>
</dd>
<dt>sigmasq </dt><dd><p>summary information on the posterior distribution
of the variance parameter <code class="reqn">\sigma^2</code> (partial sill).  </p>
</dd>
<dt>phi </dt><dd><p>summary information on the posterior distribution
of the correlation parameter <code class="reqn">\phi</code> (range parameter) .  </p>
</dd>
<dt>tausq.rel </dt><dd><p>summary information on the posterior distribution
of the relative nugget variance parameter
<code class="reqn">\tau^2_{rel} </code>.  </p>
</dd>
<dt>joint.phi.tausq.rel</dt><dd><p>information on discrete the joint
distribution of these parameters.  </p>
</dd>
<dt>sample </dt><dd><p>a data.frame with a sample from the posterior
distribution.
Each column corresponds to one of the basic model parameters.  </p>
</dd>
</dl>

<table>
<tr><td><code>predictive</code></td>
<td>
<p>results on the predictive distribution at the
prediction locations, if provided.
A list with the following possible components:  </p>
</td></tr>
</table>
    
<dl>
<dt>mean </dt><dd><p>expected values.  </p>
</dd>
<dt>variance </dt><dd><p>expected variance.  </p>
</dd>
<dt>distribution </dt><dd><p>type of posterior distribution.  </p>
</dd>
<dt>mean.simulations </dt><dd><p>mean of the simulations at each locations.  </p>
</dd>
<dt>variance.simulations </dt><dd><p>variance of the simulations at each locations.  </p>
</dd>
<dt>quantiles.simulations </dt><dd><p>quantiles computed from the the simulations.  </p>
</dd>
<dt>probabilities.simulations </dt><dd><p>probabilities computed from the simulations.  </p>
</dd>
<dt>simulations </dt><dd><p>simulations from the predictive distribution.  </p>
</dd>
</dl>

<table>
<tr><td><code>prior</code></td>
<td>
<p>a list with information on the prior distribution
and hyper-parameters of the model parameters (<code class="reqn">\beta, \sigma^2,
      \phi, \tau^2_{rel}</code>).
</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>model specification as defined by <code>model.control</code>.  </p>
</td></tr>
<tr><td><code>.Random.seed</code></td>
<td>
<p>system random seed before running the function.
Allows reproduction of results. If
the <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> is set to this value and the function is run
again, it will produce exactly the same results.  </p>
</td></tr>
<tr><td><code>max.dist</code></td>
<td>
<p>maximum distance found between two data locations.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Diggle, P.J. &amp; Ribeiro Jr, P.J. (2002) Bayesian inference in
Gaussian model-based geostatistics. Geographical and Environmental
Modelling, Vol. 6, No. 2, 129-146.
</p>
<p>The technical details about the  implementation of <code>krige.bayes</code> can be
found at:<br />
Ribeiro, P.J. Jr. and Diggle, P.J. (1999) <em>Bayesian inference in
Gaussian model-based geostatistics</em>. Tech. Report ST-99-08, Dept
Maths and Stats, Lancaster University.<br />
Available at:
<a href="http://www.leg.ufpr.br/geoR/geoRdoc/bayeskrige.pdf">http://www.leg.ufpr.br/geoR/geoRdoc/bayeskrige.pdf</a>
</p>
<p>Further information about <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.  
</p>
<p>For a extended list of examples of the usage
see <a href="http://www.leg.ufpr.br/geoR/tutorials/examples.krige.bayes.R">http://www.leg.ufpr.br/geoR/tutorials/examples.krige.bayes.R</a>
and/or the <span class="pkg">geoR</span> tutorials page at
<a href="http://www.leg.ufpr.br/geoR/tutorials/">http://www.leg.ufpr.br/geoR/tutorials/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel.krige.bayes">lines.variomodel.krige.bayes</a></code>,
<code><a href="#topic+plot.krige.bayes">plot.krige.bayes</a></code> for outputs related to the
parameters in the model,
<code><a href="#topic+image.krige.bayes">image.krige.bayes</a></code> and
<code><a href="#topic+persp.krige.bayes">persp.krige.bayes</a></code> for graphical output of
prediction results.  
<code><a href="#topic+krige.conv">krige.conv</a></code> and
<code><a href="#topic+ksline">ksline</a></code> for conventional kriging methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generating a simulated data-set
ex.data &lt;- grf(70, cov.pars=c(10, .15), cov.model="matern", kappa=2)
#
# defining the grid of prediction locations:
ex.grid &lt;- as.matrix(expand.grid(seq(0,1,l=21), seq(0,1,l=21)))
#
# computing posterior and predictive distributions
# (warning: the next command can be time demanding)
ex.bayes &lt;- krige.bayes(ex.data, loc=ex.grid,
                 model = model.control(cov.m="matern", kappa=2),
                 prior = prior.control(phi.discrete=seq(0, 0.7, l=51),
                             phi.prior="reciprocal"))
#
# Prior and posterior for the parameter phi
plot(ex.bayes, type="h", tausq.rel = FALSE, col=c("red", "blue"))
#
# Plot histograms with samples from the posterior
par(mfrow=c(3,1))
hist(ex.bayes)
par(mfrow=c(1,1))

# Plotting empirical variograms and some Bayesian estimates:
# Empirical variogram
plot(variog(ex.data, max.dist = 1), ylim=c(0, 15))
# Since ex.data is a simulated data we can plot the line with the "true" model 
lines.variomodel(ex.data, lwd=2)
# adding lines with summaries of the posterior of the binned variogram
lines(ex.bayes, summ = mean, lwd=1, lty=2)
lines(ex.bayes, summ = median, lwd=2, lty=2)
# adding line with summary of the posterior of the parameters
lines(ex.bayes, summary = "mode", post = "parameters")

# Plotting again the empirical variogram
plot(variog(ex.data, max.dist=1), ylim=c(0, 15))
# and adding lines with median and quantiles estimates
my.summary &lt;- function(x){quantile(x, prob = c(0.05, 0.5, 0.95))}
lines(ex.bayes, summ = my.summary, ty="l", lty=c(2,1,2), col=1)

# Plotting some prediction results
op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=c(4,4,2.5,0.5), mgp = c(2,1,0))
image(ex.bayes, main="predicted values")
image(ex.bayes, val="variance", main="prediction variance")
image(ex.bayes, val= "simulation", number.col=1,
      main="a simulation from the \npredictive distribution")
image(ex.bayes, val= "simulation", number.col=2,
      main="another simulation from \nthe predictive distribution")
#
par(op)

## End(Not run)
##
## For a extended list of exemples of the usage of krige.bayes()
## see http://www.leg.ufpr.br/geoR/tutorials/examples.krige.bayes.R
##

</code></pre>

<hr>
<h2 id='krige.conv'>Spatial Prediction &ndash; Conventional Kriging</h2><span id='topic+krige.conv'></span><span id='topic+krige.control'></span>

<h3>Description</h3>

<p>This function performs spatial prediction for fixed covariance
parameters using global neighbourhood.
</p>
<p>Options available implement the following types of kriging:
<em>SK</em> (simple kriging), <em>OK</em> (ordinary kriging),
<em>KTE</em> (external trend kriging) and <em>UK</em> (universal kriging). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige.conv(geodata, coords=geodata$coords, data=geodata$data,
           locations, borders, krige, output)

krige.control(type.krige = "ok", trend.d = "cte", trend.l = "cte",
            obj.model = NULL, beta, cov.model, cov.pars, kappa,
            nugget, micro.scale = 0, dist.epsilon = 1e-10, 
            aniso.pars, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.conv_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. Typically an object of the <code><a href="base.html#topic+class">class</a></code>
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix or data-frame with the 2-D
coordinates of the <code class="reqn">n</code> data locations.
By default it takes the
component <code>coords</code> of the argument <code>geodata</code>, if provided.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_data">data</code></td>
<td>
<p>a vector with <em>n</em> data values. By default it takes the
component <code>data</code> of the argument <code>geodata</code>, if provided.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">N \times 2</code> matrix or data-frame with the 2-D
coordinates of the <code class="reqn">N</code> prediction locations, or a list for which
the first two components are used. Input is internally checked by the
function <code>check.locations</code>.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_borders">borders</code></td>
<td>
<p>optional. By default reads the element <code>borders</code>
from the <code>geodata</code> object, if present.
Setting to <code>NULL</code> prevents this behavior.
If a two column matrix defining a polygon is
provided the prediction is performed only at locations inside this polygon. </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_krige">krige</code></td>
<td>
<p>a list defining the model components and the type of
kriging. It can take an output to a call to <code>krige.control</code> or
a list with elements as for the arguments in <code>krige.control</code>.
Default values are assumed for arguments  or list elements not provided.
See arguments for &lsquo;krige.control&rsquo;.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_output">output</code></td>
<td>
<p>a list specifying output options.
It can take an output to a call to <code>output.control</code> or
a list with elements as for the arguments in <code>output.control</code>.
Default values are assumed for arguments not provided.
See documentation for
<code><a href="#topic+output.control">output.control</a></code> for further details.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_type.krige">type.krige</code></td>
<td>
<p>type of kriging to be performed. Options are
<code>"SK", "OK"</code> corresponding to simple or ordinary
kriging. Kriging with external trend and universal kriging can be
defined setting <code>type.krige = "OK"</code> and specifying the
trend model using the arguments <code>trend.d</code> and
<code>trend.l</code>.  </p>
</td></tr> 
<tr><td><code id="krige.conv_+3A_trend.d">trend.d</code></td>
<td>
<p>specifies the trend (covariate) values at the data
locations.
See documentation of <code><a href="#topic+trend.spatial">trend.spatial</a></code> for
further details.
Defaults to <code>"cte"</code>.   </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_trend.l">trend.l</code></td>
<td>
<p>specifies the trend (covariate) values at prediction
locations. It must be of the same type as for <code>trend.d</code>.
Only used if prediction locations are provided in the argument
<code>locations</code>.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_obj.model">obj.model</code></td>
<td>
<p>a list with the model parameters. Typically an
output of <code><a href="#topic+likfit">likfit</a></code> or
<code><a href="#topic+variofit">variofit</a></code>.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_beta">beta</code></td>
<td>
<p>numerical value of the mean (vector) parameter.
Only used if <code>type.krige="SK"</code>.</p>
</td></tr>  
<tr><td><code id="krige.conv_+3A_cov.model">cov.model</code></td>
<td>
<p>string indicating the name of the model for the
correlation function. Further details  can be found in the
documentation of the function
<code><a href="#topic+cov.spatial">cov.spatial</a></code>.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a 2 elements vector with values of the covariance parameters <code class="reqn">\sigma^2</code>
(partial sill)  and <code class="reqn">\phi</code> (range parameter),
respectively.  </p>
</td></tr>

<tr><td><code id="krige.conv_+3A_kappa">kappa</code></td>
<td>
<p>additional smoothness parameter required by the following correlation
functions: <code>"matern"</code>, <code>"powered.exponential"</code>, <code>"cauchy"</code> and
<code>"gneiting.matern"</code>.   </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_nugget">nugget</code></td>
<td>
<p>the value of the nugget variance parameter <code class="reqn">\tau^2</code>. Defaults to zero.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_micro.scale">micro.scale</code></td>
<td>
<p>micro-scale variance. If different from zero, the
nugget variance is divided into 2 terms: <em>micro-scale variance</em>
and <em>measurement error</em>. This affect the precision of the predictions. 
Often in practice, these two variance components are indistinguishable but the
distinction can be made here if justifiable. See the section
<code>DETAILS</code> in the documentation of <code><a href="#topic+output.control">output.control</a></code>. </p>
</td></tr> 
<tr><td><code id="krige.conv_+3A_dist.epsilon">dist.epsilon</code></td>
<td>
<p>a numeric value. Locations which are separated
by a distance less than this value
are considered co-located.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_aniso.pars">aniso.pars</code></td>
<td>
<p>parameters for geometric anisotropy
correction. If <code>aniso.pars = FALSE</code> no correction is made, otherwise
a two elements vector with values for the anisotropy parameters
must be provided. Anisotropy correction consists of a
transformation of the data and prediction coordinates performed
by the function <code><a href="#topic+coords.aniso">coords.aniso</a></code>.  </p>
</td></tr>
<tr><td><code id="krige.conv_+3A_lambda">lambda</code></td>
<td>
<p>numeric value of the Box-Cox transformation parameter.
The value <code class="reqn">\lambda = 1</code> corresponds to
no transformation and <code class="reqn">\lambda = 0</code> corresponds to
the log-transformation. 
Prediction results are back-transformed and
returned is the same scale as for the original data.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the arguments provided,  one of the following different
types of kriging: <em>SK</em>, <em>OK</em>, <em>UK</em> or  <em>KTE</em>
is performed.
Defaults correspond to ordinary kriging.
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>kriging</code>.
The attribute <code>prediction.locations</code> containing the name of the
object with the coordinates of the prediction locations (argument
<code>locations</code>) is assigned to the object.
Returns  a  list with the following components:
</p>
<table>
<tr><td><code>predict</code></td>
<td>
<p>a vector with predicted values.  </p>
</td></tr>
<tr><td><code>krige.var</code></td>
<td>
<p>a vector with predicted variances.  </p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>estimates of the <code class="reqn">\beta</code>, parameter
implicit in kriging procedure. Not included if <code>type.krige = "SK"</code>.  </p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>
<p>an <code class="reqn">ni \times n.sim</code> matrix where <code class="reqn">ni</code> is the
number of prediction locations. Each column corresponds to a
conditional simulation of the predictive distribution.
Only returned if <code>n.sim &gt; 0</code>.  </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>messages about the type of prediction performed.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>
<p>Other results can be included depending on the options passed to
<code><a href="#topic+output.control">output.control</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+output.control">output.control</a></code> sets output options,
<code><a href="#topic+image.kriging">image.kriging</a></code> and <code><a href="#topic+persp.kriging">persp.kriging</a></code>
for graphical output of the results,
<code><a href="#topic+krige.bayes">krige.bayes</a></code> for Bayesian prediction and <code><a href="#topic+ksline">ksline</a></code>
for a different implementation of kriging allowing for moving
neighborhood. For model fitting see <code><a href="#topic+likfit">likfit</a></code> or <code><a href="#topic+variofit">variofit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Defining a prediction grid
loci &lt;- expand.grid(seq(0,1,l=21), seq(0,1,l=21))
# predicting by ordinary kriging
kc &lt;- krige.conv(s100, loc=loci,
                 krige=krige.control(cov.pars=c(1, .25)))
# mapping point estimates and variances
par.ori &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2), mar=c(3.5,3.5,1,0), mgp=c(1.5,.5,0))
image(kc, main="kriging estimates")
image(kc, val=sqrt(kc$krige.var), main="kriging std. errors")
# Now setting the output to simulate from the predictive
# (obtaining conditional simulations),
# and to compute quantile and probability estimators
s.out &lt;- output.control(n.predictive = 1000, quant=0.9, thres=2)
set.seed(123)
kc &lt;- krige.conv(s100, loc = loci,
         krige = krige.control(cov.pars = c(1,.25)),
         output = s.out)
par(mfrow=c(2,2))
image(kc, val=kc$simul[,1], main="a cond. simul.")
image(kc, val=kc$simul[,1], main="another cond. simul.")
image(kc, val=(1 - kc$prob), main="Map of P(Y &gt; 2)")
image(kc, val=kc$quant, main="Map of y s.t. P(Y &lt; y) = 0.9")
par(par.ori)

## End(Not run)
</code></pre>

<hr>
<h2 id='krweights'>Computes kriging weights</h2><span id='topic+krweights'></span>

<h3>Description</h3>

<p>Computes the weights assign for each data point in simple and ordinary
krigring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krweights(coords, locations, krige)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krweights_+3A_coords">coords</code></td>
<td>
<p>matrix with data coordinates</p>
</td></tr>
<tr><td><code id="krweights_+3A_locations">locations</code></td>
<td>
<p>matrix with coordinates of the prediciton  points</p>
</td></tr>
<tr><td><code id="krweights_+3A_krige">krige</code></td>
<td>
<p>kriging parameters. See krige.control in krige.conv</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Figure 8.4 in Webster and Oliver (2001), see help(wo)
attach(wo)
par(mfrow=c(2,2))
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC1 &lt;- krige.control(cov.pars=c(0.382,90.53))
w1 &lt;- krweights(wo$coords, loc=x1, krige=KC1)
text(coords[,1], 5+coords[,2], round(w1, dig=3))
##
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC2 &lt;- krige.control(cov.pars=c(0.282,90.53), nug=0.1)
w2 &lt;- krweights(wo$coords, loc=x1, krige=KC2)
text(coords[,1], 5+coords[,2], round(w2, dig=3))
##
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC3 &lt;- krige.control(cov.pars=c(0.082,90.53), nug=0.3)
w3 &lt;- krweights(wo$coords, loc=x1, krige=KC3)
text(coords[,1], 5+coords[,2], round(w3, dig=3))
##
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC4 &lt;- krige.control(cov.pars=c(0,90.53), nug=0.382, micro=0.382)
w4 &lt;- krweights(wo$coords, loc=x1, krige=KC4)
text(coords[,1], 5+coords[,2], round(w4, dig=3))
##
## SK vs OK
##
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC5 &lt;- krige.control(cov.pars=c(0.382,50))
w5 &lt;- krweights(wo$coords, loc=x1, krige=KC5)
KC6 &lt;- krige.control(type="sk", beta=2, cov.pars=c(0.382,50))
w6 &lt;- krweights(wo$coords, loc=x1, krige=KC6)
text(coords[,1],  5+coords[,2], round(w5, dig=3))
text(coords[,1], -5+coords[,2], round(w6, dig=3))
##
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
KC7 &lt;- krige.control(cov.pars=c(0.382,0))
w7 &lt;- krweights(wo$coords, loc=x1, krige=KC7)
KC8 &lt;- krige.control(type="sk", beta=2, cov.pars=c(0.382,0))
w8 &lt;- krweights(wo$coords, loc=x1, krige=KC8)
text(coords[,1],  5+coords[,2], round(w7, dig=3))
text(coords[,1], -5+coords[,2], round(w8, dig=3))
</code></pre>

<hr>
<h2 id='Ksat'>Saturated Hydraulic Conductivity</h2><span id='topic+Ksat'></span>

<h3>Description</h3>

<p>The data consists of 32 measurements of the saturated hydraulic
conductivity of a soil. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Ksat)</code></pre>


<h3>Format</h3>

<p>The object <code>Ksat</code> is a list of the class <code>geodata</code>
with the following elements:
</p>
    
<dl>
<dt><code>coords</code></dt><dd><p>a matrix with the coordinates of the soil samples.  </p>
</dd>
<dt><code>data</code></dt><dd><p>measurements of the saturated hidraulic conductivity.  </p>
</dd>
<dt><code>borders</code></dt><dd><p>a data-frame with the coordinates of a polygon defining the
borders of the area.  </p>
</dd>
</dl>



<h3>Source</h3>

<p>Data provided by Dr. Décio Cruciani, ESALQ/USP, Brasil.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(Ksat)
plot(Ksat)
</code></pre>

<hr>
<h2 id='ksline'>Spatial Prediction &ndash; Conventional Kriging</h2><span id='topic+ksline'></span><span id='topic+.ksline.aux.1'></span>

<h3>Description</h3>

<p>This function performs spatial prediction for given covariance
parameters. Options implement
the following kriging types:
<em>SK</em> (simple kriging), <em>OK</em> (ordinary kriging),
<em>KTE</em> (external trend kriging) and <em>UK</em> (universal kriging).
</p>
<p>The function <code><a href="#topic+krige.conv">krige.conv</a></code> should be preferred, unless
moving neighborhood is to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksline(geodata, coords = geodata$coords, data = geodata$data,
       locations, borders = NULL, 
       cov.model = "matern",
       cov.pars=stop("covariance parameters (sigmasq and phi) needed"),
       kappa = 0.5, nugget = 0, micro.scale = 0,
       lambda = 1, m0 = "ok", nwin = "full",
       n.samples.backtransform = 500, trend = 1, d = 2,
       ktedata = NULL, ktelocations = NULL, aniso.pars = NULL,
       signal = FALSE, dist.epsilon = 1e-10, messages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksline_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. Typically an object of the <code><a href="base.html#topic+class">class</a></code>
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix where each row has the 2-D
coordinates of the <code class="reqn">n</code> data locations.
By default it takes the
component <code>coords</code> of the argument <code>geodata</code>, if
provided.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_data">data</code></td>
<td>
<p>a vector with <em>n</em> data values. By default it takes the
component <code>data</code> of the argument <code>geodata</code>, if provided.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">N \times 2</code> matrix or data-frame with the 2-D
coordinates of the <code class="reqn">N</code> prediction locations, or a list for which
the first two components are used. Input is internally checked by the
function <code>check.locations</code>.  </p>
</td></tr> 
<tr><td><code id="ksline_+3A_borders">borders</code></td>
<td>
<p>optional. If a two column matrix defining a polygon is
provided the prediction is performed only at locations inside this polygon. </p>
</td></tr>
<tr><td><code id="ksline_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector with 2 elements or an <code class="reqn">n \times 2</code> matrix with the covariance parameters <code class="reqn">\sigma^2</code>
(partial sill)  and <code class="reqn">\phi</code> (range parameter). If a vector, the elements are the values of
<code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code>, respectively.
If a matrix, corresponding to a model with several structures, the
values of <code class="reqn">\sigma^2</code> 
are in the first column and the values of <code class="reqn">\phi</code> are in the second.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_nugget">nugget</code></td>
<td>
<p>the value of the nugget variance parameter <code class="reqn">\tau^2</code>. Defaults to zero.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_micro.scale">micro.scale</code></td>
<td>
<p>micro-scale variance. If different from zero, the
nugget variance is divided into 2 terms: <em>micro-scale variance</em>
and <em>measurement error</em>. This might affect the precision of
the predictions. 
In practice, these two variance components are usually indistinguishable but the
distinction can be made here if justifiable.  </p>
</td></tr> 
<tr><td><code id="ksline_+3A_cov.model">cov.model</code></td>
<td>
<p>string indicating the name of the model for the
correlation function. Further details  in the
documentation for
<code><a href="#topic+cov.spatial">cov.spatial</a></code>.  
Defaults are equivalent to the <em>exponential</em> model.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_kappa">kappa</code></td>
<td>
<p>additional smoothness parameter required by the following correlation
functions: <code>"matern"</code>, 
<code>"powered.exponential"</code>,  
<code>"cauchy"</code>  and  
<code> "gneiting.matern"</code>.   </p>
</td></tr>
<tr><td><code id="ksline_+3A_lambda">lambda</code></td>
<td>
<p>numeric value of the Box-Cox transformation parameter.
The value <code class="reqn">\lambda = 1</code> corresponds to
no transformation and <code class="reqn">\lambda = 0</code> corresponds to
the log-transformation. 
Prediction results are back-transformed and
returned is the same scale as for the original data.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_m0">m0</code></td>
<td>
<p>The default value <code>"ok"</code> indicates that ordinary
kriging will be performed. Other options are <code>"kt"</code> for kriging
with a trend model (universal kriging) and <code>"kte"</code> for kriging
with external trend (covariates). If a numeric value is provided it
is assumed to be the value of a know mean and simple kriging is then
performed.
If <code>"av"</code> the arithmetic mean of the data is assumed to be the
know mean for simple kriging algorithm.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_nwin">nwin</code></td>
<td>
<p>If <code>"full"</code> <em>global neighborhood</em> is used
i.e., all data values are used in the
prediction of every prediction location.
An integer number defines the <em>moving neighborhood</em> algorithm.
The number provided is used as  
the number closest neighbors to be used for the prediction at each
location.
Defaults to <code>"full"</code>.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_n.samples.backtransform">n.samples.backtransform</code></td>
<td>
<p>number of samples used in the
back-transformation. When transformations are used
(specified by an argument <code>lambda</code>), back-transformations
are usually performed by sampling from the predictive distribution and
then back-transforming the sampled values. The exceptions are for
<code class="reqn">\lambda = 0</code> (log-transformation)  and
<code class="reqn">\lambda = 1</code> (no transformation).  </p>
</td></tr>
<tr><td><code id="ksline_+3A_trend">trend</code></td>
<td>
<p>only required if <code>m0 = "kt"</code> (universal kriging).
Possible values are <code class="reqn">1</code> or <code class="reqn">2</code>, corresponding to a first or second degree
polynomial trend on the coordinates, respectively.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_d">d</code></td>
<td>
<p>spatial dimension, <code class="reqn">1</code> defines a prediction on a line, <code class="reqn">2</code> on
a plane (the default).</p>
</td></tr>
<tr><td><code id="ksline_+3A_ktedata">ktedata</code></td>
<td>
<p>only required if <code>m0 = "kte"</code>. A vector or matrix
with the values of the
external trend (covariates) at the data locations.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_ktelocations">ktelocations</code></td>
<td>
<p>only required if <code>m0 = "kte"</code>. A vector or
matrix with the values of the
external trend (covariates) at the prediction locations.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_aniso.pars">aniso.pars</code></td>
<td>
<p>parameters for geometric anisotropy
correction. If <code>aniso.pars = FALSE</code> no correction is made, otherwise
a two elements vector with values for the anisotropy parameters
must be provided. Anisotropy correction consists of a
transformation of the data and prediction coordinates performed
by the function <code><a href="#topic+coords.aniso">coords.aniso</a></code>.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_signal">signal</code></td>
<td>
<p>logical. If <code>TRUE</code> the signal is predicted, otherwise the
variable is predicted. If no transformation is performed the
expectations are the same in both cases and the difference is only for
values of the kriging variance, if the value of the nugget is
different from zero.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_dist.epsilon">dist.epsilon</code></td>
<td>
<p>a numeric value. Points which are separated
by a distance less than this value
are considered co-located.  </p>
</td></tr>
<tr><td><code id="ksline_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates
whether or not status messages are printed on the screen (or other output device)
while the function is running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>kriging</code> which is a  list
with the following components:
</p>
<table>
<tr><td><code>predict</code></td>
<td>
<p>the predicted values.  </p>
</td></tr>
<tr><td><code>krige.var</code></td>
<td>
<p>the kriging variances.  </p>
</td></tr>
<tr><td><code>dif</code></td>
<td>
<p>the difference between the predicted value and the global
mean. Represents the contribution to the neighboring data to
the prediction at each point.  </p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>values of the arithmetic and weighted mean of the data and standard
deviations. The weighted mean corresponds to the estimated value of
the global mean. </p>
</td></tr>
<tr><td><code>ktrend</code></td>
<td>
<p>the matrix with trend if <code>m0 = "kt"</code>
(universal kriging).  </p>
</td></tr>
<tr><td><code>ktetrend</code></td>
<td>
<p>the matrix with trend if <code>m0 = "kte"</code>
(external trend kriging).</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the value of the mean which is implicitly estimated for
<code>m0 = "ok", "kte"</code> or <code>"kt"</code>.</p>
</td></tr>
<tr><td><code>wofmean</code></td>
<td>
<p>weight of mean. The predicted value is an
weighted average between the global mean and the values at the
neighboring locations.
The value returned is the weight of the mean.  </p>
</td></tr>
<tr><td><code>locations</code></td>
<td>
<p>the coordinates of the prediction locations.  </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>status messages returned by the algorithm.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a preliminary and inefficient function implementing kriging methods.
For predictions using global neighborhood the function
<code><a href="#topic+krige.conv">krige.conv</a></code> should be used instead.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.conv">krige.conv</a></code> for a more efficient implementation of
conventional kriging methods, <br /> <code><a href="#topic+krige.bayes">krige.bayes</a></code> for Bayesian prediction.</p>


<h3>Examples</h3>

<pre><code class='language-R'>loci &lt;- expand.grid(seq(0,1,l=31), seq(0,1,l=31))
kc &lt;- ksline(s100, loc=loci, cov.pars=c(1, .25))
par(mfrow=c(1,2))
image(kc, main="kriging estimates")
image(kc, val=sqrt(kc$krige.var), main="kriging std. errors")
</code></pre>

<hr>
<h2 id='landim1'>Data from Landim's book</h2><span id='topic+landim1'></span>

<h3>Description</h3>

<p>Artificial or non-specified data from Paulo Landim's book 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(landim1)</code></pre>


<h3>Format</h3>

<p>A data frame with 38 observations on the following 4 variables.
</p>

<dl>
<dt><code>EW</code></dt><dd><p>a numeric vector with the east-west coordinates. </p>
</dd>
<dt><code>NS</code></dt><dd><p>a numeric vector with the north-south coordinates. </p>
</dd>
<dt><code>A</code></dt><dd><p>a numeric vector with data on a first variable. </p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector with data on a second variable. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Landim, P. M. B. (2004) <em>Análise estatística de dados geológicos</em>. Editora Unesp. 
Data from Table~1, pg.12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(landim)
plot(as.geodata(landim1, data.col=3))
plot(as.geodata(landim1, data.col=4))
</code></pre>

<hr>
<h2 id='legend.krige'>Add a legend to a image with kriging results</h2><span id='topic+legend.krige'></span>

<h3>Description</h3>

<p>This function allows adds a legend to an image plot generated by
<code><a href="#topic+image.kriging">image.kriging</a></code> or <code><a href="#topic+image.krige.bayes">image.krige.bayes</a></code>.
It can be called internally by these functions or directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend.krige(x.leg, y.leg, values, scale.vals,
             vertical = FALSE, offset.leg = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legend.krige_+3A_x.leg">x.leg</code></td>
<td>
<p>limits for the legend in the <code class="reqn">x</code> direction.  </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_y.leg">y.leg</code></td>
<td>
<p>limits for the legend in the <code class="reqn">y</code> direction.  </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_values">values</code></td>
<td>
<p>values plotted in the image.  </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_scale.vals">scale.vals</code></td>
<td>
<p>optional. Values to appear in the legend.
If not provided the function <code><a href="base.html#topic+pretty">pretty</a></code> is used to define
the values.  </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_vertical">vertical</code></td>
<td>
<p>If <code>TRUE</code> the legend is drawn in the vertical
direction. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_offset.leg">offset.leg</code></td>
<td>
<p>numeric value controlling the distance between the
legend text and the legend box. </p>
</td></tr>
<tr><td><code id="legend.krige_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="graphics.html#topic+text">text</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A legend is added to the current plot. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image.kriging">image.kriging</a></code>, <code><a href="#topic+image.krige.bayes">image.krige.bayes</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in the documentation for image.kriging
</code></pre>

<hr>
<h2 id='likfit'>Likelihood Based Parameter Estimation for Gaussian Random Fields</h2><span id='topic+likfit'></span><span id='topic+logLik.likGRF'></span><span id='topic+resid.likGRF'></span><span id='topic+residuals.likGRF'></span><span id='topic+fitted.likGRF'></span><span id='topic+likfit'></span><span id='topic+likfit.limits'></span><span id='topic+.negloglik.GRF'></span><span id='topic+logLik.likGRF'></span><span id='topic+check.parameters.values'></span>

<h3>Description</h3>

<p><em>Maximum likelihood</em> (ML) or <em>restricted maximum likelihood</em> (REML)
parameter estimation for (transformed) Gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likfit(geodata, coords = geodata$coords, data = geodata$data,
       trend = "cte", ini.cov.pars, fix.nugget = FALSE, nugget = 0,
       fix.kappa = TRUE, kappa = 0.5, fix.lambda = TRUE, lambda = 1,
       fix.psiA = TRUE, psiA = 0, fix.psiR = TRUE, psiR = 1, 
       cov.model, realisations, lik.method = "ML", components = TRUE,
       nospatial = TRUE, limits = pars.limits(),
       print.pars = FALSE, messages, ...)

## S3 method for class 'likGRF'
fitted(object, spatial = TRUE, ...)

## S3 method for class 'likGRF'
resid(object, spatial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likfit_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. 
Typically an object of the class <code>"geodata"</code>.
If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix where each row has the 2-D
coordinates of the <code class="reqn">n</code> data locations.
By default it takes the
component <code>coords</code> of the argument <code>geodata</code>, if provided.
</p>
</td></tr>
<tr><td><code id="likfit_+3A_data">data</code></td>
<td>
<p>a vector with <em>n</em> data values. By default it takes the
component <code>data</code> of the argument <code>geodata</code>, if provided.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model. See documentation
of <code><a href="#topic+trend.spatial">trend.spatial</a></code> for further details.
Defaults to <code>"cte"</code>.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_ini.cov.pars">ini.cov.pars</code></td>
<td>
<p>initial values for the covariance parameters:
<code class="reqn">\sigma^2</code> (partial sill) and <code class="reqn">\phi</code> (range
parameter).  Typically a vector with two components. However a
matrix can be used to provide several initial values. See
<code>DETAILS</code> below.</p>
</td></tr>
<tr><td><code id="likfit_+3A_fix.nugget">fix.nugget</code></td>
<td>
<p>logical, indicating whether the parameter
<code class="reqn">\tau^2</code> (nugget variance) should be regarded as fixed
(<code>fix.nugget = TRUE</code>) or should be
estimated (<code>fix.nugget = FALSE</code>). Defaults to
<code>FALSE</code>.  </p>
</td></tr>    
<tr><td><code id="likfit_+3A_nugget">nugget</code></td>
<td>
<p>value of the nugget parameter.
Regarded as a fixed value if <code>fix.nugget = TRUE</code> otherwise
as the initial value for the minimisation algorithm. Defaults to zero.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_fix.kappa">fix.kappa</code></td>
<td>
<p>logical, indicating whether the extra parameter
<code class="reqn">\kappa</code> should be regarded as fixed
(<code>fix.kappa = TRUE</code>) or should be 
estimated (<code>fix.kappa = FALSE</code>). Defaults to <code>TRUE</code>.  </p>
</td></tr>    
<tr><td><code id="likfit_+3A_kappa">kappa</code></td>
<td>
<p>value of the extra parameter <code class="reqn">\kappa</code>.
Regarded as a fixed value if <code>fix.kappa = TRUE</code>
otherwise as the initial value for the minimisation algorithm. Defaults to
<code class="reqn">0.5</code>. This parameter is valid only if the covariance function is one
of: <code>"matern"</code>, <code>"powered.exponential"</code>, <code>"cauchy"</code> or
<code>"gneiting.matern"</code>.  For more details on covariance functions
see documentation for <code><a href="#topic+cov.spatial">cov.spatial</a></code>.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_fix.lambda">fix.lambda</code></td>
<td>
<p>logical, indicating whether the Box-Cox transformation parameter
<code class="reqn">\lambda</code> should be regarded as fixed
(<code>fix.lambda = TRUE</code>) or should be
be estimated (<code>fix.lambda = FALSE</code>). Defaults to <code>TRUE</code>.  </p>
</td></tr>    
<tr><td><code id="likfit_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter
<code class="reqn">\lambda</code>.
Regarded as a fixed value if <code>fix.lambda = TRUE</code> otherwise 
as the initial value for the minimisation algorithm. Defaults to
<code class="reqn">1</code>. Two particular cases are <code class="reqn">\lambda = 1</code>
indicating no transformation and <code class="reqn">\lambda = 0</code> indicating log-transformation.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_fix.psia">fix.psiA</code></td>
<td>
<p>logical, indicating whether the anisotropy angle parameter
<code class="reqn">\psi_R</code> should be regarded as fixed
(<code>fix.psiA = TRUE</code>) or should 
be estimated (<code>fix.psiA = FALSE</code>). Defaults to
<code>TRUE</code>.  </p>
</td></tr>    
<tr><td><code id="likfit_+3A_psia">psiA</code></td>
<td>
<p>value (in radians) for the anisotropy angle parameter
<code class="reqn">\psi_A</code>. 
Regarded as a fixed value if <code>fix.psiA = TRUE</code>
otherwise  as the initial value for the minimisation algorithm.
Defaults to <code class="reqn">0</code>. See <code><a href="#topic+coords.aniso">coords.aniso</a></code> for further
details on anisotropy correction.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_fix.psir">fix.psiR</code></td>
<td>
<p>logical, indicating whether the anisotropy ratio parameter
<code class="reqn">\psi_R</code> should be regarded as fixed
(<code>fix.psiR = TRUE</code>) or should be estimated (<code>fix.psiR = FALSE</code>). Defaults to
<code>TRUE</code>.  </p>
</td></tr>    
<tr><td><code id="likfit_+3A_psir">psiR</code></td>
<td>
<p>value, always greater than 1, for the anisotropy ratio  parameter
<code class="reqn">\psi_R</code>. 
Regarded as a fixed value if <code>fix.psiR = TRUE</code>
otherwise as the initial value for the minimisation algorithm.
Defaults to <code class="reqn">1</code>. See <code><a href="#topic+coords.aniso">coords.aniso</a></code> for further
details on anisotropy correction.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_cov.model">cov.model</code></td>
<td>
<p>a string specifying the model for the correlation
function. For further details see documentation for <code><a href="#topic+cov.spatial">cov.spatial</a></code>.
Reads values from an <code>variomodel</code> object passed to <code>ini.cov.pars</code> if any, otherwise
defaults to the <em>exponential</em> model.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_realisations">realisations</code></td>
<td>
<p>optional. Logical or a vector indicating the number of replication
for each datum. For further information see <code>DETAILS</code> below and
documentation for <code><a href="#topic+as.geodata">as.geodata</a></code>. </p>
</td></tr>
<tr><td><code id="likfit_+3A_lik.method">lik.method</code></td>
<td>
<p>(formely method.lik) options are <code>"ML"</code> for maximum likelihood and <code>"REML"</code> for
restricted maximum likelihood. Defaults to <code>"ML"</code>.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_components">components</code></td>
<td>
<p>an <code class="reqn">n \times 3</code> data-frame with fitted
values for the three model components: trend, spatial and residuals.
See the section <code>DETAILS</code> below for the model specification.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_nospatial">nospatial</code></td>
<td>
<p>logical. If <code>TRUE</code> parameter estimates for the
model without spatial component are included in the output.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_limits">limits</code></td>
<td>
<p>values defining lower and upper limits for the model
parameters used in the numerical minimisation.
The auxiliary function <code><a href="#topic+pars.limits">pars.limits</a></code> is called to set
the limits.
See also <b>Limits</b> in DETAILS below.</p>
</td></tr>
<tr><td><code id="likfit_+3A_print.pars">print.pars</code></td>
<td>
<p>logical. If <code>TRUE</code> the parameters and the value
of the negative log-likelihood (up to a constant) are printed each
time the function to be minimised is called.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates whether
status messages should be printed on the screen (or output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the minimisation
function. Typically  arguments of the type  <code>control()</code> which controls the
behavior of the minimisation algorithm. For further details see documentation 
for the minimisation function <code><a href="stats.html#topic+optim">optim</a></code>.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_object">object</code></td>
<td>
<p>an object with output of the function <code>likfit</code>.  </p>
</td></tr>
<tr><td><code id="likfit_+3A_spatial">spatial</code></td>
<td>
<p>logical, determines whether the spatial component of
the model in included in the output. The geostatistical model
components are: <em>trend</em>, <em>spatial</em> and <em>residulas</em>.
See DETAILS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimate the parameters of the Gaussian random field model,
specified as:
</p>
<p style="text-align: center;"><code class="reqn">Y(x) = \mu(x) + S(x) + e</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">x</code> defines a spatial location. Typically Euclidean
coordinates on a plane. 
</p>
</li>
<li> <p><code class="reqn">Y</code> is the variable been observed.
</p>
</li>
<li> <p><code class="reqn">\mu(x) = X\beta</code> is the mean component of
the model (trend). 
</p>
</li>
<li> <p><code class="reqn">S(x)</code> is a stationary Gaussian process with variance <code class="reqn">\sigma^2</code>
(partial sill) and a correlation function parametrized in its
simplest form by <code class="reqn">\phi</code> (the range parameter). Possible extra parameters
for the correlation function are the smoothness parameter
<code class="reqn">\kappa</code> and the anisotropy parameters <code class="reqn">\phi_R</code> and
<code class="reqn">\phi_A</code> (anisotropy ratio and angle, respectively).  
</p>
</li>
<li> <p><code class="reqn">e</code> is the error term with variance parameter  <code class="reqn">\tau^2</code>
(nugget variance).
</p>
</li></ul>

<p>The additional parameter <code class="reqn">\lambda</code> allows for the Box-Cox
transformation of the response variable.
If used (i.e. if <code class="reqn">\lambda \neq 1</code>) <code class="reqn">Y(x)</code> above is replaced by <code class="reqn">g(Y(x))</code>
such that
</p>
<p style="text-align: center;"><code class="reqn">g(Y(x)) = \frac{Y^\lambda(x) - 1}{\lambda}.</code>
</p>

<p>Two particular cases are <code class="reqn">\lambda = 1</code>
which indicates no transformation and <code class="reqn">\lambda = 0</code>
indicating the log-transformation.
</p>
<p><b>Numerical minimization</b>
</p>
<p>In general parameter estimation is performed numerically using the <span class="rlang"><b>R</b></span>
function <code><a href="stats.html#topic+optim">optim</a></code> to minimise the
negative log-likelihood computed by the function <code>negloglik.GRF</code>.
If the nugget, anisotropy (<code class="reqn">\psi_A, \psi_R</code>),
smoothness (<code class="reqn">\kappa</code>) and transformation (<code class="reqn">\lambda</code>) parameters
are held fixed then the numerical minimisation can be reduced to
one-dimension and the function <code><a href="stats.html#topic+optimize">optimize</a></code> is used instead
of <code>optim</code>. In this case initial values are irrelevant.
</p>
<p><b>Limits</b>
</p>
<p>Lower and upper limits for parameter values can be
individually specified using the function <code>link{pars.limits}</code>.
For example, including the following in the function call:<br />
<code>limits = pars.limits(phi=c(0, 10), lambda=c(-2.5, 2.5))</code>, <br />
will change the limits for the parameters <code class="reqn">\phi</code> and <code class="reqn">\lambda</code>.
Default values are used if the argument <code>limits</code> is not provided.  
</p>
<p>There are internal reparametrisation depending on the options for
parameters to be estimated.
For instance for the common situation when <code>fix.nugget=FALSE</code> the
minimisation is performed in a reduced
parameter space using
<code class="reqn">\tau^2_{rel} = \frac{\tau^2}{\sigma^2}</code>.
In this case values of <code class="reqn">\sigma^2</code> and <code class="reqn">\beta</code>
are then given by
analytical expressions which are function of the two parameters
remaining parameters and limits for these two parameters will be ignored.
</p>
<p>Since parameter values are found by numerical optimization using 
the function  <code><a href="stats.html#topic+optim">optim</a></code>, 
in given circunstances the algorithm may not converge to correct
parameter values when called with default options and the user may
need to pass extra options for the optimizer. For instance the
function <code>optim</code> takes a <code>control</code> argument.
The user should try different initial values and if the parameters have
different orders of magnitude may need to use options to scale the parameters.
Some possible workarounds in case of problems include:
</p>

<ul>
<li><p> rescale you data values (dividing by a constant, say)
</p>
</li>
<li><p> rescale your coordinates (subtracting values and/or dividing by constants)
</p>
</li>
<li><p> Use the  mechanism to pass <code>control()</code> options for the
optimiser internally
</p>
</li></ul>

<p><b>Transformation</b>  
If the <code>fix.lambda = FALSE</code> and <code>nospatial = FALSE</code> the
Box-Cox parameter for the model without the spatial component is
obtained numerically, with log-likelihood computed by the function
<code>boxcox.ns</code>.
</p>
<p><b>Multiple initial values</b> can be specified providing a <code class="reqn">n
    \times 2</code> matrix for the argument <code>ini.cov.pars</code> and/or
providing a vector for the values of the remaining model parameters.
In this case the log-likelihood is computed for all combinations of
the model parameters. The parameter set which maximises the
value of the log-likelihood is then used to start the
minimisation algorithm.
</p>
<p>Alternatively the argument <code>ini.cov.pars</code> can take an object of
the class <code>eyefit</code> or <code>variomodel</code>. This allows the usage 
of an output of the functions <code><a href="#topic+eyefit">eyefit</a></code>, <code><a href="#topic+variofit">variofit</a></code> or
<code><a href="#topic+likfit">likfit</a></code> be used as initial value.
</p>
<p>The argument <b>realisations</b> allows sets of data <em>assumed to be
independent</em> replications of the same process.
Data on different realisations may or may not be co-located.
For instance, data collected at different times
can be pooled together in the parameter estimation assuming
time independence.
The argument <code>realisations</code> takes a vector indicating the
replication number (e.g. the times).
If <code>realisations = TRUE</code> the code looks for an element
named <code>realisations</code> in the <code>geodata</code> object.
The log-likelihoods are computed for each replication and added together.
</p>


<h3>Value</h3>

<p>An object of the classes <code>"likGRF"</code> and <code>"variomodel"</code>.<br />
The function <code><a href="#topic+summary.likGRF">summary.likGRF</a></code> is used to print a summary
of the fitted model.<br /> 
The object is a list with the following components:
</p>
<table>
<tr><td><code>cov.model</code></td>
<td>
<p>a string with the name of the correlation
function.  </p>
</td></tr>
<tr><td><code>nugget</code></td>
<td>
<p>value of the nugget parameter <code class="reqn">\tau^2</code>.
This is an estimate if <code>fix.nugget = FALSE</code> otherwise, a fixed
value.  </p>
</td></tr>
<tr><td><code>cov.pars</code></td>
<td>
<p>a vector with the estimates of the parameters
<code class="reqn">\sigma^2</code> 
and <code class="reqn">\phi</code>, respectively.  </p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>value of the smoothness parameter. Valid only if 
the correlation function is one of: <code>"matern"</code>,
<code>"powered.exponential"</code>, <code>"cauchy"</code>
or <code>"gneiting.matern"</code>.  </p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>estimate of mean parameter <code class="reqn">\beta</code>.
This can be a scalar or vector depending on the
trend (covariates) specified in the model.  </p>
</td></tr>
<tr><td><code>beta.var</code></td>
<td>
<p>estimated variance (or covariance matrix) for the mean
parameter <code class="reqn">\beta</code>.  </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>values of the Box-Cox transformation parameter. A fixed value if
<code>fix.lambda = TRUE</code> otherwise the estimate value.  </p>
</td></tr>
<tr><td><code>aniso.pars</code></td>
<td>
<p>fixed values or estimates of the anisotropy
parameters, according to the function call.  </p>
</td></tr>
<tr><td><code>method.lik</code></td>
<td>
<p>estimation method used, <code>"ML"</code> (maximum likelihood)
or <code>"REML"</code> (restricted maximum likelihood).  </p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the value of the maximized likelihood.  </p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>number of estimated parameters.  </p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>value of the Akaike Information Criteria, <code class="reqn">AIC=-2
      ln(L) + 2 p</code> where <code class="reqn">L</code> is the maximised likelihood and p is
the number of parameters in the model.  </p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>value of the Bayesian Information Criteria,
<code class="reqn">BIC=-2ln(L) + p log(n)</code>, where <code class="reqn">n</code> is the number of data,
<code class="reqn">L,p</code> as for AIC above.  </p>
</td></tr>
<tr><td><code>parameters.summary</code></td>
<td>
<p>a data-frame with all model parameters,
their status (estimated or fixed) and values.  </p>
</td></tr>
<tr><td><code>info.minimisation</code></td>
<td>
<p>results returned by the minimisation function.</p>
</td></tr>
<tr><td><code>max.dist</code></td>
<td>
<p>maximum distance between 2 data points. This
information relevant for other functions which use outputs from
<code>likfit</code>.  </p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>the trend (covariates) matrix <code class="reqn">X</code>.  </p>
</td></tr>
<tr><td><code>log.jacobian</code></td>
<td>
<p>numerical value of the logarithm of the Jacobian of
the transformation.  </p>
</td></tr>
<tr><td><code>nospatial</code></td>
<td>
<p>estimates for the model without the spatial
component. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package
<span class="pkg">geoR</span>
can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.likGRF">summary.likGRF</a></code> for summary of the results,
<code><a href="#topic+plot.variogram">plot.variogram</a></code>, <code><a href="#topic+lines.variogram">lines.variogram</a></code> and
<code><a href="#topic+lines.variomodel">lines.variomodel</a></code> for graphical output,
<code><a href="#topic+proflik">proflik</a></code> for computing profile likelihoods,
<code><a href="#topic+variofit">variofit</a></code> and for other estimation methods, 
and <code><a href="stats.html#topic+optim">optim</a></code> for the numerical minimisation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ml &lt;- likfit(s100, ini=c(0.5, 0.5), fix.nug = TRUE)
ml
summary(ml)
reml &lt;- likfit(s100, ini=c(0.5, 0.5), fix.nug = TRUE, lik.met = "REML")
summary(reml)
plot(variog(s100))
lines(ml)
lines(reml, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='likfitBGCCM'>Fits the bivariate Gaussian
common component geostatistical model</h2><span id='topic+likfitBGCCM'></span><span id='topic+.negloglikBGCCM'></span><span id='topic+loglikBGCCM'></span><span id='topic+.naiveLL.BGCCM'></span>

<h3>Description</h3>

<p>Computes maximum likelihood estimates of the 
bivariate Gaussian
common component geostatistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likfitBGCCM(geodata1, geodata2, ini.sigmasq, ini.phi,
            cov0.model="matern", cov1.model="matern", cov2.model="matern",
            kappa0=0.5, kappa1=0.5, kappa2=0.5,
            fc.min = c("optim", "nlminb"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likfitBGCCM_+3A_geodata1">geodata1</code></td>
<td>
<p>an object of the class <code>geodata</code> with the first variable. </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_geodata2">geodata2</code></td>
<td>
<p>an object of the class <code>geodata</code> with the second variable. </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_ini.sigmasq">ini.sigmasq</code></td>
<td>
<p>optional, a vector with initial values for the
variance parameters. If not provided default values are used.  </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_ini.phi">ini.phi</code></td>
<td>
<p>optional, a vector with initial values for the
correlation range parameters. If not provided default values are
used. </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_cov0.model">cov0.model</code>, <code id="likfitBGCCM_+3A_cov1.model">cov1.model</code>, <code id="likfitBGCCM_+3A_cov2.model">cov2.model</code></td>
<td>
<p>covariance model for each of
the processes. See <code><a href="#topic+cov.spatial">cov.spatial</a></code> for details.  </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_kappa0">kappa0</code>, <code id="likfitBGCCM_+3A_kappa1">kappa1</code>, <code id="likfitBGCCM_+3A_kappa2">kappa2</code></td>
<td>
<p>extra parameter for some covariance
models.  </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_fc.min">fc.min</code></td>
<td>
<p>a string indication which function
should be used to minimise the negative of the log-likelihood. </p>
</td></tr>
<tr><td><code id="likfitBGCCM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>
or <code><a href="stats.html#topic+nlminb">nlminb</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with model fitting information to which
the class <code>BGCCM</code> is assigned.
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>a 2 elements vector with mean estimates.</p>
</td></tr>
<tr><td><code>sigmasq</code></td>
<td>
<p>a 4 elements vector with variance estimates.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a 3 elements vector with estimated correlation
parameters values.  </p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>a scalar. Maximised value of the log-likelihood.  </p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>results returned by <code><a href="stats.html#topic+optim">optim</a></code> or
<code><a href="stats.html#topic+nlminb">nlminb</a></code>. </p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>and other information related to the model fitting. </p>
</td></tr>
</table>


<h3>Warning  </h3>

<p> This is a new function and still in draft format and pretty much untested.</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>,
<code><a href="#topic+varcovBGCCM">varcovBGCCM</a></code>,
<code><a href="#topic+as.geodata">as.geodata</a></code>, <code><a href="#topic+likfit">likfit</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'># see http://www.leg.ufpr.br/geoR/tutorials/CCM.R
</code></pre>

<hr>
<h2 id='lines.variogram'>Line with a Empirical Variogram</h2><span id='topic+lines.variogram'></span>

<h3>Description</h3>

<p>A sample (empirical) variogram computed using the
function <code><a href="#topic+variog">variog</a></code> is added to the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogram'
lines(x, max.dist, type = "o",  scaled = FALSE,
         pts.range.cex, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"variogram"</code>, typically an
output from the function <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr>
<tr><td><code id="lines.variogram_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance for the x-axis. By default takes
the maximum distance for which the sample variogram was computed.  </p>
</td></tr>
<tr><td><code id="lines.variogram_+3A_type">type</code></td>
<td>
<p>type of line for the empirical variogram. The default is
<code>"o"</code> (dots and lines). See documentation for
<code><a href="graphics.html#topic+lines">lines</a></code> for further details.  </p>
</td></tr>
<tr><td><code id="lines.variogram_+3A_scaled">scaled</code></td>
<td>
<p>logical. If <code>TRUE</code> the variogram values are divided by the
sample variance. This allows comparison between variograms of
different variables.  </p>
</td></tr>
<tr><td><code id="lines.variogram_+3A_pts.range.cex">pts.range.cex</code></td>
<td>
<p>optional. A two elements vector with maximum and
minimum values for the caracter expansion factor <code>cex</code>. If
provided the point sizes in binned variogram are proportional to the
number of pairs of points used to compute each bin.  </p>
</td></tr> 
<tr><td><code id="lines.variogram_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="graphics.html#topic+lines">lines</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line with the empirical variogram is added to the plot in the current
graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog">variog</a></code>, <code><a href="#topic+lines.variogram">lines.variogram</a></code>,
<code><a href="#topic+lines.variomodel">lines.variomodel</a></code>, <code><a href="#topic+variog.model.env">variog.model.env</a></code>,
<code><a href="#topic+variog.mc.env">variog.mc.env</a></code>, <code><a href="#topic+plot.grf">plot.grf</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>.</p>

<hr>
<h2 id='lines.variogram.envelope'>Adds Envelopes Lines to a Variogram Plot</h2><span id='topic+lines.variogram.envelope'></span>

<h3>Description</h3>

<p>Variogram envelopes computed by <code><a href="#topic+variog.model.env">variog.model.env</a></code> or
<code><a href="#topic+variog.mc.env">variog.mc.env</a></code> are added to the current variogram plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogram.envelope'
lines(x, lty = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variogram.envelope_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"variogram.envelope"</code>,
typically an output of the functions <code><a href="#topic+variog.model.env">variog.model.env</a></code> or
<code><a href="#topic+variog.mc.env">variog.mc.env</a></code>.  </p>
</td></tr> 
<tr><td><code id="lines.variogram.envelope_+3A_lty">lty</code></td>
<td>
<p>line type. Defaults to 3.  </p>
</td></tr>
<tr><td><code id="lines.variogram.envelope_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function <code><a href="graphics.html#topic+lines">lines</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines defining the variogram envelope
are added to the plotin the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog">variog</a></code> for variogram computation,
<code><a href="#topic+variog.model.env">variog.model.env</a></code> and <code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for
computation of variogram envelopes, and <code><a href="graphics.html#topic+lines">lines</a></code> for the
generic function.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>s100.vario &lt;- variog(s100, max.dist = 1)
s100.ml &lt;- likfit(s100, ini=c(.5, .5))
s100.mod.env &lt;- variog.model.env(s100, obj.variog = s100.vario,
   model = s100.ml) 
s100.mc.env &lt;- variog.mc.env(s100, obj.variog = s100.vario)
plot(s100.vario)
lines(s100.mod.env)
lines(s100.mc.env, lwd=2)

</code></pre>

<hr>
<h2 id='lines.variomodel'>Adds a Line with a Variogram Model to a Variogram Plot</h2><span id='topic+lines.variomodel'></span><span id='topic+lines.variomodel.default'></span>

<h3>Description</h3>

<p>This function adds a line with a variogram model specifyed by the user
to a current variogram plot.
The variogram is specifyed either by passing a list with values for the variogram
elements or using each argument in the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variomodel'
lines(x, ...)
## Default S3 method:
lines.variomodel(x, cov.model, cov.pars, nugget, kappa,
                          max.dist, scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variomodel_+3A_x">x</code></td>
<td>
<p>a list with the values for the following components: <code>cov.model</code>, <code>cov.pars</code>,
<code>nugget</code>, <code>kappa</code> , <code>max.dist</code>; or a numeric vector
with values for x-axis values for the variogram (distances).
This argument is not required if the other arguments in the function
are provided, otherwise is compulsory.
If a list is provided the arguments which match the list elements
are ignored.
</p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_cov.model">cov.model</code></td>
<td>
<p>a string with the type of the variogram function. See
documentation of <code><a href="#topic+cov.spatial">cov.spatial</a></code> for further details.
</p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector or matrix with the values for the partial sill
(<code class="reqn">\sigma^2</code>) and range (<code class="reqn">\phi</code>) parameters. </p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_nugget">nugget</code></td>
<td>
<p>a scalar with the value of the nugget
(<code class="reqn">\tau^2</code>) parameter.
</p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_kappa">kappa</code></td>
<td>
<p>a scalar with the value of the smoothness
(<code class="reqn">\kappa</code>) parameters. Only required if <code>cov.model</code>
is one of the following: <code>"matern"</code>, <code>"powered.exponential"</code>,
<code>"cauchy"</code> and <code>"gneiting.matern"</code>
</p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance (x-axis) to compute and draw the line
representing the  variogram model.
If a list is provided in <code>x</code> the default is the distance given by
<code>x$max.dist</code>. If a vector is provided in <code>x</code> it takes <code>max(x)</code>.
</p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_scaled">scaled</code></td>
<td>
<p>logical. If <code>TRUE</code> the total sill in the plot is
equals to <code class="reqn">1</code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function
<code><a href="graphics.html#topic+curve">curve</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds a line with a variogram model  to a plot.
In conjuction with <code><a href="#topic+plot.variogram">plot.variogram</a></code> can be
used for instance to compare sample variograms against fitted models returned by
<code><a href="#topic+variofit">variofit</a></code>  and/or <code><a href="#topic+likfit">likfit</a></code>.
</p>


<h3>Value</h3>

<p>A line with a variogram model is added to a plot on the current
graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel.krige.bayes">lines.variomodel.krige.bayes</a></code>,
<code><a href="#topic+lines.variomodel.grf">lines.variomodel.grf</a></code>,
<code><a href="#topic+lines.variomodel.variofit">lines.variomodel.variofit</a></code>,
<code><a href="#topic+lines.variomodel.likGRF">lines.variomodel.likGRF</a></code>,
<code><a href="#topic+plot.variogram">plot.variogram</a></code>, <code><a href="#topic+lines.variogram">lines.variogram</a></code>,
<code><a href="#topic+variofit">variofit</a></code>, <code><a href="#topic+likfit">likfit</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># computing and ploting empirical variogram
vario &lt;- variog(s100, max.dist = 1)
plot(vario)
# estimating parameters by weighted least squares
vario.wls &lt;- variofit(vario, ini = c(1, .3), fix.nugget = TRUE)
# adding fitted model to the plot  
lines(vario.wls)
#
# Ploting different variogram models
plot(0:1, 0:1, type="n")
lines.variomodel(cov.model = "exp", cov.pars = c(.7, .25), nug = 0.3, max.dist = 1) 
# an alternative way to do this is:
my.model &lt;- list(cov.model = "exp", cov.pars = c(.7, .25), nugget = 0.3,
max.dist = 1) 
lines.variomodel(my.model, lwd = 2)
# now adding another model
lines.variomodel(cov.m = "mat", cov.p = c(.7, .25), nug = 0.3,
                 max.dist = 1, kappa = 1, lty = 2)
# adding the so-called "nested" models
# two exponential structures
lines.variomodel(seq(0,1,l=101), cov.model="exp",
                 cov.pars=rbind(c(0.6,0.15),c(0.4,0.25)), nug=0, col=2)
## exponential and spherical structures
lines.variomodel(seq(0,1,l=101), cov.model=c("exp", "sph"),
                 cov.pars=rbind(c(0.6,0.15), c(0.4,0.75)), nug=0, col=3)
</code></pre>

<hr>
<h2 id='lines.variomodel.grf'>Lines with True Variogram for Simulated Data</h2><span id='topic+lines.variomodel.grf'></span>

<h3>Description</h3>

<p>This functions adds to the graphics device a line with the theoretical
(true) variogram used when generating simulations with
the function <code><a href="#topic+grf">grf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grf'
lines.variomodel(x, max.dist, n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variomodel.grf_+3A_x">x</code></td>
<td>
<p>an object from the class <code>grf</code> typically an output of
the function <code><a href="#topic+grf">grf</a></code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.grf_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance to compute and plot the true
variogram. Defaults to the maximum distance between two data locations.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.grf_+3A_n">n</code></td>
<td>
<p>number of points used to compute and draw the variogram line.</p>
</td></tr>
<tr><td><code id="lines.variomodel.grf_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="graphics.html#topic+curve">curve</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line with the true variogram model is added to the current
plot on the graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel">lines.variomodel</a></code>,
<code><a href="#topic+grf">grf</a></code>, <code><a href="#topic+plot.grf">plot.grf</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- grf(100, cov.pars=c(1, .25)) # simulates data
plot(variog(sim, max.dist=1))       # plot empirical variogram
</code></pre>

<hr>
<h2 id='lines.variomodel.krige.bayes'>Adds a Bayesian Estimate of the Variogram to a Plot</h2><span id='topic+lines.variomodel.krige.bayes'></span>

<h3>Description</h3>

<p>Adds a Bayesian estimate of the variogram model to a plot typically with an empirical variogram.
The estimate is a chosen summary (mean, mode or mean) of the
posterior distribution returned by the function <code><a href="#topic+krige.bayes">krige.bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'krige.bayes'
lines.variomodel(x, summary.posterior, max.dist, uvec,
                 posterior = c("variogram", "parameters"),  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_x">x</code></td>
<td>
<p>an object of the class <code>krige.bayes</code>, typically an output
of the function <code><a href="#topic+krige.bayes">krige.bayes</a></code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_summary.posterior">summary.posterior</code></td>
<td>
<p>specify which summary of the posterior
distribution should be used as the parameter estimate.
Options are <code>"mean"</code>, <code>"median"</code> or
<code>"mode"</code>. See <code>DETAILS</code> below. </p>
</td></tr>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_max.dist">max.dist</code></td>
<td>
<p>numerical, the maximum distance for the x-axis.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_uvec">uvec</code></td>
<td>
<p>a numerical vector with support points to compute the
variogram values. Only used if <code>posterior = "variogram"</code>.
Defaults to <code>seq(0, max.dist, length = 51)</code>.
</p>
</td></tr>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_posterior">posterior</code></td>
<td>
<p>indicates whether the the variogram line is
based on the posterior of the variogram function (default)
or the posterior of the model parameters.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.krige.bayes_+3A_...">...</code></td>
<td>
<p>arguments passed to the functions <code><a href="graphics.html#topic+lines">lines</a></code> or <code><a href="graphics.html#topic+curve">curve</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+krige.bayes">krige.bayes</a></code> returns samples from the
posterior distribution of the parameters <code class="reqn">(\sigma^2, \phi,
    \tau^{2}_{rel})</code>.
</p>
<p>This function allows for two basic options to draw a line with a
summary of the variogram function.
</p>

<dl>
<dt>&quot;variogram&quot;: </dt><dd><p>for each sample of the parameters the variogram
function is computed at the support points defined in the
argument <code>uvec</code>. Then a function provided by the user in the
argument <code>summary.posterior</code> is used to compute a summary of
the values obtained at each support point.  
</p>
</dd>
<dt>&quot;parameters&quot;: </dt><dd><p>in this case summaries of the posterior
distribution of the model parameters as &ldquo;plugged-in&rdquo; in the
variogram function.
One of the options <code>"mode"</code> (default) ,<code>"median"</code> or <code>"mean"</code>
can be provided in the argument <code>summary.posterior</code>.
The option <code>mode</code>, uses the mode of <code class="reqn">(\phi,
	\tau^{2}_{rel})</code> and the mode of
of <code class="reqn">\sigma^2</code> conditional on the modes of the former parameters.
For the options <code>mean</code> and <code>median</code> these summaries are
computed from the samples of the posterior.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A line with the estimated variogram plot is added to the plot in the
current graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel">lines.variomodel</a></code>, <code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="graphics.html#topic+lines">lines</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See examples in the documentation of the function krige.bayes().
</code></pre>

<hr>
<h2 id='lines.variomodel.likGRF'>Adds a Variogram Line to a Variogram Plot</h2><span id='topic+lines.variomodel.likGRF'></span>

<h3>Description</h3>

<p>This function adds a fitted variogram based on the estimates of the
model parameters returned by the function <code><a href="#topic+likfit">likfit</a></code>
to a current variogram plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'likGRF'
lines.variomodel(x, max.dist, scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variomodel.likGRF_+3A_x">x</code></td>
<td>
<p>an object of the class <code>likGRF</code>
which is a list containing
information about the fitted model parameters, typically an output
of the function <code><a href="#topic+likfit">likfit</a></code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.likGRF_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance (x-axis) to compute and draw the line
representing the  variogram model.
The default is the distance given by <code>obj$max.dist</code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.likGRF_+3A_scaled">scaled</code></td>
<td>
<p>logical. If <code>TRUE</code> the total sill in the plot is
equals to <code class="reqn">1</code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.likGRF_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function
<code><a href="graphics.html#topic+curve">curve</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds variogram model(s)  to a plot.
In conjuction with <code><a href="#topic+plot.variogram">plot.variogram</a></code> can be
used to compare sample variograms against fitted models returned by
<code><a href="#topic+likfit">likfit</a></code>.
</p>


<h3>Value</h3>

<p>A line with a variogram model is added to a plot on the current
graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel">lines.variomodel</a></code>,
<code><a href="#topic+lines.variomodel.variofit">lines.variomodel.variofit</a></code>,
<code><a href="#topic+plot.variogram">plot.variogram</a></code>, <code><a href="#topic+lines.variogram">lines.variogram</a></code>,
<code><a href="#topic+variofit">variofit</a></code>, <code><a href="#topic+likfit">likfit</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute and plot empirical variogram
vario &lt;- variog(s100, max.dist = 1)
plot(vario)
# estimate parameters
vario.ml &lt;- likfit(s100, ini = c(1, .3), fix.nugget = TRUE)
# adds fitted model to the plot  
lines(vario.ml)
</code></pre>

<hr>
<h2 id='lines.variomodel.variofit'>Adds a Line with a Fitted Variogram Model to a Variogram Plot</h2><span id='topic+lines.variomodel.variofit'></span>

<h3>Description</h3>

<p>This function adds a line with the variogram model
fitted by the function
<code><a href="#topic+variofit">variofit</a></code> to a current variogram plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variofit'
lines.variomodel(x, max.dist, scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.variomodel.variofit_+3A_x">x</code></td>
<td>
<p>an object of the class <code>variofit</code>
which is a list containing information about
the fitted model parameters, typically an output of the function
<code><a href="#topic+variofit">variofit</a></code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.variofit_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance (x-axis) to compute and draw the line
representing the variogram model.
The default is the distance given by <code>x$max.dist</code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.variofit_+3A_scaled">scaled</code></td>
<td>
<p>logical. If <code>TRUE</code> the total sill in the plot is
set to <code class="reqn">1</code>.  </p>
</td></tr>
<tr><td><code id="lines.variomodel.variofit_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function
<code><a href="graphics.html#topic+curve">curve</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds fitted variogram model to a plot.
In conjuction with <code><a href="#topic+plot.variogram">plot.variogram</a></code> can be
used to compare empirical variograms against fitted models returned by
<code><a href="#topic+variofit">variofit</a></code>.
</p>


<h3>Value</h3>

<p>A line with a variogram model is added to a plot on the current
graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.variomodel">lines.variomodel</a></code>,
<code><a href="#topic+lines.variomodel.likGRF">lines.variomodel.likGRF</a></code>,
<code><a href="#topic+plot.variogram">plot.variogram</a></code>, <code><a href="#topic+lines.variogram">lines.variogram</a></code>,
<code><a href="#topic+variofit">variofit</a></code>, <code><a href="#topic+likfit">likfit</a></code>, <code><a href="graphics.html#topic+curve">curve</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute and plot empirical variogram
vario &lt;- variog(s100, max.dist = 1)
plot(vario)
# estimate parameters
vario.wls &lt;- variofit(vario, ini = c(1, .3), fix.nugget = TRUE)
# adds fitted model to the plot  
lines(vario.wls)
</code></pre>

<hr>
<h2 id='locations.inside'>Select prediction locations inside borders</h2><span id='topic+locations.inside'></span>

<h3>Description</h3>

<p>Selects the prediction locations located inside a polygon defining
borders of a region where prediction is aimed.
Typically internally called by <span class="pkg">geoR</span> functions
<code><a href="#topic+krige.bayes">krige.bayes</a></code>, <code><a href="#topic+krige.conv">krige.conv</a></code>,
<code><a href="#topic+ksline">ksline</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locations.inside(locations, borders, as.is = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locations.inside_+3A_locations">locations</code></td>
<td>
<p>a two columns matrix or dqata frame with coordinates
of the prediction locations.  </p>
</td></tr>
<tr><td><code id="locations.inside_+3A_borders">borders</code></td>
<td>
<p>a two column matrix or data-frame with coordinates of a
polygon defining the borders of the region.  </p>
</td></tr>
<tr><td><code id="locations.inside_+3A_as.is">as.is</code></td>
<td>
<p>logical defining if the returned object of of the same
type (list, data-frame or matrix) as the provided in
<code>locations</code>. If <code>FALSE</code> the function returns a matrix.  </p>
</td></tr>
<tr><td><code id="locations.inside_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the internal function
<code>.geoR_pip</code> and currently not used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two columns matrix, data-frame or a list with 2 elements with coordinates of points inside the borders.  
</p>


<h3>See Also</h3>

<p><code><a href="sp.html#topic+over">over</a></code>,<code><a href="sp.html#topic+coordinates">coordinates</a></code>,
<code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- pred_grid(parana$borders, by=20)
plot(gr, asp=1, pch="+")
polygon(parana$borders)
gr.in &lt;- locations.inside(gr, parana$borders)
points(gr.in, col=2, pch="+")
</code></pre>

<hr>
<h2 id='loglik.GRF'>Log-Likelihood for a Gaussian Random Field</h2><span id='topic+loglik.GRF'></span>

<h3>Description</h3>

<p>This function computes the value of the log-likelihood for a
Gaussian random field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.GRF(geodata, coords = geodata$coords, data = geodata$data,
           obj.model = NULL, cov.model = "exp", cov.pars, nugget = 0,
           kappa = 0.5, lambda = 1, psiR = 1, psiA = 0,
           trend = "cte", method.lik = "ML", compute.dists = TRUE,
           realisations = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik.GRF_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. 
Typically an object of the class <code>"geodata"</code> - a <span class="pkg">geoR</span>
data-set.
If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix, each row containing Euclidean
coordinates of the <em>n</em> data locations. By default it takes the
element <code>coords</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_data">data</code></td>
<td>
<p>a vector with data values. By default it takes the
element <code>data</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_obj.model">obj.model</code></td>
<td>
<p>a object of the class <code>variomodel</code> with a fitted
model. Tipically an output of 
<code><a href="#topic+likfit">likfit</a></code> or <code><a href="#topic+variofit">variofit</a></code>. </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_cov.model">cov.model</code></td>
<td>
<p>a string specifying the model for the correlation
function. For further details see 
documentation for <code><a href="#topic+cov.spatial">cov.spatial</a></code>. </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector with 2 elements with values of  the covariance parameters
<code class="reqn">\sigma^2</code> (partial sill) and <code class="reqn">\phi</code> (range
parameter).  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_nugget">nugget</code></td>
<td>
<p>value of the nugget parameter. Defaults to <code class="reqn">0</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_kappa">kappa</code></td>
<td>
<p>value of the smoothness parameter. Defaults to
<code class="reqn">0.5</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox tranformation parameter. Defaults
to <code class="reqn">1</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_psir">psiR</code></td>
<td>
<p>value of the anisotropy ratio parameter. Defaults to
<code class="reqn">1</code>, corresponding to isotropy.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_psia">psiA</code></td>
<td>
<p>value (in radians) of the anisotropy rotation parameter. Defaults to zero.</p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model.
The options are:
<code>"cte"</code> (constant mean),
<code>"1st"</code> (a first order polynomial
on the coordinates), <code>"2nd"</code> (a second order polynomial
on the coordinates), or a formula of the type <code>~X</code> where <code>X</code>
is a matrix with the covariates (external trend). Defaults to <code>"cte"</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_method.lik">method.lik</code></td>
<td>
<p>options are <code>"ML"</code> for likelihood and <code>"REML"</code> for
restricted likelihood. Defaults to <code>"ML"</code>.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_compute.dists">compute.dists</code></td>
<td>
<p>for internal use with other function. Don't
change the default unless you know what you are doing.  </p>
</td></tr>
<tr><td><code id="loglik.GRF_+3A_realisations">realisations</code></td>
<td>
<p>optional. A vector indicating replication number
for each data. For more details see <code><a href="#topic+as.geodata">as.geodata</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression log-likelihood is:
</p>
<p style="text-align: center;"><code class="reqn">l(\theta) = -\frac{n}{2} \log (2\pi) - \frac{1}{2} \log |\Sigma|
    - \frac{1}{2} (y -
  F\beta)' \Sigma^{-1} (y - F\beta),</code>
</p>

<p>where <code class="reqn">n</code> is the size of the data vector <code class="reqn">y</code>, <code class="reqn">\beta</code>
is the mean (vector) parameter with dimention <code class="reqn">p</code>, <code class="reqn">\Sigma</code> is the covariance
matrix and <code class="reqn">F</code> is the matrix with the values of the covariates (a
vector of <code class="reqn">1</code>'s if the mean is constant.
</p>
<p>The expression restricted log-likelihood is:
</p>
<p style="text-align: center;"><code class="reqn">rl(\theta) =  -\frac{n-p}{2} \log (2\pi) + \frac{1}{2} \log |F' F|
    - \frac{1}{2} \log |\Sigma| - \frac{1}{2} \log |F' \Sigma F| - \frac{1}{2} (y -
  F\beta)' \Sigma^{-1} (y - F\beta).</code>
</p>



<h3>Value</h3>

<p>The numerical value of the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>,  <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likfit">likfit</a></code> for likelihood-based parameter estimation.</p>


<h3>Examples</h3>

<pre><code class='language-R'>loglik.GRF(s100, cov.pars=c(0.8, .25), nugget=0.2)
loglik.GRF(s100, cov.pars=c(0.8, .25), nugget=0.2, met="RML")

## Computing the likelihood of a model fitted by ML
s100.ml &lt;- likfit(s100, ini=c(1, .5))
s100.ml
s100.ml$loglik
loglik.GRF(s100, obj=s100.ml)

## Computing the likelihood of a variogram fitted model
s100.v &lt;- variog(s100, max.dist=1)
s100.vf &lt;- variofit(s100.v, ini=c(1, .5))
s100.vf
loglik.GRF(s100, obj=s100.vf)
</code></pre>

<hr>
<h2 id='matern'>Computer Values of the Matern Correlation Function</h2><span id='topic+matern'></span>

<h3>Description</h3>

<p>This function computes values of the <code class="reqn">\mbox{Mat\'{e}rn}</code>
correlation function
for given distances and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern(u, phi, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_+3A_u">u</code></td>
<td>
<p>a vector, matrix or array with values of the distances
between pairs of data locations.  </p>
</td></tr>
<tr><td><code id="matern_+3A_phi">phi</code></td>
<td>
<p>value of the range parameter <code class="reqn">\phi</code>.  </p>
</td></tr>
<tr><td><code id="matern_+3A_kappa">kappa</code></td>
<td>
<p>value of the smoothness parameter <code class="reqn">\kappa</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\mbox{Mat\'{e}rn}</code> model is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\rho(u;\phi,\kappa) =\{2^{\kappa-1}
    \Gamma(\kappa)\}^{-1} (u/\phi)^\kappa
    K_\kappa(u/\phi)</code>
</p>

<p>where <code class="reqn">\phi</code>  and <code class="reqn">\kappa</code> are parameters and 
<code class="reqn">K_\kappa(\cdot)</code> denotes the modified Bessel function of the third
kind of order <code class="reqn">\kappa</code>.
The family is valid for <code class="reqn">\phi&gt;0</code> and <code class="reqn">\kappa&gt;0</code>.
</p>


<h3>Value</h3>

<p>A vector matrix or array, according to the argument <code>u</code>, with the
values of the <code class="reqn">\mbox{Mat\'{e}rn}</code>
correlation function for the given distances.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.spatial">cov.spatial</a></code> for the correlation functions
implemented in <span class="pkg">geoR</span>, and <code><a href="base.html#topic+besselK">besselK</a></code> for computation
of the Bessel functions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Models with fixed range and varying smoothness parameter
#
curve(matern(x, phi= 0.25, kappa = 0.5),from = 0, to = 1.5,
      xlab = "distance", ylab = expression(rho(h)), lty = 2,
      main=expression(paste("varying  ", kappa, "  and fixed  ", phi)))
curve(matern(x, phi= 0.25, kappa = 1),from = 0, to = 1.5, add = TRUE)
curve(matern(x, phi= 0.25, kappa = 2),from = 0, to = 1.5, add = TRUE,
      lwd = 2, lty=2)
curve(matern(x, phi= 0.25, kappa = 3),from = 0, to = 1.5, add = TRUE,
      lwd = 2)
legend("topright", expression(kappa==0.5, kappa==1.5, kappa==2, kappa==3),
    lty=c(2,1,2,1), lwd=c(1,1,2,2))

#
# Correlations with equivalent "practical range"
# and varying smoothness parameter
#
curve(matern(x, phi = 0.25, kappa = 0.5),from = 0, to = 1,
      xlab = "distance", ylab = expression(gamma(h)), lty = 2,
      main = "models with equivalent \"practical\" range")
curve(matern(x, phi = 0.188, kappa = 1),from = 0, to = 1, add = TRUE)      
curve(matern(x, phi = 0.14, kappa = 2),from = 0, to = 1,
      add = TRUE, lwd=2, lty=2)      
curve(matern(x, phi = 0.117, kappa = 2), from = 0, to = 1,
      add = TRUE, lwd=2)      
legend("topright", expression(list(kappa == 0.5, phi == 0.250),
       list(kappa == 1, phi == 0.188), list(kappa == 2, phi == 0.140),
       list(kappa == 3, phi == 0.117)), lty=c(2,1,2,1), lwd=c(1,1,2,2))
</code></pre>

<hr>
<h2 id='names.geodata'>Lists names of the key elements of a geodata object</h2><span id='topic+names.geodata'></span>

<h3>Description</h3>

<p>Produces a list with the names of the main elements of
<code>geodata</code> object: coords, data, units.m, covariate and
realisation.
Can be useful to list names before using <code>{subset.geodata}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.geodata_+3A_x">x</code></td>
<td>
<p>an object of the class <code>geodata</code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>coords</code></td>
<td>
<p>names of the coordinates in the geodata object. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>name(s) of the data elements in the geodata object.  </p>
</td></tr>
<tr><td><code>units.m</code></td>
<td>
<p>returns the string <code>units.m</code>. </p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>return the covariate(s) name(s) if present
in the <code>geodata object</code></p>
</td></tr>
<tr><td><code>realisations</code></td>
<td>
<p>returns the string <code>units.m</code>  if present
in the <code>geodata object</code>. </p>
</td></tr>
<tr><td><code>other</code></td>
<td>
<p>other elements in the <code>geodata</code>  object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+names">names</a></code>, <code><a href="#topic+subset.geodata">subset.geodata</a></code>, <code><a href="#topic+as.geodata">as.geodata</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>names(ca20)
</code></pre>

<hr>
<h2 id='nearloc'>Near location to a point</h2><span id='topic+nearloc'></span>

<h3>Description</h3>

<p>For a given set of points and locations identified by 2D coordinates this
function finds the nearest location of each point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearloc(points, locations, positions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearloc_+3A_points">points</code></td>
<td>
<p>a matrix, data-frame or list with the 2D coordinates of
a set of points for which you want to find the nearest location.  </p>
</td></tr>
<tr><td><code id="nearloc_+3A_locations">locations</code></td>
<td>
<p>a matrix, data-frame or list with the 2D coordinates of
a set of locations.  </p>
</td></tr>
<tr><td><code id="nearloc_+3A_positions">positions</code></td>
<td>
<p>logical defining what to be returned. If <code>TRUE</code>
the function returns the positions of the locations, otherwise the
coordinates of the locations. Defaults to <code>FALSE</code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>positions = FALSE</code> the function returns 
a matrix, data-frame or list of the same type and size
as the object provided in the argument <code>points</code> with the
coordinates of the nearest locations.
</p>
<p>If <code>positions = FALSE</code> the function returns a vector with the
position of the nearest points in the <code>locations</code> object.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loccoords">loccoords</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(276)
gr &lt;- expand.grid(seq(0,1, l=11), seq(0,1, l=11))
plot(gr, asp=1)
pts &lt;- matrix(runif(10), nc=2)
points(pts, pch=19)
near &lt;- nearloc(points=pts, locations=gr)
points(near, pch=19, col=2)
rownames(near)
nearloc(points=pts, locations=gr, pos=TRUE)
</code></pre>

<hr>
<h2 id='output.control'> Defines output options for prediction functions </h2><span id='topic+output.control'></span>

<h3>Description</h3>

<p>Auxiliary function defining output options for
<code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="#topic+krige.conv">krige.conv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.control(n.posterior, n.predictive, moments, n.back.moments,
               simulations.predictive, mean.var, quantile,
               threshold, sim.means, sim.vars, signal, messages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.control_+3A_n.posterior">n.posterior</code></td>
<td>
<p>number of samples to be taken from the posterior
distribution. Defaults to 1000. </p>
</td></tr>
<tr><td><code id="output.control_+3A_n.predictive">n.predictive</code></td>
<td>
<p>number of samples to be taken from the
predictive distribution. Default equals to
<code>n.posterior</code>.  </p>
</td></tr>
<tr><td><code id="output.control_+3A_moments">moments</code></td>
<td>
<p>logical. Indicates whether the moments of the
predictive distribution are returned. If <code>lambda = 1</code>
there is no transformation/back-transformation.
If <code>lambda = 0</code> or <code>lambda = 0.5</code> the moments are
back-transformed by analytical expressions. For other cases the
back-transformation is done by simulation. Defaults to <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="output.control_+3A_n.back.moments">n.back.moments</code></td>
<td>
<p>number of sample to back-transform moments by
simulation. Defaults to 1000.  </p>
</td></tr>
<tr><td><code id="output.control_+3A_simulations.predictive">simulations.predictive</code></td>
<td>
<p>logical. Defines whether to draw simulations
from the predictive distribution.
Only considered if prediction
locations are provided in the argument <code>locations</code> of the main functions.
Defaults to <code>FALSE</code> but changed to
<code>TRUE</code> if an integer greater then zero is provided in the
argument <code>n.predictive</code> and/or simulations are required in
order to compute quantities required by other arguments such as
threshold, quantiles and some values of the transformation parameter.
</p>
</td></tr> 
<tr><td><code id="output.control_+3A_mean.var">mean.var</code></td>
<td>
<p>logical (optional). Indicates whether mean and
variances of the simulations of the predictive distributions are
computed and returned.   </p>
</td></tr> 
<tr><td><code id="output.control_+3A_quantile">quantile</code></td>
<td>
<p>a (optional) numeric vector.
If provided indicates whether quantiles of the
simulations from the
predictive distribution are computed and returned.
If a vector with numbers in the interval
<code class="reqn">[0,1]</code> is provided, the output includes the object
<code>quantiles</code>, which contains values of corresponding
estimated quantiles. For
example, if <code>quantile = c(0.25, 0.50, 0.75)</code> the function
returns the quartiles of the predictive distributions at each of the
prediction locations.
If <code>quantile = TRUE</code> default values <code>c(0.025, 0.5,
      0.975)</code> are assumed. 
A measure of uncertainty of the predictions, an alternative to the kriging
standard error, computed by <code class="reqn">(quantile_0.975 - quantile_0.025)/4</code>.
Only used if prediction locations are provided in the argument
<code>locations</code>.  </p>
</td></tr>
<tr><td><code id="output.control_+3A_threshold">threshold</code></td>
<td>
<p>Optional. A numerical vector.
If one or more values are provided, an object named
<code>probabilities</code> is included in the output.
This object contains, for each
prediction location, the probability that the variable is less
than or equal than the threshold provided by the user.
Defaults to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="output.control_+3A_sim.means">sim.means</code></td>
<td>
<p>logical (optional). Indicates whether mean
of each of the conditional simulations of the predictive
distribution should be computed and returned. Defaults to
<code>TRUE</code>, if simulations from the predictive are required.  </p>
</td></tr> 
<tr><td><code id="output.control_+3A_sim.vars">sim.vars</code></td>
<td>
<p>logical (optional). Indicates whether variance
of each of the conditional simulations of the predictive
distribution should be computed and returned. Defaults to <code>FALSE</code>.  </p>
</td></tr> 
<tr><td><code id="output.control_+3A_signal">signal</code></td>
<td>
<p>logical indicating whether the signal or the variable is
to be predicted. Different defaults are set internally by
functions calling <code>output.control</code>. See <code>DETAILS</code>
below.  </p>
</td></tr>
<tr><td><code id="output.control_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates
whether or not status messages are printed on the output device
while the function is running. Defaults to <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>SIGNAL</b>
</p>
<p>This function is typically called by the <span class="pkg">geoR</span>'s prediction functions
<code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="#topic+krige.conv">krige.conv</a></code>
defining the output.
</p>
<p>By default, <code><a href="#topic+krige.bayes">krige.bayes</a></code> sets <code>signal = TRUE</code>
and <code><a href="#topic+krige.conv">krige.conv</a></code> sets <code>signal = FALSE</code>.
</p>
<p>The underlying model
</p>
<p style="text-align: center;"><code class="reqn">Y(x) = \mu + S(x) + \epsilon</code>
</p>

<p>assumes that observations <code class="reqn">Y(x)</code> are noisy
versions of a <em>signal</em> <code class="reqn">S(x)</code> and
<code class="reqn">Var(\epsilon)=\tau^2</code> is the nugget variance.
</p>
<p>If <code class="reqn">\tau^2 = 0</code> the <code class="reqn">Y</code> and <code class="reqn">S</code> are
indistiguishable.<br />
</p>
<p>If <code class="reqn">\tau^2 &gt; 0</code> and regarded as measurement error, the
option <code>signal</code> defines whether the <code class="reqn">S</code> (<code>signal =
    TRUE</code>) or the variable <code class="reqn">Y</code> (<code>signal = FALSE</code>) is to be
predicted.<br />
For the latter the predictions will &quot;honor&quot; the data,
i.e. predicted values will coincide with the data, at data locations.<br />
For unsampled locations and untransformed data,
the predicted values equals data
regardless <code>signal = TRUE</code> or <code>FALSE</code>, however
predictions variances will differ.
</p>
<p>The function <code><a href="#topic+krige.conv">krige.conv</a></code> has an argument
<code>micro.scale</code>. If <code class="reqn">micro.scale &gt; 0</code> the error term is
divided as <code class="reqn">\epsilon = \epsilon_{ms} + \epsilon_{me}</code> and the nugget variance is divided into two terms: <em>micro-scale variance</em>
and <em>measurement error</em>.<br />
If <code>signal = TRUE</code> the term <code class="reqn">\epsilon_{ms}</code> is
regarded as part of the signal and consequently the <em>micro-scale variance</em> is added to
the prediction variance.<br />
If <code>signal = FALSE</code> the total error variance <code class="reqn">\tau^2</code>
is added to the prediction variance.
</p>


<h3>Value</h3>

<p>A list with processed arguments to be passed to the main function.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p>The prediction functions <code><a href="#topic+krige.bayes">krige.bayes</a></code> and  <code><a href="#topic+krige.conv">krige.conv</a></code>.</p>

<hr>
<h2 id='parana'>Rainfall Data from Parana State, Brasil</h2><span id='topic+parana'></span><span id='topic+maijun'></span>

<h3>Description</h3>

<p>This data-set was used by Diggle and Ribeiro (2001) to illustrate the methods
discussed in the paper. The data reported analysis was
carried out using the package <span class="pkg">geoR</span>. 
</p>
<p>The data refers to average rainfall over different years for the period May-June
(dry-season). It was collected at 143 recording stations throughout <code class="reqn">\mbox{Paran\'{a}}</code> State,
Brasil.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(parana)</code></pre>


<h3>Format</h3>

<p>The object <code>parana</code> of the class <code>geodata</code>, which is a list
containing the following components:
</p>
    
<dl>
<dt><code>coords</code></dt><dd><p>a matrix with the coordinates of the recording
stations.  </p>
</dd>
<dt><code>data</code></dt><dd><p>a vector with the average recorded rainfall for the May-June period.  </p>
</dd>
<dt><code>borders</code></dt><dd><p>a matrix with the coordinates defining the borders of
<code class="reqn">\mbox{Paran\'{a}}</code> state.  </p>
</dd>
<dt><code>loci.paper</code></dt><dd><p>a matrix with the coordinates of the four
prediction locations discussed in the paper. </p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were collected at several recording stations at
<code class="reqn">\mbox{Paran\'{a}}</code> State, Brasil, belonging to the following companies:
COPEL, IAPAR, DNAEE, SUREHMA  and INEMET.
</p>
<p>The data base was organized by Laura Regina Bernardes Kiihl (IAPAR,
Instituto <code class="reqn">\mbox{Agron\^{o}mico}</code> do <code class="reqn">\mbox{Paran\'{a}}</code>, Londrina, Brasil)
and the fraction of the data included in this data-set was
provided by Jacinta Loudovico Zamboti (Universidade Estadual de
Londrina, Brasil).
The coordinates of the borders of <code class="reqn">\mbox{Paran\'{a}}</code> State were provided
by <code class="reqn">\mbox{Jo\~{a}o}</code> Henrique Caviglione (IAPAR).
</p>


<h3>References</h3>

<p>Diggle, P.J. &amp; Ribeiro Jr, P.J. (2002) Bayesian inference in
Gaussian model-based geostatistics. Geographical and Environmental
Modelling, Vol. 6, No. 2, 129-146.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(parana)
plot(parana)
</code></pre>

<hr>
<h2 id='pars.limits'>Set limits for the parameter values</h2><span id='topic+pars.limits'></span>

<h3>Description</h3>

<p>The functions <code><a href="#topic+likfit">likfit</a></code> and <code><a href="#topic+variofit">variofit</a></code> in the
package <span class="pkg">geoR</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pars.limits(phi = c(lower = 0, upper = +Inf),
            sigmasq = c(lower = 0, upper = +Inf),
            nugget.rel = c(lower = 0, upper = +Inf),
            kappa = c(lower = 0, upper = +Inf),
            kappa2 = c(lower = 0, upper = +Inf), 
            lambda = c(lower = -3, upper = 3),
            psiR = c(lower = 1, upper = +Inf),
            psiA = c(lower = 0, upper = 2 * pi),
            tausq.rel = nugget.rel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pars.limits_+3A_phi">phi</code></td>
<td>
<p>a two elements vector with limits for the parameter phi. Defaults to [0, +Inf]</p>
</td></tr>
<tr><td><code id="pars.limits_+3A_sigmasq">sigmasq</code></td>
<td>
<p>idem for sigmasq. Defaults to [0, +Inf]</p>
</td></tr>
<tr><td><code id="pars.limits_+3A_nugget.rel">nugget.rel</code></td>
<td>
<p>idem for nugget.rel. Defaults to [0, +Inf]</p>
</td></tr>
<tr><td><code id="pars.limits_+3A_kappa">kappa</code>, <code id="pars.limits_+3A_kappa2">kappa2</code></td>
<td>
<p>idem. Defaults to [0, +Inf]</p>
</td></tr>
<tr><td><code id="pars.limits_+3A_lambda">lambda</code></td>
<td>
<p>idem for lambda. Defaults to [-3, +3]. Only used in
<code><a href="#topic+likfit">likfit</a></code>. </p>
</td></tr>
<tr><td><code id="pars.limits_+3A_psir">psiR</code></td>
<td>
<p>idem for psiR. Defaults to [1, +Inf]. Only used in
<code><a href="#topic+likfit">likfit</a></code>. </p>
</td></tr>
<tr><td><code id="pars.limits_+3A_psia">psiA</code></td>
<td>
<p>idem for psiA. Defaults to [0, 2 pi]. Only used in
<code><a href="#topic+likfit">likfit</a></code>. </p>
</td></tr>
<tr><td><code id="pars.limits_+3A_tausq.rel">tausq.rel</code></td>
<td>
<p>idem for tausq.rel. Defaults to [0, +Inf]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lower and upper limits for parameter values can be
individually specified.
For example, including the following in the function call in
<code>likfit</code> or <code>variofit</code>:<br />
<code>limits = pars.limits(phi=c(0, 10), lambda=c(-2.5, 2.5))</code>, <br />
will change the limits for the parameters <code class="reqn">\phi</code> and <code class="reqn">\lambda</code>.
Default values are used if the argument <code>limits</code> is not provided.  
</p>


<h3>Value</h3>

<p>A list of a 2 elements vector with limits for each parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likfit">likfit</a></code>, <code><a href="#topic+variofit">variofit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pars.limits(phi=c(0,10))
pars.limits(phi=c(0,10), sigmasq=c(0, 100))
</code></pre>

<hr>
<h2 id='plot.geodata'>Exploratory Geostatistical Plots</h2><span id='topic+plot.geodata'></span>

<h3>Description</h3>

<p>This function produces a <code class="reqn">2 \times 2</code> display
with the following plots: 
the first indicates the spatial locations assign different
colors to data
in different quartiles,
the next two shows data against the <em>X</em> and
<em>Y</em> coordinates and the last is an histogram of the data values or optionally,
a 3-D plot with spatial locations and associated data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
plot(x, coords=x$coords, data = x$data,
             borders, trend="cte", lambda = 1, col.data = 1,
             weights.divide = "units.m", lowess = FALSE, scatter3d = FALSE,
             density = TRUE, rug = TRUE, qt.col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.geodata_+3A_x">x</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_coords">coords</code></td>
<td>
<p> an <code class="reqn">n \times 2</code> matrix containing in each row Euclidean
coordinates of the <em>n</em> data locations. By default it takes the
element <code>coords</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_data">data</code></td>
<td>
<p>a vector with data values. By default it takes the
element <code>data</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_borders">borders</code></td>
<td>
<p>If an <code class="reqn">n \times 2</code> matrix or data-frame with
the borders of the area is provided, the borders are included in the
first plot. By default it searches for a element named &quot;borders&quot;
in  the geodata object.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model. The options are:
<code>"cte"</code> (constant mean - default option), <code>"1st"</code> (a first order polynomial
on the coordinates), <code>"2nd"</code> (a second order polynomial
on the coordinates), or a formula of the type <code>~X</code> where <code>X</code>
is a matrix with the covariates (external trend).
If provided the trend is &quot;removed&quot; using the function
<code><a href="stats.html#topic+lm">lm</a></code> and the residuals are plotted.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter. Two particular cases
are <code class="reqn">\lambda = 1</code> which corresponds to no
transformation and  <code class="reqn">\lambda = 0</code> corresponding to
the log-transformation.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_col.data">col.data</code></td>
<td>
<p>indicates the column number for the data
to be plotted. Only valid if more than one data-set is available
i.e., if the argument <code>data</code> is a matrix.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_weights.divide">weights.divide</code></td>
<td>
<p>if a vector of weights with the same length as
the data is provided each  data is
divided by the corresponding element in this vector.
Defaults divides the data by the element <code>units.m</code> in the
data object, if present, otherwise no action is taken and original
data is used.
The usage of <code>units.m</code> is common for data objects
to be analysed using the package <span class="pkg">geoRglm</span>.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_lowess">lowess</code></td>
<td>
<p>logical. Indicates whether the function
<code><a href="stats.html#topic+lowess">lowess</a></code> should be used in the plots of the data against
the coordinates.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_scatter3d">scatter3d</code></td>
<td>
<p>logical. If <code>TRUE</code> the last plot is
produced by
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> showing
a 3d plot with data locations and corresponding values.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_density">density</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) a line with density
estimation is added to the histogram.  </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_rug">rug</code></td>
<td>
<p>logical. If <code>TRUE</code> a rug plot is added to the
histogram. </p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_qt.col">qt.col</code></td>
<td>
<p>colors for the quartiles in the first plot. If missing
defaults to blue, green, yellow and red.</p>
</td></tr>
<tr><td><code id="plot.geodata_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="graphics.html#topic+hist">hist</a></code> or
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced on the graphics device. No values are returned. 
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+points.geodata">points.geodata</a></code>,
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>, <code><a href="stats.html#topic+lowess">lowess</a></code>, 
<code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+rug">rug</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>require(geoR)
plot(s100)
plot(s100, scatter3d=TRUE)
plot(s100, qt.col=1)

plot(ca20)                       # original data
plot(ca20, trend=~altitude+area) # residuals from an external trend
plot(ca20, trend='1st')          # residuals from a polynomial trend

plot(sic.100, bor=sic.borders)           # original data
plot(sic.100, bor=sic.borders, lambda=0) # logarithm of the data
</code></pre>

<hr>
<h2 id='plot.grf'>Plots Variograms for Simulated Data</h2><span id='topic+plot.grf'></span>

<h3>Description</h3>

<p>This function plots variograms for simulated geostatistical data
generated by the function <code><a href="#topic+grf">grf</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grf'
plot(x, model.line = TRUE, plot.locations = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.grf_+3A_x">x</code></td>
<td>
<p>an object of the class <code>grf</code>, typically an output of the function
<code><a href="#topic+grf">grf</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.grf_+3A_model.line">model.line</code></td>
<td>
<p>logical. If <code>TRUE</code> the true variogram model is added to the
plot with the sample variogram(s).  </p>
</td></tr>
<tr><td><code id="plot.grf_+3A_plot.locations">plot.locations</code></td>
<td>
<p>logical. If <code>TRUE</code> a plot with data locations is
also shown.  </p>
</td></tr>
<tr><td><code id="plot.grf_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the functions
<code><a href="#topic+variog">variog</a></code> and <code><a href="base.html#topic+plot">plot</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the empirical variogram(s) is produced on the output device. No
values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grf">grf</a></code> for simulation of Gaussian random fields,
<code><a href="#topic+plot.variogram">plot.variogram</a></code> for plotting empirical variogram,
<code><a href="#topic+variog">variog</a></code> for computation of empirical variograms  and
<code><a href="base.html#topic+plot">plot</a></code> for the generic plotting function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
sim1 &lt;- grf(100, cov.pars=c(10, .25))
# generates simulated data
plot(sim1, plot.locations = TRUE)
#
# plots the locations and the sample true variogram model
#
par(mfrow=c(1,1))
sim2 &lt;- grf(100, cov.pars=c(10, .25), nsim=10)
# generates 10 simulated data
plot(sim1)
# plots sample variograms for all simulations with the true model
par(op)
</code></pre>

<hr>
<h2 id='plot.krige.bayes'>Plots Prior and/or Posterior Distributions</h2><span id='topic+plot.krige.bayes'></span>

<h3>Description</h3>

<p>Produces
plots the priors and posteriors distribuitions for the paramters
<code>phi</code> and <code>tausq.rel</code> based on results returned by
<code><a href="#topic+krige.bayes">krige.bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'krige.bayes'
plot(x, phi.dist = TRUE, tausq.rel.dist = TRUE, add = FALSE,
                 type=c("bars", "h", "l", "b", "o", "p"), thin, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.krige.bayes_+3A_x">x</code></td>
<td>
<p>an object of the class <code>krige.bayes</code>, with an output of
the funtions <code><a href="#topic+krige.bayes">krige.bayes</a></code>. </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_phi.dist">phi.dist</code></td>
<td>
<p>logical indicating whether or not plot the
distributions for this parameter.  </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_tausq.rel.dist">tausq.rel.dist</code></td>
<td>
<p>logical indicating whether or not plot the
distributions for this parameter.  </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code> plots is added to current one.  </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_type">type</code></td>
<td>
<p>indicates the type of plot. Option <code>"bars"</code> uses the
function <code><a href="graphics.html#topic+barplot">barplot</a></code> and the others uses
<code><a href="graphics.html#topic+matplot">matplot</a></code>. </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_thin">thin</code></td>
<td>
<p>a numerical vector defining the thining for values of the
parameters <code>phi</code> and <code>tausq.rel</code> respectively.
This improves visualisation when there are many values
in the discrete distribution of the parameters.  </p>
</td></tr>
<tr><td><code id="plot.krige.bayes_+3A_...">...</code></td>
<td>
<p>further arguments for the plotting function.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>plot.krige.bayes</code> a plot is produced or added to the current
graphics device. No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.bayes">krige.bayes</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See documentation for krige.bayes
</code></pre>

<hr>
<h2 id='plot.proflik'>Plots Profile Likelihoods</h2><span id='topic+plot.proflik'></span><span id='topic+.proflik.plot.aux1'></span>

<h3>Description</h3>

<p>This function produces plots of the profile likelihoods computed by
the function <code><a href="#topic+proflik">proflik</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proflik'
plot(x, pages = c("user", "one", "two"), uni.only, bi.only,
             type.bi = c("contour", "persp"), conf.int = c(0.90, 0.95),
             yaxis.lims = c("conf.int", "as.computed"),
             by.col = TRUE, log.scale = FALSE, use.splines = TRUE,
             par.mar.persp = c(0, 0, 0, 0), ask = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.proflik_+3A_x">x</code></td>
<td>
<p>an object of the class <code>proflik</code>, typically an
output of the function <code><a href="#topic+proflik">proflik</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_pages">pages</code></td>
<td>
<p>specify how the plots will be arranged in the
graphics device. The default option, <code>"user"</code>, uses the current
graphical parameters. The option <code>"one"</code> places all the
profiles in the same page and the option <code>"two"</code> places the
univariate profiles in one page and the bivariate profiles in
a second page.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_uni.only">uni.only</code></td>
<td>
<p>only 1-D profiles are plotted even if the object
contains results about the 2-D profiles.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_bi.only">bi.only</code></td>
<td>
<p>only 2-D profile are plotted even if the object
contains results about the 1-D profiles.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_type.bi">type.bi</code></td>
<td>
<p>Type of plot for the 2-D profiles. Options are
<code>"contour"</code> for  contour plot
(the default) and <code>"persp"</code> for perspective plot.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_conf.int">conf.int</code></td>
<td>
<p>a vector with numbers in the interval <code class="reqn">[0,1]</code>
specifying levels of the (approximated) confidence
intervals. Defaults corresponds to the levels  90% and 95%.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_yaxis.lims">yaxis.lims</code></td>
<td>
<p>defines the lower limits for the y-axis in the 1-D
plots. If <code>"conf.int"</code> the limit is determined by the level of
the confidence interval (the default) otherwise will be determined
by the smallest computed value.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_by.col">by.col</code></td>
<td>
<p>logical, If <code>TRUE</code> the plots are arranged by columns in a multiple graphics
device.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_log.scale">log.scale</code></td>
<td>
<p>plots the x-axis in the logarithmic scale. Defaults to
<code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_use.splines">use.splines</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) the function
<code><a href="stats.html#topic+spline">spline</a></code> is used to interpolate between the points
computed by <code>proflik</code>.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_par.mar.persp">par.mar.persp</code></td>
<td>
<p>graphical parameters to be used with
<code><a href="graphics.html#topic+persp">persp</a></code> plots. For more details see <code><a href="graphics.html#topic+par">par</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_ask">ask</code></td>
<td>
<p>logical. Defines whether or not the user is prompted before
each plot is produced.  </p>
</td></tr>
<tr><td><code id="plot.proflik_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the functions
<code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code> and/or <code><a href="graphics.html#topic+persp">persp</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plots with the profile likelihoods on the current graphics device.
No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proflik">proflik</a></code> for computation of the profile
likelihoods. For the generic plotting functions see
<code><a href="base.html#topic+plot">plot</a></code>,  <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>.
See <code><a href="stats.html#topic+spline">spline</a></code> for interpolation.  </p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples in the documentation for the function proflik()
</code></pre>

<hr>
<h2 id='plot.variog4'>Plot Directional Variograms</h2><span id='topic+plot.variog4'></span>

<h3>Description</h3>

<p>This function plot directional variograms computed by the function
<code><a href="#topic+variog4">variog4</a></code>. The omnidirectional variogram can be also included
in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variog4'
plot(x, omnidirectional=FALSE, same.plot=TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.variog4_+3A_x">x</code></td>
<td>
<p>an object of the class <code>variog4</code>, typically an output of the function <code><a href="#topic+variog4">variog4</a></code>. </p>
</td></tr>
<tr><td><code id="plot.variog4_+3A_omnidirectional">omnidirectional</code></td>
<td>
<p>logical. Indicates whether the omnidirectional
variogram is included in the plot. </p>
</td></tr>
<tr><td><code id="plot.variog4_+3A_same.plot">same.plot</code></td>
<td>
<p>logical. Indicates whether the directional variograms
are plotted in the same or separated plots.  </p>
</td></tr>
<tr><td><code id="plot.variog4_+3A_legend">legend</code></td>
<td>
<p>logical indicating whether legends are automatically
included in the plots.  </p>
</td></tr>
<tr><td><code id="plot.variog4_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="base.html#topic+plot">plot</a></code>. Typical arguments are <code>col</code>, <code>lty</code>,
<code>lwd</code>. For <code>same.plot = TRUE</code> the arguments are passed to
the function 
<code><a href="graphics.html#topic+matplot">matplot</a></code> which is used to produce the plot.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced on the output device. No values returned.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information about the <span class="pkg">geoR</span> package can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog4">variog4</a></code> for variogram calculations and
<code><a href="graphics.html#topic+matplot">matplot</a></code> for multiple lines plotting.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>s100.v4 &lt;- variog4(s100, max.dist=1)
# Plotting variograms for the four directions
plot(s100.v4)
# changing plot options
plot(s100.v4, lwd=2)
plot(s100.v4, lty=1, col=c("darkorange", "darkblue", "darkgreen","darkviolet"))
plot(s100.v4, lty=1, lwd=2)
# including the omnidirectional variogram
plot(s100.v4, omni=TRUE)
# variograms on different plots
plot(s100.v4, omni=TRUE, same=FALSE)
</code></pre>

<hr>
<h2 id='plot.variogram'>Plot Empirical Variogram</h2><span id='topic+plot.variogram'></span>

<h3>Description</h3>

<p>Plots sample (empirical) variogram computed using the
function <code><a href="#topic+variog">variog</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogram'
plot(x, max.dist, vario.col = "all", scaled = FALSE,
               var.lines = FALSE, envelope.obj = NULL,
               pts.range.cex, bin.cloud = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.variogram_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"variogram"</code>, typically an
output of the function <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance for the x-axis. The default is
the maximum distance for which the sample variogram was computed.</p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_vario.col">vario.col</code></td>
<td>
<p>only used if <code>obj</code> has information on more than
one empirical variogram. The default <code>"all"</code> indicates that
variograms of all variables should be plotted.  Alternativelly a
numerical vector can be used to select  variables. </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_scaled">scaled</code></td>
<td>
<p>If <code>TRUE</code> the variogram values are divided by the
sample variance. This allows comparison of variograms 
of variables measured in different scales.  </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_var.lines">var.lines</code></td>
<td>
<p>If <code>TRUE</code> a horizontal line is drawn at the value
of the variance of the data (if <code>scaled = F</code>) or at 1 (if
<code>scaled = T</code>).  </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_envelope.obj">envelope.obj</code></td>
<td>
<p>adds a variogram envelope computed by
the function <code><a href="#topic+variog.model.env">variog.model.env</a></code> or
<code><a href="#topic+variog.mc.env">variog.mc.env</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_pts.range.cex">pts.range.cex</code></td>
<td>
<p>optional. A two elements vector with maximum and
minimum values for the caracter expansion factor <code>cex</code>. If
provided the point sizes in binned variogram are proportional to the
number of pairs of points used to compute each bin.  </p>
</td></tr> 
<tr><td><code id="plot.variogram_+3A_bin.cloud">bin.cloud</code></td>
<td>
<p>logical. If <code>TRUE</code>
and the sample variogram
was computed with the option <code>bin.cloud = TRUE</code>, box-plots
of values at each bin are plotted instead of the empirical
variograms.  </p>
</td></tr>
<tr><td><code id="plot.variogram_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="base.html#topic+plot">plot</a></code> or <code><a href="graphics.html#topic+matplot">matplot</a></code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots empirical  variograms.
Toghether with  <code><a href="#topic+lines.variogram">lines.variogram</a></code>
can be used to compare sample variograms of different variables
and 
to compare variogram models against the
empirical variogram.
</p>
<p>It uses the function <code><a href="graphics.html#topic+matplot">matplot</a></code> when plotting variograms
for more them one variable.
</p>


<h3>Value</h3>

<p>Produces a plot with the sample variogram on the current graphics
device.
No values are returned.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog">variog</a></code> for variogram calculations,
<code><a href="#topic+lines.variogram">lines.variogram</a></code> and <code><a href="#topic+lines.variomodel">lines.variomodel</a></code> for
adding lines to the current plot,
<code><a href="#topic+variog.model.env">variog.model.env</a></code> and <code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for
variogram envelops computation, <code><a href="graphics.html#topic+matplot">matplot</a></code> for multiple
lines plot 
and <code><a href="base.html#topic+plot">plot</a></code> for generic plot function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly = TRUE)
sim &lt;- grf(100, cov.pars=c(1, .2)) # simulates data
vario &lt;- variog(sim, max.dist=1)   # computes sample variogram
par(mfrow=c(2,2))
plot(vario)                     # the sample variogram
plot(vario, scaled = TRUE)      # the scaled sample variogram
plot(vario, max.dist = 1)       # limiting the maximum distance
plot(vario, pts.range = c(1,3)) # points sizes proportional to number of pairs
par(op)
</code></pre>

<hr>
<h2 id='plot.xvalid'>Plot Cross-Validation Results</h2><span id='topic+plot.xvalid'></span>

<h3>Description</h3>

<p>This function produces ten plots with the results produced by the
cross-validation function <code><a href="#topic+xvalid">xvalid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xvalid'
plot(x, coords, borders = NULL, ask = TRUE,
            error = TRUE, std.error = TRUE, data.predicted = TRUE,
            pp = TRUE, map = TRUE, histogram = TRUE,
            error.predicted = TRUE, error.data = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xvalid_+3A_x">x</code></td>
<td>
<p>an object of the class <code>"xvalid"</code>, typically an output
from the function <code><a href="#topic+xvalid">xvalid</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> object containing
coordinates of the (cross-)validation locations.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_borders">borders</code></td>
<td>
<p>optional. Takes a two column matrix or data-frame with
coordinates of the borders. If provided the borders are included in
the errors maps.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_ask">ask</code></td>
<td>
<p>logical. Defines whether or not the user is prompted before
each plot is produced.</p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_error">error</code></td>
<td>
<p>logical. Defines whether the plots for the errors
(<code class="reqn">error = data - predicted</code>) will
be produced.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_std.error">std.error</code></td>
<td>
<p>logical. Defines whether the plots for the
standardised errors will be produced.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_data.predicted">data.predicted</code></td>
<td>
<p>logical defining whether a plot of data versus
predicted should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_pp">pp</code></td>
<td>
<p>logical defining whether a <em>pp</em> plot
should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_map">map</code></td>
<td>
<p>logical defining whether a map of the errors
should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_histogram">histogram</code></td>
<td>
<p>logical defining whether a histogram of the errors
should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_error.predicted">error.predicted</code></td>
<td>
<p>logical defining whether a plot of errors versus
predicted should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_error.data">error.data</code></td>
<td>
<p>logical defining whether a plot of errors versus
data should be displayed. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="plot.xvalid_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="base.html#topic+plot">plot</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of plots to be produced will depend on the input options.
If the graphics device is set to just one plot (something equivalent
to <span class="option">par(mfcol=c(1,1))</span>) after each graphic being displayed the user will be prompt
to press <kbd>&lt;return&gt;</kbd> to see the next graphic.
</p>
<p>Alternativaly the user can set the graphical parameter to have several
plots in one page. With default options for the arguments the maximum
number of plots (10) is produced and setting <span class="option">par(mfcol=c(5,2))</span>)
will display them in the same page.
</p>
<p>The &ldquo;errors&rdquo; for the plots are defined as
</p>
<p style="text-align: center;"><code class="reqn">error = data - predicted</code>
</p>

<p>and the plots uses the color blue to indicate positive errors and
red to indicate negative erros. 
</p>


<h3>Value</h3>

<p>No value returned. Plots are produced on the current graphics device.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xvalid">xvalid</a></code> for the cross-validation computations.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>wls &lt;- variofit(variog(s100, max.dist = 1), ini = c(.5, .5), fix.n = TRUE)
xvl &lt;- xvalid(s100, model = wls)
#
op &lt;- par(no.readonly = TRUE)
par(mfcol = c(3,2))
par(mar = c(3,3,0,1))
par(mgp = c(2,1,0))
plot(xvl, error = FALSE, ask = FALSE)
plot(xvl, std.err = FALSE, ask = FALSE)
par(op)
</code></pre>

<hr>
<h2 id='points.geodata'>Plots Spatial Locations and Data Values</h2><span id='topic+points.geodata'></span>

<h3>Description</h3>

<p>This function produces a plot with 
points indicating the  data locations. Arguments can control the
points sizes, patterns and colors. These can be set to be proportional
to data values, ranks  or quantiles. Alternatively, points can be added
to the current  plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
points(x, coords=x$coords, data=x$data, data.col = 1, borders,
               pt.divide=c("data.proportional","rank.proportional",
                           "quintiles", "quartiles", "deciles", "equal"),
               lambda = 1, trend = "cte", abs.residuals = FALSE,
               weights.divide = "units.m", cex.min, cex.max, cex.var,
               pch.seq, col.seq, add.to.plot = FALSE,
               x.leg, y.leg = NULL, dig.leg = 2, 
               round.quantiles = FALSE, permute = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.geodata_+3A_x">x</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  
</p>
</td></tr>
<tr><td><code id="points.geodata_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix containing
coordinates of the <code class="reqn">n</code> data locations in each row.
Defaults to <code>geodata$coords</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_data">data</code></td>
<td>
<p>a vector or matrix with data values.
If a matrix is provided each column is regarded as one variable or realization.
Defaults to <code>geodata$data</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_data.col">data.col</code></td>
<td>
<p>the number of the data column. Only used if
<code>data</code> is a matrix with columns corresponding to different
variables or simulations.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_borders">borders</code></td>
<td>
<p>If an <code class="reqn">n \times 2</code>
matrix or data-frame with the coordinates of the borders of the
regions is provided, the borders are added to the plot.
By default it searches for a element named &quot;borders&quot; in  the geodata
object.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_pt.divide">pt.divide</code></td>
<td>
<p>defines the division of the points in categories.
See <code>DETAILS</code> below for the available options.
Defaults to <code>pt.divide = "data.proportional"</code>.   </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model. The options are:
<code>"cte"</code> (constant mean - default option), <code>"1st"</code> (a first order polynomial
on the coordinates), <code>"2nd"</code> (a second order polynomial
on the coordinates), or a formula of the type <code>~X</code> where <code>X</code>
is a matrix with the covariates (external trend).
If provided the trend is &quot;removed&quot; using the function
<code><a href="stats.html#topic+lm">lm</a></code> and the residuals are plotted.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_abs.residuals">abs.residuals</code></td>
<td>
<p>logical. If <code>TRUE</code> and the value passed to
the
argument <code>trend</code> is different from <code>"cte"</code> the point sizes
are proportional to absolute values of the residuals.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter. Two particular cases
are <code class="reqn">\lambda = 1</code> which corresponds to no
transformation and  <code class="reqn">\lambda = 0</code> corresponding to
the log-transformation.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_weights.divide">weights.divide</code></td>
<td>
<p>if a vector of weights with the same length as
the data is provided each  data is
divided by the corresponding element in this vector.
Defaults divides the data by the element <code>units.m</code> in the
data object, if present, otherwise no action is taken and original
data is used.
The usage of <code>units.m</code> is common for data objects
to be analysed using the package <span class="pkg">geoRglm</span>. </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_cex.min">cex.min</code></td>
<td>
<p>minimum value for the graphical parameter
<code>cex</code>. This value defines the size of the point corresponding the minimum
of the data. Defaults to 0.5.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_cex.max">cex.max</code></td>
<td>
<p>maximum value for the graphical parameter
<code>cex</code>. This value defines the size of the point corresponding the maximum
of the data. If <code>pt.divide = "equal"</code> it is used to set
the value for the
graphical parameter <code>cex</code>. Defaults to 1.5.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_cex.var">cex.var</code></td>
<td>
<p>a numeric vector with the values of a variable defining
the size of the points. Particularly useful for displaying 2
variables at once.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_pch.seq">pch.seq</code></td>
<td>
<p>number(s) defining the graphical parameter <code>pch</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_col.seq">col.seq</code></td>
<td>
<p>number(s) defining the colors in the graphical parameter
<code>col</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>logical. If <code>TRUE</code> the points are added
to the current plot or image otherwise a display is open. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_x.leg">x.leg</code>, <code id="points.geodata_+3A_y.leg">y.leg</code></td>
<td>
<p><code>x</code> and <code>y</code> location of the legend as
documented in <code><a href="graphics.html#topic+legend">legend</a></code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_dig.leg">dig.leg</code></td>
<td>
<p>the desired number of digits after the decimal
point. Printing values in the legend uses <code><a href="base.html#topic+formatC">formatC</a></code> with
argument <code>format = "f"</code>. </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_round.quantiles">round.quantiles</code></td>
<td>
<p>logical. Defines whether or not the values
of the quantiles should be rounded. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="points.geodata_+3A_permute">permute</code></td>
<td>
<p>logical indication whether the data values should be
randomly re-alocatted to the coordinates. See <code>DETAILS</code> below.</p>
</td></tr>
<tr><td><code id="points.geodata_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="base.html#topic+plot">plot</a></code>, if <code>add.to.plot = FALSE</code>; or to the function
<code><a href="graphics.html#topic+points">points</a></code>, if <code>add.to.plot = TRUE</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points can be devided in categories and have different sizes
and/or colours according to the argument
<code>pt.divide</code>. The options are:
</p>

<dl>
<dt>&quot;data.proportional&quot;</dt><dd><p>sizes proportional to the data values.  </p>
</dd>
<dt>&quot;rank.proportional&quot;</dt><dd><p>sizes proportional to the rank of the
data.  </p>
</dd>
<dt>&quot;quintiles&quot;</dt><dd><p>five different sizes according to the
quintiles of the data.  </p>
</dd>
<dt>&quot;quartiles&quot;</dt><dd><p>four different sizes according to the
quartiles of the data.  </p>
</dd> 
<dt>&quot;deciles&quot;</dt><dd><p>ten different sizes according to the
deciles of the data. </p>
</dd>
<dt>&quot;equal&quot;</dt><dd><p>all points with the same size.  </p>
</dd>
<dt>a scalar</dt><dd><p>defines a number of quantiles, the number provided
defines the  number of different points sizes and colors.  </p>
</dd>
<dt>a numerical vector with quantiles and length &gt; 1</dt><dd><p>the values in the
vector will be used by the function <code><a href="base.html#topic+cut">cut</a></code> as break
points to divide the data in classes. </p>
</dd>
</dl>

<p>For cases where points have different sizes the arguments
<code>cex.min</code> and <code>cex.max</code> set the minimum and the maximum
point sizes. Additionally,
<code>pch.seq</code> can set different patterns for the points and
<code>col.seq</code> can be used to define colors.
For example, different colors
can be used for quartiles, quintiles and deciles while a sequence of
gray tones (or a color sequence) can be used
for point sizes proportional to the data or their ranks.
For more details see the section <code>EXAMPLES</code>.
</p>
<p>The argument <code>cex.var</code> allows for displaying 2 variables
at once. In this case one variable defines the backgroung colour
of the points and the other defines the points size.
</p>
<p>The argument <code>permute</code> if set to <code>TRUE</code>
randomly realocates the data in the coordinates.
This may be used to
contrast the spatial pattern of original data against another
situation where there is no spatial dependence (when setting
<code>permute = TRUE</code>). If a <code>trend</code> is provided the residuals
(and not the original data) are permuted.
</p>


<h3>Value</h3>

<p>A plot is created or points are added to the current graphics device.<br />
A list with graphical parameters used to produce the plot is returned invisibily.
According to the input options, the list has some or all of the
following components:
</p>
<table>
<tr><td><code>quantiles</code></td>
<td>
<p>the values of the quantiles used to divide the data.  </p>
</td></tr>
<tr><td><code>cex</code></td>
<td>
<p>the values of the graphics expansion parameter <code>cex</code>.
</p>
</td></tr> 
<tr><td><code>col</code></td>
<td>
<p>the values of the graphics color parameter <code>col</code>.  </p>
</td></tr>
<tr><td><code>pch</code></td>
<td>
<p>the values of the graphics pattern parameter <code>pch</code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.geodata">plot.geodata</a></code> for another display of the data and
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="base.html#topic+plot">plot</a></code> for information on the
generic <span class="rlang"><b>R</b></span> functions. The documentation of
<code><a href="graphics.html#topic+par">par</a></code> provides details on graphical parameters.
For  color schemes in <span class="rlang"><b>R</b></span> see <code><a href="grDevices.html#topic+gray">gray</a></code> and
<code><a href="grDevices.html#topic+rainbow">rainbow</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=c(3,3,1,1), mgp = c(2,1,0))
points(s100, xlab="Coord X", ylab="Coord Y")
points(s100, xlab="Coord X", ylab="Coord Y", pt.divide="rank.prop")
points(s100, xlab="Coord X", ylab="Coord Y", cex.max=1.7,
               col=gray(seq(1, 0.1, l=100)), pt.divide="equal")
points(s100, pt.divide="quintile", xlab="Coord X", ylab="Coord Y")
par(op)

points(ca20, pt.div='quartile', x.leg=4900, y.leg=5850)

par(mfrow=c(1,2), mar=c(3,3,1,1), mgp = c(2,1,0))
points(s100, main="Original data")
points(s100, permute=TRUE, main="Permuting locations")

## Now an example using 2 variable, 1 defining the
## gray scale and the other the points size
points.geodata(coords=camg[,1:2], data=camg[,3], col="gray",
               cex.var=camg[,5])
points.geodata(coords=camg[,1:2], data=camg[,3], col="gray",
               cex.var=camg[,5], pt.div="quint")
</code></pre>

<hr>
<h2 id='polygrid'>Coordinates of Points Inside a Polygon </h2><span id='topic+polygrid'></span>

<h3>Description</h3>

<p>This function builds a rectangular grid and extracts points which are
inside of an internal polygonal region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygrid(xgrid, ygrid, borders, vec.inout = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygrid_+3A_xgrid">xgrid</code></td>
<td>
<p>grid values in the <em>x</em>-direction.  </p>
</td></tr>
<tr><td><code id="polygrid_+3A_ygrid">ygrid</code></td>
<td>
<p>grid values in the <em>y</em>-direction.  </p>
</td></tr>
<tr><td><code id="polygrid_+3A_borders">borders</code></td>
<td>
<p>a matrix with polygon coordinates defining the
borders of the region.  </p>
</td></tr>
<tr><td><code id="polygrid_+3A_vec.inout">vec.inout</code></td>
<td>
<p>logical. If <code>TRUE</code> a logical vector is included
in the output indicating whether each point of the grid is inside
the polygon.  Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="polygrid_+3A_...">...</code></td>
<td>
<p>currently not used (kept for back compatibility). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works as follows:
First it creates a grid using the <span class="rlang"><b>R</b></span> function
<code><a href="base.html#topic+expand.grid">expand.grid</a></code> and then it uses the geoR'
internal function
<code>.geoR_inout()</code> which wraps usage of <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>
and <code><a href="sp.html#topic+over">over</a></code>
from the package <span class="pkg">sp</span> to extract the points
of the grid which are inside the polygon.
</p>
<p>Within the package <span class="pkg">geoR</span>
this function is typically used to select points in a non-rectangular
region to perform spatial prediction
using <code><a href="#topic+krige.bayes">krige.bayes</a></code>, <code><a href="#topic+krige.conv">krige.conv</a></code> or
<code><a href="#topic+ksline">ksline</a></code>. It is also useful to produce
image or perspective plots of the prediction results.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>xypoly</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the coordinates of the points inside the polygon.  </p>
</td></tr>
<tr><td><code>vec.inout</code></td>
<td>
<p>logical, a vector indicating whether each point of
the rectangular grid is inside the polygon. Only returned if <code>vec.inout = TRUE</code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pred_grid">pred_grid</a></code>, <code><a href="base.html#topic+expand.grid">expand.grid</a></code>, <code><a href="sp.html#topic+over">over</a></code>,
<code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> poly &lt;- matrix(c(.2, .8, .7, .1, .2, .1, .2, .7, .7, .1), ncol=2)
 plot(0:1, 0:1, type="n")
 lines(poly)
 poly.in &lt;- polygrid(seq(0,1,l=11), seq(0,1,l=11), poly, vec=TRUE)
 points(poly.in$xy)
</code></pre>

<hr>
<h2 id='practicalRange'>Pratical range for correlation functions</h2><span id='topic+practicalRange'></span>

<h3>Description</h3>

<p>Computes practical ranges for the correlation functions implemented in
the geoR package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>practicalRange(cov.model, phi, kappa = 0.5, correlation = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="practicalRange_+3A_cov.model">cov.model</code></td>
<td>
<p>correlation model as documented in
<code><a href="#topic+cov.spatial">cov.spatial</a></code>.  </p>
</td></tr>
<tr><td><code id="practicalRange_+3A_phi">phi</code></td>
<td>
<p>correlation parameter as documented in <code><a href="#topic+cov.spatial">cov.spatial</a></code>. </p>
</td></tr>
<tr><td><code id="practicalRange_+3A_kappa">kappa</code></td>
<td>
<p>additional correlation parameter as documented in
<code><a href="#topic+cov.spatial">cov.spatial</a></code>.  </p>
</td></tr>
<tr><td><code id="practicalRange_+3A_correlation">correlation</code></td>
<td>
<p>correlation threshold for asymptotic
models. Defaults to 0.05.  </p>
</td></tr>
<tr><td><code id="practicalRange_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="stats.html#topic+optimise">optimise</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar with the value of the practical range.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.spatial">cov.spatial</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>practicalRange("exp", phi=10)
practicalRange("sph", phi=10)
practicalRange("gaus", phi=10)
practicalRange("matern", phi=10, kappa=0.5)
practicalRange("matern", phi=10, kappa=1.5)
practicalRange("matern", phi=10, kappa=2.5)
</code></pre>

<hr>
<h2 id='pred_grid'>Generates a 2D Prediction Grid </h2><span id='topic+pred_grid'></span>

<h3>Description</h3>

<p>This function facilitates the generation of a 2D prediction grid for
geostatistical kriging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_grid(coords, y.coords = NULL, ..., y.by = NULL,
          y.length.out = NULL, y.along.with = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_grid_+3A_coords">coords</code></td>
<td>
<p>a list, matrix or data-frame with xy-coordinates
of prediction points or a vector with x-coordinates.  </p>
</td></tr>
<tr><td><code id="pred_grid_+3A_y.coords">y.coords</code></td>
<td>
<p>a vector with y-coordinates. Needed if
argument <code>coords</code> provides only x-coordinates.  </p>
</td></tr>
<tr><td><code id="pred_grid_+3A_...">...</code></td>
<td>
<p>arguments <code>by</code> or <code>length.out</code>
to be passed to the function <code><a href="base.html#topic+rep">rep</a></code>.
These arguments are used for the x-coordinates and are
default optioons for y-coordinates.  </p>
</td></tr>
<tr><td><code id="pred_grid_+3A_y.by">y.by</code></td>
<td>
<p>Optional. <code>by</code> argument for <code><a href="base.html#topic+rep">rep</a></code> to be
used with the y-coordinates. </p>
</td></tr>
<tr><td><code id="pred_grid_+3A_y.length.out">y.length.out</code></td>
<td>
<p>Optional. <code>length.out</code> argument for
<code><a href="base.html#topic+rep">rep</a></code> to be used with the y-coordinates. </p>
</td></tr>
<tr><td><code id="pred_grid_+3A_y.along.with">y.along.with</code></td>
<td>
<p>Optional. <code>along.with</code> argument for <code><a href="base.html#topic+rep">rep</a></code> to be
used with the y-coordinates. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An two column data-frame which is on output of <code><a href="base.html#topic+expand.grid">expand.grid</a></code>. 
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+seq">seq</a></code> and <code><a href="base.html#topic+expand.grid">expand.grid</a></code> which are
used internally and  <code><a href="#topic+locations.inside">locations.inside</a></code> and
<code><a href="#topic+polygrid">polygrid</a></code> to select points inside a border.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pred_grid(c(0,1), c(0,1), by=0.25) ## create a grid in a unit square
loc0 &lt;- pred_grid(ca20$borders, by=20)
points(ca20)
points(loc0, pch="+")
points(locations.inside(loc0, ca20$border), pch="+", col=2)
</code></pre>

<hr>
<h2 id='predict.BGCCM'>Prediction for the bivariate Gaussian common component
geostatistical model</h2><span id='topic+predict.BGCCM'></span>

<h3>Description</h3>

<p>Performs prediction for the bivariate Gaussian common component
geostatistical model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGCCM'
predict(object, locations, borders,
              variable.to.predict = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BGCCM_+3A_object">object</code></td>
<td>
<p>on object of the class <code>BGCCMfit</code>, which is
an output of <code><a href="#topic+likfitBGCCM">likfitBGCCM</a></code>.  </p>
</td></tr>
<tr><td><code id="predict.BGCCM_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">N \times 2</code> matrix or data-frame with
the 2-D coordinates of the <code class="reqn">N</code> prediction locations,
or a list for which
the first two components are used. Input is internally checked by the
function <code>check.locations</code>.  </p>
</td></tr>
<tr><td><code id="predict.BGCCM_+3A_borders">borders</code></td>
<td>
<p>optional. If missing, by default reads the element
<code>borders</code> of the <code>geodata</code> object of the variable to be
predicted. Ignored if set to <code>NULL</code>.
If a two column matrix defining a polygon is
provided the prediction is performed only at locations inside this polygon. </p>
</td></tr>
<tr><td><code id="predict.BGCCM_+3A_variable.to.predict">variable.to.predict</code></td>
<td>
<p>scalar with options for values or 2
indicating which variable is to be predicted. </p>
</td></tr>
<tr><td><code id="predict.BGCCM_+3A_...">...</code></td>
<td>
<p>not yet used.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the class <code>BGCCMpred</code> with components:
</p>
<table>
<tr><td><code>predicted</code></td>
<td>
<p>predicted values.  </p>
</td></tr>
<tr><td><code>krige.var</code></td>
<td>
<p>prediction variances.  </p>
</td></tr>
</table>


<h3>Warning  </h3>

<p> This is a new function and still in draft format and pretty much untested.</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likfitBGCCM">likfitBGCCM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see http://www.leg.ufpr.br/geoR/tutorials/CCM.R
</code></pre>

<hr>
<h2 id='print.BGCCM'>Prints an summary of of the output from likfitBGCCM. </h2><span id='topic+print.BGCCM'></span>

<h3>Description</h3>

<p>Prints a short version of an object of the class <code>BGCCM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BGCCM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BGCCM_+3A_x">x</code></td>
<td>
<p>an object of the class <code>BGCCM</code>.  </p>
</td></tr>
<tr><td><code id="print.BGCCM_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="base.html#topic+format">format</a></code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+format">format</a></code> for options to format the output.</p>

<hr>
<h2 id='proflik'>Computes Profile Likelihoods</h2><span id='topic+proflik'></span><span id='topic+.proflik.aux0'></span><span id='topic+.proflik.aux1'></span><span id='topic+.proflik.aux10'></span><span id='topic+.proflik.aux11'></span><span id='topic+.proflik.aux1.1'></span><span id='topic+.proflik.aux12'></span><span id='topic+.proflik.aux13'></span><span id='topic+.proflik.aux14'></span><span id='topic+.proflik.aux15'></span><span id='topic+.proflik.aux16'></span><span id='topic+.proflik.aux17'></span><span id='topic+.proflik.aux18'></span><span id='topic+.proflik.aux19'></span><span id='topic+.proflik.aux2'></span><span id='topic+.proflik.aux20'></span><span id='topic+.proflik.aux21'></span><span id='topic+.proflik.aux21.1'></span><span id='topic+.proflik.aux22'></span><span id='topic+.proflik.aux23'></span><span id='topic+.proflik.aux24'></span><span id='topic+.proflik.aux27'></span><span id='topic+.proflik.aux28'></span><span id='topic+.proflik.aux30'></span><span id='topic+.proflik.aux3'></span><span id='topic+.proflik.aux31'></span><span id='topic+.proflik.aux32'></span><span id='topic+.proflik.aux33'></span><span id='topic+.proflik.aux4'></span><span id='topic+.proflik.aux5'></span><span id='topic+.proflik.aux6'></span><span id='topic+.proflik.aux7'></span><span id='topic+.proflik.aux8'></span><span id='topic+.proflik.aux9'></span><span id='topic+.proflik.cov'></span><span id='topic+.proflik.lambda'></span><span id='topic+.proflik.main'></span>

<h3>Description</h3>

<p>Computes profile likelihoods for model parameters
previously estimated using the function
<code><a href="#topic+likfit">likfit</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proflik(obj.likfit, geodata, coords = geodata$coords,
        data = geodata$data, sill.values, range.values,
        nugget.values, nugget.rel.values, lambda.values, 
        sillrange.values = TRUE, sillnugget.values = TRUE,
        rangenugget.values = TRUE, sillnugget.rel.values = FALSE,
        rangenugget.rel.values = FALSE, silllambda.values = FALSE,
        rangelambda.values = TRUE,  nuggetlambda.values = FALSE,
        nugget.rellambda.values = FALSE,
        uni.only = TRUE, bi.only = FALSE, messages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proflik_+3A_obj.likfit">obj.likfit</code></td>
<td>
<p>an object of the class <code>likfit</code>, typically an
output of the function <code><a href="#topic+likfit">likfit</a></code>.</p>
</td></tr>
<tr><td><code id="proflik_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set. If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_coords">coords</code></td>
<td>
<p> an <code class="reqn">n \times 2</code> matrix containing in each row Euclidean
coordinates of the <code class="reqn">n</code> data locations. By default it takes the
element <code>coords</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_data">data</code></td>
<td>
<p>a vector with data values. By default it takes the
element <code>data</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_sill.values">sill.values</code></td>
<td>
<p>set of values of the partial sill parameter
<code class="reqn">\sigma^2</code> for which the profile likelihood will be
computed.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_range.values">range.values</code></td>
<td>
<p>set of values of the range parameter
<code class="reqn">\phi</code> for which the profile likelihood will be computed.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_nugget.values">nugget.values</code></td>
<td>
<p>set of values of the nugget parameter
<code class="reqn">\tau^2</code> for which the profile likelihood will be
computed. Only used if the model was fitted using the function
<code><a href="#topic+likfit">likfit</a></code> with the option <code>fix.nugget = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_nugget.rel.values">nugget.rel.values</code></td>
<td>
<p>set of values of the relative nugget parameter
<code class="reqn">\tau_{R}^{2}</code> for which the profile likelihood will be
computed. Only used if the model was fitted using the function
<code><a href="#topic+likfit">likfit</a></code> with the option <code>fix.nugget = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_lambda.values">lambda.values</code></td>
<td>
<p>set of values of the Box-Cox transformation parameter
<code class="reqn">\lambda</code> for which the profile likelihood will be
computed. Only to be used if the model was fitted using the function
<code><a href="#topic+likfit">likfit</a></code> with the option <code>fix.lambda = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_sillrange.values">sillrange.values</code></td>
<td>
<p>logical indicating
whether or not the 2-D profile likelihood should be computed.
Only valid if <code>uni.only = FALSE</code>.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_sillnugget.values">sillnugget.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_rangenugget.values">rangenugget.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_sillnugget.rel.values">sillnugget.rel.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_rangenugget.rel.values">rangenugget.rel.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_silllambda.values">silllambda.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_rangelambda.values">rangelambda.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_nuggetlambda.values">nuggetlambda.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_nugget.rellambda.values">nugget.rellambda.values</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_uni.only">uni.only</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_bi.only">bi.only</code></td>
<td>
<p>as above.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates whether
status messages should be printed on the screen (i.e. current output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="proflik_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the minimization
function.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>.proflik.*</code> are auxiliary functions used to
compute the profile likelihoods. These functions are
internally called by the
minimization functions when estimating the model parameters.
</p>


<h3>Value</h3>

<p>An object of the class <code>"proflik"</code> which is 
a list. Each element contains values of a parameter (or a pair of
parameters for 2-D profiles) and the
corresponding value of the profile likelihood.
The components of the output will vary according to the
input options.
</p>


<h3>Note</h3>


<ol>
<li><p> Profile likelihoods for Gaussian Random Fields are usually
uni-modal. 
Unusual or jagged shapes can
be due to the lack of the convergence in the numerical minimization
for particular values of the parameter(s).  
If this is the case it might be necessary to pass <code>control</code> arguments 
to the minimization functions using the argument ....
It's also advisable to try the different options for the
<code>minimisation.function</code> argument.
See documentation of the functions <code><a href="stats.html#topic+optim">optim</a></code> and/or
<code><a href="stats.html#topic+nlm">nlm</a></code> for further details.
</p>
</li>
<li><p> 2-D profiles can be computed by setting the argument
<code>uni.only = FALSE</code>. However, before computing 2-D profiles be
sure they are really necessary.
Their computation can be time demanding since it 
is performed on a grid determined by the
cross-product of the values defining the 1-D profiles.
</p>
</li>
<li><p> There is no &quot;default strategy&quot; to find reasonable values for the
x-axis.
They must be found in a &quot;try-and-error&quot; exercise. It's recommended
to use short sequences in the initial attempts.
The <code>EXAMPLE</code> section below illustrates this.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.proflik">plot.proflik</a></code> for graphical output,
<code><a href="#topic+likfit">likfit</a></code> for the parameter estimation,
<code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code> for further details about
the minimization functions.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly=TRUE)
ml &lt;- likfit(s100, ini=c(.5, .5), fix.nug=TRUE)
## a first atempt to find reasonable values for the x-axis:
prof &lt;- proflik(ml, s100, sill.values=seq(0.5, 1.5, l=4),
                range.val=seq(0.1, .5, l=4))
par(mfrow=c(1,2))
plot(prof)
## a nicer setting 
## Not run: 
prof &lt;- proflik(ml, s100, sill.values=seq(0.45, 2, l=11),
                range.val=seq(0.1, .55, l=11))
plot(prof)
## to include 2-D profiles use:
## (commented because this is time demanding)
#prof &lt;- proflik(ml, s100, sill.values=seq(0.45, 2, l=11),
#                range.val=seq(0.1, .55, l=11), uni.only=FALSE)
#par(mfrow=c(2,2))
#plot(prof, nlevels=16)

## End(Not run)
par(op)
</code></pre>

<hr>
<h2 id='read.geodata'>Reads and Converts Data to geoR Format</h2><span id='topic+read.geodata'></span>

<h3>Description</h3>

<p>Reads data from a <em>ASCII</em> file and converts it to an object of the
<code><a href="base.html#topic+class">class</a></code> <code>geodata</code>, the standard data format for the
<span class="pkg">geoR</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.geodata(file, header = FALSE, coords.col = 1:2, data.col = 3,
             data.names = NULL, covar.col = NULL, covar.names = "header",
             units.m.col = NULL, realisations = NULL,
             na.action = c("ifany", "ifdata", "ifcovar", "none"),
             rep.data.action, rep.covar.action, rep.units.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.geodata_+3A_file">file</code></td>
<td>
<p>a string with the name of the <em>ASCII</em> file.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_header">header</code></td>
<td>
<p>logical.
Indicates whether the variables names should be
read from the first line of the input file.   </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_coords.col">coords.col</code></td>
<td>
<p>a vector with the numbers of the columns containing the
coordinates.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_data.col">data.col</code></td>
<td>
<p>a scalar or vector with the number of the column(s)
containing the data.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_data.names">data.names</code></td>
<td>
<p>a string or vector of strings with names for
the data columns. Only valid if there is more than one column of
data.
By default the names in the original object are used.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_covar.col">covar.col</code></td>
<td>
<p>optional. A scalar or vector with the number
of the column(s) with the values of the covariate(s).  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_covar.names">covar.names</code></td>
<td>
<p>optional. A vector with the names of the
the covariates. By default the names in the original object are
used.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_units.m.col">units.m.col</code></td>
<td>
<p>optional. A scalar 
with the column number corresponding to the offset variable.
Alternativelly can be a character vector with the name of the
offset. This option is particularly relevant when using the package
<span class="pkg">geoRglm</span>. </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_realisations">realisations</code></td>
<td>
<p>optional. A vector indicating the replication
number. For more details see documentation for
<code><a href="#topic+as.geodata">as.geodata</a></code>.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_na.action">na.action</code></td>
<td>
<p>a string. Defines action to be taken in the presence of
<code>NA</code>'s. For more details see documentation for
<code><a href="#topic+as.geodata">as.geodata</a></code>.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_rep.data.action">rep.data.action</code></td>
<td>
<p>a string or a function. Defines action to be taken when there is more than
one data at the same location. For more details see documentation for
<code><a href="#topic+as.geodata">as.geodata</a></code>.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_rep.covar.action">rep.covar.action</code></td>
<td>
<p>a string or a function. Defines action to be taken when there is more than
one covariate at the same location. For more details see documentation for
<code><a href="#topic+as.geodata">as.geodata</a></code>.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_rep.units.action">rep.units.action</code></td>
<td>
<p>a string or a function.
Defines action to be taken on the element <code>units.m</code>, if present
when there is more than
one data at the same location. The default option is the same
value set for <code>rep.data.action</code>.  </p>
</td></tr>
<tr><td><code id="read.geodata_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function <code><a href="utils.html#topic+read.table">read.table</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="utils.html#topic+read.table">read.table</a></code> is used to read the data from the
<em>ASCII</em> file and then <code><a href="#topic+as.geodata">as.geodata</a></code> is used to convert
to an object of the <code><a href="base.html#topic+class">class</a></code> <code>geodata</code>.
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>geodata</code>.
See documentation for the function <code><a href="#topic+as.geodata">as.geodata</a></code> for
further details.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.geodata">as.geodata</a></code> to convert existing <span class="rlang"><b>R</b></span> objects,
<code><a href="utils.html#topic+read.table">read.table</a></code>, the basic <span class="rlang"><b>R</b></span> function used to  read <em>ASCII</em> files,
and <code><a href="base.html#topic+list">list</a></code> for detailed information about lists.</p>

<hr>
<h2 id='rongelap'>Radionuclide Concentrations on Rongelap Island</h2><span id='topic+rongelap'></span>

<h3>Description</h3>

 
<p>This data-set was used by Diggle, Tawn and Moyeed (1998) to illustrate
the model-based geostatistical methodology introduced in the paper.
discussed in the paper. The radionuclide concentration data set consists 
of measurements of <code class="reqn">\gamma</code>-ray counts at <code class="reqn">157</code> locations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rongelap)</code></pre>


<h3>Format</h3>

<p>The object is a list
with the following components:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of data locations.  </p>
</dd>
<dt><code>data</code></dt><dd><p>the data.  </p>
</dd>
<dt><code>units.m</code></dt><dd><p><code class="reqn">n</code>-dimensional vector of observation-times for the data.  </p>
</dd>
<dt><code>borders</code></dt><dd><p>a matrix with the coordinates defining the coastline on
Rongelap Island.  </p>
</dd>
</dl>



<h3>Source</h3>

<p>For further details on the radionuclide concentration data, see Diggle,
Harper and Simon (1997), Diggle, Tawn and Moyeed (1998) and Christensen (2004).
</p>


<h3>References</h3>

<p>Christensen, O. F. (2004). Monte Carlo maximum likelihood in model-based geostatistics.
Journal of computational and graphical statistics <b>13</b> 702-718.
</p>
<p>Diggle, P. J., Harper, L. and Simon, S. L. (1997). Geostatistical analysis of residual contamination from nuclea
testing. In: <em>Statistics for the environment 3: pollution assesment and control</em> (eds. V. Barnet and K. F. Turkmann), Wiley, 
Chichester, 89-107.
</p>
<p>Diggle, P. J., Tawn, J. A. and Moyeed, R. A. (1998). Model-based
geostatistics (with Discussion). Applied Statistics,
47, 299&ndash;350.
</p>

<hr>
<h2 id='s100+20and+20s121'>Simulated Data-Sets which Illustrate the Usage of the Package
geoR  </h2><span id='topic+s100'></span><span id='topic+s121'></span>

<h3>Description</h3>

<p>These two simulated data sets are the ones used in the Technical
Report which describes the package <span class="pkg">geoR</span>
(see reference below). 
These data-sets are used in several examples throughout the package
documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s100)

data(s121)
</code></pre>


<h3>Format</h3>

<p>Two objects of the <code><a href="base.html#topic+class">class</a></code> <code>geodata</code>. Both are lists
with the following components:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of data locations.  </p>
</dd>
<dt><code>data</code></dt><dd><p>the simulated data. Notice that for <code>s121</code>
this a <code class="reqn">121 \times 10</code> matrix with 10 simulations.  </p>
</dd>
<dt><code>cov.model</code></dt><dd><p>the correlation model.  </p>
</dd>
<dt><code>nugget</code></dt><dd><p>the values of the nugget parameter.  </p>
</dd>
<dt><code>cov.pars</code></dt><dd><p>the covariance parameters.  </p>
</dd>
<dt><code>kappa</code></dt><dd><p>the value of the parameter <em>kappa</em>.  </p>
</dd>
<dt><code>lambda</code></dt><dd><p>the value of the parameter <em>lambda</em>.  </p>
</dd>
</dl>



<h3>References</h3>

<p>Ribeiro Jr, P.J. and Diggle, P.J. (1999) geoS: A geostatistical
library for S-PLUS. <em>Technical report ST-99-09, Dept of Maths and
Stats, Lancaster University</em>. 
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(s100)
plot(s121, type="l")
</code></pre>

<hr>
<h2 id='s256i'>Simulated Data-Set which Illustrate the Usage of krige.bayes  </h2><span id='topic+s256i'></span>

<h3>Description</h3>

<p>This is the simulated data-set used in the Technical
Report which describes the implementation of the function <b>krige.bayes</b>
(see reference below). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s256i)
</code></pre>


<h3>Format</h3>

<p>Two objects of the <code><a href="base.html#topic+class">class</a></code> <code>geodata</code>. Both are lists
with the following components:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of data locations.  </p>
</dd>
<dt><code>data</code></dt><dd><p>the simulated data.  </p>
</dd>
</dl>



<h3>References</h3>

<p>Ribeiro Jr, P.J. and Diggle, P.J. (1999)
Bayesian inference in Gaussian model-based geostatistics.
<em>Technical report ST-99-08, Dept of Maths and
Stats, Lancaster University</em>. 
</p>
<p>Further information about the <span class="pkg">geoR</span> package can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points(s256i, pt.div="quintiles", cex.min=1, cex.max=1)
</code></pre>

<hr>
<h2 id='sample.geodata'>Sampling from geodata objects</h2><span id='topic+sample.geodata'></span>

<h3>Description</h3>

<p>This functions facilitates extracting samples from geodata objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.geodata(x, size, replace = FALSE, prob = NULL, coef.logCox,
               external)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.geodata_+3A_x">x</code></td>
<td>
<p>an object of the class <code>geodata</code>. </p>
</td></tr>
<tr><td><code id="sample.geodata_+3A_size">size</code></td>
<td>
<p>non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="sample.geodata_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="sample.geodata_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights for obtaining the elements of
the data points being sampled.</p>
</td></tr>
<tr><td><code id="sample.geodata_+3A_coef.logcox">coef.logCox</code></td>
<td>
<p>optional. A scalar with the coeficient for the
log-Cox process. See DETAILS below.  </p>
</td></tr>
<tr><td><code id="sample.geodata_+3A_external">external</code></td>
<td>
<p>numeric values of a random field to be used
in the log-Cox inhomogeneous poisson process. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>prob=NULL</code> and 
the argument <code>coef.logCox</code>, is provided,
sampling follows a log-Cox proccess, i.e.
the probability of each point being sampled is proportional to:
</p>
<p style="text-align: center;"><code class="reqn">exp(b Y(x))</code>
</p>

<p>with <code class="reqn">b</code> given by the value passed to the argument
<code>coef.logCox</code> and <code class="reqn">Y(x)</code> taking values passed to
the argument <code>external</code> or, if this is missing,
the element <code>data</code> of the <code>geodata</code> object.
Therefore, the latter generates a preferential sampling. 
</p>


<h3>Value</h3>

<p>a list which is an object of the class <code>geodata</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.geodata">as.geodata</a></code>, <code><a href="base.html#topic+sample">sample</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(mfrow=c(1,2))
S1 &lt;- grf(2500,  grid="reg", cov.pars=c(1, .23))
image(S1, col=gray(seq(0.9,0.1,l=100)))
y1 &lt;- sample.geodata(S1, 80)
points(y1$coords, pch=19)
## Now a preferential sampling
y2 &lt;- sample.geodata(S1, 80, coef=1.3)
## which is equivalent topps
## y2 &lt;- sample.geodata(S1, 80, prob=exp(1.3*S1$data))
points(y2$coords, pch=19, col=2)
## and now a clustered (but not preferential)
S2 &lt;- grf(2500,  grid="reg", cov.pars=c(1, .23))
y3 &lt;- sample.geodata(S1, 80, prob=exp(1.3*S2$data))
## which is equivalent to
## points(y3$coords, pch=19, col=4)
image(S2, col=gray(seq(0.9,0.1,l=100)))
points(y3$coords, pch=19, col=4)

## End(Not run)
</code></pre>

<hr>
<h2 id='sample.posterior'>Samples from the posterior distribution</h2><span id='topic+sample.posterior'></span>

<h3>Description</h3>

<p>Sample quadruples <code class="reqn">(\beta, \sigma^2, \phi, \tau^2_{rel})</code> from the posterior
distribution returned by <code><a href="#topic+krige.bayes">krige.bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.posterior(n, kb.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.posterior_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="sample.posterior_+3A_kb.obj">kb.obj</code></td>
<td>
<p>on object with an output of <code><a href="#topic+krige.bayes">krige.bayes</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times 4</code> data-frame with samples from the posterior distribution of the model parameters.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="#topic+sample.posterior">sample.posterior</a></code>.  </p>

<hr>
<h2 id='sample.prior'>Sample the prior distribution</h2><span id='topic+sample.prior'></span>

<h3>Description</h3>

<p>Sample quadruples <code class="reqn">(\beta, \sigma^2, \phi, \tau^2_{rel})</code> from the prior distribution of parameters specifying a Gaussian
random field.
Typically the prior is specified in the same manner as when calling <code><a href="#topic+krige.bayes">krige.bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.prior(n, kb.obj=NULL, prior=prior.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.prior_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="sample.prior_+3A_kb.obj">kb.obj</code></td>
<td>
<p>on object with an output of <code><a href="#topic+krige.bayes">krige.bayes</a></code>.  </p>
</td></tr>
<tr><td><code id="sample.prior_+3A_prior">prior</code></td>
<td>
<p>an call to <code><a href="#topic+prior.control">prior.control</a></code>. Unnecessary if
<code>kb.obj</code> is provided.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">p+3 \times 4</code> data-frame with a sample of the prior
distribution of model parameters, where <code class="reqn">p</code> is the length of
the mean parameter <code class="reqn">\beta</code>.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="#topic+sample.posterior">sample.posterior</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>sample.prior(50, 
             prior=prior.control(beta.prior = "normal", beta = .5, beta.var.std=0.1, 
                                 sigmasq.prior="sc", sigmasq=1.2, df.sigmasq= 2, 
                                 phi.prior="rec", phi.discrete = seq(0,2, l=21)))
</code></pre>

<hr>
<h2 id='set.coords.lims'>Sets Limits to Scale Plots</h2><span id='topic+set.coords.lims'></span>

<h3>Description</h3>

<p>This is an function typically called by functions in the package
<span class="pkg">geoR</span> to set limits for the axis when plotting spatial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.coords.lims(coords, borders = coords, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.coords.lims_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with coordinates.  </p>
</td></tr>
<tr><td><code id="set.coords.lims_+3A_borders">borders</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with coordinates.  </p>
</td></tr>
<tr><td><code id="set.coords.lims_+3A_xlim">xlim</code>, <code id="set.coords.lims_+3A_ylim">ylim</code></td>
<td>
<p>the ranges to be encompassed by the x and y axes.  </p>
</td></tr>
<tr><td><code id="set.coords.lims_+3A_...">...</code></td>
<td>
<p>not used, included just for internal handling.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">2 \times 2</code> matrix with limits for the axis.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>

<hr>
<h2 id='SIC'>Spatial Interpolation Comparison data</h2><span id='topic+sic'></span><span id='topic+SIC'></span><span id='topic+sic.100'></span><span id='topic+sic.367'></span><span id='topic+sic.all'></span><span id='topic+sic.some'></span><span id='topic+sic.borders'></span>

<h3>Description</h3>

<p>Data from the SIC-97 project: Spatial Interpolation Comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SIC)</code></pre>


<h3>Format</h3>

<p>Four objects of the <code><a href="base.html#topic+class">class</a></code>  <code>"geodata"</code>:
<code>sic.all</code>, <code>sic.100</code>, <code>sic.367</code>, <code>sic.some</code>.
Each is a list with two components:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of the data locations. The
distance are given in kilometers.  </p>
</dd>
<dt><code>data</code></dt><dd><p>rainfall values. The unit is milimeters.  </p>
</dd>
<dt><code>altitude</code></dt><dd><p>elevation values. The unit is milimeters.  </p>
</dd>
</dl>

<p>Additionally an matrix <code>sic.borders</code> with the borders of the country.
</p>


<h3>Source</h3>

<p>Data from the project <em>Spatial Interpolation Comparison 97</em>;
see <a href="https://wiki.52north.org/bin/view/AI_GEOSTATS/EventsSIC97">https://wiki.52north.org/bin/view/AI_GEOSTATS/EventsSIC97</a>.
</p>


<h3>References</h3>

<p>Christensen, O.F., Diggle, P.J. and Ribeiro Jr, P.J. (2001)  Analysing positive-valued spatial data: the transformed Gaussian model.  In Monestiez, P., Allard, D. and Froidevaux (eds), GeoENV III - Geostatistics for environmental applications. Quantitative Geology and Geostatistics, Kluwer Series, 11, 287&ndash;298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points(sic.100, borders=sic.borders)
points(sic.all, borders=sic.borders)
</code></pre>

<hr>
<h2 id='soil250'>Soil chemistry properties data set</h2><span id='topic+soil250'></span>

<h3>Description</h3>

<p>Several soil chemistry properties measured on a regular grid with 10x25 points
spaced by 5 meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil250)</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 22 variables.
</p>

<dl>
<dt>Linha</dt><dd><p>x-coordinate</p>
</dd>
<dt>Coluna</dt><dd><p>y-coordinate</p>
</dd>
<dt>Cota</dt><dd><p>elevation</p>
</dd>
<dt>AGrossa</dt><dd><p>a numeric vecto, sand portion of the sample.</p>
</dd>
<dt>Silte</dt><dd><p>a numeric vector, silt portion of the sample.</p>
</dd>
<dt>Argila</dt><dd><p>a numeric vector, sand portion of the sample.</p>
</dd>
<dt>pHAgua</dt><dd><p>a numeric vector, soil pH at water </p>
</dd>
<dt>pHKCl</dt><dd><p>a numeric vector, soil pH by KCl </p>
</dd>
<dt>Ca</dt><dd><p>a numeric vector, calcium content </p>
</dd>
<dt>Mg</dt><dd><p>a numeric vector, magnesium content </p>
</dd>
<dt>K</dt><dd><p>a numeric vector, potassio content </p>
</dd>
<dt>Al</dt><dd><p>a numeric vector, aluminium content </p>
</dd>
<dt>H</dt><dd><p>a numeric vector, hidrogen content </p>
</dd>
<dt>C</dt><dd><p>a numeric vector, carbon content </p>
</dd>
<dt>N</dt><dd><p>a numeric vector, nitrogen content </p>
</dd>
<dt>CTC</dt><dd><p>a numeric vector, catium exchange capability </p>
</dd>
<dt>S</dt><dd><p>a numeric vector, enxofrar content </p>
</dd>
<dt>V</dt><dd><p>a numeric vector</p>
</dd>
<dt>M</dt><dd><p>a numeric vector</p>
</dd>
<dt>NC</dt><dd><p>a numeric vector</p>
</dd>
<dt>CEC</dt><dd><p>a numeric vector</p>
</dd>
<dt>CN</dt><dd><p>a numeric vector, carbon/nitrogen relation </p>
</dd>
</dl>



<h3>Details</h3>

<p>Uniformity trial with 250 undisturbed soil samples collected at 25cm
soil depth of spacing of 5 meters, resulting on a regular grid of
<code class="reqn">25 \times 10</code> points.
</p>
<p>See also the data-set <em>wrc</em> with other variables colected at the same points.
</p>


<h3>Source</h3>

<p>Bassoi thesis
</p>


<h3>References</h3>

<p>Bassoi papers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soil250)
ctc &lt;- as.geodata(soil250, data.col=16)
plot(ctc)
</code></pre>

<hr>
<h2 id='soja98'>Soya bean production and other variables in a uniformity trial</h2><span id='topic+soja98'></span>

<h3>Description</h3>

<p>Data on soya bean production in a uniformity trial measured at
plots of size 5x5 meters and other soil properties measured
in points given by the data coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soja98)</code></pre>


<h3>Format</h3>

<p>A data frame with 256 observations on the following 10 variables.
</p>

<dl>
<dt><code>X</code></dt><dd><p>a numeric vector with X-coordinates of the plot centres.  </p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector with X-coordinates of the plot centres.  </p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector, phosphorous content.  </p>
</dd>
<dt><code>PH</code></dt><dd><p>a numeric vector, soil pH.  </p>
</dd>
<dt><code>K</code></dt><dd><p>a numeric vector, potassium content. (Cmol/dm^3)  </p>
</dd>
<dt><code>MO</code></dt><dd><p>a numeric vector, organic matter. (percentage) </p>
</dd>
<dt><code>SB</code></dt><dd><p>a numeric vector, basis saturation.  </p>
</dd>
<dt><code>iCone</code></dt><dd><p>a numeric vector, cone index, measuring mechanic
resistence of the soil. (kg/cm^2)  </p>
</dd>
<dt><code>Rend</code></dt><dd><p>a numeric vector, total soya production within
the plot (kg). </p>
</dd>
<dt><code>PROD</code></dt><dd><p>a numeric vector, production converted to
productivity by a unit of area - hectare (ton/ha). </p>
</dd>
</dl>



<h3>Source</h3>

<p>Souza, E.G.; Jojann, J. A.; Rocha, J. V.; Ribeiro, S. R. A.; Silva, M. S., Upazo, M. A. U.; Molin, J. P.; Oliveira, E. F.; Nóbrega, L. H. P. (1999) Variabilidade espacial dos atributos químicos do solo em um latossolo roxo distrófico da região de Cascavel-PR. <em>Engenharia Agrícola</em>. Jaboticabal, volume 18, nr. 3, p.80-92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soja98)
plot(soja98)
require(geoR)
prod98 &lt;- as.geodata(soja98, coords.col=1:2, data.col=)
plot(prod98, low=TRUE)
</code></pre>

<hr>
<h2 id='statistics.predictive'>Summary statistics from predictive distributions</h2><span id='topic+statistics.predictive'></span>

<h3>Description</h3>

<p>Computes summaries based on simulations of predictive distribution
returned by
<code><a href="#topic+krige.bayes">krige.bayes</a></code> and <code><a href="#topic+krige.conv">krige.conv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statistics.predictive(simuls, mean.var = TRUE, quantile, threshold,
                      sim.means, sim.vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statistics.predictive_+3A_simuls">simuls</code></td>
<td>
<p>object with simulations from the predictive distribution</p>
</td></tr>
<tr><td><code id="statistics.predictive_+3A_mean.var">mean.var</code></td>
<td>
<p>Logical. Indicates whether or not to compute mean and variances
of the simulations at each location.  </p>
</td></tr>
<tr><td><code id="statistics.predictive_+3A_quantile">quantile</code></td>
<td>
<p>defines quantile estimator. See
documentation for <code><a href="#topic+output.control">output.control</a></code> .  </p>
</td></tr>
<tr><td><code id="statistics.predictive_+3A_threshold">threshold</code></td>
<td>
<p>defines probability estimator. See
documentation for <code><a href="#topic+output.control">output.control</a></code>.  </p>
</td></tr>
<tr><td><code id="statistics.predictive_+3A_sim.means">sim.means</code></td>
<td>
<p>Logical. Indicates whether or not to compute the mean
of of the conditional simulations.  </p>
</td></tr>
<tr><td><code id="statistics.predictive_+3A_sim.vars">sim.vars</code></td>
<td>
<p>Logical. Indicates whether or not to compute the variances
of the conditional simulations.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one ore more of the following components.
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>mean at each prediction location.  </p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>variance at each prediction location.  </p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>quantiles, at each prediction location.</p>
</td></tr>  
<tr><td><code>probabilities</code></td>
<td>
<p>probabilities, at each prediction location, of been below
the provided threshold.  </p>
</td></tr>
<tr><td><code>sim.means</code></td>
<td>
<p>vector with means of each conditional simulation.  </p>
</td></tr>
<tr><td><code>sim.vars</code></td>
<td>
<p>vector with variances of each conditional simulation.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>

<hr>
<h2 id='subarea'>Selects a Subarea from a Geodata Object</h2><span id='topic+subarea'></span>

<h3>Description</h3>

<p>Selects elements of a <code>geodata</code> object wich are within a
rectangular (sub)area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subarea(geodata, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subarea_+3A_geodata">geodata</code></td>
<td>
<p>an object of the class <code>geodata</code> as defined in <code><a href="#topic+as.geodata">as.geodata</a></code>.  </p>
</td></tr>
<tr><td><code id="subarea_+3A_xlim">xlim</code></td>
<td>
<p>optional, a vector with selected range of the x-coordinates. </p>
</td></tr>
<tr><td><code id="subarea_+3A_ylim">ylim</code></td>
<td>
<p>optional, a vector with selected range of the y-coordinates. </p>
</td></tr>
<tr><td><code id="subarea_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+zoom.coords">zoom.coords</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function copies the original <code>geodata</code> object and
selects values of <code>$coords</code>, <code>$data</code>, <code>$borders</code>,
<code>$covariate</code> and <code>$units.m</code> which lies within the selected
sub-area.
Remaining components of the geodata objects are untouched.
</p>
<p>If <code>xlim</code> and/or <code>ylim</code> are not provided the function
prompts the user to click 2 points defining an retangle defining the 
subarea on a existing plot.
</p>


<h3>Value</h3>

<p>Returns an <code>geodata</code> object, subsetting of the original one provided.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zoom.coords">zoom.coords</a></code>, <code><a href="graphics.html#topic+locator">locator</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- matrix(c(4,6,6,4,2,2,4,4), nc=2)
foo1 &lt;- zoom.coords(foo, 2)
foo1
foo2 &lt;- coords2coords(foo, c(6,10), c(6,10))
foo2
plot(1:10, 1:10, type="n")
polygon(foo)
polygon(foo1, lty=2)
polygon(foo2, lwd=2)
arrows(foo[,1], foo[,2],foo1[,1],foo1[,2], lty=2)
arrows(foo[,1], foo[,2],foo2[,1],foo2[,2])
legend("topleft", c("foo", "foo1 (zoom.coords)", "foo2 (coords2coords)"), 
       lty=c(1,2,1), lwd=c(1,1,2))

## "zooming" part of The Gambia map
gb &lt;- gambia.borders/1000
gd &lt;- gambia[,1:2]/1000
plot(gb, ty="l", asp=1, xlab="W-E (kilometres)", ylab="N-S (kilometres)")
points(gd, pch=19, cex=0.5)
r1b &lt;- gb[gb[,1] &lt; 420,]
rc1 &lt;- rect.coords(r1b, lty=2)

r1bn &lt;- zoom.coords(r1b, 1.8, xoff=90, yoff=-90)
rc2 &lt;- rect.coords(r1bn, xz=1.05)
segments(rc1[c(1,3),1],rc1[c(1,3),2],rc2[c(1,3),1],rc2[c(1,3),2], lty=3)

lines(r1bn)
r1d &lt;- gd[gd[,1] &lt; 420,]
r1dn &lt;- zoom.coords(r1d, 1.7, xlim.o=range(r1b[,1],na.rm=TRUE), ylim.o=range(r1b[,2], na.rm=TRUE), 
                    xoff=90, yoff=-90)
points(r1dn, pch=19, cex=0.5)
text(450,1340, "Western Region", cex=1.5)

#if(require(geoRglm)){
#data(rongelap)
#points(rongelap)
## zooming the western area
#rongwest &lt;- subarea(rongelap, xlim=c(-6300, -4800))
#points(rongwest)
## now zooming in the same plot
#points(rongelap)
#rongwest.z &lt;- zoom.coords(rongwest, xzoom=3, xoff=2000, yoff=3000)
#points(rongwest.z, add=TRUE)
#rect.coords(rongwest$sub, quiet=TRUE)
#rect.coords(rongwest.z$sub, quiet=TRUE)
#}
</code></pre>

<hr>
<h2 id='subset.geodata'>Method for subsetting geodata objects</h2><span id='topic+subset.geodata'></span>

<h3>Description</h3>

<p>Subsets a object of the class <code>geodata</code>
by transforming it to a data-frame, using <code>subset</code>
and back transforming to a <code>geodata</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
subset(x, ..., other = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.geodata_+3A_x">x</code></td>
<td>
<p>an object of the class <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="subset.geodata_+3A_...">...</code></td>
<td>
<p>arguments to be passed to
<code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>.  </p>
</td></tr>
<tr><td><code id="subset.geodata_+3A_other">other</code></td>
<td>
<p>logical. If <code>TRUE</code> non-standard
<code>geodata</code> elements
of the original <code>geodata</code> object are copied to the
resulting object.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list which is an object of the class <code>geodata</code>.  
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code> for the generic function and methods and
<code><a href="#topic+as.geodata">as.geodata</a></code> for more information on geodata objects.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>subset(ca20, data &gt; 70)
subset(ca20, area == 1)
</code></pre>

<hr>
<h2 id='summary.geodata'>Summaries for geodata object</h2><span id='topic+summary.geodata'></span><span id='topic+print.summary.geodata'></span>

<h3>Description</h3>

<p>Sumarises each of the main elements of an object of the class <code>geodata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geodata'
summary(object, lambda =1, add.to.data = 0,
                by.realisations=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.geodata_+3A_object">object</code></td>
<td>
<p>an object of the class <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="summary.geodata_+3A_lambda">lambda</code></td>
<td>
<p>value of the Box-Cox transformation parameter. Two particular cases
are <code class="reqn">\lambda = 1</code> which corresponds to no
transformation and  <code class="reqn">\lambda = 0</code> corresponding to
the log-transformation.  </p>
</td></tr>
<tr><td><code id="summary.geodata_+3A_add.to.data">add.to.data</code></td>
<td>
<p>scalar, Constant value to be added to the data
values.
Only used if a value different from 1 is passed to the argument <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="summary.geodata_+3A_by.realisations">by.realisations</code></td>
<td>
<p>logical. Indicates whether the summary must be performed separatly for each realisation, if the <code>geodata</code> object contains the element <code>realisations</code>. Defaults to <code>TRUE</code>.  </p>
</td></tr>
<tr><td><code id="summary.geodata_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function
<code><a href="base.html#topic+summary.default">summary.default</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>coords.summary</code></td>
<td>
<p>a matrix with minimum and maximum values for
the coordinates.  </p>
</td></tr>
<tr><td><code>distances.summary</code></td>
<td>
<p>minimum and maximum distances between pairs of points.  </p>
</td></tr>
<tr><td><code>borders.summary</code></td>
<td>
<p>a matrix with minimum and maximum values for
the coordinates. Only returned if there is an element <code>borders</code>
in the <code>geodata</code> object.  </p>
</td></tr>
<tr><td><code>data.summary</code></td>
<td>
<p>summary statistics (min, max, quartiles and mean)
for the data.  </p>
</td></tr>
<tr><td><code>units.m.summary</code></td>
<td>
<p>summary statistics (min, max, quartiles and mean)
for the offset variable. Only returned if there is an element <code>units.m</code>
in the <code>geodata</code> object. </p>
</td></tr>
<tr><td><code>covariate.summary</code></td>
<td>
<p>summary statistics (min, max, quartiles and mean)
for the covariate(s). Only returned if there is an element <code>covariate</code>
in the <code>geodata</code> object. </p>
</td></tr>
<tr><td><code>others</code></td>
<td>
<p>names of other elements if present in the <code>geodata</code> object.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+as.geodata">as.geodata</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(s100)

summary(ca20)
</code></pre>

<hr>
<h2 id='summary.likGRF'>Summarizes Parameter Estimation Results for Gaussian Random Fields</h2><span id='topic+summary.likGRF'></span><span id='topic+print.summary.likGRF'></span><span id='topic+print.likGRF'></span>

<h3>Description</h3>

<p>Summarizes results returned by the function <code><a href="#topic+likfit">likfit</a></code>.<br />
Functions are <em>methods</em> for <code><a href="base.html#topic+summary">summary</a></code> and
<code><a href="base.html#topic+print">print</a></code> for the classes <code>likGRF</code> and <code>summary.likGRF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'likGRF'
summary(object, ...)
## S3 method for class 'likGRF'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'summary.likGRF'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.likGRF_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> <em>likGRF</em>, typically
a result of a call to <code><a href="#topic+likfit">likfit</a></code>.  </p>
</td></tr>
<tr><td><code id="summary.likGRF_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> <em>likGRF</em> or
<code><a href="base.html#topic+class">class</a></code> <em>summary.likGRF</em>, typically
resulting from a call to <code><a href="#topic+likfit">likfit</a></code>.  </p>
</td></tr>
<tr><td><code id="summary.likGRF_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing. </p>
</td></tr>
<tr><td><code id="summary.likGRF_+3A_...">...</code></td>
<td>
<p>extra arguments for <code><a href="base.html#topic+print">print</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A detailed summary of a object of the class <code>likGRF</code> is produced by
by <code>summary.likGRF</code> and printed by <code>print.summary.likGRF</code>.
This includes model specification with values of fixed and estimated parameters. 
A simplified summary of the parameter estimation is printed by
<code>print.likGRF</code>. 
</p>


<h3>Value</h3>

<p><code>print.likGRF</code> prints the parameter estimates and the value of the
maximized likelihood.<br />
<code>summary.likGRF</code> returns a list with main results of a call to
<code><a href="#topic+likfit">likfit</a></code>.<br />
<code>print.summary.likGRF</code> prints these results on the screen (or other
output device) in a &quot;nice&quot; format.
</p>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likfit">likfit</a></code>, <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for the function likfit()
</code></pre>

<hr>
<h2 id='summary.variofit'>Summarize Results of Variogram Estimation</h2><span id='topic+summary.variofit'></span><span id='topic+print.summary.variofit'></span><span id='topic+print.variofit'></span>

<h3>Description</h3>

<p>This function prints a summary of the parameter estimation results given
by <code><a href="#topic+variofit">variofit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variofit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.variofit_+3A_object">object</code></td>
<td>
<p>an object of the class <code>"variomodel"</code>
typically an output of
<code><a href="#topic+variofit">variofit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.variofit_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="base.html#topic+print">print</a></code> or <code><a href="base.html#topic+summary">summary</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the estimation results on the screen or
other output device. 
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p>The functions <code><a href="#topic+variofit">variofit</a></code> for
variogram based estimation. For likelihood based parameter estimation see  <code><a href="#topic+likfit">likfit</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>s100.vario &lt;- variog(s100, max.dist=1)
wls &lt;- variofit(s100.vario, ini=c(.5, .5), fix.nugget = TRUE)
wls
summary(wls)
</code></pre>

<hr>
<h2 id='tce'>TCE concentrations in groundwater in a vertical cross section</h2><span id='topic+tce'></span>

<h3>Description</h3>

<p>Measurements at 56 locations of concentration of trichloroethylene
(TCE) in groundwater on a transect in a fine-sand superficial aquifer.
Extract from Kitanidis' book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tce)</code></pre>


<h3>Format</h3>

<p>An object of the class <code>geodata</code> which is a list with the elements:
</p>

<dl>
<dt>coords</dt><dd><p>coordinates of the data location (feet). </p>
</dd>
<dt>data</dt><dd><p>the data vector with measurements of the TCE
concentration (ppb). </p>
</dd>
</dl>



<h3>Source</h3>

<p>Kitanidis, P.K. Introduction to geostatistics - applications in
hidrology (1997). Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(tce)
summary(tce, lambda=0)
plot(tce)
points(tce)
points(tce, lambda=0)
</code></pre>

<hr>
<h2 id='trend.spatial'>Builds the Trend Matrix</h2><span id='topic+trend.spatial'></span>

<h3>Description</h3>

<p>Builds the <em>trend</em> matrix in accordance to a specification
of the mean provided by the user. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend.spatial(trend, geodata, add.to.trend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trend.spatial_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model.
See <code>DETAILS</code> below.  </p>
</td></tr>
<tr><td><code id="trend.spatial_+3A_geodata">geodata</code></td>
<td>
<p>optional. An object of the class <code>geodata</code> as described in
<code><a href="#topic+as.geodata">as.geodata</a></code>. </p>
</td></tr>
<tr><td><code id="trend.spatial_+3A_add.to.trend">add.to.trend</code></td>
<td>
<p>optional. Specifies aditional terms to the mean
part of the model. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implicity model assumes that there is an underlying process
with mean <code class="reqn">\mu(x)</code>, where <code class="reqn">x = (x_1, x_2)</code> denotes the coordinates
of a spatial location.
The argument <code>trend</code> defines the form of the mean and the
following options are allowed:
</p>

<dl>
<dt><code>"cte"</code></dt><dd><p>the mean is assumed to be constant over the region,
in which case <code class="reqn">\mu(x)= \mu</code>. This is the default
option.  </p>
</dd>
<dt><code>"1st"</code></dt><dd><p>the mean is assumed to be a first order polynomial
on the coordinates:
</p>
<p style="text-align: center;"><code class="reqn">\mu(x)= \beta_0 + \beta_1 x_1 + \beta_2 x_2</code>
</p>
</dd>
<dt><code>"2nd"</code></dt><dd><p>the mean is assumed to be a second order polynomial
on the coordinates:
</p>
<p style="text-align: center;"><code class="reqn">\mu(x)= \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \beta_3 (x_1)^2 +
	\beta_4 (x_2)^2 + \beta_5 x_1 *  x_2</code>
</p>
</dd>
<dt><code>~ model</code></dt><dd><p>a model specification. See
<code><a href="stats.html#topic+formula">formula</a></code> for further details on how to specify
a model in <span class="rlang"><b>R</b></span>  using formulas. Notice that the model term before
the <code>~</code> is not necessary.
Typically used to include covariates
(external trend) in the model.</p>
</dd>
</dl>

<p>Denote by <code class="reqn">x_1</code> and <code class="reqn">x_2</code> the spatial coordinates.
The following specifications are equivalent:
</p>

<ul>
<li> <p><code>trend = "1st"</code> and <code>trend = ~ x1 + x2</code>
</p>
</li>
<li> <p><code>trend = "2nd"</code> and <code>trend = ~ x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2)</code>
</p>
</li></ul>

<p><b>Search path for covariates</b><br />
Typically, functions in the package <span class="pkg">geoR</span> which calls
<code>trend.spatial</code> will have the arguments <code>geodata</code>,
<code>coords</code> and <code>data</code>. 
</p>
<p>When the trend is specifed as <code>trend = ~ model</code>
the terms included in the model will be searched for in the following
path sequence (modified in version 1.7-6, no longer attach objects):
</p>

<ol>
<li><p> in the object <code>geodata</code> (coerced to data-frame)
</p>
</li>
<li><p> in the users/session Global environment
</p>
</li>
<li><p> in the session search path
</p>
</li></ol>

<p>The argument <code>add.to.trend</code> adds terms to what is specified in
the argument <code>trend</code>. This seems redundant but allow
specifications of the type: <code>trend="2nd", add.trend=~other.covariates</code>.
</p>


<h3>Value</h3>

<p>An object of the class <code>trend.spatial</code>
which is an <code class="reqn">n \times p</code> <em>trend</em>
matrix, where <code class="reqn">n</code>
is the number of spatial
locations and <code class="reqn">p</code> is the number of mean parameters in the model. 
</p>


<h3>Note</h3>

<p>This is an auxiliary function typically called by
other <span class="pkg">geoR</span> functions.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p>The section <code>DETAILS</code> in the documentation for
<code><a href="#topic+likfit">likfit</a></code> for more about the underlying model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a first order polynomial trend
trend.spatial("1st", sic.100)[1:5,]
# a second order polynomial trend
trend.spatial("2nd", sic.100)[1:5,]
# a trend with a covariate
trend.spatial(~altitude, sic.100)[1:5,]
# a first degree trend plus a covariate
trend.spatial(~coords+altitude, sic.100)[1:5,]
# with produces the same as
trend.spatial("1st", sic.100, add=~altitude)[1:5,]
# and yet another exemple
trend.spatial("2nd", sic.100, add=~altitude)[1:5,]
</code></pre>

<hr>
<h2 id='varcov.spatial'>Computes Covariance Matrix and Related Results</h2><span id='topic+varcov.spatial'></span>

<h3>Description</h3>

<p>This function builds the covariance matrix for a set of spatial
locations, given the covariance parameters.
According to the input options  other results related to the covariance matrix
(such as decompositions, determinants, inverse. etc)
can also be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcov.spatial(coords = NULL, dists.lowertri = NULL,
               cov.model = "matern", kappa = 0.5, nugget = 0,
               cov.pars = stop("no cov.pars argument"), 
               inv = FALSE, det = FALSE,
               func.inv = c("cholesky", "eigen", "svd", "solve"),
               scaled = FALSE,  only.decomposition = FALSE,
               sqrt.inv = FALSE, try.another.decomposition = TRUE,
               only.inv.lower.diag = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov.spatial_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the coordinates
of the data locations. If not provided
the argument <code>dists.lowertri</code> should be provided instead.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_dists.lowertri">dists.lowertri</code></td>
<td>
<p>a vector with the lower triangle of the matrix
of distances between pairs of data points. If not provided
the argument <code>coords</code> should be provided instead.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_cov.model">cov.model</code></td>
<td>
<p>a string indicating the type of the correlation
function. More details in the
documentation for <code><a href="#topic+cov.spatial">cov.spatial</a></code>.
Defaults are equivalent to the <em>exponential</em> model.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_kappa">kappa</code></td>
<td>
<p>values of the additional smoothness parameter, only required by
the following correlation
functions: <code>"matern"</code>, <code>"powered.exponential"</code>, <code>"cauchy"</code> and
<code>"gneiting.matern"</code>.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_nugget">nugget</code></td>
<td>
<p>the value of the nugget parameter <code class="reqn">\tau^2</code>.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_cov.pars">cov.pars</code></td>
<td>
<p>a vector with 2 elements or an <code class="reqn">ns \times 2</code> matrix with
the covariance parameters. The first element (if a vector) or first
column (if a matrix) corresponds to the variance parameter <code class="reqn">\sigma^2</code>.
second element or column corresponds to the correlation function parameter
<code class="reqn">\phi</code>. If a matrix is provided each row corresponds to
the parameters of one <em>spatial structure</em>. Models with several structures
are also called <em>nested models</em> in the geostatistical
literature.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_inv">inv</code></td>
<td>
<p>if <code>TRUE</code> the inverse of covariance
matrix is returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_det">det</code></td>
<td>
<p>if <code>TRUE</code> the  logarithmic of the square root of the
determinant of the covariance
matrix is returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_func.inv">func.inv</code></td>
<td>
<p>algorithm used for the decomposition and inversion of the covariance
matrix. Options are <code>"chol"</code> for Cholesky decomposition,
<code>"svd"</code> for singular value decomposition and <code>"eigen"</code> for
eigenvalues/eigenvectors decomposition. Defaults to <code>"chol"</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_scaled">scaled</code></td>
<td>
<p>logical indicating whether the covariance matrix should
be scaled. If <code>TRUE</code> the partial sill
parameter <code class="reqn">\sigma^2</code> is set to 1. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_only.decomposition">only.decomposition</code></td>
<td>
<p>logical. If <code>TRUE</code> only the square root
of the covariance matrix is
returned. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_sqrt.inv">sqrt.inv</code></td>
<td>
<p>if <code>TRUE</code> the square root of the inverse of  covariance
matrix is returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_try.another.decomposition">try.another.decomposition</code></td>
<td>
<p>logical. If <code>TRUE</code> and the argument
<code>func.inv</code> is one of <code>"cholesky"</code>, <code>"svd"</code> or
<code>"solve"</code>, the matrix decomposition or inversion is tested and,
if it fails, the argument <code>func.inv</code> is re-set to <code>"eigen"</code>.  </p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_only.inv.lower.diag">only.inv.lower.diag</code></td>
<td>
<p>logical. If <code>TRUE</code> only the lower triangle and
the diagonal of the inverse of the covariance matrix are
returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="varcov.spatial_+3A_...">...</code></td>
<td>
<p>for naw, only for internal usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The elements of the covariance matrix are computed by the function
<code><a href="#topic+cov.spatial">cov.spatial</a></code>. Typically  this is an auxiliary function  called by other
functions in the <span class="pkg">geoR</span> package.
</p>


<h3>Value</h3>

<p>The result is always list. The components will vary according to the input
options. The possible components are:
</p>
<table>
<tr><td><code>varcov</code></td>
<td>
<p>the covariance matrix.  </p>
</td></tr>
<tr><td><code>sqrt.varcov</code></td>
<td>
<p>a square root of the covariance matrix.  </p>
</td></tr>
<tr><td><code>lower.inverse</code></td>
<td>
<p>the lower triangle of the inverse of covariance
matrix.  </p>
</td></tr>
<tr><td><code>diag.inverse</code></td>
<td>
<p>the diagonal of the inverse of covariance matrix.
</p>
</td></tr>
<tr><td><code>inverse</code></td>
<td>
<p>the inverse of covariance matrix.  </p>
</td></tr>
<tr><td><code>sqrt.inverse</code></td>
<td>
<p>a square root of the inverse of covariance
matrix.  </p>
</td></tr> 
<tr><td><code>log.det.to.half</code></td>
<td>
<p>the logarithmic of the square root of the
determinant of the covariance matrix.   </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.spatial">cov.spatial</a></code> for more information on the
correlation functions; <code><a href="base.html#topic+chol">chol</a></code>, <code><a href="base.html#topic+solve">solve</a></code>,
<code><a href="base.html#topic+svd">svd</a></code> and <code><a href="base.html#topic+eigen">eigen</a></code> for matrix inversion and/or decomposition.
</p>

<hr>
<h2 id='varcovBGCCM'>Covariance matrix for the bivariate Gaussian
common component geostatistical model</h2><span id='topic+varcovBGCCM'></span><span id='topic+.dist12'></span><span id='topic+.cov012.model'></span>

<h3>Description</h3>

<p>Covariance matrix for the bivariate Gaussian
common component geostatistical model or its inverse,
and optionally the determinant of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcovBGCCM(dists.obj, cov0.pars, cov1.pars, cov2.pars,
            cov0.model = "matern", cov1.model = "matern",
            cov2.model = "matern", kappa0 = 0.5, kappa1 = 0.5,
            kappa2 = 0.5, scaled = TRUE, inv = FALSE, det = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcovBGCCM_+3A_dists.obj">dists.obj</code></td>
<td>
<p>a vector with distance values </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov0.pars">cov0.pars</code></td>
<td>
<p>covarianve paremeter values for the common component </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov1.pars">cov1.pars</code></td>
<td>
<p>covariance parameter for the individual structure of
the first variable </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov2.pars">cov2.pars</code></td>
<td>
<p>covariance parameter for the individual structure of
the second variable </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov0.model">cov0.model</code></td>
<td>
<p>character indicating a valid correlation model </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov1.model">cov1.model</code></td>
<td>
<p>character indicating a valid correlation model </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_cov2.model">cov2.model</code></td>
<td>
<p>character indicating a valid correlation model </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_kappa0">kappa0</code></td>
<td>
<p>scalar </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_kappa1">kappa1</code></td>
<td>
<p>scalar </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_kappa2">kappa2</code></td>
<td>
<p>scalar </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_scaled">scaled</code></td>
<td>
<p>logical </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_inv">inv</code></td>
<td>
<p>logical. If <code>TRUE</code> the inverse of the covariance
matrix
is returned instead.  </p>
</td></tr>
<tr><td><code id="varcovBGCCM_+3A_det">det</code></td>
<td>
<p>logical. Optional, if <code>TRUE</code> the logarithm of the
detarminant of the covariance matrix is returned as an attribute.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which is the covariance matrix for the
bivariate Gaussian
common component geostatistical model or its inverse if
<code>inv=TRUE</code>.
If <code>det=T</code> the logarithm of the determinant
of the matrix is also returned as an attribute
named <code>logdetS</code>. 
</p>


<h3>Warning  </h3>

<p>This is a new function and still in draft format and pretty much untested.</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.spatial">cov.spatial</a></code>, <code><a href="#topic+varcov.spatial">varcov.spatial</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see http://www.leg.ufpr.br/geoR/tutorials/CCM.R
</code></pre>

<hr>
<h2 id='variofit'> Variogram Based Parameter Estimation </h2><span id='topic+variofit'></span><span id='topic+.loss.vario'></span>

<h3>Description</h3>

<p>Estimate covariance parameters by fitting a parametric model to a
empirical variogram. Variograms models can be fitted by using weighted or ordinary least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variofit(vario, ini.cov.pars, cov.model,
         fix.nugget = FALSE, nugget = 0,
         fix.kappa = TRUE, kappa = 0.5,
         simul.number = NULL, max.dist = vario$max.dist,
         weights, minimisation.function,
         limits = pars.limits(), messages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variofit_+3A_vario">vario</code></td>
<td>
<p>an object of the class <code>"variogram"</code>, typically an output of the function
<code><a href="#topic+variog">variog</a></code>. The object is a list with information about the
empirical variogram.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_ini.cov.pars">ini.cov.pars</code></td>
<td>
<p>initial values for the covariance parameters:
<code class="reqn">\sigma^2</code> (partial sill) and <code class="reqn">\phi</code> (range
parameter). See <code>DETAILS</code> below.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_cov.model">cov.model</code></td>
<td>
<p>a string with the name of the correlation
function. For further details see documentation for
<code><a href="#topic+cov.spatial">cov.spatial</a></code>. For the linear model use <code>cov.model
      = "linear"</code>. Read values from <code>variomodel</code> object passed <code>ini.cov.pars</code>,
otherwise default is the <em>exponential</em> model.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_fix.nugget">fix.nugget</code></td>
<td>
<p>logical, indicating whether the parameter
<code class="reqn">\tau^2</code> (nugget variance) should be regarded as fixed
(<code>fix.nugget = TRUE</code>) or should
be estimated (<code>fix.nugget = FALSE</code>). Defaults to
<code>FALSE</code>.  </p>
</td></tr>    
<tr><td><code id="variofit_+3A_nugget">nugget</code></td>
<td>
<p>value for the nugget parameter.  Regarded as a
fixed values if <code>fix.nugget = TRUE</code> or as a initial value for the
minimization algorithm if <code>fix.nugget = FALSE</code>. 
Defaults to zero.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_fix.kappa">fix.kappa</code></td>
<td>
<p>logical, indicating whether the parameter
<code class="reqn">\kappa</code> should be regarded as fixed or 
be estimated. Defaults to <code>TRUE</code>.  </p>
</td></tr>    
<tr><td><code id="variofit_+3A_kappa">kappa</code></td>
<td>
<p>value of the smoothness parameter.  Regarded as a
fixed values if <code>fix.kappa = TRUE</code> or as a initial value for the
minimization algorithm if <code>fix.kappa = FALSE</code>. Only required if
one of the following correlation functions is used: <code>"matern"</code>, <code>"powered.exponential"</code>, <code>"cauchy"</code>
and <code>"gneiting.matern"</code>. Defaults to <code class="reqn">0.5</code>.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_simul.number">simul.number</code></td>
<td>
<p>number of simulation. To be used when the object passed to the
argument <code>vario</code> has empirical variograms for more than one
data-set (or simulation). Indicates to which one the model will be
fitted.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum distance considered when fitting the
variogram. Defaults to <code>vario$max.dist</code>.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_weights">weights</code></td>
<td>
<p>type weights used in the loss function. See
<code>DETAILS</code> below.  </p>
</td></tr> 
<tr><td><code id="variofit_+3A_limits">limits</code></td>
<td>
<p>values defining lower and upper limits for the model
parameters used in the numerical minimisation.
Only valid if <code>minimisation.function = "optim"</code>.
The auxiliary function <code><a href="#topic+pars.limits">pars.limits</a></code> is called to set the limits.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_minimisation.function">minimisation.function</code></td>
<td>
<p>minimization function used to estimate
the parameters. Options are <code>"optim"</code>, <code>"nlm"</code>.
If <code>weights = "equal"</code> the option 
<code>"nls"</code> is also valid and det as default.
Otherwise defaults to <code>"optim"</code>.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates
whether or not status messages are printed on the screen (or other output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="variofit_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to the minimization
function. Typically arguments of the type <code>control()</code> which controls the
behavior of the minimization algorithm. See documentation for the 
selected minimization function for further details.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Numerical minimization</b>
</p>
<p>The parameter values are found by numerical optimization using one of
the functions: <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> and <code><a href="stats.html#topic+nls">nls</a></code>.
In given circunstances the algorithm may not converge to correct
parameter values when called with default options and the user may
need to pass extra options for the optimizers. For instance the
function <code>optim</code> takes a <code>control</code> argument.
The user should try different initial values and if the parameters have
different orders of magnitude may need to use options to scale the parameters.
Some possible workarounds in case of problems include:
</p>

<ul>
<li><p> rescale you data values (dividing by a constant, say)
</p>
</li>
<li><p> rescale your coordinates (subtracting values and/or dividing by constants)
</p>
</li>
<li><p> Use the  mechanism to pass <code>control()</code> options for the
optimiser internally
</p>
</li></ul>

<p><b>Initial values</b>
</p>
<p>The algorithms for minimization functions require initial values of
the parameters.
</p>
<p>A unique initial value is used if a vector is provided in the argument
<code>ini.cov.pars</code>. The elements are initial values for
<code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code>, respectively.
This vector is concatenated with the value of the
argument <code>nugget</code> if <code>fix.nugget = FALSE</code> and <code>kappa</code>
if <code>fix.kappa = TRUE</code>.
</p>
<p>Specification of multiple initial values is also possible.
If this is the case, the function
searches for the one which minimizes the loss function and uses this as
the initial value for the minimization algorithm.
Multiple initial values are specified  by providing a matrix in the
argument
<code>ini.cov.pars</code> and/or, vectors in the arguments 
<code>nugget</code> and <code>kappa</code> (if included in the estimation).
If <code>ini.cov.pars</code> is a matrix, the first column has values of
<code class="reqn">\sigma^2</code> and the second has values of  <code class="reqn">\phi</code>. 
</p>
<p>Alternatively the argument <code>ini.cov.pars</code> can take an object of
the class <code>eyefit</code> or <code>variomodel</code>. This allows the usage 
of an output of the functions <code><a href="#topic+eyefit">eyefit</a></code>, <code><a href="#topic+variofit">variofit</a></code> or
<code><a href="#topic+likfit">likfit</a></code> be used as initial value.
</p>
<p>If <code>minimisation.function = "nls"</code> only the values of
<code class="reqn">\phi</code> and <code class="reqn">\kappa</code> (if this is included in the
estimation) are used. Values for the remaning are not need by the algorithm.
</p>
<p>If <code>cov.model = "linear"</code> only the value of
<code class="reqn">\sigma^2</code> is used. Values for the
remaning are not need by this algorithm.
</p>
<p>If <code>cov.model = "pure.nugget"</code> no initial values are needed since
no minimisation function is used.
</p>
<p><b>Weights</b>
</p>
<p>The different options for the argument <code>weights</code>
are used to define the loss function to be minimised.
The available options are as follows.
</p>

<dl>
<dt><code>"npairs"</code></dt><dd><p>indicates that the weights are given by the
number of pairs in each bin.
This is the default option unless <code>variog$output.type ==
      "cloud"</code>.
The loss function is:
</p>
<p style="text-align: center;"><code class="reqn">LOSS(\theta) = \sum_k n_k [(\hat{\gamma}_k) -
	\gamma_k(\theta)]^2</code>
</p>

</dd>
<dt><code>"cressie"</code></dt><dd><p>weights as suggested by Cressie (1985).
</p>
<p style="text-align: center;"><code class="reqn">LOSS(\theta) = \sum_k n_k [\frac{\hat{\gamma}_k -
	  \gamma_k(\theta)}{\gamma_k(\theta)}]^2</code>
</p>

</dd>
<dt><code>"equal"</code></dt><dd><p>equal values for the weights. For this case
the estimation corresponds to the ordinary least squares variogram
fitting. This is the default option if <code>variog$output.type ==
      "cloud"</code>.
</p>
<p style="text-align: center;"><code class="reqn">LOSS(\theta) = \sum_k [(\hat{\gamma}_k) -
	\gamma_k(\theta)]^2</code>
</p>

</dd>
</dl>
<p>Where <code class="reqn">\theta</code> is the vector with the variogram parameters
and
for each <code class="reqn">k^{th}</code>-bin
<code class="reqn">n_k</code> is the number of
pairs, <code class="reqn">(\hat{\gamma}_k)</code> is the
value of the empirical variogram and
<code class="reqn">\gamma_k(\theta)</code>
is the value of the theoretical variogram.
</p>
<p>See also Cressie (1993) and Barry, Crowder and Diggle (1997) for further discussions on 
methods to estimate the variogram parameters.

</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>"variomodel"</code> and <code>"variofit"</code> which is list with the following components:
</p>
<table>
<tr><td><code>nugget</code></td>
<td>
<p>value of the nugget parameter. An estimated value if
<code>fix.nugget = FALSE</code> or a fixed value if <code>fix.nugget = TRUE</code>.  </p>
</td></tr>
<tr><td><code>cov.pars</code></td>
<td>
<p>a two elements vector with estimated values of the covariance
parameters <code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code>,  respectively.  </p>
</td></tr>
<tr><td><code>cov.model</code></td>
<td>
<p>a string with the name of the correlation function.  </p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>fixed value of the smoothness parameter.  </p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>minimized value of the loss function.  </p>
</td></tr>
<tr><td><code>max.dist</code></td>
<td>
<p>maximum distance considered in the variogram fitting.
</p>
</td></tr>
<tr><td><code>minimisation.function</code></td>
<td>
<p>minimization function used.  </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a string indicating the
type of weights used for the variogram fitting.  </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a string indicating the
type of variogram fitting method (OLS or WLS).  </p>
</td></tr>
<tr><td><code>fix.kappa</code></td>
<td>
<p>logical indicating whether the parameter <code class="reqn">\kappa</code> was
fixed.  </p>
</td></tr>
<tr><td><code>fix.nugget</code></td>
<td>
<p>logical indicating whether the nugget parameter was
fixed.  </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>transformation parameters inherith from the object
provided in the argument <code>vario</code>.  </p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>status messages returned by the function.  </p>
</td></tr>  
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Barry, J.T., Crowder, M.J. and Diggle, P.J. (1997) Parametric
estimation of the variogram. <em>Tech. Report, Dept Maths &amp; Stats,
Lancaster University</em>.
</p>
<p>Cressie, N.A.C (1985) <em>Mathematical Geology</em>. <b>17</b>, 563-586. 
</p>
<p>Cressie, N.A.C (1993) <em>Statistics for Spatial Data</em>. New York: Wiley.
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.spatial">cov.spatial</a></code> for a detailed description of the
available correlation (variogram) functions,
<code><a href="#topic+likfit">likfit</a></code> for maximum
and restricted maximum likelihood estimation,
<code><a href="#topic+lines.variomodel">lines.variomodel</a></code> for graphical output of the fitted
model. For details on the minimization functions see <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+nlm">nlm</a></code> and <code><a href="stats.html#topic+nls">nls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vario100 &lt;- variog(s100, max.dist=1)
ini.vals &lt;- expand.grid(seq(0,1,l=5), seq(0,1,l=5))
ols &lt;- variofit(vario100, ini=ini.vals, fix.nug=TRUE, wei="equal")
summary(ols)
wls &lt;- variofit(vario100, ini=ini.vals, fix.nug=TRUE)
summary(wls)
plot(vario100)
lines(wls)
lines(ols, lty=2)



</code></pre>

<hr>
<h2 id='variog'>Compute Empirical Variograms</h2><span id='topic+variog'></span><span id='topic+.rfm.bin'></span><span id='topic+.define.bins'></span>

<h3>Description</h3>

<p>Computes sample (empirical) variograms with options for  the <em>classical</em> or <em>robust</em>
estimators. Output can be returned as a <code>binned variogram</code>, a <code>
    variogram cloud</code> or a <code>smoothed variogram</code>. Data
transformation (Box-Cox) is allowed.
&ldquo;Trends&rdquo; can be specified and are fitted by ordinary least
squares in which case the variograms are computed using the
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog(geodata, coords = geodata$coords, data = geodata$data, 
       uvec = "default", breaks = "default",
       trend = "cte", lambda = 1,
       option = c("bin", "cloud", "smooth"),
       estimator.type = c("classical", "modulus"), 
       nugget.tolerance, max.dist, pairs.min = 2,
       bin.cloud = FALSE, direction = "omnidirectional", tolerance = pi/8,
       unit.angle = c("radians","degrees"), angles = FALSE, messages, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variog_+3A_geodata">geodata</code></td>
<td>
<p>a list containing element <code>coords</code>
as described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set.
If not provided the arguments
<code>coords</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="variog_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix containing
coordinates of the <code class="reqn">n</code> data locations in each row.
Defaults to <code>geodata$coords</code>, if provided.</p>
</td></tr>
<tr><td><code id="variog_+3A_data">data</code></td>
<td>
<p>a vector or matrix with data values.
If a matrix is provided, each column is regarded as one variable or realization.
Defaults to <code>geodata$data</code>, if provided.</p>
</td></tr>
<tr><td><code id="variog_+3A_uvec">uvec</code></td>
<td>
<p>a vector with values used to define the variogram binning. Only
used when <code>option = "bin"</code>.
See <code>DETAILS</code> below for more details on how to specify the bins.
</p>
</td></tr>
<tr><td><code id="variog_+3A_breaks">breaks</code></td>
<td>
<p>a vector with values to define the variogram binning. Only
used when <code>option = "bin"</code>.
See <code>DETAILS</code> below for more details on how to specify the bins.
</p>
</td></tr>
<tr><td><code id="variog_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model.
See documentation of <code><a href="#topic+trend.spatial">trend.spatial</a></code> for further details.
Defaults to <code>"cte"</code>.  </p>
</td></tr>
<tr><td><code id="variog_+3A_lambda">lambda</code></td>
<td>
<p>values of the Box-Cox transformation parameter.
Defaults to <code class="reqn">1</code> (no
transformation). If another value is provided the variogram is
computed after transforming the 
data. A case of particular interest is <code class="reqn">\lambda = 0</code>
which corresponds to log-transformation.  </p>
</td></tr>
<tr><td><code id="variog_+3A_option">option</code></td>
<td>
<p>defines the output type: the options <code>"bin"</code> returns values of
binned variogram, <code>"cloud"</code> returns the variogram cloud and
<code>"smooth"</code> returns the kernel smoothed variogram.
Defaults to <code>"bin"</code>.</p>
</td></tr>
<tr><td><code id="variog_+3A_estimator.type">estimator.type</code></td>
<td>
<p><code>"classical"</code> computes the classical method of
moments estimator.  <code>"modulus"</code> returns the variogram
estimator suggested by Hawkins and Cressie (see Cressie, 1993, pg 75).
Defaults to <code>"classical"</code>.  </p>
</td></tr>
<tr><td><code id="variog_+3A_nugget.tolerance">nugget.tolerance</code></td>
<td>
<p>a numeric value. Points which are separated
by a distance less than this value
are considered co-located. Defaults to zero.  </p>
</td></tr>
<tr><td><code id="variog_+3A_max.dist">max.dist</code></td>
<td>
<p>a numerical value defining the maximum distance for
the variogram. Pairs of locations
separated for distance larger than this value are ignored for the
variogram calculation. If not provided defaults takes the maximum
distance among all pairs of data locations.  </p>
</td></tr>
<tr><td><code id="variog_+3A_pairs.min">pairs.min</code></td>
<td>
<p>a integer number defining the minimum numbers of
pairs for the bins.
For <code>option = "bin"</code>,
bins with number of pairs smaller than this
value are ignored. Defaults to <code>NULL</code>.  </p>
</td></tr>
<tr><td><code id="variog_+3A_bin.cloud">bin.cloud</code></td>
<td>
<p>logical. If <code>TRUE</code> and
<code>option = "bin"</code> the cloud values for each class are
included in the output. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="variog_+3A_direction">direction</code></td>
<td>
<p>a numerical value for the directional (azimuth) angle. This
used to specify directional variograms. Default defines the
omnidirectional variogram. The value must be in the interval
<code class="reqn">[0, \pi]</code> radians (<code class="reqn">[0, 180]</code> degrees).  </p>
</td></tr>
<tr><td><code id="variog_+3A_tolerance">tolerance</code></td>
<td>
<p>numerical value for the tolerance angle, when
computing directional variograms. The value must be in the interval
<code class="reqn">[0, \pi/2]</code> radians (<code class="reqn">[0, 90]</code> degrees).  Defaults to <code class="reqn">\pi/8</code>.  </p>
</td></tr>
<tr><td><code id="variog_+3A_unit.angle">unit.angle</code></td>
<td>
<p>defines the unit for the specification of angles in
the two previous arguments. Options are <code>"radians"</code> and
<code>"degrees"</code>, with default to <code>"radians"</code>. </p>
</td></tr>
<tr><td><code id="variog_+3A_angles">angles</code></td>
<td>
<p>Logical with default to <code>FALSE</code>. If <code>TRUE</code> the
function also returns the angles between the pairs of points
(unimplemented). </p>
</td></tr>
<tr><td><code id="variog_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates whether
status messages should be printed on the screen (or output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="variog_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function <code><a href="stats.html#topic+ksmooth">ksmooth</a></code>, if
<code>option = "smooth"</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variograms are widely used in geostatistical analysis for exploratory
purposes, to estimate covariance parameters and/or to compare theoretical
and fitted models against sample variograms.
</p>
<p><b>Estimators</b><br />
The two estimators currently implemented are:
</p>

<ul>
<li> <p><em>classical</em> (method of moments) estimator:
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = \frac{1}{2N_h} \sum_{i=1}^{N_h}[Y(x_{i+h}) -
      Y(x_i)]^2</code>
</p>

</li>
<li><p> Hawkins and Cressie's <em>modulus</em> estimator
</p>
<p style="text-align: center;"><code class="reqn">\gamma(h) = \frac{[\frac{1}{N_h}\sum_{i=1}^{N_h}|Y(x_{i+h}) -
	Y(x_i)|^{\frac{1}{2}}]^4}{0.914 + \frac{0.988}{N_h}}</code>
</p>

</li></ul>

<p><b>Defining the bins</b>
</p>
<p><em>The defaults</em><br />
If arguments <code>breaks</code> and <code>uvec</code> are not provided, the
binning is defined as follows:<br />
</p>

<ol>
<li><p> read the argument <code>max.dist</code>. If not provided it is set
to the maximum distance between the pairs of points.
</p>
</li>
<li><p> the center of the bins are initially defined by the sequence <code>u = seq(0,
      max.dist, l = 13)</code>.
</p>
</li>
<li><p> the interval spanned by each bin is given by the mid-points
between the centers of the bins.
</p>
</li></ol>

<p>If an vector is passed to the argument <code>breaks</code> its elements are
taken as the limits of the bins (classes of distance) and the argument <code>uvec</code> is ignored.
</p>
<p><em>Variations on the default</em><br />
The default definition of the bins is different for some particular
cases.
</p>

<ol>
<li><p> if there are  coincident data locations
the bins follows the default above but
one more bin is added at the origin (distance zero) for
the collocated points.
</p>
</li>
<li><p> if the argument <code>nugget.tolerance</code> is provided the
separation distance between all pairs
in the interval <code class="reqn">[0, nugget.tolerance]</code> are set to zero.
The first bin distance is set to zero (<code>u[1] = 0</code>).
The remaining bins follows the default.
</p>
</li>
<li><p> if a scalar is provided to the argument <code>uvec</code> the
default number of bins is defined by this number.
</p>
</li>
<li><p> if a vector is provided to the argument <code>uvec</code>,
its elements are taken as central points of the bins.
</p>
</li></ol>







<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>variogram</code> which is a
list with the following components:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>a vector with distances.  </p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>a vector with estimated variogram values at distances given
in <code>u</code>.  </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of pairs in each bin, if
<code>option = "bin"</code>.  </p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>standard deviation of the values in each bin.  </p>
</td></tr>
<tr><td><code>bins.lim</code></td>
<td>
<p>limits defining the interval spanned by each bin.  </p>
</td></tr>
<tr><td><code>ind.bin</code></td>
<td>
<p>a logical vector indicating whether the number of
pairs in each bin is greater or equal to the value in the argument
<code>pairs.min</code>.  </p>
</td></tr>
<tr><td><code>var.mark</code></td>
<td>
<p>variance of the data.  </p>
</td></tr>
<tr><td><code>beta.ols</code></td>
<td>
<p>parameters of the mean part of the model fitted by
ordinary least squares.  </p>
</td></tr>
<tr><td><code>output.type</code></td>
<td>
<p>echoes the <code>option</code> argument.  </p>
</td></tr>
<tr><td><code>max.dist</code></td>
<td>
<p>maximum distance between pairs allowed in the
variogram calculations.</p>
</td></tr>
<tr><td><code>estimator.type</code></td>
<td>
<p>echoes the type of estimator used.  </p>
</td></tr>
<tr><td><code>n.data</code></td>
<td>
<p>number of data.  </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>value of the transformation parameter.  </p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>trend specification.  </p>
</td></tr>
<tr><td><code>nugget.tolerance</code></td>
<td>
<p>value of the nugget tolerance argument.  </p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>direction for which the variogram was computed.  </p>
</td></tr>
<tr><td><code>tolerance</code></td>
<td>
<p>tolerance angle for directional variogram.  </p>
</td></tr>
<tr><td><code>uvec</code></td>
<td>
<p>lags provided in the function call.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Cressie, N.A.C (1993) <em>Statistics for Spatial Data</em>. New York: Wiley.
</p>
<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog4">variog4</a></code> for more on computation of
directional variograms, 
<code><a href="#topic+variog.model.env">variog.model.env</a></code> and <code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for
variogram envelopes,
<code><a href="#topic+variofit">variofit</a></code>  for variogram based
parameter estimation and
<code><a href="#topic+plot.variogram">plot.variogram</a></code> for graphical output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# computing variograms:
#
# binned variogram
vario.b &lt;- variog(s100, max.dist=1)
# variogram cloud
vario.c &lt;- variog(s100, max.dist=1, op="cloud")
#binned variogram and stores the cloud
vario.bc &lt;- variog(s100, max.dist=1, bin.cloud=TRUE)
# smoothed variogram
vario.s &lt;- variog(s100, max.dist=1, op="sm", band=0.2)
#
#
# plotting the variograms:
par(mfrow=c(2,2))
plot(vario.b, main="binned variogram") 
plot(vario.c, main="variogram cloud")
plot(vario.bc, bin.cloud=TRUE, main="clouds for binned variogram")  
plot(vario.s, main="smoothed variogram") 

# computing a directional variogram
vario.0 &lt;- variog(s100, max.dist=1, dir=0, tol=pi/8)
plot(vario.b, type="l", lty=2)
lines(vario.0)
legend("topleft", legend=c("omnidirectional", expression(0 * degree)), lty=c(2,1))
</code></pre>

<hr>
<h2 id='variog.mc.env'>Envelops for Empirical Variograms Based on Permutation</h2><span id='topic+variog.mc.env'></span>

<h3>Description</h3>

<p>Computes envelops for empirical variograms by
permutation of the data values on the spatial locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog.mc.env(geodata, coords = geodata$coords, data = geodata$data,
              obj.variog, nsim = 99, save.sim = FALSE, messages) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variog.mc.env_+3A_geodata">geodata</code></td>
<td>
<p>a list containing elements <code>coords</code> and
<code>data</code> as described next. 
Typically an object of the class <code>"geodata"</code> - a <span class="pkg">geoR</span>
data-set.
If not provided the arguments
<code>coords</code> and <code>data</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix, each row containing Euclidean
coordinates of the <em>n</em> data locations. By default it takes the
element <code>coords</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_data">data</code></td>
<td>
<p>a vector with the data values. By default it takes the
element <code>data</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_obj.variog">obj.variog</code></td>
<td>
<p>an object of the class <code>"variogram"</code>, typically
an output of the function <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used to compute the envelope. Defaults to
99.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_save.sim">save.sim</code></td>
<td>
<p>logical. Indicates whether or not the simulated data
are included in the output. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="variog.mc.env_+3A_messages">messages</code></td>
<td>
<p>logical. If <code>TRUE</code>, the default, status messages
are printed while the function is running.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The envelops are obtained by permutation.
For each simulations data values are randomly allocated to the spatial locations.
The empirical variogram is computed for each simulation
using the same lags as for the variogram originally computed for the data.
The envelops are computed by taking, at each lag, the maximum and minimum
values of the variograms for the simulated data.
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>"variogram.envelope"</code> which is a
list with the following components:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>a vector with distances. </p>
</td></tr>
<tr><td><code>v.lower</code></td>
<td>
<p>a vector with the minimum variogram values at each
distance in <code>u</code>.  </p>
</td></tr>
<tr><td><code>v.upper</code></td>
<td>
<p>a vector with the maximum variogram values at each
distance in <code>u</code>.  </p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>
<p>a matrix with simulated data.
Only returned if <code>save.sim = TRUE</code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog.model.env">variog.model.env</a></code> for envelops computed by
from a model specification, 
<code><a href="#topic+variog">variog</a></code> for variogram calculations,
<code><a href="#topic+plot.variogram">plot.variogram</a></code> and <code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for
graphical output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s100.vario &lt;- variog(s100, max.dist=1)
s100.env &lt;- variog.mc.env(s100, obj.var = s100.vario)
plot(s100.vario, envelope = s100.env)
</code></pre>

<hr>
<h2 id='variog.model.env'>Envelops for Empirical Variograms Based on Model Parameters</h2><span id='topic+variog.model.env'></span><span id='topic+boot.variofit'></span>

<h3>Description</h3>

<p>Computes envelopes for a empirical variogram by simulating
data for given model parameters.
</p>
<p>Computes bootstrap paremeter estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog.model.env(geodata, coords = geodata$coords, obj.variog,
                 model.pars, nsim = 99, save.sim = FALSE, messages)

boot.variofit(geodata, coords = geodata$coords, obj.variog,
              model.pars, nsim = 99, trace = FALSE, messages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variog.model.env_+3A_geodata">geodata</code></td>
<td>
<p>a list containing element <code>coords</code>
as described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set.
If not provided the argument
<code>coords</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix, each row containing
Euclidean 
coordinates of the <em>n</em> data locations. By default it takes the
element <code>coords</code> of the argument <code>geodata</code>.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_obj.variog">obj.variog</code></td>
<td>
<p>an object of the class <code>"variogram"</code>, typically
an output of the function <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_model.pars">model.pars</code></td>
<td>
<p>a list with model specification and parameter
values. The input is typically an object of the class
<code>variomodel</code> which is an output of <code><a href="#topic+likfit">likfit</a></code>,
<code><a href="#topic+variofit">variofit</a></code>.
The required components of the list are:
</p>

<ul>
<li> <p><code>beta</code>, the mean parameter. Defaults to zero.
</p>
</li>
<li> <p><code>cov.model</code>, the covariance model. Defaults to
&quot;exponential&quot;.
</p>
</li>
<li> <p><code>cov.pars</code>, the covariance parameters
<code class="reqn">\sigma^2</code> and <code class="reqn">\phi</code>.
</p>
</li>
<li> <p><code>kappa</code>, the extra covariance parameters for some of the
covariance models. Defaults to <code class="reqn">0.5</code>.
</p>
</li>
<li> <p><code>nugget</code>, the error component variance. Defaults to zero.
</p>
</li>
<li> <p><code>estimator.type</code>, the type of variogram
estimator. Options for <code>"classical"</code> and
<code>"robust"</code>. Defaults to <code>obj.variog$estimator</code>.  </p>
</li></ul>

</td></tr> 
<tr><td><code id="variog.model.env_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used to compute the envelopes.
Defaults to 99.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_save.sim">save.sim</code></td>
<td>
<p>logical. Indicates whether or not the simulated data
are included in the output. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_trace">trace</code></td>
<td>
<p>logical. If <code>TRUE</code> the fitted values for the
bootstrap parameter estimation are printend while the function is
running.  </p>
</td></tr>
<tr><td><code id="variog.model.env_+3A_messages">messages</code></td>
<td>
<p>logical. If <code>TRUE</code>, the default, status messages
are printed while the function is running.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The envelopes are computed assuming a (transformed) Gaussian random
field model.
Simulated values are generated at the data locations, given the model parameters.
The empirical variogram is computed for each simulation
using the same lags as for the original variogram of the data.
The envelopes are computed by taking, at each lag, the maximum and minimum
values of the variograms for the simulated data.
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>"variogram.envelope"</code> which is a
list with the components:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>a vector with distances. </p>
</td></tr>
<tr><td><code>v.lower</code></td>
<td>
<p>a vector with the minimum variogram values at each
distance in <code>u</code>.  </p>
</td></tr>
<tr><td><code>v.upper</code></td>
<td>
<p>a vector with the maximum variogram values at each
distance in <code>u</code>.  </p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>
<p>a matrix with the simulated data.
Only returned if <code>save.sim = TRUE</code>.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>,  <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for envelops computed by
using data permutation, 
<code><a href="#topic+variog">variog</a></code> for variogram calculations,
<code><a href="#topic+plot.variogram">plot.variogram</a></code> and <code><a href="#topic+variog.mc.env">variog.mc.env</a></code> for
graphical output. The functions
<code><a href="#topic+likfit">likfit</a></code>, <code><a href="#topic+variofit">variofit</a></code>
are used to estimate the model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s100.ml &lt;- likfit(s100, ini = c(0.5, 0.5), fix.nugget = TRUE)
s100.vario &lt;- variog(s100, max.dist = 1)
s100.env &lt;- variog.model.env(s100, obj.v = s100.vario,
                             model.pars = s100.ml)
plot(s100.vario, env = s100.env)
</code></pre>

<hr>
<h2 id='variog4'>Computes Directional Variograms</h2><span id='topic+variog4'></span>

<h3>Description</h3>

<p>Computes directional variograms for 4 directions provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog4(geodata, coords = geodata$coords, data = geodata$data, 
        uvec = "default", breaks = "default", trend = "cte", lambda = 1,
        option = c("bin", "cloud", "smooth"),
        estimator.type = c("classical", "modulus"), 
        nugget.tolerance, max.dist, pairs.min = 2,
        bin.cloud = FALSE, direction = c(0, pi/4, pi/2, 3*pi/4), tolerance = pi/8,
        unit.angle = c("radians", "degrees"), messages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variog4_+3A_geodata">geodata</code></td>
<td>
<p>a list containing element <code>coords</code>
as described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set.
If not provided the arguments
<code>coords</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix containing
coordinates of the <code class="reqn">n</code> data locations in each row.
Defaults to <code>geodata$coords</code>, if provided.</p>
</td></tr>
<tr><td><code id="variog4_+3A_data">data</code></td>
<td>
<p>a vector or matrix with data values.
If a matrix is provided, each column is regarded as one variable or realization.
Defaults to <code>geodata$data</code>, if provided.</p>
</td></tr>
<tr><td><code id="variog4_+3A_uvec">uvec</code></td>
<td>
<p>a vector with values to define the variogram binning. For
further details see documentation for <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr> 
<tr><td><code id="variog4_+3A_breaks">breaks</code></td>
<td>
<p>a vector with values to define the variogram binning. For
further details see documentation for <code><a href="#topic+variog">variog</a></code>.  </p>
</td></tr> 
<tr><td><code id="variog4_+3A_trend">trend</code></td>
<td>
<p>specifies the mean part of the model.
The options are:
<code>"cte"</code> (constant mean),
<code>"1st"</code> (a first order polynomial
on the coordinates), <code>"2nd"</code> (a second order polynomial
on the coordinates), or a formula of the type <code>~X</code> where <code>X</code>
is a matrix with the covariates (external trend). Defaults to <code>"cte"</code>.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_lambda">lambda</code></td>
<td>
<p>values of the Box-Cox transformation parameter.
Defaults to <code class="reqn">1</code> (no
transformation). If another value is provided the variogram is
computed after transforming the 
data. A case of particular interest is <code class="reqn">\lambda = 0</code>
which corresponds to log-transformation.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_option">option</code></td>
<td>
<p>defines the output type: the options <code>"bin"</code> returns values of
binned variogram, <code>"cloud"</code> returns the variogram cloud and
<code>"smooth"</code> returns the kernel smoothed variogram.
Defaults to <code>"bin"</code>.</p>
</td></tr>
<tr><td><code id="variog4_+3A_estimator.type">estimator.type</code></td>
<td>
<p><code>"classical"</code> computes the classical method of
moments estimator.  <code>"modulus"</code> returns the variogram
estimator suggested by Hawkins and Cressie (see Cressie, 1993, pg 75).
Defaults to <code>"classical"</code>.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_nugget.tolerance">nugget.tolerance</code></td>
<td>
<p>a numeric value. Points which are separated
by a distance less than this value
are considered co-located. Defaults to zero.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_max.dist">max.dist</code></td>
<td>
<p>a numerical value defining the maximum distance for
the variogram. Pairs of locations
separated for distance larger than this value are ignored for the
variogram calculation. Defaults to the maximum distance among the pairs
of data locations.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_pairs.min">pairs.min</code></td>
<td>
<p>a integer number defining the minimum numbers of
pairs for the bins.
For <code>option = "bin"</code>,
bins with number of pairs smaller than this
value are ignored. Defaults to <code>NULL</code>.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_bin.cloud">bin.cloud</code></td>
<td>
<p>logical. If <code>TRUE</code> and
<code>option = "bin"</code> the cloud values for each class are
included in the output. Defaults to <code>FALSE</code>.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_direction">direction</code></td>
<td>
<p>a vector with values of 4 angles, indicating the
directions for which the variograms will be computed. Default
corresponds to <code>c(0, 45, 90, 135)</code> (degrees). </p>
</td></tr>
<tr><td><code id="variog4_+3A_tolerance">tolerance</code></td>
<td>
<p>numerical value for the tolerance angle, when
computing directional variograms. The value must be in the interval
<code class="reqn">[0, 90]</code> degrees.  Defaults to <code class="reqn">\pi/8</code>.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_unit.angle">unit.angle</code></td>
<td>
<p>defines the unit for the specification of angles in
the two previous arguments. Options are <code>"degrees"</code> and <code>"radians"</code>. </p>
</td></tr>
<tr><td><code id="variog4_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates whether
status messages should be printed on the screen (or output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="variog4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function <code><a href="stats.html#topic+ksmooth">ksmooth</a></code>, if
<code>option = "smooth"</code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is an object of the class <code>variog4</code>,
a list with five components.
The first four elements are estimated variograms for the directions
provided and the last is the omnidirectional variogram. 
Each individual component is an object of the class <code>variogram</code>,
an output of the function <code><a href="#topic+variog">variog</a></code>.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog">variog</a></code> for variogram calculations and
<code><a href="#topic+plot.variog4">plot.variog4</a></code> for plotting results</p>


<h3>Examples</h3>

<pre><code class='language-R'>var4 &lt;- variog4(s100, max.dist=1)
plot(var4)
</code></pre>

<hr>
<h2 id='wo'>Kriging example data from Webster and Oliver</h2><span id='topic+wo'></span>

<h3>Description</h3>

<p>Data used in Chapter 8,
page 156 of Webster and Oliver (2001) to illustrate
properties of the kriging predictor.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wo)</code></pre>


<h3>Format</h3>

<p>An object of the class <code>geodata</code> which is a list with the elements:
</p>

<dl>
<dt>coords</dt><dd><p>coordinates of the data location. </p>
</dd>
<dt>data</dt><dd><p>the data vector. </p>
</dd>
<dt>x1</dt><dd><p>coordinate of the centrally located prediction point. </p>
</dd>
<dt>x2</dt><dd><p>coordinate of the off-centre prediction point. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Webster, R. and Oliver, M.A. (2001). Geostatistics for Environmental
Scientists. Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>attach(wo)
par(mfrow=c(1,2))
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x1))
text(coords[,1], 5+coords[,2], format(data))
text(x1[1]+5, x1[2]+5, "?", col=2)
plot(c(-10,130), c(-10,130), ty="n", asp=1)
points(rbind(coords, x2))
text(coords[,1], 5+coords[,2], format(data))
text(x2[1]+5, x2[2]+5, "?", col=2)
</code></pre>

<hr>
<h2 id='wolfcamp'>Wolfcamp Aquifer Data</h2><span id='topic+wolfcamp'></span><span id='topic+wolf'></span>

<h3>Description</h3>

<p>Piezometric head measurements taken at the Wolfcamp Aquifer, Texas,
USA.
See Cressie (1993, p.212&ndash;214) for description of the scientific
problem and the data.
Original data were converted to SI units: coordinates are given in
kilometers and pressure heads to meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wolfcamp)</code></pre>


<h3>Format</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code>  <code>"geodata"</code>, which is list with two components:
</p>

<dl>
<dt><code>coords</code></dt><dd><p>the coordinates of the data locations. The
distance are given in kilometers.  </p>
</dd>
<dt><code>data</code></dt><dd><p>values of the piezometric head. The unit is heads
to meters.  </p>
</dd>
</dl>



<h3>Source</h3>

<p>Harper, W.V and Furr, J.M. (1986) Geostatistical analysis of
potentiometric data in the Wolfcamp Aquifer of the Palo Duro Basin,
Texas. <em>Technical Report BMI/ONWI-587, Bettelle Memorial Institute,
Columbus, OH</em>.   
</p>


<h3>References</h3>

<p>Cressie, N.A.C (1993) <em>Statistics for Spatial Data</em>. New York: Wiley.
</p>
<p>Papritz, A. and Moyeed, R. (2001) Parameter uncertainty in spatial
prediction: checking its importance by cross-validating the Wolfcamp
and Rongelap data sets. <em>GeoENV 2000: Geostatistical for
Environmental Applications. Ed. P. Monestiez, D. Allard,
R. Froidevaux</em>. Kluwer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(wolfcamp)
plot(wolfcamp)
</code></pre>

<hr>
<h2 id='wrappers'>Wrappers for the C functions used in geoR</h2><span id='topic+wrappers'></span><span id='topic+diffpairs'></span><span id='topic+loccoords'></span><span id='topic+.diagquadraticformXAX'></span><span id='topic+.bilinearformXAY'></span><span id='topic+.corr.diaglowertri'></span><span id='topic+.Ccor.spatial'></span>

<h3>Description</h3>

<p>These functions are <em>wrappers</em> for some (but not all)
the C functions
included in the <span class="pkg">geoR</span> package.<br />
Typically the C code is directly  called from the <span class="pkg">geoR</span>
functions but these functions allows independent calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffpairs(coords, data)
loccoords(coords, locations)
.diagquadraticformXAX(X, lowerA, diagA) 
.bilinearformXAY(X, lowerA, diagA, Y) 
.corr.diaglowertri(coords, cov.model, phi, kappa)
.Ccor.spatial(x, phi, kappa, cov.model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrappers_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix with the data
coordinates.  </p>
</td></tr>
<tr><td><code id="wrappers_+3A_data">data</code></td>
<td>
<p>an vector with the data values.  </p>
</td></tr>
<tr><td><code id="wrappers_+3A_locations">locations</code></td>
<td>
<p>an <code class="reqn">N \times 2</code> matrix with the
coordinates of the prediction locations. </p>
</td></tr>
<tr><td><code id="wrappers_+3A_lowera">lowerA</code></td>
<td>
<p>a vector with the diagonal terms of the symmetric matrix 
A. </p>
</td></tr>
<tr><td><code id="wrappers_+3A_diaga">diagA</code></td>
<td>
<p>a vector with the diagonal terms of the symmetric matrix A. </p>
</td></tr>
<tr><td><code id="wrappers_+3A_x">X</code></td>
<td>
<p>a matrix with conforming dimensions. </p>
</td></tr>
<tr><td><code id="wrappers_+3A_y">Y</code></td>
<td>
<p>a matrix with conforming dimensions. </p>
</td></tr>
<tr><td><code id="wrappers_+3A_cov.model">cov.model</code></td>
<td>
<p>covariance model, see <code><a href="#topic+cov.spatial">cov.spatial</a></code> for options and
more details.  </p>
</td></tr>
<tr><td><code id="wrappers_+3A_phi">phi</code></td>
<td>
<p>numerical value of the correlation function parameter phi.</p>
</td></tr>
<tr><td><code id="wrappers_+3A_kappa">kappa</code></td>
<td>
<p>numerical value of the correlation function parameter
kappa.</p>
</td></tr>
<tr><td><code id="wrappers_+3A_x">x</code></td>
<td>
<p>a vector of distances.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The outputs for the different functions are: 
</p>
<table>
<tr><td><code>diffpairs</code></td>
<td>
<p>returns a list with elements <code>dist</code> - the
distance between pairs of points, and <code>diff</code> - the difference
between the values of the attributes.  </p>
</td></tr>
<tr><td><code>loccoords</code></td>
<td>
<p>returns a <code class="reqn">n \times N</code>  matrix with distances
between data points and prediction locations.  </p>
</td></tr>


<tr><td><code>diagquadraticformXAX</code></td>
<td>
<p>returns a vector with the diagonal term of the
quadratic form <code class="reqn">X' A X</code>.  </p>
</td></tr>
<tr><td><code>bilinearformXAY</code></td>
<td>
<p>returns a vector or a matrix with the terms of the
quadratic form <code class="reqn">X' A Y</code>.  </p>
</td></tr>
<tr><td><code>corr.diaglowertri</code></td>
<td>
<p>returns the lower triangle of the
correlation matrix, including the diagonal.  </p>
</td></tr>
<tr><td><code>Ccor.spatial</code></td>
<td>
<p>returns a vector of values of spatial
correlations.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paulo Justiniano Ribeiro Jr. <a href="mailto:paulojus@leg.ufpr.br">paulojus@leg.ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>

<hr>
<h2 id='wrc'>Points of a water retention curve data set</h2><span id='topic+wrc'></span>

<h3>Description</h3>

<p>Soil density and measures of the water retention curve obtained at
different pressures on a regular grid with 10x25 points
spaced by 5 meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wrc)</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 11 variables.
</p>

<dl>
<dt><code>CoordX</code></dt><dd><p>a numeric vector with the X coordinates of the
samples. </p>
</dd>
<dt><code>CoordY</code></dt><dd><p>a numeric vector with the Y coordinate of the
samples. </p>
</dd>
<dt><code>Densidade</code></dt><dd><p>a numeric vector, soil density <code class="reqn">(g/cm^3)</code></p>
</dd>
<dt><code>Pr5</code></dt><dd><p>a numeric vector, water content at a pressure of 5
mca &ndash; <code class="reqn">5 \times 10^2</code> Pa (atm)</p>
</dd>
<dt><code>Pr10</code></dt><dd><p>a numeric vector, water content at a pressure of
10 mca &ndash; <code class="reqn">1 \times 10^3</code> Pa (atm)</p>
</dd>
<dt><code>Pr60</code></dt><dd><p>a numeric vector, water content at a pressure of 60 mca &ndash; <code class="reqn">6 \times 10^3</code> Pa (atm)</p>
</dd>
<dt><code>Pr100</code></dt><dd><p>a numeric vector, water content at a pressure of 100 mca &ndash; <code class="reqn">1 \times 10^4</code> Pa (atm)</p>
</dd>
<dt><code>Pr306</code></dt><dd><p>a numeric vector, water content at a pressure of 306 mca &ndash; <code class="reqn">3 \times 10^4</code> Pa (atm)</p>
</dd>
<dt><code>Pr816</code></dt><dd><p>a numeric vector, water content at a pressure of 816 mca &ndash; <code class="reqn">8 \times 10^4</code> Pa (atm)</p>
</dd>
<dt><code>Pr3060</code></dt><dd><p>a numeric vector, water content at a pressure of 3060 mca &ndash; <code class="reqn">3 \times 10^5</code> Pa (atm)</p>
</dd>
<dt><code>Pr15300</code></dt><dd><p>a numeric vector, water content at a pressure of 15300 mca &ndash; <code class="reqn">1.5 \times 10^6</code> Pa (atm)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Uniformity trial with 250 undisturbed soil samples collected at 25cm
soil depth of spacing of 5 meters, resulting on a regular grid of
<code class="reqn">25 \times 10</code> sampling points.
</p>
<p>For each sampling point there are measurents of the soil density and
water content obtained at eight pressures: 5, 10, 60, 100, 306, 816,
3060 and 15300 meters of column of water (mca), corresponding to
<code class="reqn">5 \times 10^2</code>, 
<code class="reqn">1 \times 10^3</code>, <code class="reqn">6 \times 10^3</code>, <code class="reqn">1 \times 10^4</code>,
<code class="reqn">3 \times 10^4</code>, <code class="reqn">8 \times 10^4</code>, <code class="reqn">3 \times 10^5</code>,
<code class="reqn">1.5 \times10^6</code> Pa.
</p>
<p>The experiment aimed to use the water contents of the samples to
estimate the water retention curve at the 250 data points.
</p>
<p>See also the data-set <code><a href="#topic+soil250">soil250</a></code> with soil chemistry properties measured at the same points.
</p>


<h3>Source</h3>

<p>MORAES, S.O. (1991) Heterogeneidade hidráulica de uma terra roxa
estruturada. PhD Thesis. ESALQ/USP.
</p>


<h3>References</h3>

<p>MORAES, S. O. ; LIBARDI, P. L. ; REICHARDT, K. (1993) Problemas
metodológicos na obtenção da curva de retenção de água pelo
solo. Scientia Agricola, Piracicaba, v. 50, n. 3, p. 383-392.
</p>
<p>MORAES, S. O. ; LIBARDI, P. L. ; REICHARDT, K. ; BACCHI,
O. O. S. (1993) Heterogeneidade dos pontos experimentais
de curvas de retenção da água do solo.. Scientia Agricola, Piracicaba, v. 50, n. 3, p. 393-402.
</p>
<p>MORAES, S. O. ; LIBARDI, P. L. (1993) Variabilidade da água disponível
em uma terra roxa estruturada latossólica.
Scientia Agricola, Piracicaba, v. 50, n. 3, p. 393-402, 1993. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr100 &lt;- as.geodata(wrc, data.col=7)
summary(pr100)
plot(pr100)
</code></pre>

<hr>
<h2 id='xvalid'>Cross-validation by kriging</h2><span id='topic+xvalid'></span><span id='topic+summary.xvalid'></span><span id='topic+print.summary.xvalid'></span>

<h3>Description</h3>

<p>A function to perform model validation by comparing observed and
values predicted by kriging.
Options include: (i) <em>leaving-one-out</em> cross-validation where
each data location is removed from the data set and the variable at
this location is predicted using the remaining locations, for a given
model. This can be computed for all or a subset of the data locations;
(ii) <em>external validation</em> can be performed by using
validation locations other than data locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvalid(geodata, coords = geodata$coords, data = geodata$data,
       model, reestimate = FALSE, variog.obj = NULL,
       output.reestimate = FALSE, locations.xvalid = "all",
       data.xvalid = NULL, messages, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvalid_+3A_geodata">geodata</code></td>
<td>
<p>a list containing element <code>coords</code>
as described next. Typically an object of the class
<code>"geodata"</code> - a <span class="pkg">geoR</span> data-set.
If not provided the arguments
<code>coords</code> must be provided instead.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_coords">coords</code></td>
<td>
<p>an <code class="reqn">n \times 2</code> matrix containing
coordinates of the <code class="reqn">n</code> data locations in each row.
Defaults to <code>geodata$coords</code>, if provided.</p>
</td></tr>
<tr><td><code id="xvalid_+3A_data">data</code></td>
<td>
<p>a vector or matrix with data values.
If a matrix is provided, each column is regarded as one variable or realization.
Defaults to <code>geodata$data</code>, if provided.</p>
</td></tr>
<tr><td><code id="xvalid_+3A_model">model</code></td>
<td>
<p>an object containing information on a fitted
model. Typically an output of <code><a href="#topic+likfit">likfit</a></code>,
<code><a href="#topic+variofit">variofit</a></code>. If an object of the class
<code>eyefit</code> is passed it takes the first model
specified in the object.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_reestimate">reestimate</code></td>
<td>
<p>logical. Indicates whether or not the model
parameters should be re-estimated for each point removed from the data-set. </p>
</td></tr>
<tr><td><code id="xvalid_+3A_variog.obj">variog.obj</code></td>
<td>
<p>on object with the empirical variogram, typically an
output  of the function <code><a href="#topic+variog">variog</a></code>. Only used if
<code>reestimate = TRUE</code> and the object passed to the argument
<code>model</code> is the result of a variogram based estimation, i.e. if
the model was fitted by <code><a href="#topic+variofit">variofit</a></code>.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_output.reestimate">output.reestimate</code></td>
<td>
<p>logical. Only valid if <code>reestimate =
      TRUE</code>. Specifies whether the re-estimated parameters are returned.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_locations.xvalid">locations.xvalid</code></td>
<td>
<p>there are three possible specifications for
this argument: <code>"all"</code> indicates the <em>leaving-on-out</em>
method is used at all data locations.
The second possibility is to use only a sub-set of
the data for cross-validation in which case the argument takes
a vector with numbers (indexes) indicating at which of the data locations the
cross-validation should be performed. The third option is to perform
external validation, on locations other than data locations used for
the model. For the latter a matrix with the
coordinates of the validation points should be provided and the
argument <code>data.xvalid</code> mandatory.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_data.xvalid">data.xvalid</code></td>
<td>
<p>data values at the validation locations.
Only used if the validation locations are other than the data
locations.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_messages">messages</code></td>
<td>
<p>logical. Indicates whether
status messages should be printed on the screen (or output device)
while the function is running.  </p>
</td></tr>
<tr><td><code id="xvalid_+3A_...">...</code></td>
<td>
<p>further arguments to the minimization functions used by
<code><a href="#topic+likfit">likfit</a></code>, <code><a href="#topic+variofit">variofit</a></code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-validation uses internally the function <code>krige.conv</code>
to predict at each location.
</p>
<p>For models fitted by <code><a href="#topic+variofit">variofit</a></code> the
parameters <code class="reqn">\kappa</code>, <code class="reqn">\psi_A</code>, <code class="reqn">\psi_R</code>
and <code class="reqn">\lambda</code> are always regarded as fixed when
reestimating the model.
</p>
<p>See documentation of the function <code><a href="#topic+likfit">likfit</a></code> for further
details on the model specification and parameters.
</p>


<h3>Value</h3>

<p>An object of the <code><a href="base.html#topic+class">class</a></code> <code>"xvalid"</code> which is a list with the following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the original data.  </p>
</td></tr>
<tr><td><code>predicted</code></td>
<td>
<p>the values predicted by cross-validation.  </p>
</td></tr>
<tr><td><code>krige.var</code></td>
<td>
<p>the cross-validation prediction variance.  </p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>the differences <code>data - predicted value</code>.   </p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>the errors divided by the square root of the
prediction variances.  </p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the cumulative probability at original value under a
normal distribution with parameters given by the cross-validation results.  </p>
</td></tr>
</table>
<p>A method for <code>summary</code> returns summary statistics for the errors
and standard errors.
</p>
<p>If <code>reestimate = TRUE</code> and <code>output = TRUE</code> additional
columns are added to the resulting data-frame with the
values of the re-estimated parameters.
</p>


<h3>Author(s)</h3>

<p>Paulo J. Ribeiro Jr. <a href="mailto:paulojus@ufpr.br">paulojus@ufpr.br</a>, <br />
Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>.
</p>


<h3>References</h3>

<p>Further information on the package <span class="pkg">geoR</span> can be found at:<br />
<a href="http://www.leg.ufpr.br/geoR/">http://www.leg.ufpr.br/geoR/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.xvalid">plot.xvalid</a></code> for plotting of the results, <code><a href="#topic+likfit">likfit</a></code>,
<code><a href="#topic+variofit">variofit</a></code> for parameter estimation and
<code><a href="#topic+krige.conv">krige.conv</a></code> for the kriging method used for predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Maximum likelihood estimation
#
s100.ml &lt;- likfit(s100, ini = c(.5, .5), fix.nug = TRUE)
#
# Weighted least squares estimation
#
s100.var &lt;- variog(s100, max.dist = 1)
s100.wls &lt;- variofit(s100.var, ini = c(.5, .5), fix.nug = TRUE)
#
# Now, performing cross-validation without reestimating the model
#
s100.xv.ml &lt;- xvalid(s100, model = s100.ml)
s100.xv.wls &lt;- xvalid(s100, model = s100.wls)
##
## Plotting results
##
par.ori &lt;- par(no.readonly = TRUE)
##
par(mfcol=c(5,2), mar=c(2.3,2.3,.5,.5), mgp=c(1.3, .6, 0))
plot(s100.xv.ml)
par(mfcol=c(5,2))
plot(s100.xv.wls)
##
par(par.ori)
#

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
