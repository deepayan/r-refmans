<!DOCTYPE html><html><head><title>Help for package mcga</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcga}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcga-package'>
<p>Machine Coded Genetic Algorithms for Real-valued Optimization Problems</p></a></li>
<li><a href='#arithmetic_crossover'><p>Performs arithmetic crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#blx_crossover'><p>Performs blx (blend) crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#byte_crossover'><p>Performs crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#byte_crossover_1p'><p>Performs one-point crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#byte_crossover_2p'><p>Performs two-point crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#byte_mutation'><p>Performs mutation operation on a given double vector</p></a></li>
<li><a href='#byte_mutation_dynamic'><p>Performs mutation operation on a given double vector using dynamic mutation probabilities</p></a></li>
<li><a href='#byte_mutation_random'><p>Performs mutation operation on a given double vector</p></a></li>
<li><a href='#byte_mutation_random_dynamic'><p>Performs mutation operation on a given double vector with dynamic mutation probabilities</p></a></li>
<li><a href='#ByteCodeMutation'><p>Mutation operator for byte representation of double values</p></a></li>
<li><a href='#ByteCodeMutationUsingDoubles'><p>Mutation operator for byte representation of double values</p></a></li>
<li><a href='#ByteCodeMutationUsingDoublesRandom'><p>Mutation operator for byte representation of double values</p></a></li>
<li><a href='#BytesToDouble'><p>Converting <code>sizeof(double)</code> bytes to a double value</p></a></li>
<li><a href='#ByteVectorToDoubles'><p>Converting p * <code>sizeof(double)</code> bytes to a vector of p double values</p></a></li>
<li><a href='#DoubleToBytes'><p>Byte representation of a <code>double</code> typed variable</p></a></li>
<li><a href='#DoubleVectorToBytes'><p>Byte representation of a vector of <code>double</code> typed variables</p></a></li>
<li><a href='#EnsureBounds'><p>Altering vector of doubles to satisfy boundary constraints</p></a></li>
<li><a href='#flat_crossover'><p>Performs flat crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#linear_crossover'><p>Performs linear crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#MaxDouble'><p>Maximum value of a <code>double</code> typed variable</p></a></li>
<li><a href='#mcga'>
<p>Performs machine coded genetic algorithms on a function subject to be minimized.</p></a></li>
<li><a href='#mcga-internal'><p>Internal mcga objects</p></a></li>
<li><a href='#mcga2'><p>Performs a machine-coded genetic algorithm search for a given optimization problem</p></a></li>
<li><a href='#multi_mcga'>
<p>Performs multi objective machine coded genetic algorithms.</p></a></li>
<li><a href='#OnePointCrossOver'><p>One Point Crossover operation on the two vectors of bytes</p></a></li>
<li><a href='#OnePointCrossOverOnDoublesUsingBytes'><p>One-point Crossover operation on the two vectors of doubles using their byte representations</p></a></li>
<li><a href='#sbx_crossover'><p>Performs sbx (simulated binary) crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#SizeOfDouble'><p>Byte-length of a <code>double</code> typed variable</p></a></li>
<li><a href='#SizeOfInt'><p>Byte-length of a <code>int</code> typed variable</p></a></li>
<li><a href='#SizeOfLong'><p>Byte-length of a <code>long</code> typed variable</p></a></li>
<li><a href='#TwoPointCrossOver'><p>Two Point Crossover operation on the two vectors of bytes</p></a></li>
<li><a href='#TwoPointCrossOverOnDoublesUsingBytes'><p>Two-point Crossover operation on the two vectors of doubles using their byte representations</p></a></li>
<li><a href='#unfair_average_crossover'><p>Performs unfair average crossover operation on a pair of two selected parent candidate solutions</p></a></li>
<li><a href='#UniformCrossOver'><p>Uniform Crossover operation on the two vectors of bytes</p></a></li>
<li><a href='#UniformCrossOverOnDoublesUsingBytes'><p>Uniform Crossover operation on the two vectors of doubles using their byte representations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Machine Coded Genetic Algorithms for Real-Valued Optimization
Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Mehmet Hakan Satman</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mehmet Hakan Satman &lt;mhsatman@istanbul.edu.tr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Machine coded genetic algorithm (MCGA) is a fast tool for
    real-valued optimization problems. It uses the byte
    representation of variables rather than real-values. It
    performs the classical crossover operations (uniform) on these
    byte representations. Mutation operator is also similar to
    classical mutation operator, which is to say, it changes a
    randomly selected byte value of a chromosome by +1 or -1 with
    probability 1/2. In MCGAs there is no need for
    encoding-decoding process and the classical operators are
    directly applicable on real-values. It is fast and can handle a
    wide range of a search space with high precision. Using a
    256-unary alphabet is the main disadvantage of this algorithm
    but a moderate size population is convenient for many problems.
    Package also includes multi_mcga function for multi objective
    optimization problems. This function sorts the chromosomes
    using their ranks calculated from the non-dominated sorting
    algorithm.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>GA</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 11:40:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 11:21:21 UTC; hako</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
</table>
<hr>
<h2 id='mcga-package'>
Machine Coded Genetic Algorithms for Real-valued Optimization Problems
</h2><span id='topic+mcga-package'></span>

<h3>Description</h3>

<p>Machine coded genetic algorithm (MCGA) is a fast tool for real-valued optimization problems. It uses the byte representation of variables rather than real-values. It performs the classical crossover operations (uniform) on these byte representations. Mutation operator is also similar to classical mutation operator, which is to say, it changes a randomly selected byte value of a chromosome by +1 or -1 with probability 1/2. In MCGAs there is no need for encoding-decoding process and the classical operators are directly applicable on real-values. It is fast and can handle a wide range of a search space with high precision. Using a 256-unary alphabet is the main disadvantage of this algorithm but a moderate size population is convenient for many problems.
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman
</p>
<p>Maintainer: Mehmet Hakan Satman &lt;mhsatman@istanbul.edu.tr&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A sample optimization problem
# Min f(xi) = (x1-7)^2 + (x2-77)^2 + (x3-777)^2 + (x4-7777)^2 + (x5-77777)^2
# The range of xi is unknown. The solution is
# x1 = 7
# x2 = 77
# x3 = 777
# x4 = 7777
# x5 = 77777
# Min f(xi) = 0
require("mcga")
 f&lt;-function(x){
    return ((x[1]-7)^2 + (x[2]-77)^2 +(x[3]-777)^2 +(x[4]-7777)^2 +(x[5]-77777)^2)
 }
 m &lt;- mcga(	popsize=200, 
			chsize=5, 
			minval=0.0, 
			maxval=999999999.9, 
			maxiter=2500, 
			crossprob=1.0, 
			mutateprob=0.01, 
			evalFunc=f)
			
 cat("Best chromosome:\n")
 print(m$population[1,])
 cat("Cost: ",m$costs[1],"\n")

## End(Not run)
</code></pre>

<hr>
<h2 id='arithmetic_crossover'>Performs arithmetic crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+arithmetic_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>arithmetic_crossover</code> than
the arithmetic crossover operator is applied in the genetic search. <code>arithmetic_crossover</code> generates offspring using the weighted mean of parents' genes. Weights are drawn randomly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithmetic_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithmetic_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="arithmetic_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="arithmetic_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = arithmetic_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='blx_crossover'>Performs blx (blend) crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+blx_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>blx_crossover</code> than
the blx crossover operator is applied in the genetic search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blx_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blx_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="blx_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="blx_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = blx_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_crossover'>Performs crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+byte_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>byte_crossover</code> than
the byte-coded crossover operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
crossover parameter is set to byte_crossover by definition. <code>byte_crossover</code> function simply takes two double vectors 
(parents) and combines the bytes of doubles using a Uniform distribution with parameters 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="byte_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>See Also</h3>

<p>mcga2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              lower = rep(-50,5), upper = rep(50,5), crossover = byte_crossover,
              mutation = byte_mutation)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_crossover_1p'>Performs one-point crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+byte_crossover_1p'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>byte_crossover_1p</code> than
the byte-coded one-point crossover operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
crossover parameter is set to byte_crossover by definition. <code>byte_crossover_1p</code> function simply takes two double vectors 
(parents) and combines the bytes of doubles using given cut-point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_crossover_1p(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_crossover_1p_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_crossover_1p_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="byte_crossover_1p_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>See Also</h3>

<p>mcga2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover_1p,
              mutation = byte_mutation)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_crossover_2p'>Performs two-point crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+byte_crossover_2p'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>byte_crossover_2p</code> than
the byte-coded two-point crossover operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
crossover parameter is set to byte_crossover by definition. <code>byte_crossover_2p</code> function simply takes two double vectors 
(parents) and combines the bytes of doubles using given cutpoint1 and cutpoint2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_crossover_2p(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_crossover_2p_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_crossover_2p_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="byte_crossover_2p_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>See Also</h3>

<p>mcga2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover_2p,
              mutation = byte_mutation)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_mutation'>Performs mutation operation on a given double vector</h2><span id='topic+byte_mutation'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>mutation=</code> is set to <code>byte_mutation</code> than
the byte-coded mutation operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
mutation parameter is set to byte_mutation by definition. Byte-mutation function simply takes an double vector and
changes bytes of this values by +1 or -1 using the pre-determined mutation probabilty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_mutation(object, parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_mutation_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_mutation_+3A_parent">parent</code></td>
<td>
<p>Index of the candidate solution of the current population</p>
</td></tr>
<tr><td><code id="byte_mutation_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mutated double vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover,
              mutation = byte_mutation)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_mutation_dynamic'>Performs mutation operation on a given double vector using dynamic mutation probabilities</h2><span id='topic+byte_mutation_dynamic'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>mutation=</code> is set to <code>byte_mutation_dynamic</code> than
the byte-coded mutation operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
mutation parameter is set to byte_mutation by definition. Byte-mutation function simply takes an double vector and
changes bytes of this values by +1 or -1 using the dynamically decreased and pre-determined mutation probabilty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_mutation_dynamic(object, parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_mutation_dynamic_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_mutation_dynamic_+3A_parent">parent</code></td>
<td>
<p>Index of the candidate solution of the current population</p>
</td></tr>
<tr><td><code id="byte_mutation_dynamic_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mutated double vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover,
              mutation = byte_mutation_dynamic, pmutation = 0.10)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_mutation_random'>Performs mutation operation on a given double vector</h2><span id='topic+byte_mutation_random'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>mutation=</code> is set to <code>byte_mutation_random</code> than
the byte-coded mutation operator is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
mutation parameter is set to byte_mutation by definition. This function simply takes an double vector and
changes bytes randomly in the range of [0,255] using the pre-determined mutation probabilty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_mutation_random(object, parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_mutation_random_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_mutation_random_+3A_parent">parent</code></td>
<td>
<p>Index of the candidate solution of the current population</p>
</td></tr>
<tr><td><code id="byte_mutation_random_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mutated double vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover,
              mutation = byte_mutation_random, pmutation = 0.20)
print(myga@solution)
</code></pre>

<hr>
<h2 id='byte_mutation_random_dynamic'>Performs mutation operation on a given double vector with dynamic mutation probabilities</h2><span id='topic+byte_mutation_random_dynamic'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>mutation=</code> is set to <code>byte_mutation_random_dynamic</code> than
the byte-coded mutation operator with dynamic probabilities is applied in the genetic search. In <code>mcga2</code> function, the hard-coded 
mutation parameter is set to byte_mutation by definition. This function simply takes an double vector and
changes bytes randomly in the range of [0,255] using the descrasing values of pre-determined mutation probabilty by generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte_mutation_random_dynamic(object, parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="byte_mutation_random_dynamic_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="byte_mutation_random_dynamic_+3A_parent">parent</code></td>
<td>
<p>Index of the candidate solution of the current population</p>
</td></tr>
<tr><td><code id="byte_mutation_random_dynamic_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mutated double vector
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
# Increase popSize and maxiter for more precise solutions
myga &lt;- GA::ga(type="real-valued", fitness = f, popSize = 100, maxiter = 200, 
              min = rep(-50,5), max = rep(50,5), crossover = byte_crossover,
              mutation = byte_mutation_random_dynamic, pmutation = 0.20)
print(myga@solution)
</code></pre>

<hr>
<h2 id='ByteCodeMutation'>Mutation operator for byte representation of double values</h2><span id='topic+ByteCodeMutation'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for mutating byte representation of a given candidate solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ByteCodeMutation(bytes1, pmutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ByteCodeMutation_+3A_bytes1">bytes1</code></td>
<td>
<p>A vector of bytes of a candidate solution</p>
</td></tr>
<tr><td><code id="ByteCodeMutation_+3A_pmutation">pmutation</code></td>
<td>
<p>Probability of mutation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Byte vector of mutated solution
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>ByteCodeMutationUsingDoubles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1246)
print(pi)
bytes &lt;- DoubleToBytes(pi)
mutated.bytes &lt;- ByteCodeMutation(bytes, 0.10) 
new.var &lt;- BytesToDouble(mutated.bytes)
print(new.var)
</code></pre>

<hr>
<h2 id='ByteCodeMutationUsingDoubles'>Mutation operator for byte representation of double values</h2><span id='topic+ByteCodeMutationUsingDoubles'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for mutating byte representation of a given candidate solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ByteCodeMutationUsingDoubles(d, pmutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ByteCodeMutationUsingDoubles_+3A_d">d</code></td>
<td>
<p>A vector of doubles</p>
</td></tr>
<tr><td><code id="ByteCodeMutationUsingDoubles_+3A_pmutation">pmutation</code></td>
<td>
<p>Probability of mutation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double vector of mutated solution
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>ByteCodeMutation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1246)
print(pi)
print(exp(1))
new.var &lt;- ByteCodeMutationUsingDoubles(c(pi, exp(1)), 0.10)
print(new.var)
</code></pre>

<hr>
<h2 id='ByteCodeMutationUsingDoublesRandom'>Mutation operator for byte representation of double values</h2><span id='topic+ByteCodeMutationUsingDoublesRandom'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for mutating byte representation of a given candidate solution. This mutation operator 
randomly changes a byte in the range of [0,255].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ByteCodeMutationUsingDoublesRandom(d, pmutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ByteCodeMutationUsingDoublesRandom_+3A_d">d</code></td>
<td>
<p>A vector of doubles</p>
</td></tr>
<tr><td><code id="ByteCodeMutationUsingDoublesRandom_+3A_pmutation">pmutation</code></td>
<td>
<p>Probability of mutation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double vector of mutated solution
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>ByteCodeMutation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1246)
print(pi)
print(exp(1))
new.var &lt;- ByteCodeMutationUsingDoublesRandom(c(pi, exp(1)), 0.10)
print(new.var)
</code></pre>

<hr>
<h2 id='BytesToDouble'>Converting <code>sizeof(double)</code> bytes to a double value</h2><span id='topic+BytesToDouble'></span>

<h3>Description</h3>

<p>This function converts <code>sizeof(double)</code> bytes to a double typed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BytesToDouble(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BytesToDouble_+3A_x">x</code></td>
<td>
<p>A vector of bytes (unsigned chars in C++)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corresponding <code>double</code> typed value for a given vector of bytes
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>DoubleVectorToBytes
</p>
<p>DoubleToBytes
</p>
<p>ByteVectorToDoubles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(BytesToDouble(DoubleToBytes(56.43)))
</code></pre>

<hr>
<h2 id='ByteVectorToDoubles'>Converting p * <code>sizeof(double)</code> bytes to a vector of p double values</h2><span id='topic+ByteVectorToDoubles'></span>

<h3>Description</h3>

<p>This function converts a byte vector to a vector of doubles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ByteVectorToDoubles(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ByteVectorToDoubles_+3A_b">b</code></td>
<td>
<p>A vector of bytes (unsigned chars in C++)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Corresponding vector of <code>double</code> typed values for a given vector of bytes
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>DoubleVectorToBytes
</p>
<p>BytesToDouble
</p>
<p>ByteVectorToDoubles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- DoubleVectorToBytes(c(56.54, 89.7666, 98.565))
b &lt;- ByteVectorToDoubles(a)
print(b)
</code></pre>

<hr>
<h2 id='DoubleToBytes'>Byte representation of a <code>double</code> typed variable</h2><span id='topic+DoubleToBytes'></span>

<h3>Description</h3>

<p>This function returns a vector of byte values with the length of <code>sizeof(double)</code> for a given <code>double</code> typed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleToBytes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleToBytes_+3A_x">x</code></td>
<td>
<p>A double typed value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of byte values with the length of <code>sizeof(double)</code> for a given <code>double</code> typed value
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>DoubleVectorToBytes
</p>
<p>BytesToDouble
</p>
<p>ByteVectorToDoubles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(DoubleToBytes(56.43))
</code></pre>

<hr>
<h2 id='DoubleVectorToBytes'>Byte representation of a vector of <code>double</code> typed variables</h2><span id='topic+DoubleVectorToBytes'></span>

<h3>Description</h3>

<p>This function returns a vector of byte values for a given vector of <code>double</code> typed values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DoubleVectorToBytes(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DoubleVectorToBytes_+3A_d">d</code></td>
<td>
<p>A vector of double typed values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of byte values for a given vector of <code>double</code> typed values
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>DoubleToBytes
</p>
<p>BytesToDouble
</p>
<p>ByteVectorToDoubles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(DoubleVectorToBytes(c(56.54, 89.7666, 98.565)))
</code></pre>

<hr>
<h2 id='EnsureBounds'>Altering vector of doubles to satisfy boundary constraints</h2><span id='topic+EnsureBounds'></span>

<h3>Description</h3>

<p>Byte based crossover and mutation operators can generate variables out of bounds of the decision variables. This function controls if variables are between their lower and upper bounds and if not, draws random numbers between these ranges. This function directly modifies the argument <code>doubles</code> and does not return a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EnsureBounds(doubles, mins, maxs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EnsureBounds_+3A_doubles">doubles</code></td>
<td>
<p>A vector of doubles</p>
</td></tr>
<tr><td><code id="EnsureBounds_+3A_mins">mins</code></td>
<td>
<p>A vector of lower bounds of decision variables</p>
</td></tr>
<tr><td><code id="EnsureBounds_+3A_maxs">maxs</code></td>
<td>
<p>A vector of upper bounds of decision variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function directly modifies the argument <code>doubles</code> and does not return a result.
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>byte_crossover
</p>
<p>byte_mutation
</p>
<p>mcga2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
x &lt;- runif(10)
print(x)
# [1] 0.113703411 0.622299405 0.609274733 0.623379442 0.860915384 0.640310605
# [7] 0.009495756 0.232550506 0.666083758 0.514251141
EnsureBounds(x, mins=rep(0,10), maxs=rep(0.2,10))
print(x)
# [1] 0.113703411 0.138718258 0.108994967 0.056546717 0.184686697 0.058463168
# [7] 0.009495756 0.167459126 0.057244657 0.053364156
</code></pre>

<hr>
<h2 id='flat_crossover'>Performs flat crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+flat_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>flat_crossover</code> than
the flat crossover operator is applied in the genetic search. <code>flat_crossover</code> draws a random number between parents' genes and returns a pair of generated offspring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="flat_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="flat_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = flat_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='linear_crossover'>Performs linear crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+linear_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>linear_crossover</code> than
the linear crossover operator is applied in the genetic search. <code>linear_crossover</code> generates three offspring and performs a selection mechanism to determine best two of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="linear_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="linear_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = linear_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='MaxDouble'>Maximum value of a <code>double</code> typed variable</h2><span id='topic+MaxDouble'></span>

<h3>Description</h3>

<p>Maximum value of a <code>double</code> typed variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxDouble()
</code></pre>


<h3>Value</h3>

<p>Returns maximum value of a <code>double</code> typed variable in C++ compiler
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(MaxDouble())
</code></pre>

<hr>
<h2 id='mcga'>
Performs machine coded genetic algorithms on a function subject to be minimized.
</h2><span id='topic+mcga'></span>

<h3>Description</h3>

<p>Machine coded genetic algorithm (MCGA) is a fast tool for real-valued optimization problems. It uses the byte representation of variables rather than real-values. It performs the classical crossover operations (uniform) on these byte representations. Mutation operator is also similar to classical mutation operator, which is to say, it changes a randomly selected byte value of a chromosome by +1 or -1 with probability 1/2. In MCGAs there is no need for encoding-decoding process and the classical operators are directly applicable on real-values. It is fast and can handle a wide range of a search space with high precision. Using a 256-unary alphabet is the main disadvantage of this algorithm but a moderate size population is convenient for many problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcga(popsize, chsize, crossprob = 1.0, mutateprob = 0.01, 
	 elitism = 1, minval, maxval, maxiter = 10, evalFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcga_+3A_popsize">popsize</code></td>
<td>

<p>Number of chromosomes. 
</p>
</td></tr>
<tr><td><code id="mcga_+3A_chsize">chsize</code></td>
<td>

<p>Number of parameters.
</p>
</td></tr>
<tr><td><code id="mcga_+3A_crossprob">crossprob</code></td>
<td>

<p>Crossover probability. By default it is 1.0
</p>
</td></tr>
<tr><td><code id="mcga_+3A_mutateprob">mutateprob</code></td>
<td>

<p>Mutation probability. By default it is 0.01
</p>
</td></tr>
<tr><td><code id="mcga_+3A_elitism">elitism</code></td>
<td>

<p>Number of best chromosomes to be copied directly into next generation. By default it is 1
</p>
</td></tr>
<tr><td><code id="mcga_+3A_minval">minval</code></td>
<td>

<p>The lower bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td></tr>
<tr><td><code id="mcga_+3A_maxval">maxval</code></td>
<td>

<p>The upper bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td></tr>
<tr><td><code id="mcga_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of generations. By default it is 10
</p>
</td></tr>
<tr><td><code id="mcga_+3A_evalfunc">evalFunc</code></td>
<td>

<p>An R function. By default, each problem is a minimization. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>population</code></td>
<td>
<p>Sorted population resulted after generations</p>
</td></tr>
<tr><td><code>costs</code></td>
<td>
<p>Cost values for each chromosomes in the resulted population</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A sample optimization problem
# Min f(xi) = (x1-7)^2 + (x2-77)^2 + (x3-777)^2 + (x4-7777)^2 + (x5-77777)^2
# The range of xi is unknown. The solution is
# x1 = 7
# x2 = 77
# x3 = 777
# x4 = 7777
# x5 = 77777
# Min f(xi) = 0
require("mcga")
 f&lt;-function(x){
    return ((x[1]-7)^2 + (x[2]-77)^2 +(x[3]-777)^2 +(x[4]-7777)^2 +(x[5]-77777)^2)
 }
 m &lt;- mcga(	popsize=200, 
			chsize=5, 
			minval=0.0, 
			maxval=999999999.9, 
			maxiter=2500, 
			crossprob=1.0, 
			mutateprob=0.01, 
			evalFunc=f)
			
 cat("Best chromosome:\n")
 print(m$population[1,])
 cat("Cost: ",m$costs[1],"\n")
</code></pre>

<hr>
<h2 id='mcga-internal'>Internal mcga objects</h2><span id='topic+.First.lib'></span>

<h3>Description</h3>

<p>Internal mcga objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='mcga2'>Performs a machine-coded genetic algorithm search for a given optimization problem</h2><span id='topic+mcga2'></span>

<h3>Description</h3>

<p><code>mcga2</code> is the improvement version of the standard mcga function as it is based on the <code>GA::ga</code> function. The 
<code>byte_crossover</code> and the <code>byte_mutation</code> operators are the main reproduction operators and these operators uses the byte 
representations of parents in the computer memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcga2(fitness, ..., min, max,
  population = gaControl("real-valued")$population,
  selection = gaControl("real-valued")$selection,
  crossover = byte_crossover, mutation = byte_mutation, popSize = 50,
  pcrossover = 0.8, pmutation = 0.1, elitism = base::max(1, round(popSize
  * 0.05)), maxiter = 100, run = maxiter, maxFitness = Inf,
  names = NULL, parallel = FALSE, monitor = gaMonitor, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcga2_+3A_fitness">fitness</code></td>
<td>
<p>The goal function to be maximized</p>
</td></tr>
<tr><td><code id="mcga2_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the fitness function</p>
</td></tr>
<tr><td><code id="mcga2_+3A_min">min</code></td>
<td>
<p>Vector of lower bounds of variables</p>
</td></tr>
<tr><td><code id="mcga2_+3A_max">max</code></td>
<td>
<p>Vector of upper bounds of variables</p>
</td></tr>
<tr><td><code id="mcga2_+3A_population">population</code></td>
<td>
<p>Initial population. It is <code>gaControl("real-valued")$population</code> by default.</p>
</td></tr>
<tr><td><code id="mcga2_+3A_selection">selection</code></td>
<td>
<p>Selection operator. It is <code>gaControl("real-valued")$selection</code> by default.</p>
</td></tr>
<tr><td><code id="mcga2_+3A_crossover">crossover</code></td>
<td>
<p>Crossover operator. It is <code>byte_crossover</code> by default.</p>
</td></tr>
<tr><td><code id="mcga2_+3A_mutation">mutation</code></td>
<td>
<p>Mutation operator. It is <code>byte_mutation</code> by default. Other values can be given including <code>byte_mutation_random</code>, 
<code>byte_mutation_dynamic</code> and <code>byte_mutation_random_dynamic</code></p>
</td></tr>
<tr><td><code id="mcga2_+3A_popsize">popSize</code></td>
<td>
<p>Population size. It is 50 by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_pcrossover">pcrossover</code></td>
<td>
<p>Probability of crossover. It is 0.8 by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_pmutation">pmutation</code></td>
<td>
<p>Probability of mutation. It is 0.1 by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_elitism">elitism</code></td>
<td>
<p>Number of elitist solutions. It is <code>base::max(1, round(popSize*0.05))</code> by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of generations. It is 100 by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_run">run</code></td>
<td>
<p>The genetic search is stopped if the best solution has not any improvements in last <code>run</code> generations. By default it is <code>maxiter</code></p>
</td></tr>
<tr><td><code id="mcga2_+3A_maxfitness">maxFitness</code></td>
<td>
<p>Upper bound of the fitness function. By default it is Inf</p>
</td></tr>
<tr><td><code id="mcga2_+3A_names">names</code></td>
<td>
<p>Vector of names of the variables. By default it is <code>NULL</code></p>
</td></tr>
<tr><td><code id="mcga2_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, fitness calculations are performed parallel. It is FALSE by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_monitor">monitor</code></td>
<td>
<p>The monitoring function for printing some information about the current state of the genetic search. It is <code>gaMonitor</code> by default</p>
</td></tr>
<tr><td><code id="mcga2_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generating. It is <code>NULL</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>ga-class</code>
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>M.H.Satman (2013), Machine Coded Genetic Algorithms for Real Parameter Optimization Problems, Gazi University Journal of Science, Vol 26, No 1, pp. 85-95
</p>
<p>Luca Scrucca (2013). GA: A Package for Genetic Algorithms in R. Journal of Statistical Software, 53(4), 1-37. 
</p>


<h3>See Also</h3>

<p>GA::ga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- mcga2(fitness = f, popSize = 100, maxiter = 300, 
              min = rep(-50,5), max = rep(50,5))
print(myga@solution)
</code></pre>

<hr>
<h2 id='multi_mcga'>
Performs multi objective machine coded genetic algorithms.
</h2><span id='topic+multi_mcga'></span>

<h3>Description</h3>

<p>Machine coded genetic algorithm (MCGA) is a fast tool for real-valued optimization problems. It uses the byte representation of variables rather than real-values. It performs the classical crossover operations (uniform) on these byte representations. Mutation operator is also similar to classical mutation operator, which is to say, it changes a randomly selected byte value of a chromosome by +1 or -1 with probability 1/2. In MCGAs there is no need for encoding-decoding process and the classical operators are directly applicable on real-values. It is fast and can handle a wide range of a search space with high precision. Using a 256-unary alphabet is the main disadvantage of this algorithm but a moderate size population is convenient for many problems.
</p>
<p>This function performs multi objective optimization using the same logic underlying the mcga. Chromosomes are sorted by their 
objective values using a non-dominated sorting algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_mcga(popsize, chsize, crossprob = 1.0, mutateprob = 0.01, 
		   elitism = 1, minval, maxval, maxiter = 10, numfunc, evalFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_mcga_+3A_popsize">popsize</code></td>
<td>

<p>Number of chromosomes. 
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_chsize">chsize</code></td>
<td>

<p>Number of parameters.
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_crossprob">crossprob</code></td>
<td>

<p>Crossover probability. By default it is 1.0
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_mutateprob">mutateprob</code></td>
<td>

<p>Mutation probability. By default it is 0.01
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_elitism">elitism</code></td>
<td>

<p>Number of best chromosomes to be copied directly into next generation. By default it is 1
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_minval">minval</code></td>
<td>

<p>The lower bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_maxval">maxval</code></td>
<td>

<p>The upper bound of the randomized initial population. This is not a constraint for parameters.
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of generations. By default it is 10.
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_numfunc">numfunc</code></td>
<td>

<p>Number of objective functions.
</p>
</td></tr>
<tr><td><code id="multi_mcga_+3A_evalfunc">evalFunc</code></td>
<td>

<p>An R function. By default, each problem is a minimization. This function must return a cost vector
with dimension of numfunc. Each element of this vector points to the corresponding function to optimize. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>population</code></td>
<td>
<p>Sorted population resulted after generations</p>
</td></tr>
<tr><td><code>costs</code></td>
<td>
<p>Cost values for each chromosomes in the resulted population</p>
</td></tr>
<tr><td><code>ranks</code></td>
<td>
<p>Calculated ranks using a non-dominated sorting for each chromosome</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>Deb, K. (2000). An efficient constraint handling method for
genetic algorithms. Computer methods in applied mechanics and
engineering, 186(2), 311-338.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # We have two objective functions.
 f1&lt;-function(x){
   return(sin(x))
 }

 f2&lt;-function(x){
   return(sin(2*x))
 }

 # This function returns a vector of cost functions for a given x sent from mcga
 f&lt;-function(x){
   return ( c( f1(x), f2(x)) )
 }

 # main loop
 m&lt;-multi_mcga(popsize=200, chsize=1, minval= 0, elitism=2, 
 	      maxval= 2.0 * pi, maxiter=1000, crossprob=1.0, 
	      mutateprob=0.01, evalFunc=f, numfunc=2)

 # Points show best five solutions. 
 curve(f1, 0, 2*pi)
 curve(f2, 0, 2*pi, add=TRUE)

 p &lt;- m$population[1:5,]
 points(p, f1(p))
 points(p, f2(p))

## End(Not run)
</code></pre>

<hr>
<h2 id='OnePointCrossOver'>One Point Crossover operation on the two vectors of bytes</h2><span id='topic+OnePointCrossOver'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two byte vectors of candidate solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnePointCrossOver(bytes1, bytes2, cutpoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OnePointCrossOver_+3A_bytes1">bytes1</code></td>
<td>
<p>A vector of bytes of the first parent</p>
</td></tr>
<tr><td><code id="OnePointCrossOver_+3A_bytes2">bytes2</code></td>
<td>
<p>A vector of bytes of the second parent</p>
</td></tr>
<tr><td><code id="OnePointCrossOver_+3A_cutpoint">cutpoint</code></td>
<td>
<p>Cut-point for the single point crossing-over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two byte vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>UniformCrossOver
</p>
<p>UniformCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- DoubleVectorToBytes(c(56.54, 89.7666, 98.565))
b2 &lt;- DoubleVectorToBytes(c(79.76, 56.4443, 34.22121))
result &lt;- OnePointCrossOver(b1,b2, round(runif(1,1,SizeOfDouble() * 3)))
print(ByteVectorToDoubles(result[[1]]))
print(ByteVectorToDoubles(result[[2]]))
</code></pre>

<hr>
<h2 id='OnePointCrossOverOnDoublesUsingBytes'>One-point Crossover operation on the two vectors of doubles using their byte representations</h2><span id='topic+OnePointCrossOverOnDoublesUsingBytes'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two double vectors of candidate solutions using their byte representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnePointCrossOverOnDoublesUsingBytes(d1, d2, cutpoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OnePointCrossOverOnDoublesUsingBytes_+3A_d1">d1</code></td>
<td>
<p>A vector of doubles of the first parent</p>
</td></tr>
<tr><td><code id="OnePointCrossOverOnDoublesUsingBytes_+3A_d2">d2</code></td>
<td>
<p>A vector of doubles of the second parent</p>
</td></tr>
<tr><td><code id="OnePointCrossOverOnDoublesUsingBytes_+3A_cutpoint">cutpoint</code></td>
<td>
<p>An integer between 1 and chromosome length for crossover cutting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two double vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>OnePointCrossOver
</p>
<p>UniformCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- runif(3)
d2 &lt;- runif(3)
cutp &lt;- sample(1:(length(d1)*SizeOfDouble()), 1)[1]
offspring &lt;- OnePointCrossOverOnDoublesUsingBytes(d1,d2, cutp)
print("Parents:")
print(d1)
print(d2)
print("Offspring:")
print(offspring[[1]])
print(offspring[[2]])
</code></pre>

<hr>
<h2 id='sbx_crossover'>Performs sbx (simulated binary) crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+sbx_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>sbx_crossover</code> than
the sbx crossover operator is applied in the genetic search. sbx_crossover mimics the classical single-point crossover operator
in binary genetic algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbx_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbx_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="sbx_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="sbx_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>References</h3>

<p>Deb, Kalyanmoy, and Ram Bhushan Agrawal. &quot;Simulated binary crossover for continuous search space.&quot; Complex systems 9.2 (1995): 115-148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = sbx_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='SizeOfDouble'>Byte-length of a <code>double</code> typed variable</h2><span id='topic+SizeOfDouble'></span>

<h3>Description</h3>

<p>Byte-length of a <code>double</code> typed variable in computer memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SizeOfDouble()
</code></pre>


<h3>Value</h3>

<p>Returns the byte-length of a <code>double</code> typed variable in computer memory
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(SizeOfDouble())
</code></pre>

<hr>
<h2 id='SizeOfInt'>Byte-length of a <code>int</code> typed variable</h2><span id='topic+SizeOfInt'></span>

<h3>Description</h3>

<p>Byte-length of a <code>int</code> typed variable in computer memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SizeOfInt()
</code></pre>


<h3>Value</h3>

<p>Returns the byte-length of a <code>int</code> typed variable in computer memory
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(SizeOfInt())
</code></pre>

<hr>
<h2 id='SizeOfLong'>Byte-length of a <code>long</code> typed variable</h2><span id='topic+SizeOfLong'></span>

<h3>Description</h3>

<p>Byte-length of a <code>long</code> typed variable in computer memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SizeOfLong()
</code></pre>


<h3>Value</h3>

<p>Returns the byte-length of a <code>long</code> typed variable in computer memory
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(SizeOfLong())
</code></pre>

<hr>
<h2 id='TwoPointCrossOver'>Two Point Crossover operation on the two vectors of bytes</h2><span id='topic+TwoPointCrossOver'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two byte vectors of candidate solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoPointCrossOver(bytes1, bytes2, cutpoint1, cutpoint2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoPointCrossOver_+3A_bytes1">bytes1</code></td>
<td>
<p>A vector of bytes of the first parent</p>
</td></tr>
<tr><td><code id="TwoPointCrossOver_+3A_bytes2">bytes2</code></td>
<td>
<p>A vector of bytes of the second parent</p>
</td></tr>
<tr><td><code id="TwoPointCrossOver_+3A_cutpoint1">cutpoint1</code></td>
<td>
<p>First cut-point for the single point crossing-over</p>
</td></tr>
<tr><td><code id="TwoPointCrossOver_+3A_cutpoint2">cutpoint2</code></td>
<td>
<p>Second cut-point for the single point crossing-over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two byte vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>OnePointCrossOver
</p>
<p>OnePointCrossOverOnDoublesUsingBytes
</p>
<p>UniformCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- DoubleVectorToBytes(c(56.54, 89.7666, 98.565))
b2 &lt;- DoubleVectorToBytes(c(79.76, 56.4443, 34.22121))
cutpoints &lt;- sort(sample(1:(length(b1)*SizeOfDouble()), 2, replace = FALSE))
result &lt;- TwoPointCrossOver(b1,b2, cutpoints[1], cutpoints[2])
print(ByteVectorToDoubles(result[[1]]))
print(ByteVectorToDoubles(result[[2]]))
</code></pre>

<hr>
<h2 id='TwoPointCrossOverOnDoublesUsingBytes'>Two-point Crossover operation on the two vectors of doubles using their byte representations</h2><span id='topic+TwoPointCrossOverOnDoublesUsingBytes'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two double vectors of candidate solutions using their byte representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoPointCrossOverOnDoublesUsingBytes(d1, d2, cutpoint1, cutpoint2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoPointCrossOverOnDoublesUsingBytes_+3A_d1">d1</code></td>
<td>
<p>A vector of doubles of the first parent</p>
</td></tr>
<tr><td><code id="TwoPointCrossOverOnDoublesUsingBytes_+3A_d2">d2</code></td>
<td>
<p>A vector of doubles of the second parent</p>
</td></tr>
<tr><td><code id="TwoPointCrossOverOnDoublesUsingBytes_+3A_cutpoint1">cutpoint1</code></td>
<td>
<p>An integer between 1 and chromosome length for crossover cutting</p>
</td></tr>
<tr><td><code id="TwoPointCrossOverOnDoublesUsingBytes_+3A_cutpoint2">cutpoint2</code></td>
<td>
<p>An integer between cutpoint1 and chromosome length for crossover cutting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two double vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>TwoPointCrossOver
</p>
<p>OnePointCrossOver
</p>
<p>UniformCrossOver
</p>
<p>OnePointCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- runif(3)
d2 &lt;- runif(3)
cutpoints &lt;- sort(sample(1:(length(d1)*SizeOfDouble()), 2, replace = FALSE))
offspring &lt;- TwoPointCrossOverOnDoublesUsingBytes(d1,d2,cutpoints[1], cutpoints[2])
print("Parents:")
print(d1)
print(d2)
print("Offspring:")
print(offspring[[1]])
print(offspring[[2]])
</code></pre>

<hr>
<h2 id='unfair_average_crossover'>Performs unfair average crossover operation on a pair of two selected parent candidate solutions</h2><span id='topic+unfair_average_crossover'></span>

<h3>Description</h3>

<p>This function is not called directly but is given as a parameter in <code>GA::ga</code> function. 
In <code>GA::ga</code>, if the parameter <code>crossover=</code> is set to <code>unfair_average_crossover</code> than
the unfair average crossover operator is applied in the genetic search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfair_average_crossover(object, parents, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfair_average_crossover_+3A_object">object</code></td>
<td>
<p>A <code>GA::ga</code> object</p>
</td></tr>
<tr><td><code id="unfair_average_crossover_+3A_parents">parents</code></td>
<td>
<p>Indices of the selected parents</p>
</td></tr>
<tr><td><code id="unfair_average_crossover_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two generated offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x){ 
  return(-sum( (x-5)^2 ) )
}
myga &lt;- ga(type="real-valued", fitness = f, popSize = 100, maxiter = 100, 
           min = rep(-50,5), max = rep(50,5), crossover = unfair_average_crossover)
print(myga@solution)
</code></pre>

<hr>
<h2 id='UniformCrossOver'>Uniform Crossover operation on the two vectors of bytes</h2><span id='topic+UniformCrossOver'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two byte vectors of candidate solutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniformCrossOver(bytes1, bytes2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniformCrossOver_+3A_bytes1">bytes1</code></td>
<td>
<p>A vector of bytes of the first parent</p>
</td></tr>
<tr><td><code id="UniformCrossOver_+3A_bytes2">bytes2</code></td>
<td>
<p>A vector of bytes of the second parent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two byte vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>OnePointCrossOver
</p>
<p>UniformCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b1 &lt;- DoubleVectorToBytes(c(56.54, 89.7666, 98.565))
b2 &lt;- DoubleVectorToBytes(c(79.76, 56.4443, 34.22121))
result &lt;- UniformCrossOver(b1,b2)
print(ByteVectorToDoubles(result[[1]]))
print(ByteVectorToDoubles(result[[2]]))
</code></pre>

<hr>
<h2 id='UniformCrossOverOnDoublesUsingBytes'>Uniform Crossover operation on the two vectors of doubles using their byte representations</h2><span id='topic+UniformCrossOverOnDoublesUsingBytes'></span>

<h3>Description</h3>

<p>This function is a C++ wrapper for crossing-over of two double vectors of candidate solutions using their byte representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniformCrossOverOnDoublesUsingBytes(d1, d2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniformCrossOverOnDoublesUsingBytes_+3A_d1">d1</code></td>
<td>
<p>A vector of doubles of the first parent</p>
</td></tr>
<tr><td><code id="UniformCrossOverOnDoublesUsingBytes_+3A_d2">d2</code></td>
<td>
<p>A vector of doubles of the second parent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two double vectors of offspring
</p>


<h3>Author(s)</h3>

<p>Mehmet Hakan Satman - mhsatman@istanbul.edu.tr
</p>


<h3>See Also</h3>

<p>OnePointCrossOver
</p>
<p>OnePointCrossOverOnDoublesUsingBytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- runif(3)
d2 &lt;- runif(3)
offspring &lt;- UniformCrossOverOnDoublesUsingBytes(d1,d2)
print("Parents:")
print(d1)
print(d2)
print("Offspring:")
print(offspring[[1]])
print(offspring[[2]])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
