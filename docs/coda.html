<!DOCTYPE html><html><head><title>Help for package coda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.ts.mcmc'><p>Coerce mcmc object to time series</p></a></li>
<li><a href='#autocorr'><p>Autocorrelation function for Markov chains</p></a></li>
<li><a href='#autocorr.diag'><p>Autocorrelation function for Markov chains</p></a></li>
<li><a href='#autocorr.plot'><p>Plot autocorrelations for Markov Chains</p></a></li>
<li><a href='#batchSE'><p>Batch Standard Error</p></a></li>
<li><a href='#bugs2jags'><p>Convert WinBUGS data file to JAGS data file</p></a></li>
<li><a href='#coda.options'><p>Options settings for the codamenu driver</p></a></li>
<li><a href='#codamenu'><p>Main menu driver for the coda package</p></a></li>
<li><a href='#Cramer'><p>The Cramer-von Mises Distribution</p></a></li>
<li><a href='#crosscorr'><p>Cross correlations for MCMC output</p></a></li>
<li><a href='#crosscorr.plot'><p>Plot image of correlation matrix</p></a></li>
<li><a href='#cumuplot'><p>Cumulative quantile plot</p></a></li>
<li><a href='#densplot'><p>Probability density function estimate from MCMC output</p></a></li>
<li><a href='#effectiveSize'><p>Effective sample size for estimating the mean</p></a></li>
<li><a href='#gelman.diag'><p>Gelman and Rubin's convergence diagnostic</p></a></li>
<li><a href='#gelman.plot'><p>Gelman-Rubin-Brooks plot</p></a></li>
<li><a href='#geweke.diag'><p>Geweke's convergence diagnostic</p></a></li>
<li><a href='#geweke.plot'><p>Geweke-Brooks plot</p></a></li>
<li><a href='#heidel.diag'><p>Heidelberger and Welch's convergence diagnostic</p></a></li>
<li><a href='#HPDinterval'><p>Highest Posterior Density intervals</p></a></li>
<li><a href='#line'><p>Simple linear regression example</p></a></li>
<li><a href='#mcmc'><p>Markov Chain Monte Carlo Objects</p></a></li>
<li><a href='#mcmc.convert'><p>Conversions of MCMC objects</p></a></li>
<li><a href='#mcmc.list'><p>Replicated Markov Chain Monte Carlo Objects</p></a></li>
<li><a href='#mcmc.subset'><p>Extract or replace parts of MCMC objects</p></a></li>
<li><a href='#mcmcUpgrade'><p>Upgrade mcmc objects in obsolete format</p></a></li>
<li><a href='#mcpar'><p>Mcpar attribute of MCMC objects</p></a></li>
<li><a href='#multi.menu'><p>Choose multiple options from a menu</p></a></li>
<li><a href='#nchain'><p>Dimensions of MCMC objects</p></a></li>
<li><a href='#plot.mcmc'><p>Summary plots of mcmc objects</p></a></li>
<li><a href='#raftery.diag'><p>Raftery and Lewis's diagnostic</p></a></li>
<li><a href='#read.and.check'><p>Read data interactively and check that it satisfies conditions</p></a></li>
<li><a href='#read.coda'><p>Read output files in CODA format</p></a></li>
<li><a href='#read.coda.interactive'><p>Read CODA output files interactively</p></a></li>
<li><a href='#read.openbugs'><p>Read CODA output files produced by OpenBUGS</p></a></li>
<li><a href='#rejectionRate'><p>Rejection Rate for Metropolis&ndash;Hastings chains</p></a></li>
<li><a href='#spectrum0'><p>Estimate spectral density at zero</p></a></li>
<li><a href='#spectrum0.ar'><p>Estimate spectral density at zero</p></a></li>
<li><a href='#summary.mcmc'><p>Summary statistics for  Markov Chain Monte Carlo chains</p></a></li>
<li><a href='#thin'><p>Thinning interval</p></a></li>
<li><a href='#time.mcmc'><p>Time attributes for mcmc objects</p></a></li>
<li><a href='#traceplot'><p>Trace plot of MCMC output</p></a></li>
<li><a href='#trellisplots'><p>Trellis plots for mcmc objects</p></a></li>
<li><a href='#varnames'><p>Named dimensions of MCMC objects</p></a></li>
<li><a href='#window.mcmc'><p>Time windows for mcmc objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.19-4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Output Analysis and Diagnostics for MCMC</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for summarizing and plotting the
	output from Markov Chain Monte Carlo (MCMC) simulations, as
	well as diagnostic tests of convergence to the equilibrium
	distribution of the Markov chain.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 09:50:53 UTC; ripley</td>
</tr>
<tr>
<td>Author:</td>
<td>Martyn Plummer [aut, cre, trl],
  Nicky Best [aut],
  Kate Cowles [aut],
  Karen Vines [aut],
  Deepayan Sarkar [aut],
  Douglas Bates [aut],
  Russell Almond [aut],
  Arni Magnusson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martyn Plummer &lt;martyn.plummer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 09:52:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.ts.mcmc'>Coerce mcmc object to time series</h2><span id='topic+as.ts.mcmc'></span>

<h3>Description</h3>

<p>the <code>as.ts</code> method for <code>mcmc</code> objects coerces an mcmc object to a time series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
as.ts(x,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ts.mcmc_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="as.ts.mcmc_+3A_...">...</code></td>
<td>
<p>unused arguments for compatibility with generic <code>as.ts</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+as.ts">as.ts</a></code>
</p>

<hr>
<h2 id='autocorr'>Autocorrelation function for Markov chains</h2><span id='topic+autocorr'></span>

<h3>Description</h3>

<p><code>autocorr</code> calculates the autocorrelation function for the
Markov chain <code>mcmc.obj</code> at the lags given by <code>lags</code>.
The lag values are taken to be relative to the thinning interval
if <code>relative=TRUE</code>.
</p>
<p>High autocorrelations within chains indicate slow mixing and, usually,
slow convergence. It may be useful to thin out a chain with high
autocorrelations before calculating summary statistics: a thinned
chain may contain most of the information, but take up less space in
memory. Re-running the MCMC sampler with a different parameterization
may help to reduce autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr(x, lags = c(0, 1, 5, 10, 50), relative=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorr_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="autocorr_+3A_lags">lags</code></td>
<td>
<p>a vector of lags at which to calculate the autocorrelation</p>
</td></tr>
<tr><td><code id="autocorr_+3A_relative">relative</code></td>
<td>
<p>a logical flag. TRUE if lags are relative to the thinning
interval of the chain, or FALSE if they are absolute difference in iteration
numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or array containing the autocorrelations.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="#topic+autocorr.plot">autocorr.plot</a></code>.
</p>

<hr>
<h2 id='autocorr.diag'>Autocorrelation function for Markov chains</h2><span id='topic+autocorr.diag'></span><span id='topic+autocorr.diag.mcmc'></span><span id='topic+autocorr.diag.mcmc.list'></span>

<h3>Description</h3>

<p><code>autocorr.diag</code> calculates the autocorrelation function for the
Markov chain <code>mcmc.obj</code> at the lags given by <code>lags</code>.
The lag values are taken to be relative to the thinning interval
if <code>relative=TRUE</code>.  Unlike <code>autocorr</code>, if <code>mcmc.obj</code>
has many parmeters it only computes the autocorrelations with itself and
not the cross correlations.  In cases where <code>autocorr</code> would
return a matrix, this function returns the diagonal of the matrix.
Hence it is more useful for chains with many parameters, but may not
be as helpful at spotting parameters. 
</p>
<p>If <code>mcmc.obj</code> is of class <code>mcmc.list</code> then the returned
vector is the average autocorrelation across all chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr.diag(mcmc.obj, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorr.diag_+3A_mcmc.obj">mcmc.obj</code></td>
<td>
<p>an object of class <code>mcmc</code> or <code>mcmc.list</code></p>
</td></tr>
<tr><td><code id="autocorr.diag_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>autocorr</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the autocorrelations.
</p>


<h3>Author(s)</h3>

<p>Russell Almond</p>


<h3>See Also</h3>

<p><code><a href="#topic+autocorr">autocorr</a></code>, <code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="#topic+autocorr.plot">autocorr.plot</a></code>.
</p>

<hr>
<h2 id='autocorr.plot'>Plot autocorrelations for Markov Chains</h2><span id='topic+autocorr.plot'></span>

<h3>Description</h3>

<p>Plots the autocorrelation function for each variable in each chain in x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr.plot(x, lag.max, auto.layout = TRUE, ask, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorr.plot_+3A_x">x</code></td>
<td>
<p>A Markov Chain</p>
</td></tr>
<tr><td><code id="autocorr.plot_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum value at which to calculate acf</p>
</td></tr>
<tr><td><code id="autocorr.plot_+3A_auto.layout">auto.layout</code></td>
<td>
<p>If <code>TRUE</code> then, set up own layout for
plots, otherwise use existing one.</p>
</td></tr>
<tr><td><code id="autocorr.plot_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code> then prompt user before displaying
each page of plots.  Default is <code>dev.interactive()</code> in
R and <code>interactive()</code> in S-PLUS.</p>
</td></tr>
<tr><td><code id="autocorr.plot_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+autocorr">autocorr</a></code>.
</p>

<hr>
<h2 id='batchSE'>Batch Standard Error</h2><span id='topic+batchSE'></span>

<h3>Description</h3>

<p>Effective standard deviation of population to produce the correct
standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchSE(x, batchSize=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchSE_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object.</p>
</td></tr>
<tr><td><code id="batchSE_+3A_batchsize">batchSize</code></td>
<td>
<p>Number of observations to include in each batch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of the autocorrelation, the usual method of taking
<code>var(x)/n</code> overstates the precision of the estimate.  This method
works around the problem by looking at the means of batches of the
parameter.  If the batch size is large enough, the batch means should
be approximately uncorrelated and the normal formula for computing the
standard error should work.
</p>
<p>The batch standard error procedure is usually thought to be not as
accurate as the time series methods used in <code>summary</code> and
<code>effectiveSize</code>.  It is included here for completeness.
</p>


<h3>Value</h3>

<p>A vector giving the standard error for each column of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Russell Almond</p>


<h3>References</h3>

<p>Roberts, GO (1996) Markov chain concepts related to sampling algorithms,
in Gilks, WR, Richardson, S and Spiegelhalter, DJ, <em>Markov Chain
Monte Carlo in Practice</em>, Chapman and Hall, 45-58.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectrum0.ar">spectrum0.ar</a></code>, <code><a href="#topic+effectiveSize">effectiveSize</a></code>,
<code><a href="#topic+summary.mcmc">summary.mcmc</a></code> 
</p>

<hr>
<h2 id='bugs2jags'>Convert WinBUGS data file to JAGS data file</h2><span id='topic+bugs2jags'></span>

<h3>Description</h3>

<p><code>bugs2jags</code> converts a WinBUGS data in the format called &quot;S-Plus&quot;
(i.e. the format created by the <code>dput</code> function) and writes it in
<code>dump</code> format used by JAGS.
</p>
<p>NB WinBUGS stores its arrays in row order.  This is different
from R and JAGS which both store arrays in column order. This
difference is taken into account by <code>bugs2jags</code> which will
automatically reorder the data in arrays, without changing the
dimension.
</p>
<p>Not yet available in S-PLUS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bugs2jags(infile, outfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bugs2jags_+3A_infile">infile</code></td>
<td>
<p>name of the input file</p>
</td></tr>
<tr><td><code id="bugs2jags_+3A_outfile">outfile</code></td>
<td>
<p>name of the output file</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the input file is saved from WinBUGS, it must be saved in plain text
format. The default format for files saved from WinBUGS is a binary
compound document format (with extension odc) that cannot be read by
bugs2jags.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Spiegelhalter DJ, Thomas A, Best NG and Lunn D (2003).
<em>WinBUGS version 1.4 user manual</em>
MRC Biostatistics Unit, Cambridge, UK.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dput">dput</a></code>, 
<code><a href="base.html#topic+dump">dump</a></code>.
</p>

<hr>
<h2 id='coda.options'>Options settings for the codamenu driver</h2><span id='topic+coda.options'></span><span id='topic+display.coda.options'></span><span id='topic+.Coda.Options'></span><span id='topic+.Coda.Options.Default'></span>

<h3>Description</h3>

<p><code>coda.options</code> is a utility function that queries and sets
options for the <code>codamenu()</code> function.  These settings affect
the behaviour of the functions in the coda library only when they
are called via the <code>codamenu()</code> interface.
</p>
<p>The <code>coda.options()</code> function behaves just like the
<code>options()</code> function in the base library, with the additional
feature that <code>coda.options(default=TRUE)</code> will reset all options
to the default values.
</p>
<p>Options can be pretty-printed using the <code>display.coda.options()</code>
function, which groups the options into sections.
</p>
<p>Available options are
</p>

<dl>
<dt>bandwidth</dt><dd><p>Bandwidth function used when smoothing samples to
produce density estimates.  Defaults to Silverman's &ldquo;Rule of thumb&rdquo;.</p>
</dd>
<dt>combine.corr</dt><dd><p>Logical option that determines whether to
combine multiple chains when calculating cross-correlations.</p>
</dd>
<dt>combine.plots</dt><dd><p>Logical option that determines whether to
combine multiple chains when plotting.</p>
</dd>
<dt>combine.plots</dt><dd><p>Logical option that determines whether to
combine multiple chains when calculating summary statistics.</p>
</dd>
<dt>data.saved</dt><dd><p>For internal use only.</p>
</dd>
<dt>densplot</dt><dd><p>Logical option that determines whether to plot
a density plot when plot methods are called for mcmc objects.</p>
</dd>
<dt>digits</dt><dd><p>Number of significant digits to use when printing.</p>
</dd>
<dt>frac1</dt><dd><p>For Geweke diagnostic, fraction to use from
start of chain.  Defaults to 0.1</p>
</dd>
<dt>frac2</dt><dd><p>For Geweke diagnostic, fraction to use from
end of chain.  Default to 0.5.</p>
</dd>
<dt>gr.bin</dt><dd><p>For Geweke-Brooks plot, number of iterations to use
per bin.</p>
</dd>
<dt>gr.max</dt><dd><p>For Geweke-Brooks plot, maximum number of bins to
use.  This option overrides <code>gr.bin</code>.</p>
</dd>
<dt>halfwidth</dt><dd><p>For Heidelberger and Welch diagnostic, the target
value for the ratio of half width to sample mean.</p>
</dd>
<dt>lowess</dt><dd><p>Logical option that controls whether to plot a 
smooth line through a trace plot when plotting MCMC output.</p>
</dd>
<dt>q</dt><dd><p>For Raftery and Lewis diagnostic, the target quantile to
be estimated</p>
</dd>
<dt>r</dt><dd><p>For Raftery and Lewis diagnostic, the required precision.</p>
</dd>
<dt>s</dt><dd><p>For Raftery and Lewis diagnostic, the probability of
obtaining an estimate in the interval (q-r, q+r).</p>
</dd>
<dt>quantiles</dt><dd><p>Vector of quantiles to print when calculating
summary statistics for MCMC output.</p>
</dd>
<dt>trace</dt><dd><p>Logical option that determines whether to plot a trace
of the sampled output when plotting MCMC output.</p>
</dd>
<dt>user.layout</dt><dd><p>Logical option that determines whether current
value of par(&quot;mfrow&quot;) should be used for plots (TRUE) or whether
the optimal layout should be calculated (FALSE).</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>coda.options(...)
display.coda.options(stats = FALSE, plots = FALSE, diags = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coda.options_+3A_stats">stats</code></td>
<td>
<p>logical flag: show summary statistic options?</p>
</td></tr>
<tr><td><code id="coda.options_+3A_plots">plots</code></td>
<td>
<p>logical flag: show plotting options?</p>
</td></tr>
<tr><td><code id="coda.options_+3A_diags">diags</code></td>
<td>
<p>logical flag: show plotting options?</p>
</td></tr>
<tr><td><code id="coda.options_+3A_...">...</code></td>
<td>
<p>list of options</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>
</p>

<hr>
<h2 id='codamenu'>Main menu driver for the coda package</h2><span id='topic+codamenu'></span>

<h3>Description</h3>

<p><code>codamenu</code> presents a simple menu-based interface to the functions
in the coda package.  It is designed for users who know nothing about
the R/S language.</p>


<h3>Usage</h3>

<pre><code class='language-R'>codamenu()
</code></pre>


<h3>Author(s)</h3>

<p>Kate Cowles, Nicky Best, Karen Vines, Martyn Plummer</p>

<hr>
<h2 id='Cramer'>The Cramer-von Mises Distribution</h2><span id='topic+pcramer'></span>

<h3>Description</h3>

<p>Distribution function of the Cramer-von Mises distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pcramer(q, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cramer_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Cramer_+3A_eps">eps</code></td>
<td>
<p>accuracy required</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pcramer</code> gives the distribution function,
</p>


<h3>References</h3>

<p>Anderson TW. and Darling DA. Asymptotic theory of certain 'goodness
of fit' criteria based on stochastic processes.  <em>Ann. Math.
Statist.</em>, <b>23</b>, 192-212 (1952).
</p>
<p>Csorgo S. and Faraway, JJ. The exact and asymptotic distributions of
the Cramer-von Mises statistic.  J. Roy. Stat. Soc. (B), <b>58</b>,
221-234 (1996).
</p>

<hr>
<h2 id='crosscorr'>Cross correlations for MCMC output</h2><span id='topic+crosscorr'></span>

<h3>Description</h3>

<p><code>crosscorr</code> calculates cross-correlations between
variables in Markov Chain Monte Carlo output. If <code>x</code>
is an mcmc.list then all chains in <code>x</code> are combined
before calculating the correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscorr(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosscorr_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> or <code>mcmc.list</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or 3-d array containing the correlations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crosscorr.plot">crosscorr.plot</a></code>, <code><a href="#topic+autocorr">autocorr</a></code>.
</p>

<hr>
<h2 id='crosscorr.plot'>Plot image of correlation matrix</h2><span id='topic+crosscorr.plot'></span>

<h3>Description</h3>

<p><code>crosscorr.plot</code> provides an image of the correlation matrix for
<code>x</code>. If <code>x</code> is an <code>mcmc.list</code> object, then all chains
are combined.
</p>
<p>The range [-1,1] is divided into a number of equal-length categories
given by the length of <code>col</code> and assigned the corresponding color.
By default, topographic colours are used as this makes it easier to
distinguish positive and negative correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosscorr.plot (x, col = topo.colors(10), ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosscorr.plot_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="crosscorr.plot_+3A_col">col</code></td>
<td>
<p>color palette to use</p>
</td></tr>
<tr><td><code id="crosscorr.plot_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+crosscorr">crosscorr</a></code>, <code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>.
</p>

<hr>
<h2 id='cumuplot'>Cumulative quantile plot</h2><span id='topic+cumuplot'></span>

<h3>Description</h3>

<p>Plots the evolution of the sample quantiles as a function of the
number of iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cumuplot(x, probs=c(0.025,0.5,0.975), ylab="",
           lty=c(2,1), lwd=c(1,2), type="l", ask,
           auto.layout=TRUE, col=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumuplot_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> object</p>
</td></tr>
<tr><td><code id="cumuplot_+3A_probs">probs</code></td>
<td>
<p>vector of desired quantiles</p>
</td></tr>
<tr><td><code id="cumuplot_+3A_ylab">ylab</code>, <code id="cumuplot_+3A_lty">lty</code>, <code id="cumuplot_+3A_lwd">lwd</code>, <code id="cumuplot_+3A_type">type</code>, <code id="cumuplot_+3A_col">col</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
<tr><td><code id="cumuplot_+3A_auto.layout">auto.layout</code></td>
<td>
<p>If <code>TRUE</code>, then set up own layout for
plots, otherwise use existing one.</p>
</td></tr>
<tr><td><code id="cumuplot_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code> then prompt user before displaying
each page of plots.  Default is <code>dev.interactive()</code> in
R and <code>interactive()</code> in S-PLUS.</p>
</td></tr>
<tr><td><code id="cumuplot_+3A_...">...</code></td>
<td>
<p>further graphical parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arni Magnusson</p>

<hr>
<h2 id='densplot'>Probability density function estimate from MCMC output</h2><span id='topic+densplot'></span>

<h3>Description</h3>

<p>Displays a plot of the density estimate for each variable in <code>x</code>,
calculated by the <code>density</code> function. For discrete-valued
variables, a histogram is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densplot(x, show.obs = TRUE, bwf, 
                ylim, xlab, ylab = "", type="l", main, right=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densplot_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="densplot_+3A_show.obs">show.obs</code></td>
<td>
<p>Show observations along the x-axis</p>
</td></tr>
<tr><td><code id="densplot_+3A_bwf">bwf</code></td>
<td>
<p>Function for calculating the bandwidth.  If omitted,
the bandwidth is calculate by 1.06 times the minimum of the standard
deviation and the interquartile range divided by 1.34 times the sample
size to the negative one fifth power</p>
</td></tr>
<tr><td><code id="densplot_+3A_ylim">ylim</code></td>
<td>
<p>Limits on y axis.  See <code>plot.window</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label. By default this will show the sample size
and the bandwidth used for smoothing. See <code>plot</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label. By default, this is blank. See <code>plot</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_type">type</code></td>
<td>
<p>Plot type. See <code>plot</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_main">main</code></td>
<td>
<p>An overall title for the plot. See <code>title</code></p>
</td></tr>
<tr><td><code id="densplot_+3A_right">right</code></td>
<td>
<p>Logical flag for discrete-valued distributions passed to
the <code>hist</code> function. See Details</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="densplot_+3A_...">...</code></td>
<td>
<p>Further graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For discrete-valued distributions, a histogram is produced and values
are aggregated using the pretty() function. By default, tick marks
appear to the right of the corresponding bar in the histogram and give
the inclusive upper limit of the hist (<code>right=TRUE</code>). This can be
modified by specifying <code>right=FALSE</code>. In this case tick marks
appear on the left and specify the inclusive lower limit of the bar.
</p>
<p>For continous distributions, if a variable is bounded below at 0, or
bounded in the interval [0,1], then the data are reflected at the
boundary before being passed to the density() function. This allows
correct estimation of a non-zero density at the boundary.
</p>


<h3>Note</h3>

<p>You can call this function directly, but it is more usually called by
the <code>plot.mcmc</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+plot.mcmc">plot.mcmc</a></code>.
</p>

<hr>
<h2 id='effectiveSize'>Effective sample size for estimating the mean</h2><span id='topic+effectiveSize'></span>

<h3>Description</h3>

<p>Sample size adjusted for autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveSize(x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectiveSize_+3A_x">x</code></td>
<td>
<p>An mcmc or mcmc.list object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a time series <code>x</code> of length <code>N</code>, the standard error of the
mean is the square root of <code>var(x)/n</code> where <code>n</code> is the
effective sample size.  <code>n = N</code> only when there is no
autocorrelation.
</p>
<p>Estimation of the effective sample size requires estimating the
spectral density at frequency zero.  This is done by the function
<code>spectrum0.ar</code>
</p>
<p>For a <code>mcmc.list</code> object, the effective sizes are summed across
chains.  To get the size for each chain individually use
<code>lapply(x,effectiveSize)</code>.  
</p>


<h3>Value</h3>

<p>A vector giving the effective sample size for each column of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectrum0.ar">spectrum0.ar</a></code>.
</p>

<hr>
<h2 id='gelman.diag'>Gelman and Rubin's convergence diagnostic</h2><span id='topic+gelman.diag'></span>

<h3>Description</h3>

<p>The &lsquo;potential scale reduction factor&rsquo; is calculated for each variable in
<code>x</code>, together with upper and lower confidence limits. Approximate
convergence is diagnosed when the upper limit is close to 1. For
multivariate chains, a multivariate value is calculated that bounds
above the potential scale reduction factor for any linear combination
of the (possibly transformed) variables.
</p>
<p>The confidence limits are based on the assumption that the stationary
distribution of the variable under examination is normal. Hence the
&lsquo;transform&rsquo; parameter may be used to improve the normal approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelman.diag(x, confidence = 0.95, transform=FALSE, autoburnin=TRUE,
                   multivariate=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelman.diag_+3A_x">x</code></td>
<td>
<p>An <code>mcmc.list</code> object with more than one chain,
and with starting values that are overdispersed with respect to the
posterior distribution.</p>
</td></tr>
<tr><td><code id="gelman.diag_+3A_confidence">confidence</code></td>
<td>
<p>the coverage probability of the confidence interval for the
potential scale reduction factor</p>
</td></tr>
<tr><td><code id="gelman.diag_+3A_transform">transform</code></td>
<td>
<p>a logical flag indicating whether variables in
<code>x</code> should be transformed to improve the normality of the
distribution. If set to TRUE, a log transform or logit transform, as
appropriate, will be applied.</p>
</td></tr>
<tr><td><code id="gelman.diag_+3A_autoburnin">autoburnin</code></td>
<td>
<p>a logical flag indicating whether only the second half
of the series should be used in the computation.  If set to TRUE
(default) and <code>start(x)</code> is less than <code>end(x)/2</code> then start
of series will be adjusted so that only second half of series is used.</p>
</td></tr>
<tr><td><code id="gelman.diag_+3A_multivariate">multivariate</code></td>
<td>
<p>a logical flag indicating whether the multivariate
potential scale reduction factor should be calculated for multivariate
chains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gelman.diag</code>. This is a list with the
following elements:
</p>
<table>
<tr><td><code>psrf</code></td>
<td>
<p>A list containing the point estimates of the potential
scale reduction factor (labelled <code>Point est.</code>)  and their upper
confidence limits (labelled <code>Upper C.I.</code>).</p>
</td></tr>
<tr><td><code>mpsrf</code></td>
<td>
<p>The point estimate of the multivariate potential scale reduction
factor. This is NULL if there is only one variable in <code>x</code>.</p>
</td></tr>
</table>
<p>The <code>gelman.diag</code> class has its own <code>print</code> method.
</p>


<h3>Theory</h3>

<p>Gelman and Rubin (1992) propose a general approach to monitoring
convergence of MCMC output in which <code class="reqn">m &gt; 1</code> parallel chains are run
with starting values that are overdispersed relative to the posterior
distribution. Convergence is diagnosed when the chains have &lsquo;forgotten&rsquo;
their initial values, and the output from all chains is
indistinguishable.  The <code>gelman.diag</code> diagnostic is applied to a
single variable from the chain. It is based a comparison of within-chain
and between-chain variances, and is similar to a classical analysis of
variance.
</p>
<p>There are two ways to estimate the variance of the stationary distribution:
the mean of the empirical variance within each chain, <code class="reqn">W</code>, and
the empirical variance from all chains combined, which can be expressed as
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{\sigma}^2 = 
  \frac{(n-1) W }{n} + \frac{B}{n} </code>
</p>

<p>where <code class="reqn">n</code> is the number of iterations and <code class="reqn">B/n</code> is the empirical
between-chain variance.
</p>
<p>If the chains have converged, then both estimates are
unbiased. Otherwise the first method will <em>underestimate</em> the
variance, since the individual chains have not had time to range all
over the stationary distribution, and the second method will
<em>overestimate</em> the variance, since the starting points were chosen
to be overdispersed.
</p>
<p>The convergence diagnostic is based on the assumption that the
target distribution is normal. A Bayesian credible interval can
be constructed using a t-distribution with mean
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mu}=\mbox{Sample mean of all chains
combined}</code>
</p>

<p>and variance
</p>
<p style="text-align: center;"><code class="reqn">\widehat{V}=\widehat{\sigma}^2 + \frac{B}{mn}</code>
</p>

<p>and degrees of freedom estimated by the method of moments
</p>
<p style="text-align: center;"><code class="reqn">d = \frac{2*\widehat{V}^2}{\mbox{Var}(\widehat{V})}</code>
</p>

<p>Use of the t-distribution accounts for the fact that the mean
and variance of the posterior distribution are estimated.
</p>
<p>The convergence diagnostic itself is
</p>
<p style="text-align: center;"><code class="reqn">R=\sqrt{\frac{(d+3) \widehat{V}}{(d+1)W}}</code>
</p>

<p>Values substantially above 1 indicate lack of convergence.  If the
chains have not converged, Bayesian credible intervals based on the
t-distribution are too wide, and have the potential to shrink by this
factor if the MCMC run is continued.
</p>


<h3>Note</h3>

<p>The multivariate a version of Gelman and Rubin's diagnostic was
proposed by Brooks and Gelman (1998). Unlike the univariate proportional
scale reduction factor, the multivariate version does not include an
adjustment for the estimated number of degrees of freedom.
</p>


<h3>References</h3>

<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation
using multiple sequences, <em>Statistical Science</em>, <b>7</b>, 457-511.
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring
convergence of iterative simulations. <em>Journal of Computational and
Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gelman.plot">gelman.plot</a></code>.
</p>

<hr>
<h2 id='gelman.plot'>Gelman-Rubin-Brooks plot</h2><span id='topic+gelman.plot'></span>

<h3>Description</h3>

<p>This plot shows the evolution of Gelman and Rubin's shrink factor as
the number of iterations increases. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelman.plot(x, bin.width = 10, max.bins = 50,
confidence = 0.95, transform = FALSE, autoburnin=TRUE, auto.layout = TRUE,
ask, col, lty, xlab, ylab, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelman.plot_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_bin.width">bin.width</code></td>
<td>
<p>Number of observations per segment, excluding the
first segment which always has at least 50 iterations.</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_max.bins">max.bins</code></td>
<td>
<p>Maximum number of bins, excluding the last one.</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_confidence">confidence</code></td>
<td>
<p>Coverage probability of confidence interval.</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_transform">transform</code></td>
<td>
<p>Automatic variable transformation (see <code>gelman.diag</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_autoburnin">autoburnin</code></td>
<td>
<p>Remove first half of sequence (see <code>gelman.diag</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_auto.layout">auto.layout</code></td>
<td>
<p>If <code>TRUE</code> then, set up own layout for
plots, otherwise use existing one.</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_ask">ask</code></td>
<td>
<p>Prompt user before displaying each page of plots.  Default is 
<code>dev.interactive()</code> in R and <code>interactive()</code> in S-PLUS.</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_col">col</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_lty">lty</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_type">type</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="gelman.plot_+3A_...">...</code></td>
<td>
<p>further graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Markov chain is divided into bins according to the arguments
<code>bin.width</code> and <code>max.bins</code>. Then the Gelman-Rubin shrink factor
is repeatedly calculated. The first shrink factor is calculated with
observations 1:50, the second with observations <code class="reqn">1:(50+bin.width)</code>,
the third contains samples <code class="reqn">1:(50+2*bin.width)</code> and so on.
If the chain has less than <code class="reqn">50 + bin.width</code> iterations then
<code>gelman.diag</code> will exit with an error.
</p>


<h3>Theory</h3>

<p>A potential problem with <code>gelman.diag</code> is that it may mis-diagnose
convergence if the shrink factor happens to be close to 1 by chance.
By calculating the shrink factor at several points in time,
<code>gelman.plot</code> shows if the shrink factor has really converged, or
whether it is still fluctuating.
</p>


<h3>References</h3>

<p>Brooks, S P. and Gelman, A. (1998) General Methods for Monitoring
Convergence of Iterative Simulations. <em>Journal of Computational and
Graphical Statistics</em>, <b>7</b>, 434-455.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gelman.diag">gelman.diag</a></code>.
</p>

<hr>
<h2 id='geweke.diag'>Geweke's convergence diagnostic</h2><span id='topic+geweke.diag'></span>

<h3>Description</h3>

<p>Geweke (1992) proposed a convergence diagnostic for Markov chains
based on a test for equality of the means of the first and last part
of a Markov chain (by default the first 10% and the last 50%).  If the
samples are drawn from the stationary distribution of the chain, the two
means are equal and Geweke's statistic has an asymptotically standard
normal distribution.
</p>
<p>The test statistic is a standard Z-score: the difference between the
two sample means divided by its estimated standard error.  The standard
error is estimated from the spectral density at zero and so takes into
account any autocorrelation.
</p>
<p>The Z-score is calculated under the assumption that the two parts of
the chain are asymptotically independent, which requires that the sum
of <code>frac1</code> and <code>frac2</code> be strictly less than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geweke.diag(x, frac1=0.1, frac2=0.5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geweke.diag_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="geweke.diag_+3A_frac1">frac1</code></td>
<td>
<p>fraction to use from beginning of chain</p>
</td></tr>
<tr><td><code id="geweke.diag_+3A_frac2">frac2</code></td>
<td>
<p>fraction to use from end of chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Z-scores for a test of equality of means
between the first and last parts of the chain. A separate
statistic is calculated for each variable in each chain.
</p>


<h3>References</h3>

<p>Geweke, J. Evaluating the accuracy of sampling-based approaches
to calculating posterior moments. In <em>Bayesian Statistics 4</em>
(ed JM Bernado, JO Berger, AP Dawid and AFM Smith). Clarendon Press,
Oxford, UK.</p>


<h3>See Also</h3>

<p><code><a href="#topic+geweke.plot">geweke.plot</a></code>.
</p>

<hr>
<h2 id='geweke.plot'>Geweke-Brooks plot</h2><span id='topic+geweke.plot'></span>

<h3>Description</h3>

<p>If <code>geweke.diag</code> indicates that the first and last part of a sample
from a Markov chain are not drawn from the same distribution, it may
be useful to discard the first few iterations to see if the rest of the
chain has &quot;converged&quot;. This plot shows what happens to Geweke's Z-score
when successively larger numbers of iterations are discarded from the
beginning of the chain. To preserve the asymptotic conditions required
for Geweke's diagnostic, the plot never discards more than half the chain.
</p>
<p>The first half of the Markov chain is divided into <code>nbins - 1</code>
segments, then Geweke's Z-score is repeatedly calculated. The first
Z-score is calculated with all iterations in the chain, the second
after discarding the first segment, the third after discarding the first
two segments, and so on. The last Z-score is calculated using only the
samples in the second half of the chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geweke.plot(x, frac1 = 0.1, frac2 = 0.5, nbins = 20,
            pvalue = 0.05, auto.layout = TRUE, ask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geweke.plot_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_frac1">frac1</code></td>
<td>
<p>fraction to use from beginning of chain.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_frac2">frac2</code></td>
<td>
<p>fraction to use from end of chain.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_nbins">nbins</code></td>
<td>
<p>Number of segments.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_pvalue">pvalue</code></td>
<td>
<p>p-value used to plot confidence limits for the null hypothesis.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_auto.layout">auto.layout</code></td>
<td>
<p>If <code>TRUE</code> then, set up own layout for
plots, otherwise use existing one.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code> then prompt user before displaying
each page of plots.  Default is <code>dev.interactive()</code> in
R and <code>interactive()</code> in S-PLUS.</p>
</td></tr>
<tr><td><code id="geweke.plot_+3A_...">...</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The graphical implementation of Geweke's diagnostic was suggested
by Steve Brooks.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geweke.diag">geweke.diag</a></code>.
</p>

<hr>
<h2 id='heidel.diag'>Heidelberger and Welch's convergence diagnostic</h2><span id='topic+heidel.diag'></span>

<h3>Description</h3>

<p><code>heidel.diag</code> is a run length control diagnostic based on a criterion
of relative accuracy for the estimate of the mean.  The default setting
corresponds to a relative accuracy of two significant digits.
</p>
<p><code>heidel.diag</code> also implements a convergence diagnostic, and removes
up to half the chain in order to ensure that the means are estimated
from a chain that has converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heidel.diag(x, eps=0.1, pvalue=0.05)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heidel.diag_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> object</p>
</td></tr>
<tr><td><code id="heidel.diag_+3A_eps">eps</code></td>
<td>
<p>Target value for ratio of halfwidth to sample mean</p>
</td></tr>
<tr><td><code id="heidel.diag_+3A_pvalue">pvalue</code></td>
<td>
<p>significance level to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The convergence test uses the Cramer-von-Mises statistic to test the null
hypothesis that the sampled values come from a stationary distribution.
The test is successively applied, firstly  to the whole chain, then after
discarding the first 10%, 20%, ... of the chain until either the null
hypothesis is accepted, or 50% of the chain has been discarded. The latter
outcome constitutes &lsquo;failure&rsquo; of the stationarity test and indicates
that a longer MCMC run is needed. If the stationarity test is passed,
the number of iterations to keep and the number to discard are reported.
</p>
<p>The half-width test calculates a 95% confidence interval for the
mean, using the portion of the chain which passed the stationarity test.
Half the width of this interval is compared with the estimate of the mean.
If the ratio between the half-width and the mean is lower than <code>eps</code>,
the halfwidth test is passed. Otherwise the length of the sample is
deemed not long enough to estimate the mean with sufficient accuracy.
</p>


<h3>Theory</h3>

<p>The <code>heidel.diag</code> diagnostic is based on the work of Heidelberger
and Welch (1983), who combined their earlier work on simulation run
length control (Heidelberger and Welch, 1981) with the work of Schruben
(1982) on detecting initial transients using Brownian bridge theory.
</p>


<h3>Note</h3>

<p>If the half-width test fails then the run should be extended.  In order
to avoid problems caused by sequential testing, the test should not
be repeated too frequently.  Heidelberger and Welch (1981) suggest
increasing the run length by a factor I &gt; 1.5, each time, so that 
estimate has the same, reasonably large, proportion of new data.
</p>


<h3>References</h3>

<p>Heidelberger P and Welch PD. A spectral method for confidence interval
generation and run length control in simulations. Comm. ACM. <b>24</b>,
233-245 (1981)
</p>
<p>Heidelberger P and Welch PD. Simulation run length control in the 
presence of an initial transient. <em>Opns Res.</em>, <b>31</b>,
1109-44 (1983)
</p>
<p>Schruben LW. Detecting initialization bias in simulation experiments.
<em>Opns. Res.</em>, <b>30</b>, 569-590 (1982).
</p>

<hr>
<h2 id='HPDinterval'>Highest Posterior Density intervals</h2><span id='topic+HPDinterval'></span><span id='topic+HPDinterval.mcmc'></span><span id='topic+HPDinterval.mcmc.list'></span>

<h3>Description</h3>

<p>Create Highest Posterior Density (HPD) intervals for the parameters in
an MCMC sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPDinterval(obj, prob = 0.95, ...)
## S3 method for class 'mcmc'
HPDinterval(obj, prob = 0.95, ...)
## S3 method for class 'mcmc.list'
HPDinterval(obj, prob = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPDinterval_+3A_obj">obj</code></td>
<td>
<p>The object containing the MCMC sample - usually of class
<code>"mcmc"</code> or <code>"mcmc.list"</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="HPDinterval_+3A_prob">prob</code></td>
<td>
<p>A numeric scalar in the interval (0,1) giving the target
probability content of the intervals.  The nominal probability
content of the intervals is the multiple of <code>1/nrow(obj)</code>
nearest to <code>prob</code>.</p>
</td></tr>
<tr><td><code id="HPDinterval_+3A_...">...</code></td>
<td>
<p>Optional additional arguments for methods.  None are used
at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each parameter the interval is constructed from the empirical cdf
of the sample as the shortest interval for which the difference in
the ecdf values of the endpoints is the nominal probability.  Assuming
that the distribution is not severely multimodal, this is the HPD interval.
</p>


<h3>Value</h3>

<p>For an <code>"mcmc"</code> object, a matrix with columns <code>"lower"</code> and
<code>"upper"</code> and rows corresponding to the parameters.  The
attribute <code>"Probability"</code> is the nominal probability content of
the intervals.  A list of such matrices is returned for an
<code>"mcmc.list"</code> object.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(line)
HPDinterval(line)
</code></pre>

<hr>
<h2 id='line'>Simple linear regression example</h2><span id='topic+line'></span>

<h3>Description</h3>

<p>Sample MCMC output from a simple linear regression model given in
the BUGS manual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(line)</code></pre>


<h3>Format</h3>

<p>An <code>mcmc</code> object</p>


<h3>Source</h3>

<p>Spiegelhalter, D.J., Thomas, A., Best, N.G. and Gilks, W.R. (1995)
BUGS: Bayesian inference using Gibbs Sampling, Version 0.5, 
MRC Biostatistics Unit, Cambridge.
</p>

<hr>
<h2 id='mcmc'>Markov Chain Monte Carlo Objects</h2><span id='topic+mcmc'></span><span id='topic+as.mcmc'></span><span id='topic+as.mcmc.default'></span><span id='topic+is.mcmc'></span><span id='topic+print.mcmc'></span>

<h3>Description</h3>

<p>The function <code>mcmc</code> is used to create a Markov Chain Monte Carlo
object.  The input data are taken to be a vector, or a matrix with
one column per variable.
</p>
<p>If the optional arguments <code>start</code>, <code>end</code>, and <code>thin</code>
are omitted then the chain is assumed to start with iteration 1 and
have thinning interval 1. If <code>data</code> represents a chain that
starts at a later iteration, the first iteration in the chain should
be given as the <code>start</code> argument. Likewise, if <code>data</code>
represents a chain that has already been thinned, the thinning
interval should be given as the <code>thin</code> argument.
</p>
<p>An mcmc object may be summarized by the <code>summary</code> function
and visualized with the <code>plot</code> function.
</p>
<p>MCMC objects resemble time series (<code>ts</code>) objects and have
methods for the generic functions <code>time</code>, <code>start</code>,
<code>end</code>, <code>frequency</code> and <code>window</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(data= NA, start = 1, end = numeric(0), thin = 1)
as.mcmc(x, ...)
is.mcmc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_+3A_data">data</code></td>
<td>
<p>a vector or  matrix of MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_+3A_start">start</code></td>
<td>
<p>the iteration number of the first observation</p>
</td></tr>
<tr><td><code id="mcmc_+3A_end">end</code></td>
<td>
<p>the iteration number of the last observation</p>
</td></tr>
<tr><td><code id="mcmc_+3A_thin">thin</code></td>
<td>
<p>the thinning interval between consecutive observations</p>
</td></tr>
<tr><td><code id="mcmc_+3A_x">x</code></td>
<td>
<p>An object that may be coerced to an mcmc object</p>
</td></tr>
<tr><td><code id="mcmc_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to specific methods</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The format of the mcmc class has changed between coda version 0.3
and 0.4.  Older mcmc objects will now cause <code>is.mcmc</code> to
fail with an appropriate warning message.  Obsolete mcmc objects can
be upgraded with the <code>mcmcUpgrade</code> function.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc.list">mcmc.list</a></code>,
<code><a href="#topic+mcmcUpgrade">mcmcUpgrade</a></code>,
<code><a href="#topic+thin">thin</a></code>,
<code><a href="#topic+window.mcmc">window.mcmc</a></code>,
<code><a href="#topic+summary.mcmc">summary.mcmc</a></code>,
<code><a href="#topic+plot.mcmc">plot.mcmc</a></code>.
</p>

<hr>
<h2 id='mcmc.convert'>Conversions of MCMC objects</h2><span id='topic+as.matrix.mcmc'></span><span id='topic+as.matrix.mcmc.list'></span><span id='topic+as.array.mcmc.list'></span><span id='topic+as.mcmc.mcmc.list'></span>

<h3>Description</h3>

<p>These are methods for the generic functions <code>as.matrix()</code>,
<code>as.array()</code> and <code>as.mcmc()</code>.
</p>
<p><code>as.matrix()</code> strips the MCMC attributes from an <code>mcmc</code>
object and returns a matrix.  If <code>iters = TRUE</code> then a
column is added with the iteration number.  For <code>mcmc.list</code>
objects, the rows of multiple chains are concatenated and, if
<code>chains = TRUE</code> a column is added with the chain number.
</p>
<p><code>mcmc.list</code> objects can be coerced to 3-dimensional arrays
with the <code>as.array()</code> function.
</p>
<p>An <code>mcmc.list</code> object with a single chain can be coerced
to an <code>mcmc</code> object with <code>as.mcmc()</code>.  If the argument
has multiple chains, this causes an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
as.matrix(x, iters = FALSE, ...)
## S3 method for class 'mcmc.list'
as.matrix(x, iters = FALSE, chains = FALSE, ...)
## S3 method for class 'mcmc.list'
as.array(x, drop, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.convert_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="mcmc.convert_+3A_iters">iters</code></td>
<td>
<p>logical flag: add column for iteration number?</p>
</td></tr>
<tr><td><code id="mcmc.convert_+3A_chains">chains</code></td>
<td>
<p>logical flag: add column for chain number? (if mcmc.list)</p>
</td></tr>
<tr><td><code id="mcmc.convert_+3A_drop">drop</code></td>
<td>
<p>logical flag: if <code>TRUE</code> the result is coerced to the
lowest possible dimension</p>
</td></tr>
<tr><td><code id="mcmc.convert_+3A_...">...</code></td>
<td>
<p>optional arguments to the various methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.matrix">as.matrix</a></code>,
<code><a href="base.html#topic+as.array">as.array</a></code>,
<code><a href="#topic+as.mcmc">as.mcmc</a></code>,
</p>

<hr>
<h2 id='mcmc.list'>Replicated Markov Chain Monte Carlo Objects</h2><span id='topic+mcmc.list'></span><span id='topic+as.mcmc.list'></span><span id='topic+as.mcmc.list.default'></span><span id='topic+is.mcmc.list'></span><span id='topic+plot.mcmc.list'></span>

<h3>Description</h3>

<p>The function &lsquo;mcmc.list&rsquo; is used to represent parallel runs of the same
chain, with different starting values and random seeds.  The list must
be balanced: each chain in the list must have the same iterations and
the same variables.
</p>
<p>Diagnostic functions which act on <code>mcmc</code> objects may also be applied
to <code>mcmc.list</code> objects. In general, the chains will be combined,
if this makes sense, otherwise the diagnostic function will be applied
separately to each chain in the list.
</p>
<p>Since all the chains in the list have the same iterations, a single time
dimension can be ascribed to the list. Hence there are time series methods
<code>time</code>, <code>window</code>, <code>start</code>, <code>end</code>, <code>frequency</code>
and <code>thin</code> for <code>mcmc.list</code> objects.
</p>
<p>An <code>mcmc.list</code> can be indexed as if it were a single mcmc object
using the <code>[</code> operator (see examples below). The <code>[[</code> operator
selects a single <code>mcmc</code> object from the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.list(...)
as.mcmc.list(x, ...)
is.mcmc.list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.list_+3A_...">...</code></td>
<td>
<p>a list of mcmc objects</p>
</td></tr>
<tr><td><code id="mcmc.list_+3A_x">x</code></td>
<td>
<p>an object that may be coerced to mcmc.list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(line)
x1 &lt;- line[[1]]                    #Select first chain
x2 &lt;- line[,1, drop=FALSE]         #Select first var from all chains
varnames(x2) == varnames(line)[1]  #TRUE
</code></pre>

<hr>
<h2 id='mcmc.subset'>Extract or replace parts of MCMC objects</h2><span id='topic++5B.mcmc'></span><span id='topic++5B.mcmc.list'></span>

<h3>Description</h3>

<p>These are methods for subsetting <code>mcmc</code> objects.  You can select
iterations using the first dimension and variables using the second
dimension.  Selecting iterations will return a vector or matrix, not an
<code>mcmc</code> object. If you want to do row-subsetting of an <code>mcmc</code>
object and preserve its dimensions, use the <code>window</code> function.
</p>
<p>Subsetting applied to an <code>mcmc.list</code> object will simultaneously 
affect all the parallel chains in the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
x[i,j, drop=missing(i)]
## S3 method for class 'mcmc.list'
x[i,j, drop=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.subset_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> object</p>
</td></tr>
<tr><td><code id="mcmc.subset_+3A_i">i</code></td>
<td>
<p>Row to extract</p>
</td></tr>
<tr><td><code id="mcmc.subset_+3A_j">j</code></td>
<td>
<p>Column to extract</p>
</td></tr>
<tr><td><code id="mcmc.subset_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, the redundant dimensions are dropped</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic++5B">[</a></code>,
<code><a href="#topic+window.mcmc">window.mcmc</a></code>
</p>

<hr>
<h2 id='mcmcUpgrade'>Upgrade mcmc objects in obsolete format</h2><span id='topic+mcmcUpgrade'></span>

<h3>Description</h3>

<p>In previous releases of CODA, an <code>mcmc</code>  object could
be a single or multiple chains.  A new class <code>mcmc.list</code>
has now been introduced to deal with multiple chains and
<code>mcmc</code> objects can only have data from a single chain.
</p>
<p>Objects stored in the old format are now obsolete
and must be upgraded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   mcmcUpgrade(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcUpgrade_+3A_x">x</code></td>
<td>
<p>an obsolete <code>mcmc</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>.
</p>

<hr>
<h2 id='mcpar'>Mcpar attribute of MCMC objects</h2><span id='topic+mcpar'></span>

<h3>Description</h3>

<p>The &lsquo;mcpar&rsquo; attribute of an MCMC object gives the start iteration
the end iteration and the thinning interval of the chain.
</p>
<p>It resembles the &lsquo;tsp&rsquo; attribute of time series (<code>ts</code>) objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcpar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcpar_+3A_x">x</code></td>
<td>
<p>An <code>mcmcm</code> or <code>mcmc.list</code> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ts">ts</a></code>,
<code><a href="#topic+mcmc">mcmc</a></code>,
<code><a href="#topic+mcmc.list">mcmc.list</a></code>,
</p>

<hr>
<h2 id='multi.menu'>Choose multiple options from a menu</h2><span id='topic+multi.menu'></span>

<h3>Description</h3>

<p><code>multi.menu</code> presents the user with a menu of choices
labelled from 1 to the number of choices.  The user may choose
one or more options by entering a comma separated list. A range
of values may also be specified using the &quot;:&quot; operator. Mixed
expressions such as &quot;1,3:5, 6&quot; are permitted.
</p>
<p>If <code>allow.zero</code> is set to TRUE, one can select &lsquo;0&rsquo; to exit
without choosing an item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.menu(choices, title, header, allow.zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi.menu_+3A_choices">choices</code></td>
<td>
<p>Character vector of labels for choices</p>
</td></tr>
<tr><td><code id="multi.menu_+3A_title">title</code></td>
<td>
<p>Title printed before menu</p>
</td></tr>
<tr><td><code id="multi.menu_+3A_header">header</code></td>
<td>
<p>Character vector of length 2 giving column titles</p>
</td></tr>
<tr><td><code id="multi.menu_+3A_allow.zero">allow.zero</code></td>
<td>
<p>Permit 0 as an acceptable response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector giving the numbers of the options selected, or
0 if no selection is made.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+menu">menu</a></code>.
</p>

<hr>
<h2 id='nchain'>Dimensions of MCMC objects</h2><span id='topic+niter'></span><span id='topic+nvar'></span><span id='topic+nchain'></span>

<h3>Description</h3>

<p>These functions give the dimensions of an MCMC object
</p>

<dl>
<dt>niter(x)</dt><dd><p>returns the number of iterations.</p>
</dd>
<dt>nvar(x)</dt><dd><p>returns the number of variables.</p>
</dd>
<dt>nchain(x)</dt><dd><p>returns the number of parallel chains.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>niter(x)
nvar(x)
nchain(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchain_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 1:
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>,
<code><a href="#topic+mcmc.list">mcmc.list</a></code>,
</p>

<hr>
<h2 id='plot.mcmc'>Summary plots of mcmc objects</h2><span id='topic+plot.mcmc'></span>

<h3>Description</h3>

<p><code>plot.mcmc</code> summarizes an mcmc or mcmc.list object
with a trace of the sampled output and a density estimate
for each variable in the chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
plot(x, trace = TRUE, density = TRUE, smooth = FALSE, bwf,
	auto.layout = TRUE, ask = dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcmc_+3A_x">x</code></td>
<td>
<p>an object of class <code>mcmc</code> or <code>mcmc.list</code></p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_trace">trace</code></td>
<td>
<p>Plot trace of each variable</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_density">density</code></td>
<td>
<p>Plot density estimate of each variable</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_smooth">smooth</code></td>
<td>
<p>Draw a smooth line through trace plots</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_bwf">bwf</code></td>
<td>
<p>Bandwidth function for density plots</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_auto.layout">auto.layout</code></td>
<td>
<p>Automatically generate output format</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_ask">ask</code></td>
<td>
<p>Prompt user before each page of plots</p>
</td></tr>
<tr><td><code id="plot.mcmc_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+densplot">densplot</a></code>, <code><a href="#topic+traceplot">traceplot</a></code>.
</p>

<hr>
<h2 id='raftery.diag'>Raftery and Lewis's diagnostic</h2><span id='topic+raftery.diag'></span>

<h3>Description</h3>

<p><code>raftery.diag</code> is a run length control diagnostic based on a
criterion of accuracy of estimation of the quantile <code>q</code>.  It is
intended for use on a short pilot run of a Markov chain.  The number
of iterations required to estimate the quantile <code class="reqn">q</code> to within an
accuracy of +/- <code class="reqn">r</code> with probability <code class="reqn">p</code> is calculated. Separate
calculations are performed for each variable within each chain.
</p>
<p>If the number of iterations in <code>data</code> is too small,
an error message is printed indicating the minimum length of
pilot run.  The minimum length is the required sample size for a
chain with no correlation between consecutive samples. Positive
autocorrelation will increase the required sample size above this
minimum value. An estimate <code>I</code> (the &lsquo;dependence factor&rsquo;) of the
extent to which autocorrelation inflates the required sample size
is also provided. Values of <code>I</code> larger than 5 indicate strong
autocorrelation which may be due to a poor choice of starting value,
high posterior correlations or &lsquo;stickiness&rsquo; of the MCMC algorithm.
</p>
<p>The number of &lsquo;burn in&rsquo; iterations to be discarded at the beginning
of the chain is also calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raftery.diag(data, q=0.025, r=0.005, s=0.95, converge.eps=0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raftery.diag_+3A_data">data</code></td>
<td>
<p>an <code>mcmc</code> object</p>
</td></tr>
<tr><td><code id="raftery.diag_+3A_q">q</code></td>
<td>
<p>the quantile to be estimated.</p>
</td></tr>
<tr><td><code id="raftery.diag_+3A_r">r</code></td>
<td>
<p>the desired margin of error of the estimate.</p>
</td></tr>
<tr><td><code id="raftery.diag_+3A_s">s</code></td>
<td>
<p>the probability of obtaining an estimate in the interval (q-r,q+r).</p>
</td></tr>
<tr><td><code id="raftery.diag_+3A_converge.eps">converge.eps</code></td>
<td>
<p>Precision required for estimate of time to convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>raftery.diag</code>.  A print method is available
for objects of this class. the contents of the list are
</p>
<table>
<tr><td><code>tspar</code></td>
<td>
<p>The time series parameters of <code>data</code></p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A vector containing the parameters <code>r</code>, <code>s</code>
and <code>q</code></p>
</td></tr>
<tr><td><code>Niters</code></td>
<td>
<p>The number of iterations in <code>data</code></p>
</td></tr>
<tr><td><code>resmatrix</code></td>
<td>
<p>A 3-d array containing the results: <code class="reqn">M</code> the
length of &quot;burn in&quot;, <code class="reqn">N</code> the required sample size, <code class="reqn">Nmin</code>
the minimum sample size based on zero autocorrelation and 
<code class="reqn">I = (M+N)/Nmin</code> the &quot;dependence factor&quot;</p>
</td></tr>
</table>


<h3>Theory</h3>

<p>The estimated sample size for variable U is based on the process <code class="reqn">Z_t
   = d(U_t &lt;= u)</code> where <code class="reqn">d</code> is the indicator function and u is the
qth quantile of U. The process <code class="reqn">Z_t</code> is derived from the Markov
chain <code>data</code> by marginalization and truncation, but is not itself
a Markov chain.  However, <code class="reqn">Z_t</code> may behave as a Markov chain if
it is sufficiently thinned out.  <code>raftery.diag</code> calculates the
smallest value of thinning interval <code class="reqn">k</code> which makes the thinned
chain <code class="reqn">Z^k_t</code> behave as a Markov chain. The required sample size is
calculated from this thinned sequence.  Since some data is &lsquo;thrown away&rsquo;
the sample size estimates are conservative.
</p>
<p>The criterion for the number of &lsquo;burn in&rsquo; iterations <code class="reqn">m</code> to be
discarded, is that the conditional distribution of <code class="reqn">Z^k_m</code>
given <code class="reqn">Z_0</code> should be within <code>converge.eps</code> of the equilibrium
distribution of the chain <code class="reqn">Z^k_t</code>.
</p>


<h3>Note</h3>

<p><code>raftery.diag</code> is based on the FORTRAN program &lsquo;gibbsit&rsquo; 
written by Steven Lewis, and available from the Statlib archive.
</p>


<h3>References</h3>

<p>Raftery, A.E. and Lewis, S.M. (1992).  One long run with diagnostics:
Implementation strategies for Markov chain Monte Carlo.
<em>Statistical Science</em>, <b>7</b>, 493-497.
</p>
<p>Raftery, A.E. and Lewis, S.M. (1995).  The number of iterations,
convergence diagnostics and generic Metropolis algorithms.  <em>In</em>
Practical Markov Chain Monte Carlo (W.R. Gilks, D.J. Spiegelhalter
and S. Richardson, eds.). London, U.K.: Chapman and Hall.
</p>

<hr>
<h2 id='read.and.check'>Read data interactively and check that it satisfies conditions</h2><span id='topic+read.and.check'></span>

<h3>Description</h3>

<p>Input is read interactively and checked against conditions specified
by the arguments <code>what</code>, <code>lower</code>, <code>upper</code> and
<code>answer.in</code>. If the input does not satisfy all the conditions,
an appropriate error message is produced and the user is prompted
to provide input. This process is repeated until a valid input value
is entered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.and.check(message = "", what = numeric(), lower, upper, answer.in,
default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.and.check_+3A_message">message</code></td>
<td>
<p>message displayed before prompting for user input.</p>
</td></tr>
<tr><td><code id="read.and.check_+3A_what">what</code></td>
<td>
<p>the type of <code>what</code> gives the type of data to be read.</p>
</td></tr>
<tr><td><code id="read.and.check_+3A_lower">lower</code></td>
<td>
<p>lower limit of input, for numeric input only.</p>
</td></tr>
<tr><td><code id="read.and.check_+3A_upper">upper</code></td>
<td>
<p>upper limit of input, for numeric input only.</p>
</td></tr>
<tr><td><code id="read.and.check_+3A_answer.in">answer.in</code></td>
<td>
<p>the input must correspond to one of the elements of the
vector <code>answer.in</code>, if supplied.</p>
</td></tr>
<tr><td><code id="read.and.check_+3A_default">default</code></td>
<td>
<p>value assumed if user enters a blank line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the valid input.  When the <code>default</code> argument is
specified, a blank line is accepted as valid input and in this case
<code>read.and.check</code> returns the value of <code>default</code>.
</p>


<h3>Note</h3>

<p>Since the function does not return a value until it receives valid
input, it extensively checks the conditions for consistency before
prompting the user for input.  Inconsistent conditions will cause
an error.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>

<hr>
<h2 id='read.coda'>Read output files in CODA format</h2><span id='topic+read.coda'></span><span id='topic+read.jags'></span>

<h3>Description</h3>

<p><code>read.coda</code> reads Markov Chain Monte Carlo output in
the CODA format produced by OpenBUGS and JAGS. By default, all
of the data in the file is read, but the arguments <code>start</code>,
<code>end</code> and <code>thin</code> may be used to read a subset of the
data.  If the arguments given to <code>start</code>, <code>end</code> or
<code>thin</code> are incompatible with the data, they are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.coda(output.file, index.file, start, end, thin, quiet=FALSE)
read.jags(file = "jags.out", start, end, thin, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.coda_+3A_output.file">output.file</code></td>
<td>
<p>The name of the file containing the monitored
output</p>
</td></tr>
<tr><td><code id="read.coda_+3A_index.file">index.file</code></td>
<td>
<p>The name of the file containing the index, showing
which rows of the output file correspond to which variables</p>
</td></tr>
<tr><td><code id="read.coda_+3A_file">file</code></td>
<td>
<p>For JAGS output, the name of the output file.  The
extension &quot;.out&quot; may be omitted. There must be a corresponding
&quot;.ind&quot; file with the same file stem.</p>
</td></tr>
<tr><td><code id="read.coda_+3A_start">start</code></td>
<td>
<p>First iteration of chain</p>
</td></tr>
<tr><td><code id="read.coda_+3A_end">end</code></td>
<td>
<p>Last iteration of chain</p>
</td></tr>
<tr><td><code id="read.coda_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for chain</p>
</td></tr>
<tr><td><code id="read.coda_+3A_quiet">quiet</code></td>
<td>
<p>Logical flag. If true, a progress summary will be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mcmc</code> containing a representation of 
the data in the file.
</p>


<h3>Author(s)</h3>

<p>Karen Vines, Martyn Plummer</p>


<h3>References</h3>

<p>Spiegelhalter DJ, Thomas A, Best NG and Gilks WR (1995).
<em>BUGS: Bayesian inference Using Gibbs Sampling, Version 0.50.</em>
MRC Biostatistics Unit, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>, 
<code><a href="#topic+read.coda.interactive">read.coda.interactive</a></code>,
<code><a href="#topic+read.openbugs">read.openbugs</a></code>.
</p>

<hr>
<h2 id='read.coda.interactive'>Read CODA output files interactively</h2><span id='topic+read.coda.interactive'></span>

<h3>Description</h3>

<p><code>read.coda.interactive</code> reads Markov Chain Monte Carlo output
in the format produced by the classic BUGS program. No arguments are
required. Instead, the user is prompted for the required information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.coda.interactive()
</code></pre>


<h3>Value</h3>

<p>An object of class <code>mcmc.list</code> containing a representation of 
the data in one or more BUGS output files.
</p>


<h3>Note</h3>

<p>This function is normally called by the <code>codamenu</code> function,
but can also be used on a stand-alone basis.
</p>


<h3>Author(s)</h3>

<p>Nicky Best, Martyn Plummer</p>


<h3>References</h3>

<p>Spiegelhalter DJ, Thomas A, Best NG and Gilks WR (1995).
<em>BUGS: Bayesian inference Using Gibbs Sampling, Version 0.50.</em>
MRC Biostatistics Unit, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>, 
<code><a href="#topic+mcmc.list">mcmc.list</a></code>, 
<code><a href="#topic+read.coda">read.coda</a></code>, 
<code><a href="#topic+codamenu">codamenu</a></code>. 
</p>

<hr>
<h2 id='read.openbugs'>Read CODA output files produced by OpenBUGS</h2><span id='topic+read.openbugs'></span>

<h3>Description</h3>

<p><code>read.openbugs</code> reads Markov Chain Monte Carlo output in
the CODA format produced by OpenBUGS.
</p>
<p>This is a convenience wrapper around the function <code>read.coda</code>
which allows you to read all the data output by OpenBUGS by
specifying only the file stem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.openbugs(stem="", start, end, thin, quiet=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.openbugs_+3A_stem">stem</code></td>
<td>
<p>Character string giving the stem for the output files.
OpenBUGS produces files with names &quot;&lt;stem&gt;CODAindex.txt&quot;,
&quot;&lt;stem&gt;CODAchain1.txt&quot;, &quot;&lt;stem&gt;CODAchain2.txt&quot;, ...</p>
</td></tr>
<tr><td><code id="read.openbugs_+3A_start">start</code></td>
<td>
<p>First iteration of chain</p>
</td></tr>
<tr><td><code id="read.openbugs_+3A_end">end</code></td>
<td>
<p>Last iteration of chain</p>
</td></tr>
<tr><td><code id="read.openbugs_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for chain</p>
</td></tr>
<tr><td><code id="read.openbugs_+3A_quiet">quiet</code></td>
<td>
<p>Logical flag. If true, a progress summary will be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mcmc.list</code> containing output from all
chains.
</p>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>References</h3>

<p>Spiegelhalter DJ, Thomas A, Best NG and Lunn D (2004).
<em>WinBUGS User Manual, Version 2.0, June 2004</em>,
MRC Biostatistics Unit, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.coda">read.coda</a></code>.
</p>

<hr>
<h2 id='rejectionRate'>Rejection Rate for Metropolis&ndash;Hastings chains</h2><span id='topic+rejectionRate'></span><span id='topic+rejectionRate.mcmc'></span><span id='topic+rejectionRate.mcmc.list'></span>

<h3>Description</h3>

<p><code>rejectionRate</code> calculates the fraction of time that a
Metropolis&ndash;Hastings type chain rejected a proposed move.  The rejection
rate is calculates separately for each variable in the <code>mcmc.obj</code>
argument, irregardless of whether the variables were drawn separately or
in a block.  In the latter case, the values returned should be the
same. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejectionRate(x) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rejectionRate_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the purposes of this function, a &quot;rejection&quot; has occurred if the
value of the time series is the same at two successive time points.
This test is done naively using <code>==</code> and may produce problems due
to rounding error.
</p>


<h3>Value</h3>

<p>A vector containing the rejection rates, one for each variable.
</p>


<h3>Author(s)</h3>

<p>Russell Almond</p>

<hr>
<h2 id='spectrum0'>Estimate spectral density at zero</h2><span id='topic+spectrum0'></span>

<h3>Description</h3>

<p>The spectral density at frequency zero is estimated by fitting a glm to
the low-frequency end of the periodogram.  <code>spectrum0(x)/length(x)</code>
estimates the variance of <code>mean(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum0(x, max.freq = 0.5, order = 1, max.length = 200) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrum0_+3A_x">x</code></td>
<td>
<p>A time series.</p>
</td></tr>
<tr><td><code id="spectrum0_+3A_max.freq">max.freq</code></td>
<td>
<p>The glm is fitted on the frequency range (0, max.freq]</p>
</td></tr>
<tr><td><code id="spectrum0_+3A_order">order</code></td>
<td>
<p>Order of the polynomial to fit to the periodogram.</p>
</td></tr>
<tr><td><code id="spectrum0_+3A_max.length">max.length</code></td>
<td>
<p>The data <code>x</code> is aggregated if necessary by
taking batch means so that the length of the series is less than
<code>max.length</code>.  If this is set to <code>NULL</code> no aggregation occurs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw periodogram is calculated for the series <code>x</code> and a generalized
linear model with family <code>Gamma</code> and log link is fitted to
the periodogram.
</p>
<p>The linear predictor is a polynomial in terms of the frequency.  The
degree of the polynomial is determined by the parameter <code>order</code>.
</p>


<h3>Value</h3>

<p>A list with the following values
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>The predicted value of the spectral density at frequency zero.</p>
</td></tr>
</table>


<h3>Theory</h3>

<p>Heidelberger and Welch (1991) observed that the usual non-parametric
estimator of the spectral density, obtained by smoothing the periodogram,
is not appropriate for frequency zero.  They proposed an alternative
parametric method which consisted of fitting a linear model to the
log periodogram of the batched time series. Some technical problems 
with model fitting in their original proposal can be overcome by using
a generalized linear model.
</p>
<p>Batching of the data, originally proposed in order to save space, has the
side effect of flattening the spectral density and making a polynomial
fit more reasonable.  Fitting a polynomial of degree zero is equivalent
to using the &lsquo;batched means&rsquo; method.
</p>


<h3>Note</h3>

<p>The definition of the spectral density used here differs from that used by
<code>spec.pgram</code>. We consider the frequency range to be between 0 and 0.5,
not between 0 and <code>frequency(x)/2</code>.
</p>
<p>The model fitting may fail on chains with very high autocorrelation.
</p>


<h3>References</h3>

<p>Heidelberger, P and Welch, P.D. A spectral method for confidence interval
generation and run length control in simulations. Communications of the
ACM, Vol 24, pp233-245, 1981.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="#topic+spectrum0.ar">spectrum0.ar</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>.
</p>

<hr>
<h2 id='spectrum0.ar'>Estimate spectral density at zero</h2><span id='topic+spectrum0.ar'></span>

<h3>Description</h3>

<p>The spectral density at frequency zero is estimated by fitting an
autoregressive model.  <code>spectrum0(x)/length(x)</code> estimates the
variance of <code>mean(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum0.ar(x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrum0.ar_+3A_x">x</code></td>
<td>
<p>A time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ar()</code> function to fit an autoregressive model to the time
series x. For multivariate time series, separate models are fitted for
each column. The value of the spectral density at zero is then given
by a well-known formula.
</p>


<h3>Value</h3>

<p>A list with the following values
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>The predicted value of the spectral density at frequency zero.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>The order of the fitted model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The definition of the spectral density used here differs from that used by
<code>spec.pgram</code>. We consider the frequency range to be between 0 and 0.5,
not between 0 and <code>frequency(x)/2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spectrum">spectrum</a></code>, <code><a href="#topic+spectrum0">spectrum0</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>.
</p>

<hr>
<h2 id='summary.mcmc'>Summary statistics for  Markov Chain Monte Carlo chains</h2><span id='topic+summary.mcmc'></span><span id='topic+summary.mcmc.list'></span>

<h3>Description</h3>

<p><code>summary.mcmc</code> produces two sets of summary statistics for
each variable:
</p>
<p>Mean, standard deviation, naive standard error of the mean
(ignoring autocorrelation of the chain) and time-series standard
error based on an estimate of the spectral density at 0.
</p>
<p>Quantiles of the sample distribution using the <code>quantiles</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
summary(object, quantiles = c(0.025, 0.25, 0.5, 0.75, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcmc_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcmc</code> or <code>mcmc.list</code></p>
</td></tr>
<tr><td><code id="summary.mcmc_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles to evaluate for each variable</p>
</td></tr>
<tr><td><code id="summary.mcmc_+3A_...">...</code></td>
<td>
<p>a list of further arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>,
<code><a href="#topic+mcmc.list">mcmc.list</a></code>.
</p>

<hr>
<h2 id='thin'>Thinning interval</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p><code>thin</code> returns the interval between successive
values of a time series. <code>thin(x)</code> is equivalent
to <code>1/frequency(x)</code>.
</p>
<p>This is a generic function. Methods have been implemented
for <code>mcmc</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_+3A_x">x</code></td>
<td>
<p>a regular time series</p>
</td></tr>
<tr><td><code id="thin_+3A_...">...</code></td>
<td>
<p>a list of arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martyn Plummer</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+time">time</a></code>.
</p>

<hr>
<h2 id='time.mcmc'>Time attributes for mcmc objects</h2><span id='topic+time.mcmc'></span><span id='topic+start.mcmc'></span><span id='topic+end.mcmc'></span><span id='topic+frequency.mcmc'></span><span id='topic+thin.mcmc'></span><span id='topic+time.mcmc.list'></span><span id='topic+start.mcmc.list'></span><span id='topic+end.mcmc.list'></span><span id='topic+thin.mcmc.list'></span>

<h3>Description</h3>

<p>These are methods for mcmc objects for the generic time
series functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
time(x, ...)
## S3 method for class 'mcmc'
start(x, ...)
## S3 method for class 'mcmc'
end(x, ...)
## S3 method for class 'mcmc'
thin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time.mcmc_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="time.mcmc_+3A_...">...</code></td>
<td>
<p>extra arguments for future methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+time">time</a></code>,
<code><a href="stats.html#topic+start">start</a></code>,
<code><a href="stats.html#topic+frequency">frequency</a></code>,
<code><a href="#topic+thin">thin</a></code>.
</p>

<hr>
<h2 id='traceplot'>Trace plot of MCMC output</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>Displays a plot of iterations <em>vs.</em> sampled values for each variable
in the chain, with a separate plot per variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(x, smooth = FALSE,
       col = 1:6, type = "l", xlab = "Iterations", ylab = "", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_x">x</code></td>
<td>
<p>An <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="traceplot_+3A_smooth">smooth</code></td>
<td>
<p>draw smooth line through trace plot</p>
</td></tr>
<tr><td><code id="traceplot_+3A_col">col</code></td>
<td>
<p>graphical parameter (see <code>par</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_type">type</code></td>
<td>
<p>graphical parameter (see <code>plot</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter (see <code>plot</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameter (see <code>plot</code>)</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>further graphical parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>You can call this function directly, but it is more usually
called by the <code>plot.mcmc</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densplot">densplot</a></code>, <code><a href="#topic+plot.mcmc">plot.mcmc</a></code>.
</p>

<hr>
<h2 id='trellisplots'>Trellis plots for mcmc objects</h2><span id='topic+densityplot.mcmc'></span><span id='topic+levelplot.mcmc'></span><span id='topic+qqmath.mcmc'></span><span id='topic+xyplot.mcmc'></span><span id='topic+densityplot.mcmc.list'></span><span id='topic+levelplot.mcmc.list'></span><span id='topic+qqmath.mcmc.list'></span><span id='topic+xyplot.mcmc.list'></span><span id='topic+acfplot'></span><span id='topic+acfplot.mcmc'></span><span id='topic+acfplot.mcmc.list'></span>

<h3>Description</h3>

<p>These methods use the Trellis framework as implemented in the
<code>lattice</code> package to produce space-conserving diagnostic plots
from <code>"mcmc"</code> and <code>"mcmc.list"</code> objects.  The <code>xyplot</code>
methods produce trace plots.  The <code>densityplot</code> methods and
<code>qqmath</code> methods produce empirical density and probability
plots.  The <code>levelplot</code> method depicts the correlation of the
series.  The <code>acfplot</code> methods plot the auto-correlation in the
series.  
</p>
<p>Not yet available in S-PLUS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
densityplot(x, data,
             outer, aspect = "xy",
             default.scales = list(relation = "free"),
             start = 1, thin = 1,
             main = attr(x, "title"),
             xlab = "",
             plot.points = "rug",
             ...,
             subset)
## S3 method for class 'mcmc.list'
densityplot(x, data,
             outer = FALSE, groups = !outer,
             aspect = "xy",
             default.scales = list(relation = "free"),
             start = 1, thin = 1,
             main = attr(x, "title"),
             xlab = "",
             plot.points = "rug",
             ...,
             subset)
## S3 method for class 'mcmc'
levelplot(x, data, main = attr(x, "title"),
             start = 1, thin = 1,
             ...,
             xlab = "", ylab = "",
             cuts = 10, at,
             col.regions = topo.colors(100),
             subset)
## S3 method for class 'mcmc'
qqmath(x, data,
             outer, aspect = "xy",
             default.scales = list(y = list(relation = "free")),
             prepanel = prepanel.qqmathline,
             start = 1, thin = 1,
             main = attr(x, "title"),
             ylab = "",
             ...,
             subset)
## S3 method for class 'mcmc.list'
qqmath(x, data,
             outer = FALSE, groups = !outer,
             aspect = "xy",
             default.scales = list(y = list(relation = "free")),
             prepanel = prepanel.qqmathline,
             start = 1, thin = 1,
             main = attr(x, "title"),
             ylab = "",
             ...,
             subset)
## S3 method for class 'mcmc'
xyplot(x, data,
             outer, layout = c(1, nvar(x)),
             default.scales = list(y = list(relation = "free")),
             type = 'l',
             start = 1, thin = 1,
             xlab = "Iteration number",
             ylab = "", 
             main = attr(x, "title"),
             ...,
             subset)
## S3 method for class 'mcmc.list'
xyplot(x, data, outer = FALSE, groups = !outer,
             aspect = "xy", layout = c(1, nvar(x)),
             default.scales = list(y = list(relation = "free")),
             type = 'l',
             start = 1, thin = 1,
             xlab = "Iteration number",
             ylab = "",
             main = attr(x, "title"),
             ...,
             subset)
acfplot(x, data, ...)
## S3 method for class 'mcmc'
acfplot(x, data, outer,
             prepanel, panel, 
             type = 'h',
             aspect = "xy",
             start = 1, thin = 1,
             lag.max = NULL,
             ylab = "Autocorrelation",
             xlab = "Lag",
             main = attr(x, "title"),
             ...,
             subset)
## S3 method for class 'mcmc.list'
acfplot(x, data, outer = FALSE, groups = !outer,
             prepanel, panel,
             type = if (groups) 'b' else 'h',
             aspect = "xy",
             start = 1, thin = 1,
             lag.max = NULL,
             ylab = "Autocorrelation",
             xlab = "Lag",
             main = attr(x, "title"),
             ...,
             subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trellisplots_+3A_x">x</code></td>
<td>
<p> an <code>"mcmc"</code> or <code>"mcmc.list"</code> object. </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_data">data</code></td>
<td>
<p> ignored, present for consistency with generic. </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_outer">outer</code></td>
<td>
<p> for the <code>"mcmc.list"</code> methods, a logical flag to
control whether multiple runs of a series are displayed in the same
panel (they are if <code>FALSE</code>, not if <code>TRUE</code>).  If specified
in the <code>"mcmc"</code> methods, this argument is ignored with a
warning.  </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_groups">groups</code></td>
<td>
<p> for the <code>"mcmc.list"</code> methods, a logical flag to
control whether the underlying <code>lattice</code> call will be supplied
a <code>groups</code> arguments indicating which run a data point
originated from.  The panel function is responsible for handling
such an argument, and will usually differentiate runs within a panel
by using different graphical parameters.  When <code>outer=FALSE</code>,
the default of <code>groups</code> is <code>TRUE</code> if the corresponding
default panel function is able to make use of such information.
When <code>outer=FALSE</code>, <code>groups=TRUE</code> will be ignored with a
warning.  </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_aspect">aspect</code></td>
<td>
<p> controls the physical aspect ratio of the panel.  See
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> for details.  The default for
these methods is chosen carefully - check what the default plot
looks like before changing this parameter.</p>
</td></tr>
<tr><td><code id="trellisplots_+3A_default.scales">default.scales</code></td>
<td>
<p> this parameter provides a reasonable default
value of the <code>scales</code> parameter for the method. It is unlikely
that a user will wish to change this parameter.  Pass a value for
<code>scales</code> (see <code><a href="lattice.html#topic+xyplot">xyplot</a></code>) instead,
which will override values specified here.  </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_type">type</code></td>
<td>
<p> a character vector that determines if lines, points,
etc. are drawn on the panel.  The default values for the methods are
carefully chosen.  See
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code> for possible
values. </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_thin">thin</code></td>
<td>
<p> an optional thinning interval that is applied before the
plot is drawn.</p>
</td></tr>
<tr><td><code id="trellisplots_+3A_start">start</code></td>
<td>
<p> an optional value for the starting point within the
series.  Values before the starting point are considered part of the
&quot;burn-in&quot; of the series and dropped.</p>
</td></tr>
<tr><td><code id="trellisplots_+3A_plot.points">plot.points</code></td>
<td>
<p> character argument giving the style in which
points are added to the plot.  See
<code><a href="lattice.html#topic+panel.densityplot">panel.densityplot</a></code> for
details. </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_layout">layout</code></td>
<td>
<p>a method-specific default for the <code>layout</code> argument
to the lattice functions.</p>
</td></tr>
<tr><td><code id="trellisplots_+3A_xlab">xlab</code>, <code id="trellisplots_+3A_ylab">ylab</code>, <code id="trellisplots_+3A_main">main</code></td>
<td>
<p>Used to provide default axis annotations and
plot labels.</p>
</td></tr>
<tr><td><code id="trellisplots_+3A_cuts">cuts</code>, <code id="trellisplots_+3A_at">at</code></td>
<td>
<p> defines number and location of values where colors
change </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_col.regions">col.regions</code></td>
<td>
<p> color palette used </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_lag.max">lag.max</code></td>
<td>
<p> maximum lag for which autocorrelation is computed.  By
default, the value chosen by <code><a href="stats.html#topic+acf">acf</a></code> is used </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_prepanel">prepanel</code>, <code id="trellisplots_+3A_panel">panel</code></td>
<td>
<p> suitable prepanel and panel functions for
<code>acfplot</code>.  The prepanel function omits the lag-0
auto-correlation (which is always 1) from the range calculations.  </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_...">...</code></td>
<td>
<p>other arguments, passed to the lattice function.
Documentation of the corresponding generics in the <code>lattice</code>
package should be consulted for possible arguments. </p>
</td></tr>
<tr><td><code id="trellisplots_+3A_subset">subset</code></td>
<td>
<p>indices of the subset of the series to plot.  The
default is constructed from the <code>start</code> and <code>thin</code>
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The relevant
<code><a href="lattice.html#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="lattice.html#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+Lattice">Lattice</a></code> for a brief introduction to
lattice displays and links to further documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(line)

## Not run: 
xyplot(line)
xyplot(line[[1]], start = 10)
densityplot(line, start = 10)
qqmath(line, start = 10)
levelplot(line[[2]])
acfplot(line, outer = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='varnames'>Named dimensions of MCMC objects</h2><span id='topic+varnames'></span><span id='topic+varnames+3C-'></span><span id='topic+chanames'></span><span id='topic+chanames+3C-'></span>

<h3>Description</h3>

<p><code>varnames()</code> returns the variable names and <code>chanames</code>
returns the chain names, or NULL if these are not set.  
</p>
<p>If <code>allow.null = FALSE</code> then <code>NULL</code> values will be
replaced with canonical names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varnames(x, allow.null=TRUE)
chanames(x, allow.null=TRUE)
varnames(x) &lt;- value
chanames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varnames_+3A_x">x</code></td>
<td>
<p>an <code>mcmc</code> or <code>mcmc.list</code> object</p>
</td></tr>
<tr><td><code id="varnames_+3A_allow.null">allow.null</code></td>
<td>
<p>Logical argument that determines whether the function may return NULL</p>
</td></tr>
<tr><td><code id="varnames_+3A_value">value</code></td>
<td>
<p>A character vector, or NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector , or NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc">mcmc</a></code>,
<code><a href="#topic+mcmc.list">mcmc.list</a></code>.
</p>

<hr>
<h2 id='window.mcmc'>Time windows for mcmc objects</h2><span id='topic+window.mcmc'></span><span id='topic+window.mcmc.list'></span>

<h3>Description</h3>

<p><code>window.mcmc</code> is a method for <code>mcmc</code> objects which is
normally called by the generic function <code>window</code>
</p>
<p>In addition to the generic parameters, <code>start</code> and <code>end</code>
the additional parameter <code>thin</code> may be used to thin out the
Markov chain. Setting thin=k selects every kth iteration starting
with the first. Note that the value of <code>thin</code> is <em>absolute</em>
not relative. The value supplied given to the parameter <code>thin</code>
must be a multiple of <code>thin(x)</code>.
</p>
<p>Values of <code>start</code>, <code>end</code> and <code>thin</code> which are inconsistent
with <code>x</code> are ignored, but a warning message is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
window(x, start, end, thin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.mcmc_+3A_x">x</code></td>
<td>
<p>an mcmc object</p>
</td></tr>
<tr><td><code id="window.mcmc_+3A_start">start</code></td>
<td>
<p>the first iteration of interest</p>
</td></tr>
<tr><td><code id="window.mcmc_+3A_end">end</code></td>
<td>
<p>the last iteration of interest</p>
</td></tr>
<tr><td><code id="window.mcmc_+3A_thin">thin</code></td>
<td>
<p>the required interval between successive samples</p>
</td></tr>
<tr><td><code id="window.mcmc_+3A_...">...</code></td>
<td>
<p>futher arguments for future methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+window">window</a></code>, <code><a href="#topic+thin">thin</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
