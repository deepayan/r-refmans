<!DOCTYPE html><html><head><title>Help for package approxmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {approxmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approxmatch-package'>
<p>Approximately Optimal Fine Balance Matching with Multiple Groups.</p></a></li>
<li><a href='#covbalance'>
<p>Check covariate balance of a design.</p></a></li>
<li><a href='#Dodgeram'>
<p>Dodge ram pk 2500 data on side airbag (SAB) usage from 1995 to 2015</p></a></li>
<li><a href='#kwaymatching'>
<p>Create approximately optimal matched strata of multiple, at least two, groups.</p></a></li>
<li><a href='#multigrp_dist_struc'>
<p>Construct the distance structure for the multiple groups.</p></a></li>
<li><a href='#nrbalancematch'>
<p>The is the background function to perform matching using network optimization.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximately Optimal Fine Balance Matching with Multiple Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Bikram Karmakar</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bikram Karmakar &lt;bkarmakar@ufl.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for constructing a matched design with multiple comparison groups.
 Further specifications of refined covariate balance restriction and exact match on 
 covariate can be imposed. Matches are approximately optimal in  the sense that the 
 cost of the solution is at most twice the optimal cost, Crama and Spieksma (1992) 
 &lt;<a href="https://doi.org/10.1016%2F0377-2217%2892%2990078-N">doi:10.1016/0377-2217(92)90078-N</a>&gt;, Karmakar, Small and Rosenbaum (2019)
 &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1584900">doi:10.1080/10618600.2019.1584900</a>&gt;.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch, MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-29 13:47:46 UTC; bikra</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-30 08:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='approxmatch-package'>
Approximately Optimal Fine Balance Matching with Multiple Groups.
</h2><span id='topic+approxmatch-package'></span><span id='topic+approxmatch'></span>

<h3>Description</h3>

<p>Tools for constructing a matched design with multiple comparison groups.
Further specifications of refined covariate balance restriction and exact match on 
covariate can be imposed. Matches are approximately optimal in  the sense that the 
cost of the solution is at most twice the optimal cost, Crama and Spieksma (1992) 
&lt;doi:10.1016/0377-2217(92)90078-N&gt;, Karmakar, Small and Rosenbaum (2019)
&lt;doi:10.1080/10618600.2019.1584900&gt;.
</p>


<h3>Details</h3>



<p>Index of help topics:
</p>
<pre>
Dodgeram                Dodge ram pk 2500 data on side airbag (SAB)
                        usage from 1995 to 2015
approxmatch-package     Approximately Optimal Fine Balance Matching
                        with Multiple Groups.
covbalance              Check covariate balance of a design.
kwaymatching            Create approximately optimal matched strata of
                        multiple, at least two, groups.
multigrp_dist_struc     Construct the distance structure for the
                        multiple groups.
nrbalancematch          The is the background function to perform
                        matching using network optimization.
</pre>
<p>An R package for creating matched strata with multiple treatments. Default 
design for a stratum structure is one unit from each treatment, but, other 
designs can be specified.  User can also fine match/ near fine match on 
one or more categorical covariates, e.g. sex and age group.
</p>
<p>The main functions of the package are <code>kwaymatching</code> and <code>tripletmatch</code>.
These functions take as input the distance structure of multiple groups and the grouping
information to create an approximately optimal multigroup design minimizing the 
total distance. A distance structure can be calculated as per requirement by 
the <code>multigrp_dist_struc</code> function. 
</p>
<p>The algorithm used to create matched design is an approximation algorithm developed
by Karmakar, Small and Rosenbaum (2019).  The design built is guaranteed to be 
close to the optimal matched design of the specified structure.
</p>
<p>IMPORTANT NOTE: In order to perform matching, <code>kwaymatching</code> requires the 
user to load the optmatch (&gt;= 0.9-1) package separately. A manual loading is 
required due to software license issues. If the package is not loaded, the 
<code>kwaymatching</code> command will fail with an error saying the optmatch package 
is not present. Reference to optmatch is given below.
</p>


<h3>Author(s)</h3>

<p>Bikram Karmakar
</p>
<p>Maintainer: Bikram Karmakar &lt;bkarmakar@ufl.edu&gt;
</p>


<h3>References</h3>

<p>Crama, Y. and Spieksma, F. C. R. (1992), Approximation algorithms for three-dimensional
assignment problems with triangle inequalities, European Journal of Operational Research
60, 273&ndash;279.
</p>
<p>Hansen, B.B. and Klopfer, S.O. (2006) Optimal full matching and related designs via network flows,
JCGS 15 609&ndash;627.
</p>
<p>Karmakar, B., Small, D. S. and Rosenbaum, P. R. (2019) Using Approximation Algorithms to Build 
Evidence Factors and Related Designs for Observational Studies, Journal of Computational 
and Graphical Statistics, 28, 698&ndash;709.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See kwaymatching for usage
</code></pre>

<hr>
<h2 id='covbalance'>
Check covariate balance of a design.
</h2><span id='topic+covbalance'></span>

<h3>Description</h3>

<p>For a given match, this function evaluates the balance of variables before and
after matching. Balance is evaluated using standardized differences.  

</p>


<h3>Usage</h3>

<pre><code class='language-R'>covbalance(.data, grouplabel, matches, vars, details)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covbalance_+3A_.data">.data</code></td>
<td>

<p>A data frame or matrix containing the informations on the <code>vars</code> for 
which balance will be checked.
</p>
</td></tr>
<tr><td><code id="covbalance_+3A_grouplabel">grouplabel</code></td>
<td>

<p>Argument describing the group structure. See the description in the 
documentation of <code>kwaymatching</code> function of this package.
</p>
</td></tr>
<tr><td><code id="covbalance_+3A_matches">matches</code></td>
<td>

<p>A character matrix describing the strata structure of the design. Standard
use is the output of <code>tripletmatching</code> or <code>kwaytmatching</code> function.
</p>
<p>Each row of the matrix corresponds to a strata and each entry corresponds to 
rowname of <code>.data</code>.
</p>
</td></tr>
<tr><td><code id="covbalance_+3A_vars">vars</code></td>
<td>

<p>A character vector of the names of the variables for which balance should 
be checked. 
</p>
</td></tr>
<tr><td><code id="covbalance_+3A_details">details</code></td>
<td>

<p>Optional argument. This argument can be used to get other details on the 
<code>vars</code> before and after matching. A character vector of names of functions
which summarizes a vector, e.g. mean. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardized difference of the covariates between two groups is computed as 
difference of the means of the variable over the squared root of the average
variance of the variable in the groups. 
</p>
<p>For better understanding of the matching, <code>details</code> can be used. This 
argument can be used to get summaries of the variables before and after matching.
For example, details = c(mean = 'mean', median = 'function(x) quantile(x, probs=.5)') 
given the mean and median of the variables. Only functions that give a single 
number summary can be used! 
</p>
<p>Currently, this function cannot be immediately used for a design with different
strata sizes. One way to get around would be to fill in the smaller stratum 
with false units and making all the strata of equal size.
</p>


<h3>Value</h3>

<p>A list consisting of the following elements.
</p>
<table>
<tr><td><code>std_diff</code></td>
<td>
<p> Standardized differences of the specified variables before and 
after matching for every pair of groups.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p> Only if <code>details</code> is provided. A list of summaries of the 
variables before and after matching using the functions specified by <code>details</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See <code><a href="#topic+kwaymatching">kwaymatching</a></code> for usage.
</p>


<h3>Author(s)</h3>

<p>Bikram Karmakar 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tripletmatching">tripletmatching</a></code>, <code><a href="#topic+kwaymatching">kwaymatching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	data(Dodgeram)
	
	## An example strata structure
	matches = as.matrix(sample(rownames(Dodgeram), 500), ncol = 5)
	
	vars = c("AGE", "SEX.2", "IMPACT3.3", "DR_DRINK")
	details = c('std_diff', 'mean', 'function(x) diff(range(x))', 
	                         'function(x) quantile(x, probs = .9)')
	names(details) &lt;- c('std_diff', 'mean', 'range', '90perc')
	
	covbalance(.data=Dodgeram, grouplabel=c("NOSAB", "optSAB", "WITHSABS"), 
	                 matches = matches, vars = vars, details)
					 
</code></pre>

<hr>
<h2 id='Dodgeram'>
Dodge ram pk 2500 data on side airbag (SAB) usage from 1995 to 2015
</h2><span id='topic+Dodgeram'></span>

<h3>Description</h3>

<p>This is an example dataset on the description of the Dodge pk 2500 cars involved
in fatal crashes between 1995 to 2015. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Dodgeram")</code></pre>


<h3>Format</h3>

<p>A data frame with 6953 observations on the following 33 variables.
</p>

<dl>
<dt><code>X.1</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt><code>X</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt><code>indexinSABdata</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>NOSAB</code></dt><dd><p>a numeric vector. In the earlier period when SAB was not
available? 1 = yes.</p>
</dd>
<dt><code>WITHoptSAB</code></dt><dd><p>a numeric vector. Bought SAB in the optional period?
1 = yes.</p>
</dd>
<dt><code>optSAB</code></dt><dd><p>a numeric vector. In the optional period when SAB
was available as an option? 1 = yes.</p>
</dd>
<dt><code>WITHSABS</code></dt><dd><p>a numeric vector. In the later period when SAB was standard 
issue? 1 = yes.</p>
</dd>
<dt><code>IMPACT3</code></dt><dd><p>a numeric vector. Impact code. (0 = no, 1 = right, 2 = behind, 
3 = left, 4 = front, 9 = other)</p>
</dd>
<dt><code>ROLLOVER1</code></dt><dd><p>a numeric vector. Rollover occurred? 1 = yes.</p>
</dd>
<dt><code>REST_USE1</code></dt><dd><p>a numeric vector. Restraint used by the driver?
1 = yes, 99 = unknown type, 0 = not used.</p>
</dd>
<dt><code>FRpass.REST_USE1</code></dt><dd><p>a numeric vector. Restraint use by the front 
right passenger.</p>
</dd>
<dt><code>SP_LIMIT</code></dt><dd><p>a numeric vector. Speed Limit of the route.</p>
</dd>
<dt><code>AGE</code></dt><dd><p>a numeric vector. Age of the driver.</p>
</dd>
<dt><code>DR_DRINK</code></dt><dd><p>a numeric vector. Whether the driver was drinking?
1 = yes.</p>
</dd>
<dt><code>FR.pass</code></dt><dd><p>a logical vector. Whether a front right passenger was
present.</p>
</dd>
<dt><code>FRpass.AGE</code></dt><dd><p>a numeric vector. Age of the front right passenger
if present.</p>
</dd>
<dt><code>SEX.2</code></dt><dd><p>a numeric vector. Sex of the driver. 1 = female.</p>
</dd>
<dt><code>EJECTION.1</code></dt><dd><p>a numeric vector. Ejection of the driver. 1 = yes.</p>
</dd>
<dt><code>EJECTION.2</code></dt><dd><p>a numeric vector. Ejection type of driver unknown. 1= yes.</p>
</dd>
<dt><code>IMPACT3.1</code></dt><dd><p>a numeric vector. Impact from right? 1= yes.</p>
</dd>
<dt><code>IMPACT3.2</code></dt><dd><p>a numeric vector. Impact from behind? 1= yes.</p>
</dd>
<dt><code>IMPACT3.3</code></dt><dd><p>a numeric vector. Impact from left? 1= yes.</p>
</dd>
<dt><code>IMPACT3.4</code></dt><dd><p>a numeric vector. Impact from front? 1= yes.</p>
</dd>
<dt><code>IMPACT3.9</code></dt><dd><p>a numeric vector. Impact of other type? 1= yes.</p>
</dd>
<dt><code>ROLLOVER1.1</code></dt><dd><p>a numeric vector. Rollover occurred? 1= yes.</p>
</dd>
<dt><code>FIRE_EXP1.1</code></dt><dd><p>a numeric vector. Fire occurred in the car? 1= yes.</p>
</dd>
<dt><code>REST_USE1.1</code></dt><dd><p>a numeric vector. Driver used restraint? 1= yes.</p>
</dd>
<dt><code>REST_USE1.99</code></dt><dd><p>a numeric vector. Driver restraint use of unknown
type? 1= yes.</p>
</dd>
<dt><code>FRpass.SEX.2</code></dt><dd><p>a numeric vector. Sex of the front right passenger.
2 = female.</p>
</dd>
<dt><code>FRpass.EJECTION.1</code></dt><dd><p>a numeric vector. Ejection of the front right 
passenger. 1 = yes.</p>
</dd>
<dt><code>FRpass.EJECTION.2</code></dt><dd><p>a numeric vector. Ejection type of front right
passenger unknown. 1= yes.</p>
</dd> 
<dt><code>FRpass.REST_USE1.1</code></dt><dd><p>a numeric vector. Front right passenger used restraint? 
1= yes.</p>
</dd>
<dt><code>FRpass.REST_USE1.99</code></dt><dd><p>a numeric vector. Front right passenger restraint use of unknown
type? 1= yes.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Derived from fatal accidents in the USA between 1995 and 2015 recorded by 
Fatality Analysis Reporting System (FARS) of NHTSA. Consists of 
only model years more than 1985. Sample is corrected for selection bias in 
FARS. For further detail of the variables see the code book of FARS.
</p>


<h3>Source</h3>

<p>Fatality Analysis Reporting System of NHTSA, DOT, USA. https://www.nhtsa.gov/research-data/fatality-analysis-reporting-system-fars
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Dodgeram)
## maybe str(Dodgeram) ; plot(Dodgeram) ...
</code></pre>

<hr>
<h2 id='kwaymatching'>
Create approximately optimal matched strata of multiple, at least two, groups.
</h2><span id='topic+kwaymatching'></span><span id='topic+tripletmatching'></span>

<h3>Description</h3>

<p>This function takes as input a distance structure and grouping labels of units 
to create an strata structure of the units that minimizes the sum distance.  It 
also provides features for near fine balance on one or more nominal 
variables and exact match on a nominal variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwaymatching(distmat, grouplabel, design, indexgroup = 1, .data, finebalanceVars, 
                       exactmatchon, ordering, reorder = FALSE, verbose = TRUE)
		
tripletmatching(distmat, grouplabel, design, indexgroup = 1, .data, finebalanceVars, 
                       exactmatchon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwaymatching_+3A_distmat">distmat</code></td>
<td>

<p>An output of <code>multigrp_dist_struc</code>. This a named list of matrices. Each 
list element correspond to the distance matrix between two groups. If group
labels are 1:k. Then the elements are named '1-2', '1-3',<code class="reqn">\cdots</code>, 'i-j', <code class="reqn">\cdots</code>.
For matching of three groups k=3. If groups are labeled by some character
string then list elements are named accordingly. For example, if the groups
are 'grpA', 'grpB', 'grpC'; the elements are 'grpA-grpB', 'grpA-grpC', 
'grpB-grpB'. 
</p>
<p>Each element of the list is a numeric matrix of distances between units of the
corresponding groups with number of rows equal to the size of the first group,
and number of columns the size of the second group. The units are identified
by their names in row or column names of the list elements.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_grouplabel">grouplabel</code></td>
<td>

<p>This argument is used to provide information about the group structure of the
units. There are a few options on how this information can be provided.
</p>
<p>1) A numeric vector or a categorical vector. By providing a numeric vector 
which labels each the units to corresponding groups.
</p>
<p>2) A matrix or data frame of dummy variables with number of groups 
as the number of rows (one for each group) and number of units as the 
number of columns.
</p>
<p>3) A character vector of variable names. If <code>.data</code> is provided 
then only name of the variable which contains the information about the 
grouping can be provided. If the grouping information is encoded in dummy 
variable, one can also just provide the names of the dummy variables.
</p>
<p>If either the first or the second kind of information is provided, it is 
expected that the unit are identifiable from the names (in the first case)
or rownames (in the second case) of <code>grouplabel</code>.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_design">design</code></td>
<td>

<p>A vector of positive integers specifying the design. If not provided then 
the default is one unit from each group.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_indexgroup">indexgroup</code></td>
<td>

<p>The number or the name of the group to be considered as the index group. 
The design size of the index group should be 1. Further, for each 
non-index group the size of the group should be at least the product of 
design size of that group and size of the index group.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_.data">.data</code></td>
<td>

<p>Optional argument but recommended. The data frame or matrix of the dataset.
The units are recognized by rownames. This is used when further design 
structure of near fine balance and exact match on certain variable is 
imposed.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_finebalancevars">finebalanceVars</code></td>
<td>

<p>An optional character vector of names of the columns of <code>.data</code> on which the 
matching will be near fine balanced.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_exactmatchon">exactmatchon</code></td>
<td>

<p>Name of the column of <code>.data</code> on which matching will be exact. (optional)
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_ordering">ordering</code></td>
<td>

<p>Optional vector of size the number of groups, specifying the order in which 
groups will be matched sequentially.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_reorder">reorder</code></td>
<td>

<p>Optional logical argument for whether matching will be done after permuting 
the groups randomly.
</p>
</td></tr>
<tr><td><code id="kwaymatching_+3A_verbose">verbose</code></td>
<td>

<p>A logical argument. If true some details about the implementation may be 
prompted when running.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only required arguments are distmat, grouplabel, design and indexgroup. <code>.data</code>
is suggested but not required, in which case units are assumed to be labeled 
1:length(grouplabel). 
</p>
<p>Argument <code>.data</code> must be provided if structure of fine balance and/or exact 
match is imposed by arguments <code>finebalanceVars</code> and/or <code>exactmatchon</code>.
</p>
<p>IMPORTANT NOTE: In order to perform matching, <code>kwaymatching</code> requires the 
user to load the optmatch (&gt;= 0.9-1) package separately. The manual loading is 
required due to software license issues. If the package is not loaded the 
<code>kwaymatching</code> command will fail with an error saying the optmatch package 
is not present. Reference to optmatch is given below.
</p>


<h3>Value</h3>

<p>A list consisting of the following two elements.
</p>
<table>
<tr><td><code>matches</code></td>
<td>
<p> A character matrix of size, size of the indexgroup<code class="reqn">\times</code>
<code>sum(design)</code>. Each row corresponds to a strata and cell values are 
the units in the strata. </p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p> The cost of the final matching calculated as the sum of 
the average distances between each pair of groups within every strata, and
summing over all strata.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For theoretical guarantee it is expected that the distance structure satisfies 
triangle inequality. If triangle inequality is satisfied than the cost of 
the solution of this algorithm is at most twice that of the optimal match.
Note, for more than two groups the problem of finding the optimal solution is NP-hard.
</p>


<h3>Author(s)</h3>

<p>Bikram Karmakar
</p>


<h3>References</h3>

<p>Karmakar, B., Small, D. S. and Rosenbaum, P. R. (2019) Using Approximation Algorithms to Build 
Evidence Factors and Related Designs for Observational Studies, Journal of Computational 
and Graphical Statistics, 28, 698&ndash;709.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	
	
	## USAGE 1
	## Not run: 
	library(optmatch)
	## User is required to install and load the optmatch package separately,
	
	data(Dodgeram) # dodge ram pk 2500
	
	grouplabel = 2*Dodgeram$WITHSABS + 1*Dodgeram$NOSAB + 3*Dodgeram$optSAB
	
	# distance components consists of log propensity 
	# distance and rank based Mahalanobis distance.
	components &lt;- list(prop = c("AGE", "IMPACT3"), mahal = c("SEX.2", "AGE", "FIRE_EXP1.1"))
	wgts &lt;- c(10, 5)
	distmat &lt;- multigrp_dist_struc(Dodgeram, grouplabel = grouplabel, components, wgts)	
	
	# Matching 
	design = c(1,1,3) # 3 units from the optional period, 1 each from other periods
	indexgroup = 2
	res = tripletmatching(distmat = distmat, grouplabel = grouplabel, design = design, 
	                            indexgroup = indexgroup)
	
	# covariance balance
	details = 'mean'
	covbalance(Dodgeram, grouplabel=c("NOSAB", "optSAB", "WITHSABS"), matches = res, 
	                          vars = c("AGE", "SEX.2", "IMPACT3.3", "DR_DRINK"), details)
	
## End(Not run)
	
	## USAGE 2
	## Not run: 
	library(optmatch)
	## User is required to install and load the optmatch package separately,
	
	data(Dodgeram)
	
	# Example distance structure
	components &lt;- list(prop = c("AGE", "SEX.2", "FR.pass", "REST_USE1", "ROLLOVER1",
	            "IMPACT3", "SP_LIMIT", "DR_DRINK", "FIRE_EXP1.1"), 
	            mahal = c("SEX.2", "AGE", "SP_LIMIT", "DR_DRINK"), 				
	            mahal = c("IMPACT3", "REST_USE1"))
	wgts &lt;- c(5, 8, 20)
	
	distmat &lt;- multigrp_dist_struc(Dodgeram, grouplabel = c("NOSAB", "optSAB", "WITHSABS"), 
	                                   components, wgts)
	
	# Matching with fine balance and exact match
	indexgroup = "WITHSABS"
	finebalanceVars = c("ROLLOVER1.1", "FIRE_EXP1.1")
	exactmatchon = "FR.pass"
	
	res = tripletmatching(distmat = distmat, grouplabel = c("NOSAB", "optSAB", "WITHSABS"), 
	                design = c(3,3,1), indexgroup = indexgroup, .data = Dodgeram, 
	                finebalanceVars = finebalanceVars, exactmatchon = exactmatchon)
	
	# covariance balance
	vars = c("AGE", "SEX.2", "IMPACT3.3", "DR_DRINK")
	details = c('std_diff', 'mean', 'function(x) diff(range(x))', 
	                         'function(x) quantile(x, probs = .9)')
	names(details) &lt;- c('std_diff', 'mean', 'range', '90perc')
	
	covbalance(.data=Dodgeram, grouplabel=c("NOSAB", "optSAB", "WITHSABS"), 
	                 matches = res, vars = vars, details)
	
	
## End(Not run)
</code></pre>

<hr>
<h2 id='multigrp_dist_struc'>
Construct the distance structure for the multiple groups.
</h2><span id='topic+multigrp_dist_struc'></span>

<h3>Description</h3>

<p>This function can be used to calculate the distance structure for multiple 
groups. The output of this function can be feed into the argument <code>distmat</code>
of the main functions <code>kwaymatching</code> and <code>tripletmatching</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multigrp_dist_struc(.data, grouplabel, components, wgts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multigrp_dist_struc_+3A_.data">.data</code></td>
<td>

<p>The data frame or matrix of the dataset. 
</p>
</td></tr>
<tr><td><code id="multigrp_dist_struc_+3A_grouplabel">grouplabel</code></td>
<td>

<p>The information on the group structure of the units. See description of 
<code><a href="#topic+kwaymatching">kwaymatching</a></code> for details on the argument.
</p>
</td></tr>
<tr><td><code id="multigrp_dist_struc_+3A_components">components</code></td>
<td>

<p>A list specifying the components of the distance structure.
Each element of the list is a character vector of column names
of the .data on which 'distance' will be calculated. The 
element names specify the function to be used to calculate to 
distance of two groups. Element named
'prop' indicates the propensity distance where the propensity
is calculated from the specified variable. 
Element named 'mahal' or 'Mahalanobis' for rank based
Mahalanobis distance. 
</p>
<p>User can spacify their own distance function. For example, a function 
<code>myDist</code> should be a function of two arguments:
a logical vector of the first group indicator and a data matrix. It
should return a numeric matrix of size number of units of 
first group<code class="reqn">\times</code>number of units of 
second group. See details for an example.
</p>
</td></tr>
<tr><td><code id="multigrp_dist_struc_+3A_wgts">wgts</code></td>
<td>

<p>A non-negative numeric vector of weights of the components. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to get distance structure suitable 
for creating the distances between the units of the groups. 
</p>
<p>For an example of the kind of user defined distance function that can be used see <code>smahal</code> below.
</p>


<h3>Value</h3>

<p>A list describing the distance structure. For detail see the description of 
the argument <code>distmat</code> in the function <code><a href="#topic+kwaymatching">kwaymatching</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bikram Karmakar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kwaymatching">kwaymatching</a></code>, <code><a href="#topic+tripletmatching">tripletmatching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(Dodgeram)
	
	# Example distance structure
	components &lt;- list(prop = c("AGE", "SEX.2", "FR.pass", "REST_USE1", "ROLLOVER1",
	            "IMPACT3", "SP_LIMIT", "DR_DRINK", "FIRE_EXP1.1"), 
	            mahal = c("SEX.2", "AGE", "SP_LIMIT", "DR_DRINK"), 				
	            mahal = c("IMPACT3", "REST_USE1"))
	wgts &lt;- c(5, 8, 20)
	
	distmat &lt;- multigrp_dist_struc(Dodgeram, 
            grouplabel = c("NOSAB","optSAB","WITHSABS"), components, wgts)
	
	## Propensity score caliper can be implemented mannually
	
	distmat &lt;- multigrp_dist_struc(Dodgeram, 
            grouplabel = c("NOSAB","optSAB","WITHSABS"), 
            list(mahal = c("SEX.2", "AGE", "SP_LIMIT", "DR_DRINK"), 				
                mahal = c("IMPACT3", "REST_USE1")), wgts=c(2, 5))
	distmat_prop &lt;- multigrp_dist_struc(Dodgeram, 
                grouplabel = c("NOSAB", "optSAB", "WITHSABS"), 
              list(prop = c("AGE", "SEX.2", "FR.pass", "REST_USE1", "ROLLOVER1",
	            "IMPACT3", "SP_LIMIT", "DR_DRINK", "FIRE_EXP1.1")), 1)
		
	## Distance structure with caliper
	for(i in 1:length(distmat))
			distmat[[i]][distmat_prop[[i]]&gt;.2] &lt;- 100*max(distmat[[i]])
			
				
									   
## An example function for argument detail.

smahal &lt;-  function(z,X){
        X&lt;-as.matrix(X)
		n&lt;-dim(X)[1]
		rownames(X)&lt;-1:n
		k&lt;-dim(X)[2]
		m&lt;-sum(z)
		for (j in 1:k) X[,j]&lt;-rank(X[,j])
		cv&lt;-cov(X)
		vuntied&lt;-var(1:n)
		rat&lt;-sqrt(vuntied/diag(cv))
		cv&lt;-diag(rat)
		out&lt;-matrix(NA,m,n-m)
		Xc&lt;-X[z==0,,drop=FALSE]
		Xt&lt;-X[z==1,,drop=FALSE]
		rownames(out)&lt;-rownames(X)[z==1]
		colnames(out)&lt;-rownames(X)[z==0]
		#library(MASS)
		icov&lt;-ginv(cv)
		for (i in 1:m) 
			out[i,]&lt;-mahalanobis(Xc,Xt[i,],icov,inverted=T)
		sqrt(out)
	}
</code></pre>

<hr>
<h2 id='nrbalancematch'>
The is the background function to perform matching using network optimization.
</h2><span id='topic+nrbalancematch'></span>

<h3>Description</h3>

<p>This function takes as input the information on two groups, treated and control,
along with the data structure between the units of these two groups to create a
matching. Custom specification of the categorization of the units for near fine
balanced design and balance constraints can be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrbalancematch(cardata.fil, trt_labs, ctrl_labs, stratify, extmatch = NA, 
distmat, balanceValues, nmatch = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrbalancematch_+3A_cardata.fil">cardata.fil</code></td>
<td>

<p>A data frame or matrix of the dataset. The units are identified using the 
rownames of the data.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_trt_labs">trt_labs</code></td>
<td>

<p>A logical vector of same length as nrow(cardata.fil) for the treated units.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_ctrl_labs">ctrl_labs</code></td>
<td>

<p>A logical vector of same length as nrow(cardata.fil) for the control units.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_stratify">stratify</code></td>
<td>

<p>A character vector of same length as nrow(cardata.fil) specifyting the 
categorization of the units for fine balancing.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_extmatch">extmatch</code></td>
<td>

<p>The name of the column of cardata.fil on which design will be exactly matched.
This is optional.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_distmat">distmat</code></td>
<td>

<p>A numeric matrix of distances of size the number of treated units <code class="reqn">\times</code>
number of control units. The rows and columns should be named by the unit 
names.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_balancevalues">balanceValues</code></td>
<td>

<p>A named integer vector of balance values of the categories.
</p>
</td></tr>
<tr><td><code id="nrbalancematch_+3A_nmatch">nmatch</code></td>
<td>

<p>Number of control units to be matched to each treated units. A positive 
integer.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Do not use this function directly unless you are certain of the usage. 
</p>
<p>IMPORTANT NOTE: In order to perform matching, <code>kwaymatching</code> requires the 
user to load the optmatch (&gt;= 0.9-1) package separately. The manual loading is 
required due to software license issues. If the package is not loaded the 
<code>nrbalancematch</code> command will fail with an error saying the optmatch package 
is not present. Reference to optmatch is given below.
</p>


<h3>Value</h3>

<p>A matrix of two columns first column for the treated unit and the second column 
for the control unit. Units in the first column will be repeated <code>nmatch</code>
times.
</p>


<h3>Author(s)</h3>

<p>Bikram Karmakar
</p>


<h3>References</h3>

<p>Hansen, B.B. and Klopfer, S.O. (2006) Optimal full matching and related designs via network flows,
JCGS 15 609-627.
</p>
<p>Karmakar, B., Small, D. S. and Rosenbaum, P. R. (2019) Using Approximation Algorithms to Build 
Evidence Factors and Related Designs for Observational Studies, Journal of Computational 
and Graphical Statistics, 28, 698-709.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tripletmatching">tripletmatching</a></code>, <code><a href="#topic+kwaymatching">kwaymatching</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
