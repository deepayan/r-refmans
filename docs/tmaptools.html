<!DOCTYPE html><html><head><title>Help for package tmaptools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tmaptools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tmaptools-package'><p>Thematic Map Tools</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#approx_areas'><p>Approximate area sizes of the shapes</p></a></li>
<li><a href='#approx_distances'><p>Approximate distances</p></a></li>
<li><a href='#bb'><p>Bounding box generator</p></a></li>
<li><a href='#bb_poly'><p>Convert bounding box to a spatial polygon</p></a></li>
<li><a href='#calc_densities'><p>Calculate densities</p></a></li>
<li><a href='#crop_shape'><p>Crop shape object</p></a></li>
<li><a href='#deprecated_functions'><p>Deprecated tmaptools functions</p></a></li>
<li><a href='#geocode_OSM'><p>Geocodes a location using OpenStreetMap Nominatim</p></a></li>
<li><a href='#get_asp_ratio'><p>Get aspect ratio</p></a></li>
<li><a href='#get_brewer_pal'><p>Get and plot a (modified) Color Brewer palette</p></a></li>
<li><a href='#get_neighbours'><p>Get neighbours list from spatial objects</p></a></li>
<li><a href='#map_coloring'><p>Map coloring</p></a></li>
<li><a href='#palette_explorer'><p>Explore color palettes</p></a></li>
<li><a href='#read_GPX'><p>Read GPX file</p></a></li>
<li><a href='#read_osm'><p>Read Open Street Map data</p></a></li>
<li><a href='#rev_geocode_OSM'><p>Reverse geocodes a location using OpenStreetMap Nominatim</p></a></li>
<li><a href='#simplify_shape'><p>Simplify shape</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Thematic Map Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-1</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools for reading and processing spatial data. The aim is to supply the workflow to create thematic maps. This package also facilitates 'tmap', the package for visualizing thematic maps.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-19</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 0.9.2), lwgeom (&ge; 0.1-4), stars (&ge; 0.4-1), units (&ge;
0.6-1), grid, magrittr, RColorBrewer, viridisLite, stats,
dichromat, XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tmap (&ge; 3.0), rmapshaper, osmdata, OpenStreetMap, raster,
png, shiny, shinyjs</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mtennekes/tmaptools">https://github.com/mtennekes/tmaptools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mtennekes/tmaptools/issues">https://github.com/mtennekes/tmaptools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-19 19:53:16 UTC; mtes</td>
</tr>
<tr>
<td>Author:</td>
<td>Martijn Tennekes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martijn Tennekes &lt;mtennekes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-19 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tmaptools-package'>Thematic Map Tools</h2><span id='topic+tmaptools-package'></span><span id='topic+tmaptools'></span>

<h3>Description</h3>

<p>This package offers a set of handy tool functions for reading and processing spatial data. The aim of these functions is to supply the workflow to create thematic maps, e.g. read shape files, set map projections, append data, calculate areas and distances, and query OpenStreetMap. The visualization of thematic maps can be done with the tmap package.
</p>


<h3>Details</h3>

<p>This page provides a brief overview of all package functions.
</p>


<h3>Tool functions (shape)</h3>


<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+approx_areas">approx_areas</a></code></td><td style="text-align: left;"> Approximate area sizes of polygons </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+approx_distances">approx_distances</a></code></td><td style="text-align: left;"> Approximate distances </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bb">bb</a></code></td><td style="text-align: left;"> Create, extract or modify a bounding box </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bb_poly">bb_poly</a></code></td><td style="text-align: left;"> Convert bounding box to a polygon </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+get_asp_ratio">get_asp_ratio</a></code></td><td style="text-align: left;"> Get the aspect ratio of a shape object </td>
</tr>
<tr>
 <td style="text-align: left;">
--------------------------- </td><td style="text-align: left;"> --------------------------------------------------------------------------------------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Tool functions (colors)</h3>


<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+get_brewer_pal">get_brewer_pal</a></code></td><td style="text-align: left;"> Get and plot a (modified) Color Brewer palette </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+map_coloring">map_coloring</a></code></td><td style="text-align: left;"> Find different colors for adjacent polygons </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+palette_explorer">palette_explorer</a></code></td><td style="text-align: left;"> Explore Color Brewer palettes </td>
</tr>
<tr>
 <td style="text-align: left;">
--------------------------- </td><td style="text-align: left;"> --------------------------------------------------------------------------------------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Spatial transformation functions</h3>


<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+crop_shape">crop_shape</a></code></td><td style="text-align: left;"> Crop shape objects </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+simplify_shape">simplify_shape</a></code></td><td style="text-align: left;"> Simplify a shape </td>
</tr>
<tr>
 <td style="text-align: left;">
--------------------------- </td><td style="text-align: left;"> --------------------------------------------------------------------------------------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Input and output functions</h3>


<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+geocode_OSM">geocode_OSM</a></code></td><td style="text-align: left;"> Get a location from an address description </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+read_GPX">read_GPX</a></code></td><td style="text-align: left;"> Read a GPX file </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+read_osm">read_osm</a></code></td><td style="text-align: left;"> Read Open Street Map data </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rev_geocode_OSM">rev_geocode_OSM</a></code></td><td style="text-align: left;"> Get an address description from a location </td>
</tr>
<tr>
 <td style="text-align: left;">
--------------------------- </td><td style="text-align: left;"> --------------------------------------------------------------------------------------------------- </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Martijn Tennekes <a href="mailto:mtennekes@gmail.com">mtennekes@gmail.com</a>
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>The pipe operator from magrittr, <code>%&gt;%</code>, can also be used in functions from <code>tmaptools</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>Left-hand side</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>Right-hand side</p>
</td></tr>
</table>

<hr>
<h2 id='approx_areas'>Approximate area sizes of the shapes</h2><span id='topic+approx_areas'></span>

<h3>Description</h3>

<p>Approximate the area sizes of the polygons in real-world area units (such as sq km or sq mi), proportional numbers, or normalized numbers. Also, the areas can be calibrated to a prespecified area total. This function is a convenient wrapper around <code><a href="sf.html#topic+geos_measures">st_area</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_areas(shp, target = "metric", total.area = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_areas_+3A_shp">shp</code></td>
<td>
<p>shape object, i.e., an <code><a href="sf.html#topic+sf">sf</a></code> or <code>sp</code> object.</p>
</td></tr>
<tr><td><code id="approx_areas_+3A_target">target</code></td>
<td>
<p>target unit, one of
</p>

<dl>
<dt><code>"prop"</code>:</dt><dd><p>Proportional numbers. In other words, the sum of the area sizes equals one.</p>
</dd>
<dt><code>"norm"</code>:</dt><dd><p>Normalized numbers. All area sizes are normalized to the largest area, of which the area size equals one.</p>
</dd>
<dt><code>"metric"</code> (default):</dt><dd><p>Output area sizes will be either <code>"km"</code> (kilometer) or <code>"m"</code> (meter) depending on the map scale</p>
</dd>
<dt><code>"imperial"</code>:</dt><dd><p>Output area sizes will be either <code>"mi"</code> (miles) or <code>"ft"</code> (feet) depending on the map scale</p>
</dd>
<dt>other:</dt><dd><p>Predefined values are &quot;km^2&quot;, &quot;m^2&quot;, &quot;mi^2&quot;, and &quot;ft^2&quot;. Other values can be specified as well, in which case <code>to</code> is required).</p>
</dd></dl>

<p>These units are the output units. See <code>orig</code> for the coordinate units used by the shape <code>shp</code>.</p>
</td></tr>
<tr><td><code id="approx_areas_+3A_total.area">total.area</code></td>
<td>
<p>total area size of <code>shp</code> in number of target units (defined by <code>target</code>). Useful if the total area of the <code>shp</code> differs from a reference total area value. For <code>"metric"</code> and <code>"imperial"</code> units, please provide the total area in squared kilometers respectively miles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the method of determining areas is an approximation, since it depends on the used projection and the level of detail of the shape object. Projections with equal-area property are highly recommended. See <a href="https://en.wikipedia.org/wiki/List_of_map_projections">https://en.wikipedia.org/wiki/List_of_map_projections</a> for equal area world map projections.
</p>


<h3>Value</h3>

<p>Numeric vector of area sizes (class <code><a href="units.html#topic+units">units</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+approx_distances">approx_distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(NLD_muni)

    NLD_muni$area &lt;- approx_areas(NLD_muni, total.area = 33893)

    tm_shape(NLD_muni) +
        tm_bubbles(size="area", title.size=expression("Area in " * km^2))


    # function that returns min, max, mean and sum of area values
    summary_areas &lt;- function(x) {
        list(min_area=min(x),
             max_area=max(x),
             mean_area=mean(x),
             sum_area=sum(x))
    }

    # area of the polygons
    approx_areas(NLD_muni) %&gt;% summary_areas()

    # area of the polygons, adjusted corrected for a specified total area size
    approx_areas(NLD_muni, total.area=33893) %&gt;% summary_areas()

    # proportional area of the polygons
    approx_areas(NLD_muni, target = "prop") %&gt;% summary_areas()

    # area in squared miles
    approx_areas(NLD_muni, target = "mi mi") %&gt;% summary_areas()

    # area of the polygons when unprojected
    approx_areas(NLD_muni %&gt;% sf::st_transform(crs = 4326)) %&gt;% summary_areas()
}
</code></pre>

<hr>
<h2 id='approx_distances'>Approximate distances</h2><span id='topic+approx_distances'></span>

<h3>Description</h3>

<p>Approximate distances between two points or across the horizontal and vertical centerlines of a bounding box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_distances(x, y = NULL, projection = NULL, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_distances_+3A_x">x</code></td>
<td>
<p>object that can be coerced to a bounding box with <code><a href="#topic+bb">bb</a></code>, or a pair of coordintes (vector of two). In the former case, the distance across the horizontal and vertical centerlines of the bounding box are approximated. In the latter case, <code>y</code> is also required; the distance between points <code>x</code> and <code>y</code> is approximated.</p>
</td></tr>
<tr><td><code id="approx_distances_+3A_y">y</code></td>
<td>
<p>a pair of coordintes, vector of two. Only required when <code>x</code> is also a pair of coordintes.</p>
</td></tr>
<tr><td><code id="approx_distances_+3A_projection">projection</code></td>
<td>
<p>projection code, needed in case <code>x</code> is a bounding box or when <code>x</code> and <code>y</code> are pairs of coordinates. See <code><a href="#topic+get_proj4">get_proj4</a></code></p>
</td></tr>
<tr><td><code id="approx_distances_+3A_target">target</code></td>
<td>
<p>target unit, one of:  <code>"m"</code>, <code>"km"</code>, <code>"mi"</code>, and <code>"ft"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>y</code> is specifyed, a list of two: unit and dist. Else, a list of three: unit, hdist (horizontal distance) and vdist (vertical distance).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+approx_areas">approx_areas</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(tmap)) {
    data(NLD_prov)

    # North-South and East-West distances of the Netherlands
    approx_distances(NLD_prov)

    # Distance between Maastricht and Groningen
    p_maastricht &lt;- geocode_OSM("Maastricht")$coords
    p_groningen &lt;- geocode_OSM("Groningen")$coords
    approx_distances(p_maastricht, p_groningen, projection = 4326, target = "km")

    # Check distances in several projections
    sapply(c(3035, 28992, 4326), function(projection) {
        p_maastricht &lt;- geocode_OSM("Maastricht", projection = projection)$coords
        p_groningen &lt;- geocode_OSM("Groningen", projection = projection)$coords
        approx_distances(p_maastricht, p_groningen, projection = projection)
    })
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bb'>Bounding box generator</h2><span id='topic+bb'></span>

<h3>Description</h3>

<p>Swiss army knife for bounding boxes. Modify an existing bounding box or create a new bounding box from scratch. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb(
  x = NA,
  ext = NULL,
  cx = NULL,
  cy = NULL,
  width = NULL,
  height = NULL,
  xlim = NULL,
  ylim = NULL,
  relative = FALSE,
  asp.limit = NULL,
  current.projection = NULL,
  projection = NULL,
  output = c("bbox", "matrix", "extent")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bb_+3A_x">x</code></td>
<td>
<p>One of the following:
</p>

<ul>
<li><p> A shape from class <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="stars.html#topic+st_as_stars">stars</a></code>, <code>sp</code>, or <code>raster</code>.
</p>
</li>
<li><p> A bounding box (<code><a href="sf.html#topic+st_bbox">st_bbox</a></code>, <code>Extent</code> (<code>raster</code> package, which will no longer be supported in the future versions), numeric vector of 4 (default order: xmin, ymin, xmax, ymax), or a 2x2 matrix).
</p>
</li>
<li><p> Open Street Map search query. The bounding is automatically generated by querying <code>x</code> from Open Street Map Nominatim. See <code><a href="#topic+geocode_OSM">geocode_OSM</a></code> and <a href="https://wiki.openstreetmap.org/wiki/Nominatim">https://wiki.openstreetmap.org/wiki/Nominatim</a>.</p>
</li></ul>

<p>If <code>x</code> is not specified, a bounding box can be created from scratch (see details).</p>
</td></tr>
<tr><td><code id="bb_+3A_ext">ext</code></td>
<td>
<p>Extension factor of the bounding box. If 1, the bounding box is unchanged. Values smaller than 1 reduces the bounding box, and values larger than 1 enlarges the bounding box. This argument is a shortcut for both <code>width</code> and <code>height</code> with <code>relative=TRUE</code>. If a negative value is specified, then the shortest side of the bounding box (so width or height) is extended with <code>ext</code>, and the longest side is extended with the same absolute value. This is especially useful for bounding boxes with very low or high aspect ratios.</p>
</td></tr>
<tr><td><code id="bb_+3A_cx">cx</code></td>
<td>
<p>center x coordinate</p>
</td></tr>
<tr><td><code id="bb_+3A_cy">cy</code></td>
<td>
<p>center y coordinate</p>
</td></tr>
<tr><td><code id="bb_+3A_width">width</code></td>
<td>
<p>width of the bounding box. These are either absolute or relative (depending on the argument <code>relative</code>).</p>
</td></tr>
<tr><td><code id="bb_+3A_height">height</code></td>
<td>
<p>height of the bounding box. These are either absolute or relative (depending on the argument <code>relative</code>).</p>
</td></tr>
<tr><td><code id="bb_+3A_xlim">xlim</code></td>
<td>
<p>limits of the x-axis. These are either absolute or relative (depending on the argument <code>relative</code>).</p>
</td></tr>
<tr><td><code id="bb_+3A_ylim">ylim</code></td>
<td>
<p>limits of the y-axis. See <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="bb_+3A_relative">relative</code></td>
<td>
<p>boolean that determines whether relative values are used for <code>width</code>, <code>height</code>, <code>xlim</code> and <code>ylim</code> or absolute. If <code>x</code> is unspecified, <code>relative</code> is set to <code>"FALSE"</code>.</p>
</td></tr>
<tr><td><code id="bb_+3A_asp.limit">asp.limit</code></td>
<td>
<p>maximum aspect ratio, which is width/height. Number greater than or equal to 1. For landscape bounding boxes, <code>1/asp.limit</code> will be used. The returned bounding box will have an aspect ratio between <code>1/asp.limit</code> and <code>asp.limit</code>.</p>
</td></tr>
<tr><td><code id="bb_+3A_current.projection">current.projection</code></td>
<td>
<p>projection that corresponds to the bounding box specified by <code>x</code>.</p>
</td></tr>
<tr><td><code id="bb_+3A_projection">projection</code></td>
<td>
<p>projection to transform the bounding box to.</p>
</td></tr>
<tr><td><code id="bb_+3A_output">output</code></td>
<td>
<p>output format of the bounding box, one of:
</p>

<ul>
<li> <p><code>"bbox"</code> a <code>sf::bbox</code> object, which is a numeric vector of 4: xmin, ymin, xmax, ymax. This representation used by the <code><a href="sf.html#topic+sf">sf</a></code> package.
</p>
</li>
<li> <p><code>"matrix"</code> a 2 by 2 numeric matrix, where the rows correspond to x and y, and the columns to min and max. This representation used by the <code>sp</code> package.
</p>
</li>
<li> <p><code>"extent"</code> an <code>raster::extent</code> object, which is a numeric vector of 4: xmin, xmax, ymin, ymax. This representation used by the <code>raster</code> package.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>An existing bounding box (defined by <code>x</code>) can be modified as follows:
</p>

<ul>
<li><p> Using the extension factor <code>ext</code>.
</p>
</li>
<li><p> Changing the width and height with <code>width</code> and <code>height</code>. The argument <code>relavitve</code> determines whether relative or absolute values are used.
</p>
</li>
<li><p> Setting the x and y limits. The argument <code>relavitve</code> determines whether relative or absolute values are used.</p>
</li></ul>

<p>A new bounding box can be created from scratch as follows:
</p>

<ul>
<li><p> Using the extension factor <code>ext</code>.
</p>
</li>
<li><p> Setting the center coorinates <code>cx</code> and <code>cy</code>, together with the <code>width</code> and <code>height</code>.
</p>
</li>
<li><p> Setting the x and y limits <code>xlim</code> and <code>ylim</code>
</p>
</li></ul>



<h3>Value</h3>

<p>bounding box (see argument <code>output</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geocode_OSM">geocode_OSM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {

    ## load shapes
    data(NLD_muni)
    data(World)

    ## get bounding box (similar to sp's function bbox)
    bb(NLD_muni)

    ## extent it by factor 1.10
    bb(NLD_muni, ext=1.10)

    ## convert to longlat
    bb(NLD_muni, projection=4326)

    ## change existing bounding box
    bb(NLD_muni, ext=1.5)
    bb(NLD_muni, width=2, relative = TRUE)
    bb(NLD_muni, xlim=c(.25, .75), ylim=c(.25, .75), relative = TRUE)

}

## Not run: 
if (require(tmap)) {
    bb("Limburg", projection = "rd")
    bb_italy &lt;- bb("Italy", projection = "eck4")

    tm_shape(World, bbox=bb_italy) + tm_polygons()
    # shorter alternative: tm_shape(World, bbox="Italy") + tm_polygons()
}
## End(Not run)
</code></pre>

<hr>
<h2 id='bb_poly'>Convert bounding box to a spatial polygon</h2><span id='topic+bb_poly'></span><span id='topic+bb_earth'></span>

<h3>Description</h3>

<p>Convert bounding box to a spatial (<code><a href="sf.html#topic+sfc">sfc</a></code>) object . Useful for plotting (see example). The function <code>bb_earth</code> returns a spatial polygon of the 'boundaries' of the earth, which can also be done in other projections (if a feasible solution exists).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb_poly(x, steps = 100, stepsize = NA, projection = NULL)

bb_earth(
  projection = NULL,
  stepsize = 1,
  earth.datum = 4326,
  bbx = c(-180, -90, 180, 90),
  buffer = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bb_poly_+3A_x">x</code></td>
<td>
<p>object that can be coerced to a bounding box with <code><a href="#topic+bb">bb</a></code></p>
</td></tr>
<tr><td><code id="bb_poly_+3A_steps">steps</code></td>
<td>
<p>number of intermediate points along the shortest edge of the bounding box. The number of intermediate points along the longest edge scales with the aspect ratio. These intermediate points are needed if the bounding box is plotted in another projection.</p>
</td></tr>
<tr><td><code id="bb_poly_+3A_stepsize">stepsize</code></td>
<td>
<p>stepsize in terms of coordinates (usually meters when the shape is projected and degrees of longlat coordinates are used). If specified, it overrules <code>steps</code></p>
</td></tr>
<tr><td><code id="bb_poly_+3A_projection">projection</code></td>
<td>
<p>projection in which the coordinates of <code>x</code> are provided. For <code>bb_earth</code>, <code>projection</code> is the projection in which the bounding box is returned (if possible).</p>
</td></tr>
<tr><td><code id="bb_poly_+3A_earth.datum">earth.datum</code></td>
<td>
<p>Geodetic datum to determine the earth boundary. By default EPSG 4326.</p>
</td></tr>
<tr><td><code id="bb_poly_+3A_bbx">bbx</code></td>
<td>
<p>boundig box of the earth in a vector of 4 values: min longitude, max longitude, min latitude, max latitude. By default <code>c(-180, 180, -90, 90)</code>. If for some <code>projection</code>, a feasible solution does not exist, it may be wise to choose a smaller bbx, e.g. <code>c(-180, 180, -88, 88)</code>. However, this is also automatically done with the next argument, <code>buffer</code>.</p>
</td></tr>
<tr><td><code id="bb_poly_+3A_buffer">buffer</code></td>
<td>
<p>In order to determine feasible earth bounding boxes in other projections, a buffer is used to decrease the bounding box by a small margin (default <code>1e-06</code>). This value is subtracted from each the bounding box coordinates. If it still does not result in a feasible bounding box, this procedure is repeated 5 times, where each time the buffer is multiplied by 10. Set <code>buffer=0</code> to disable this procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="sf.html#topic+sfc">sfc</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(NLD_muni)

    current.mode &lt;- tmap_mode("view")
    qtm(bb_poly(NLD_muni))

    # restore mode
    tmap_mode(current.mode)
}
</code></pre>

<hr>
<h2 id='calc_densities'>Calculate densities</h2><span id='topic+calc_densities'></span>

<h3>Description</h3>

<p>Transpose quantitative variables to densitiy variables, which are often needed for choroplets. For example, the colors of a population density map should correspond population density counts rather than absolute population numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_densities(
  shp,
  var,
  target = "metric",
  total.area = NULL,
  suffix = NA,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_densities_+3A_shp">shp</code></td>
<td>
<p>a shape object, i.e., an <code><a href="sf.html#topic+sf">sf</a></code> object or a <code>SpatialPolygons(DataFrame)</code> from the <code>sp</code> package.</p>
</td></tr>
<tr><td><code id="calc_densities_+3A_var">var</code></td>
<td>
<p>name(s) of a qualtity variable name contained in the <code>shp</code> data</p>
</td></tr>
<tr><td><code id="calc_densities_+3A_target">target</code></td>
<td>
<p>the target unit, see <code><a href="#topic+approx_areas">approx_areas</a></code>. Density values are calculated in <code>var/target^2</code>.</p>
</td></tr>
<tr><td><code id="calc_densities_+3A_total.area">total.area</code></td>
<td>
<p>total area size of <code>shp</code> in number of target units (defined by <code>unit</code>), <code><a href="#topic+approx_areas">approx_areas</a></code>.</p>
</td></tr>
<tr><td><code id="calc_densities_+3A_suffix">suffix</code></td>
<td>
<p>character that is appended to the variable names. The resulting names are used as column names of the returned data.frame. By default, <code>_sq_&lt;target&gt;</code>, where target corresponds to the target unit, e.g. <code>_sq_km</code></p>
</td></tr>
<tr><td><code id="calc_densities_+3A_drop">drop</code></td>
<td>
<p>boolean that determines whether an one-column data-frame should be returned as a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector or data.frame (depending on whether <code>length(var)==1</code> with density values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(NLD_muni)

    NLD_muni_pop_per_km2 &lt;- calc_densities(NLD_muni,
        target = "km km", var = c("pop_men", "pop_women"))
    NLD_muni &lt;- sf::st_sf(data.frame(NLD_muni, NLD_muni_pop_per_km2))

    tm_shape(NLD_muni) +
    	tm_polygons(c("pop_men_km.2", "pop_women_km.2"),
            title=expression("Population per " * km^2), style="quantile") +
    tm_facets(free.scales = FALSE) +
    tm_layout(panel.show = TRUE, panel.labels=c("Men", "Women"))
}
</code></pre>

<hr>
<h2 id='crop_shape'>Crop shape object</h2><span id='topic+crop_shape'></span>

<h3>Description</h3>

<p>Crop a shape object (from class <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="stars.html#topic+st_as_stars">stars</a></code>, <code>sp</code>, or <code>raster</code>). A shape file <code>x</code> is cropped, either by the bounding box of another shape <code>y</code>, or by <code>y</code> itself if it is a SpatialPolygons object and <code>polygon = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_shape(x, y, polygon = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_shape_+3A_x">x</code></td>
<td>
<p>shape object, i.e. an object from class <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="stars.html#topic+st_as_stars">stars</a></code>, <code>sp</code>, or <code>raster</code>.</p>
</td></tr>
<tr><td><code id="crop_shape_+3A_y">y</code></td>
<td>
<p>bounding box, an <code><a href="sf.html#topic+st_bbox">st_bbox</a></code>,  <code>extent</code> (<code>raster</code> package), or a shape object from which the bounding box is extracted (unless <code>polygon</code> is <code>TRUE</code> and <code>x</code> is an <code>sf</code> object).</p>
</td></tr>
<tr><td><code id="crop_shape_+3A_polygon">polygon</code></td>
<td>
<p>should <code>x</code> be cropped by the polygon defined by <code>y</code>? If <code>FALSE</code> (default), <code>x</code> is cropped by the bounding box of <code>x</code>. Polygon cropping only works when <code>x</code> is a spatial object and <code>y</code> is a <code>SpatialPolygons</code> object.</p>
</td></tr>
<tr><td><code id="crop_shape_+3A_...">...</code></td>
<td>
<p>not used anymore</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>crop</code> from the <code>raster</code> package. The main difference is that <code>crop_shape</code> also allows to crop using a polygon instead of a rectangle.
</p>


<h3>Value</h3>

<p>cropped shape, in the same class as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bb">bb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(World, NLD_muni, land, metro)

    #land_NLD &lt;- crop_shape(land, NLD_muni)

    #qtm(land_NLD, raster="trees", style="natural")

    metro_Europe &lt;- crop_shape(metro, World[World$continent == "Europe", ], polygon = TRUE)

    qtm(World) +
    tm_shape(metro_Europe) +
    	tm_bubbles("pop2010", col="red", title.size="European cities") +
    	tm_legend(frame=TRUE)
}
</code></pre>

<hr>
<h2 id='deprecated_functions'>Deprecated tmaptools functions</h2><span id='topic+deprecated_functions'></span><span id='topic+get_proj4'></span><span id='topic+set_projection'></span><span id='topic+get_projection'></span><span id='topic+is_projected'></span>

<h3>Description</h3>

<p>The following functions are not used anymore or deprecated as of tmaptools version 3.0. These functions are based on the <code>sp</code> package and are not supported anymore. They have been migrated to <a href="https://github.com/mtennekes/oldtmaptools">https://github.com/mtennekes/oldtmaptools</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_proj4(x, output = c("crs", "character", "epsg", "CRS"))

set_projection(
  shp,
  projection = NA,
  current.projection = NA,
  overwrite.current.projection = FALSE
)

get_projection(
  shp,
  guess.longlat = FALSE,
  output = c("character", "crs", "epsg", "CRS")
)

is_projected(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated_functions_+3A_x">x</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_output">output</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_shp">shp</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_projection">projection</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_current.projection">current.projection</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_overwrite.current.projection">overwrite.current.projection</code></td>
<td>
<p>see documentation in tmaptools 2.x for details</p>
</td></tr>
<tr><td><code id="deprecated_functions_+3A_guess.longlat">guess.longlat</code></td>
<td>
<p>see documentation in tmaptools 2.x for details
</p>
<p>Deprecated as of version 2.0
</p>

<ul>
<li> <p><code>append_data</code>, <code>aggregate_map</code>, <code>double_line</code>, <code>points_to_raster</code>, <code>poly_to_raster</code>, <code>sample_dots</code>, <code>sbind</code>, <code>smooth_map</code>, <code>smooth_raster_cover</code>, <code>read_shape</code>, <code>write_shape</code>. These functions are based on the <code>sp</code> package and are not supported anymore. They have been migrated to <a href="https://github.com/mtennekes/oldtmaptools">https://github.com/mtennekes/oldtmaptools</a>
</p>
</li>
<li> <p><code>osm_poly</code>, <code>osm_line</code>, <code>osm_point</code>. Please use the package <code>osmdata</code>
</p>
</li></ul>

<p>Deprecated as of version 3.0
</p>

<ul>
<li> <p><code>get_proj4</code>: for projections, please use the function <code><a href="sf.html#topic+st_crs">st_crs</a></code>
</p>
</li>
<li> <p><code>set_projection</code> for setting map projections, use <code><a href="sf.html#topic+st_crs">st_crs</a></code> or <code><a href="sf.html#topic+st_transform">st_transform</a></code>
</p>
</li>
<li> <p><code>get_projection</code> for getting map projections, use <code><a href="sf.html#topic+st_crs">st_crs</a></code>
</p>
</li>
<li> <p><code>is_projected</code> for checking if projections are long lat coordinates, use <code><a href="sf.html#topic+st_is_longlat">st_is_longlat</a></code>
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='geocode_OSM'>Geocodes a location using OpenStreetMap Nominatim</h2><span id='topic+geocode_OSM'></span>

<h3>Description</h3>

<p>Geocodes a location (based on a search query) to coordinates and a bounding box. Similar to geocode from the ggmap package. It uses OpenStreetMap Nominatim. For processing large amount of queries, please read the usage policy (<a href="https://operations.osmfoundation.org/policies/nominatim/">https://operations.osmfoundation.org/policies/nominatim/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocode_OSM(
  q,
  projection = NULL,
  return.first.only = TRUE,
  keep.unfound = FALSE,
  details = FALSE,
  as.data.frame = NA,
  as.sf = FALSE,
  geometry = c("point", "bbox"),
  server = "https://nominatim.openstreetmap.org"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocode_OSM_+3A_q">q</code></td>
<td>
<p>a character (vector) that specifies a search query. For instance <code>"India"</code> or <code>"CBS Weg 11, Heerlen, Netherlands"</code>.</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_projection">projection</code></td>
<td>
<p>projection in which the coordinates and bounding box are returned. See <code><a href="sf.html#topic+st_crs">st_crs</a></code> for details. By default latitude longitude coordinates (EPSG 4326).</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_return.first.only">return.first.only</code></td>
<td>
<p>Only return the first result</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_keep.unfound">keep.unfound</code></td>
<td>
<p>Keep list items / data.frame rows with <code>NA</code>s for unfound search terms. By default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_details">details</code></td>
<td>
<p>provide output details, other than the point coordinates and bounding box</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>Return the output as a <code>data.frame</code>. If <code>FALSE</code>, a list is returned with at least two items: <code>"coords"</code>, a vector containing the coordinates, and <code>"bbox"</code>, the corresponding bounding box. By default false, unless <code>q</code> contains multiple queries. If <code>as.sf = TRUE</code> (see below), <code>as.data.frame</code> will set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_as.sf">as.sf</code></td>
<td>
<p>Return the output as <code><a href="sf.html#topic+sf">sf</a></code> object. If <code>TRUE</code>, <code>return.first.only</code> will be set to <code>TRUE</code>. Two geometry columns are added: <code>bbox</code> and <code>point</code>. The argument <code>geometry</code> determines which of them is set to the default geometry.</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_geometry">geometry</code></td>
<td>
<p>When <code>as.sf</code>, this argument determines which column (<code>bbox</code> or <code>point</code>) is set as geometry column. Note that the geometry can be changed afterwards with <code><a href="sf.html#topic+st_geometry">st_set_geometry</a></code>.</p>
</td></tr>
<tr><td><code id="geocode_OSM_+3A_server">server</code></td>
<td>
<p>OpenStreetMap Nominatim server name. Could also be a local OSM Nominatim server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.sf</code> then a <code><a href="sf.html#topic+sf">sf</a></code> object is returned. Else, if <code>as.data.frame</code>, then a <code>data.frame</code> is returned, else a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rev_geocode_OSM">rev_geocode_OSM</a></code>, <code><a href="#topic+bb">bb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(tmap)) {
    geocode_OSM("India")
    geocode_OSM("CBS Weg 1, Heerlen")
    geocode_OSM("CBS Weg 1, Heerlen", projection = 28992)

    data(metro)

    # sample 5 cities from the metro dataset
    five_cities &lt;- metro[sample(length(metro), 5), ]

    # obtain geocode locations from their long names
    five_cities_geocode &lt;- geocode_OSM(five_cities$name_long, as.sf = TRUE)

    # change to interactive mode
    current.mode &lt;- tmap_mode("view")

    # plot metro coordinates in red and geocode coordinates in blue
    # zoom in to see the differences
    tm_shape(five_cities) +
    	tm_dots(col = "blue") +
    tm_shape(five_cities_geocode) +
    	tm_dots(col = "red")

    # restore current mode
    tmap_mode(current.mode)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='get_asp_ratio'>Get aspect ratio</h2><span id='topic+get_asp_ratio'></span>

<h3>Description</h3>

<p>Get the aspect ratio of a shape object, a <code><a href="tmap.html#topic+tmap-element">tmap</a></code> object, or a bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_asp_ratio(x, is.projected = NA, width = 700, height = 700, res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_asp_ratio_+3A_x">x</code></td>
<td>
<p>A shape from class <code><a href="sf.html#topic+sf">sf</a></code>, <code><a href="stars.html#topic+st_as_stars">stars</a></code>, <code>sp</code>, or <code>Raster</code>, a bounding box (that can be coerced by <code><a href="#topic+bb">bb</a></code>), or a <code><a href="tmap.html#topic+tmap-element">tmap</a></code> object.</p>
</td></tr>
<tr><td><code id="get_asp_ratio_+3A_is.projected">is.projected</code></td>
<td>
<p>Logical that determined wether the coordinates of <code>x</code> are projected (<code>TRUE</code>) or longitude latitude coordinates (<code>FALSE</code>). By deafult, it is determined by the coordinates of <code>x</code>.</p>
</td></tr>
<tr><td><code id="get_asp_ratio_+3A_width">width</code></td>
<td>
<p>See details; only applicable if <code>x</code> is a <code><a href="tmap.html#topic+tmap-element">tmap</a></code> object.</p>
</td></tr>
<tr><td><code id="get_asp_ratio_+3A_height">height</code></td>
<td>
<p>See details; only applicable if <code>x</code> is a <code><a href="tmap.html#topic+tmap-element">tmap</a></code> object.</p>
</td></tr>
<tr><td><code id="get_asp_ratio_+3A_res">res</code></td>
<td>
<p>See details; only applicable if <code>x</code> is a <code><a href="tmap.html#topic+tmap-element">tmap</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>width</code>, <code>height</code>, and <code>res</code> are passed on to <code><a href="grDevices.html#topic+png">png</a></code>. If <code>x</code> is a tmap object, a temporarily png image is created to calculate the aspect ratio of a tmap object. The default size of this image is 700 by 700 pixels at 100 dpi.
</p>


<h3>Value</h3>

<p>aspect ratio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(World)

    get_asp_ratio(World)

    get_asp_ratio(bb(World))

    tm &lt;- qtm(World)
    get_asp_ratio(tm)
}

## Not run: 
    get_asp_ratio("Germany") #note: bb("Germany") uses geocode_OSM("Germany")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_brewer_pal'>Get and plot a (modified) Color Brewer palette</h2><span id='topic+get_brewer_pal'></span>

<h3>Description</h3>

<p>Get and plot a (modified) palette from Color Brewer. In addition to the base function <code><a href="RColorBrewer.html#topic+ColorBrewer">brewer.pal</a></code>, a palette can be created for any number of classes. The contrast of the palette can be adjusted for sequential and diverging palettes. For categorical palettes, intermediate colors can be generated. An interactive tool that uses this function is <code><a href="#topic+palette_explorer">palette_explorer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_brewer_pal(palette, n = 5, contrast = NA, stretch = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_brewer_pal_+3A_palette">palette</code></td>
<td>
<p>name of the color brewer palette. Run <code><a href="#topic+palette_explorer">palette_explorer</a></code> or see <code><a href="RColorBrewer.html#topic+ColorBrewer">brewer.pal</a></code> for options.</p>
</td></tr>
<tr><td><code id="get_brewer_pal_+3A_n">n</code></td>
<td>
<p>number of colors</p>
</td></tr>
<tr><td><code id="get_brewer_pal_+3A_contrast">contrast</code></td>
<td>
<p>a vector of two numbers between 0 and 1 that defines the contrast range of the palette. Applicable to sequential and diverging palettes. For sequential palettes, 0 stands for the leftmost color and 1 the rightmost color. For instance, when <code>contrast=c(.25, .75)</code>, then the palette ranges from 1/4 to 3/4 of the available color range. For diverging palettes, 0 stands for the middle color and 1 for both outer colors. If only one number is provided, the other number is set to 0. The default value depends on <code>n</code>. See details.</p>
</td></tr>
<tr><td><code id="get_brewer_pal_+3A_stretch">stretch</code></td>
<td>
<p>logical that determines whether intermediate colors are used for a categorical palette when <code>n</code> is greater than the number of available colors.</p>
</td></tr>
<tr><td><code id="get_brewer_pal_+3A_plot">plot</code></td>
<td>
<p>should the palette be plot, or only returned? If <code>TRUE</code> the palette is silently returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default contrast of the palette depends on the number of colors, <code>n</code>, in the following way. The default contrast is maximal, so <code>(0, 1)</code>, when <code>n = 9</code> for sequential palettes and <code>n = 11</code> for diverging palettes. The default contrast values for smaller values of <code>n</code> can be extracted with some R magic: <code>sapply(1:9, tmaptools:::default_contrast_seq)</code> for sequential palettes and <code>sapply(1:11, tmaptools:::default_contrast_div)</code> for diverging palettes.
</p>


<h3>Value</h3>

<p>vector of color values. It is silently returned when <code>plot=TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+palette_explorer">palette_explorer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_brewer_pal("Blues")
get_brewer_pal("Blues", contrast=c(.4, .8))
get_brewer_pal("Blues", contrast=c(0, 1))
get_brewer_pal("Blues", n=15, contrast=c(0, 1))

get_brewer_pal("RdYlGn")
get_brewer_pal("RdYlGn", n=11)
get_brewer_pal("RdYlGn", n=11, contrast=c(0, .4))
get_brewer_pal("RdYlGn", n=11, contrast=c(.4, 1))

get_brewer_pal("Set2", n = 12)
get_brewer_pal("Set2", n = 12, stretch = FALSE)
</code></pre>

<hr>
<h2 id='get_neighbours'>Get neighbours list from spatial objects</h2><span id='topic+get_neighbours'></span>

<h3>Description</h3>

<p>Get neighbours list from spatial objects. The output is similar to the function <code>poly2nb</code> of the <code>spdep</code> package, but uses <code>sf</code> instead of <code>sp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbours(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbours_+3A_x">x</code></td>
<td>
<p>a shape object, i.e., a <code><a href="sf.html#topic+sf">sf</a></code> object or a <code>SpatialPolygons(DataFrame)</code> (<code>sp</code> package).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where the items correspond to the features. Each item is a vector of neighbours.
</p>

<hr>
<h2 id='map_coloring'>Map coloring</h2><span id='topic+map_coloring'></span>

<h3>Description</h3>

<p>Color the polygons of a map such that adjacent polygons have different colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_coloring(
  x,
  algorithm = "greedy",
  ncols = NA,
  minimize = FALSE,
  palette = NULL,
  contrast = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_coloring_+3A_x">x</code></td>
<td>
<p>Either a shape (i.e. a <code><a href="sf.html#topic+sf">sf</a></code> or <code>SpatialPolygons(DataFrame)</code> (<code>sp</code> package) object), or an adjacency list.</p>
</td></tr>
<tr><td><code id="map_coloring_+3A_algorithm">algorithm</code></td>
<td>
<p>currently, only &quot;greedy&quot; is implemented.</p>
</td></tr>
<tr><td><code id="map_coloring_+3A_ncols">ncols</code></td>
<td>
<p>number of colors. By default it is 8 when <code>palette</code> is undefined. Else, it is set to the length of <code>palette</code></p>
</td></tr>
<tr><td><code id="map_coloring_+3A_minimize">minimize</code></td>
<td>
<p>logical that determines whether <code>algorithm</code> will search for a minimal number of colors. If <code>FALSE</code>, the <code>ncols</code> colors will be picked by a random procedure.</p>
</td></tr>
<tr><td><code id="map_coloring_+3A_palette">palette</code></td>
<td>
<p>color palette.</p>
</td></tr>
<tr><td><code id="map_coloring_+3A_contrast">contrast</code></td>
<td>
<p>vector of two numbers that determine the range that is used for sequential and diverging palettes (applicable when <code>auto.palette.mapping=TRUE</code>). Both numbers should be between 0 and 1. The first number determines where the palette begins, and the second number where it ends. For sequential palettes, 0 means the brightest color, and 1 the darkest color. For diverging palettes, 0 means the middle color, and 1 both extremes. If only one number is provided, this number is interpreted as the endpoint (with 0 taken as the start).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>palette</code> is defined, a vector of colors is returned, otherwise a vector of color indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tmap) &amp;&amp; packageVersion("tmap") &gt;= "2.0") {
    data(World, metro)

    World$color &lt;- map_coloring(World, palette="Pastel2")
    qtm(World, fill = "color")

    # map_coloring used indirectly: qtm(World, fill = "MAP_COLORS")

    data(NLD_prov, NLD_muni)
    tm_shape(NLD_prov) +
    	tm_fill("name", legend.show = FALSE) +
    tm_shape(NLD_muni) +
    	tm_polygons("MAP_COLORS", palette="Greys", alpha = .25) +
    tm_shape(NLD_prov) +
    	tm_borders(lwd=2) +
    	tm_text("name", shadow=TRUE) +
    tm_format("NLD", title="Dutch provinces and\nmunicipalities", bg.color="white")
}

</code></pre>

<hr>
<h2 id='palette_explorer'>Explore color palettes</h2><span id='topic+palette_explorer'></span><span id='topic+tmap.pal.info'></span>

<h3>Description</h3>

<p><code>palette_explorer()</code> starts an interactive tool shows all Color Brewer and viridis palettes, where the number of colors can be adjusted as well as the constrast range. Categorical (qualitative) palettes can be stretched when the number of colors exceeds the number of palette colors. Output code needed to get the desired color values is generated. Finally, all colors can be tested for color blindness. The data.frame <code>tmap.pal.info</code> is similar to <code><a href="RColorBrewer.html#topic+ColorBrewer">brewer.pal.info</a></code>, but extended with the color palettes from viridis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palette_explorer()

tmap.pal.info
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 40 rows and 4 columns.
</p>


<h3>References</h3>

<p><a href="https://www.color-blindness.com/types-of-color-blindness/">https://www.color-blindness.com/types-of-color-blindness/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_brewer_pal">get_brewer_pal</a></code>, <code><a href="dichromat.html#topic+dichromat">dichromat</a></code>, <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(shiny) &amp;&amp; require(shinyjs)) {
    palette_explorer()
}

## End(Not run)
</code></pre>

<hr>
<h2 id='read_GPX'>Read GPX file</h2><span id='topic+read_GPX'></span>

<h3>Description</h3>

<p>Read a GPX file. By default, it reads all possible GPX layers, and only returns shapes for layers that have any features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_GPX(
  file,
  layers = c("waypoints", "routes", "tracks", "route_points", "track_points"),
  remove.empty.layers = TRUE,
  as.sf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_GPX_+3A_file">file</code></td>
<td>
<p>a GPX filename (including directory)</p>
</td></tr>
<tr><td><code id="read_GPX_+3A_layers">layers</code></td>
<td>
<p>vector of GPX layers. Possible options are <code>"waypoints"</code>, <code>"tracks"</code>, <code>"routes"</code>, <code>"track_points"</code>, <code>"route_points"</code>. By dedault, all those layers are read.</p>
</td></tr>
<tr><td><code id="read_GPX_+3A_remove.empty.layers">remove.empty.layers</code></td>
<td>
<p>should empty layers (i.e. with 0 features) be removed from the list?</p>
</td></tr>
<tr><td><code id="read_GPX_+3A_as.sf">as.sf</code></td>
<td>
<p>not used anymore</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function returns <code><a href="sf.html#topic+sf">sf</a></code> objects, but still uses methods from sp and rgdal internally.
</p>


<h3>Value</h3>

<p>a list of sf objects, one for each layer
</p>

<hr>
<h2 id='read_osm'>Read Open Street Map data</h2><span id='topic+read_osm'></span>

<h3>Description</h3>

<p>Read Open Street Map data. OSM tiles are read and returned as a spatial raster. Vectorized OSM data is not supported anymore (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_osm(
  x,
  zoom = NULL,
  type = "osm",
  minNumTiles = NULL,
  mergeTiles = NULL,
  use.colortable = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_osm_+3A_x">x</code></td>
<td>
<p>object that can be coerced to a bounding box with <code><a href="#topic+bb">bb</a></code> (e.g. an existing bounding box or a shape). In the first case, other arguments can be passed on to <code><a href="#topic+bb">bb</a></code> (see <code>...</code>). If an existing bounding box is specified in projected coordinates, plesae specify <code>current.projection</code>.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_zoom">zoom</code></td>
<td>
<p>passed on to <code><a href="OpenStreetMap.html#topic+openmap">openmap</a></code>. Only applicable when <code>raster=TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_type">type</code></td>
<td>
<p>tile provider, by default <code>"osm"</code>, which corresponds to OpenStreetMap Mapnik. See <code><a href="OpenStreetMap.html#topic+openmap">openmap</a></code> for options. Only applicable when <code>raster=TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_minnumtiles">minNumTiles</code></td>
<td>
<p>passed on to <code><a href="OpenStreetMap.html#topic+openmap">openmap</a></code> Only applicable when <code>raster=TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_mergetiles">mergeTiles</code></td>
<td>
<p>passed on to <code><a href="OpenStreetMap.html#topic+openmap">openmap</a></code> Only applicable when <code>raster=TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_use.colortable">use.colortable</code></td>
<td>
<p>should the colors of the returned raster object be stored in a <code><a href="raster.html#topic+colortable">colortable</a></code>? If <code>FALSE</code>, a RasterStack is returned with three layers that correspond to the red, green and blue values betweeen 0 and 255.</p>
</td></tr>
<tr><td><code id="read_osm_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+bb">bb</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 2.0, <code>read_osm</code> cannot be used to read vectorized OSM data anymore. The reason is that the package that was used under the hood, <code>osmar</code>, has some limitations and is not actively maintained anymore. Therefore, we recommend the package <code>osmdata</code>. Since this package is very user-friendly, there was no reason to use <code>read_osm</code> as a wrapper for reading vectorized OSM data.
</p>


<h3>Value</h3>

<p>The output of <code>read_osm</code> is a <code><a href="raster.html#topic+raster">raster</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(tmap)) {
    #### Choropleth with OSM background

    # load Netherlands shape
    data(NLD_muni)

    # read OSM raster data
    osm_NLD &lt;- read_osm(NLD_muni, ext=1.1)

    # plot with regular tmap functions
    tm_shape(osm_NLD) +
    	tm_rgb() +
    tm_shape(NLD_muni) +
    	tm_polygons("population", convert2density=TRUE, style="kmeans", alpha=.7, palette="Purples")

    #### A close look at the building of Statistics Netherlands in Heerlen

    # create a bounding box around the CBS (Statistics Netherlands) building
    CBS_bb &lt;- bb("CBS Weg 11, Heerlen", width=.003, height=.002)

    # read Microsoft Bing satellite and OpenCycleMap OSM layers
    CBS_osm1 &lt;- read_osm(CBS_bb, type="bing")
    CBS_osm2 &lt;- read_osm(CBS_bb, type="opencyclemap")

    # plot OSM raster data
    qtm(CBS_osm1)
    qtm(CBS_osm2)

}

## End(Not run)
</code></pre>

<hr>
<h2 id='rev_geocode_OSM'>Reverse geocodes a location using OpenStreetMap Nominatim</h2><span id='topic+rev_geocode_OSM'></span>

<h3>Description</h3>

<p>Reverse geocodes a location (based on spatial coordinates) to an address. It uses OpenStreetMap Nominatim. For processing large amount of queries, please read the usage policy (<a href="https://operations.osmfoundation.org/policies/nominatim/">https://operations.osmfoundation.org/policies/nominatim/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_geocode_OSM(
  x,
  y = NULL,
  zoom = NULL,
  projection = 4326,
  as.data.frame = NA,
  server = "https://nominatim.openstreetmap.org"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_geocode_OSM_+3A_x">x</code></td>
<td>
<p>x coordinate(s), or a spatial points object (<code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sp.html#topic+SpatialPoints">SpatialPoints</a></code>)</p>
</td></tr>
<tr><td><code id="rev_geocode_OSM_+3A_y">y</code></td>
<td>
<p>y coordinate(s)</p>
</td></tr>
<tr><td><code id="rev_geocode_OSM_+3A_zoom">zoom</code></td>
<td>
<p>zoom level</p>
</td></tr>
<tr><td><code id="rev_geocode_OSM_+3A_projection">projection</code></td>
<td>
<p>projection in which the coordinates <code>x</code> and <code>y</code> are provided.</p>
</td></tr>
<tr><td><code id="rev_geocode_OSM_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>return as data.frame (<code>TRUE</code>) or list (<code>FALSE</code>). By default a list, unless multiple coordinates are provided.</p>
</td></tr>
<tr><td><code id="rev_geocode_OSM_+3A_server">server</code></td>
<td>
<p>OpenStreetMap Nominatim server name. Could also be a local OSM Nominatim server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or a list with all attributes that are contained in the search result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geocode_OSM">geocode_OSM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(tmap)) {
    data(metro)

    # sample five cities from metro dataset
    set.seed(1234)
    five_cities &lt;- metro[sample(length(metro), 5), ]

    # obtain reverse geocode address information
    addresses &lt;- rev_geocode_OSM(five_cities, zoom = 6)
    five_cities &lt;- sf::st_sf(data.frame(five_cities, addresses))

    # change to interactive mode
    current.mode &lt;- tmap_mode("view")
    tm_shape(five_cities) +
    	tm_markers(text="name")

    # restore current mode
    tmap_mode(current.mode)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='simplify_shape'>Simplify shape</h2><span id='topic+simplify_shape'></span>

<h3>Description</h3>

<p>Simplify a shape consisting of polygons or lines. This can be useful for shapes that are too detailed for visualization, especially along natural borders such as coastlines and rivers. The number of coordinates is reduced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_shape(shp, fact = 0.1, keep.units = FALSE, keep.subunits = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_shape_+3A_shp">shp</code></td>
<td>
<p>an <code><a href="sf.html#topic+sf">sf</a></code> or <code><a href="sf.html#topic+sfc">sfc</a></code>  object.</p>
</td></tr>
<tr><td><code id="simplify_shape_+3A_fact">fact</code></td>
<td>
<p>simplification factor, number between 0 and 1 (default is 0.1)</p>
</td></tr>
<tr><td><code id="simplify_shape_+3A_keep.units">keep.units</code></td>
<td>
<p>prevent small polygon features from disappearing at high simplification (default FALSE)</p>
</td></tr>
<tr><td><code id="simplify_shape_+3A_keep.subunits">keep.subunits</code></td>
<td>
<p>should multipart polygons be converted to singlepart polygons? This prevents small shapes from disappearing during simplification if keep.units = TRUE. Default FALSE</p>
</td></tr>
<tr><td><code id="simplify_shape_+3A_...">...</code></td>
<td>
<p>other arguments passed on to the underlying function <code><a href="rmapshaper.html#topic+ms_simplify">ms_simplify</a></code> (except for the arguments <code>input</code>, <code>keep</code>, <code>keep_shapes</code> and <code>explode</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper of <code><a href="rmapshaper.html#topic+ms_simplify">ms_simplify</a></code>. In addition, the data is preserved. Also <code><a href="sf.html#topic+sf">sf</a></code> objects are supported.
</p>


<h3>Value</h3>

<p><code><a href="sf.html#topic+sf">sf</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(tmap)) {
    data(World)

    # show different simplification factors
    tm1 &lt;- qtm(World %&gt;% simplify_shape(fact = 0.05), title="Simplify 0.05")
    tm2 &lt;- qtm(World %&gt;% simplify_shape(fact = 0.1), title="Simplify 0.1")
    tm3 &lt;- qtm(World %&gt;% simplify_shape(fact = 0.2), title="Simplify 0.2")
    tm4 &lt;- qtm(World %&gt;% simplify_shape(fact = 0.5), title="Simplify 0.5")
    tmap_arrange(tm1, tm2, tm3, tm4)

    # show different options for keeping smaller (sub)units
    tm5 &lt;- qtm(World %&gt;% simplify_shape(keep.units = TRUE, keep.subunits = TRUE),
        title="Keep units and subunits")
    tm6 &lt;- qtm(World %&gt;% simplify_shape(keep.units = TRUE, keep.subunits = FALSE),
        title="Keep units, ignore small subunits")
    tm7 &lt;- qtm(World %&gt;% simplify_shape(keep.units = FALSE),
        title="Ignore small units and subunits")
    tmap_arrange(tm5, tm6, tm7)
}

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
