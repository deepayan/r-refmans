<!DOCTYPE html><html lang="en"><head><title>Help for package control</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {control}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abcdchk'><p>State-space matrices check.</p></a></li>
<li><a href='#acker'><p>Pole placement gain selection using Ackermann's formula</p></a></li>
<li><a href='#append'><p>Append the dynamics of a set of systems</p></a></li>
<li><a href='#bode'><p>Bode Frequency Response for continuous-time Linear Systems.</p></a></li>
<li><a href='#c2d'><p>Continuous Time model conversion to Discrete Time model.</p></a></li>
<li><a href='#care'><p>Continuous-time Algebraic Riccati Equation solution</p></a></li>
<li><a href='#cloop'><p>Closed Feedback Loops</p></a></li>
<li><a href='#connect'><p>Block diagram interconnections of dynamic systems</p></a></li>
<li><a href='#ctrb'><p>Form Controllability Matrix</p></a></li>
<li><a href='#damp'><p>Damping and Natural Frequencies for Continuous Systems</p></a></li>
<li><a href='#dcgain'><p>DC Gain</p></a></li>
<li><a href='#esort'><p>Sort Complex Continuous Eigenvalues in Descending</p>
Order</a></li>
<li><a href='#feedback'><p>Feedback Connection of LTI systems</p></a></li>
<li><a href='#freqresp'><p>Low level frequency response function</p></a></li>
<li><a href='#gensig'><p>Generate periodic signal</p></a></li>
<li><a href='#givens_rot'><p>Complex Givens Rotation</p></a></li>
<li><a href='#impulse'><p>Impulse Response for Linear Systems</p></a></li>
<li><a href='#initial'><p>Initial Condition Response for Linear Systems</p></a></li>
<li><a href='#issiso'><p>SISO / MIMO Check</p></a></li>
<li><a href='#lsim'><p>Time response of a Linear system</p></a></li>
<li><a href='#lsimplot'><p>Plot time response of an LTI system</p></a></li>
<li><a href='#ltifr'><p>LTI frequency response kernel</p></a></li>
<li><a href='#ltitr'><p>Time response of a Linear Time-Invariant system</p></a></li>
<li><a href='#nyquist'><p>Nyquist Frequency Response for continuous-time Linear Systems.</p></a></li>
<li><a href='#obsv'><p>Observability Matrix</p></a></li>
<li><a href='#ordschur'><p>Ordered schur decomposition</p></a></li>
<li><a href='#parallel'><p>Parallel Connection of two systems</p></a></li>
<li><a href='#pid'><p>Proportional-Integral-Derivative (PID) Controller</p></a></li>
<li><a href='#place'><p>Pole placement gain selection</p></a></li>
<li><a href='#pole'><p>Obtain Poles for a System</p></a></li>
<li><a href='#poly2str'><p>Print Polynomial</p></a></li>
<li><a href='#polysub'><p>Subtracting Polynomials</p></a></li>
<li><a href='#ramp'><p>Ramp Response for Linear Time-Invariant Systems</p></a></li>
<li><a href='#selectsys'><p>Select/Remove Subsystem in State-space Model</p></a></li>
<li><a href='#series'><p>Series Connection of two systems</p></a></li>
<li><a href='#ss'><p>Create State-space Model.</p></a></li>
<li><a href='#ss2tf'><p>State-space model conversion to Transfer function model.</p></a></li>
<li><a href='#ss2zp'><p>State-space representation to zero-pole-gain representation</p></a></li>
<li><a href='#ssdata'><p>Retrieve State-space data</p></a></li>
<li><a href='#step'><p>Step Response for Linear Systems</p></a></li>
<li><a href='#tf'><p>Create Transfer function Model.</p></a></li>
<li><a href='#TF'><p>Evaluate Transfer function Expressions</p></a></li>
<li><a href='#tf2ss'><p>Transfer function model conversion to State-space model.</p></a></li>
<li><a href='#tf2zp'><p>Transfer function model conversion to Zero-Pole-Gain model.</p></a></li>
<li><a href='#tfchk'><p>Transfer function check.</p></a></li>
<li><a href='#tfdata'><p>Retrieve Transfer function data</p></a></li>
<li><a href='#zp2ss'><p>Convert Zero-Pole-Gain Model to State-Space Model</p></a></li>
<li><a href='#zp2tf'><p>Zero-pole-gain model conversion to Transfer function model</p></a></li>
<li><a href='#zpk'><p>Create Zero-Pole-Gain Model.</p></a></li>
<li><a href='#zpkdata'><p>Retrieve zero-pole data from LTI system object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Control Systems Toolbox</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben C. Ubah [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben C. Ubah &lt;ubah.ben22@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, expm, signal, Matrix, graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Solves control systems problems relating to time/frequency response, LTI systems design and analysis, transfer function manipulations, and system conversion.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benubah/control/issues">https://github.com/benubah/control/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-11 20:30:07 UTC; CUB-PC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-12 09:35:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='abcdchk'>State-space matrices check.</h2><span id='topic+abcdchk'></span>

<h3>Description</h3>

<p><code>abcdchk</code> verifies the dimensions of A,B,C,D matrices in its arguments, to ascertain that they are correctly defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abcdchk(a, b, c, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abcdchk_+3A_a">a</code></td>
<td>
<p>An n x n matrix</p>
</td></tr>
<tr><td><code id="abcdchk_+3A_b">b</code></td>
<td>
<p>An n x m matrix</p>
</td></tr>
<tr><td><code id="abcdchk_+3A_c">c</code></td>
<td>
<p>An p x n matrix</p>
</td></tr>
<tr><td><code id="abcdchk_+3A_d">d</code></td>
<td>
<p>An p x m matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility function that is always invoked by other functions to
ascertain the dimensions of the arguments <code>a,b,c,d</code> and returns a message
if there is an ill-defined entry.
</p>


<h3>Value</h3>

<p>Returns an empty string if matrix dimensions are consistent. Otherwise it returns the associated error message
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(0,1), c(-10000,-4))
B &lt;- rbind(0,1)
C &lt;- rbind(c(1,0), c(0,1))
D &lt;- rbind(0,0)
message &lt;-  abcdchk(A,B,C,D)

</code></pre>

<hr>
<h2 id='acker'>Pole placement gain selection using Ackermann's formula</h2><span id='topic+acker'></span>

<h3>Description</h3>

<p>Computes the Pole placement gain selection using Ackermann's formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acker(a, b, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acker_+3A_a">a</code></td>
<td>
<p>State-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="acker_+3A_b">b</code></td>
<td>
<p>Input-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="acker_+3A_p">p</code></td>
<td>
<p>closed loop poles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>K &lt;- ACKER(A,B,P)  calculates the feedback gain matrix K such that
the single input system
.
x &lt;- Ax + Bu
</p>
<p>with a feedback law of  u &lt;- -Kx  has closed loop poles at the
values specified in vector P, i.e.,  P &lt;- eigen(A - B * K).
</p>
<p>This method is NOT numerically stable and a warning message is printed if the nonzero closed loop
poles are greater than 10
in P.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- rbind(c(0,1),c(0,0))
G &lt;- rbind(0,1)
H &lt;- cbind(1,0);
J &lt;- 0
t &lt;- 1
sys  &lt;-  ss(F,G, H,J)
A  &lt;-  c2d(sys,t);
j &lt;- sqrt(as.complex(-1));
pc  &lt;- rbind(0.78+0.18*j, 0.78-0.18*j)
K  &lt;-  acker(A$A, A$B, pc)
</code></pre>

<hr>
<h2 id='append'>Append the dynamics of a set of systems</h2><span id='topic+append'></span><span id='topic+sysgroup'></span>

<h3>Description</h3>

<p><code>append</code> appends the dynamics of a set of n-state-space systems together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="append_+3A_...">...</code></td>
<td>
<p>Variable argument for LTI system models of tf, ss or zpk class</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>append(sys1, sys2, sys3,...sysN)</code> first combines the the first two systems and then
goes on to combine  the resulting state-space system to the next system and so forth.
This is achieved by calling the <code>sysgroup(sys1, sys2)</code> at each iteration to group
the systems in consecutive pairs until all systems are
completely appended to form one system.
</p>
<p><code>sysgroup(sys1, sys2)</code> appends only two systems and is used by <code>append</code>
</p>
<p>If a system is not in state-space representation, the function
tries to form a state-space representation for such system.
</p>


<h3>Value</h3>

<p>The function returns a state-space model of the formed appended system with A, B, C, D matrices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series">series</a></code> <code><a href="#topic+parallel">parallel</a></code> <code><a href="#topic+feedback">feedback</a></code> <code><a href="#topic+connect">connect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys1 &lt;- ss(1,2,3,4)
sys2 &lt;- ss(2,3,4,5)
sys3 &lt;- ss(6,7,8,9)
append(sys1, sys2, sys3)
sys4 &lt;- tf(1, c(1,2,5))
append(sys1, sys2, sys4)

</code></pre>

<hr>
<h2 id='bode'>Bode Frequency Response for continuous-time Linear Systems.</h2><span id='topic+bode'></span><span id='topic+bodeplot'></span>

<h3>Description</h3>

<p><code>bode</code> computes the magnitude and phase of the frequency response of system <code>sys</code>
at given frequencies <code>w</code>
</p>
<p>General Usage:
</p>
<p><code>bode(sys)</code>
</p>
<p><code>bode(sys, w)</code>
</p>
<p><code>bode(sys, w, iu)</code>
</p>
<p><code>bode(sys, w = seq(0, 100, length = 10000), iu = 1)</code>
</p>
<p><code>bodeplot(sys)</code>
</p>
<p><code>bodeplot(sys, w)</code>
</p>
<p><code>bodeplot(sys, w, subtitle)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bode(sys, w, iu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bode_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="bode_+3A_w">w</code></td>
<td>
<p>vector of range of frequencies at the response is computed in rad/sec</p>
</td></tr>
<tr><td><code id="bode_+3A_iu">iu</code></td>
<td>
<p>number to specify an input for a MIMO state-space system. If the system has
3 inputs, then <code>iu</code> would be set to 1, set to 2 and then to 3 to obtain the bode
response from input 1, 2, and 3 to the outputs. For single input systems, <code>iu</code> is always
set to 1. <code>iu</code> is not needed/allowed for calls to <code>bodeplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bode</code> Compute the magnitude and phase of the frequency response of system <code>sys</code>
at given frequencies <code>w</code>. When <code>sys</code> is a transfer function, <code>bode</code>
computes the frequency response of the system using the <code>signal</code> package.
</p>
<p><code>bodeplot</code> plots the frequency response computed by <code>bode</code>. For a MIMO state-space system,
<code>bodeplot</code> uses <code>selectsys</code> to obtain the bode response for each input-to-output pair and plot
them individually. This means that for a 2-input, 2-output system, <code>bodeplot</code> obtains the response
for input 1 to output 1, input 1 to output 2, input 2 to output 1 and input 2 to output 2.
<code>bodeplot</code> uses the <code>subtitle</code> argument to allow a user assign the plot a sub-title
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>bode</code> containing:
<code>w</code> - frequencies
</p>
<p><code>mag</code> - magnitude of the response
</p>
<p><code>phase</code> - phase of the response
</p>
<p>A plot is returned by calling <code>bodeplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nyquist">nyquist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bode(tf(100, c(1,6,100)))
bode(ssdata(tf(100, c(1,6,100))))

bode(tf(4, c(1,1)))
A &lt;- rbind(c(-2, -1), c(1,0)); B &lt;- rbind(1,0);
C &lt;- cbind(0,1); D &lt;- as.matrix(0);
bode(ss(A,B,C,D))

## MIMO plot
A1 &lt;- rbind(c(0,1), c(-25,-4)); B1 &lt;- rbind(c(1,1), c(0,1))
C1 &lt;- rbind(c(1,0), c(0,1)); D1 &lt;- rbind(c(0,0), c(0,0))
sys1 &lt;- ss(A1,B1,C1,D1)
bodeplot(sys1)
# Use:  par(mfrow = c(2,1)); bodeplot(selectsys(sys1,1,2)) to obtain the response for a subsystem
# of sys1 for input 1 and output 2 only
# RESET your plot layout using par(mfrow = c(1,1))

</code></pre>

<hr>
<h2 id='c2d'>Continuous Time model conversion to Discrete Time model.</h2><span id='topic+c2d'></span>

<h3>Description</h3>

<p><code>c2d</code> converts a system in continuous-time model to a discrete time model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2d(sys, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c2d_+3A_sys">sys</code></td>
<td>
<p>An object of transfer function, state-space or zero-pole class</p>
</td></tr>
<tr><td><code id="c2d_+3A_t">t</code></td>
<td>
<p>Sample time; a numeric value greater than 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>c2d</code> converts the continuous-time system: x = Ax + Bu
to the discrete-time state-space system: x[n+1] = Phi * x[n] + Gamma * u[n] based on the method
of assuming a zero-order hold on the inputs and sample time
Transfer function and zero-pole systems are converted to state-space representation before
conversion to discrete-time.
</p>


<h3>Value</h3>

<p>Returns the provided system (transfer function, state-space or zero-pole) in an equivalent discrete-time.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltitr">ltitr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## for TF
c2d(tf(c(1,-1), c(1,4,5)), 0.1)
## for ZPK
sys &lt;- zpkdata( tf(c(1,-1), c(1,4,5)) )
c2d(sys, 0.1)
c2d(zpkdata( tf(c(1,-1), c(1,4,5)) ), 0.1)

</code></pre>

<hr>
<h2 id='care'>Continuous-time Algebraic Riccati Equation solution</h2><span id='topic+care'></span>

<h3>Description</h3>

<p>Computes the unique solution to the continuous-time Riccati equation:
</p>
<p>A'* X + X*A - X * B * R^-1 * B' * X + Q'*Q = 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>care(A, B, Q, R = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="care_+3A_a">A</code></td>
<td>
<p>State-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="care_+3A_b">B</code></td>
<td>
<p>Input-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="care_+3A_q">Q</code></td>
<td>
<p>Symmetric output-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="care_+3A_r">R</code></td>
<td>
<p>Single number</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X &lt;- care(A, B, Q, R)</code> returns the stablizing solution (if it
exists) to the continuous-time Riccati equation.
</p>
<p>The <code>care</code> function also returns the gain matrix, <code>G</code>
and a vector, <code>L</code> of the closed-loop eigenvalues, where
</p>
<p>G = R^-1 B'X*E
</p>
<p><code>L = eig(a-b*g)</code>
</p>


<h3>Value</h3>

<p>Returns the stabilizing matrix, gain and closed-loop eigenvalues in a list.
</p>


<h3>Note</h3>

<p>A, B must be controllable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(-3, 2,1, 1), byrow = TRUE, ncol = 2)
b &lt;- matrix(c(0, 1), nrow = 2)
c &lt;- matrix(c(1, -1), ncol = 2)
q &lt;- t(c)%*%c
r &lt;- 3
care(a, b, q, r)
</code></pre>

<hr>
<h2 id='cloop'>Closed Feedback Loops</h2><span id='topic+cloop'></span>

<h3>Description</h3>

<p><code>cloop</code> forms a closed feedback loop for a state-space or transfer function system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloop(sys, e, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cloop_+3A_sys">sys</code></td>
<td>
<p>LTI system model of transfer-function or state-space model</p>
</td></tr>
<tr><td><code id="cloop_+3A_e">e</code></td>
<td>
<p>inputs vector</p>
</td></tr>
<tr><td><code id="cloop_+3A_f">f</code></td>
<td>
<p>outputs vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other possible usages of <code>cloop</code>:
</p>
<p><code>cloop(sys)</code>
</p>
<p><code>cloop(sys, sgn)</code>
</p>
<p>If <code>sys</code> is a state-space model,  <code>cloop(sys, SGN)</code> produces a state-space model
of the closed-loop system obtained by feeding all the outputs of
the system to all the inputs.  Positive feedback is used when SGN &lt;- 1 and negative
when SGN &lt;- -1
</p>
<p>If <code>sys</code> is a transfer function model, <code>cloop(sys, SGN)</code>
produces the SISO closed loop
system in transfer function form obtained by unity feedback with
the sign SGN.
</p>
<p>cloop(sys,OUTPUTS,INPUTS) forms the closed
loop system obtained by feeding the specific outputs into
specific outputs.  The vectors <code>OUTPUTS</code> and <code>INPUTS</code> contain indices
into the outputs and inputs of the system respectively.  Positive
feedback is assumed. To form closed loop with negative feedback, negative	values are used in the vector <code>INPUTS</code>.
</p>


<h3>Value</h3>

<p>Returns a closed feedback loop system
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feedback">feedback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 2.0; b &lt;- 0.04; K &lt;- 1.0; R &lt;- 0.08; L &lt;- 1e-4
P &lt;- TF("K/(s*((J*s + b)*(L*s + R) + K^2))")
cloop(P)
cloop(ss(1,2,3,4))
</code></pre>

<hr>
<h2 id='connect'>Block diagram interconnections of dynamic systems</h2><span id='topic+connect'></span>

<h3>Description</h3>

<p><code>connect</code> is used to form a state-space model of a system from its block diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect(sysapp, q, inputs, outputs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connect_+3A_sysapp">sysapp</code></td>
<td>
<p>A state-space system containing several appended systems returned from the <code><a href="#topic+append">append</a></code> function.
All appended systems must be in state-space model.</p>
</td></tr>
<tr><td><code id="connect_+3A_q">q</code></td>
<td>
<p>Matrix that specifies the interconnections of the block diagram. Each row specifies a connection.
The first element of each row is the number of the block. The other following elements of each row specify where the  block gets its summing inputs, with negative elements used to
indicate minus inputs to the summing junction.
For example: cbind(2,1,3) means that block 2 has an input from block 1 and block 3</p>
</td></tr>
<tr><td><code id="connect_+3A_inputs">inputs</code></td>
<td>
<p>A column matrix specifying the inputs of the resulting aggregate system</p>
</td></tr>
<tr><td><code id="connect_+3A_outputs">outputs</code></td>
<td>
<p>A column matrix specifying the outputs of the resulting aggregate system</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>connect</code>
This function requires calling the <code><a href="#topic+append">append</a></code> function to group a set of unconnected dynamics system
in one system object. It then uses the <code>q</code> matrix to determine the interconnections between the systems
and finally specifies the inputs and outputs for the new aggregate system.
This approach helps to realize a block diagram as a single system on which further analysis could be performed.
See examples below.
</p>


<h3>Value</h3>

<p>Returns the interconnected system, returned as either a state-space model
</p>


<h3>See Also</h3>

<p><code><a href="#topic+append">append</a></code> <code><a href="#topic+series">series</a></code> <code><a href="#topic+parallel">parallel</a></code> <code><a href="#topic+feedback">feedback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- rbind(c(0, 0), c(1,-3))
b1 &lt;- rbind(-2,0)
c1 &lt;- cbind(0,-1)
d &lt;- as.matrix(0)
a2 &lt;- as.matrix(-5)
b2 &lt;- as.matrix(5)
c2 &lt;- as.matrix(1)
d2 &lt;- as.matrix(0)
sysa1 &lt;- ss(a1, b1, c1, d)
sysa2 &lt;- ss(a2, b2, c2, d2)
al &lt;- append(sysa1, sysa2)
connect(al, cbind(2,1,0), cbind(1,2), cbind(1,2))
## OR
connect(append(sysa1, sysa2), cbind(2,1,0), cbind(1), cbind(2))
 ## Not run: 
cbind(2,1,0) means that block 2 has an input from block 1 and block 0 (which doesnt exist)
cbind(1) means that block 1 is the input of the system, and cbind(2) means block 2 is the
output of the system.
if we replace cbind(2) with cbind(1,2), this means that the system has two outputs from
block 1 and 2
i.e. \code{connect(append(sysa1, sysa2), cbind(2,1,0), cbind(1), cbind(1,2))}

## End(Not run)
</code></pre>

<hr>
<h2 id='ctrb'>Form Controllability Matrix</h2><span id='topic+ctrb'></span>

<h3>Description</h3>

<p><code>ctrb</code> forms the controllability matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctrb(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctrb_+3A_a">A</code></td>
<td>
<p>State matrix, A</p>
</td></tr>
<tr><td><code id="ctrb_+3A_b">B</code></td>
<td>
<p>State matrix, B</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ctrb</code>  <code>ctrb(a, b)</code> returns the controllability matrix,  [B AB A^2B ... A^(n-1)B]. If the Controllability
matrix has full row rank, the system is controllable.
</p>


<h3>Value</h3>

<p>Returns the controllability matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+obsv">obsv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- rbind(c(0,0),c(1,-3))
b1 &lt;- rbind(-2,0)
ctrb(a1, b1)

</code></pre>

<hr>
<h2 id='damp'>Damping and Natural Frequencies for Continuous Systems</h2><span id='topic+damp'></span>

<h3>Description</h3>

<p><code>damp</code> computes the natural frequency and damping for
continuous systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>damp(sys, doPrint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="damp_+3A_sys">sys</code></td>
<td>
<p>A Continuous-time system of state-space, transfer-function or zero-pole-gain model.</p>
</td></tr>
<tr><td><code id="damp_+3A_doprint">doPrint</code></td>
<td>
<p>If TRUE prints out the results. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A table of the eigenvalues of
the matrix a, the associated damping factors, the associated natural
frequency (rad/s and Hz.) is displayed by calling the function.
</p>
<p>When the continuous system is a state-space model, the eigenvalues of the state matrix
are obtained and sorted.
If the system is a transfer-function, the poles of the systems are obtained and sorted.
For zero-pole systems, the poles are just extracted and sorted.
The sorted eigenvalues are printed to output and used to obtain the natural frequencies
and damping factors.
</p>


<h3>Value</h3>

<p>Returns the natrural frequencies and damping
factors in a list:
</p>
<p>omegan = Natural Frequencies (rad/s)
zeta   = Damping Factors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+esort">esort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys1 &lt;- tf(1, c(1,2,5))
damp(sys1)

</code></pre>

<hr>
<h2 id='dcgain'>DC Gain</h2><span id='topic+dcgain'></span>

<h3>Description</h3>

<p><code>dcgain</code> Forms the Givens rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcgain(sys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcgain_+3A_sys">sys</code></td>
<td>
<p>A transfer function or state-space model</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dcgain(sys)</code>  Computes the steady-state gain (or low frequency gain) of a continuous
system.
</p>


<h3>Value</h3>

<p>Returns the gain.
</p>

<hr>
<h2 id='esort'>Sort Complex Continuous Eigenvalues in Descending
Order</h2><span id='topic+esort'></span>

<h3>Description</h3>

<p><code>esort</code> sorts the complex continuous eigenvalues in descending
order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esort(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="esort_+3A_p">p</code></td>
<td>
<p>A vector containing the poles of a transfer-function, zero-pole model or the eigenvalues of a state-matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>esort</code> sorts the complex eigenvalues based on their real part. The unstable eigenvalues (positive
real part) are first shown.
</p>
<p>This function is used to sort eigenvalues and system poles in <code><a href="#topic+damp">damp</a></code>
</p>


<h3>Value</h3>

<p>Returns the sorted eigenvalues and the cooresponding
indices in a list:
</p>
<p>s   = sorted eigenvalues
idx = index
</p>


<h3>See Also</h3>

<p><code><a href="#topic+damp">damp</a></code>
</p>

<hr>
<h2 id='feedback'>Feedback Connection of LTI systems</h2><span id='topic+feedback'></span><span id='topic+fdbcksys'></span>

<h3>Description</h3>

<p><code>feedback</code> forms a feedback connection for two LTI state-space or transfer function systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feedback(sys1, sys2, in1, out1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feedback_+3A_sys1">sys1</code></td>
<td>
<p>LTI system model of transfer-function or state-space model</p>
</td></tr>
<tr><td><code id="feedback_+3A_sys2">sys2</code></td>
<td>
<p>LTI system model of transfer-function or state-space model</p>
</td></tr>
<tr><td><code id="feedback_+3A_in1">in1</code></td>
<td>
<p>vector of inputs</p>
</td></tr>
<tr><td><code id="feedback_+3A_out1">out1</code></td>
<td>
<p>vector of outputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>sys1</code> and <code>sys2</code> are transfer functions <code>feedback(sys1, sys2, SIGN)</code> produces the SISO
closed loop system in transfer function form obtained by
connecting the two SISO transfer function systems in feedback
with the sign SIGN.
</p>
<p><code>feedback(sys1, sys2, SIGN)</code> produces an
aggregate state-space system consisting of the feedback connection
of the two systems 1 and 2.    If <code>SIGN = 1</code> then positive feedback is
used. If <code>SIGN = -1</code> then negative feedback is used.  In all cases,
the resulting system has the same inputs and outputs as system 1.
</p>
<p><code>feedback(sys1, sys2, inputs, outputs)</code>
produces the feedback system formed by feeding all the outputs of
system2 into the inputs of system 1 specified by INPUTS1 and by
feeding the outputs of system 2 specified by OUTPUTS1 into all the
inputs of system 2.  Positive feedback is assumed.  To connect
with negative feedback, use negative values in the vector INPUTS1.
</p>
<p><code>feedback()</code> calls <code>fdbcksys()</code> to perform the feedback connection for two systems.
Unity feedback calls are possile, for example, <code>feedback(sys1, 1)</code>, <code>feedback(1, sys1)</code>
</p>


<h3>Value</h3>

<p>Returns the feedback system in <code>tf</code> or <code>ss</code> model
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cloop">cloop</a></code> <code><a href="#topic+parallel">parallel</a></code> <code><a href="#topic+series">series</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- pid(350,300,50)
P &lt;- TF(" 1/(s^2 + 10* s + 20)")
feedback(C,P)
feedback(P,P,1)
feedback(P,P,-1)
feedback(P,P)
feedback(P,1)
feedback(TF("C*P"))
## Not run:  On Octave: feedback(C*P)

</code></pre>

<hr>
<h2 id='freqresp'>Low level frequency response function</h2><span id='topic+freqresp'></span>

<h3>Description</h3>

<p>This function obtains the low level frequency response of a system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqresp(sys, w = seq(0, 100, length = 10000), iu = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freqresp_+3A_sys">sys</code></td>
<td>
<p>An LTI system of <code>tf</code>, <code>ss</code> and <code>zpk</code> class</p>
</td></tr>
<tr><td><code id="freqresp_+3A_w">w</code></td>
<td>
<p>a vector of frequency points</p>
</td></tr>
<tr><td><code id="freqresp_+3A_iu">iu</code></td>
<td>
<p>For calls to <code>freqresp</code>, <code>iu</code> is a number specifying an input for a MIMO state-space system. If the system has
3 inputs, then <code>iu</code> would be set to 1, set to 2 and then to 3 to obtain the step
response from input 1, 2, and 3 to the outputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>freqresp(sys, w)</code> returns a vector of frequencies for <code>sys</code> in complex form
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bode">bode</a></code> <code><a href="#topic+nyquist">nyquist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H &lt;- freqresp(ssdata(tf(c(1,1), c(1,2,1))), (seq(0, 100, length = 10000)))
H &lt;- freqresp(tf(c(1,1), c(1,2,1)), seq(0, 100, length = 10000))

</code></pre>

<hr>
<h2 id='gensig'>Generate periodic signal</h2><span id='topic+gensig'></span>

<h3>Description</h3>

<p><code>gensig</code> generates a periodic signal. More useful when used in combination with <code>lsim</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gensig(signal, tau, tfinal, tsam)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gensig_+3A_signal">signal</code></td>
<td>
<p>A string input containing either values of: <code>square, sin, cos, pulse</code> in the following format:
</p>
<p>'sq' or 'square' - Square wave
</p>
<p>'si' or 'sine'  -  Sine wave
</p>
<p>'co' or 'cos' -  Cosine wave
</p>
<p>'pu' or 'pulse' -  Periodic pulse</p>
</td></tr>
<tr><td><code id="gensig_+3A_tau">tau</code></td>
<td>
<p>Duration of one period in seconds. Default is 5</p>
</td></tr>
<tr><td><code id="gensig_+3A_tfinal">tfinal</code></td>
<td>
<p>Duration of the signal in seconds. Default is 30</p>
</td></tr>
<tr><td><code id="gensig_+3A_tsam">tsam</code></td>
<td>
<p>sampling time in seconds. Default is 0.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gensig</code> generates a periodic signal of the following types: <code>square, sin, cos, pulse</code>
</p>
<p>Possible usage: <code>gensig(signal)</code>
</p>


<h3>Value</h3>

<p>Returns a list of two single column matrices, <code>u</code> and <code>t</code>
</p>
<p><code>u</code> is the vector of signal values
</p>
<p><code>t</code> is the time vector of the signal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsim">lsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  A square wave signal 
sig &lt;-  gensig('square', 4, 10, 0.1)
plot(sig$t, sig$u, type = "l", col = "blue")
grid(5,5, col = "lightgray")

## Not run:  A sine wave signal 

sig &lt;-  gensig('sin')
plot(sig$t, sig$u, type = "l", col = "blue")
grid(5,5, col = "lightgray")

</code></pre>

<hr>
<h2 id='givens_rot'>Complex Givens Rotation</h2><span id='topic+givens_rot'></span>

<h3>Description</h3>

<p><code>givens_rot</code> Forms the Givens rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>givens_rot(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="givens_rot_+3A_a">a</code></td>
<td>
<p>Complex Square-matrix</p>
</td></tr>
<tr><td><code id="givens_rot_+3A_b">b</code></td>
<td>
<p>complex Input-matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>givens_rot(a, b)</code> returns the complex Givens rotation matrix
This function is called by <code><a href="#topic+ordschur">ordschur</a></code>
</p>


<h3>Value</h3>

<p>Returns the complex Givens rotation matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordschur">ordschur</a></code>
</p>

<hr>
<h2 id='impulse'>Impulse Response for Linear Systems</h2><span id='topic+impulse'></span><span id='topic+impulseplot'></span>

<h3>Description</h3>

<p><code>impulse</code> obtains the impulse response of the linear system:
</p>
<p style="text-align: center;"><code class="reqn">dx/dt =  Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn">y = Cx + Du</code>
</p>

<p>to an impulse applied to the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulse(sys, t, input)
impulseplot(sys, t, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impulse_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="impulse_+3A_t">t</code></td>
<td>
<p>Time vector. If not provided, it is automatically set.</p>
</td></tr>
<tr><td><code id="impulse_+3A_input">input</code></td>
<td>
<p>For calls to <code>impulse</code>, <code>input</code> is a number specifying an input for a MIMO state-space system. If the system has
3 inputs, then <code>input</code> would be set to 1, set to 2 and then to 3 to obtain the impulse
response from input 1, 2, and 3 to the outputs. For single input systems, <code>input</code> is always
set to 1.
</p>
<p>For calls to <code>impulseplot</code>, <code>input</code> is a vector or range for a MIMO state-space system. For example, <code>input &lt;- 1:3</code> for a system with 3-inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>impulse</code> produces the impulse response of linear systems using <code>lsim</code>
</p>
<p><code>impulseplot</code> produces the impulse response as a plot against time.
</p>
<p>These functions can handle both SISO and MIMO (state-space) models.
</p>
<p>Other possible calls using <code>impulse</code> and <code>impulseplot</code> are:
</p>
<p><code>impulse(sys)</code>
</p>
<p><code>impulse(sys, t)</code>
</p>
<p><code>impulseplot(sys)</code>
</p>
<p><code>impulseplot(sys, t)</code>
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>impulse</code> containing:
</p>
<p><code>t</code> Time vector
</p>
<p><code>x</code> Individual response of each x variable
</p>
<p><code>y</code> Response of the system
</p>
<p>The matrix <code>y</code> has as many rows as there are outputs, and columns of the same size of <code>length(t)</code>.
The matrix <code>x</code> has as many rows as there are states.  If the time
vector is not specified, then the automatically set time
vector is returned as <code>t</code>
</p>
<p>A plot of <code>y</code> vs <code>t</code> is returned by calling <code>impulseplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initial">initial</a></code> <code><a href="#topic+step">step</a></code> <code><a href="#topic+ramp">ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- impulse(tf(1, c(1,2,1)))
res$y
res$t
impulse(tf(1, c(1,2,1)), seq(0, 10, 0.1))
impulseplot(tf(1, c(1,2,1)))
impulseplot(tf(1, c(1,2,1)), seq(0, 10, 0.1))

## Not run:  State-space MIMO systems 
A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1));
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
res1 &lt;- impulse(ss(A,B,C,D), input = 1)
res2 &lt;- impulse(ss(A,B,C,D), input = 2)
res1$y # has two rows, i.e. for two outputs
res2$y # has two rows, i.e. for two outputs
impulseplot(ss(A,B,C,D), input = 1:2) # OR
impulseplot(ss(A,B,C,D), input = 1:ncol(D))
impulseplot(ss(A,B,C,D), seq(0,3,0.01), 1:2)

</code></pre>

<hr>
<h2 id='initial'>Initial Condition Response for Linear Systems</h2><span id='topic+initial'></span><span id='topic+initialplot'></span>

<h3>Description</h3>

<p><code>initial</code> obtains the time response of the linear system:
</p>
<p style="text-align: center;"><code class="reqn">dx/dt =  Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn">y = Cx + Du</code>
</p>

<p>to an initial condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial(sys, x0, t)
initialplot(sys, x0, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="initial_+3A_x0">x0</code></td>
<td>
<p>initial conditions as a column vector. Should have as many rows as the rows of A.
where x0 is not specified, random values are assigned</p>
</td></tr>
<tr><td><code id="initial_+3A_t">t</code></td>
<td>
<p>regularly spaced time vector. If not provided, it is automatically set.
</p>
<p>For calls to <code>initialplot</code>, the same arguments are allowed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>initial</code> produces the time response of linear systems to initial conditions using <code>lsim</code>
</p>
<p><code>initialplot</code> produces the time response to initial conditions as a plot againts time.
</p>
<p>The functions can handle both SISO and MIMO (state-space) models.
</p>
<p>Other possible calls using <code>initial</code> and <code>initialplot</code> are:
</p>
<p><code>initial(sys)</code>
</p>
<p><code>initial(sys, x0)</code>
</p>
<p><code>initialplot(sys)</code>
</p>
<p><code>initialplot(sys, x0)</code>
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>initial</code> containing:
</p>
<p><code>x</code> Individual response of each x variable
</p>
<p><code>y</code> Response of the system
</p>
<p><code>t</code> Time vector
</p>
<p>The matrix <code>y</code> has as many rows as there are outputs, and columns of the same size of <code>length(t)</code>.
The matrix X has as many rows as there are states.  If the time
vector is not specified, then the automatically set time
vector is returned as <code>t</code>
</p>
<p>A plot of <code>y</code> vs <code>t</code> is returned by calling <code>initialplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step">step</a></code> <code><a href="#topic+impulse">impulse</a></code> <code><a href="#topic+ramp">ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- initial(tf(1, c(1,2,1)))
res$y
res$t
A &lt;- rbind(c(-2, -1), c(1,0)); B &lt;- rbind(1,0);
C &lt;- cbind(0,1); D &lt;- as.matrix(0);
x0 &lt;- matrix(c( 0.51297, 0.98127))
initialplot(ss(A,B,C,D), x0)
initialplot(tf(1, c(1,2,1)), t = seq(0, 10, 0.1))

## Not run:  State-space MIMO systems 
A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1));
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
res &lt;- initial(ss(A,B,C,D))
res$y # has two rows, i.e. for two outputs
initialplot(ss(A,B,C,D))

</code></pre>

<hr>
<h2 id='issiso'>SISO / MIMO Check</h2><span id='topic+issiso'></span><span id='topic+ismimo'></span>

<h3>Description</h3>

<p><code>issiso</code> checks if state-space system is a single-input single-output system
<code>ismimo</code> checks if state-space system is a multiple-input multiple-output system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issiso(sys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="issiso_+3A_sys">sys</code></td>
<td>
<p>Dynamic system of state-space model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE or FALSE
</p>

<hr>
<h2 id='lsim'>Time response of a Linear system</h2><span id='topic+lsim'></span>

<h3>Description</h3>

<p><code>lsim</code> Computes the time response of a Linear system described by:
</p>
<p style="text-align: center;"><code class="reqn">x = Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn"> y = Cx + Du</code>
</p>

<p>to the input time history <code>u</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsim(sys, u, t, x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsim_+3A_sys">sys</code></td>
<td>
<p>An LTI system of <code>tf</code>, <code>ss</code> and <code>zpk</code> class</p>
</td></tr>
<tr><td><code id="lsim_+3A_u">u</code></td>
<td>
<p>A row vector for single input systems. The input <code>u</code> must have as many rows as there are inputs
in the system. Each column of U corresponds to a new time point. <code>u</code> could be generated using a signal generator
like <code>gensig</code></p>
</td></tr>
<tr><td><code id="lsim_+3A_t">t</code></td>
<td>
<p>time vector which must be regularly spaced. e.g. <code>seq(0,4,0.1)</code></p>
</td></tr>
<tr><td><code id="lsim_+3A_x0">x0</code></td>
<td>
<p>a vector of initial conditions with as many rows as the rows of <code>a</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lsim(sys, u, t)</code> provides the time history of the linear system with zero-initial conditions.
</p>
<p><code>lsim(sys, u, t, x0)</code> provides the time history of the linear system with initial conditions.
If the linear system is represented as a model of <code>tf</code> or <code>zpk</code>
it is first converted to state-space before linear simulation is performed. This function depends on <code>c2d</code> and <code>ltitr</code>
</p>


<h3>Value</h3>

<p>Returns a list of two matrices, <code>x</code> and <code>y</code>. The <code>x</code> values are returned from <code>ltitr</code>
call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltitr">ltitr</a></code>   <code><a href="#topic+lsimplot">lsimplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signal &lt;- gensig('square',4,10,0.1)
H &lt;- tf(c(2, 5, 1),c(1, 2, 3))
response &lt;- lsim(H, signal$u, signal$t)
plot(signal$t, response$y, type = "l", main = "Linear Simulation Response", col = "blue")
lines(signal$t, signal$u, type = "l", col = "grey")
grid(5,5, col = "lightgray")
## Not run:  based on example at: https://www.mathworks.com/help/ident/ref/lsim.html 

## Not run:  MIMO system response 
A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1))
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
response &lt;- lsim(ss(A,B,C,D), cbind(signal$u, signal$u), signal$t)
plot(signal$t, response$y[1,], type = "l",
 main = "Linear Simulation Response", col = "blue"); grid(7,7)
plot(signal$t, response$y[2,], type = "l",
main = "Linear Simulation Response", col = "blue"); grid(7,7)

</code></pre>

<hr>
<h2 id='lsimplot'>Plot time response of an LTI system</h2><span id='topic+lsimplot'></span>

<h3>Description</h3>

<p><code>lsimplot</code> Plots the time response of a Linear system described by:
</p>
<p style="text-align: center;"><code class="reqn">x = Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn"> y = Cx + Du</code>
</p>

<p>to the input time history <code>u</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsimplot(sys, u, t, x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsimplot_+3A_sys">sys</code></td>
<td>
<p>An LTI system of <code>tf</code>, <code>ss</code> and <code>zpk</code> class</p>
</td></tr>
<tr><td><code id="lsimplot_+3A_u">u</code></td>
<td>
<p>A row vector for single input systems. The input <code>u</code> must have as many rows as there are inputs
in the system. Each column of <code>u</code> corresponds to a new time point. <code>u</code> could be generated using a signal generator
such as <code>gensig</code></p>
</td></tr>
<tr><td><code id="lsimplot_+3A_t">t</code></td>
<td>
<p>time vector which must be regularly spaced. e.g. <code>seq(0,4,0.1)</code></p>
</td></tr>
<tr><td><code id="lsimplot_+3A_x0">x0</code></td>
<td>
<p>a vector of initial conditions with as many rows as the rows of <code>sys$A</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lsimplot(sys, u, t)</code> plots the time history of the linear system with zero-initial conditions.
</p>
<p><code>lsimplot(sys, u, t, x0)</code> plots the time history of the linear system with given initial conditions.
</p>
<p>If the linear system is represented as a model of <code>tf</code> or <code>zpk</code>
it is first converted to state-space before linear simulation is performed. This function depends on <code>c2d</code> and <code>ltitr</code>
</p>


<h3>Value</h3>

<p>Returns a plot for the response of the system
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsim">lsim</a></code> <code><a href="#topic+stepplot">stepplot</a></code>   <code><a href="#topic+rampplot">rampplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>signal &lt;- gensig('square',4,10,0.1)
H &lt;- tf(c(2, 5, 1),c(1, 2, 3))
lsimplot(H, signal$u, signal$t)

## Not run:  MIMO system response 
A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1))
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
lsimplot(ss(A,B,C,D), cbind(signal$u, signal$u), signal$t)

</code></pre>

<hr>
<h2 id='ltifr'>LTI frequency response kernel</h2><span id='topic+ltifr'></span>

<h3>Description</h3>

<p>This function computes the frequency
response of the following system:
</p>
<p>g(w) = (wI-A) \ B
</p>
<p>for the complex frequencies contained in the vector W. The column
vector B must have as many rows as the matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltifr(A, B, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ltifr_+3A_a">A</code></td>
<td>
<p>State-space matrix, A</p>
</td></tr>
<tr><td><code id="ltifr_+3A_b">B</code></td>
<td>
<p>State-space input-matrix, B. B must have as many rows as the matrix A.</p>
</td></tr>
<tr><td><code id="ltifr_+3A_w">w</code></td>
<td>
<p>Vector of complex frequencies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the frequency response in vector. <code><a href="#topic+freqresp">freqresp</a></code> utilizes this function for state-space systems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqresp">freqresp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use \code{\link{freqresp}}

</code></pre>

<hr>
<h2 id='ltitr'>Time response of a Linear Time-Invariant system</h2><span id='topic+ltitr'></span>

<h3>Description</h3>

<p><code>ltitr</code> Computes the time response of a Linear Time-Invariant system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltitr(a, b, u, x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ltitr_+3A_a">a</code></td>
<td>
<p>An n x n matrix of the state-space system</p>
</td></tr>
<tr><td><code id="ltitr_+3A_b">b</code></td>
<td>
<p>An n x m matrix of the state-space system</p>
</td></tr>
<tr><td><code id="ltitr_+3A_u">u</code></td>
<td>
<p>A row vector for single input systems. The input U must have as many rows as there are inputs
in the system. Each column of U corresponds to a new time point. <code>u</code> could be generated using a signal generator
like <code>gensig</code></p>
</td></tr>
<tr><td><code id="ltitr_+3A_x0">x0</code></td>
<td>
<p>a vector of initial conditions with as many rows as the rows of <code>a</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ltitr</code> computes the time response of a Linear Time-Invariant system in state-space representation of the form:
x[n+1] = Ax[n] + Bu[n] to an input, <code>U</code>
</p>
<p><code>ltitr(a, b, u)</code> computes the time response with zero-initial conditions since x0 is not supplied.
</p>


<h3>Value</h3>

<p>Returns a matrix X which has as
many rows as there are outputs y (and with <code>max(dim(U))</code> columns).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsim">lsim</a></code> <code><a href="#topic+gensig">gensig</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- diag(1, 2)
B &lt;- rbind(1, 1)
x0 &lt;- rbind(-1, -2)
u &lt;- cbind(1, 2, 3, 4, 5)
X &lt;- ltitr(A, B, u)
X &lt;- ltitr(A, B, u, x0)

A &lt;- replicate(6, abs(rnorm(6)))
B &lt;- replicate(3, abs(rnorm(6)))
U &lt;- replicate(100, rnorm(3))
x0 &lt;-  rnorm(6)
X &lt;- ltitr(A, B, U)
X &lt;- ltitr(A, B, U, x0)

</code></pre>

<hr>
<h2 id='nyquist'>Nyquist Frequency Response for continuous-time Linear Systems.</h2><span id='topic+nyquist'></span><span id='topic+nyquistplot'></span>

<h3>Description</h3>

<p><code>nyquist</code> computes the real and imaginary parts of the frequency response of system <code>sys</code>
at given frequencies <code>w</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyquist(sys, w, iu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nyquist_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="nyquist_+3A_w">w</code></td>
<td>
<p>vector of range of frequencies at the response is computed in rad/sec</p>
</td></tr>
<tr><td><code id="nyquist_+3A_iu">iu</code></td>
<td>
<p>number to specify an input for a MIMO state-space system. If the system has
3 inputs, then <code>iu</code> would be set to 1, set to 2 and then to 3 to obtain the nyquist
response from input 1, 2, and 3 to the outputs. For single input systems, <code>iu</code> is always
set to 1. <code>iu</code> is not needed/allowed for calls to <code>nyquistplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nyquist</code> Compute the real and imaginary parts of the frequency response of system <code>sys</code>
at given frequencies <code>w</code>. When <code>sys</code> is a transfer function, <code>nyquist</code>
computes the frequency response of the system using the <code>signal</code> package.
</p>
<p><code>nyquistplot</code> plots the frequency response computed by <code>nyquist</code>. For a MIMO state-space system,
<code>nyquistplot</code> uses <code>selectsys</code> to obtain the nyquist response for each input-to-output pair and plot
them individually. This means that for a 2-input, 2-output system, <code>nyquistplot</code> obtains the response
for input 1 to output 1, input 1 to output 2, input 2 to output 1 and input 2 to output 2.
<code>nyquistplot</code> uses the <code>subtitle</code> argument to allow a user assign the plot a sub-title
</p>
<p>Other possible calls using <code>nyquist</code> and <code>nyquistplot</code> are:
</p>
<p><code>nyquist(sys)</code>
<code>nyquist(sys, w)</code>
<code>nyquist(sys, w = seq(0, 100, length = 10000), iu = 1)</code>
<code>nyquistplot(sys)</code>
<code>nyquistplot(sys, w)</code>
<code>nyquistplot(sys, w, subtitle)</code>
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>nyquist</code> containing:
<code>h.real</code> - real part of the frequency response
</p>
<p><code>h.imag</code> - imaginary part of the frequency response
</p>
<p>A plot is returned by calling <code>nyquistplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bode">bode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nyquist(tf(100, c(1,6,100)))
nyquist(ssdata(tf(100, c(1,6,100))))

## Not run:  MIMO plot 
A1 &lt;- rbind(c(0,1), c(-25,-4)); B1 &lt;- rbind(c(1,1), c(0,1))
C1 &lt;- rbind(c(1,0), c(0,1)); D1 &lt;- rbind(c(0,0), c(0,0))
sys1 &lt;- ss(A1,B1,C1,D1)
nyquistplot(sys1)
## Not run:  Use nyquistplot(selectsys(sys1,1,2)) to obtain the response for a subsystem
 of sys1 for input 1 and output 2 only.

 RESET your plot layout using par(mfrow = c(1,1)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='obsv'>Observability Matrix</h2><span id='topic+obsv'></span>

<h3>Description</h3>

<p>This function creates the observability matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsv(A, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obsv_+3A_a">A</code></td>
<td>
<p>State-space matrix, A</p>
</td></tr>
<tr><td><code id="obsv_+3A_c">C</code></td>
<td>
<p>State-space matrix, C</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>obsv(A, C)</code> returns the observability matrix, <code>obsvm</code>.
where
obsvm =  | C CA CA^2 ... CA^(n-1) |
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctrb">ctrb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(0,1), c(-25,-4))
C &lt;- rbind(c(1,0), c(0,1))
 obsv(A, C)

</code></pre>

<hr>
<h2 id='ordschur'>Ordered schur decomposition</h2><span id='topic+ordschur'></span>

<h3>Description</h3>

<p><code>ordschur</code> Orders a schur decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordschur(Ui, Si, idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordschur_+3A_ui">Ui</code></td>
<td>
<p>Square upper-triangular matrix matrix from schur decomposition. If Ui is not given it is set to the identity matrix.</p>
</td></tr>
<tr><td><code id="ordschur_+3A_si">Si</code></td>
<td>
<p>Orthogonal matrix from schur decomposition</p>
</td></tr>
<tr><td><code id="ordschur_+3A_idx">idx</code></td>
<td>
<p>array index</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ordschur</code> finds an orthogonal matrix, <code>U</code> so that the eigenvalues
appearing on the diagonal of <code>Si</code> are ordered according to the
increasing values of the array index where the i-th element
of index corresponds to the eigenvalue appearing as the
element  <code>Si[i,i]</code>.
</p>
<p><code>ordschur</code> could also be used in this syntax:  <code>ordschur(Si, idx)</code>
</p>


<h3>Value</h3>

<p>Returns a list of ordered (U, S)
</p>

<hr>
<h2 id='parallel'>Parallel Connection of two systems</h2><span id='topic+parallel'></span>

<h3>Description</h3>

<p><code>parallel</code> connects two systems in the parallel block form below
</p>
<p>|&ndash;&gt;[System1]&ndash;|
u&ndash;&gt;+              0&mdash;&gt;y
|&lt;&ndash;[System2]&ndash;|
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallel(sys1, sys2, in1, in2, out1, out2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallel_+3A_sys1">sys1</code></td>
<td>
<p>LTI system object of tf, ss or zpk class</p>
</td></tr>
<tr><td><code id="parallel_+3A_sys2">sys2</code></td>
<td>
<p>LTI system object of tf, ss or zpk class</p>
</td></tr>
<tr><td><code id="parallel_+3A_in1">in1</code></td>
<td>
<p>Numeric vector containing indexes to the inputs of sys1</p>
</td></tr>
<tr><td><code id="parallel_+3A_in2">in2</code></td>
<td>
<p>Numeric vector containing indexes to the inputs of sys2</p>
</td></tr>
<tr><td><code id="parallel_+3A_out1">out1</code></td>
<td>
<p>Numeric vector containing indexes to the outputs of sys1</p>
</td></tr>
<tr><td><code id="parallel_+3A_out2">out2</code></td>
<td>
<p>Numeric vector containing indexes to the outputs of sys2</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>psys &lt;-  parallel(sys1, sys2)</code> produces a state-
space system consisting of the parallel connection of sys1
and sys2 that connects all the inputs together and sums all the
outputs of the two systems.
</p>
<p>The parallel connection
is performed by appending the two systems, summing the specified
inputs and outputs, and removing the, now redundant, inputs and
outputs of system 2.
</p>
<p>If sys1 and sys2 are transfer functions, then parallel(sys1, sys2) produces a parallel
connection of the two transfer function systems.
</p>
<p><code>parallel(sys1, sys2,IN1,IN2,OUT1,OUT2)</code>
connects the two systems in parallel by connecting the inputs
specified by IN1 and IN2 and by summing the outputs specified
by OUT1 and OUT2. The vector IN1 contains
indexes into the input vectors of sys1 while, IN2 contains indexes for sys2,
. Vectors OUT1 and OUT2 contain	indexes for the outputs of the sys1 and sys2 respectively.
</p>


<h3>Value</h3>

<p>The function returns a state-space model of the parallel-connected system with A, B, C, D matrices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+series">series</a></code> <code><a href="#topic+feedback">feedback</a></code> <code><a href="#topic+connect">connect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys2 = ss(1,2,3,4)
sys3 = ss(6,7,8,9)
parallel(sys2, sys3)
parallel(tf(1, c(1,2,3)), ss(1,2,3,4))
parallel(tf(1, c(1,2,3)),tf(2, c(3,2,3)))
</code></pre>

<hr>
<h2 id='pid'>Proportional-Integral-Derivative (PID) Controller</h2><span id='topic+pid'></span>

<h3>Description</h3>

<p><code>pid</code> Parallel form of the model of a PID controller
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pid(p, i, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pid_+3A_p">p</code></td>
<td>
<p>Proportional gain. A real and finite value.</p>
</td></tr>
<tr><td><code id="pid_+3A_i">i</code></td>
<td>
<p>Integral gain. A real and finite value. set this to zero for PD and P-control</p>
</td></tr>
<tr><td><code id="pid_+3A_d">d</code></td>
<td>
<p>Derivative gain. A real and finite value. set this to zero for PI and P-control</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pid</code> creates the transfer function model for a PID, PI, PD, and P-controller.
</p>


<h3>Value</h3>

<p>Returns a transfer function model for the PID, PI, PD or P-controller.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- pid(350,300,50) # PID-control
P &lt;- TF(" 1/(s^2 + 10* s + 20)")
T &lt;- feedback(TF("C*P"), 1)
stepplot(T, seq(0,2,0.01))

C &lt;- pid(300,0,0) # P-control
T &lt;- feedback(TF("C*P"), 1)
stepplot(T, seq(0,2,0.01))

C &lt;- pid(30,70,0) # PI-control
T &lt;- feedback(TF("C*P"), 1)
stepplot(T, seq(0,2,0.01))

C &lt;- pid(300,0,10) # PD-control
T &lt;- feedback(TF("C*P"), 1)
stepplot(T, seq(0,2,0.01))

</code></pre>

<hr>
<h2 id='place'>Pole placement gain selection</h2><span id='topic+place'></span>

<h3>Description</h3>

<p>Computes the Pole placement gain selection using Ackermann's formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>place(a, b, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="place_+3A_a">a</code></td>
<td>
<p>State-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="place_+3A_b">b</code></td>
<td>
<p>Input-matrix of a state-space system</p>
</td></tr>
<tr><td><code id="place_+3A_p">p</code></td>
<td>
<p>closed loop poles</p>
</td></tr>
</table>


<h3>Details</h3>

<p>K &lt;- place(A,B,P)  calculates the feedback gain matrix K such that
the single input system
.
x &lt;- Ax + Bu
</p>
<p>with a feedback law of  u &lt;- -Kx  has closed loop poles at the
values specified in vector P, i.e.,  P &lt;- eigen(A - B * K). This function
is just a wrapper for the <code>acker</code> function.
</p>
<p>This method is NOT numerically stable and a warning message is printed if the nonzero closed loop
poles are greater than 10
in P.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F &lt;- rbind(c(0,1),c(0,0))
G &lt;- rbind(0,1)
H &lt;- cbind(1,0);
J &lt;- 0
t &lt;- 1
sys  &lt;-  ss(F,G, H,J)
A  &lt;-  c2d(sys,t);
j &lt;- sqrt(as.complex(-1));
pc  &lt;- rbind(0.78+0.18*j, 0.78-0.18*j)
K  &lt;-  place(A$A, A$B, pc)
</code></pre>

<hr>
<h2 id='pole'>Obtain Poles for a System</h2><span id='topic+pole'></span>

<h3>Description</h3>

<p>This function obtains the poles for a given system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pole(sys)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pole_+3A_sys">sys</code></td>
<td>
<p>LTI system of tf, ss and zpk class</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pole</code> returns the poles for a given system either a transfer function,
state-space or zero-pole models. If sys is a transfer function, it computes the roots of the denominator
If sys is a state-space object, it computes the eigenvalues of the A matrix.
If sys is a zpk object, it retrieves the poles from the object.
</p>


<h3>Value</h3>

<p>The function returns a column matrix containing the poles for the given system
</p>


<h3>Examples</h3>

<pre><code class='language-R'>H1 &lt;- tf(c(2, 5, 1),c(1, 3, 5))
pole(zpk(NULL, c(-1,-1), 1))
pole(ssdata(tf(1, c(1,2,1))))

</code></pre>

<hr>
<h2 id='poly2str'>Print Polynomial</h2><span id='topic+poly2str'></span>

<h3>Description</h3>

<p>Print polynomial as a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2str(p, svar = "x", smul = "*", d = options("digits")$digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly2str_+3A_p">p</code></td>
<td>
<p>numeric vector representing a polynomial</p>
</td></tr>
<tr><td><code id="poly2str_+3A_svar">svar</code></td>
<td>
<p>character representing the unknown, default x.</p>
</td></tr>
<tr><td><code id="poly2str_+3A_smul">smul</code></td>
<td>
<p>multiplication symbol, default *.</p>
</td></tr>
<tr><td><code id="poly2str_+3A_d">d</code></td>
<td>
<p>significant digits, default options(&quot;digits&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified from package *pracma*.
Modification: To hide any coefficient and power that is equal to 1
So that instead of '1s^3' we have 's^3' and instead of 's^1', we have 's'
</p>


<h3>Value</h3>

<p>Returns the usual string representing a polynomial in mathematics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly2str(c(2, -3, 1, 20, -11))

</code></pre>

<hr>
<h2 id='polysub'>Subtracting Polynomials</h2><span id='topic+polysub'></span>

<h3>Description</h3>

<p>Subtract two polynomials given as vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polysub(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polysub_+3A_a">a</code></td>
<td>
<p>Vector representing first polynomial.</p>
</td></tr>
<tr><td><code id="polysub_+3A_b">b</code></td>
<td>
<p>Vector representing second polynomial.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply calls <code>polyadd</code> from <code>pracma</code> package
in the following manner: <code>pracma::polyadd(a, -b)</code>
</p>


<h3>Value</h3>

<p>Returns a Vector representing the resulting polynomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polysub(c(1, 1, 1), 1)
polysub(c(1, 1, 1), c(0, 0, 1))

</code></pre>

<hr>
<h2 id='ramp'>Ramp Response for Linear Time-Invariant Systems</h2><span id='topic+ramp'></span><span id='topic+rampplot'></span>

<h3>Description</h3>

<p><code>ramp</code> obtains the ramp response of the linear system:
</p>
<p style="text-align: center;"><code class="reqn">dx/dt =  Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn">y = Cx + Du</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ramp(sys, t, input)
rampplot(sys, t, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ramp_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="ramp_+3A_t">t</code></td>
<td>
<p>Time vector. If not provided, it is automatically set.</p>
</td></tr>
<tr><td><code id="ramp_+3A_input">input</code></td>
<td>
<p>For calls to <code>ramp</code>, <code>input</code> is a number specifying an input for a MIMO state-space system. If the system has
3 inputs, then <code>input</code> would be set to 1, set to 2 and then to 3 to obtain the ramp
response from input 1, 2, and 3 to the outputs. For single input systems, <code>input</code> is always
set to 1.
</p>
<p>For calls to <code>rampplot</code>, <code>input</code> is a vector or range for a MIMO state-space system. For example, <code>input &lt;- 1:3</code> for a system with 3-inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ramp</code> produces the ramp response of linear systems using <code>lsim</code>
</p>
<p><code>rampplot</code> produces the ramp response as a plot against time.
</p>
<p>These functions can handle both SISO and MIMO (state-space) models.
</p>
<p>#' Other possible calls using <code>ramp</code> and <code>rampplot</code> are:
</p>
<p><code>ramp(sys)</code>
</p>
<p><code>ranp(sys, t)</code>
</p>
<p><code>rampplot(sys)</code>
</p>
<p><code>rampplot(sys, t)</code>
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>ramp</code> containing:
</p>
<p><code>t</code> Time vector
</p>
<p><code>x</code> Individual response of each x variable
</p>
<p><code>y</code> Response of the system
</p>
<p>The matrix <code>y</code> has as many rows as there are outputs, and columns of the same size of <code>length(t)</code>.
The matrix <code>x</code> has as many rows as there are states.  If the time
vector is not specified, then the automatically set time
vector is returned as <code>t</code>
</p>
<p>A plot of <code>y</code> vs <code>t</code> is returned by calling <code>rampplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initial">initial</a></code> <code><a href="#topic+step">step</a></code> <code><a href="#topic+impulse">impulse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- ramp(tf(1, c(1,2,1)))
res$y
res$t
ramp(tf(1, c(1,2,1)), seq(0, 6, 0.1))
rampplot(tf(1, c(1,2,1)))
rampplot(tf(1, c(1,2,1)), seq(0, 6, 0.1))

## Not run:  State-space MIMO systems 
A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1));
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
res1 &lt;- ramp(ss(A,B,C,D), input = 1)
res2 &lt;- ramp(ss(A,B,C,D), input = 2)
res1$y # has two rows, i.e. for two outputs
res2$y # has two rows, i.e. for two outputs
rampplot(ss(A,B,C,D), input = 1:2) # OR
rampplot(ss(A,B,C,D), input = 1:ncol(D))
rampplot(ss(A,B,C,D), seq(0,3,0.01), 1:2)

</code></pre>

<hr>
<h2 id='selectsys'>Select/Remove Subsystem in State-space Model</h2><span id='topic+selectsys'></span><span id='topic+removesys'></span>

<h3>Description</h3>

<p><code>selectsys</code> extracts a subsystem from a larger state-space system.
<code>removesys</code> removes specified inputs, outputs, and state from a state-space system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectsys(statesys, inputs, outputs, states)
       removesys(statesys, inputs, outputs, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectsys_+3A_statesys">statesys</code></td>
<td>
<p>LTI system model of state-space model</p>
</td></tr>
<tr><td><code id="selectsys_+3A_inputs">inputs</code></td>
<td>
<p>single integer or vector specifying the particular inputs to be selected/removed</p>
</td></tr>
<tr><td><code id="selectsys_+3A_outputs">outputs</code></td>
<td>
<p>single integer or vector specifying the particular outputs to be selected/removed</p>
</td></tr>
<tr><td><code id="selectsys_+3A_states">states</code></td>
<td>
<p>single integer or vector specifying the particular states to be selected/removed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subsys &lt;- selectsys(statesys,inputs,outputs)</code> will extract a state
space subsystem with the specified inputs and outputs.
</p>
<p><code>subsys &lt;- selectsys(statesys, inputs,outputs,states)</code> will return
the state space subsystem with the specified inputs, outputs, and states.
</p>
<p><code>subsys &lt;-  removesys(statesys, inputs, outputs)</code> will remove the specified inputs and outputs from the system.
</p>
<p><code>subsys &lt;-  removesys(statesys, inputs, outputs, states)</code> will
also return a state-space model with the specified inputs, outputs, and
states removed from the system.
</p>


<h3>Value</h3>

<p>Returns a subsystem of the state-space model
</p>


<h3>See Also</h3>

<p><code><a href="#topic+append">append</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(33,2,5), c(23,200,2), c(9,2,45))
B &lt;- rbind(c(4,5), c(12,5), c(82,1))
C &lt;- rbind(c(34,56,2), c(6,2,112))
D &lt;- rbind(c(2,0), c(0,19))
sys1 &lt;- ss(A, B, C, D)
 selectsys(sys1, 1, 1) # extract subsystem for only input 1 and output 1
 selectsys(sys1, 2,2) # extract subsystem for only input 2 and output 2
 selectsys(sys1, 2, 1:2) # extract subsystem for only input 1 and output 1 to 2
 selectsys(sys1, 1:2, 2) # extract subsystem for only input 1 to 2 and output 2 to 2
 selectsys(sys1, 2, 2, 1:2) # extract subsystem for only input 2 and output 2 but states 1 to 2
 removesys(sys1, 1,2) # removes input 1 and output 2
</code></pre>

<hr>
<h2 id='series'>Series Connection of two systems</h2><span id='topic+series'></span>

<h3>Description</h3>

<p><code>series</code> connects two systems in the series block form below
</p>
<p>u &mdash;&gt;[System1]&mdash;&gt;[System2]&mdash;-&gt; y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series(sys1, sys2, outputs, inputs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_+3A_sys1">sys1</code></td>
<td>
<p>LTI system object of tf, ss or zpk class</p>
</td></tr>
<tr><td><code id="series_+3A_sys2">sys2</code></td>
<td>
<p>LTI system object of tf, ss or zpk class</p>
</td></tr>
<tr><td><code id="series_+3A_outputs">outputs</code></td>
<td>
<p>vector of outputs</p>
</td></tr>
<tr><td><code id="series_+3A_inputs">inputs</code></td>
<td>
<p>vector of inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seriessys &lt;- series(sys1, sys2)</code> connects the two state-space systems in series such that the outputs of sys1
specified are connected to the inputs of sys2	specified by input2.
If sys1 and sys2 are both transfer functions,  <code>series(systf1, systf2)</code> produces the SISO system
in transfer function form obtained by connecting the two SISO
transfer function systems in series.
If a system is not in state-space representation, the function
tries to form a state-space representation for such system.
</p>


<h3>Value</h3>

<p>The function returns a state-space model of the aggregate system with A, B, C, D matrices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parallel">parallel</a></code> <code><a href="#topic+feedback">feedback</a></code> <code><a href="#topic+connect">connect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series(tf(1, c(1,2,3)), tf(2, c(2,3,5)))
sys2 = ss(1,2,3,4)
sys3 = ss(6,7,8,9)
series(sys2, sys3)
series(tf(1, c(1,2,3)), ss(1,2,3,4))

</code></pre>

<hr>
<h2 id='ss'>Create State-space Model.</h2><span id='topic+ss'></span>

<h3>Description</h3>

<p><code>ss</code> creates the model for a system represented in state-space form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss(A, B, C, D, Ts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ss_+3A_a">A</code></td>
<td>
<p>An n x n matrix</p>
</td></tr>
<tr><td><code id="ss_+3A_b">B</code></td>
<td>
<p>An n x m matrix</p>
</td></tr>
<tr><td><code id="ss_+3A_c">C</code></td>
<td>
<p>An p x n matrix</p>
</td></tr>
<tr><td><code id="ss_+3A_d">D</code></td>
<td>
<p>An p x m matrix</p>
</td></tr>
<tr><td><code id="ss_+3A_ts">Ts</code></td>
<td>
<p>Sample time for discrete time systems</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ss</code> creates a model object for state-space systems.
</p>


<h3>Value</h3>

<p>Returns a list object of 'ss' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf">tf</a></code> <code><a href="#topic+zpk">zpk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(-2, -1), c(1,0))
B &lt;- rbind(1,0)
C &lt;- cbind(0,1)
D &lt;- 0;
sys &lt;- ss(A,B,C,D)

## Not run:   OR 

sys &lt;- ss(c(-2,-1,1,0), c(1,0), c(0,1), 0)

## Not run:   Access individual state-space sys elements as 

sys$A
sys$B
sys$C
sys$D

</code></pre>

<hr>
<h2 id='ss2tf'>State-space model conversion to Transfer function model.</h2><span id='topic+ss2tf'></span>

<h3>Description</h3>

<p><code>ss2tf</code> converts the model for a state-space system to transfer function representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss2tf(a, b, c, d, iu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ss2tf_+3A_a">a</code></td>
<td>
<p>An n x n matrix</p>
</td></tr>
<tr><td><code id="ss2tf_+3A_b">b</code></td>
<td>
<p>An n x m matrix</p>
</td></tr>
<tr><td><code id="ss2tf_+3A_c">c</code></td>
<td>
<p>An p x n matrix</p>
</td></tr>
<tr><td><code id="ss2tf_+3A_d">d</code></td>
<td>
<p>An p x m matrix</p>
</td></tr>
<tr><td><code id="ss2tf_+3A_iu">iu</code></td>
<td>
<p>A numeric value denoting number of inputs. default value is 1.For example, if the system
has three inputs (u1, u2, u3), then iu must be either 1, 2, or 3, where 1 implies u1, 2
implies u2, and 3 implies u3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ss2tf</code> converts a model object in state-space form to transfer function model by calculating the transfer function of the system:
.
x = Ax + Bu
y = Cx + Du
</p>
<p>#' Other possible usages for <code>ss2tf</code> are:
<code>ss2tf(a,b,c,d)</code>
<code>ss2tf(sys)</code>
<code>ss2tf(sys, iu)</code>
</p>
<p>where <code>sys</code> is an object of state-space class
</p>


<h3>Value</h3>

<p>Returns an object of 'tf' class containing <code>num</code> and <code>den</code>. The numerator coefficients
are returned in matrix <code>num</code> with as many rows as outputs <code>y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf2ss">tf2ss</a></code> <code><a href="#topic+ss2zp">ss2zp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys2 &lt;- tf2ss(tf(1, c(1,2,1)))
ss2tf(sys2)

## Not run:   OR 

ss2tf(sys2$A,sys2$B,sys2$C,sys2$D)

# a single input multiple output system
A &lt;- rbind(c(0,1), c(-10000,-4)); B &lt;- rbind(0,1); C &lt;- rbind(c(1,0), c(0,1));
D &lt;- rbind(0,0)
ss2tf(A, B, C, D)

# a MIMO system
A = rbind(c(0,1), c(-25,-4)); B = rbind(c(1,1), c(0,1));
C = rbind(c(1,0), c(0,1)); D = rbind(c(0,0), c(0,0))
ss2tf(A,B,C,D,1) # to obtain output for input 1
ss2tf(A,B,C,D,2) # to obtain output for input 2

## OR

systems &lt;- vector("list", ncol(D))
for(i in 1:ncol(D)){ systems[[i]] &lt;- ss2tf(A,B,C,D,i) }
systems
systems[[1]]
systems[[2]]

</code></pre>

<hr>
<h2 id='ss2zp'>State-space representation to zero-pole-gain representation</h2><span id='topic+ss2zp'></span>

<h3>Description</h3>

<p><code>ss2zp</code> converts a system represented in state-space form to zero-pole-gain model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss2zp(a,b,c,d,iu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ss2zp_+3A_a">a</code></td>
<td>
<p>An n x n matrix</p>
</td></tr>
<tr><td><code id="ss2zp_+3A_b">b</code></td>
<td>
<p>An n x m matrix</p>
</td></tr>
<tr><td><code id="ss2zp_+3A_c">c</code></td>
<td>
<p>An p x n matrix</p>
</td></tr>
<tr><td><code id="ss2zp_+3A_d">d</code></td>
<td>
<p>An p x m matrix</p>
</td></tr>
<tr><td><code id="ss2zp_+3A_iu">iu</code></td>
<td>
<p>A numeric value denoting number of inputs. default value is 1.For example, if the system
has three inputs (u1, u2, u3), then iu must be either 1, 2, or 3, where 1 implies u1, 2
implies u2, and 3 implies u3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ss2zp</code> converts a system represented in zero-pole form to state-space by converting from zero-pole to transfer function and from transfer functon to state-space
The vector P contains the pole locations of the denominator of the transfer function.
</p>
<p>Other possible usages for <code>ss2zp</code> are:
</p>
<p><code>ss2zp(a,b,c,d)</code>
</p>
<p><code>ss2zp(sys)</code>
</p>
<p><code>ss2zp(sys, iu)</code>
</p>
<p>where <code>sys</code> is  an object of state-space class
</p>


<h3>Value</h3>

<p>Returns a list object of 'zpk' class, consisting of z, p and k. The numerator zeros are returned in the columns of matrix Z with number of columns equal to number of outputs.  The gains for
each numerator transfer function are returned in column vector K. P, a column vector contains the pole locations of the denominator of the transfer function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zp2ss">zp2ss</a></code> <code><a href="#topic+ss2tf">ss2tf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(-2, -1), c(1,0)); B &lt;- rbind(1,0);
C &lt;- cbind(0,1); D &lt;- 0;
sys2 &lt;- ss(A,B,C,D)
ss2zp(sys2$A,sys2$B,sys2$C,sys2$D)
ss2zp( zp2ss ( tf2zp( c(1,1,1), c(1,2,1) ) ) )

## Not run:   A MIMO system 
A = rbind(c(0,1), c(-25,-4)); B = rbind(c(1,1), c(0,1));
C = rbind(c(1,0), c(0,1)); D = rbind(c(0,0), c(0,0))
ss2tf(A,B,C,D,1) # to obtain output for input 1
ss2tf(A,B,C,D,2) # to obtain output for input 2

## Not run:   OR 

systems &lt;- vector("list", ncol(D))
for(i in 1:ncol(D)){ systems[[i]] &lt;- ss2zp(A,B,C,D,i) }
systems
systems[[1]]
systems[[2]]

</code></pre>

<hr>
<h2 id='ssdata'>Retrieve State-space data</h2><span id='topic+ssdata'></span>

<h3>Description</h3>

<p><code>ssdata</code> retrieves the model for a state-space system from a <code>sys</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssdata(sys1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssdata_+3A_sys1">sys1</code></td>
<td>
<p>an LTI system object of tf, ss or zpk classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ssdata</code> retrieves a model object for a state-space system, from a <code>sys</code> object of tf, ss and zpk classes
</p>


<h3>Value</h3>

<p>Returns a list object of <code>ss</code> class containing A, B, C and D matrices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ss">ss</a></code> <code><a href="#topic+tfdata">tfdata</a></code> <code><a href="#topic+zpkdata">zpkdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys1 &lt;- tf(c(1), c(1,2,1))
 ssdata(sys1)
 A &lt;- rbind(c(-2, -1), c(1,0)); B &lt;- rbind(1,0);
 C &lt;- cbind(0,1); D &lt;- 0;
 sys2 &lt;- ss(A,B,C,D)
 ssdata(sys2)
 ss2zp(ssdata(zpk(NULL, c(-1,-1), 1)))

</code></pre>

<hr>
<h2 id='step'>Step Response for Linear Systems</h2><span id='topic+step'></span><span id='topic+stepplot'></span>

<h3>Description</h3>

<p><code>step</code> obtains the time response of the linear system:
</p>
<p style="text-align: center;"><code class="reqn">dx/dt =  Ax + Bu</code>
</p>

<p style="text-align: center;"><code class="reqn">y = Cx + Du</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>step(sys, t, input)
stepplot(sys, t, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_+3A_sys">sys</code></td>
<td>
<p>LTI system of transfer-function, state-space and zero-pole classes</p>
</td></tr>
<tr><td><code id="step_+3A_t">t</code></td>
<td>
<p>Time vector. If not provided, it is automatically set.</p>
</td></tr>
<tr><td><code id="step_+3A_input">input</code></td>
<td>
<p>For calls to <code>step</code>, <code>input</code> is a number specifying an input for a MIMO state-space system. If the system has
3 inputs, then <code>input</code> would be set to 1, set to 2 and then to 3 to obtain the step
response from input 1, 2, and 3 to the outputs. For single input systems, <code>input</code> is always
set to 1.
</p>
<p>For calls to <code>stepplot</code>, <code>input</code> is a vector or range for a MIMO state-space system. For example, <code>input &lt;- 1:3</code> for a system with 3-inputs</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>step</code> produces the step response of linear systems using <code>lsim</code>
</p>
<p><code>stepplot</code> produces the step response as a plot againts time.
</p>
<p>The functions can handle both SISO and MIMO (state-space) models.
</p>
<p>Other possible calls using <code>step</code> and <code>stepplot</code> are:
</p>
<p><code>step(sys)</code>
</p>
<p><code>step(sys, t)</code>
</p>
<p><code>stepplot(sys)</code>
</p>
<p><code>stepplot(sys, t)</code>
</p>


<h3>Value</h3>

<p>A list is returned by calling <code>step</code> containing:
</p>
<p><code>x</code> Individual response of each x variable
</p>
<p><code>y</code> Response of the system
</p>
<p><code>t</code> Time vector
</p>
<p>The matrix <code>y</code> has as many rows as there are outputs, and columns of the same size of <code>length(t)</code>.
The matrix X has as many rows as there are states.  If the time
vector is not specified, then the automatically set time
vector is returned as <code>t</code>
</p>
<p>A plot of <code>y</code> vs <code>t</code> is returned by calling <code>stepplot</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initial">initial</a></code> <code><a href="#topic+impulse">impulse</a></code> <code><a href="#topic+ramp">ramp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- step(tf(1, c(1,2,1)))
res$y
res$t
step(tf(1, c(1,2,1)), seq(0, 10, 0.1))
stepplot(tf(1, c(1,2,1)))
stepplot(tf(1, c(1,2,1)), seq(0, 10, 0.1))

## Not run:   State-space MIMO systems 

A &lt;- rbind(c(0,1), c(-25,-4)); B &lt;- rbind(c(1,1), c(0,1));
C &lt;- rbind(c(1,0), c(0,1)); D &lt;- rbind(c(0,0), c(0,0))
res1 &lt;- step(ss(A,B,C,D), input = 1)
res2 &lt;- step(ss(A,B,C,D), input = 2)
res1$y # has two rows, i.e. for two outputs
res2$y # has two rows, i.e. for two outputs
stepplot(ss(A,B,C,D), input = 1:2) # OR
stepplot(ss(A,B,C,D), input = 1:ncol(D))

</code></pre>

<hr>
<h2 id='tf'>Create Transfer function Model.</h2><span id='topic+tf'></span>

<h3>Description</h3>

<p><code>tf</code> creates the model for a transfer function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf(num, den, Ts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tf_+3A_num">num</code></td>
<td>
<p>A numeric vector or matrix (for multivariable systems)</p>
</td></tr>
<tr><td><code id="tf_+3A_den">den</code></td>
<td>
<p>A numeric vector or matrix (for multivariable systems)</p>
</td></tr>
<tr><td><code id="tf_+3A_ts">Ts</code></td>
<td>
<p>Sample time for discrete time systems</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tf</code> creates a model object for a transfer function, Where <code>num</code> is the numerator and <code>den</code> is the denominator
of the transfer function.
</p>


<h3>Value</h3>

<p>Returns an object of 'tf' class list with a proper transfer function or with warnings when not proper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ss">ss</a></code> <code><a href="#topic+zpk">zpk</a></code> <code><a href="#topic+TF">TF</a></code> <code><a href="#topic+tf2ss">tf2ss</a></code> <code><a href="#topic+tf2zp">tf2zp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf(1, c(1,2,1))
sys1 &lt;- tf(1, c(1,2,1))
sys1$num
sys1$den

## Not run:   for single-input multi-output systems (SIMO) each numerator row for one output 
num = rbind(c(0,1,1), c(1,0,1))
den = rbind(c(1,3,2))
tf(num, den)

</code></pre>

<hr>
<h2 id='TF'>Evaluate Transfer function Expressions</h2><span id='topic+TF'></span>

<h3>Description</h3>

<p><code>TF</code> Evaluates a given transfer function expression in the s-domain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TF(str_expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TF_+3A_str_expr">str_expr</code></td>
<td>
<p>String expression containing the transfer function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>TF</code> Evaluates a given transfer function polynomial expression in the s-domain.
The evaluation of the expressions are performed similar to symbolic math computations for polynomials.
A transfer function model is created as the result of the expression evaluation.
Thus, this is an alternative way of creating transfer function models following the natural math expressions
found in block diagrams. It also provides an alternative way to perform system interconnections. Only transfer
function models are currently supported for system interconnection using this function. System interconnections
for other models could be performed using the <code>series</code>, <code>parallel</code>, <code>feedback</code> or <code>connect</code> functions.
See the Examples section for further details.
</p>


<h3>Value</h3>

<p>Returns an object of 'tf' class list with a transfer function. Numerator and denominator
coefficients could then be retrieved from the object the same way as any other <code>tf</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf">tf</a></code> <code><a href="#topic+tf2ss">tf2ss</a></code> <code><a href="#topic+series">series</a></code> <code><a href="#topic+parallel">parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example taken from the GitHub page of Julia Control - an electric motor example
J &lt;- 2.0
b &lt;- 0.04
K &lt;- 1.0
R &lt;- 0.08
L &lt;- 1e-4
P &lt;- TF("K/(s*((J*s + b)*(L*s + R) + K^2))")
Cls &lt;- TF("P/(1 + P)") # closed-loop connection

# More examples
TF("s+1")
sys1 &lt;- tf(1, c(1, 2, 5))
sys2 &lt;- tf(2, c(1, 2, 5))
TF("sys1 + sys2") # parallel system interconnection
TF("sys1 * sys2") # series system interconnection
TF("sys1 - sys2")
TF("sys1 - 1")
TF("sys1 + 1")
TF("sys1 - sys2 + sys2")
TF("sys1 / sys2 / sys2")

</code></pre>

<hr>
<h2 id='tf2ss'>Transfer function model conversion to State-space model.</h2><span id='topic+tf2ss'></span>

<h3>Description</h3>

<p><code>tf2ss</code> converts the model for a transfer function to state-space representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf2ss(num, den)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tf2ss_+3A_num">num</code></td>
<td>
<p>A numeric vector containing the coefficients of the</p>
</td></tr>
<tr><td><code id="tf2ss_+3A_den">den</code></td>
<td>
<p>A numeric vector containing the coefficients of the</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tf2ss</code> converts a model object for a transfer function to a state-space model, Where <code>num</code> is the numerator and <code>den</code> is the denominator
of the transfer function and <code>sys</code> is a transfer function object
</p>
<p>Another possible call is <code>tf2ss(sys)</code> where <code>sys</code> is object of transfer-function model.
</p>


<h3>Value</h3>

<p>Returns an object of 'ss' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ss2tf">ss2tf</a></code> <code><a href="#topic+tf2zp">tf2zp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf2ss(tf(1, c(1,2,1)))

## Not run:   OR 

sys &lt;- tf(1, c(1,2,1))
tf2ss(sys)

## Not run:   OR 

sys2 &lt;- tf2ss(1, c(1,2,1))

</code></pre>

<hr>
<h2 id='tf2zp'>Transfer function model conversion to Zero-Pole-Gain model.</h2><span id='topic+tf2zp'></span>

<h3>Description</h3>

<p><code>tf2zp</code> converts the model for a transfer function to zero-pole-gain representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tf2zp(num, den)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tf2zp_+3A_num">num</code></td>
<td>
<p>A numeric vector containing the coefficients of the</p>
</td></tr>
<tr><td><code id="tf2zp_+3A_den">den</code></td>
<td>
<p>A numeric vector containing the coefficients of the</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tf2zp</code> converts a model object for a transfer function to a zero-pole model, Where <code>num</code> is the numerator and <code>den</code> is the denominator
of the transfer function and <code>sys</code> is a transfer function object
</p>
<p>Another possible call is: <code>tf2zp(sys)</code>
</p>
<p>where <code>sys</code> is  an object of transfer-function model.
</p>


<h3>Value</h3>

<p>Returns a list object of 'zpk' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf2ss">tf2ss</a></code> <code><a href="#topic+zp2tf">zp2tf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>syszp1 &lt;- tf2zp(c(1,1), c(1,2,1))
syszp1
syszp2 &lt;- tf2zp(c(2,2,1), c(1,2,1))
syszp2
unclass(syszp2) # to see list of the zeros,poles and gain as vectors
tf2zp(zp2tf(c(-1,-1), c(-1,-2), 5))
</code></pre>

<hr>
<h2 id='tfchk'>Transfer function check.</h2><span id='topic+tfchk'></span>

<h3>Description</h3>

<p><code>tfchk</code> verifies the structure of a transfer function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfchk(num, den)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfchk_+3A_num">num</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="tfchk_+3A_den">den</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility function that is always invoked by other functions to
verify the structure of <code>num, den</code>. Where <code>num</code> is the numerator and <code>den</code> is the denominator
of the transfer function. If the transfer function is not proper, it returns a list with length(num) = length(den).
</p>


<h3>Value</h3>

<p>Returns a list with a proper transfer function or with warnings when not proper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tf1 &lt;- tfchk(1, c(1,2,1))

</code></pre>

<hr>
<h2 id='tfdata'>Retrieve Transfer function data</h2><span id='topic+tfdata'></span>

<h3>Description</h3>

<p><code>tfdata</code> retrieves the model for a transfer function from a <code>sys</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfdata(sys1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfdata_+3A_sys1">sys1</code></td>
<td>
<p>an LTI system object of tf, ss or zpk classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfdata</code> retrieves a model object for a transfer function, from a <code>sys</code> object of tf, ss and zpk classes
</p>


<h3>Value</h3>

<p>Returns a list object of <code>tf</code> class containing numerator and denominator coefficients in desecending values of s.
For multiple-input multiple-output systems (MIMO) a list containing tf sys objects for as many outputs is returned
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tf">tf</a></code> <code><a href="#topic+ssdata">ssdata</a></code> <code><a href="#topic+zpkdata">zpkdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys1 &lt;- zpk(NULL, c(-1,-1), 1)
tfdata(sys1)
A &lt;- rbind(c(-2, -1), c(1,0)); B &lt;- rbind(1,0);
C &lt;- cbind(0,1); D &lt;- 0
tfdata( ss(A, B, C, D) )
tfdata(ss2zp( A,B,C,D))
tfdata(tf(c(1), c(1,2,1)))

 ## Not run:   MIMO system 
A = rbind(c(0,1), c(-25,-4)); B = rbind(c(1,1), c(0,1));
C = rbind(c(1,0), c(0,1)); D = rbind(c(0,0), c(0,0))
tfdata(ss(A,B,C,D))

</code></pre>

<hr>
<h2 id='zp2ss'>Convert Zero-Pole-Gain Model to State-Space Model</h2><span id='topic+zp2ss'></span>

<h3>Description</h3>

<p><code>zp2ss</code> converts a system represented in zero-pole form to state-space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zp2ss(z,p,k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zp2ss_+3A_z">z</code></td>
<td>
<p>Zero, a vector or single row matrix</p>
</td></tr>
<tr><td><code id="zp2ss_+3A_p">p</code></td>
<td>
<p>Pole, a vector or single row matrix</p>
</td></tr>
<tr><td><code id="zp2ss_+3A_k">k</code></td>
<td>
<p>Gain, a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zp2ss</code> converts a system represented in zero-pole form to state-space by converting from zero-pole to transfer function and from transfer functon to state-space
</p>
<p>Another possible usage is: <code>zp2ss(sys)</code>
</p>
<p>where <code>sys</code> is  an object of zero-pole-gain model.
</p>


<h3>Value</h3>

<p>Returns a list object of 'ss' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ss2zp">ss2zp</a></code> <code><a href="#topic+zp2tf">zp2tf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zp2ss(NULL, c(-1,-1), 1)
zp2ss(tf2zp(c(1,1,1), c(1,2,1)))

</code></pre>

<hr>
<h2 id='zp2tf'>Zero-pole-gain model conversion to Transfer function model</h2><span id='topic+zp2tf'></span>

<h3>Description</h3>

<p><code>zp2tf</code> converts the model for a zero-pole-gain system to transfer function representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zp2tf(z, p, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zp2tf_+3A_z">z</code></td>
<td>
<p>A numeric vector containing zero locations</p>
</td></tr>
<tr><td><code id="zp2tf_+3A_p">p</code></td>
<td>
<p>A numeric vector containing pole locations</p>
</td></tr>
<tr><td><code id="zp2tf_+3A_k">k</code></td>
<td>
<p>A numeric vector for gain</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zp2tf</code> converts a model object for a zero-pole-gain system to a transfer function model
</p>
<p>Another possible usage is: <code>zp2tf(sys)</code>
</p>
<p>where <code>sys</code> is  an object of zero-pole-gain model.
</p>


<h3>Value</h3>

<p>Returns a list object of 'tf' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zp2ss">zp2ss</a></code> <code><a href="#topic+tf2zp">tf2zp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>systf &lt;- zp2tf(zpk(NULL, c(-1,-1), 1))
zp2tf(tf2zp(c(2,2,1), c(1,2,1)))

</code></pre>

<hr>
<h2 id='zpk'>Create Zero-Pole-Gain Model.</h2><span id='topic+zpk'></span>

<h3>Description</h3>

<p><code>zpk</code> creates the model for a system represented in zero-pole form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zpk(zero, pole, gain, Ts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zpk_+3A_zero">zero</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="zpk_+3A_pole">pole</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="zpk_+3A_gain">gain</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="zpk_+3A_ts">Ts</code></td>
<td>
<p>Sample time for discrete time systems</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zpk</code> creates a model object for zero-pole systems.
</p>


<h3>Value</h3>

<p>Returns a list object of 'zpk' class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ss">ss</a></code> <code><a href="#topic+tf">tf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sys &lt;- zpk(NULL, c(-1,-1), 1)
sys &lt;- zpk(c(1,2), c(3,4), 5)
sys &lt;- zpk(c(1,2), c(3+1i,4+2i), 5)

## Not run:   Access individual sys elements as 
sys$z
sys$p
sys$k

</code></pre>

<hr>
<h2 id='zpkdata'>Retrieve zero-pole data from LTI system object</h2><span id='topic+zpkdata'></span>

<h3>Description</h3>

<p><code>zpkdata</code> retrieves the model for a zero-pole-gain system from a <code>sys</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zpkdata(sys1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zpkdata_+3A_sys1">sys1</code></td>
<td>
<p>an LTI system object of <code>tf</code>, <code>ss</code> or <code>zpk</code> classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zpkdata</code> retrieves a model object for a zero-pole-gain system, from a <code>sys</code> object of <code>tf</code>, <code>ss</code> and <code>zpk</code> classes
</p>


<h3>Value</h3>

<p>Returns a list object of <code>zpk</code> class containing zero, pole and gain matrices. For multivariable systems,
the zeros of each system is listed as a column in the zeros matrix, the poles are listed as a column-vector as well as the
gain
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zpk">zpk</a></code> <code><a href="#topic+tfdata">tfdata</a></code> <code><a href="#topic+ssdata">ssdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sys1 &lt;- zpk(NULL, c(-1,-1), 1)
zpkdata(sys1)
sys3 &lt;- tf(c(1), c(1,2,1))
zpkdata(sys3)

## Not run:   MIMO system of 2-inputs and 2-outputs 
A = rbind(c(0,1), c(-25,-4)); B = rbind(c(1,1), c(0,1));
C = rbind(c(1,0), c(0,1)); D = rbind(c(0,0), c(0,0))
zpkdata(ss(A,B,C,D))

## OR
syszp &lt;- zpkdata(ss(A,B,C,D))
syszp[[1]]
syszp[[2]]
syszp[[1]]$z # retrieve zeros of system 1 - Input 1 to Outputs 1 and 2
syszp[[2]]$z # retrieve zeros of system 2 - Input 2 to Outputs 1 and 2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
