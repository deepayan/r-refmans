<!DOCTYPE html><html lang="en"><head><title>Help for package mlmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcqmc06_l'><p>Financial options using a Milstein discretisation</p></a></li>
<li><a href='#mlmc'><p>Multi-level Monte Carlo estimation</p></a></li>
<li><a href='#mlmc.test'><p>Multi-level Monte Carlo estimation test suite</p></a></li>
<li><a href='#opre_l'><p>Financial options using an Euler-Maruyama discretisation</p></a></li>
<li><a href='#plot.mlmc.test'><p>Plot an <code>mlmc.test</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Level Monte Carlo</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of MLMC (Multi-Level Monte Carlo), Giles (2008)
    &lt;<a href="https://doi.org/10.1287%2Fopre.1070.0496">doi:10.1287/opre.1070.0496</a>&gt;, Heinrich (1998) &lt;<a href="https://doi.org/10.1006%2Fjcom.1998.0471">doi:10.1006/jcom.1998.0471</a>&gt;,
    for R.  This package builds on the original 'Matlab' and 'C++' implementations
    by Mike Giles to provide a full MLMC driver and example level samplers.
    Multi-core parallel sampling of levels is provided built-in.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/louisaslett/mlmc/issues">https://github.com/louisaslett/mlmc/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlmc.louisaslett.com/">https://mlmc.louisaslett.com/</a>, <a href="https://github.com/louisaslett/mlmc">https://github.com/louisaslett/mlmc</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, grid, parallel, Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 18:02:37 UTC; louis</td>
</tr>
<tr>
<td>Author:</td>
<td>Louis Aslett <a href="https://orcid.org/0000-0003-2211-233X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, trl],
  Mike Giles <a href="https://orcid.org/0000-0002-5445-3721"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Tigran Nagapetyan <a href="https://orcid.org/0000-0002-0379-1157"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sebastian Vollmer <a href="https://orcid.org/0000-0003-2831-1401"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-11 18:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcqmc06_l'>Financial options using a Milstein discretisation</h2><span id='topic+mcqmc06_l'></span>

<h3>Description</h3>

<p>Financial options based on scalar geometric Brownian motion, similar to Mike Giles' MCQMC06 paper, Giles (2008), using a Milstein discretisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcqmc06_l(l, N, option)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcqmc06_l_+3A_l">l</code></td>
<td>
<p>the level to be simulated.</p>
</td></tr>
<tr><td><code id="mcqmc06_l_+3A_n">N</code></td>
<td>
<p>the number of samples to be computed.</p>
</td></tr>
<tr><td><code id="mcqmc06_l_+3A_option">option</code></td>
<td>
<p>the option type, between 1 and 5.
The options are:
</p>

<dl>
<dt>1 = European call;</dt><dd></dd>
<dt>2 = Asian call;</dt><dd></dd>
<dt>3 = lookback call;</dt><dd></dd>
<dt>4 = digital call;</dt><dd></dd>
<dt>5 = barrier call.</dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on GPL-2 C++ code by Mike Giles.
</p>


<h3>Value</h3>

<p>A named list containing: </p>

<dl>
<dt><code>sums</code></dt><dd><p>is a vector of length six <code class="reqn">\left(\sum Y_i, \sum Y_i^2, \sum Y_i^3, \sum Y_i^4, \sum X_i, \sum X_i^2\right)</code> where <code class="reqn">Y_i</code> are iid simulations with expectation <code class="reqn">E[P_0]</code> when <code class="reqn">l=0</code> and expectation <code class="reqn">E[P_l-P_{l-1}]</code> when <code class="reqn">l&gt;0</code>, and <code class="reqn">X_i</code> are iid simulations with expectation <code class="reqn">E[P_l]</code>.
Note that only the first two components of this are used by the main <code><a href="#topic+mlmc">mlmc()</a></code> driver, the full vector is used by <code><a href="#topic+mlmc.test">mlmc.test()</a></code> for convergence tests etc;</p>
</dd>
<dt><code>cost</code></dt><dd><p>is a scalar with the total cost of the paths simulated, computed as <code class="reqn">N \times 2^l</code> for level <code class="reqn">l</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;
</p>
<p>Mike Giles &lt;Mike.Giles@maths.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Giles, M. (2008) 'Improved Multilevel Monte Carlo Convergence using the Milstein Scheme', in A. Keller, S. Heinrich, and H. Niederreiter (eds) <em>Monte Carlo and Quasi-Monte Carlo Methods 2006</em>. Berlin, Heidelberg: Springer, pp. 343–358. Available at: <a href="https://doi.org/10.1007/978-3-540-74496-2_20">doi:10.1007/978-3-540-74496-2_20</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# These are similar to the MLMC tests for the MCQMC06 paper
# using a Milstein discretisation with 2^l timesteps on level l
#
# The figures are slightly different due to:
# -- change in MSE split
# -- change in cost calculation
# -- different random number generation
# -- switch to S_0=100
#
# Note the following takes quite a while to run, for a toy example see after
# this block.

N0   &lt;- 200 # initial samples on coarse levels
Lmin &lt;- 2 # minimum refinement level
Lmax &lt;- 10 # maximum refinement level

test.res &lt;- list()
for(option in 1:5) {
  if(option == 1) {
    cat("\n ---- Computing European call ---- \n")
    N      &lt;- 20000 # samples for convergence tests
    L      &lt;- 8 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  } else if(option == 2) {
    cat("\n ---- Computing Asian call ---- \n")
    N      &lt;- 20000 # samples for convergence tests
    L      &lt;- 8 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  } else if(option == 3) {
    cat("\n ---- Computing lookback call ---- \n")
    N      &lt;- 20000 # samples for convergence tests
    L      &lt;- 10 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  } else if(option == 4) {
    cat("\n ---- Computing digital call ---- \n")
    N      &lt;- 200000 # samples for convergence tests
    L      &lt;- 8 # levels for convergence tests
    Eps    &lt;- c(0.01, 0.02, 0.05, 0.1, 0.2)
  } else if(option == 5) {
    cat("\n ---- Computing barrier call ---- \n")
    N      &lt;- 200000 # samples for convergence tests
    L      &lt;- 8 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  }

  test.res[[option]] &lt;- mlmc.test(mcqmc06_l, N, L, N0, Eps, Lmin, Lmax, option = option)

  # print exact analytic value, based on S0=K
  T   &lt;- 1
  r   &lt;- 0.05
  sig &lt;- 0.2
  K   &lt;- 100
  B   &lt;- 0.85*K

  k   &lt;- 0.5*sig^2/r;
  d1  &lt;- (r+0.5*sig^2)*T / (sig*sqrt(T))
  d2  &lt;- (r-0.5*sig^2)*T / (sig*sqrt(T))
  d3  &lt;- (2*log(B/K) + (r+0.5*sig^2)*T) / (sig*sqrt(T))
  d4  &lt;- (2*log(B/K) + (r-0.5*sig^2)*T) / (sig*sqrt(T))

  if(option == 1) {
    val &lt;- K*( pnorm(d1) - exp(-r*T)*pnorm(d2) )
  } else if(option == 2) {
    val &lt;- NA
  } else if(option == 3) {
    val &lt;- K*( pnorm(d1) - pnorm(-d1)*k - exp(-r*T)*(pnorm(d2) - pnorm(d2)*k) )
  } else if(option == 4) {
    val &lt;- K*exp(-r*T)*pnorm(d2)
  } else if(option == 5) {
    val &lt;- K*(                             pnorm(d1) - exp(-r*T)*pnorm(d2) -
              ((K/B)^(1-1/k))*((B^2)/(K^2)*pnorm(d3) - exp(-r*T)*pnorm(d4)) )
  }

  if(is.na(val)) {
    cat(sprintf("\n Exact value unknown, MLMC value: %f \n", test.res[[option]]$P[1]))
  } else {
    cat(sprintf("\n Exact value: %f, MLMC value: %f \n", val, test.res[[option]]$P[1]))
  }

  # plot results
  plot(test.res[[option]])
}


# The level sampler can be called directly to retrieve the relevant level sums:
mcqmc06_l(l = 7, N = 10, option = 1)

</code></pre>

<hr>
<h2 id='mlmc'>Multi-level Monte Carlo estimation</h2><span id='topic+mlmc'></span>

<h3>Description</h3>

<p>This function is the Multi-level Monte Carlo driver which will sample from the levels of user specified function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlmc(
  Lmin,
  Lmax,
  N0,
  eps,
  mlmc_l,
  alpha = NA,
  beta = NA,
  gamma = NA,
  parallel = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlmc_+3A_lmin">Lmin</code></td>
<td>
<p>the minimum level of refinement.  Must be <code class="reqn">\ge 2</code>.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_lmax">Lmax</code></td>
<td>
<p>the maximum level of refinement.  Must be <code class="reqn">\ge</code> <code>Lmin</code>.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_n0">N0</code></td>
<td>
<p>initial number of samples which are used for the first 3 levels and for any subsequent levels which are automatically added.
Must be <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_eps">eps</code></td>
<td>
<p>the target accuracy of the estimate (root mean square error).
Must be <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_mlmc_l">mlmc_l</code></td>
<td>
<p>a user supplied function which provides the estimate for level <code class="reqn">l</code>.
It must take at least two arguments, the first is the level number to be simulated and the second the number of paths.
Additional arguments can be taken if desired: all additional <code>...</code> arguments to this function are forwarded to the user defined <code>mlmc_l</code> function.
</p>
<p>The user supplied function should return a named list containing one element named <code>sums</code> and second named <code>cost</code>, where:
</p>

<dl>
<dt><code>sums</code></dt><dd><p>is a vector of length at least two.
The first two elements should be <code class="reqn">\left(\sum Y_i, \sum Y_i^2\right)</code> where <code class="reqn">Y_i</code> are iid simulations with expectation <code class="reqn">E[P_0]</code> when <code class="reqn">l=0</code> and expectation <code class="reqn">E[P_l-P_{l-1}]</code> when <code class="reqn">l&gt;0</code>.
Note that typically the user supplied level sampler will actually return a vector of length six, also enabling use of the <code><a href="#topic+mlmc.test">mlmc.test()</a></code> function to perform convergence tests, kurtosis, and telescoping sum checks.
See <code><a href="#topic+mlmc.test">mlmc.test()</a></code> for the definition of these remaining four elements.</p>
</dd>
<dt><code>cost</code></dt><dd><p>is a scalar with the total cost of the paths simulated.
For example, in the financial options samplers included in this package, this is calculated as <code class="reqn">NM^l</code>, where <code class="reqn">N</code> is the number of paths requested in the call to the user function <code>mlmc_l</code>, <code class="reqn">M</code> is the refinement cost factor (<code class="reqn">M=2</code> for <code><a href="#topic+mcqmc06_l">mcqmc06_l()</a></code> and <code class="reqn">M=4</code> for <code><a href="#topic+opre_l">opre_l()</a></code>), and <code class="reqn">l</code> is the level being sampled.</p>
</dd>
</dl>

<p>See the function (and source code of) <code><a href="#topic+opre_l">opre_l()</a></code> and <code><a href="#topic+mcqmc06_l">mcqmc06_l()</a></code> in this package for an example of user supplied level samplers.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_alpha">alpha</code></td>
<td>
<p>the weak error, <code class="reqn">O(2^{-\alpha l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>alpha</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_beta">beta</code></td>
<td>
<p>the variance, <code class="reqn">O(2^{-\beta l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>beta</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_gamma">gamma</code></td>
<td>
<p>the sample cost, <code class="reqn">O(2^{\gamma l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>gamma</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_parallel">parallel</code></td>
<td>
<p>if an integer is supplied, R will fork <code>parallel</code> parallel processes and spread the simulations required at each level as evenly as possible across all cores.</p>
</td></tr>
<tr><td><code id="mlmc_+3A_...">...</code></td>
<td>
<p>additional arguments which are passed on when the user supplied <code>mlmc_l</code> function is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Multilevel Monte Carlo Method method originated in the works Giles (2008) and Heinrich (1998).
</p>
<p>Consider a sequence <code class="reqn">P_0, P_1, \ldots</code>, which approximates <code class="reqn">P_L</code> with increasing accuracy, but also increasing cost, we have the simple identity
</p>
<p style="text-align: center;"><code class="reqn">E[P_L] = E[P_0] + \sum_{l=1}^L E[P_l-P_{l-1}],</code>
</p>

<p>and therefore we can use the following unbiased estimator for <code class="reqn">E[P_L]</code>,
</p>
<p style="text-align: center;"><code class="reqn">N_0^{-1} \sum_{n=1}^{N_0} P_0^{(0,n)} + \sum_{l=1}^L \left\{ N_l^{-1} \sum_{n=1}^{N_l} \left(P_l^{(l,n)} - P_{l-1}^{(l,n)}\right) \right\}</code>
</p>

<p>where <code class="reqn">N_l</code> samples are produced at level <code class="reqn">l</code>.
The inclusion of the level <code class="reqn">l</code> in the superscript <code class="reqn">(l,n)</code> indicates that the samples used at each level of correction are independent.
</p>
<p>Set <code class="reqn">C_0</code>, and <code class="reqn">V_0</code> to be the cost and variance of one sample of <code class="reqn">P_0</code>, and <code class="reqn">C_l, V_l</code> to be the cost and variance of one sample of <code class="reqn">P_l - P_{l-1}</code>, then the overall cost and variance of the multilevel estimator is <code class="reqn">\sum_{l=0}^L N_l C_l</code> and <code class="reqn">\sum_{l=0}^L N_l^{-1} V_l</code>, respectively.
</p>
<p>The idea behind the method, is that provided that the product <code class="reqn">V_l C_l</code> decreases with <code class="reqn">l</code>, i.e. the cost increases with level slower than the variance decreases, then one can achieve significant computational savings, which can be formalised as in Theorem 1 of Giles (2015).
</p>
<p>For further information on multilevel Monte Carlo methods, see the webpage <a href="https://people.maths.ox.ac.uk/gilesm/mlmc_community.html">https://people.maths.ox.ac.uk/gilesm/mlmc_community.html</a> which lists the research groups working in the area, and their main publications.
</p>
<p>This function is based on GPL-2 'Matlab' code by Mike Giles.
</p>


<h3>Value</h3>

<p>A named list containing: </p>

<dl>
<dt><code>P</code></dt><dd><p>The MLMC estimate;</p>
</dd>
<dt><code>Nl</code></dt><dd><p>A vector of the number of samples performed on each level;</p>
</dd>
<dt><code>Cl</code></dt><dd><p>Per sample cost at each level.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;
</p>
<p>Mike Giles &lt;Mike.Giles@maths.ox.ac.uk&gt;
</p>
<p>Tigran Nagapetyan &lt;nagapetyan@stats.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Giles, M.B. (2008) 'Multilevel Monte Carlo Path Simulation', <em>Operations Research</em>, 56(3), pp. 607–617. Available at: <a href="https://doi.org/10.1287/opre.1070.0496">doi:10.1287/opre.1070.0496</a>.
</p>
<p>Giles, M.B. (2015) 'Multilevel Monte Carlo methods', <em>Acta Numerica</em>, 24, pp. 259–328. Available at: <a href="https://doi.org/10.1017/S096249291500001X">doi:10.1017/S096249291500001X</a>.
</p>
<p>Heinrich, S. (1998) 'Monte Carlo Complexity of Global Solution of Integral Equations', <em>Journal of Complexity</em>, 14(2), pp. 151–175. Available at: <a href="https://doi.org/10.1006/jcom.1998.0471">doi:10.1006/jcom.1998.0471</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mlmc(2, 6, 1000, 0.01, opre_l, option = 1)

mlmc(2, 10, 1000, 0.01, mcqmc06_l, option = 1)

</code></pre>

<hr>
<h2 id='mlmc.test'>Multi-level Monte Carlo estimation test suite</h2><span id='topic+mlmc.test'></span>

<h3>Description</h3>

<p>Computes a suite of diagnostic values for an MLMC estimation problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlmc.test(
  mlmc_l,
  N,
  L,
  N0,
  eps.v,
  Lmin,
  Lmax,
  alpha = NA,
  beta = NA,
  gamma = NA,
  parallel = NA,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlmc.test_+3A_mlmc_l">mlmc_l</code></td>
<td>
<p>a user supplied function which provides the estimate for level <code class="reqn">l</code>.
It must take at least two arguments, the first is the level number to be simulated and the second the number of paths.
Additional arguments can be taken if desired: all additional <code>...</code> arguments to this function are forwarded to the user defined <code>mlmc_l</code> function.
</p>
<p>The user supplied function should return a named list containing one element named <code>sums</code> and second named <code>cost</code>, where:
</p>

<dl>
<dt><code>sums</code></dt><dd><p>is a vector of length six <code class="reqn">\left(\sum Y_i, \sum Y_i^2, \sum Y_i^3, \sum Y_i^4, \sum X_i, \sum X_i^2\right)</code> where <code class="reqn">Y_i</code> are iid simulations with expectation <code class="reqn">E[P_0]</code> when <code class="reqn">l=0</code> and expectation <code class="reqn">E[P_l-P_{l-1}]</code> when <code class="reqn">l&gt;0</code>, and <code class="reqn">X_i</code> are iid simulations with expectation <code class="reqn">E[P_l]</code>.
Note that this differs from the main <code><a href="#topic+mlmc">mlmc()</a></code> driver, which only requires the first two of these elements in order to calculate the estimate.
The remaining elements are required by <code>mlmc.test()</code> since they are used for convergence tests, kurtosis, and telescoping sum checks.</p>
</dd>
<dt><code>cost</code></dt><dd><p>is a scalar with the total cost of the paths simulated.
For example, in the financial options samplers included in this package, this is calculated as <code class="reqn">NM^l</code>, where <code class="reqn">N</code> is the number of paths requested in the call to the user function <code>mlmc_l</code>, <code class="reqn">M</code> is the refinement cost factor (<code class="reqn">M=2</code> for <code><a href="#topic+mcqmc06_l">mcqmc06_l()</a></code> and <code class="reqn">M=4</code> for <code><a href="#topic+opre_l">opre_l()</a></code>), and <code class="reqn">l</code> is the level being sampled.</p>
</dd>
</dl>

<p>See the function (and source code of) <code><a href="#topic+opre_l">opre_l()</a></code> and <code><a href="#topic+mcqmc06_l">mcqmc06_l()</a></code> in this package for an example of user supplied level samplers.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_n">N</code></td>
<td>
<p>number of samples to use in convergence tests, kurtosis, telescoping sum check.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_l">L</code></td>
<td>
<p>number of levels to use in convergence tests, kurtosis, telescoping sum check.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_n0">N0</code></td>
<td>
<p>initial number of samples which are used for the first 3 levels and for any subsequent levels which are automatically added in the complexity tests.
Must be <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_eps.v">eps.v</code></td>
<td>
<p>a vector of one or more target accuracies for the complexity tests.
Must all be <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_lmin">Lmin</code></td>
<td>
<p>the minimum level of refinement for complexity tests.
Must be <code class="reqn">\ge 2</code>.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_lmax">Lmax</code></td>
<td>
<p>the maximum level of refinement for complexity tests.
Must be <code class="reqn">\ge</code> <code>Lmin</code>.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_alpha">alpha</code></td>
<td>
<p>the weak error, <code class="reqn">O(2^{-\alpha l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>alpha</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_beta">beta</code></td>
<td>
<p>the variance, <code class="reqn">O(2^{-\beta l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>beta</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_gamma">gamma</code></td>
<td>
<p>the sample cost, <code class="reqn">O(2^{\gamma l})</code>.
Must be <code class="reqn">&gt; 0</code> if specified.
If <code>NA</code> then <code>gamma</code> will be estimated.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_parallel">parallel</code></td>
<td>
<p>if an integer is supplied, R will fork <code>parallel</code> parallel processes.
This is done for the convergence tests section by splitting the <code>N</code> samples as evenly as possible across cores when sampling each level.
This is also done for the MLMC complexity tests by passing the <code>parallel</code> argument on to the <code><a href="#topic+mlmc">mlmc()</a></code> driver when targeting each accuracy level in <code>eps</code>.</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_silent">silent</code></td>
<td>
<p>set to TRUE to supress running output (identical output can still be printed by printing the return result)</p>
</td></tr>
<tr><td><code id="mlmc.test_+3A_...">...</code></td>
<td>
<p>additional arguments which are passed on when the user supplied <code>mlmc_l</code> function is called</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See one of the example level sampler functions (e.g. <code><a href="#topic+opre_l">opre_l()</a></code>) for example usage.
</p>
<p>This function is based on GPL-2 'Matlab' code by Mike Giles.
</p>


<h3>Value</h3>

<p>An <code>mlmc.test</code> object which contains all the computed diagnostic values.
This object can be printed or plotted (see <code><a href="#topic+plot.mlmc.test">plot.mlmc.test</a></code>).
</p>


<h3>Author(s)</h3>

<p>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;
</p>
<p>Mike Giles &lt;Mike.Giles@maths.ox.ac.uk&gt;
</p>
<p>Tigran Nagapetyan &lt;nagapetyan@stats.ox.ac.uk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example calls with realistic arguments
# Financial options using an Euler-Maruyama discretisation
tst &lt;- mlmc.test(opre_l, N = 2000000,
                 L = 5, N0 = 1000,
                 eps.v = c(0.005, 0.01, 0.02, 0.05, 0.1),
                 Lmin = 2, Lmax = 6,
                 option = 1)
tst
plot(tst)

# Financial options using a Milstein discretisation
tst &lt;- mlmc.test(mcqmc06_l, N = 20000,
                 L = 8, N0 = 200,
                 eps.v = c(0.005, 0.01, 0.02, 0.05, 0.1),
                 Lmin = 2, Lmax = 10,
                 option = 1)
tst
plot(tst)


# Toy versions for CRAN tests
tst &lt;- mlmc.test(opre_l, N = 10000,
                 L = 5, N0 = 1000,
                 eps.v = c(0.025, 0.1),
                 Lmin = 2, Lmax = 6,
                 option = 1)

tst &lt;- mlmc.test(mcqmc06_l, N = 10000,
                 L = 8, N0 = 1000,
                 eps.v = c(0.025, 0.1),
                 Lmin = 2, Lmax = 10,
                 option = 1)

</code></pre>

<hr>
<h2 id='opre_l'>Financial options using an Euler-Maruyama discretisation</h2><span id='topic+opre_l'></span>

<h3>Description</h3>

<p>Financial options based on scalar geometric Brownian motion and Heston models, similar to Mike Giles' original 2008 Operations Research paper, Giles (2008), using an Euler-Maruyama discretisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opre_l(l, N, option)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opre_l_+3A_l">l</code></td>
<td>
<p>the level to be simulated.</p>
</td></tr>
<tr><td><code id="opre_l_+3A_n">N</code></td>
<td>
<p>the number of samples to be computed.</p>
</td></tr>
<tr><td><code id="opre_l_+3A_option">option</code></td>
<td>
<p>the option type, between 1 and 5.
The options are:
</p>

<dl>
<dt>1 = European call;</dt><dd></dd>
<dt>2 = Asian call;</dt><dd></dd>
<dt>3 = lookback call;</dt><dd></dd>
<dt>4 = digital call;</dt><dd></dd>
<dt>5 = Heston model.</dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on GPL-2 'Matlab' code by Mike Giles.
</p>


<h3>Value</h3>

<p>A named list containing: </p>

<dl>
<dt><code>sums</code></dt><dd><p>is a vector of length six <code class="reqn">\left(\sum Y_i, \sum Y_i^2, \sum Y_i^3, \sum Y_i^4, \sum X_i, \sum X_i^2\right)</code> where <code class="reqn">Y_i</code> are iid simulations with expectation <code class="reqn">E[P_0]</code> when <code class="reqn">l=0</code> and expectation <code class="reqn">E[P_l-P_{l-1}]</code> when <code class="reqn">l&gt;0</code>, and <code class="reqn">X_i</code> are iid simulations with expectation <code class="reqn">E[P_l]</code>.
Note that only the first two components of this are used by the main <code><a href="#topic+mlmc">mlmc()</a></code> driver, the full vector is used by <code><a href="#topic+mlmc.test">mlmc.test()</a></code> for convergence tests etc;</p>
</dd>
<dt><code>cost</code></dt><dd><p>is a scalar with the total cost of the paths simulated, computed as <code class="reqn">N \times 4^l</code> for level <code class="reqn">l</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;
</p>
<p>Mike Giles &lt;Mike.Giles@maths.ox.ac.uk&gt;
</p>
<p>Tigran Nagapetyan &lt;nagapetyan@stats.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Giles, M.B. (2008) 'Multilevel Monte Carlo Path Simulation', <em>Operations Research</em>, 56(3), pp. 607–617. Available at: <a href="https://doi.org/10.1287/opre.1070.0496">doi:10.1287/opre.1070.0496</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# These are similar to the MLMC tests for the original
# 2008 Operations Research paper, using an Euler-Maruyama
# discretisation with 4^l timesteps on level l.
#
# The differences are:
# -- the plots do not have the extrapolation results
# -- two plots are log_2 rather than log_4
# -- the new MLMC driver is a little different
# -- switch to X_0=100 instead of X_0=1
#
# Note the following takes quite a while to run, for a toy example see after
# this block.

N0   &lt;- 1000 # initial samples on coarse levels
Lmin &lt;- 2 # minimum refinement level
Lmax &lt;- 6 # maximum refinement level

test.res &lt;- list()
for(option in 1:5) {
  if(option == 1) {
    cat("\n ---- Computing European call ---- \n")
    N      &lt;- 1000000 # samples for convergence tests
    L      &lt;- 5 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  } else if(option == 2) {
    cat("\n ---- Computing Asian call ---- \n")
    N      &lt;- 1000000 # samples for convergence tests
    L      &lt;- 5 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  } else if(option == 3) {
    cat("\n ---- Computing lookback call ---- \n")
    N      &lt;- 1000000 # samples for convergence tests
    L      &lt;- 5 # levels for convergence tests
    Eps    &lt;- c(0.01, 0.02, 0.05, 0.1, 0.2)
  } else if(option == 4) {
    cat("\n ---- Computing digital call ---- \n")
    N      &lt;- 4000000 # samples for convergence tests
    L      &lt;- 5 # levels for convergence tests
    Eps    &lt;- c(0.02, 0.05, 0.1, 0.2, 0.5)
  } else if(option == 5) {
    cat("\n ---- Computing Heston model ---- \n")
    N      &lt;- 2000000 # samples for convergence tests
    L      &lt;- 5 # levels for convergence tests
    Eps    &lt;- c(0.005, 0.01, 0.02, 0.05, 0.1)
  }

  test.res[[option]] &lt;- mlmc.test(opre_l, N, L, N0, Eps, Lmin, Lmax, option = option)

  # print exact analytic value, based on S0=K
  T   &lt;- 1
  r   &lt;- 0.05
  sig &lt;- 0.2
  K   &lt;- 100

  k   &lt;- 0.5*sig^2/r;
  d1  &lt;- (r+0.5*sig^2)*T / (sig*sqrt(T))
  d2  &lt;- (r-0.5*sig^2)*T / (sig*sqrt(T))

  if(option == 1) {
    val &lt;- K*( pnorm(d1) - exp(-r*T)*pnorm(d2) )
  } else if(option == 2) {
    val &lt;- NA
  } else if(option == 3) {
    val &lt;- K*( pnorm(d1) - pnorm(-d1)*k - exp(-r*T)*(pnorm(d2) - pnorm(d2)*k) )
  } else if(option == 4) {
    val &lt;- K*exp(-r*T)*pnorm(d2)
  } else if(option == 5) {
    val &lt;- NA
  }

  if(is.na(val)) {
    cat(sprintf("\n Exact value unknown, MLMC value: %f \n", test.res[[option]]$P[1]))
  } else {
    cat(sprintf("\n Exact value: %f, MLMC value: %f \n", val, test.res[[option]]$P[1]))
  }

  # plot results
  plot(test.res[[option]])
}


# The level sampler can be called directly to retrieve the relevant level sums:
opre_l(l = 7, N = 10, option = 1)

</code></pre>

<hr>
<h2 id='plot.mlmc.test'>Plot an <code>mlmc.test</code> object</h2><span id='topic+plot.mlmc.test'></span>

<h3>Description</h3>

<p>Produces diagnostic plots on the result of an <code><a href="#topic+mlmc.test">mlmc.test</a></code> function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlmc.test'
plot(x, which = "all", cols = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mlmc.test_+3A_x">x</code></td>
<td>
<p>an <code>mlmc.test</code> object as produced by a call to the <code><a href="#topic+mlmc.test">mlmc.test</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.mlmc.test_+3A_which">which</code></td>
<td>
<p>a vector of strings specifying which plots to produce, or <code>"all"</code> to do all diagnostic plots
The options are: </p>

<dl>
<dt><code>"var"</code> = <code class="reqn">\log_2</code> of variance against level;</dt><dd></dd>
<dt><code>"mean"</code> = <code class="reqn">\log_2</code> of the absolute value of the mean against level;</dt><dd></dd>
<dt><code>"consis"</code> = consistency against level;</dt><dd></dd>
<dt><code>"kurt"</code> = kurtosis against level;</dt><dd></dd>
<dt><code>"Nl"</code> = <code class="reqn">\log_2</code> of number of samples against level;</dt><dd></dd>
<dt><code>"cost"</code> = <code class="reqn">\log_{10}</code> of cost against <code class="reqn">\log_{10}</code> of epsilon (accuracy).</dt><dd></dd>
</dl>
</td></tr>
<tr><td><code id="plot.mlmc.test_+3A_cols">cols</code></td>
<td>
<p>the number of columns across to plot to override the default value.</p>
</td></tr>
<tr><td><code id="plot.mlmc.test_+3A_...">...</code></td>
<td>
<p>additional arguments which are passed on to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the plots produced are relatively self-explanatory.
However, the consistency and kurtosis plots in particular may require some background.
It is highly recommended to refer to Section 3.3 of Giles (2015), where the rationale for these diagnostic plots is addressed in full detail.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;
</p>


<h3>References</h3>

<p>Giles, M.B. (2015) 'Multilevel Monte Carlo methods', <em>Acta Numerica</em>, 24, pp. 259–328. Available at: <a href="https://doi.org/10.1017/S096249291500001X">doi:10.1017/S096249291500001X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tst &lt;- mlmc.test(opre_l, N = 2000000,
                 L = 5, N0 = 1000,
                 eps.v = c(0.005, 0.01, 0.02, 0.05, 0.1),
                 Lmin = 2, Lmax = 6,
                 option = 1)
tst
plot(tst)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
