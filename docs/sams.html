<!DOCTYPE html><html lang="en"><head><title>Help for package sams</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sams}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asCanonical'><p>Coerce a Vector of Cluster Labels to Canonical Form</p></a></li>
<li><a href='#asClusterLabels'><p>Coerce a Set Partition in List Structure to Numeric Vectors of Cluster Label</p></a></li>
<li><a href='#asSetPartition'><p>Coerce a Set Partition as Numeric Vectors of Cluster Labels to a List</p>
Structure</a></li>
<li><a href='#clusterProportions'><p>Compute the Proportion of Items in Each Cluster for All Partitions</p></a></li>
<li><a href='#clusterTrace'><p>Plot Traces of Cluster Sizes</p></a></li>
<li><a href='#clusterWithItem'><p>Identify Which Cluster Contains a Given Item</p></a></li>
<li><a href='#createNewCluster'><p>Create a New Cluster with Given Item</p></a></li>
<li><a href='#dCRP'><p>Compute Probability Mass of a Partition Under the Two Parameter Chinese</p>
Restaurant Process (CRP)</a></li>
<li><a href='#getThetas'><p>Get theta Parameters from a Numeric Vector of Cluster Labels and Unique phi</p>
Values</a></li>
<li><a href='#isCanonical'><p>Check if a Vector of Cluster Labels is in Canonical Form</p></a></li>
<li><a href='#joinExistingCluster'><p>Join Item to an Existing Cluster</p></a></li>
<li><a href='#nClusters'><p>Count the Number of Clusters in a Set Partition</p></a></li>
<li><a href='#nealAlgorithm3'><p>Conjugate Gibbs Sampler for a Partition</p></a></li>
<li><a href='#p18_bern'><p>Multivariate Independent Bernoulli Data (p = 18)</p></a></li>
<li><a href='#p18_corr_mvn'><p>Correlated Multivariate Normal Data (p = 18)</p></a></li>
<li><a href='#p18_mvn'><p>Independent Multivariate Normal Data (p = 18)</p></a></li>
<li><a href='#p6_bern'><p>Multivariate Independent Bernoulli Data (p = 6)</p></a></li>
<li><a href='#p6_big_bern'><p>Large Sample Multivariate Independent Bernoulli Data (p = 6)</p></a></li>
<li><a href='#p6_mvn'><p>Independent Multivariate Normal Data (p = 6)</p></a></li>
<li><a href='#partitionEntropy'><p>Calculate the Entropy of a Set Partition</p></a></li>
<li><a href='#poch'><p>Compute the Pochhammer Symbol (Rising Factorials) With Increment</p></a></li>
<li><a href='#psm'><p>Compute the Posterior Pairwise Similarity for All Pairs of Items</p></a></li>
<li><a href='#psmMergeSplit'><p>Merge-Split Sampling for a Partition Based on Sequential Allocation Informed</p>
by Pairwise Similarities</a></li>
<li><a href='#psmMergeSplit_base'><p>Base Functionality for the psmMergeSplit Function</p></a></li>
<li><a href='#restrictedGibbsMergeSplit'><p>Merge-Split Sampling for a Partition Based on Restricted Gibbs Scans</p></a></li>
<li><a href='#seqAllocatedMergeSplit'><p>Merge-split Sampling for a Partition Based on Sequential Allocation of Items</p></a></li>
<li><a href='#seqAllocatedMergeSplit_base'><p>Base Functionality for the seqAllocatedMergeSplit Function</p></a></li>
<li><a href='#simpleMergeSplit'><p>Merge-Split Sampling for a Partition Using Uniformly Random Allocation</p></a></li>
<li><a href='#sizeOfLargestCluster'><p>Calculate the Number of Items in the Largest Cluster of a Set Partition</p></a></li>
<li><a href='#transformedWeights'><p>Enumerate Transformed Weights for Choosing i and j Non-Uniformly</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Merge-Split Samplers for Conjugate Bayesian Nonparametric Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Markov chain Monte Carlo samplers for posterior simulations of conjugate Bayesian nonparametric
    mixture models. Functionality is provided for Gibbs sampling as in Algorithm 3 of Neal (2000)
    &lt;<a href="https://doi.org/10.1080%2F10618600.2000.10474879">doi:10.1080/10618600.2000.10474879</a>&gt;, restricted Gibbs merge-split sampling as described in Jain &amp; Neal
    (2004) &lt;<a href="https://doi.org/10.1198%2F1061860043001">doi:10.1198/1061860043001</a>&gt;, and sequentially-allocated merge-split sampling &lt;<a href="https://doi.org/10.1080%2F00949655.2021.1998502">doi:10.1080/00949655.2021.1998502</a>&gt;, as well as
    summary and utility functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-19 18:46:11 UTC; dahl</td>
</tr>
<tr>
<td>Author:</td>
<td>Spencer Newcomb [aut],
  David B. Dahl <a href="https://orcid.org/0000-0002-8173-1547"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David B. Dahl &lt;dahl@stat.byu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asCanonical'>Coerce a Vector of Cluster Labels to Canonical Form</h2><span id='topic+asCanonical'></span>

<h3>Description</h3>

<p>Coerce a Vector of Cluster Labels to Canonical Form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asCanonical(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asCanonical_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a set partition of the
integers <code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing <code>partition</code>, but now in canonical
form.
</p>

<hr>
<h2 id='asClusterLabels'>Coerce a Set Partition in List Structure to Numeric Vectors of Cluster Label</h2><span id='topic+asClusterLabels'></span>

<h3>Description</h3>

<p>Coerce a Set Partition in List Structure to Numeric Vectors of Cluster Label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asClusterLabels(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asClusterLabels_+3A_partition">partition</code></td>
<td>
<p>A list representing a set partition of the integers <code class="reqn">1</code>,
..., <code class="reqn">n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the set partition using cluster labels.
</p>

<hr>
<h2 id='asSetPartition'>Coerce a Set Partition as Numeric Vectors of Cluster Labels to a List
Structure</h2><span id='topic+asSetPartition'></span>

<h3>Description</h3>

<p>Coerce a Set Partition as Numeric Vectors of Cluster Labels to a List
Structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSetPartition(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asSetPartition_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The set partition in a list structure.
</p>

<hr>
<h2 id='clusterProportions'>Compute the Proportion of Items in Each Cluster for All Partitions</h2><span id='topic+clusterProportions'></span>

<h3>Description</h3>

<p>Compute the Proportion of Items in Each Cluster for All Partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterProportions(partitions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterProportions_+3A_partitions">partitions</code></td>
<td>
<p>A matrix, with each row representing a set partition of the
integers <code class="reqn">1</code>, ..., <code class="reqn">n</code> as cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose columns represent the cumulative proportion of the
data that correspond to that cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 500L
partitions &lt;- matrix(0, nrow=nSamples, ncol=length(nealData))
for ( i in 2:nSamples ) {
  partitions[i,] &lt;- nealAlgorithm3(partitions[i-1,], logPostPredict, mass = 1.0, nUpdates = 2)
}
clusterProportions(partitions)
</code></pre>

<hr>
<h2 id='clusterTrace'>Plot Traces of Cluster Sizes</h2><span id='topic+clusterTrace'></span>

<h3>Description</h3>

<p>Plot Traces of Cluster Sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTrace(
  partitions,
  plot.cols = rep("black", ncol(partitions)),
  plot.title = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterTrace_+3A_partitions">partitions</code></td>
<td>
<p>A matrix, with each row a numeric vector cluster labels</p>
</td></tr>
<tr><td><code id="clusterTrace_+3A_plot.cols">plot.cols</code></td>
<td>
<p>A character vector of valid color names, whose length
represents the maximum number of stacked traces to be plotted</p>
</td></tr>
<tr><td><code id="clusterTrace_+3A_plot.title">plot.title</code></td>
<td>
<p>A character string to be used as the main title on the
trace plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 500L
partitions &lt;- matrix(0, nrow=nSamples, ncol=length(nealData))
for ( i in 2:nSamples ) {
  partitions[i,] &lt;- nealAlgorithm3(partitions[i-1,], logPostPredict, mass = 1.0, nUpdates = 2)
}

clusterTrace(partitions, plot.title = "Neal (2000) Data")
</code></pre>

<hr>
<h2 id='clusterWithItem'>Identify Which Cluster Contains a Given Item</h2><span id='topic+clusterWithItem'></span>

<h3>Description</h3>

<p>Identify Which Cluster Contains a Given Item
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterWithItem(i, partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterWithItem_+3A_i">i</code></td>
<td>
<p>Item index as an integer vector of length one</p>
</td></tr>
<tr><td><code id="clusterWithItem_+3A_partition">partition</code></td>
<td>
<p>Set partition of the integers <code class="reqn">1</code>, ..., <code class="reqn">n</code>
represented as either a numeric vector of cluster labels, or a list
containing subsets of these integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of </p>
 <dl>
<dt>which</dt><dd><p>An integer representing
which cluster <code>i</code> belongs to</p>
</dd> <dt>cluster</dt><dd><p>The subset of indices
that correspond to the same cluster as <code>i</code></p>
</dd> </dl>


<hr>
<h2 id='createNewCluster'>Create a New Cluster with Given Item</h2><span id='topic+createNewCluster'></span>

<h3>Description</h3>

<p>Create a New Cluster with Given Item
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNewCluster(i, partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createNewCluster_+3A_i">i</code></td>
<td>
<p>Item index as an integer vector of length one</p>
</td></tr>
<tr><td><code id="createNewCluster_+3A_partition">partition</code></td>
<td>
<p>Set partition of the integers <code class="reqn">1</code>, ..., <code class="reqn">n</code>
represented as either a numeric vector of cluster labels, or a list
containing subsets of these integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated partition with a new cluster.
</p>

<hr>
<h2 id='dCRP'>Compute Probability Mass of a Partition Under the Two Parameter Chinese
Restaurant Process (CRP)</h2><span id='topic+dCRP'></span>

<h3>Description</h3>

<p>Compute Probability Mass of a Partition Under the Two Parameter Chinese
Restaurant Process (CRP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCRP(partition, mass = 1, discount = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dCRP_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels, or a matrix whose rows
are numeric vectors of cluster labels</p>
</td></tr>
<tr><td><code id="dCRP_+3A_mass">mass</code></td>
<td>
<p>A numeric value indicating the mass parameter in the CRP, which
must be greater than the <code>-discount</code> argument</p>
</td></tr>
<tr><td><code id="dCRP_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1), indicating the
discount parameter of the two parameter CRP</p>
</td></tr>
<tr><td><code id="dCRP_+3A_log">log</code></td>
<td>
<p>A logical value indicating whether results should be returned on
the log scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of probabilities, or log probabilities if <code>log
  = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
partitions &lt;- matrix(c(0,0,0,0,0,
                       0,0,0,0,1,
                       0,0,0,1,2,
                       0,0,1,2,3,
                       0,1,2,3,4), ncol = 5, nrow = 5, byrow = TRUE)

# discount = 0 shows higher probability for lower quantity of components
dCRP(partitions, mass = 1, discount = 0, log = FALSE)

# discount = 0.5 shows higher probability for higher quantity of components
dCRP(partitions, mass = 1, discount = 0.5, log = FALSE)
</code></pre>

<hr>
<h2 id='getThetas'>Get theta Parameters from a Numeric Vector of Cluster Labels and Unique phi
Values</h2><span id='topic+getThetas'></span>

<h3>Description</h3>

<p>Get theta Parameters from a Numeric Vector of Cluster Labels and Unique phi
Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getThetas(partition, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getThetas_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
<tr><td><code id="getThetas_+3A_phi">phi</code></td>
<td>
<p>A list of unique model parameters whose length must equal the
number of unique cluster labels in <code>partition</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of model parameters <code class="reqn">theta_1</code>, ...,
<code class="reqn">theta_n</code>.
</p>

<hr>
<h2 id='isCanonical'>Check if a Vector of Cluster Labels is in Canonical Form</h2><span id='topic+isCanonical'></span>

<h3>Description</h3>

<p>Check if a Vector of Cluster Labels is in Canonical Form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCanonical(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isCanonical_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, indicating whether <code>partition</code> is in canonical form.
</p>

<hr>
<h2 id='joinExistingCluster'>Join Item to an Existing Cluster</h2><span id='topic+joinExistingCluster'></span>

<h3>Description</h3>

<p>Join Item to an Existing Cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinExistingCluster(i, join, partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joinExistingCluster_+3A_i">i</code></td>
<td>
<p>Item index as an integer vector of length one</p>
</td></tr>
<tr><td><code id="joinExistingCluster_+3A_join">join</code></td>
<td>
<p>Label or index of cluster that <code>i</code> must join</p>
</td></tr>
<tr><td><code id="joinExistingCluster_+3A_partition">partition</code></td>
<td>
<p>Set partition of the integers <code class="reqn">1</code>, ..., <code class="reqn">n</code>
represented as either a numeric vector of cluster labels, or a list
containing subsets of these integers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated partition.
</p>

<hr>
<h2 id='nClusters'>Count the Number of Clusters in a Set Partition</h2><span id='topic+nClusters'></span>

<h3>Description</h3>

<p>Count the Number of Clusters in a Set Partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nClusters(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nClusters_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of clusters in the given set partition as a numeric vector
of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- c(0,1,1,2,3,2,4,4,2)
nClusters(p)
</code></pre>

<hr>
<h2 id='nealAlgorithm3'>Conjugate Gibbs Sampler for a Partition</h2><span id='topic+nealAlgorithm3'></span>

<h3>Description</h3>

<p>Algorithm 3 from Neal (2000) to update the state of a partition based on the
&quot;Chinese Restaurant Process&quot; (CRP) prior and a user-supplied log posterior
predictive density function, with additional functionality for the two
parameter CRP prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nealAlgorithm3(
  partition,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  mass = 1,
  discount = 0,
  nUpdates = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nealAlgorithm3_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="nealAlgorithm3_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="nealAlgorithm3_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="nealAlgorithm3_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two parameter CRP prior.  Set to zero for the
usual, one parameter CRP prior.</p>
</td></tr>
<tr><td><code id="nealAlgorithm3_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of Gibbs scans before returning.
This has the effect of thinning the Markov chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the updated partition encoded using cluster
labels.
</p>


<h3>References</h3>

<p>Neal, R. M. (2000). Markov chain sampling methods for Dirichlet
process mixture models. <em>Journal of computational and graphical
statistics</em>, 9(2), 249-265.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 1000L
partitions &lt;- matrix(0, nrow = nSamples, ncol = length(nealData))
for (i in 2:nSamples) {
  partitions[i,] &lt;- nealAlgorithm3(partitions[i-1,], logPostPredict, mass = 1.0, nUpdates = 1)
}

# convergence and mixing diagnostics
nSubsets &lt;- apply(partitions, 1, function(x) length(unique(x)))
mean(nSubsets)
sum(acf(nSubsets)$acf) - 1   # Autocorrelation time

entropy &lt;- apply(partitions, 1, partitionEntropy)
plot.ts(entropy)

</code></pre>

<hr>
<h2 id='p18_bern'>Multivariate Independent Bernoulli Data (p = 18)</h2><span id='topic+p18_bern'></span><span id='topic+p18_bern_1'></span><span id='topic+p18_bern_2'></span><span id='topic+p18_bern_3'></span>

<h3>Description</h3>

<p>Multivariate categorical data, generated as five clusters of independent variables with different
success probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p18_bern_1

p18_bern_2

p18_bern_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 18 columns.
</p>
<p>An object of class <code>data.frame</code> with 100 rows and 18 columns.
</p>
<p>An object of class <code>data.frame</code> with 100 rows and 18 columns.
</p>

<hr>
<h2 id='p18_corr_mvn'>Correlated Multivariate Normal Data (p = 18)</h2><span id='topic+p18_corr_mvn'></span><span id='topic+p18_corr_mvn_1'></span><span id='topic+p18_corr_mvn_2'></span><span id='topic+p18_corr_mvn_3'></span>

<h3>Description</h3>

<p>Multivariate continuous data, generated as five clusters with an AR(1) correlation structure
determining the common covariance matrix for each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p18_corr_mvn_1

p18_corr_mvn_2

p18_corr_mvn_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>

<hr>
<h2 id='p18_mvn'>Independent Multivariate Normal Data (p = 18)</h2><span id='topic+p18_mvn'></span><span id='topic+p18_mvn_1'></span><span id='topic+p18_mvn_2'></span><span id='topic+p18_mvn_3'></span>

<h3>Description</h3>

<p>Multivariate continuous data, generated as five clusters of independent variables with different
means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p18_mvn_1

p18_mvn_2

p18_mvn_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 18 columns.
</p>

<hr>
<h2 id='p6_bern'>Multivariate Independent Bernoulli Data (p = 6)</h2><span id='topic+p6_bern'></span><span id='topic+p6_bern_1'></span><span id='topic+p6_bern_2'></span><span id='topic+p6_bern_3'></span>

<h3>Description</h3>

<p>Multivariate categorical data, generated as five clusters of independent variables with different
success probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p6_bern_1

p6_bern_2

p6_bern_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 6 columns.
</p>
<p>An object of class <code>data.frame</code> with 100 rows and 6 columns.
</p>
<p>An object of class <code>data.frame</code> with 100 rows and 6 columns.
</p>

<hr>
<h2 id='p6_big_bern'>Large Sample Multivariate Independent Bernoulli Data (p = 6)</h2><span id='topic+p6_big_bern'></span><span id='topic+p6_big_bern_1'></span><span id='topic+p6_big_bern_2'></span><span id='topic+p6_big_bern_3'></span>

<h3>Description</h3>

<p>Multivariate categorical data, generated as five clusters of independent variables with different
success probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p6_big_bern_1

p6_big_bern_2

p6_big_bern_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1000 rows and 6 columns.
</p>
<p>An object of class <code>data.frame</code> with 1000 rows and 6 columns.
</p>
<p>An object of class <code>data.frame</code> with 1000 rows and 6 columns.
</p>

<hr>
<h2 id='p6_mvn'>Independent Multivariate Normal Data (p = 6)</h2><span id='topic+p6_mvn'></span><span id='topic+p6_mvn_1'></span><span id='topic+p6_mvn_2'></span><span id='topic+p6_mvn_3'></span>

<h3>Description</h3>

<p>Multivariate continuous data, generated as five clusters of independent variables with different
means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p6_mvn_1

p6_mvn_2

p6_mvn_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 6 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 6 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 6 columns.
</p>

<hr>
<h2 id='partitionEntropy'>Calculate the Entropy of a Set Partition</h2><span id='topic+partitionEntropy'></span>

<h3>Description</h3>

<p>Calculate the Entropy of a Set Partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitionEntropy(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partitionEntropy_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculated partition entropy as a numeric vector of length one
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- c(0,0,0,1,1,2) # n = 6, 3 unique clusters
partitionEntropy(p)
</code></pre>

<hr>
<h2 id='poch'>Compute the Pochhammer Symbol (Rising Factorials) With Increment</h2><span id='topic+poch'></span>

<h3>Description</h3>

<p>Compute the Pochhammer Symbol (Rising Factorials) With Increment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poch(x, y = NULL, n = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poch_+3A_x">x</code></td>
<td>
<p>Non-negative numeric value</p>
</td></tr>
<tr><td><code id="poch_+3A_y">y</code></td>
<td>
<p>Non-negative real value representing increment parameter for
Pochhammer function. If <code>NULL</code>, there is no increment (i.e.
<code>y=1</code>).</p>
</td></tr>
<tr><td><code id="poch_+3A_n">n</code></td>
<td>
<p>Non-negative integer representing subscript in Pochhammer symbol</p>
</td></tr>
<tr><td><code id="poch_+3A_log">log</code></td>
<td>
<p>Logical value indicating whether to return results on log scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the result of Pochhammer function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># effect of increment parameter
poch(5, y = NULL, n = 3, log = FALSE)
poch(5, y = 1, n = 3, log = FALSE)
poch(5, y = 1:4, n = 3, log = FALSE)

# increment being NULL is equivalent to ratio of gamma functions
a &lt;- 7
b &lt;- 3
out1 &lt;- poch(a, y = NULL, n = b, log = FALSE)
out2 &lt;- gamma(a + b) / gamma(a)

</code></pre>

<hr>
<h2 id='psm'>Compute the Posterior Pairwise Similarity for All Pairs of Items</h2><span id='topic+psm'></span>

<h3>Description</h3>

<p>Compute the Posterior Pairwise Similarity for All Pairs of Items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psm(partitions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psm_+3A_partitions">partitions</code></td>
<td>
<p>A matrix, with each row a numeric vector cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix of pairwise similarities based on the partitions
given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 500L
partitions &lt;- matrix(0, nrow=nSamples, ncol=length(nealData))
for ( i in 2:nSamples ) {
  partitions[i,] &lt;- nealAlgorithm3(partitions[i-1,], logPostPredict, mass = 1.0, nUpdates = 2)
}

psm(partitions)
</code></pre>

<hr>
<h2 id='psmMergeSplit'>Merge-Split Sampling for a Partition Based on Sequential Allocation Informed
by Pairwise Similarities</h2><span id='topic+psmMergeSplit'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using sequentially-allocated elements. Allocation is performed
with weights derived from a previously-calculated pairwise similarity matrix,
and optionally complemented with &quot;restricted Gibbs&quot; scans as discussed in
Jain &amp; Neal (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psmMergeSplit(
  partition,
  psm,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  t = 1,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psmMergeSplit_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_psm">psm</code></td>
<td>
<p>A matrix of previously-calculated pairwise similarity
probabilities for each pair of data indices.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_t">t</code></td>
<td>
<p>A non-negative integer indicating the number of restricted Gibbs
scans to perform for each merge/split proposal.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two-parameter CRP prior.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>A numeric vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number of accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>References</h3>

<p>Jain, S., &amp; Neal, R. M. (2004). A split-merge Markov chain Monte
Carlo procedure for the Dirichlet process mixture model. <em>Journal of
computational and Graphical Statistics</em>, 13(1), 158-182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 1100L
nBurn &lt;- 100
partitions &lt;- matrix(0, nrow=nSamples, ncol=length(nealData))

# initial draws to inform similarity matrix
for ( i in 2:nBurn ) {
  partitions[i,] &lt;- nealAlgorithm3(partitions[i-1,],
                                   logPostPredict,
                                   mass = 1,
                                   nUpdates = 1)
}

# Generate pairwise similarity matrix from initial draws
psm.mat &lt;- psm(partitions[1:nBurn,])

accept &lt;- 0
for ( i in (nBurn+1):nSamples ) {
  ms &lt;- psmMergeSplit(partitions[i-1,],
                      psm.mat,
                      logPostPredict,
                      t = 1,
                      mass = 1.0,
                      nUpdates = 1)
  partitions[i,] &lt;- ms$partition
  accept &lt;- accept + ms$accept
}

accept / (nSamples - nBurn) # post burn-in M-H acceptance rate
nSubsets &lt;- apply(partitions, 1, function(x) length(unique(x)))
mean(nSubsets)
sum(acf(nSubsets)$acf)-1   # Autocorrelation time

entropy &lt;- apply(partitions, 1, partitionEntropy)
plot.ts(entropy)

</code></pre>

<hr>
<h2 id='psmMergeSplit_base'>Base Functionality for the psmMergeSplit Function</h2><span id='topic+psmMergeSplit_base'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using sequentially-allocated elements. Allocation is performed
with weights derived from a previously-calculated pairwise similarity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psmMergeSplit_base(
  partition,
  psm,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psmMergeSplit_base_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_psm">psm</code></td>
<td>
<p>A matrix of previously-calculated pairwise similarity
probabilities for each pair of data indices.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two-parameter CRP prior.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="psmMergeSplit_base_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>A numeric vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number of accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="#topic+psmMergeSplit">psmMergeSplit</a></code>
</p>

<hr>
<h2 id='restrictedGibbsMergeSplit'>Merge-Split Sampling for a Partition Based on Restricted Gibbs Scans</h2><span id='topic+restrictedGibbsMergeSplit'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using restricted Gibbs scans from a uniformly random launch
state, as presented in Jain &amp; Neal (2004), with additional functionality for
the two parameter CRP prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrictedGibbsMergeSplit(
  partition,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  t = 1,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="restrictedGibbsMergeSplit_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_t">t</code></td>
<td>
<p>A non-negative integer indicating the number of restricted Gibbs
scans to perform for each merge/split proposal.</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two parameter CRP prior.</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="restrictedGibbsMergeSplit_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>An integer vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>References</h3>

<p>Jain, S., &amp; Neal, R. M. (2004). A split-merge Markov chain Monte
Carlo procedure for the Dirichlet process mixture model. <em>Journal of
computational and Graphical Statistics</em>, 13(1), 158-182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log = TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 1000L
partitions &lt;- matrix(0, nrow = nSamples, ncol = length(nealData))
accept &lt;- 0
for ( i in 2:nSamples ) {
  ms &lt;- restrictedGibbsMergeSplit(partitions[i-1,],
                                  logPostPredict,
                                  t = 1,
                                  mass = 1.0,
                                  nUpdates = 2)
  partitions[i,] &lt;- ms$partition
  accept &lt;- accept + ms$accept
}

accept / nSamples # M-H acceptance rate

# convergence and mixing diagnostics
nSubsets &lt;- apply(partitions, 1, function(x) length(unique(x)))
mean(nSubsets)
sum(acf(nSubsets)$acf)-1   # Autocorrelation time

entropy &lt;- apply(partitions, 1, partitionEntropy)
plot.ts(entropy)

</code></pre>

<hr>
<h2 id='seqAllocatedMergeSplit'>Merge-split Sampling for a Partition Based on Sequential Allocation of Items</h2><span id='topic+seqAllocatedMergeSplit'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using sequential allocation of items, as originally described
in Dahl (2003), with additional functionality for the two parameter CRP
prior, as well as complementing these allocations with restricted Gibbs scans
such as those discussed in Jain &amp; Neal (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqAllocatedMergeSplit(
  partition,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  t = 1,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqAllocatedMergeSplit_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_t">t</code></td>
<td>
<p>A non-negative integer indicating the number of restricted Gibbs
scans to perform for each merge/split proposal.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two parameter CRP prior.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>An integer vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>References</h3>

<p>Dahl, D. B. (2003). An improved merge-split sampler for conjugate
Dirichlet process mixture models. Technical Report, 1, 086. Jain, S., &amp; Neal,
R. M. (2004). A split-merge Markov chain Monte Carlo procedure for the
Dirichlet process mixture model. <em>Journal of computational and Graphical
Statistics</em>, 13(1), 158-182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Neal (2000) model and data
nealData &lt;- c(-1.48, -1.40, -1.16, -1.08, -1.02, 0.14, 0.51, 0.53, 0.78)
mkLogPosteriorPredictiveDensity &lt;- function(data = nealData,
                                            sigma2 = 0.1^2,
                                            mu0 = 0,
                                            sigma02 = 1) {
  function(i, subset) {
    posteriorVariance &lt;- 1 / ( 1/sigma02 + length(subset)/sigma2 )
    posteriorMean &lt;- posteriorVariance * ( mu0/sigma02 + sum(data[subset])/sigma2 )
    posteriorPredictiveSD &lt;- sqrt(posteriorVariance + sigma2)
    dnorm(data[i], posteriorMean, posteriorPredictiveSD, log=TRUE)
  }
}

logPostPredict &lt;- mkLogPosteriorPredictiveDensity()

nSamples &lt;- 1000L
partitions &lt;- matrix(0, nrow = nSamples, ncol = length(nealData))
accept &lt;- 0
for ( i in 2:nSamples ) {
  ms &lt;- seqAllocatedMergeSplit(partitions[i-1,],
                               logPostPredict,
                               t = 1,
                               mass = 1.0,
                               nUpdates = 2)
  partitions[i,] &lt;- ms$partition
  accept &lt;- accept + ms$accept
}

accept / nSamples # M-H acceptance rate

# convergence and mixing diagnostics
nSubsets &lt;- apply(partitions, 1, function(x) length(unique(x)))
mean(nSubsets)
sum(acf(nSubsets)$acf)-1   # Autocorrelation time

entropy &lt;- apply(partitions, 1, partitionEntropy)
plot.ts(entropy)

</code></pre>

<hr>
<h2 id='seqAllocatedMergeSplit_base'>Base Functionality for the seqAllocatedMergeSplit Function</h2><span id='topic+seqAllocatedMergeSplit_base'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using sequential allocation of items, as originally described
in Dahl (2003), with additional functionality for the two parameter CRP
prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqAllocatedMergeSplit_base(
  partition,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two-parameter CRP prior.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="seqAllocatedMergeSplit_base_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>An integer vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>References</h3>

<p>Dahl, D. B. (2003). An improved merge-split sampler for conjugate
Dirichlet process mixture models. Technical Report, 1, 086.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqAllocatedMergeSplit">seqAllocatedMergeSplit</a></code>
</p>

<hr>
<h2 id='simpleMergeSplit'>Merge-Split Sampling for a Partition Using Uniformly Random Allocation</h2><span id='topic+simpleMergeSplit'></span>

<h3>Description</h3>

<p>Merge-split proposals for conjugate &quot;Chinese Restaurant Process&quot; (CRP)
mixture models using uniformly random allocation of items, as presented in
Jain &amp; Neal (2004), with additional functionality for the two parameter CRP
prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleMergeSplit(
  partition,
  logPosteriorPredictiveDensity = function(i, subset) 0,
  mass = 1,
  discount = 0,
  nUpdates = 1L,
  selectionWeights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleMergeSplit_+3A_partition">partition</code></td>
<td>
<p>A numeric vector of cluster labels representing the current
partition.</p>
</td></tr>
<tr><td><code id="simpleMergeSplit_+3A_logposteriorpredictivedensity">logPosteriorPredictiveDensity</code></td>
<td>
<p>A function taking an index <code class="reqn">i</code> (as a
numeric vector of length one) and a subset of integers <code class="reqn">subset</code>, and
returning the natural logarithm of <code class="reqn">p( y_i | y_subset )</code>, i.e., that
item's contribution to the log integrated likelihood given a subset of the
other items. The default value &quot;turns off&quot; the likelihood, resulting in
prior simulation (rather than posterior simulation).</p>
</td></tr>
<tr><td><code id="simpleMergeSplit_+3A_mass">mass</code></td>
<td>
<p>A specification of the mass (concentration) parameter in the CRP
prior. Must be greater than the <code>-discount</code> argument.</p>
</td></tr>
<tr><td><code id="simpleMergeSplit_+3A_discount">discount</code></td>
<td>
<p>A numeric value on the interval [0,1) corresponding to the
discount parameter in the two parameter CRP prior.</p>
</td></tr>
<tr><td><code id="simpleMergeSplit_+3A_nupdates">nUpdates</code></td>
<td>
<p>An integer giving the number of merge-split proposals before
returning. This has the effect of thinning the Markov chain.</p>
</td></tr>
<tr><td><code id="simpleMergeSplit_+3A_selectionweights">selectionWeights</code></td>
<td>
<p>A matrix or data frame whose first two columns are
the unique pairs of data indices, along with a column of weights
representing how likely each pair is to be selected at the beginning of
each merge-split update.</p>
</td></tr>
</table>


<h3>Value</h3>

 <dl>
<dt>partition</dt><dd><p>An integer vector giving the updated
partition encoded using cluster labels.</p>
</dd> <dt>accept</dt><dd><p>The acceptance rate
of the Metropolis-Hastings proposals, i.e. the number accepted proposals
divided by <code>nUpdates</code>.</p>
</dd> </dl>



<h3>References</h3>

<p>Jain, S., &amp; Neal, R. M. (2004). A split-merge Markov chain Monte
Carlo procedure for the Dirichlet process mixture model. <em>Journal of
computational and Graphical Statistics</em>, 13(1), 158-182.
</p>

<hr>
<h2 id='sizeOfLargestCluster'>Calculate the Number of Items in the Largest Cluster of a Set Partition</h2><span id='topic+sizeOfLargestCluster'></span>

<h3>Description</h3>

<p>Calculate the Number of Items in the Largest Cluster of a Set Partition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeOfLargestCluster(partition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sizeOfLargestCluster_+3A_partition">partition</code></td>
<td>
<p>A numeric vector representing a partition of the integers
<code class="reqn">1</code>, ..., <code class="reqn">n</code> using cluster labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of items in the largest cluster of the given partition as
a numeric vector of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- c(0,1,1,1,1,1,2)
sizeOfLargestCluster(p)
</code></pre>

<hr>
<h2 id='transformedWeights'>Enumerate Transformed Weights for Choosing i and j Non-Uniformly</h2><span id='topic+transformedWeights'></span>

<h3>Description</h3>

<p>Enumerate Transformed Weights for Choosing i and j Non-Uniformly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformedWeights(m, fn = function(x) x, eps = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformedWeights_+3A_m">m</code></td>
<td>
<p>A square matrix of pairwise similarilities between items</p>
</td></tr>
<tr><td><code id="transformedWeights_+3A_fn">fn</code></td>
<td>
<p>A function that maps pairwise similarities. Default is the identity
function.</p>
</td></tr>
<tr><td><code id="transformedWeights_+3A_eps">eps</code></td>
<td>
<p>A numeric value close to 0 to give some nonzero weight to pairs of
items with 0 or 1 pairwise similarity</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
