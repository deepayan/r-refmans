<!DOCTYPE html><html lang="en"><head><title>Help for package pulsar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pulsar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pulsar-package'><p>The pulsar package</p></a></li>
<li><a href='#batch.pulsar'><p>pulsar: batch mode</p></a></li>
<li><a href='#estrada.class'><p>Estrada class</p></a></li>
<li><a href='#findConfFile'><p>find config file</p></a></li>
<li><a href='#findTemplateFile'><p>find template file</p></a></li>
<li><a href='#gcvec'><p>Graphlet correlation vector</p></a></li>
<li><a href='#get.opt.index'><p>Get or evaluate an optimal index</p></a></li>
<li><a href='#getEnvir'><p>Get calling environment</p></a></li>
<li><a href='#getLamPath'><p>Lambda path</p></a></li>
<li><a href='#getMaxCov'><p>Max value of cov</p></a></li>
<li><a href='#graph.diss'><p>Graph dissimilarity</p></a></li>
<li><a href='#natural.connectivity'><p>Natural Connectivity</p></a></li>
<li><a href='#opt.index'><p>Optimal index</p></a></li>
<li><a href='#plot.pulsar'><p>Plot a <code>pulsar</code> S3 object</p></a></li>
<li><a href='#print.pulsar'><p>Print a <code>pulsar</code> and <code>batch.pulsar</code> S3 object</p></a></li>
<li><a href='#print.pulsar.refit'><p>Print a <code>pulsar.refit</code> S3 object</p></a></li>
<li><a href='#pulsar'><p>pulsar: serial or parallel mode</p></a></li>
<li><a href='#pulsar-function'><p>Graphical model functions for pulsar</p></a></li>
<li><a href='#refit'><p>Refit pulsar model</p></a></li>
<li><a href='#update.pulsar'><p>Update a pulsar call</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Parallel Utilities for Lambda Selection along a Regularization
Path</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Model selection for penalized graphical models using the Stability Approach to Regularization Selection ('StARS'), with options for speed-ups including Bounded StARS (B-StARS), batch computing, and other stability metrics (e.g., graphlet stability G-StARS). Christian L. Müller, Richard Bonneau, Zachary Kurtz (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1605.07072">doi:10.48550/arXiv.1605.07072</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zdk123/pulsar">https://github.com/zdk123/pulsar</a>, <a href="https://arxiv.org/abs/1605.07072">https://arxiv.org/abs/1605.07072</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zdk123/pulsar/issues">https://github.com/zdk123/pulsar/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>batchtools (&ge; 0.9.10), fs (&ge; 1.2.2), checkmate (&ge; 1.8.5),
orca, huge, MASS, clime, glmnet, network, cluster, testthat,
knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, graphics, stats, utils, tools, Matrix (&ge;
1.5)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 17:17:23 UTC; zkurtz</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary Kurtz [aut, cre],
  Christian Müller [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary Kurtz &lt;zdkurtz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-24 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pulsar-package'>The pulsar package</h2><span id='topic+pulsar-package'></span>

<h3>Description</h3>

<p>Graphical model selection with the pulsar package
</p>


<h3>Details</h3>

<p>This package provides methods to select a sparse, undirected graphical model by choosing a penalty parameter (lambda or <code class="reqn">\lambda</code>) among a list of ordered values of lambda. We use an implementation of the Stability Approach to Regularization Selection (StARS, see references) inspired by the <span class="pkg">huge</span> package.
</p>
<p>However, <span class="pkg">pulsar</span> includes some major differences from other R packages for graphical model estimation and selection (<span class="pkg">glasso</span>, <span class="pkg">huge</span>, <span class="pkg">QUIC</span>, <span class="pkg">XMRF</span>, <span class="pkg">clime</span>, <span class="pkg">flare</span>, etc). The underlying graphical model is computed by passing a function as an argument to <code><a href="#topic+pulsar">pulsar</a></code>. Thus, any algorithm for penalized graphical models can be used in this framework (see <code><a href="#topic+pulsar-function">pulsar-function</a></code> for more details), including those from the above packages. <span class="pkg">pulsar</span> brings computational experiments under one roof by separating subsampling and calculation of summary criteria from the user-specified core model. The typical workflow in <span class="pkg">pulsar</span> is to perform subsampling first (via the <code><a href="#topic+pulsar">pulsar</a></code>) and then refit the model on the full dataset using <code><a href="#topic+refit">refit</a></code>.
</p>
<p>Previous StARS implementations can be inefficient for large graphs or when many subsamples are required. <code><a href="#topic+pulsar">pulsar</a></code> can compute upper and lower bounds on the regularization path for the StARS criterion after only <code class="reqn">2</code> subsamples which makes it possible to neglect lambda values that are far from the desired StARS regularization parameter, reducing computation time for the rest of the <code class="reqn">N-2</code> subsamples (Bounded StARS (B-StARS)).
</p>
<p>We also implement additional subsampling-based graph summary criteria which can be used for more informed model selection. For example, we have shown that induced subgraph (graphlet) stability (G-StARS) improves empirical performance over StARS but other criteria are also offered.
</p>
<p>Subsampling amounts to running the specified core model for <code class="reqn">N</code> independent computations. Using the <span class="pkg">batchtools</span> framework, we provide a simple wrapper, <code>batch.pulsar</code>, for running <code><a href="#topic+pulsar">pulsar</a></code> in embarrassingly parallel mode in an hpc environment. Summary criteria are computed using a Map/Reduce strategy, which lowers memory footprint for large models.
</p>


<h3>References</h3>

<p>Müller, C. L., Bonneau, R. A., &amp; Kurtz, Z. D. (2016).Generalized Stability Approach for Regularized Graphical Models.arXiv: https://arxiv.org/abs/1605.07072.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulsar-function">pulsar-function</a></code>, <code><a href="#topic+pulsar">pulsar</a></code>, <code><a href="#topic+batch.pulsar">batch.pulsar</a></code>
</p>

<hr>
<h2 id='batch.pulsar'>pulsar: batch mode</h2><span id='topic+batch.pulsar'></span>

<h3>Description</h3>

<p>Run pulsar using stability selection, or another criteria, to select an undirected graphical model over a lambda-path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch.pulsar(
  data,
  fun = huge::huge,
  fargs = list(),
  criterion = c("stars"),
  thresh = 0.1,
  subsample.ratio = NULL,
  lb.stars = FALSE,
  ub.stars = FALSE,
  rep.num = 20,
  seed = NULL,
  wkdir = getwd(),
  regdir = NA,
  init = "init",
  conffile = "",
  job.res = list(),
  cleanup = FALSE,
  refit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch.pulsar_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">n*p</code> matrix of data matrix input to solve for the <code class="reqn">p*p</code> graphical model</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_fun">fun</code></td>
<td>
<p>pass in a function that returns a list representing <code class="reqn">p*p</code> sparse, undirected graphical models along the desired regularization path. The expected inputs to this function are: a data matrix input and a sequence of decreasing lambdas and must return a list or S3 object with a member <em>named</em> <code>path</code>. This should be a list of adjacency matrices for each value of <code>lambda</code>. See <code><a href="#topic+pulsar-function">pulsar-function</a></code> for more information.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_fargs">fargs</code></td>
<td>
<p>arguments to argument <code>fun</code>. Must be a named list and requires at least one member <code>lambda</code>, a numeric vector with values for the penalty parameter.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_criterion">criterion</code></td>
<td>
<p>A character vector of selection statistics. Multiple criteria can be supplied. Only StARS can be used to automatically select an optimal index for the lambda path. See details for additional statistics.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_thresh">thresh</code></td>
<td>
<p>threshold (referred to as scalar <code class="reqn">\beta</code> in StARS publication) for selection criterion. Only implemented for StARS. <code>thresh=0.1</code> is recommended.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_subsample.ratio">subsample.ratio</code></td>
<td>
<p>determine the size of the subsamples (referred to as <code class="reqn">b(n)/n</code>). Default is 10*sqrt(n)/n for n &gt; 144 or 0.8 otherwise. Should be strictly less than 1.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_lb.stars">lb.stars</code></td>
<td>
<p>Should the lower bound be computed after the first <code class="reqn">N=2</code> subsamples (should result in considerable speedup and only implemented if stars is selected). If this option is selected, other summary metrics will only be applied to the smaller lambda path.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_ub.stars">ub.stars</code></td>
<td>
<p>Should the upper bound be computed after the first <code class="reqn">N=2</code> subsamples (should result in considerable speedup and only implemented if stars is selected). If this option is selected, other summary metrics will only be applied to the smaller lambda path. This option is ignored if the lb.stars flag is FALSE.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_rep.num">rep.num</code></td>
<td>
<p>number of random subsamples <code class="reqn">N</code> to take for graph re-estimation. Default is <code class="reqn">N=20</code>, but more is recommended for non-StARS criteria or if using edge frequencies as confidence scores.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_seed">seed</code></td>
<td>
<p>A numeric seed to force predictable subsampling. Default is NULL. Use for testing purposes only.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_wkdir">wkdir</code></td>
<td>
<p>set the working directory if different than <code><a href="base.html#topic+getwd">getwd</a></code></p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_regdir">regdir</code></td>
<td>
<p>directory to store intermediate batch job files. Default will be a tempory directory</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_init">init</code></td>
<td>
<p>text string appended to basename of the regdir path to store the batch jobs for the initial StARS variability estimate (ignored if 'regdir' is NA)</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_conffile">conffile</code></td>
<td>
<p>path to or string that identifies a <code><a href="batchtools.html#topic+batchtools-package">batchtools</a></code> configuration file. This argument is passed directly to the <code>name</code> argument of the <code><a href="#topic+findConfFile">findConfFile</a></code> function. See that help for detailed explanation.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_job.res">job.res</code></td>
<td>
<p>named list of resources needed for each job (e.g. for PBS submission script). The format and members depends on configuration and template. See examples section for a Torque example</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_cleanup">cleanup</code></td>
<td>
<p>Flag for removing batchtools registry files. Recommended FALSE unless you're sure intermediate data shouldn't be saved.</p>
</td></tr>
<tr><td><code id="batch.pulsar_+3A_refit">refit</code></td>
<td>
<p>Boolean flag to refit on the full dataset after pulsar is run. (see also <code><a href="#topic+refit">refit</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3 object of class <code><a href="#topic+batch.pulsar">batch.pulsar</a></code> with a named member for each stability criterion/metric. Within each of these are:
</p>

<ul>
<li><p> summary: the summary criterion over <code>rep.num</code> graphs at each value of lambda
</p>
</li>
<li><p> criterion: the stability metric
</p>
</li>
<li><p> merge: the raw criterion merged over the <code>rep.num</code> graphs (constructed from <code>rep.num</code> subsamples), prior to summarization
</p>
</li>
<li><p> opt.ind: index (along the path) of optimal lambda selected by the criterion at the desired threshold. Will return <code class="reqn">0</code> if no optimum is found or <code>NULL</code> if selection for the criterion is not implemented.
</p>
</li></ul>

<p>If <code>stars</code> is included as a criterion then additional arguments include
</p>

<ul>
<li><p> lb.index: the lambda index of the lower bound at <code class="reqn">N=2</code> samples if <code>lb.stars</code> flag is set to TRUE
</p>
</li>
<li><p> ub.index: the lambda index of the upper bound at <code class="reqn">N=2</code> samples if <code>ub.stars</code> flag is set to TRUE
</p>
</li></ul>

<p>reg: Registry object. See <code>batchtools::makeRegistry</code>
</p>
<p>id: Identifier for mapping graph estimation function. See <code>batchtools::batchMap</code>
</p>
<p>call: the original function call
</p>


<h3>References</h3>

<p>Müller, C. L., Bonneau, R., &amp; Kurtz, Z. (2016). Generalized Stability Approach for Regularized Graphical Models. arXiv https://arxiv.org/abs/1605.07072
</p>
<p>Liu, H., Roeder, K., &amp; Wasserman, L. (2010). Stability approach to regularization selection (stars) for high dimensional graphical models. Proceedings of the Twenty-Third Annual Conference on Neural Information Processing Systems (NIPS).
</p>
<p>Zhao, T., Liu, H., Roeder, K., Lafferty, J., &amp; Wasserman, L. (2012). The huge Package for High-dimensional Undirected Graph Estimation in R. The Journal of Machine Learning Research, 13, 1059–1062.
</p>
<p>Michel Lang, Bernd Bischl, Dirk Surmann (2017). batchtools: Tools for R to work on batch systems. The Journal of Open Source Software, 2(10). URL https://doi.org/10.21105/joss.00135.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulsar">pulsar</a></code> <code><a href="#topic+refit">refit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Generate the data with huge:
library(huge)
set.seed(10010)
p &lt;- 400 ; n &lt;- 1200
dat   &lt;- huge.generator(n, p, "hub", verbose=FALSE, v=.1, u=.3)
lams  &lt;- getLamPath(.2, .01, len=40)
hugeargs  &lt;- list(lambda=lams, verbose=FALSE)

## Run batch.pulsar using snow on 5 cores, and show progress.
options(mc.cores=5)
options(batchtools.progress=TRUE, batchtools.verbose=FALSE)
out &lt;- batch.pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                 rep.num=20, criterion='stars', conffile='snow')
## Run batch.pulsar on a Torque cluster
## Give each job 1gb of memory and a limit of 30 minutes
resources &lt;- list(mem="1GB", nodes="1", walltime="00:30:00")
out.p &lt;- batch.pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                 rep.num=100, criterion=c('stars', 'gcd'), conffile='torque'
                 job.res=resources, regdir=file.path(getwd(), "testtorq"))
plot(out.p)
## take a look at the default torque config and template files we just used
file.show(findConfFile('torque'))
file.show(findTemplateFile('simpletorque'))

## End(Not run)
</code></pre>

<hr>
<h2 id='estrada.class'>Estrada class</h2><span id='topic+estrada.class'></span>

<h3>Description</h3>

<p>Estrada proposes that graphs can be classified into four different classes. We call this the Estrada class.
These are:
I. Expander-like
II. Cluster
III. Core-Periphery
IV.  Mixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estrada.class(G, evthresh = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estrada.class_+3A_g">G</code></td>
<td>
<p>a <code class="reqn">p*p</code> adjacency matrix of a Graph</p>
</td></tr>
<tr><td><code id="estrada.class_+3A_evthresh">evthresh</code></td>
<td>
<p>tolerance for a zero eigenvalue</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estrada class (<code class="reqn">1-4</code>)
</p>


<h3>References</h3>

<p>Estrada, E. (2007). Topological structural classes of complex networks. Physical Review E - Statistical, Nonlinear, and Soft Matter Physics, 75(1), 1-12. doi:10.1103/PhysRevE.75.016103
</p>

<hr>
<h2 id='findConfFile'>find config file</h2><span id='topic+findConfFile'></span>

<h3>Description</h3>

<p>Find a default config file. First calls <code>batchtools::findConfFile</code> and then find a pulsar default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findConfFile(name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findConfFile_+3A_name">name</code></td>
<td>
<p>name of default config or path to config file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the batchtools functions <code>batchtools::findConfFile</code> and <code>batchtools::makeRegistry</code>. When calling <code>batch.pulsar</code>, we attempt to use batchtool's default lookup for a config file before calling <code>pulsar::findConfFile</code>.
</p>
<p>For clusters with a queuing submission system, a template file, for
defining worker node resources and executing the batch R code, will need to
be defined somewhere on the system. See <code><a href="#topic+findTemplateFile">findTemplateFile</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findTemplateFile">findTemplateFile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default config file provided by pulsar runs code in interactive mode
## This is for testing purposes and executes serially.
findConfFile()
## Use the parallel package
## slower than providing the 'ncores' argument to pulsar function, due to
## the overhead of creating the batchtools registry.
findConfFile('parallel')

## Use the snow package to register/execute batch jobs on socket clusters.
findConfFile('snow')
## Use a TORQUE / PBS queing system. Requires brew template file.
findConfFile('torque')
findTemplateFile('simpletorque')

</code></pre>

<hr>
<h2 id='findTemplateFile'>find template file</h2><span id='topic+findTemplateFile'></span>

<h3>Description</h3>

<p>Find a config file from batchtools or default file from pulsar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findTemplateFile(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findTemplateFile_+3A_name">name</code></td>
<td>
<p>name of default template or path to template file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the batchtools functions <code>batchtools::findTemplateFile</code>, <code>batchtools::makeClusterFunctionsTORQUE</code>, <code>batchtools::makeClusterFunctionsSGE</code>, etc, to employ batchtools' default lookup scheme for template files. Supply the output of this function to the <code>template</code> argument to override batchtools' default.
</p>
<p>In this case we look for &quot;[name].tmpl&quot; in the pulsar installation directory in the subfolder &quot;templates&quot;.
</p>


<h3>See Also</h3>

<p>findConfFile
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 cluster.functions = batchtools::makeClusterFunctionsTORQUE(
                     template=pulsar::findTemplateFile('simpletorque'))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='gcvec'>Graphlet correlation vector</h2><span id='topic+gcvec'></span>

<h3>Description</h3>

<p>Compute graphlet correlations over the desired orbits (default is 11 non-redundant orbits of graphlets of size &lt;=4) for a single graph <code>G</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcvec(G, orbind = c(0, 2, 5, 7, 8, 10, 11, 6, 9, 4, 1) + 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcvec_+3A_g">G</code></td>
<td>
<p>a <code class="reqn">p*p</code> adjacency matrix (dense or sparse) of a graph.</p>
</td></tr>
<tr><td><code id="gcvec_+3A_orbind">orbind</code></td>
<td>
<p>index vector for which orbits to use for computing pairwise graphlet correlations. Default is from Yaveroğlu et al, 2014 (see References), but 1 offset needed for R-style indexing.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hočevar, T., &amp; Demšar, J. (2014). A combinatorial approach to graphlet counting. Bioinformatics (Oxford, England), 30(4), 559–65. doi:10.1093/bioinformatics/btt717
</p>
<p>Yaveroğlu, Ö. N., Malod-Dognin, N., Davis, D., Levnajic, Z., Janjic, V., Karapandza, R., … Pržulj, N. (2014). Revealing the hidden language of complex networks. Scientific Reports, 4, 4547. doi:10.1038/srep04547
</p>

<hr>
<h2 id='get.opt.index'>Get or evaluate an optimal index</h2><span id='topic+get.opt.index'></span>

<h3>Description</h3>

<p>If the optimal index for the lambda path is not already assigned, then use a validated method to
select the optimal index of the lambda path for alternate criteria  (i.e. other than StARS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.opt.index(obj, criterion = "gcd", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.opt.index_+3A_obj">obj</code></td>
<td>
<p>the pulsar/batch.pulsar object to evaluate</p>
</td></tr>
<tr><td><code id="get.opt.index_+3A_criterion">criterion</code></td>
<td>
<p>a character argument for the desired summary criterion</p>
</td></tr>
<tr><td><code id="get.opt.index_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Automated optimal index selection is [currently] only implemented for <code>gcd</code> (graphlet stability).
</p>
<p>Criterion:
</p>

<ul>
<li><p> gcd: Select the minimum gcd summary score within the lower and upper StARS bounds.
</p>
</li></ul>



<h3>Value</h3>

<p>index of the lambda path
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt.index">opt.index</a></code>
</p>

<hr>
<h2 id='getEnvir'>Get calling environment</h2><span id='topic+getEnvir'></span><span id='topic+getEnvir.default'></span>

<h3>Description</h3>

<p>Generic S3 method for extracting an environment from an S3 object. A getter for an explicitly stored environment from an S3 object or list... probably the environment where the original function that created the object was called from. The default method is a wrapper for <code>x$envir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnvir(x)

## Default S3 method:
getEnvir(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnvir_+3A_x">x</code></td>
<td>
<p>S3 object to extract the environment</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>getCall</code>, <code>environment</code>, <code>parent.env</code>, <code>eval</code>
</p>

<hr>
<h2 id='getLamPath'>Lambda path</h2><span id='topic+getLamPath'></span>

<h3>Description</h3>

<p>Generate a lambda path sequence in descending order, equally or log-spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLamPath(max, min, len, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLamPath_+3A_max">max</code></td>
<td>
<p>numeric, maximum lambda value</p>
</td></tr>
<tr><td><code id="getLamPath_+3A_min">min</code></td>
<td>
<p>numeric, minimum lambda value</p>
</td></tr>
<tr><td><code id="getLamPath_+3A_len">len</code></td>
<td>
<p>numeric/int, length of lambda path</p>
</td></tr>
<tr><td><code id="getLamPath_+3A_log">log</code></td>
<td>
<p>logical, should the lambda path be log-spaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of lambdas
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getMaxCov">getMaxCov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate the data with huge:
library(huge)
set.seed(10010)
p &lt;- 40 ; n &lt;- 100
dat   &lt;- huge.generator(n, p, "hub", verbose=FALSE, v=.1, u=.3)

## Theoretical lamda max is the maximum abs value of the empirical covariance matrix
maxCov &lt;- getMaxCov(dat$data)
lams   &lt;- getLamPath(maxCov, 5e-2*maxCov, len=40)

</code></pre>

<hr>
<h2 id='getMaxCov'>Max value of cov</h2><span id='topic+getMaxCov'></span>

<h3>Description</h3>

<p>Get the maximum [absolute] value of a covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxCov(x, cov = isSymmetric(x), abs = TRUE, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMaxCov_+3A_x">x</code></td>
<td>
<p>A matrix/Matrix of data or covariance</p>
</td></tr>
<tr><td><code id="getMaxCov_+3A_cov">cov</code></td>
<td>
<p>Flag if <code>x</code> is a covariance matrix, Set False is <code>x</code> is an nxp data matrix. By default, if <code>x</code> is symmetric, assume it is a covariance matrix.</p>
</td></tr>
<tr><td><code id="getMaxCov_+3A_abs">abs</code></td>
<td>
<p>Flag to get max absolute value</p>
</td></tr>
<tr><td><code id="getMaxCov_+3A_diag">diag</code></td>
<td>
<p>Flag to include diagonal entries in the max</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to determine the theoretical value for lambda_max - for Gaussian data, but may be a useful starting point in the general case as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLamPath">getLamPath</a></code>
</p>

<hr>
<h2 id='graph.diss'>Graph dissimilarity</h2><span id='topic+graph.diss'></span>

<h3>Description</h3>

<p>Dissimilarity matrix of a graph is here defined as the number of neighbors shared by any two nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.diss(G, sim = FALSE, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.diss_+3A_g">G</code></td>
<td>
<p>a <code class="reqn">p*p</code> adjacency matrix (dense or sparse) of a graph.</p>
</td></tr>
<tr><td><code id="graph.diss_+3A_sim">sim</code></td>
<td>
<p>Flag to return Graph similarity instead (1-dissimilarity)</p>
</td></tr>
<tr><td><code id="graph.diss_+3A_loops">loops</code></td>
<td>
<p>Flag to consider self loops</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code class="reqn">p*p</code> dissimilarity matrix
</p>


<h3>References</h3>

<p>Bochkina, N. (2015). Selection of the Regularization Parameter in Graphical Models using a Priori Knowledge of Network Structure, arXiv: 1509.05326.
</p>

<hr>
<h2 id='natural.connectivity'>Natural Connectivity</h2><span id='topic+natural.connectivity'></span>

<h3>Description</h3>

<p>Compute the natural connectivity of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natural.connectivity(G, eig = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="natural.connectivity_+3A_g">G</code></td>
<td>
<p>a <code class="reqn">p*p</code> adjacency matrix (dense or sparse) of a graph. Ignored if <code>eig</code> is given</p>
</td></tr>
<tr><td><code id="natural.connectivity_+3A_eig">eig</code></td>
<td>
<p>precomputed list of eigen vals/vectors (output from <code>eigen</code>). If NULL, compute for <code>G</code>.</p>
</td></tr>
<tr><td><code id="natural.connectivity_+3A_norm">norm</code></td>
<td>
<p>should the natural connectivity score be normalized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The natural connectivity of a graph is a useful robustness measure of complex networks, corresponding to the average eigenvalue of the adjacency matrix.
</p>


<h3>Value</h3>

<p>numeric natural connectivity score
</p>


<h3>References</h3>

<p>Jun, W., Barahona, M., Yue-Jin, T., &amp; Hong-Zhong, D. (2010). Natural Connectivity of Complex Networks. Chinese Physics Letters, 27(7), 78902. doi:10.1088/0256-307X/27/7/078902
</p>

<hr>
<h2 id='opt.index'>Optimal index</h2><span id='topic+opt.index'></span><span id='topic+opt.index+3C-'></span>

<h3>Description</h3>

<p>Get or set the optimal index of the lambda path, as determined by a given criterion. <code>value</code> must be a numeric/int.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.index(obj, criterion = "gcd")

opt.index(obj, criterion = names(value)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.index_+3A_obj">obj</code></td>
<td>
<p>a pulsar or batch.pulsar object</p>
</td></tr>
<tr><td><code id="opt.index_+3A_criterion">criterion</code></td>
<td>
<p>a summary statistic criterion for lambda selection. If value is not named, default to gcd.</p>
</td></tr>
<tr><td><code id="opt.index_+3A_value">value</code></td>
<td>
<p>Integer index for optimal lambda by criterion</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get.opt.index">get.opt.index</a></code>
</p>

<hr>
<h2 id='plot.pulsar'>Plot a <code>pulsar</code> S3 object</h2><span id='topic+plot.pulsar'></span>

<h3>Description</h3>

<p>Plot a <code>pulsar</code> S3 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pulsar'
plot(x, scale = TRUE, invlam = FALSE, loglam = FALSE, legends = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pulsar_+3A_x">x</code></td>
<td>
<p>a <code>pulsar</code> or <code>batch.pulsar</code> object</p>
</td></tr>
<tr><td><code id="plot.pulsar_+3A_scale">scale</code></td>
<td>
<p>Flag to scale non-StARS criterion to max StARS value (or 1)</p>
</td></tr>
<tr><td><code id="plot.pulsar_+3A_invlam">invlam</code></td>
<td>
<p>Flag to plot 1/lambda</p>
</td></tr>
<tr><td><code id="plot.pulsar_+3A_loglam">loglam</code></td>
<td>
<p>Flag to plot log[lambda]</p>
</td></tr>
<tr><td><code id="plot.pulsar_+3A_legends">legends</code></td>
<td>
<p>Flag to plot legends</p>
</td></tr>
<tr><td><code id="plot.pulsar_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both invlam and loglam are given, log[1/lambda] is plotted
</p>

<hr>
<h2 id='print.pulsar'>Print a <code>pulsar</code> and <code>batch.pulsar</code> S3 object</h2><span id='topic+print.pulsar'></span><span id='topic+print.batch.pulsar'></span>

<h3>Description</h3>

<p>Print information about the model, path length, graph dimension, criterion and optimal indices, if defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pulsar'
print(x, ...)

## S3 method for class 'batch.pulsar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pulsar_+3A_x">x</code></td>
<td>
<p>a fitted <code>pulsar</code> or <code>batch.pulsar</code> object</p>
</td></tr>
<tr><td><code id="print.pulsar_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.pulsar.refit'>Print a <code>pulsar.refit</code> S3 object</h2><span id='topic+print.pulsar.refit'></span>

<h3>Description</h3>

<p>Print information about the model, path length, graph dimension, criterion and optimal indices and graph sparsity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pulsar.refit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pulsar.refit_+3A_x">x</code></td>
<td>
<p>a <code>pulsar.refit</code>. output from <code>refit</code></p>
</td></tr>
<tr><td><code id="print.pulsar.refit_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='pulsar'>pulsar: serial or parallel mode</h2><span id='topic+pulsar'></span>

<h3>Description</h3>

<p>Run pulsar using StARS' edge stability (or other criteria) to select an undirected graphical model over a lambda path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pulsar(
  data,
  fun = huge::huge,
  fargs = list(),
  criterion = c("stars"),
  thresh = 0.1,
  subsample.ratio = NULL,
  rep.num = 20,
  seed = NULL,
  lb.stars = FALSE,
  ub.stars = FALSE,
  ncores = 1,
  refit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pulsar_+3A_data">data</code></td>
<td>
<p>A <code class="reqn">n*p</code> matrix of data matrix input to solve for the <code class="reqn">p*p</code> graphical model</p>
</td></tr>
<tr><td><code id="pulsar_+3A_fun">fun</code></td>
<td>
<p>pass in a function that returns a list representing <code class="reqn">p*p</code> sparse, undirected graphical models along the desired regularization path. The expected inputs to this function are: a data matrix input and a sequence of decreasing lambdas and must return a list or S3 object with a member <em>named</em> <code>path</code>. This should be a list of adjacency matrices for each value of <code>lambda</code>. See <code><a href="#topic+pulsar-function">pulsar-function</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_fargs">fargs</code></td>
<td>
<p>arguments to argument <code>fun</code>. Must be a named list and requires at least one member <code>lambda</code>, a numeric vector with values for the penalty parameter.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_criterion">criterion</code></td>
<td>
<p>A character vector of selection statistics. Multiple criteria can be supplied. Only StARS can be used to automatically select an optimal index for the lambda path. See details for additional statistics.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_thresh">thresh</code></td>
<td>
<p>threshold (referred to as scalar <code class="reqn">\beta</code> in StARS publication) for selection criterion. Only implemented for StARS. <code>thresh=0.1</code> is recommended.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_subsample.ratio">subsample.ratio</code></td>
<td>
<p>determine the size of the subsamples (referred to as <code class="reqn">b(n)/n</code>). Default is 10*sqrt(n)/n for n &gt; 144 or 0.8 otherwise. Should be strictly less than 1.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_rep.num">rep.num</code></td>
<td>
<p>number of random subsamples <code class="reqn">N</code> to take for graph re-estimation. Default is <code class="reqn">N=20</code>, but more is recommended for non-StARS criteria or if using edge frequencies as confidence scores.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_seed">seed</code></td>
<td>
<p>A numeric seed to force predictable subsampling. Default is NULL. Use for testing purposes only.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_lb.stars">lb.stars</code></td>
<td>
<p>Should the lower bound be computed after the first <code class="reqn">N=2</code> subsamples (should result in considerable speedup and only implemented if stars is selected). If this option is selected, other summary metrics will only be applied to the smaller lambda path.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_ub.stars">ub.stars</code></td>
<td>
<p>Should the upper bound be computed after the first <code class="reqn">N=2</code> subsamples (should result in considerable speedup and only implemented if stars is selected). If this option is selected, other summary metrics will only be applied to the smaller lambda path. This option is ignored if the lb.stars flag is FALSE.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for subsampling. See <code>batch.pulsar</code> for more parallelization options.</p>
</td></tr>
<tr><td><code id="pulsar_+3A_refit">refit</code></td>
<td>
<p>Boolean flag to refit on the full dataset after pulsar is run. (see also <code><a href="#topic+refit">refit</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options for <code>criterion</code> statistics are:
</p>

<ul>
<li><p> stars (Stability approach to regularization selection)
</p>
</li>
<li><p> gcd   (Graphet correlation distance, requires the <span class="pkg">orca</span> package) see <code><a href="#topic+gcvec">gcvec</a></code>
</p>
</li>
<li><p> diss  (Node-node dissimilarity) see <code><a href="#topic+graph.diss">graph.diss</a></code>
</p>
</li>
<li><p> estrada (estrada class) see <code><a href="#topic+estrada.class">estrada.class</a></code>
</p>
</li>
<li><p> nc  (natural connectivity) see <code><a href="#topic+natural.connectivity">natural.connectivity</a></code>
</p>
</li>
<li><p> sufficiency (Tandon &amp; Ravikumar's sufficiency statistic)
</p>
</li></ul>



<h3>Value</h3>

<p>an S3 object of class <code>pulsar</code> with a named member for each stability metric run. Within each of these are:
</p>

<ul>
<li><p> summary: the summary statistic over <code>rep.num</code> graphs at each value of lambda
</p>
</li>
<li><p> criterion: the stability criterion used
</p>
</li>
<li><p> merge: the raw statistic over the <code>rep.num</code> graphs, prior to summarization
</p>
</li>
<li><p> opt.ind: index (along the path) of optimal lambda selected by the criterion at the desired threshold. Will return <code class="reqn">0</code> if no optimum is found or <code>NULL</code> if selection for the criterion is not implemented.
</p>
</li></ul>

<p>If <code>stars</code> is included as a criterion then additional arguments include
</p>

<ul>
<li><p> lb.index: the lambda index of the lower bound at <code class="reqn">N=2</code> samples if <code>lb.stars</code> flag is set to TRUE
</p>
</li>
<li><p> ub.index: the lambda index of the upper bound at <code class="reqn">N=2</code> samples if <code>ub.stars</code> flag is set to TRUE
</p>
</li></ul>

<p>call: the original function call
</p>


<h3>References</h3>

<p>Müller, C. L., Bonneau, R., &amp; Kurtz, Z. (2016). Generalized Stability Approach for Regularized Graphical Models. arXiv. https://arxiv.org/abs/1605.07072
</p>
<p>Liu, H., Roeder, K., &amp; Wasserman, L. (2010). Stability approach to regularization selection (stars) for high dimensional graphical models. Proceedings of the Twenty-Third Annual Conference on Neural Information Processing Systems (NIPS).
</p>
<p>Zhao, T., Liu, H., Roeder, K., Lafferty, J., &amp; Wasserman, L. (2012). The huge Package for High-dimensional Undirected Graph Estimation in R. The Journal of Machine Learning Research, 13, 1059–1062.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+batch.pulsar">batch.pulsar</a></code> <code><a href="#topic+refit">refit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Generate the data with huge:
library(huge)
p &lt;- 40 ; n &lt;- 1200
dat   &lt;- huge.generator(n, p, "hub", verbose=FALSE, v=.1, u=.3)
lams  &lt;- getLamPath(getMaxCov(dat$data), .01, len=20)

## Run pulsar with huge
hugeargs &lt;- list(lambda=lams, verbose=FALSE)
out.p &lt;- pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                rep.num=20, criterion='stars')

## Run pulsar in bounded stars mode and include gcd metric:
out.b &lt;- pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                rep.num=20, criterion=c('stars', 'gcd'),
                lb.stars=TRUE, ub.stars=TRUE)
plot(out.b)

## End(Not run)
</code></pre>

<hr>
<h2 id='pulsar-function'>Graphical model functions for pulsar</h2><span id='topic+pulsar-function'></span>

<h3>Description</h3>

<p>Correctly specify a function for graphical model estimation that is compatible with the pulsar package.
</p>


<h3>Details</h3>

<p>It is easy to construct your own function for penalized model estimation that can be used with this package. The R function must have correctly specified inputs and outputs and is passed into the <code>fun</code> argument to <code><a href="#topic+pulsar">pulsar</a></code> or <code><a href="#topic+batch.pulsar">batch.pulsar</a></code>. Any function that does not follow these rules will fail to give the desired output and may trigger an error.
</p>
<p>These packages on CRAN have functions that work out of the box, so you won't need to construct a wrapper:
</p>

<table>
<tr>
 <td style="text-align: left;">
  ~function~ </td><td style="text-align: left;"> ~package~</td>
</tr>
<tr>
 <td style="text-align: left;">
   huge     </td><td style="text-align: left;">   huge   </td>
</tr>
<tr>
 <td style="text-align: left;">
   sugm     </td><td style="text-align: left;">   flare
</td>
</tr>

</table>

<p>Inputs:
</p>
<p>The function may take arbitrary, named arguments but the first argument must be the data <code class="reqn">n*p</code> data matrix with the <code class="reqn">n</code> samples in rows and <code class="reqn">p</code> features in the columns.
At least one argument must be named &quot;lambda&quot;, which is expected to be a decreasing numeric vector of penalties. The non-data arguments should be passed into <code><a href="#topic+pulsar">pulsar</a></code> or <code><a href="#topic+batch.pulsar">batch.pulsar</a></code> as a named list (the names must match function arguments exactly) to the <code>fargs</code> argument.
</p>
<p>Outputs:
</p>
<p>The output from the function must be a list or another S3 object inherited from a list. At least one member must be named <code>path</code>. This <code>path</code> object itself must be a list of <code class="reqn">p*p</code> adjacency matrices, one for each value of lambda. Each cell in the adjacency matrix contains a 1 or TRUE if there is an edge between two nodes or 0/FALSE otherwise. It is highly recommended (though not enforced by <span class="pkg">pulsar</span>) that each adjacency matrix be a column-oriented, compressed, sparse matrix from the <span class="pkg">Matrix</span> package. For example, <code>dgCMatrix</code>/<code>dsCMatrix</code> (general/symmetric numeric Matrix) or the 1-bit <code>lgCMatrix</code>/<code>lsCMatrix</code> classes.
The function may return other named outputs, but these will be ignored.
</p>


<h3>References</h3>

<p>Müller, C. L., Bonneau, R. A., &amp; Kurtz, Z. D. (2016). Generalized Stability Approach for Regularized Graphical Models. arXiv: https://arxiv.org/abs/1605.07072.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pulsar">pulsar</a></code>, <code><a href="#topic+batch.pulsar">batch.pulsar</a></code>, <span class="pkg">huge</span>, <span class="pkg">Matrix</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a hub example
 dat &lt;- huge::huge.generator(100, 40, 'hub', verbose=FALSE)

## Simple correlation thresholding
corrthresh &lt;- function(data, lambda) {
  S &lt;- cor(data)
  path &lt;- lapply(lambda, function(lam) {
    tmp &lt;- abs(S) &gt; lam
    diag(tmp) &lt;- FALSE
    as(tmp, 'lMatrix')
  })
  list(path=path)
}

## Inspect output
lam &lt;- getLamPath(getMaxCov(dat$sigmahat), 1e-4, 10)
out.cor  &lt;- pulsar(dat$data, corrthresh, fargs=list(lambda=lam))
out.cor

## Not run: 
## Additional examples
## quic
library(QUIC)
quicr &lt;- function(data, lambda, ...) {
    S    &lt;- cov(data)
    est  &lt;- QUIC(S, rho=1, path=lambda, msg=0, tol=1e-2, ...)
    est$path &lt;-  lapply(seq(length(lambda)), function(i) {
                   ## convert precision array to adj list
                   tmp &lt;- est$X[,,i]; diag(tmp) &lt;- 0
                 as(tmp!=0, "lMatrix")
    })
    est
}
## clime
library(clime)
climer &lt;- function(data, lambda, tol=1e-5, ...) {
     est &lt;- clime(data, lambda, ...)
     est$path &lt;- lapply(est$Omegalist, function(x) {
                     diag(x) &lt;- 0
                     as(abs(x) &gt; tol, "lMatrix")
                 })
     est
}

## inverse cov shrinkage Schafer and Strimmer, 2005
library(corpcor)
icovshrink &lt;- function(data, lambda, tol=1e-3, ...) {
     path &lt;- lapply(lambda, function(lam) {
                     tmp &lt;- invcov.shrink(data, lam, verbose=FALSE)
                     diag(tmp) &lt;- 0
                     as(abs(tmp) &gt; tol, "lMatrix")
                 })
     list(path=path)
}

## Penalized linear model, only
library(glmnet)
lasso &lt;- function(data, lambda, respind=1, family="gaussian", ...) {
         n &lt;- length(lambda)
         tmp &lt;- glmnet(data[,-respind], data[,respind],
                                   family=family, lambda=lambda, ...)
         path &lt;-lapply(1:n, function(i) as(tmp$beta[,i,drop=FALSE], "lMatrix"))
         list(path=path)
}

## alternative stability selection (DIFFERENT from hdi package)
out &lt;- pulsar(dat$data, lasso, fargs=list(lambda=lam))
mergmat &lt;- do.call('cbind', tmp$stars$merge)
image(mergmat)

## End(Not run)
</code></pre>

<hr>
<h2 id='refit'>Refit pulsar model</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>Run the supplied graphical model function on the whole dataset and refit with the selected lambda(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(obj, criterion)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit_+3A_obj">obj</code></td>
<td>
<p>a fitted <code>pulsar</code> or <code>batch.pulsar</code> object</p>
</td></tr>
<tr><td><code id="refit_+3A_criterion">criterion</code></td>
<td>
<p>a character vector of criteria for refitting on full data. An optimal index must be defined for each criterion or a message will displayed. If missing (no argument is supplied), try to refit for all pre-specified criteria.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>refit</code> call is evaluated in the environment specified by the <code>pulsar</code> or <code>batch.pulsar</code> object, so if any variables were used for arguments to the original call, unless they are purposefully updated, should not be altered. For example, if the variable for the original data is reassigned, the output of <code>refit</code> will not be on the original dataset.
</p>


<h3>Value</h3>

<p>a <code>pulsar.refit</code> S3 object with members:
</p>

<ul>
<li><p> est: the raw output from the graphical model function, <code>fun</code>, applied to the full dataset.
</p>
</li>
<li><p> refit: a named list of adjacency matrices, for each optimal criterion in <code>obj</code> or specified in the <code>criterion</code> argument.
</p>
</li>
<li><p> fun: the original function used to estimate the graphical model along the lambda path.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pulsar">pulsar</a></code> <code><a href="#topic+batch.pulsar">batch.pulsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate the data with huge:
## Not run: 
library(huge)
set.seed(10010)
p &lt;- 40 ; n &lt;- 1200
dat   &lt;- huge.generator(n, p, "hub", verbose=FALSE, v=.1, u=.3)
lams  &lt;- getLamPath(getMaxCov(dat$data), .01, len=20)

## Run pulsar with huge
hugeargs &lt;- list(lambda=lams, verbose=FALSE)
out.p &lt;- pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                rep.num=20, criterion='stars')

fit  &lt;- refit(out.p)

## End(Not run)
</code></pre>

<hr>
<h2 id='update.pulsar'>Update a pulsar call</h2><span id='topic+update.pulsar'></span>

<h3>Description</h3>

<p>Update a pulsar model with new or altered arguments. It does this by extracting the call stored in the object, updating the call and (by default) evaluating it in the environment of the original <code>pulsar</code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pulsar'
update(object, ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.pulsar_+3A_object">object</code></td>
<td>
<p>a n existing pulsar or batch.pulsar object</p>
</td></tr>
<tr><td><code id="update.pulsar_+3A_...">...</code></td>
<td>
<p>arguments to <code>pulsar</code> to update</p>
</td></tr>
<tr><td><code id="update.pulsar_+3A_evaluate">evaluate</code></td>
<td>
<p>Flag to evaluate the function. If <code>FALSE</code>, the updated call is returned without evaluation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>update</code> call is evaluated in the environment specified by the <code>pulsar</code> or <code>batch.pulsar</code> object, so if any variables were used for arguments to the original call, unless they are purposefully updated, should not be altered. For example, if the variable for the original data is reassigned, the output of <code>update</code> will not be on the original dataset.
</p>


<h3>Value</h3>

<p>If <code>evaluate = TRUE</code>, the fitted object - the same output as <code>pulsar</code> or <code>batch.pulsar</code>. Otherwise, the updated call.
</p>


<h3>See Also</h3>

<p><code>eval</code>, <code><a href="stats.html#topic+update">update</a></code>, <code><a href="#topic+pulsar">pulsar</a></code>, <code><a href="#topic+batch.pulsar">batch.pulsar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: p &lt;- 40 ; n &lt;- 1200
dat   &lt;- huge.generator(n, p, "hub", verbose=FALSE, v=.1, u=.3)
lams  &lt;- getLamPath(getMaxCov(dat$data), .01, len=20)

## Run pulsar with huge
hugeargs &lt;- list(lambda=lams, verbose=FALSE)
out.p &lt;- pulsar(dat$data, fun=huge::huge, fargs=hugeargs,
                rep.num=20, criterion='stars')

## update call, adding bounds
out.b &lt;- update(out.p, lb.stars=TRUE, ub.stars=TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
