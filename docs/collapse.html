<!DOCTYPE html><html><head><title>Help for package collapse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {collapse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#across'>
<p>Apply Functions Across Multiple Columns</p></a></li>
<li><a href='#arithmetic'>
<p>Fast Row/Column Arithmetic for Matrix-Like Objects</p></a></li>
<li><a href='#BY'>
<p>Split-Apply-Combine Computing</p></a></li>
<li><a href='#collap'>
<p>Advanced Data Aggregation</p></a></li>
<li><a href='#collapse-documentation'><p>Collapse Documentation &amp; Overview</p></a></li>
<li><a href='#collapse-options'><p><em>collapse</em> Package Options</p></a></li>
<li><a href='#collapse-package'>
<p>Advanced and Fast Data Transformation</p></a></li>
<li><a href='#collapse-renamed'>
<p>Renamed Functions</p></a></li>
<li><a href='#colorder'>
<p>Fast Reordering of Data Frame Columns</p></a></li>
<li><a href='#dapply'>
<p>Data Apply</p></a></li>
<li><a href='#data-transformations'><p>Data Transformations</p></a></li>
<li><a href='#descr'>
<p>Detailed Statistical Description of Data Frame</p></a></li>
<li><a href='#efficient-programming'>
<p>Small Functions to Make R Programming More Efficient</p></a></li>
<li><a href='#fast-data-manipulation'><p>Fast Data Manipulation</p></a></li>
<li><a href='#fast-grouping-ordering'><p>Fast Grouping and Ordering</p></a></li>
<li><a href='#fast-statistical-functions'><p>Fast (Grouped, Weighted) Statistical Functions for Matrix-Like Objects</p></a></li>
<li><a href='#fbetween-fwithin'>
<p>Fast Between (Averaging) and (Quasi-)Within (Centering) Transformations</p></a></li>
<li><a href='#fcount'>
<p>Efficiently Count Observations by Group</p></a></li>
<li><a href='#fcumsum'>
<p>Fast (Grouped, Ordered) Cumulative Sum for Matrix-Like Objects</p></a></li>
<li><a href='#fdiff'>
<p>Fast (Quasi-, Log-) Differences for Time Series and Panel Data</p></a></li>
<li><a href='#fdist'>
<p>Fast and Flexible Distance Computations</p></a></li>
<li><a href='#fdroplevels'>
<p>Fast Removal of Unused Factor Levels</p></a></li>
<li><a href='#ffirst-flast'><p>Fast (Grouped) First and Last Value for Matrix-Like Objects</p></a></li>
<li><a href='#fFtest'>
<p>Fast (Weighted) F-test for Linear Models (with Factors)</p></a></li>
<li><a href='#fgrowth'>
<p>Fast Growth Rates for Time Series and Panel Data</p></a></li>
<li><a href='#fhdbetween-fhdwithin'>
<p>Higher-Dimensional Centering and Linear Prediction</p></a></li>
<li><a href='#flag'>
<p>Fast Lags and Leads for Time Series and Panel Data</p></a></li>
<li><a href='#flm'>
<p>Fast (Weighted) Linear Model Fitting</p></a></li>
<li><a href='#fmatch'><p>Fast Matching</p></a></li>
<li><a href='#fmean'><p>Fast (Grouped, Weighted) Mean for Matrix-Like Objects</p></a></li>
<li><a href='#fmin-fmax'><p>Fast (Grouped) Maxima and Minima for Matrix-Like Objects</p></a></li>
<li><a href='#fmode'><p>Fast (Grouped, Weighted) Statistical Mode for Matrix-Like Objects</p></a></li>
<li><a href='#fndistinct'><p>Fast (Grouped) Distinct Value Count for Matrix-Like Objects</p></a></li>
<li><a href='#fnobs'><p>Fast (Grouped) Observation Count for Matrix-Like Objects</p></a></li>
<li><a href='#fnth-fmedian'>
<p>Fast (Grouped, Weighted) N'th Element/Quantile for Matrix-Like Objects</p></a></li>
<li><a href='#fprod'><p>Fast (Grouped, Weighted) Product for Matrix-Like Objects</p></a></li>
<li><a href='#fquantile'>
<p>Fast (Weighted) Sample Quantiles and Range</p></a></li>
<li><a href='#frename'>
<p>Fast Renaming and Relabelling Objects</p></a></li>
<li><a href='#fscale'>
<p>Fast (Grouped, Weighted) Scaling and Centering of Matrix-like Objects</p></a></li>
<li><a href='#fselect-get_vars-add_vars'><p>Fast Select, Replace or Add Data Frame Columns</p></a></li>
<li><a href='#fsubset'><p>Fast Subsetting Matrix-Like Objects</p></a></li>
<li><a href='#fsum'><p>Fast (Grouped, Weighted) Sum for Matrix-Like Objects</p></a></li>
<li><a href='#fsummarise'>
<p>Fast Summarise</p></a></li>
<li><a href='#ftransform'><p>Fast Transform and Compute Columns on a Data Frame</p></a></li>
<li><a href='#funique'>
<p>Fast Unique Elements / Rows</p></a></li>
<li><a href='#fvar-fsd'><p>Fast (Grouped, Weighted) Variance and Standard Deviation for Matrix-Like Objects</p></a></li>
<li><a href='#get_elem'><p>Find and Extract / Subset List Elements</p></a></li>
<li><a href='#GGDC10S'>
<p>Groningen Growth and Development Centre 10-Sector Database</p></a></li>
<li><a href='#group'>
<p>Fast Hash-Based Grouping</p></a></li>
<li><a href='#groupid'>
<p>Generate Run-Length Type Group-Id</p></a></li>
<li><a href='#GRP'><p>Fast Grouping / <em>collapse</em> Grouping Objects</p></a></li>
<li><a href='#indexing'>
<p>Fast Indexed Time Series and Panels</p></a></li>
<li><a href='#is_unlistable'>
<p>Unlistable Lists</p></a></li>
<li><a href='#join'><p>Fast Table Joins</p></a></li>
<li><a href='#ldepth'>
<p>Determine the Depth / Level of Nesting of a List</p></a></li>
<li><a href='#list-processing'><p>List Processing</p></a></li>
<li><a href='#pad'>
<p>Pad Matrix-Like Objects with a Value</p></a></li>
<li><a href='#pivot'>
<p>Fast and Easy Data Reshaping</p></a></li>
<li><a href='#psacf'>
<p>Auto- and Cross- Covariance and Correlation Function Estimation for Panel Series</p></a></li>
<li><a href='#psmat'>
<p>Matrix / Array from Panel Series</p></a></li>
<li><a href='#pwcor-pwcov-pwnobs'>
<p>(Pairwise, Weighted) Correlations, Covariances and Observation Counts</p></a></li>
<li><a href='#qF-qG-finteraction'>
<p>Fast Factor Generation, Interactions and Vector Grouping</p></a></li>
<li><a href='#qsu'>
<p>Fast (Grouped, Weighted) Summary Statistics for Cross-Sectional and Panel Data</p></a></li>
<li><a href='#qtab'>
<p>Fast (Weighted) Cross Tabulation</p></a></li>
<li><a href='#quick-conversion'><p>Quick Data Conversion</p></a></li>
<li><a href='#radixorder'>
<p>Fast Radix-Based Ordering</p></a></li>
<li><a href='#rapply2d'>
<p>Recursively Apply a Function to a List of Data Objects</p></a></li>
<li><a href='#recode-replace'>
<p>Recode and Replace Values in Matrix-Like Objects</p></a></li>
<li><a href='#rowbind'>
<p>Row-Bind Lists / Data Frame-Like Objects</p></a></li>
<li><a href='#roworder'>
<p>Fast Reordering of Data Frame Rows</p></a></li>
<li><a href='#rsplit'>
<p>Fast (Recursive) Splitting</p></a></li>
<li><a href='#seqid'>
<p>Generate Group-Id from Integer Sequences</p></a></li>
<li><a href='#small-helpers'>
<p>Small (Helper) Functions</p></a></li>
<li><a href='#summary-statistics'><p>Summary Statistics</p></a></li>
<li><a href='#t_list'>
<p>Efficient List Transpose</p></a></li>
<li><a href='#time-series-panel-series'><p>Time Series and Panel Series</p></a></li>
<li><a href='#timeid'>
<p>Generate Integer-Id From Time/Date Sequences</p></a></li>
<li><a href='#TRA'>
<p>Transform Data by (Grouped) Replacing or Sweeping out Statistics</p></a></li>
<li><a href='#unlist2d'>
<p>Recursive Row-Binding / Unlisting in 2D - to Data Frame</p></a></li>
<li><a href='#varying'><p>Fast Check of Variation in Data</p></a></li>
<li><a href='#wlddev'>
<p>World Development Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Advanced and Fast Data Transformation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A C/C++ based package for advanced data transformation and 
    statistical computing in R that is extremely fast, class-agnostic, robust and 
    programmer friendly. Core functionality includes a rich set of S3 generic grouped 
    and weighted statistical functions for vectors, matrices and data frames, which 
    provide efficient low-level vectorizations, OpenMP multithreading, and skip missing 
    values by default. These are integrated with fast grouping and ordering algorithms 
    (also callable from C), and efficient data manipulation functions. The package also 
    provides a flexible and rigorous approach to time series and panel data in R. 
    It further includes fast functions for common statistical procedures, detailed 
    (grouped, weighted) summary statistics, powerful tools to work with nested data, 
    fast data object conversions, functions for memory efficient R programming, and 
    helpers to effectively deal with variable labels, attributes, and missing data. 
    It is well integrated with base R classes, 'dplyr'/'tibble', 'data.table', 'sf', 
    'plm' (panel-series and data frames), and 'xts'/'zoo'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sebkrantz.github.io/collapse/">https://sebkrantz.github.io/collapse/</a>,
<a href="https://github.com/SebKrantz/collapse">https://github.com/SebKrantz/collapse</a>,
<a href="https://twitter.com/collapse_R">https://twitter.com/collapse_R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SebKrantz/collapse/issues">https://github.com/SebKrantz/collapse/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fastverse, data.table, magrittr, kit, xts, zoo, plm, fixest,
vars, RcppArmadillo, RcppEigen, tibble, dplyr, ggplot2, scales,
microbenchmark, testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-30 11:38:53 UTC; sebastiankrantz</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Krantz <a href="https://orcid.org/0000-0001-6212-5229"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matt Dowle [ctb],
  Arun Srinivasan [ctb],
  Morgan Jacob [ctb],
  Dirk Eddelbuettel [ctb],
  Laurent Berge [ctb],
  Kevin Tappe [ctb],
  R Core Team and contributors worldwide [ctb],
  Martyn Plummer [cph],
  1999-2016 The R Core Team [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Krantz &lt;sebastian.krantz@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-01 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='across'>
Apply Functions Across Multiple Columns
</h2><span id='topic+across'></span>

<h3>Description</h3>

<p><code>across()</code> can be used inside <code><a href="#topic+fmutate">fmutate</a></code> and <code><a href="#topic+fsummarise">fsummarise</a></code> to apply one or more functions to a selection of columns. It is overall very similar to <code>dplyr::across</code>, but does not support some <code>rlang</code> features, has some additional features (arguments), and is optimized to work with <em>collapse</em>'s, <code><a href="#topic+.FAST_FUN">.FAST_FUN</a></code>, yielding much faster computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>across(.cols = NULL, .fns, ..., .names = NULL,
       .apply = "auto", .transpose = "auto")

# acr(...) can be used to abbreviate across(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="across_+3A_.cols">.cols</code></td>
<td>
<p>select columns using column names and expressions (e.g. <code>a:b</code> or <code>c(a, b, c:f)</code>), column indices, logical vectors, or functions yielding a logical value e.g. <code>is.numeric</code>. <code>NULL</code> applies functions to all columns except for grouping columns.</p>
</td></tr>
<tr><td><code id="across_+3A_.fns">.fns</code></td>
<td>
<p>A function, character vector of functions or list of functions. Vectors / lists can be named to yield alternative names in the result (see <code>.names</code>). This argument is evaluated inside <code>substitute()</code>, and the content (not the names of vectors/lists) is checked against <code>.FAST_FUN</code> and <code>.OPERATOR_FUN</code>. Matching functions receive vectorized execution, other functions are applied to the data in a standard way.</p>
</td></tr>
<tr><td><code id="across_+3A_...">...</code></td>
<td>
<p>further arguments to <code>.fns</code>. Arguments are evaluated in the data environment and split by groups as well (for non-vectorized functions, if of the same length as the data).</p>
</td></tr>
<tr><td><code id="across_+3A_.names">.names</code></td>
<td>
<p>controls the naming of computed columns. <code>NULL</code> generates names of the form <code>coli_funj</code> if multiple functions are used. <code>.names = TRUE</code> enables this for a single function, <code>.names = FALSE</code> disables it for multiple functions (sensible for functions such as <code>.OPERATOR_FUN</code> that rename columns (if <code>.apply = FALSE</code>)). Setting <code>.names = "flip"</code> generates names of the form <code>funj_coli</code>. It is also possible to supply a function with two arguments for column and function names e.g. <code>function(c, f) paste0(f, "_", c)</code>. Finally, you can supply a custom vector of names which must match <code>length(.cols) * length(.fns)</code>.</p>
</td></tr>
<tr><td><code id="across_+3A_.apply">.apply</code></td>
<td>
<p>controls whether functions are applied column-by-column (<code>TRUE</code>) or to multiple columns at once (<code>FALSE</code>). The default, <code>"auto"</code>, does the latter for vectorized functions, which have an efficient data frame method. It can also be sensible to use <code>.apply = FALSE</code> for non-vectorized functions, especially multivariate functions like <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="#topic+pwcor">pwcor</a></code>, or functions renaming the data. See Examples.  </p>
</td></tr>
<tr><td><code id="across_+3A_.transpose">.transpose</code></td>
<td>
<p>with multiple <code>.fns</code>, <code>.transpose</code> controls whether the result is ordered first by column, then by function (<code>TRUE</code>), or vice-versa (<code>FALSE</code>). <code>"auto"</code> does the former if all functions yield results of the same dimensions (dimensions may differ if <code>.apply = FALSE</code>). See Examples.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>across</code> does not support <em>purr</em>-style lambdas, and does not support <code>dplyr</code>-style predicate functions e.g. <code>across(where(is.numeric), sum)</code>, simply use <code>across(is.numeric, sum)</code>. In contrast to <code>dplyr</code>, you can also compute on grouping columns.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+fsummarise">fsummarise</a></code>, <code><a href="#topic+fmutate">fmutate</a></code>, <a href="#topic+fast-data-manipulation">Fast Data Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic (Weighted) Summaries
fsummarise(wlddev, across(PCGDP:GINI, fmean, w = POP))

wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, fmean, w = POP))

# Note that for these we don't actually need across...
fselect(wlddev, PCGDP:GINI) |&gt; fmean(w = wlddev$POP, drop = FALSE)
wlddev |&gt; fgroup_by(region, income) |&gt;
    fselect(PCGDP:GINI, POP) |&gt; fmean(POP, keep.w = FALSE)
collap(wlddev, PCGDP + LIFEEX + GINI ~ region + income, w = ~ POP, keep.w = FALSE)

# But if we want to use some base R function that reguires argument splitting...
wlddev |&gt; na_omit(cols = "POP") |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, weighted.mean, w = POP, na.rm = TRUE))

# Or if we want to apply different functions...
wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, list(mu = fmean, sd = fsd), w = POP),
               POP_sum = fsum(POP), OECD = fmean(OECD))
# Note that the above still detects fmean as a fast function, the names of the list
# are irrelevant, but the function name must be typed or passed as a character vector,
# Otherwise functions will be executed by groups e.g. function(x) fmean(x) won't vectorize

# Same, naming in a different way
wlddev |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(PCGDP:GINI, list(mu = fmean, sd = fsd), w = POP, .names = "flip"),
               sum_POP = fsum(POP), OECD = fmean(OECD))

# Or we want to do more advanced things..
# Such as nesting data frames..
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
               function(x) list(Nest = list(x)),
               .apply = FALSE))
# Or linear models..
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
               function(x) list(Mods = list(lm(PCGDP ~., x))),
               .apply = FALSE))
# Or cumputing grouped correlation matrices
qTBL(wlddev) |&gt; fgroup_by(region, income) |&gt;
    fsummarise(across(c(PCGDP, LIFEEX, ODA),
      function(x) qDF(pwcor(x), "Variable"), .apply = FALSE))

# Here calculating 1- and 10-year lags and growth rates of these variables
qTBL(wlddev) |&gt; fgroup_by(country) |&gt;
    fmutate(across(c(PCGDP, LIFEEX, ODA), list(L, G),
                   n = c(1, 10), t = year, .names = FALSE))

# Same but variables in different order
qTBL(wlddev) |&gt; fgroup_by(country) |&gt;
    fmutate(across(c(PCGDP, LIFEEX, ODA), list(L, G), n = c(1, 10),
                   t = year, .names = FALSE, .transpose = FALSE))

</code></pre>

<hr>
<h2 id='arithmetic'>
Fast Row/Column Arithmetic for Matrix-Like Objects
</h2><span id='topic+arithmetic'></span><span id='topic++25rr+25'></span><span id='topic++25r+2B+25'></span><span id='topic++25r-+25'></span><span id='topic++25r+2A+25'></span><span id='topic++25r+2F+25'></span><span id='topic++25cr+25'></span><span id='topic++25c+2B+25'></span><span id='topic++25c-+25'></span><span id='topic++25c+2A+25'></span><span id='topic++25c+2F+25'></span>

<h3>Description</h3>

<p>Fast operators to perform row- or column-wise replacing and sweeping operations of vectors on matrices, data frames, lists. See also <code><a href="#topic+setop">setop</a></code> for math by reference and <code><a href="#topic+setTRA">setTRA</a></code> for sweeping by reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Perform the operation with v and each row of X

X %rr% v    # Replace rows of X with v
X %r+% v    # Add v to each row of X
X %r-% v    # Subtract v from each row of X
X %r*% v    # Multiply each row of X with v
X %r/% v    # Divide each row of X by v

## Perform a column-wise operation between V and X

X %cr% V    # Replace columns of X with V
X %c+% V    # Add V to columns of X
X %c-% V    # Subtract V from columns of X
X %c*% V    # Multiply columns of X with V
X %c/% V    # Divide columns of X by V
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arithmetic_+3A_x">X</code></td>
<td>
<p>a vector, matrix, data frame or list like object (with rows (r) columns (c) matching <code>v</code> / <code>V</code>).</p>
</td></tr>
<tr><td><code id="arithmetic_+3A_v">v</code></td>
<td>
<p>for row operations: an atomic vector of matching <code>NCOL(X)</code>. If <code>X</code> is a data frame, <code>v</code> can also be a list of scalar atomic elements. It is also possible to sweep lists of vectors <code>v</code> out of lists of matrices or data frames <code>X</code>.</p>
</td></tr>
<tr><td><code id="arithmetic_+3A_v">V</code></td>
<td>
<p>for column operations: a suitable scalar, vector, or matrix / data frame matching <code>NROW(X)</code>. <code>X</code> can also be a list of vectors / matrices in which case <code>V</code> can be a scalar / vector / matrix or matching list of scalars / vectors / matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With a matrix or data frame <code>X</code>, the default behavior of R when calling <code>X op v</code> (such as multiplication <code>X * v</code>) is to perform the operation of <code>v</code> with each column of <code>X</code>. The equivalent operation is performed by <code>X %cop% V</code>, with the difference that it computes significantly faster if <code>X</code>/<code>V</code> is a data frame / list. A more complex but frequently required task is to perform an operation with <code>v</code> on each row of <code>X</code>. This is provided based on efficient C++ code by the <code>%rop%</code> set of functions, e.g. <code>X %r*% v</code> efficiently multiplies <code>v</code> to each row of <code>X</code>.
</p>


<h3>Value</h3>

<p><code>X</code> where the operation with <code>v</code> / <code>V</code> was performed on each row or column. All attributes of <code>X</code> are preserved.
</p>


<h3>Note</h3>

<p><em>Computations and Output:</em> These functions are all quite simple, they only work with <code>X</code> on the LHS i.e. <code>v %op% X</code> will likely fail. The row operations are simple wrappers around <code><a href="#topic+TRA">TRA</a></code> which provides more operations including grouped replacing and sweeping (where <code>v</code> would be a matrix or data frame with less rows than <code>X</code> being mapped to the rows of <code>X</code> by grouping vectors). One consequence is that just like <code><a href="#topic+TRA">TRA</a></code>, row-wise mathematical operations (+, -, *, /) always yield numeric output, even if both <code>X</code> and <code>v</code> may be integer. This is different for column- operations which depend on base R and may also preserve integer data.
</p>
<p><em>Rules of Arithmetic:</em> Since these operators are defined as simple infix functions, the normal rules of arithmetic are not respected. So <code>a %c+% b %c*% c</code> evaluates as <code>(a %c+% b) %c*% c</code>. As with all chained infix operations, they are just evaluated sequentially from left to right.
</p>
<p><em>Performance Notes:</em> The function <code><a href="#topic+setop">setop</a></code> and a related set of <code>%op=%</code> operators as well as the <code><a href="#topic+setTRA">setTRA</a></code> function can be used to perform these operations by reference, and are faster if copies of the output are not required!! Furthermore, for Fast Statistical Functions, using <code>fmedian(X, TRA = "-")</code> will be a tiny bit faster than <code>X %r-% fmedian(X)</code>. Also use <code>fwithin(X)</code> for fast centering using the mean, and <code>fscale(X)</code> for fast scaling and centering or mean-preserving scaling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setop">setop</a></code>, <code><a href="#topic+TRA">TRA</a></code>, <code><a href="#topic+dapply">dapply</a></code>, <a href="#topic+efficient-programming">Efficient Programming</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using data frame's / lists
v &lt;- mtcars$cyl
mtcars %cr% v
mtcars %c-% v
mtcars %r-% seq_col(mtcars)
mtcars %r-% lapply(mtcars, quantile, 0.28)

mtcars %c*% 5       # Significantly faster than mtcars * 5
mtcars %c*% mtcars  # Significantly faster than mtcars * mtcars

## Using matrices
X &lt;- qM(mtcars)
X %cr% v
X %c-% v
X %r-% dapply(X, quantile, 0.28)

## Chained Operations
library(magrittr) # Needed here to evaluate infix operators in sequence
mtcars %&gt;% fwithin() %r-% rnorm(11) %c*% 5 %&gt;%
    tfm(mpg = fsum(mpg)) %&gt;% qsu()

</code></pre>

<hr>
<h2 id='BY'>
Split-Apply-Combine Computing 
</h2><span id='topic+BY'></span><span id='topic+BY.default'></span><span id='topic+BY.matrix'></span><span id='topic+BY.data.frame'></span><span id='topic+BY.grouped_df'></span>

<h3>Description</h3>

<p><code>BY</code> is an S3 generic that efficiently applies functions over vectors or matrix- and data frame columns by groups. Similar to <code><a href="#topic+dapply">dapply</a></code> it seeks to retain the structure and attributes of the data, but can also output to various standard formats. A simple parallelism is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BY(x, ...)

## Default S3 method:
BY(x, g, FUN, ..., use.g.names = TRUE, sort = .op[["sort"]], reorder = TRUE,
   expand.wide = FALSE, parallel = FALSE, mc.cores = 1L,
   return = c("same", "vector", "list"))

## S3 method for class 'matrix'
BY(x, g, FUN, ..., use.g.names = TRUE, sort = .op[["sort"]], reorder = TRUE,
   expand.wide = FALSE, parallel = FALSE, mc.cores = 1L,
   return = c("same", "matrix", "data.frame", "list"))

## S3 method for class 'data.frame'
BY(x, g, FUN, ..., use.g.names = TRUE, sort = .op[["sort"]], reorder = TRUE,
   expand.wide = FALSE, parallel = FALSE, mc.cores = 1L,
   return = c("same", "matrix", "data.frame", "list"))

## S3 method for class 'grouped_df'
BY(x, FUN, ..., reorder = TRUE, keep.group_vars = TRUE, use.g.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BY_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame or alike object.</p>
</td></tr>
<tr><td><code id="BY_+3A_g">g</code></td>
<td>
<p>a <code><a href="#topic+GRP">GRP</a></code> object, or a factor / atomic vector / list of atomic vectors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="BY_+3A_fun">FUN</code></td>
<td>
<p>a function, can be scalar- or vector-valued. For vector valued functions see also <code>reorder</code> and <code>expand.wide</code>.</p>
</td></tr>
<tr><td><code id="BY_+3A_...">...</code></td>
<td>
<p>further arguments to <code>FUN</code>, or to <code>BY.data.frame</code> for the 'grouped_df' method. Since v1.9.0 data length arguments are also split by groups.</p>
</td></tr>
<tr><td><code id="BY_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). For vector-valued functions (row-)names are only generated if the function itself creates names for the statistics e.g. <code>quantile()</code> adds names, <code>range()</code> or <code>log()</code> don't. No row-names are generated on <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="BY_+3A_sort">sort</code></td>
<td>
<p>logical. Sort the groups? Internally passed to <code><a href="#topic+GRP">GRP</a></code>, and only effective if <code>g</code> is not already a factor or <code><a href="#topic+GRP">GRP</a></code> object.</p>
</td></tr>
<tr><td><code id="BY_+3A_reorder">reorder</code></td>
<td>
<p>logical. If a vector-valued function is passed that preserves the data length, <code>TRUE</code> will reorder the result such that the elements/rows match the original data. <code>FALSE</code> just combines the data in order of the groups (i.e. all elements of the first group in first-appearance order followed by all elements in the second group etc..). <em>Note</em> that if <code>reorder = FALSE</code>, grouping variables, names or rownames are only retained if the grouping is on sorted data, see <code><a href="#topic+GRP">GRP</a></code>. </p>
</td></tr>
<tr><td><code id="BY_+3A_expand.wide">expand.wide</code></td>
<td>
<p>logical. If <code>FUN</code> is a vector-valued function returning a vector of fixed length &gt; 1 (such as the <code><a href="stats.html#topic+quantile">quantile</a></code> function), <code>expand.wide</code> can be used to return the result in a wider format (instead of stacking the resulting vectors of fixed length above each other in each output column).</p>
</td></tr>
<tr><td><code id="BY_+3A_parallel">parallel</code></td>
<td>
<p>logical. <code>TRUE</code> implements simple parallel execution by internally calling <code><a href="parallel.html#topic+mclapply">mclapply</a></code> instead of <code><a href="base.html#topic+lapply">lapply</a></code>. Parallelism is across columns, except for the default method.</p>
</td></tr>
<tr><td><code id="BY_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer. Argument to <code><a href="parallel.html#topic+mclapply">mclapply</a></code> indicating the number of cores to use for parallel execution. Can use <code><a href="parallel.html#topic+detectCores">detectCores()</a></code> to select all available cores.</p>
</td></tr>
<tr><td><code id="BY_+3A_return">return</code></td>
<td>
<p>an integer or string indicating the type of object to return. The default <code>1 - "same"</code> returns the same object type (i.e. class and other attributes are retained if the underlying data type is the same, just the names for the dimensions are adjusted). <code>2 - "matrix"</code> always returns the output as matrix, <code>3 - "data.frame"</code> always returns a data frame and <code>4 - "list"</code> returns the raw (uncombined) output. <em>Note</em>: <code>4 - "list"</code> works together with <code>expand.wide</code> to return a list of matrices.</p>
</td></tr>
<tr><td><code id="BY_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation. See also the Note. </p>
</td></tr>

</table>


<h3>Details</h3>

<p><code>BY</code> is a re-implementation of the Split-Apply-Combine computing paradigm. It is faster than <code><a href="base.html#topic+tapply">tapply</a></code>, <code><a href="base.html#topic+by">by</a></code>, <code><a href="stats.html#topic+aggregate">aggregate</a></code> and <em>(d)plyr</em>, and preserves data attributes just like <code><a href="#topic+dapply">dapply</a></code>.  
</p>

<p>It is principally a wrapper around <code>lapply(gsplit(x, g), FUN, ...)</code>, that uses <code><a href="#topic+gsplit">gsplit</a></code> for optimized splitting and also strongly optimizes on the internal code compared to <em>base</em> R functions. For more details look at the documentation for <code><a href="#topic+dapply">dapply</a></code> which works very similar (apart from the splitting performed in <code>BY</code>). The function is intended for simple cases involving flexible computation of statistics across groups using a single function e.g. <code>iris |&gt; gby(Species) |&gt; BY(IQR)</code> is simpler than <code>iris |&gt; gby(Species) |&gt; smr(acr(.fns = IQR))</code> etc..
</p>



<h3>Value</h3>

<p><code>X</code> where <code>FUN</code> was applied to every column split by <code>g</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dapply">dapply</a></code>, <code><a href="#topic+collap">collap</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- iris$Sepal.Length   # A numeric vector
g &lt;- GRP(iris$Species)   # A grouping

## default vector method
BY(v, g, sum)                                # Sum by species
head(BY(v, g, scale))                        # Scale by species (please use fscale instead)
BY(v, g, fquantile)                          # Species quantiles: by default stacked
BY(v, g, fquantile, expand.wide = TRUE)      # Wide format

## matrix method
m &lt;- qM(num_vars(iris))
BY(m, g, sum)                          # Also return as matrix
BY(m, g, sum, return = "data.frame")   # Return as data.frame.. also works for computations below
head(BY(m, g, scale))
BY(m, g, fquantile)
BY(m, g, fquantile, expand.wide = TRUE)
ml &lt;- BY(m, g, fquantile, expand.wide = TRUE, # Return as list of matrices
         return = "list")
ml
# Unlisting to Data Frame
unlist2d(ml, idcols = "Variable", row.names = "Species")

## data.frame method
BY(num_vars(iris), g, sum)             # Also returns a data.fram
BY(num_vars(iris), g, sum, return = 2) # Return as matrix.. also works for computations below
head(BY(num_vars(iris), g, scale))
BY(num_vars(iris), g, fquantile)
BY(num_vars(iris), g, fquantile, expand.wide = TRUE)
BY(num_vars(iris), g, fquantile,       # Return as list of matrices
   expand.wide = TRUE, return = "list")

## grouped data frame method
giris &lt;- fgroup_by(iris, Species)
giris |&gt; BY(sum)                      # Compute sum
giris |&gt; BY(sum, use.g.names = TRUE,  # Use row.names and
             keep.group_vars = FALSE)  # remove 'Species' and groups attribute
giris |&gt; BY(sum, return = "matrix")   # Return matrix
giris |&gt; BY(sum, return = "matrix",   # Matrix with row.names
             use.g.names = TRUE)
giris |&gt; BY(.quantile)                # Compute quantiles (output is stacked)
giris |&gt; BY(.quantile, names = TRUE,  # Wide output
               expand.wide = TRUE)
</code></pre>

<hr>
<h2 id='collap'>
Advanced Data Aggregation
</h2><span id='topic+advanced-aggregation'></span><span id='topic+A5-advanced-aggregation'></span><span id='topic+collap'></span><span id='topic+collapv'></span><span id='topic+collapg'></span>

<h3>Description</h3>

<p><code>collap</code> is a fast and versatile multi-purpose data aggregation command.
</p>
<p>It performs simple and weighted aggregations, multi-type aggregations automatically applying different functions to numeric and categorical columns, multi-function aggregations applying multiple functions to each column, and fully custom aggregations where the user passes a list mapping functions to columns.
</p>




<h3>Usage</h3>

<pre><code class='language-R'># Main function: allows formula and data input to `by` and `w` arguments
collap(X, by, FUN = fmean, catFUN = fmode, cols = NULL, w = NULL, wFUN = fsum,
       custom = NULL, ..., keep.by = TRUE, keep.w = TRUE, keep.col.order = TRUE,
       sort = .op[["sort"]], decreasing = FALSE, na.last = TRUE, return.order = sort,
       method = "auto", parallel = FALSE, mc.cores = 2L,
       return = c("wide","list","long","long_dupl"), give.names = "auto")

# Programmer function: allows column names and indices input to `by` and `w` arguments
collapv(X, by, FUN = fmean, catFUN = fmode, cols = NULL, w = NULL, wFUN = fsum,
        custom = NULL, ..., keep.by = TRUE, keep.w = TRUE, keep.col.order = TRUE,
        sort = .op[["sort"]], decreasing = FALSE, na.last = TRUE, return.order = sort,
        method = "auto", parallel = FALSE, mc.cores = 2L,
        return = c("wide","list","long","long_dupl"), give.names = "auto")

# Auxiliary function: for grouped data ('grouped_df') input + non-standard evaluation
collapg(X, FUN = fmean, catFUN = fmode, cols = NULL, w = NULL, wFUN = fsum,
        custom = NULL, keep.group_vars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collap_+3A_x">X</code></td>
<td>
<p>a data frame, or an object coercible to data frame using <code><a href="#topic+qDF">qDF</a></code>.</p>
</td></tr>
<tr><td><code id="collap_+3A_by">by</code></td>
<td>
<p>for <code>collap</code>: a one-or two sided formula, i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>, or a atomic vector, list of vectors or <code><a href="#topic+GRP">GRP</a></code> object used to group <code>X</code>. For <code>collapv</code>: names or indices of grouping columns, or a logical vector or selector function such as <code><a href="#topic+is_categorical">is_categorical</a></code> selecting grouping columns.</p>
</td></tr>
<tr><td><code id="collap_+3A_fun">FUN</code></td>
<td>
<p>a function, list of functions (i.e. <code>list(fsum, fmean, fsd)</code> or <code>list(sd = fsd, myfun1 = function(x)..)</code>), or a character vector of function names, which are automatically applied only to numeric variables.</p>
</td></tr>
<tr><td><code id="collap_+3A_catfun">catFUN</code></td>
<td>
<p>same as <code>FUN</code>, but applied only to categorical (non-numeric) typed columns (<code><a href="#topic+is_categorical">is_categorical</a></code>).</p>
</td></tr>
<tr><td><code id="collap_+3A_cols">cols</code></td>
<td>
<p>select columns to aggregate using a function, column names, indices or logical vector. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="collap_+3A_w">w</code></td>
<td>
<p>weights. Can be passed as numeric vector or alternatively as formula i.e. <code>~ weightvar</code> in <code>collap</code> or column name / index etc. i.e. <code>"weightvar"</code> in <code>collapv</code>. <code>collapg</code> supports non-standard evaluations so <code>weightvar</code> can be indicated without quotes. </p>
</td></tr>
<tr><td><code id="collap_+3A_wfun">wFUN</code></td>
<td>
<p>same as <code>FUN</code>: Function(s) to aggregate weight variable if <code>keep.w = TRUE</code>. By default the sum of the weights is computed in each group.</p>
</td></tr>
<tr><td><code id="collap_+3A_custom">custom</code></td>
<td>
<p>a named list specifying a fully customized aggregation task. The names of the list are function names and the content columns to aggregate using this function (same input as <code>cols</code>). For example <code>custom = list(fmean = 1:6, fsd = 7:9, fmode = 10:11)</code> tells <code>collap</code> to aggregate columns 1-6 of <code>X</code> using the mean, columns 7-9 using the standard deviation etc. <em>Notes</em>: <code>custom</code> lets <code>collap</code> ignore any inputs passed to <code>FUN</code>, <code>catFUN</code> or <code>cols</code>. Since v1.6.0 you can also rename columns e.g. <code>custom = list(fmean = c(newname = "col1", "col2"), fmode = c(newname = 3))</code>.</p>
</td></tr>
<tr><td><code id="collap_+3A_keep.by">keep.by</code>, <code id="collap_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p>logical. <code>FALSE</code> will omit grouping variables from the output. <code>TRUE</code> keeps the variables, even if passed externally in a list or vector (unlike other <em>collapse</em> functions).</p>
</td></tr>
<tr><td><code id="collap_+3A_keep.w">keep.w</code></td>
<td>
<p>logical. <code>FALSE</code> will omit weight variable from the output i.e. no aggregation of the weights. <code>TRUE</code> aggregates and adds weights, even if passed externally as a vector (unlike other <em>collapse</em> functions).</p>
</td></tr>
<tr><td><code id="collap_+3A_keep.col.order">keep.col.order</code></td>
<td>
<p>logical. Retain original column order post-aggregation.</p>
</td></tr>
<tr><td><code id="collap_+3A_sort">sort</code>, <code id="collap_+3A_decreasing">decreasing</code>, <code id="collap_+3A_na.last">na.last</code>, <code id="collap_+3A_return.order">return.order</code>, <code id="collap_+3A_method">method</code></td>
<td>
<p>logical / character. Arguments passed to <code><a href="#topic+GRP.default">GRP.default</a></code> and affecting the row-order in the aggregated data frame and the grouping algorithm.</p>
</td></tr>
<tr><td><code id="collap_+3A_parallel">parallel</code></td>
<td>
<p>logical. Use <code><a href="parallel.html#topic+mclapply">mclapply</a></code> instead of <code>lapply</code> to parallelize the computation at the column level. Not available for Windows.</p>
</td></tr>
<tr><td><code id="collap_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer. Argument to <code><a href="parallel.html#topic+mclapply">mclapply</a></code> setting the number of cores to use, default is 2.</p>
</td></tr>
<tr><td><code id="collap_+3A_return">return</code></td>
<td>
<p>character. Control the output format when aggregating with multiple functions or performing custom aggregation. &quot;wide&quot; (default) returns a wider data frame with added columns for each additional function. &quot;list&quot; returns a list of data frames - one for each function. &quot;long&quot; adds a column &quot;Function&quot; and row-binds the results from different functions using <code>data.table::rbindlist</code>. &quot;long.dupl&quot; is a special option for aggregating multi-type data using multiple <code>FUN</code> but only one <code>catFUN</code> or vice-versa. In that case the format is long and data aggregated using only one function is duplicated. See Examples.</p>
</td></tr>
<tr><td><code id="collap_+3A_give.names">give.names</code></td>
<td>
<p>logical. Create unique names of aggregated columns by adding a prefix 'FUN.var'. <code>'auto'</code> will automatically create such prefixes whenever multiple functions are applied to a column. 
</p>
</td></tr>
<tr><td><code id="collap_+3A_...">...</code></td>
<td>
<p>additional arguments passed to all functions supplied to <code>FUN</code>, <code>catFUN</code>, <code>wFUN</code> or <code>custom</code>. Since v1.9.0 these are also split by groups for non-<a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>. The behavior of <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> with unused arguments is regulated by <code>option("collapse_unused_arg_action")</code> and defaults to <code>"warning"</code>. <code>collapg</code> also allows other arguments to <code>collap</code> except for <code>sort, decreasing, na.last, return.order, method</code> and <code>keep.by</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collap</code> automatically checks each function passed to it whether it is a <a href="#topic+fast-statistical-functions">Fast Statistical Function</a> (i.e. whether the function name is contained in <code>.FAST_STAT_FUN</code>). If the function is a fast statistical function, <code>collap</code> only does the grouping and then calls the function to carry out the grouped computations (vectorized in C/C++), resulting in high aggregation speeds, even with weights. If the function is not one of <code>.FAST_STAT_FUN</code>, <code><a href="#topic+BY">BY</a></code> is called internally to perform the computation. The resulting computations from each function are put into a list and recombined to produce the desired output format as controlled by the <code>return</code> argument. This is substantially slower, particularly with many groups.
</p>
<p>When setting <code>parallel = TRUE</code> on a non-windows computer, aggregations will efficiently be parallelized at the column level using <code><a href="parallel.html#topic+mclapply">mclapply</a></code> utilizing <code>mc.cores</code> cores. Some <a href="#topic+fast-statistical-functions">Fast Statistical Function</a> support multithreading i.e. have an <code>nthreads</code> argument that can be passed to <code>collap</code>. Using C-level multithreading is much more effective than R-level parallelism, and also works on Windows, but the two should never be combined.
</p>
<p>When the <code>w</code> argument is used, the weights are passed to all functions except for <code>wFUN</code>. This may be undesirable in settings like <code>collap(data, ~ id, custom = list(fsum = ..., fmean = ...), w = ~ weights)</code> where we wish to aggregate some columns using the weighted mean, and others using a simple sum or another unweighted statistic. 
Therefore it is possible to append <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> by <code>_uw</code> to yield an unweighted computation. So for the above example one can specify: <code>collap(data, ~ id, custom = list(fsum_uw = ..., fmean = ...), w = ~ weights)</code> to get the weighted mean and the simple sum. <em>Note</em> that the <code>_uw</code> functions are not available for use outside collap. Thus one also needs to quote them when passing to the <code>FUN</code> or <code>catFUN</code> arguments, e.g. use <code>collap(data, ~ id, fmean, "fmode_uw", w = ~ weights)</code>. 
</p>


<h3>Value</h3>

<p><code>X</code> aggregated. If <code>X</code> is not a data frame it is coerced to one using <code><a href="#topic+qDF">qDF</a></code> and then aggregated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsummarise">fsummarise</a></code>, <code><a href="#topic+BY">BY</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A Simple Introduction --------------------------------------
head(iris)
collap(iris, ~ Species)                                        # Default: FUN = fmean for numeric
collapv(iris, 5)                                               # Same using collapv
collap(iris, ~ Species, fmedian)                               # Using the median
collap(iris, ~ Species, fmedian, keep.col.order = FALSE)       # Groups in-front
collap(iris, Sepal.Width + Petal.Width ~ Species, fmedian)     # Only '.Width' columns
collapv(iris, 5, cols = c(2, 4))                               # Same using collapv
collap(iris, ~ Species, list(fmean, fmedian))                  # Two functions
collap(iris, ~ Species, list(fmean, fmedian), return = "long") # Long format
collapv(iris, 5, custom = list(fmean = 1:2, fmedian = 3:4))    # Custom aggregation
collapv(iris, 5, custom = list(fmean = 1:2, fmedian = 3:4),    # Raw output, no column reordering
        return = "list")
collapv(iris, 5, custom = list(fmean = 1:2, fmedian = 3:4),    # A strange choice..
        return = "long")
collap(iris, ~ Species, w = ~ Sepal.Length)                    # Using Sepal.Length as weights, ..
weights &lt;- abs(rnorm(fnrow(iris)))
collap(iris, ~ Species, w = weights)                           # Some random weights..
collap(iris, iris$Species, w = weights)                        # Note this behavior..
collap(iris, iris$Species, w = weights,
       keep.by = FALSE, keep.w = FALSE)



## Multi-Type Aggregation --------------------------------------
head(wlddev)                                                    # World Development Panel Data
head(collap(wlddev, ~ country + decade))                        # Aggregate by country and decade
head(collap(wlddev, ~ country + decade, fmedian, ffirst))       # Different functions
head(collap(wlddev, ~ country + decade, cols = is.numeric))     # Aggregate only numeric columns
head(collap(wlddev, ~ country + decade, cols = 9:13))           # Only the 5 series
head(collap(wlddev, PCGDP + LIFEEX ~ country + decade))         # Only GDP and life-expactancy
head(collap(wlddev, PCGDP + LIFEEX ~ country + decade, fsum))   # Using the sum instead
head(collap(wlddev, PCGDP + LIFEEX ~ country + decade, sum,     # Same using base::sum -&gt; slower!
            na.rm = TRUE))
head(collap(wlddev, wlddev[c("country","decade")], fsum,        # Same, exploring different inputs
            cols = 9:10))
head(collap(wlddev[9:10], wlddev[c("country","decade")], fsum))
head(collapv(wlddev, c("country","decade"), fsum))              # ..names/indices with collapv
head(collapv(wlddev, c(1,5), fsum))

g &lt;- GRP(wlddev, ~ country + decade)                            # Precomputing the grouping
head(collap(wlddev, g, keep.by = FALSE))                        # This is slightly faster now
# Aggregate categorical data using not the mode but the last element
head(collap(wlddev, ~ country + decade, fmean, flast))
head(collap(wlddev, ~ country + decade, catFUN = flast,         # Aggregate only categorical data
            cols = is_categorical))


## Weighted Aggregation ----------------------------------------
# We aggregate to region level using population weights
head(collap(wlddev, ~ region + year, w = ~ POP))                # Takes weighted mean for numeric..
# ..and weighted mode for categorical data. The weight vector is aggregated using fsum

head(collap(wlddev, ~ region + year, w = ~ POP,                 # Aggregating weights using sum
            wFUN = list(sum = fsum, max = fmax)))               # and max (corresponding to mode)


## Multi-Function Aggregation ----------------------------------
head(collap(wlddev, ~ country + decade, list(mean = fmean, N = fnobs),  # Saving mean and Nobs
            cols = 9:13))

head(collap(wlddev, ~ country + decade,                         # Same using base R -&gt; slower
            list(mean = mean,
                 N = function(x, ...) sum(!is.na(x))),
            cols = 9:13, na.rm = TRUE))

lapply(collap(wlddev, ~ country + decade,                       # List output format
       list(mean = fmean, N = fnobs), cols = 9:13, return = "list"), head)

head(collap(wlddev, ~ country + decade,                         # Long output format
     list(mean = fmean, N = fnobs), cols = 9:13, return = "long"))

head(collap(wlddev, ~ country + decade,                         # Also aggregating categorical data,
     list(mean = fmean, N = fnobs), return = "long_dupl"))      # and duplicating it 2 times

head(collap(wlddev, ~ country + decade,                         # Now also using 2 functions on
     list(mean = fmean, N = fnobs), list(mode = fmode, last = flast),   # categorical data
            keep.col.order = FALSE))

head(collap(wlddev, ~ country + decade,                         # More functions, string input,
            c("fmean","fsum","fnobs","fsd","fvar"),             # parallelized execution
            c("fmode","ffirst","flast","fndistinct"),           # (choose more than 1 cores,
            parallel = TRUE, mc.cores = 1L,                     # depending on your machine)
            keep.col.order = FALSE))


## Custom Aggregation ------------------------------------------
head(collap(wlddev, ~ country + decade,                         # Custom aggregation
            custom = list(fmean = 11:13, fsd = 9:10, fmode = 7:8)))

head(collap(wlddev, ~ country + decade,                         # Using column names
            custom = list(fmean = "PCGDP", fsd = c("LIFEEX","GINI"),
                          flast = "date")))

head(collap(wlddev, ~ country + decade,                         # Weighted parallelized custom
            custom = list(fmean = 9:12, fsd = 9:10,             # aggregation
                          fmode = 7:8), w = ~ POP,
            wFUN = list(fsum, fmax),
            parallel = TRUE, mc.cores = 1L))

head(collap(wlddev, ~ country + decade,                         # No column reordering
            custom = list(fmean = 9:12, fsd = 9:10,
                          fmode = 7:8), w = ~ POP,
            wFUN = list(fsum, fmax),
            parallel = TRUE, mc.cores = 1L, keep.col.order = FALSE))

## Piped Use --------------------------------------------------
iris |&gt; fgroup_by(Species) |&gt; collapg()
wlddev |&gt; fgroup_by(country, decade) |&gt; collapg() |&gt; head()
wlddev |&gt; fgroup_by(region, year) |&gt; collapg(w = POP) |&gt; head()
wlddev |&gt; fgroup_by(country, decade) |&gt; collapg(fmedian, flast) |&gt; head()
wlddev |&gt; fgroup_by(country, decade) |&gt;
  collapg(custom = list(fmean = 9:12, fmode = 5:7, flast = 3)) |&gt; head()
</code></pre>

<hr>
<h2 id='collapse-documentation'>Collapse Documentation &amp; Overview</h2><span id='topic+A0-collapse-documentation'></span><span id='topic+collapse-documentation'></span><span id='topic+.COLLAPSE_TOPICS'></span><span id='topic+.COLLAPSE_ALL'></span><span id='topic+.COLLAPSE_GENERIC'></span><span id='topic+.COLLAPSE_DATA'></span>

<h3>Description</h3>

<p>The following table fully summarizes the contents of <em><a href="#topic+collapse">collapse</a></em>. The documentation is structured hierarchically: This is the main overview page, linking to topical overview pages and associated function pages (unless functions are documented on the topic page). 
</p>


<h3>Topics and Functions</h3>


<table>
<tr>
 <td style="text-align: left;"> <em> Topic </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Main Features / Keywords</em> </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Functions </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 

  <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (grouped and weighted) statistical functions for vector, matrix, data frame and grouped data frames (class 'grouped_df', <em>dplyr</em> compatible).  </td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+fsum">fsum</a></code>, <code><a href="#topic+fprod">fprod</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmedian">fmedian</a></code>, <code><a href="#topic+fmode">fmode</a></code>, <code><a href="#topic+fvar">fvar</a></code>, <code><a href="#topic+fsd">fsd</a></code>, <code><a href="#topic+fmin">fmin</a></code>, <code><a href="#topic+fmax">fmax</a></code>, <code><a href="#topic+fnth">fnth</a></code>, <code><a href="#topic+ffirst">ffirst</a></code>, <code><a href="#topic+flast">flast</a></code>, <code><a href="#topic+fnobs">fnobs</a></code>, <code><a href="#topic+fndistinct">fndistinct</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (ordered) groupings from vectors, data frames, lists. 'GRP' objects are efficient inputs for programming with <em>collapse</em>'s fast functions. <code>fgroup_by</code> can attach them to a data frame, for fast dplyr-style grouped computations. Fast splitting of vectors based on 'GRP' objects. Fast radix-based ordering and hash-based grouping (the workhorses behind <code>GRP</code>). Fast matching (rows) and unique values/rows, group counts, factor generation, vector grouping, interactions, dropping unused factor levels, generalized run-length type grouping and grouping of integer sequences and time vectors.   
</td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+GRP">GRP</a></code>, <code><a href="#topic+as_factor_GRP">as_factor_GRP</a></code>, <code><a href="#topic+GRPN">GRPN</a></code>, <code><a href="#topic+GRPid">GRPid</a></code>, <code><a href="#topic+GRPnames">GRPnames</a></code>, <code><a href="#topic+is_GRP">is_GRP</a></code>, <code><a href="#topic+fgroup_by">fgroup_by</a></code>, <code><a href="#topic+fgroup_vars">fgroup_vars</a></code>, <code><a href="#topic+fungroup">fungroup</a></code>, <code><a href="#topic+gsplit">gsplit</a></code>, <code><a href="#topic+greorder">greorder</a></code>, <code><a href="#topic+radixorder">radixorder(v)</a></code>, <code><a href="#topic+group">group</a></code>, <code><a href="#topic+fmatch">fmatch</a></code>, <code><a href="#topic+ckmatch">ckmatch</a></code>, <code><a href="#topic+fmatch">%!in%</a></code>, <code><a href="#topic+fmatch">%[!]iin%</a></code>, <code><a href="#topic+funique">funique</a></code>,  <code><a href="#topic+fnunique">fnunique</a></code>, <code><a href="#topic+fduplicated">fduplicated</a></code>, <code><a href="#topic+any_duplicated">any_duplicated</a></code>, <code><a href="#topic+fcount">fcount(v)</a></code>, <code><a href="#topic+qF">qF</a></code>, <code><a href="#topic+qG">qG</a></code>, <code><a href="#topic+is_qG">is_qG</a></code>, <code><a href="#topic+finteraction">finteraction</a></code>, <code><a href="#topic+fdroplevels">fdroplevels</a></code>, <code><a href="#topic+groupid">groupid</a></code>, <code><a href="#topic+seqid">seqid</a></code>, <code><a href="#topic+timeid">timeid</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">




<a href="#topic+fast-data-manipulation">Fast Data Manipulation</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast and flexible select, subset, summarise, mutate/transform, sort/reorder, combine, join, reshape, rename and relabel data. Some functions modify by reference and/or allow assignment. In addition a set of (standard evaluation) functions for fast selecting, replacing or adding data frame columns, including shortcuts to select and replace variables by data type.
</td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+fselect">fselect(&lt;-)</a></code>, <code><a href="#topic+fsubset">fsubset/ss</a></code>, <code><a href="#topic+fsummarise">fsummarise</a></code>, <code><a href="#topic+fmutate">fmutate</a></code>, <code><a href="#topic+across">across</a></code>, <code><a href="#topic+ftransform">(f/set)transform(v)(&lt;-)</a></code>, <code><a href="#topic+fcompute">fcompute(v)</a></code>, <code><a href="#topic+roworder">roworder(v)</a></code>, <code><a href="#topic+colorder">colorder(v)</a></code>, <code><a href="#topic+rowbind">rowbind</a></code>, <code><a href="#topic+join">join</a></code>, <code><a href="#topic+pivot">pivot</a></code>, <code><a href="#topic+frename">(f/set)rename</a></code>, <code><a href="#topic+relabel">(set)relabel</a></code>, <code><a href="#topic+get_vars">get_vars(&lt;-)</a></code>, <code><a href="#topic+add_vars">add_vars(&lt;-)</a></code>, <code><a href="#topic+num_vars">num_vars(&lt;-)</a></code>, <code><a href="#topic+cat_vars">cat_vars(&lt;-)</a></code>, <code><a href="#topic+char_vars">char_vars(&lt;-)</a></code>, <code><a href="#topic+fact_vars">fact_vars(&lt;-)</a></code>, <code><a href="#topic+logi_vars">logi_vars(&lt;-)</a></code>, <code><a href="#topic+date_vars">date_vars(&lt;-)</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+quick-conversion">Quick Data Conversion</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Quick conversions: data.frame &lt;&gt; data.table &lt;&gt; tibble &lt;&gt; matrix (row- or column-wise) &lt;&gt; list | array &gt; matrix, data.frame, data.table, tibble | vector &gt; factor, matrix, data.frame, data.table, tibble; and converting factors / all factor columns. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>qDF</code>, <code>qDT</code>, <code>qTBL</code>, <code>qM</code>, <code>qF</code>, <code>mrtl</code>, <code>mctl</code>, <code>as_numeric_factor</code>, <code>as_character_factor</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+advanced-aggregation">Advanced Data Aggregation</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast and easy (weighted and parallelized) aggregation of multi-type data, with different functions applied to numeric and categorical variables. Custom specifications allow mappings of functions to variables + renaming. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>collap(v/g)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+data-transformations">Data Transformations</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast row- and column- arithmetic and (object preserving) apply functionality for vectors, matrices and data frames. Fast (grouped) replacing and sweeping of statistics (by reference) and (grouped and weighted) scaling / standardizing, (higher-dimensional) between- and within-transformations (i.e. averaging and centering), linear prediction and partialling out. 
</td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+arithmetic">%(r/c)r%</a></code>, <code><a href="#topic+arithmetic">%(r/c)(+/-/*//)%</a></code>, <code><a href="#topic+dapply">dapply</a></code>, <code><a href="#topic+BY">BY</a></code>, <code><a href="#topic+TRA">(set)TRA</a></code>, <code><a href="#topic+fscale">fscale/STD</a></code>, <code><a href="#topic+fbetween">fbetween/B</a></code>, <code><a href="#topic+fwithin">fwithin/W</a></code>, <code><a href="#topic+HDB">fhdbetween/HDB</a></code>, <code><a href="#topic+HDW">fhdwithin/HDW</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

Linear Models </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (weighted) linear model fitting with 6 different solvers and a fast F-test to test exclusion restrictions on linear models with (large) factors. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+flm">flm</a></code>, <code><a href="#topic+fFtest">fFtest</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+time-series-panel-series">Time Series and Panel Series</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast and class-agnostic indexed time series and panel data objects, check for irregularity in time series and panels, and efficient time-sequence to integer/factor conversion. Fast (sequences of) lags / leads and (lagged / leaded and iterated, quasi-, log-) differences, and (compounded) growth rates on (irregular) time series and panel data. Flexible cumulative sums. Panel data to array conversions. Multivariate panel- auto-, partial- and cross-correlation functions. 
</td><td style="text-align: left;"></td><td style="text-align: left;">
<code><a href="#topic+findex_by">findex_by</a></code>, <code><a href="#topic+findex">findex</a></code>, <code><a href="#topic+unindex">unindex</a></code>, <code><a href="#topic+reindex">reindex</a></code>, <code><a href="#topic+is_irregular">is_irregular</a></code>, <code><a href="#topic+to_plm">to_plm</a></code>, <code><a href="#topic+timeid">timeid</a></code>,
<code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code>, <code><a href="#topic+fgrowth">fgrowth/G</a></code>, <code><a href="#topic+fcumsum">fcumsum</a></code>, <code><a href="#topic+psmat">psmat</a></code>, <code><a href="#topic+psacf">psacf</a></code>, <code><a href="#topic+pspacf">pspacf</a></code>, <code><a href="#topic+psccf">psccf</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+summary-statistics">Summary Statistics</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (grouped and weighted) summary statistics for cross-sectional and panel data. Fast (weighted) cross tabulation. Efficient detailed description of data frame. Fast check of variation in data (within groups / dimensions). (Weighted) pairwise correlations and covariances (with obs. and p-value), pairwise observation count. 
</td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+qsu">qsu</a></code>, <code><a href="#topic+qtab">qtab</a></code>, <code><a href="#topic+descr">descr</a></code>, <code><a href="#topic+varying">varying</a></code>, <code><a href="#topic+pwcor">pwcor</a></code>, <code><a href="#topic+pwcov">pwcov</a></code>, <code><a href="#topic+pwnobs">pwnobs</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

Other Statistical </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast euclidean distance computations, (weighted) sample quantiles, and range of vector. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+fdist">fdist</a></code>, <code><a href="#topic+fquantile">fquantile</a></code>, <code><a href="#topic+frange">frange</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+list-processing">List Processing</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> (Recursive) list search and checks, extraction of list-elements / list-subsetting, fast (recursive) splitting, list-transpose, apply functions to lists of data frames / data objects, and generalized recursive row-binding / unlisting in 2-dimensions / to data frame.  </td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+is_unlistable">is_unlistable</a></code>, <code><a href="#topic+ldepth">ldepth</a></code>, <code><a href="#topic+has_elem">has_elem</a></code>, <code><a href="#topic+get_elem">get_elem</a></code>, <code><a href="#topic+atomic_elem">atomic_elem(&lt;-)</a></code>, <code><a href="#topic+list_elem">list_elem(&lt;-)</a></code>, <code><a href="#topic+reg_elem">reg_elem</a></code>, <code><a href="#topic+irreg_elem">irreg_elem</a></code>, <code><a href="#topic+rsplit">rsplit</a></code>, <code><a href="#topic+t_list">t_list</a></code>, <code><a href="#topic+rapply2d">rapply2d</a></code>, <code><a href="#topic+unlist2d">unlist2d</a></code>, <code><a href="#topic+rowbind">rowbind</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">





<a href="#topic+recode-replace">Recode and Replace Values</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Recode multiple values (exact or regex matching) and replace <code>NaN/Inf/-Inf</code> and outliers (according to 1- or 2-sided threshold or standard-deviations) in vectors, matrices or data frames. Insert a value at arbitrary positions into vectors, matrices or data frames. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>recode_num</code>, <code>recode_char</code>, <code>replace_na</code>, <code>replace_inf</code>, <code>replace_outliers</code>, <code><a href="#topic+pad">pad</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">


<a href="#topic+efficient-programming">(Memory) Efficient Programming</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Efficient comparisons of a vector/matrix with a value, and replacing values/rows in vector/matrix/DF (avoiding logical vectors or subsets), faster generation of initialized vectors, and fast mathematical operations on vectors/matrices/DF's with no copies at all. Fast missing value detection, (random) insertion and removal/replacement, lengths and C storage types, greatest common divisor of vector, <code>nlevels</code> for factors, <code>nrow</code>, <code>ncol</code>, <code>dim</code> (for data frames) and <code>seq_along</code> rows or columns. Fast vectorization of matrices and lists, and choleski inverse of symmetric PD matrix. </td><td style="text-align: left;"></td><td style="text-align: left;">
<code>anyv</code>, <code>allv</code>, <code>allNA</code>, <code>whichv</code>, <code>whichNA</code>, <code>%==%</code>,
<code>%!=%</code>, <code>copyv</code>, <code>setv</code>, <code>alloc</code>, <code>setop</code>, <code>%+=%</code>, <code>%-=%</code>, <code>%*=%</code>, <code>%/=%</code>, <code>missing_cases</code>, <code>na_insert</code>, <code>na_rm</code>, <code>na_locf</code>, <code>na_focb</code>, <code>na_omit</code>, <code>vlengths</code>, <code>vtypes</code>, <code>vgcd</code>, <code>fnlevels</code>, <code>fnrow</code>, <code>fncol</code>, <code>fdim</code>, <code>seq_row</code>, <code>seq_col</code>, <code>vec</code>, <code>cinv</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">

<a href="#topic+small-helpers">Small (Helper) Functions</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> Multiple-assignment, non-standard concatenation, set and extract variable labels and classes, display variable names and labels together, add / remove prefix or postfix to / from column names, check exact or near / numeric equality of multiple objects or of all elements in a list, get names of functions called in an expression, return object with dimnames, row- or colnames efficiently set, or with all attributes removed, C-level functions to set and shallow-copy attributes, identify categorical (non-numeric) and date(-time) objects. </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>massign</code>, <code>%=%</code>, <code>.c</code>, <code>vlabels(&lt;-)</code>, <code>setLabels</code>, <code>vclasses</code>, <code>namlab</code>, <code>add_stub</code>, <code>rm_stub</code>, <code>all_identical</code>, <code>all_obj_equal</code>, <code>all_funs</code>, <code>setDimnames</code>, <code>setRownames</code>, <code>setColnames</code>, <code>unattrib</code>, <code>setAttrib</code>, <code>setattrib</code>, <code>copyAttrib</code>, <code>copyMostAttrib</code>, <code>is_categorical</code>, <code>is_date</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">


Data and Global Macros </td><td style="text-align: left;"></td><td style="text-align: left;"> Groningen Growth and Development Centre 10-Sector Database, World Bank World Development dataset, and some global macros containing links to the topical documentation pages (including this page), all exported objects (excluding exported S3 methods and depreciated functions), all generic functions (excluding depreciated), the 2 datasets, depreciated functions, all fast functions, all fast statistical (scalar-valued) functions, and all transformation operators (these are not infix functions but function shortcuts resembling operators in a statistical sense, such as the lag/lead operators <code>L</code>/<code>F</code>, both wrapping <code>flag</code>, see <code><a href="#topic+.OPERATOR_FUN">.OPERATOR_FUN</a></code>).  </td><td style="text-align: left;"></td><td style="text-align: left;"> <code><a href="#topic+GGDC10S">GGDC10S</a>, <a href="#topic+wlddev">wlddev</a>, .COLLAPSE_TOPICS, .COLLAPSE_ALL, .COLLAPSE_GENERIC, .COLLAPSE_DATA, .COLLAPSE_OLD, .FAST_FUN, .FAST_STAT_FUN, .OPERATOR_FUN</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">


<a href="#topic+collapse-options">Package Options</a> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>set_collapse</code>/<code>get_collapse</code> can be used to globally set/get the defaults for <code>na.rm</code>, <code>nthreads</code> and <code>sort</code>, etc., arguments found in many functions, and to globally control the namespace with options 'mask' and 'remove': 'mask' can be used to mask base R/dplyr functions by export copies of equivalent <em>collapse</em> functions starting with <code>"f"</code>, removing the leading <code>"f"</code> (e.g. exporting <code>subset &lt;- fsubset</code>). 'remove' allows removing arbitrary functions from the exported namespace. <code>options("collapse_unused_arg_action")</code> sets the action taken by generic statistical functions when unknown arguments are passed to a method. The default is <code>"warning"</code>.  </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>set_collapse</code>, <code>get_collapse</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Details</h3>

<p>The added top-level documentation infrastructure in <em>collapse</em> allows you to effectively navigate the package. 
Calling <code>?FUN</code> brings up the documentation page documenting the function, which contains links to associated topic pages and closely related functions. You can also call topical documentation pages directly from the console. The links to these pages are contained in the global macro <code>.COLLAPSE_TOPICS</code> (e.g. calling <code>help(.COLLAPSE_TOPICS[1])</code> brings up this page).
</p>


<h3>Author(s)</h3>

<p><b>Maintainer</b>: Sebastian Krantz <a href="mailto:sebastian.krantz@graduateinstitute.ch">sebastian.krantz@graduateinstitute.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+collapse-package">collapse-package</a>
</p>

<hr>
<h2 id='collapse-options'><em>collapse</em> Package Options</h2><span id='topic+collapse-options'></span><span id='topic+AA4-collapse-options'></span><span id='topic+set_collapse'></span><span id='topic+get_collapse'></span><span id='topic+.op'></span>

<h3>Description</h3>

<p><em>collapse</em> is globally configurable to an extent few packages are: the default value of key function arguments governing the behavior of its algorithms, and the exported namespace, can be adjusted interactively through the <code>set_collapse()</code> function.
</p>
<p>These options are saved in an internal environment called <code>.op</code> (for safety and performance reasons) visible in the documentation of some functions such as <code><a href="#topic+fmean">fmean</a></code>. The contents of this environment can be accessed using <code>get_collapse()</code>.
</p>
<p>There are also a few options that can be set using <code><a href="base.html#topic+options">options</a></code> (retrievable using <code><a href="base.html#topic+getOption">getOption</a></code>). These options mainly affect package startup behavior.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>set_collapse(...)
get_collapse(opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse-options_+3A_...">...</code></td>
<td>
<p>either comma separated options, or a single list of options. The available options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>na.rm</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> logical, default <code>TRUE</code>. Sets the default for statistical algorithms such as the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> to skip missing values. If your data does not have missing values, or only in rare cases, it is recommended to change this to <code>FALSE</code> for performance gains. <em>Note</em> that this does not affect other (non-statistical) uses of <code>na.rm</code> arguments, such as in <code><a href="#topic+pivot">pivot</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>sort</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> logical, default <code>TRUE</code>. Sets the default for grouping operations to be sorted. This also applies to factor generation using <code><a href="#topic+qF">qF</a></code> and tabulation with <code><a href="#topic+qtab">qtab</a></code>, but excludes other uses of <code>sort</code> arguments where grouping is not the objective (such as in <code><a href="#topic+funique">funique</a></code> or <code><a href="#topic+pivot">pivot</a></code>). In general, sorted grouping (internally using <code><a href="#topic+radixorder">radixorder</a></code>) is slower than hash-based direct grouping (internally using <code><a href="#topic+group">group</a></code>). However, if data is pre-sorted, sorted grouping is slightly faster. In general, if records don't need to be sorted or you want to maintain their first-appearance order, changing this to <code>FALSE</code> is recommended and often brings substantial performance gains. <em>Note</em> that this also affects internal grouping applied when atomic vectors (except for factors) or lists are passed to <code>g</code> arguments in <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>nthreads</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> integer, default 1. Sets the default for OpenMP multithreading, available in certain statistical and data manipulation functions. Setting values greater than 1 is strongly recommended with larger datasets. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>stable.algo</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> logical, default <code>TRUE</code>. Option passed to <code><a href="#topic+fvar">fvar()/fsd()</a></code> and <code><a href="#topic+qsu">qsu()</a></code>. <code>FALSE</code> enables one-pass standard deviation calculation, which is very fast, but might incur catastrophic cancellation if numbers are large and the variance is small. see <code><a href="#topic+fvar">fvar</a></code> for details. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>stub</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> logical, default <code>TRUE</code>. Controls whether <a href="#topic+.OPERATOR_FUN">transformation operators</a> (<code>.OPERATOR_FUN</code>) such as <code><a href="#topic+W">W</a></code>, <code><a href="#topic+L">L</a></code>, <code><a href="#topic+STD">STD</a></code> etc. add prefixes to transformed columns of matrix and data.frame-like objects. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>verbose</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> integer, default <code>1</code>. Print additional (diagnostic) information or messages when executing code. Currently only used in <code><a href="#topic+join">join</a></code> and <code><a href="#topic+roworder">roworder</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>digits</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> integer, default <code>2</code>. Number of digits to print, e.g. in <code><a href="#topic+descr">descr</a></code> or <code><a href="#topic+pwcor">pwcor</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    <code>mask</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> character, default <code>NULL</code>. Allows masking existing base R/dplyr functions with faster <em>collapse</em> versions, by creating additional functions in the namespace and instantly exporting them: </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

    </td><td style="text-align: left;"></td><td style="text-align: left;"> For example <code>set_collapse(mask = "unique")</code> (or, equivalently, <code>set_collapse(mask = "funique")</code>) will create <code>unique &lt;- funique</code> in the <em>collapse</em> namespace, export <code>unique()</code>, and silently detach and attach the namespace again so R can find it - all in millisecond. Thus calling <code>unique()</code> afterwards uses the <em>collapse</em> version - which is many times faster. <code>funique</code> remains available and you can still call <code>base::unique</code> explicitly. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

  </td><td style="text-align: left;"></td><td style="text-align: left;"> All <em>collapse</em> functions starting with 'f' can be passed to the option (with or without the 'f') e.g. <code>set_collapse(mask = c("subset", "transform", "droplevels"))</code> creates <code>subset &lt;- fsubset</code>, <code>transform &lt;- ftransform</code> etc. Special functions are <code>"n"</code> and <code>"table"/"qtab"</code>, and <code>"%in%"</code>, which create <code>n &lt;- GRPN</code> (for use in <code>(f)summarise</code>/<code>(f)mutate</code>), <code>table &lt;- qtab</code>, and replace <code>%in%</code> with a fast version using <code><a href="#topic+fmatch">fmatch</a></code>, respectively. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

  </td><td style="text-align: left;"></td><td style="text-align: left;"> There are also a couple of convenience keywords that you can use to mask groups of functions: </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"manip"</code> adds data manipulation functions: <code>fsubset, ftransform, ftransform&lt;-, ftransformv, fcompute, fcomputev, fselect, fselect&lt;-, fgroup_by, fgroup_vars, fungroup, fsummarise, fsummarize, fmutate, frename, findex_by, findex</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"helper"</code> adds the functions: <code>fdroplevels</code>, <code>finteraction</code>, <code>fmatch</code>, <code>funique</code>, <code>fnunique</code>, <code>fduplicated</code>, <code>fcount</code>, <code>fcountv</code>, <code>fquantile</code>, <code>frange</code>, <code>fdist</code>, <code>fnlevels</code>, <code>fnrow</code> and <code>fncol</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"> 
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"special"</code> exports <code>n()</code>, <code>table()</code> and <code>%in%</code>. See above. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"fast-fun"</code> adds the functions contained in the macro: <code>.FAST_FUN</code>. See also Note. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"fast-stat-fun"</code> adds the functions contained in the macro: <code>.FAST_STAT_FUN</code>. See also Note. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"fast-trfm-fun"</code> adds the functions contained in: <code>setdiff(.FAST_FUN, .FAST_STAT_FUN)</code>. See also Note. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"all"</code> turns on all of the above.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">


</td><td style="text-align: left;"></td><td style="text-align: left;"> The re-attaching of the namespace places <em>collapse</em> at the top of the search path (after the global environment), implying that all its exported functions will take priority over other libraries. Users can use <code>fastverse::fastverse_conflicts()</code> to check which functions are masked following <code>set_collapse(mask = ...)</code>. The option can be changed at any time with immediate effect. Using <code>set_collapse(mask = NULL)</code> removes all masked functions from the namespace, and can also be called simply to place <em>collapse</em> at the top of the search path. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

 <code>remove</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> character, default <code>NULL</code>. Similar to 'mask': allows removing functions from the exported namespace (they are still in the namespace, just no longer exported). All <em>collapse</em> functions can be passed here. This argument is always evaluated after 'mask', thus you can also remove masked functions again i.e. after setting a keyword which masks a bunch of functions. There are also a couple of convenience keywords you can specify to bulk-remove certain functions:
</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"shorthand"</code> removes function shorthands: <code>gv, gv&lt;-, av, av&lt;-, nv, nv&lt;-, gvr, gvr&lt;-, itn, ix, slt, slt&lt;-, sbt, gby, iby, mtt, smr, tfm, tfmv, tfm&lt;-, settfm, settfmv, rnm</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"infix"</code> removes infix functions: <code>%!=%, %[!]in%, %[!]iin%, %*=%, %+=%, %-=%, %/=%, %=%, %==%, %c*%, %c+%, %c-%, %c/%, %cr%, %r*%, %r+%, %r-%, %r/%, %rr%</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"operator"</code> removes functions contained in the macro: <code>.OPERATOR_FUN</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"></td><td style="text-align: left;"> - <code>"old"</code> removes depreciated functions contained in the macro: <code>.COLLAPSE_OLD</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">


</td><td style="text-align: left;"></td><td style="text-align: left;"> Like 'mask', the option is alterable and reversible. Specifying <code>set_collapse(remove = NULL)</code> restores the exported namespace. Also like 'mask', this option silently detaches and attaches <em>collapse</em> again, ensuring that it is at the top of the search path.

 </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="collapse-options_+3A_opts">opts</code></td>
<td>
<p>character. A vector of options to receive from <code>.op</code>, or <code>NULL</code> for a list of all options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>set_collapse()</code> returns the old content of <code>.op</code> invisibly as a list. <code>get_collapse()</code>, if called with only one option, returns the value of the option, and otherwise a list.
</p>


<h3>Options Set Using <code>options()</code></h3>


<ul>
<li> <p><code>"collapse_unused_arg_action"</code> regulates how generic functions (such as the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>) in the package react when an unknown argument is passed to a method. The default action is <code>"warning"</code> which issues a warning. Other options are <code>"error"</code>, <code>"message"</code> or <code>"none"</code>, whereby the latter enables silent swallowing of such arguments.
</p>






</li>
<li> <p><code>"collapse_export_F"</code>, if set to <code>TRUE</code>, exports the lead operator <code>F</code> in the package namespace when loading the package. The operator was exported by default until v1.9.0, but is now hidden inside the package due to too many problems with <code>base::F</code>. Alternatively, the operator can be accessed using <code>collapse:::F</code>.
</p>

</li>
<li> <p><code>"collapse_nthreads"</code>, <code>"collapse_na_rm"</code>, <code>"collapse_sort"</code>, <code>"collapse_stable_algo"</code>, <code>"collapse_verbose"</code>, <code>"collapse_digits"</code>, <code>"collapse_mask"</code> and <code>"collapse_remove"</code> can be set before loading the package to initialize <code>.op</code> with different defaults (e.g. using an <code><a href="base.html#topic+.Rprofile">.Rprofile</a></code> file). Once loaded, these options have no effect, and users need to use <code>set_collapse()</code> to change them. See also the Note.
</p>
</li></ul>



<h3>Note</h3>

<p>Setting keywords &quot;fast-fun&quot;, &quot;fast-stat-fun&quot;, &quot;fast-trfm-fun&quot; or &quot;all&quot; with <code>set_collapse(mask = ...)</code> will also adjust internal optimization flags, e.g. in <code><a href="#topic+fsummarise">(f)summarise</a></code> and <code><a href="#topic+fmutate">(f)mutate</a></code>, so that these functions - and all expressions containing them - receive vectorized execution (see examples of <code><a href="#topic+fsummarise">(f)summarise</a></code> and <code><a href="#topic+fmutate">(f)mutate</a></code>). Users should be aware of expressions like <code>fmutate(mu = sum(var) / lenth(var))</code>: this usually gets executed by groups, but with these keywords set,this will be vectorized (like <code>fmutate(mu = fsum(var) / lenth(var))</code>) implying grouped sum divided by overall length. In this case <code>fmutate(mu = base::sum(var) / lenth(var))</code> needs to be specified to retain the original result.
</p>
<p><em>Note</em> that passing individual functions like <code>set_collapse(mask = "(f)sum")</code> will <b>not</b> change internal optimization flags for these functions. This is to ensure consistency i.e. you can be either all in (by setting appropriate keywords) or all out when it comes to vectorized stats with basic R names.
</p>
<p><em>Note</em> also that masking does not change documentation links, so you need to look up the f- version of a function to get the right documentation.
</p>
<p>A safe way to set options affecting startup behavior is by using a <code><a href="base.html#topic+.Rprofile">.Rprofile</a></code> file in your user or project directory (see also <a href="https://www.statmethods.net/interface/customizing.html">here</a>, the user-level file is located at <code>file.path(Sys.getenv("HOME"), ".Rprofile")</code> and can be edited using <code>file.edit(Sys.getenv("HOME"), ".Rprofile")</code>), or by using a <a href="https://fastverse.github.io/fastverse/articles/fastverse_intro.html#custom-fastverse-configurations-for-projects"><code>.fastverse</code></a> configuration file in the project directory.
</p>
<p><code>options("collapse_remove")</code> does in fact remove functions from the namespace and cannot be reversed by <code>set_collapse(remove = NULL)</code> once the package is loaded. It is only reversed by re-loading <em>collapse</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+collapse-package">collapse-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting new values
oldopts &lt;- set_collapse(nthreads = 2, na.rm = FALSE)

# Getting the values
get_collapse()
get_collapse("nthreads")

# Resetting
set_collapse(oldopts)
rm(oldopts)

## Not run: 
## This is a typical working setup I use:
library(fastverse)
# Loading other stats packages with fastverse_extend():
# displays versions, checks conflicts, and installs if unavailable
fastverse_extend(qs, fixest, grf, glmnet, install = TRUE)
# Now setting collapse options with some namespace modification
set_collapse(
  nthreads = 4,
  sort = FALSE,
  mask = c("manip", "helper", "special", "mean", "scale"),
  remove = "old"
)
# Final conflicts check (optional)
fastverse_conflicts()

# For some simpler scripts I also use
set_collapse(
  nthreads = 4,
  sort = FALSE,
  mask = "all",
  remove = c("old", "between") # I use data.table::between &gt; fbetween
)

# This is now collapse code
mtcars |&gt;
  subset(mpg &gt; 12) |&gt;
  group_by(cyl) |&gt;
  sum()

## End(Not run)

## Changing what happens with unused arguments
oldopts &lt;- options(collapse_unused_arg_action = "message") # default: "warning"
fmean(mtcars$mpg, bla = 1)

# Now nothing happens, same as base R
options(collapse_unused_arg_action = "none")
fmean(mtcars$mpg, bla = 1)
mean(mtcars$mpg, bla = 1)

options(oldopts)
rm(oldopts)
</code></pre>

<hr>
<h2 id='collapse-package'> 
Advanced and Fast Data Transformation
</h2><span id='topic+collapse-package'></span><span id='topic+collapse'></span>

<h3>Description</h3>

<p><em>collapse</em> is a C/C++ based package for data transformation and statistical computing in R. Its aims are:
</p>

<ul>
<li><p> To facilitate complex data transformation, exploration and computing tasks in R.
</p>
</li>
<li><p> To help make R code fast, flexible, parsimonious and programmer friendly. 

</p>
</li></ul>

<p>It is made compatible with the <em>tidyverse</em>, <em>data.table</em>, <em>sf</em> and the <em>plm</em> approach to panel data, and non-destructively handles other classes such as <em>xts</em>.
</p>


<h3>Getting Started</h3>

<p>Read the short <a href="https://sebkrantz.github.io/collapse/articles/collapse_documentation.html">vignette</a> on documentation resources, and check out the built in <a href="#topic+collapse-documentation">documentation</a>.  

</p>


<h3>Details</h3>


<p><em>collapse</em> provides an integrated suite of statistical and data manipulation functions that greatly extend and enhance the capabilities of base R. In a nutshell, <em>collapse</em> provides:
</p>

<ul>
<li><p> Fast C/C++ based (grouped, weighted) computations embedded in highly optimized R code.
</p>
</li>
<li><p> More complex statistical, time series / panel data and recursive (list-processing) operations.
</p>
</li>
<li><p> A flexible and generic approach supporting and preserving many R objects. 
</p>
</li>
<li><p> Optimized programming in standard and non-standard evaluation.
</p>
</li></ul>


<p>The statistical functions in <em>collapse</em> are S3 generic with core methods for vectors, matrices and data frames, and internally support grouped and weighted computations carried out in C/C++. 


</p>







<p>Additional methods and C-level features enable broad based compatibility with <em>dplyr</em> (grouped tibble), <em>data.table</em>, <em>sf</em> and <em>plm</em> panel data classes. Functions and core methods seek to preserve object attributes (including column attributes such as variable labels), ensuring flexibility and effective workflows with a very broad range of R objects (including most time-series classes). See also the <a href="https://sebkrantz.github.io/collapse/articles/collapse_object_handling.html">vignette</a> on <em>collapse</em>'s handling of R objects.
</p>
<p>Missing values are efficiently skipped at C/C++ level. The package default is <code>na.rm = TRUE</code>. This can be changed using <code><a href="#topic+set_collapse">set_collapse(na.rm = FALSE)</a></code>. Missing weights are generally supported. 
</p>


<p><em>collapse</em> installs with a built-in hierarchical <a href="#topic+collapse-documentation">documentation</a> facilitating the use of the package. 
</p>




<p>The package is coded both in C and C++ and built with <em>Rcpp</em>, but also uses C/C++ functions from <em>data.table</em>, <em>kit</em>, <em>fixest</em>, <em>weights</em>, <em>stats</em> and <em>RcppArmadillo / RcppEigen</em>. 

</p>


<h3>Author(s)</h3>

 
<p><b>Maintainer</b>: Sebastian Krantz <a href="mailto:sebastian.krantz@graduateinstitute.ch">sebastian.krantz@graduateinstitute.ch</a>
</p>
<p>Other contributors from packages <em>collapse</em> utilizes:
</p>

<ul>
<li><p> Matt Dowle, Arun Srinivasan and contributors worldwide (<em>data.table</em>)
</p>
</li>
<li><p> Dirk Eddelbuettel and contributors worldwide (<em>Rcpp</em>, <em>RcppArmadillo</em>, <em>RcppEigen</em>)
</p>
</li>
<li><p> Morgan Jacob (<em>kit</em>)
</p>
</li>
<li><p> Laurent Berge (<em>fixest</em>)
</p>
</li>
<li><p> Josh Pasek (<em>weights</em>)
</p>
</li>
<li><p> R Core Team and contributors worldwide (<em>stats</em>)
</p>
</li></ul>

<p>I thank many people from diverse fields for helpful answers on Stackoverflow, Joris Meys for encouraging me and helping to set up the <a href="https://github.com/SebKrantz/collapse">GitHub repository</a> for <em>collapse</em>, and many other people for feature requests and helpful suggestions.
</p>


<h3>Developing / Bug Reporting</h3>


<ul>
<li><p> Please report issues at <a href="https://github.com/SebKrantz/collapse/issues">https://github.com/SebKrantz/collapse/issues</a>.
</p>
</li>
<li><p> Please send pull-requests to the 'development' branch of the repository.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Note: this set of examples is is certainly non-exhaustive and does not
## showcase many recent features, but remains a very good starting point

## Let's start with some statistical programming
v &lt;- iris$Sepal.Length
d &lt;- num_vars(iris)    # Saving numeric variables
f &lt;- iris$Species      # Factor

# Simple statistics
fmean(v)               # vector
fmean(qM(d))           # matrix (qM is a faster as.matrix)
fmean(d)               # data.frame

# Preserving data structure
fmean(qM(d), drop = FALSE)     # Still a matrix
fmean(d, drop = FALSE)         # Still a data.frame

# Weighted statistics, supported by most functions...
w &lt;- abs(rnorm(fnrow(iris)))
fmean(d, w = w)

# Grouped statistics...
fmean(d, f)

# Groupwise-weighted statistics...
fmean(d, f, w)

# Simple Transformations...
head(fmode(d, TRA = "replace"))    # Replacing values with the mode
head(fmedian(d, TRA = "-"))        # Subtracting the median
head(fsum(d, TRA = "%"))           # Computing percentages
head(fsd(d, TRA = "/"))            # Dividing by the standard-deviation (scaling), etc...

# Weighted Transformations...
head(fnth(d, 0.75, w = w, TRA = "replace"))  # Replacing by the weighted 3rd quartile

# Grouped Transformations...
head(fvar(d, f, TRA = "replace"))  # Replacing values with the group variance
head(fsd(d, f, TRA = "/"))         # Grouped scaling
head(fmin(d, f, TRA = "-"))        # Setting the minimum value in each species to 0
head(fsum(d, f, TRA = "/"))        # Dividing by the sum (proportions)
head(fmedian(d, f, TRA = "-"))     # Groupwise de-median
head(ffirst(d, f, TRA = "%%"))     # Taking modulus of first group-value, etc. ...

# Grouped and weighted transformations...
head(fsd(d, f, w, "/"), 3)         # weighted scaling
head(fmedian(d, f, w, "-"), 3)     # subtracting the weighted group-median
head(fmode(d, f, w, "replace"), 3) # replace with weighted statistical mode

## Some more advanced transformations...
head(fbetween(d))                             # Averaging (faster t.: fmean(d, TRA = "replace"))
head(fwithin(d))                              # Centering (faster than: fmean(d, TRA = "-"))
head(fwithin(d, f, w))                        # Grouped and weighted (same as fmean(d, f, w, "-"))
head(fwithin(d, f, w, mean = 5))              # Setting a custom mean
head(fwithin(d, f, w, theta = 0.76))          # Quasi-centering i.e. d - theta*fbetween(d, f, w)
head(fwithin(d, f, w, mean = "overall.mean")) # Preserving the overall mean of the data
head(fscale(d))                               # Scaling and centering
head(fscale(d, mean = 5, sd = 3))             # Custom scaling and centering
head(fscale(d, mean = FALSE, sd = 3))         # Mean preserving scaling
head(fscale(d, f, w))                         # Grouped and weighted scaling and centering
head(fscale(d, f, w, mean = 5, sd = 3))       # Custom grouped and weighted scaling and centering
head(fscale(d, f, w, mean = FALSE,            # Preserving group means
            sd = "within.sd"))                # and setting group-sd to fsd(fwithin(d, f, w), w = w)
head(fscale(d, f, w, mean = "overall.mean",   # Full harmonization of group means and variances,
            sd = "within.sd"))                # while preserving the level and scale of the data.

head(get_vars(iris, 1:2))                      # Use get_vars for fast selecting, gv is shortcut
head(fhdbetween(gv(iris, 1:2), gv(iris, 3:5))) # Linear prediction with factors and covariates
head(fhdwithin(gv(iris, 1:2), gv(iris, 3:5)))  # Linear partialling out factors and covariates
ss(iris, 1:10, 1:2)                            # Similarly fsubset/ss for fast subsetting rows

# Simple Time-Computations..
head(flag(AirPassengers, -1:3))                # One lead and three lags
head(fdiff(EuStockMarkets,                     # Suitably lagged first and second differences
      c(1, frequency(EuStockMarkets)), diff = 1:2))
head(fdiff(EuStockMarkets, rho = 0.87))        # Quasi-differences (x_t - rho*x_t-1)
head(fdiff(EuStockMarkets, log = TRUE))        # Log-differences
head(fgrowth(EuStockMarkets))                  # Exact growth rates (percentage change)
head(fgrowth(EuStockMarkets, logdiff = TRUE))  # Log-difference growth rates (percentage change)
# Note that it is not necessary to use factors for grouping.
fmean(gv(mtcars, -c(2,8:9)), mtcars$cyl) # Can also use vector (internally converted using qF())
fmean(gv(mtcars, -c(2,8:9)),
      gv(mtcars, c(2,8:9)))              # or a list of vector (internally grouped using GRP())
g &lt;- GRP(mtcars, ~ cyl + vs + am)        # It is also possible to create grouping objects
print(g)                                 # These are instructive to learn about the grouping,
plot(g)                                  # and are directly handed down to C++ code
fmean(gv(mtcars, -c(2,8:9)), g)          # This can speed up multiple computations over same groups
fsd(gv(mtcars, -c(2,8:9)), g)

# Factors can efficiently be created using qF()
f1 &lt;- qF(mtcars$cyl)                     # Unlike GRP objects, factors are checked for NA's
f2 &lt;- qF(mtcars$cyl, na.exclude = FALSE) # This can however be avoided through this option
class(f2)                                # Note the added class

library(microbenchmark)
microbenchmark(fmean(mtcars, f1), fmean(mtcars, f2)) # A minor difference, larger on larger data

with(mtcars, finteraction(cyl, vs, am))  # Efficient interactions of vectors and/or factors
finteraction(gv(mtcars, c(2,8:9)))       # .. or lists of vectors/factors

# Simple row- or column-wise computations on matrices or data frames with dapply()
dapply(mtcars, quantile)                 # column quantiles
dapply(mtcars, quantile, MARGIN = 1)     # Row-quantiles
  # dapply preserves the data structure of any matrices / data frames passed
  # Some fast matrix row/column functions are also provided by the matrixStats package
# Similarly, BY performs grouped comptations
BY(mtcars, f2, quantile)
BY(mtcars, f2, quantile, expand.wide = TRUE)
# For efficient (grouped) replacing and sweeping out computed statistics, use TRA()
sds &lt;- fsd(mtcars)
head(TRA(mtcars, sds, "/"))     # Simple scaling (if sd's not needed, use fsd(mtcars, TRA = "/"))

microbenchmark(TRA(mtcars, sds, "/"), sweep(mtcars, 2, sds, "/")) # A remarkable performance gain..

sds &lt;- fsd(mtcars, f2)
head(TRA(mtcars, sds, "/", f2)) # Groupd scaling (if sd's not needed: fsd(mtcars, f2, TRA = "/"))

# All functions above perserve the structure of matrices / data frames
# If conversions are required, use these efficient functions:
mtcarsM &lt;- qM(mtcars)                      # Matrix from data.frame
head(qDF(mtcarsM))                         # data.frame from matrix columns
head(mrtl(mtcarsM, TRUE, "data.frame"))    # data.frame from matrix rows, etc..
head(qDT(mtcarsM, "cars"))                 # Saving row.names when converting matrix to data.table
head(qDT(mtcars, "cars"))                  # Same use a data.frame
 
## Now let's get some real data and see how we can use this power for data manipulation
head(wlddev) # World Bank World Development Data: 216 countries, 61 years, 5 series (columns 9-13)

# Starting with some discriptive tools...
namlab(wlddev, class = TRUE)           # Show variable names, labels and classes
fnobs(wlddev)                          # Observation count
pwnobs(wlddev)                         # Pairwise observation count
head(fnobs(wlddev, wlddev$country))    # Grouped observation count
fndistinct(wlddev)                     # Distinct values
descr(wlddev)                          # Describe data
varying(wlddev, ~ country)             # Show which variables vary within countries
qsu(wlddev, pid = ~ country,           # Panel-summarize columns 9 though 12 of this data
    cols = 9:12, vlabels = TRUE)       # (between and within countries)
qsu(wlddev, ~ region, ~ country,       # Do all of that by region and also compute higher moments
    cols = 9:12, higher = TRUE)        # -&gt; returns a 4D array
qsu(wlddev, ~ region, ~ country, cols = 9:12,
    higher = TRUE, array = FALSE) |&gt;                           # Return as a list of matrices..
unlist2d(c("Variable","Trans"), row.names = "Region") |&gt; head()# and turn into a tidy data.frame
pwcor(num_vars(wlddev), P = TRUE)                           # Pairwise correlations with p-value
pwcor(fmean(num_vars(wlddev), wlddev$country), P = TRUE)    # Correlating country means
pwcor(fwithin(num_vars(wlddev), wlddev$country), P = TRUE)  # Within-country correlations
psacf(wlddev, ~country, ~year, cols = 9:12)                 # Panel-data Autocorrelation function
pspacf(wlddev, ~country, ~year, cols = 9:12)                # Partial panel-autocorrelations
psmat(wlddev, ~iso3c, ~year, cols = 9:12) |&gt; plot()         # Convert panel to 3D array and plot

## collapse offers a few very efficent functions for data manipulation:
# Fast selecting and replacing columns
series &lt;- get_vars(wlddev, 9:12)     # Same as wlddev[9:12] but 2x faster
series &lt;- fselect(wlddev, PCGDP:ODA) # Same thing: &gt; 100x faster than dplyr::select
get_vars(wlddev, 9:12) &lt;- series     # Replace, 8x faster wlddev[9:12] &lt;- series + replaces names
fselect(wlddev, PCGDP:ODA) &lt;- series # Same thing

# Fast subsetting
head(fsubset(wlddev, country == "Ireland", -country, -iso3c))
head(fsubset(wlddev, country == "Ireland" &amp; year &gt; 1990, year, PCGDP:ODA))
ss(wlddev, 1:10, 1:10) # This is an order of magnitude faster than wlddev[1:10, 1:10]

# Fast transforming
head(ftransform(wlddev, ODA_GDP = ODA / PCGDP, ODA_LIFEEX = sqrt(ODA) / LIFEEX))
settransform(wlddev, ODA_GDP = ODA / PCGDP, ODA_LIFEEX = sqrt(ODA) / LIFEEX) # by reference
head(ftransform(wlddev, PCGDP = NULL, ODA = NULL, GINI_sum = fsum(GINI)))
head(ftransformv(wlddev, 9:12, log))                   # Can also transform with lists of columns
head(ftransformv(wlddev, 9:12, fscale, apply = FALSE)) # apply = FALSE invokes fscale.data.frame
settransformv(wlddev, 9:12, fscale, apply = FALSE)     # Changing the data by reference
ftransform(wlddev) &lt;- fscale(gv(wlddev, 9:12))         # Same thing (using replacement method)

library(magrittr) # Same thing, using magrittr
wlddev %&lt;&gt;% ftransformv(9:12, fscale, apply = FALSE)
wlddev %&gt;% ftransform(gv(., 9:12) |&gt;              # With compound pipes: Scaling and lagging
                        fscale() |&gt; flag(0:2, iso3c, year)) |&gt; head()

# Fast reordering
head(roworder(wlddev, -country, year))
head(colorder(wlddev, country, year))

# Fast renaming
head(frename(wlddev, country = Ctry, year = Yr))
setrename(wlddev, country = Ctry, year = Yr)     # By reference
head(frename(wlddev, tolower, cols = 9:12))

# Fast grouping
fgroup_by(wlddev, Ctry, decade) |&gt; fgroup_vars() |&gt; head()
rm(wlddev)                                       # .. but only works with collapse functions

## Now lets start putting things together
wlddev |&gt; fsubset(year &gt; 1990, region, income, PCGDP:ODA) |&gt;
  fgroup_by(region, income) |&gt; fmean()         # Fast aggregation using the mean

# Same thing using dplyr manipulation verbs
library(dplyr)
wlddev |&gt; filter(year &gt; 1990) |&gt; select(region, income, PCGDP:ODA) |&gt;
  group_by(region,income) |&gt; fmean()       # This is already a lot faster than summarize_all(mean)

wlddev |&gt; fsubset(year &gt; 1990, region, income, PCGDP:POP) |&gt;
  fgroup_by(region, income) |&gt; fmean(POP)     # Weighted group means

wlddev |&gt; fsubset(year &gt; 1990, region, income, PCGDP:POP) |&gt;
  fgroup_by(region, income) |&gt; fsd(POP)       # Weighted group standard deviations

wlddev |&gt; na_omit(cols = "POP") |&gt; fgroup_by(region, income) |&gt;
  fselect(PCGDP:POP) |&gt; fnth(0.75, POP)       # Weighted group third quartile

wlddev |&gt; fgroup_by(country) |&gt; fselect(PCGDP:ODA) |&gt;
  fwithin() |&gt; head()                         # Within transformation
wlddev |&gt; fgroup_by(country) |&gt; fselect(PCGDP:ODA) |&gt;
  fmedian(TRA = "-") |&gt; head()                # Grouped centering using the median
# Replacing data points by the weighted first quartile:
wlddev |&gt; na_omit(cols = "POP") |&gt; fgroup_by(country) |&gt;
  fselect(country, year, PCGDP:POP) %&gt;%
  ftransform(fselect(., -country, -year) |&gt;
             fnth(0.25, POP, "fill")) |&gt; head()

wlddev |&gt; fgroup_by(country) |&gt; fselect(PCGDP:ODA) |&gt; fscale() |&gt; head() # Standardizing
wlddev |&gt; fgroup_by(country) |&gt; fselect(PCGDP:POP) |&gt;
   fscale(POP) |&gt; head()  # Weighted..

wlddev |&gt; fselect(country, year, PCGDP:ODA) |&gt;  # Adding 1 lead and 2 lags of each variable
  fgroup_by(country) |&gt; flag(-1:2, year) |&gt; head()
wlddev |&gt; fselect(country, year, PCGDP:ODA) |&gt;  # Adding 1 lead and 10-year growth rates
  fgroup_by(country) |&gt; fgrowth(c(0:1,10), 1, year) |&gt; head()

# etc...

# Aggregation with multiple functions
wlddev |&gt; fsubset(year &gt; 1990, region, income, PCGDP:ODA) |&gt;
  fgroup_by(region, income) %&gt;% {
    add_vars(fgroup_vars(., "unique"),
             fmedian(., keep.group_vars = FALSE) |&gt; add_stub("median_"),
             fmean(., keep.group_vars = FALSE) |&gt; add_stub("mean_"),
             fsd(., keep.group_vars = FALSE) |&gt; add_stub("sd_"))
  } |&gt; head()

# Transformation with multiple functions
wlddev |&gt; fselect(country, year, PCGDP:ODA) |&gt;
  fgroup_by(country) %&gt;% {
    add_vars(fdiff(., c(1,10), 1, year) |&gt; flag(0:2, year),  # Sequence of lagged differences
             ftransform(., fselect(., PCGDP:ODA) |&gt; fwithin() |&gt; add_stub("W.")) |&gt;
               flag(0:2, year, keep.ids = FALSE))            # Sequence of lagged demeaned vars
  } |&gt; head()

# With ftransform, can also easily do one or more grouped mutations on the fly..
settransform(wlddev, median_ODA = fmedian(ODA, list(region, income), TRA = "fill"))

settransform(wlddev, sd_ODA = fsd(ODA, list(region, income), TRA = "fill"),
                     mean_GDP = fmean(PCGDP, country, TRA = "fill"))

wlddev %&lt;&gt;% ftransform(fmedian(list(median_ODA = ODA, median_GDP = PCGDP),
                               list(region, income), TRA = "fill"))

# On a groped data frame it is also possible to grouped transform certain columns
# but perform aggregate operatins on others:
wlddev |&gt; fgroup_by(region, income) %&gt;%
    ftransform(gmedian_GDP = fmedian(PCGDP, GRP(.), TRA = "replace"),
               omedian_GDP = fmedian(PCGDP, TRA = "replace"),  # "replace" preserves NA's
               omedian_GDP_fill = fmedian(PCGDP)) |&gt; tail()

rm(wlddev)

## For multi-type data aggregation, the function collap() offers ease and flexibility
# Aggregate this data by country and decade: Numeric columns with mean, categorical with mode
head(collap(wlddev, ~ country + decade, fmean, fmode))

# taking weighted mean and weighted mode:
head(collap(wlddev, ~ country + decade, fmean, fmode, w = ~ POP, wFUN = fsum))

# Multi-function aggregation of certain columns
head(collap(wlddev, ~ country + decade,
            list(fmean, fmedian, fsd),
            list(ffirst, flast), cols = c(3,9:12)))

# Customized Aggregation: Assign columns to functions
head(collap(wlddev, ~ country + decade,
            custom = list(fmean = 9:10, fsd = 9:12, flast = 3, ffirst = 6:8)))

# For grouped data frames use collapg
wlddev |&gt; fsubset(year &gt; 1990, country, region, income, PCGDP:ODA) |&gt;
  fgroup_by(country) |&gt; collapg(fmean, ffirst) |&gt;
  ftransform(AMGDP = PCGDP &gt; fmedian(PCGDP, list(region, income), TRA = "fill"),
             AMODA = ODA &gt; fmedian(ODA, income, TRA = "replace_fill")) |&gt; head()

## Additional flexibility for data transformation tasks is offerend by tidy transformation operators
# Within-transformation (centering on overall mean)
head(W(wlddev, ~ country, cols = 9:12, mean = "overall.mean"))
# Partialling out country and year fixed effects
head(HDW(wlddev, PCGDP + LIFEEX ~ qF(country) + qF(year)))
# Same, adding ODA as continuous regressor
head(HDW(wlddev, PCGDP + LIFEEX ~ qF(country) + qF(year) + ODA))
# Standardizing (scaling and centering) by country
head(STD(wlddev, ~ country, cols = 9:12))
# Computing 1 lead and 3 lags of the 4 series
head(L(wlddev, -1:3, ~ country, ~year, cols = 9:12))
# Computing the 1- and 10-year first differences
head(D(wlddev, c(1,10), 1, ~ country, ~year, cols = 9:12))
head(D(wlddev, c(1,10), 1:2, ~ country, ~year, cols = 9:12))     # ..first and second differences
# Computing the 1- and 10-year growth rates
head(G(wlddev, c(1,10), 1, ~ country, ~year, cols = 9:12))
# Adding growth rate variables to dataset
add_vars(wlddev) &lt;- G(wlddev, c(1, 10), 1, ~ country, ~year, cols = 9:12, keep.ids = FALSE)
get_vars(wlddev, "G1.", regex = TRUE) &lt;- NULL # Deleting again

# These operators can conveniently be used in regression formulas:
# Using a Mundlak (1978) procedure to estimate the effect of OECD on LIFEEX, controlling for PCGDP
lm(LIFEEX ~ log(PCGDP) + OECD + B(log(PCGDP), country),
   wlddev |&gt; fselect(country, OECD, PCGDP, LIFEEX) |&gt; na_omit())

# Adding 10-year lagged life-expectancy to allow for some convergence effects (dynamic panel model)
lm(LIFEEX ~ L(LIFEEX, 10, country) + log(PCGDP) + OECD + B(log(PCGDP), country),
   wlddev |&gt; fselect(country, OECD, PCGDP, LIFEEX) |&gt; na_omit())

# Tranformation functions and operators also support indexed data classes:
wldi &lt;- findex_by(wlddev, country, year)
head(W(wldi$PCGDP))                      # Country-demeaning
head(W(wldi, cols = 9:12))
head(W(wldi$PCGDP, effect = 2))          # Time-demeaning
head(W(wldi, effect = 2, cols = 9:12))
head(HDW(wldi$PCGDP))                    # Country- and time-demeaning
head(HDW(wldi, cols = 9:12))
head(STD(wldi$PCGDP))                    # Standardizing by country
head(STD(wldi, cols = 9:12))
head(L(wldi$PCGDP, -1:3))                # Panel-lags
head(L(wldi, -1:3, 9:12))
head(G(wldi$PCGDP))                      # Panel-Growth rates
head(G(wldi, 1, 1, 9:12))

lm(Dlog(PCGDP) ~ L(Dlog(LIFEEX), 0:3), wldi)   # Panel data regression
rm(wldi)

# Remove all objects used in this example section
rm(v, d, w, f, f1, f2, g, mtcarsM, sds, series, wlddev)
</code></pre>

<hr>
<h2 id='collapse-renamed'>
Renamed Functions
</h2><span id='topic+collapse-renamed'></span><span id='topic+.COLLAPSE_OLD'></span><span id='topic+fNobs'></span><span id='topic+fNobs.default'></span><span id='topic+fNobs.matrix'></span><span id='topic+fNobs.data.frame'></span><span id='topic+fNobs.grouped_df'></span><span id='topic+fNdistinct'></span><span id='topic+fNdistinct.default'></span><span id='topic+fNdistinct.matrix'></span><span id='topic+fNdistinct.data.frame'></span><span id='topic+fNdistinct.grouped_df'></span><span id='topic+pwNobs'></span><span id='topic+fHDwithin'></span><span id='topic+fHDwithin.default'></span><span id='topic+fHDwithin.matrix'></span><span id='topic+fHDwithin.data.frame'></span><span id='topic+fHDwithin.pseries'></span><span id='topic+fHDwithin.pdata.frame'></span><span id='topic+fHDwithin.grouped_df'></span><span id='topic+fHDbetween'></span><span id='topic+fHDbetween.default'></span><span id='topic+fHDbetween.matrix'></span><span id='topic+fHDbetween.data.frame'></span><span id='topic+fHDbetween.pseries'></span><span id='topic+fHDbetween.pdata.frame'></span><span id='topic+fHDbetween.grouped_df'></span><span id='topic+as.factor_GRP'></span><span id='topic+as.factor_qG'></span><span id='topic+is.GRP'></span><span id='topic+is.qG'></span><span id='topic+is.unlistable'></span><span id='topic+is.categorical'></span><span id='topic+is.Date'></span><span id='topic+as.character_factor'></span><span id='topic+as.numeric_factor'></span><span id='topic+Date_vars'></span><span id='topic+Date_vars+3C-'></span><span id='topic+replace_NA'></span><span id='topic+replace_Inf'></span>

<h3>Description</h3>

<p>These functions were renamed (mostly during v1.6.0 update) to make the namespace more consistent. Except for the S3 generics of <code>fNobs</code>, <code>fNdistinct</code>, <code>fHDbetween</code> and <code>fHDwithin</code>, and functions <code>replace_NA</code> and <code>replace_Inf</code>, I intend to remove all of these functions by end of 2023. 
</p>


<h3>Renaming</h3>

<pre>
fNobs -&gt; fnobs
fNdistinct -&gt; fndistinct
pwNobs -&gt; pwnobs
fHDwithin -&gt; fhdwithin
fHDbetween -&gt; fhdbetween
as.factor_GRP -&gt; as_factor_GRP
as.factor_qG -&gt; as_factor_qG
is.GRP -&gt; is_GRP
is.qG -&gt; is_qG
is.unlistable -&gt; is_unlistable
is.categorical -&gt; is_categorical
is.Date -&gt; is_date
as.numeric_factor -&gt; as_numeric_factor
as.character_factor -&gt; as_character_factor
Date_vars -&gt; date_vars
`Date_vars&lt;-` -&gt; `date_vars&lt;-`
replace_NA -&gt; replace_na
replace_Inf -&gt; replace_inf
</pre>

<hr>
<h2 id='colorder'>
Fast Reordering of Data Frame Columns
</h2><span id='topic+colorder'></span><span id='topic+colorderv'></span>

<h3>Description</h3>

<p>Efficiently reorder columns in a data frame. To do this fully by reference see also <code>data.table::setcolorder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorder(.X, ..., pos = "front")

colorderv(X, neworder = radixorder(names(X)),
          pos = "front", regex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorder_+3A_.x">.X</code>, <code id="colorder_+3A_x">X</code></td>
<td>
<p>a data frame or list.</p>
</td></tr>
<tr><td><code id="colorder_+3A_...">...</code></td>
<td>
<p>for <code>colorder</code>: Column names of <code>.X</code> in the new order (can also use sequences i.e. <code>col1:coln, newname = colk, ...</code>). For <code>colorderv</code>: Further arguments to <code><a href="base.html#topic+grep">grep</a></code> if <code>regex = TRUE</code>.</p>
</td></tr>
<tr><td><code id="colorder_+3A_neworder">neworder</code></td>
<td>
<p>a vector of column names, positive indices, a suitable logical vector, a function such as <code>is.numeric</code>, or a vector of regular expressions matching column names (if <code>regex = TRUE</code>). </p>
</td></tr>
<tr><td><code id="colorder_+3A_pos">pos</code></td>
<td>
<p>integer or character. Different options regarding column arrangement if <code>...length() &lt; ncol(.X)</code> (or <code>length(neworder) &lt; ncol(X)</code>).
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "front"   </td><td style="text-align: left;"></td><td style="text-align: left;"> move specified columns to the front (the default). </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "end" </td><td style="text-align: left;"></td><td style="text-align: left;"> move specified columns to the end. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "exchange"   </td><td style="text-align: left;"></td><td style="text-align: left;"> just exchange the positions of selected columns, other columns remain in the same position. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "after"  </td><td style="text-align: left;"></td><td style="text-align: left;"> place all further selected columns behind the first selected column. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="colorder_+3A_regex">regex</code></td>
<td>
<p>logical. <code>TRUE</code> will do regular expression search on the column names of <code>X</code> using a (vector of) regular expression(s) passed to <code>neworder</code>. Matching is done using <code><a href="base.html#topic+grep">grep</a></code>. <em>Note</em> that multiple regular expressions will be matched in the order they are passed, and <code><a href="#topic+funique">funique</a></code> will be applied to the resulting set of indices. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.X/X</code> with columns reordered (no deep copies).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roworder">roworder</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(colorder(mtcars, vs, cyl:hp, am))
head(colorder(mtcars, vs, cyl:hp, am, pos = "end"))
head(colorder(mtcars, vs, cyl:hp, am, pos = "after"))
head(colorder(mtcars, vs, cyl, pos = "exchange"))
head(colorder(mtcars, vs, cyl:hp, new = am))    # renaming

## Same in standard evaluation
head(colorderv(mtcars, c(8, 2:4, 9)))
head(colorderv(mtcars, c(8, 2:4, 9), pos = "end"))
head(colorderv(mtcars, c(8, 2:4, 9), pos = "after"))
head(colorderv(mtcars, c(8, 2), pos = "exchange"))
</code></pre>

<hr>
<h2 id='dapply'>
Data Apply
</h2><span id='topic+dapply'></span>

<h3>Description</h3>

<p><code>dapply</code> efficiently applies functions to columns or rows of matrix-like objects and by default returns an object of the same type and with the same attributes (unless the result is scalar and <code>drop = TRUE</code>). Alternatively it is possible to return the result in a plain matrix or data.frame. A simple parallelism is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dapply(X, FUN, ..., MARGIN = 2, parallel = FALSE, mc.cores = 1L,
       return = c("same", "matrix", "data.frame"), drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dapply_+3A_x">X</code></td>
<td>
<p>a matrix, data frame or alike object.</p>
</td></tr>
<tr><td><code id="dapply_+3A_fun">FUN</code></td>
<td>
<p>a function, can be scalar- or vector-valued.</p>
</td></tr>
<tr><td><code id="dapply_+3A_...">...</code></td>
<td>
<p>further arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="dapply_+3A_margin">MARGIN</code></td>
<td>
<p>integer. The margin which <code>FUN</code> will be applied over. Default <code>2</code> indicates columns while <code>1</code> indicates rows. See also Details. </p>
</td></tr>
<tr><td><code id="dapply_+3A_parallel">parallel</code></td>
<td>
<p>logical. <code>TRUE</code> implements simple parallel execution by internally calling <code><a href="parallel.html#topic+mclapply">mclapply</a></code> instead of <code><a href="base.html#topic+lapply">lapply</a></code>.</p>
</td></tr>
<tr><td><code id="dapply_+3A_mc.cores">mc.cores</code></td>
<td>
<p>integer. Argument to <code><a href="parallel.html#topic+mclapply">mclapply</a></code> indicating the number of cores to use for parallel execution. Can use <code><a href="parallel.html#topic+detectCores">detectCores()</a></code> to select all available cores.</p>
</td></tr>
<tr><td><code id="dapply_+3A_return">return</code></td>
<td>
<p>an integer or string indicating the type of object to return. The default <code>1 - "same"</code> returns the same object type (i.e. class and other attributes are retained, just the names for the dimensions are adjusted). <code>2 - "matrix"</code> always returns the output as matrix and <code>3 - "data.frame"</code> always returns a data frame.</p>
</td></tr>
<tr><td><code id="dapply_+3A_drop">drop</code></td>
<td>
<p>logical. If the result has only one row or one column, <code>drop = TRUE</code> will drop dimensions and return a (named) atomic vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dapply</code> is an efficient command to apply functions to rows or columns of data without loosing information (attributes) about the data or changing the classes or format of the data. It is principally an efficient wrapper around <code><a href="base.html#topic+lapply">lapply</a></code> and works as follows:
</p>

<ul>
<li><p> Save the attributes of <code>X</code>.
</p>
</li>
<li><p> If <code>MARGIN = 2</code> (columns), convert matrices to plain lists of columns using <code><a href="#topic+mctl">mctl</a></code> and remove all attributes from data frames.
</p>
</li>
<li><p> If <code>MARGIN = 1</code> (rows), convert matrices to plain lists of rows using <code><a href="#topic+mrtl">mrtl</a></code>. For data frames remove all attributes, efficiently convert to matrix using <code>do.call(cbind, X)</code> and also convert to list of rows using <code><a href="#topic+mrtl">mrtl</a></code>.
</p>
</li>
<li><p> Call <code><a href="base.html#topic+lapply">lapply</a></code> or <code><a href="parallel.html#topic+mclapply">mclapply</a></code> on these plain lists (which is faster than calling <code>lapply</code> on an object with attributes).
</p>
</li>
<li><p> depending on the requested output type, use <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+unlist">unlist</a></code> or <code><a href="base.html#topic+do.call">do.call(cbind, ...)</a></code> to convert the result back to a matrix or list of columns.
</p>
</li>
<li><p> modify the relevant attributes accordingly and efficiently attach to the object again (no further checks). 
</p>
</li></ul>

<p>The performance gain from working with plain lists makes <code>dapply</code> not much slower than calling <code>lapply</code> itself on a data frame. Because of the conversions involved, row-operations require some memory, but are still faster than <code><a href="base.html#topic+apply">apply</a></code>.
</p>


<h3>Value</h3>

<p><code>X</code> where <code>FUN</code> was applied to every row or column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BY">BY</a></code>, <code><a href="#topic+collap">collap</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(dapply(mtcars, log))                      # Take natural log of each variable
head(dapply(mtcars, log, return = "matrix"))   # Return as matrix
m &lt;- as.matrix(mtcars)
head(dapply(m, log))                           # Same thing
head(dapply(m, log, return = "data.frame"))    # Return data frame from matrix
dapply(mtcars, sum); dapply(m, sum)            # Computing sum of each column, return as vector
dapply(mtcars, sum, drop = FALSE)              # This returns a data frame of 1 row
dapply(mtcars, sum, MARGIN = 1)                # Compute row-sum of each column, return as vector
dapply(m, sum, MARGIN = 1)                     # Same thing for matrices, faster t. apply(m, 1, sum)
head(dapply(m, sum, MARGIN = 1, drop = FALSE)) # Gives matrix with one column
head(dapply(m, quantile, MARGIN = 1))          # Compute row-quantiles
dapply(m, quantile)                            # Column-quantiles
head(dapply(mtcars, quantile, MARGIN = 1))     # Same for data frames, output is also a data.frame
dapply(mtcars, quantile)

# With classed objects, we have to be a bit careful
## Not run: 
dapply(EuStockMarkets, quantile)  # This gives an error because the tsp attribute is misspecified

## End(Not run)
dapply(EuStockMarkets, quantile, return = "matrix")    # These both work fine..
dapply(EuStockMarkets, quantile, return = "data.frame")
 
# Similarly for grouped tibbles and other data frame based classes
library(dplyr)
gmtcars &lt;- group_by(mtcars,cyl,vs,am)
head(dapply(gmtcars, log))               # Still gives a grouped tibble back
dapply(gmtcars, quantile, MARGIN = 1)    # Here it makes sense to keep the groups attribute
dapply(gmtcars, quantile)                # This does not make much sense, ...
dapply(gmtcars, quantile,                # better convert to plain data.frame:
       return = "data.frame")

</code></pre>

<hr>
<h2 id='data-transformations'>Data Transformations</h2><span id='topic+A6-data-transformations'></span><span id='topic+data-transformations'></span><span id='topic+.OPERATOR_FUN'></span>

<h3>Description</h3>

<p><em>collapse</em> provides an ensemble of functions to perform common data transformations efficiently and user friendly:
</p>

<ul>
<li> <p><code><a href="#topic+dapply">dapply</a></code> <b>applies functions to rows or columns</b> of matrices and data frames, preserving the data format.
</p>
</li>
<li> <p><code><a href="#topic+BY">BY</a></code> is an S3 generic for efficient <b>Split-Apply-Combine computing</b>, similar to <code><a href="#topic+dapply">dapply</a></code>.
</p>
</li>
<li><p> A set of arithmetic operators facilitates <b>row-wise</b> <code><a href="#topic++25rr+25">%rr%</a></code>, <code><a href="#topic++25r+2B+25">%r+%</a></code>, <code><a href="#topic++25r-+25">%r-%</a></code>, <code><a href="#topic++25r+2A+25">%r*%</a></code>, <code><a href="#topic++25r+2F+25">%r/%</a></code> and
<b>column-wise</b> <code><a href="#topic++25cr+25">%cr%</a></code>, <code><a href="#topic++25c+2B+25">%c+%</a></code>, <code><a href="#topic++25c-+25">%c-%</a></code>, <code><a href="#topic++25c+2A+25">%c*%</a></code>, <code><a href="#topic++25c+2F+25">%c/%</a></code> <b>replacing and sweeping operations</b> involving a vector and a matrix or data frame / list. Since v1.7, the operators <code><a href="#topic++25+2B+3D+25">%+=%</a></code>, <code><a href="#topic++25-+3D+25">%-=%</a></code>, <code><a href="#topic++25+2A+3D+25">%*=%</a></code> and <code><a href="#topic++25+2F+3D+25">%/=%</a></code> do column- and element- wise math by reference, and the function <code><a href="#topic+setop">setop</a></code> can also perform sweeping out rows by reference.
</p>
</li>
<li> <p><code><a href="#topic+TRA">(set)TRA</a></code> is a more advanced S3 generic to efficiently perform <b>(groupwise) replacing and sweeping out of statistics</b>, either by creating a copy of the data or by reference. 
Supported operations are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Integer-id </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String-id </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                 0 </td><td style="text-align: left;"></td><td style="text-align: left;"> "na" or "replace_na"   </td><td style="text-align: left;"></td><td style="text-align: left;"> replace only missing values </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "fill" or "replace_fill"   </td><td style="text-align: left;"></td><td style="text-align: left;"> replace everything </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "replace" </td><td style="text-align: left;"></td><td style="text-align: left;"> replace data but preserve missing values </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-"   </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-+"  </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract group-statistics but add group-frequency weighted average of group statistics </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "/"   </td><td style="text-align: left;"></td><td style="text-align: left;"> divide </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "%"     </td><td style="text-align: left;"></td><td style="text-align: left;"> compute percentages </td>
</tr>
<tr>
 <td style="text-align: left;">
                 7 </td><td style="text-align: left;"></td><td style="text-align: left;"> "+" </td><td style="text-align: left;"></td><td style="text-align: left;"> add </td>
</tr>
<tr>
 <td style="text-align: left;">
                 8 </td><td style="text-align: left;"></td><td style="text-align: left;"> "*" </td><td style="text-align: left;"></td><td style="text-align: left;"> multiply </td>
</tr>
<tr>
 <td style="text-align: left;">
                 9 </td><td style="text-align: left;"></td><td style="text-align: left;"> "%%" </td><td style="text-align: left;"></td><td style="text-align: left;"> modulus </td>
</tr>
<tr>
 <td style="text-align: left;">
                 10 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-%%" </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract modulus

</td>
</tr>

</table>

<p>All of <em>collapse</em>'s <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> have a built-in <code>TRA</code> argument for faster access (i.e. you can compute (groupwise) statistics and use them to transform your data with a single function call).
</p>
</li>
<li> <p><code><a href="#topic+fscale">fscale/STD</a></code> is an S3 generic to perform (groupwise and / or weighted) <b>scaling / standardizing</b> of data and is orders of magnitude faster than <code><a href="base.html#topic+scale">scale</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+fwithin">fwithin/W</a></code> is an S3 generic to efficiently perform (groupwise and / or weighted) <b>within-transformations / demeaning / centering</b> of data. Similarly <code><a href="#topic+fbetween">fbetween/B</a></code> computes (groupwise and / or weighted) <b>between-transformations / averages</b> (also a lot faster than <code><a href="stats.html#topic+ave">ave</a></code>).
</p>
</li>
<li> <p><code><a href="#topic+HDW">fhdwithin/HDW</a></code>, shorthand for 'higher-dimensional within transform', is an S3 generic to efficiently <b>center data on multiple groups and partial-out linear models</b> (possibly involving many levels of fixed effects and interactions). In other words, <code><a href="#topic+HDW">fhdwithin/HDW</a></code> efficiently computes <b>residuals</b> from linear models. Similarly <code><a href="#topic+HDB">fhdbetween/HDB</a></code>, shorthand for 'higher-dimensional between transformation', computes the corresponding means or <b>fitted values</b>.
</p>

</li>
<li> <p><code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code> and <code><a href="#topic+fgrowth">fgrowth/G</a></code> are S3 generics to compute sequences of <b>lags / leads</b> and suitably lagged and iterated (quasi-, log-) <b>differences</b> and <b>growth rates</b> on time series and panel data. <code><a href="#topic+fcumsum">fcumsum</a></code> flexibly computes (grouped, ordered) cumulative sums. More in <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>.
</p>
</li>
<li> <p><code>STD, W, B, HDW, HDB, L, D, Dlog</code> and <code>G</code> are parsimonious wrappers around the <code>f-</code> functions above representing the corresponding transformation 'operators'. They have additional capabilities when applied to data-frames (i.e. variable selection, formula input, auto-renaming and id-variable preservation), and are easier to employ in regression formulas, but are otherwise identical in functionality.
</p>
</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> Function / S3 Generic </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Methods </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code><a href="#topic+dapply">dapply</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, works with matrices and data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Apply functions to rows or columns </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+BY">BY</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, grouped_df</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Split-Apply-Combine computing </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+arithmetic">%(r/c)(r/+/-/*//)%</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, works with matrices and data frames / lists </td><td style="text-align: left;"></td><td style="text-align: left;"> Row- and column-arithmetic </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+TRA">(set)TRA</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, grouped_df</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Replace and sweep out statistics (by reference) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fscale">fscale/STD</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Scale / standardize data </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fwithin">fwithin/W</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Demean / center data </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fbetween">fbetween/B</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute means / average data </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+HDW">fhdwithin/HDW</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> High-dimensional centering and lm residuals </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+HDB">fhdbetween/HDB</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> High-dimensional averages and lm fitted values </td>
</tr>
<tr>
 <td style="text-align: left;">
  
  <code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code>, <code><a href="#topic+fdiff">fgrowth/G</a></code>, <code><a href="#topic+fcumsum">fcumsum</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> (Sequences of) lags / leads, differences, growth rates and cumulative sums
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>
</p>

<hr>
<h2 id='descr'>
Detailed Statistical Description of Data Frame
</h2><span id='topic+descr'></span><span id='topic+descr.default'></span><span id='topic+descr.grouped_df'></span><span id='topic++5B.descr'></span><span id='topic+print.descr'></span><span id='topic+as.data.frame.descr'></span>

<h3>Description</h3>

<p><code>descr</code> offers a fast and detailed description of each variable in a data frame. Since v1.9.0 it fully supports grouped and weighted computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descr(X, ...)

## Default S3 method:
descr(X, by = NULL, w = NULL, cols = NULL,
      Ndistinct = TRUE, higher = TRUE, table = TRUE, sort.table = "freq",
      Qprobs = c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99), Qtype = 7L,
      label.attr = "label", stepwise = FALSE, ...)

## S3 method for class 'grouped_df'
descr(X, w = NULL,
      Ndistinct = TRUE, higher = TRUE, table = TRUE, sort.table = "freq",
      Qprobs = c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99), Qtype = 7L,
      label.attr = "label", stepwise = FALSE, ...)

## S3 method for class 'descr'
as.data.frame(x, ..., gid = "Group")

## S3 method for class 'descr'
print(x, n = 14, perc = TRUE, digits = .op[["digits"]], t.table = TRUE, total = TRUE,
      compact = FALSE, summary = !compact, reverse = FALSE, stepwise = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descr_+3A_x">X</code></td>
<td>

<p>a (grouped) data frame or list of atomic vectors. Atomic vectors, matrices or arrays can be passed but will first be coerced to data frame using <code><a href="#topic+qDF">qDF</a></code>.
</p>
</td></tr>
<tr><td><code id="descr_+3A_by">by</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+GRP">GRP</a></code>), or a one- or two-sided formula e.g. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code> to group <code>X</code>. See Examples.</p>
</td></tr>
<tr><td><code id="descr_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights. the default method also supports a one-sided formulas i.e. <code>~ weightcol</code> or <code>~ log(weightcol)</code>. The <code>grouped_df</code> method supports lazy-expressions (same without <code>~</code>). See Examples.</p>
</td></tr>
<tr><td><code id="descr_+3A_cols">cols</code></td>
<td>
<p>select columns to describe using column names, indices a logical vector or selector function (e.g. <code>is.numeric</code>). <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="descr_+3A_ndistinct">Ndistinct</code></td>
<td>

<p>logical. <code>TRUE</code> (default) computes the number of distinct values on all variables using <code><a href="#topic+fndistinct">fndistinct</a></code>.
</p>
</td></tr>
<tr><td><code id="descr_+3A_higher">higher</code></td>
<td>

<p>logical. Argument is passed down to <code><a href="#topic+qsu">qsu</a></code>: <code>TRUE</code> (default) computes the skewness and the kurtosis.
</p>
</td></tr>
<tr><td><code id="descr_+3A_table">table</code></td>
<td>

<p>logical. <code>TRUE</code> (default) computes a (sorted) frequency table for all categorical variables (excluding <a href="#topic+is_date">Date</a> variables).
</p>
</td></tr>
<tr><td><code id="descr_+3A_sort.table">sort.table</code></td>
<td>
<p>an integer or character string specifying how the frequency table should be presented:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "value"   </td><td style="text-align: left;"></td><td style="text-align: left;"> sort table by values. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "freq" </td><td style="text-align: left;"></td><td style="text-align: left;"> sort table by frequencies. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "none"   </td><td style="text-align: left;"></td><td style="text-align: left;"> return table in first-appearance order of values, or levels for factors (most efficient). </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="descr_+3A_qprobs">Qprobs</code></td>
<td>

<p>double. Probabilities for quantiles to compute on numeric variables, passed down to <code><a href="#topic+.quantile">.quantile</a></code>. If something non-numeric is passed (i.e. <code>NULL</code>, <code>FALSE</code>, <code>NA</code>, <code>""</code> etc.), no quantiles are computed.
</p>
</td></tr>
<tr><td><code id="descr_+3A_qtype">Qtype</code></td>
<td>

<p>integer. Quantile types 5-9 following Hyndman and Fan (1996) who recommended type 8, default 7 as in <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>
</td></tr>
<tr><td><code id="descr_+3A_label.attr">label.attr</code></td>
<td>

<p>character. The name of a label attribute to display for each variable (if variables are labeled).
</p>
</td></tr>
<tr><td><code id="descr_+3A_...">...</code></td>
<td>
<p>for <code>descr</code>: other arguments passed to <code><a href="#topic+qsu.default">qsu.default</a></code>. For <code>[.descr</code>: variable names or indices passed to <code>[.list</code>. The argument is unused in the <code>print</code> and <code>as.data.frame</code> methods.</p>
</td></tr>
<tr><td><code id="descr_+3A_x">x</code></td>
<td>
<p>an object of class 'descr'.</p>
</td></tr>
<tr><td><code id="descr_+3A_n">n</code></td>
<td>
<p>integer. The maximum number of table elements to print for categorical variables. If the number of distinct elements is <code>&lt;= n</code>, the whole table is printed. Otherwise the remaining items are summed into an '... %s Others' category.</p>
</td></tr>
<tr><td><code id="descr_+3A_perc">perc</code></td>
<td>
<p>logical. <code>TRUE</code> (default) adds percentages to the frequencies in the table for categorical variables, and, if <code>!is.null(by)</code>, the percentage of observations in each group.</p>
</td></tr>
<tr><td><code id="descr_+3A_digits">digits</code></td>
<td>
<p>integer. The number of decimals to print in statistics, quantiles and percentage tables.</p>
</td></tr>
<tr><td><code id="descr_+3A_t.table">t.table</code></td>
<td>
<p>logical. <code>TRUE</code> (default) prints a transposed table.</p>
</td></tr>
<tr><td><code id="descr_+3A_total">total</code></td>
<td>
<p>logical. <code>TRUE</code> (default) adds a 'Total' column for grouped tables (when using <code>by</code> argument).</p>
</td></tr>
<tr><td><code id="descr_+3A_compact">compact</code></td>
<td>
<p>logical. <code>TRUE</code> combines statistics and quantiles to generate a more compact printout. Especially useful with groups (<code>by</code>).</p>
</td></tr>
<tr><td><code id="descr_+3A_summary">summary</code></td>
<td>
<p>logical. <code>TRUE</code> (default) computes and displays a summary of the frequencies, if the size of the table for a categorical variable exceeds <code>n</code>.</p>
</td></tr>
<tr><td><code id="descr_+3A_reverse">reverse</code></td>
<td>
<p>logical. <code>TRUE</code> prints contents in reverse order, starting with the last column, so that the dataset can be analyzed by scrolling up the console after calling <code>descr</code>.</p>
</td></tr>
<tr><td><code id="descr_+3A_stepwise">stepwise</code></td>
<td>
<p>logical. <code>TRUE</code> prints one variable at a time. The user needs to press [enter] to see the printout for the next variable. If called from <code>descr</code>, the computation is also done one variable at a time, and the finished 'descr' object is returned invisibly. </p>
</td></tr>
<tr><td><code id="descr_+3A_gid">gid</code></td>
<td>
<p>character. Name assigned to the group-id column, when describing data by groups.</p>
</td></tr>


</table>


<h3>Details</h3>

<p><code>descr</code> was heavily inspired by <code>Hmisc::describe</code>, but is much faster and has more advanced statistical capabilities. It is principally a wrapper around <code><a href="#topic+qsu">qsu</a></code>, <code><a href="#topic+fquantile">fquantile</a></code> (<code>.quantile</code>), and <code><a href="#topic+fndistinct">fndistinct</a></code> for numeric variables, and computes frequency tables for categorical variables using <code><a href="#topic+qtab">qtab</a></code>. Date variables are summarized with <code><a href="#topic+fnobs">fnobs</a></code>, <code><a href="#topic+fndistinct">fndistinct</a></code> and <code><a href="#topic+frange">frange</a></code>.
</p>
<p>Since v1.9.0 grouped and weighted computations are fully supported. The use of sampling weights will produce a weighted mean, sd, skewness and kurtosis, and weighted quantiles for numeric data. For categorical data, tables will display the sum of weights instead of the frequencies, and percentage tables as well as the percentage of missing values indicated next to 'Statistics' in print, be relative to the total sum of weights. All this can be done by groups. Grouped (weighted) quantiles are computed using <code><a href="#topic+BY">BY</a></code>.
</p>
<p>For larger datasets, calling the <code>stepwise</code> option directly from <code>descr()</code> is recommended, as precomputing the statistics for all variables before digesting the results can be time consuming.

</p>
<p>The list-object returned from <code>descr</code> can efficiently be converted to a tidy data frame using the <code>as.data.frame</code> method. This representation will not include frequency tables computed for categorical variables. 
</p>


<h3>Value</h3>

<p>A 2-level nested list-based object of class 'descr'. The list has the same size as the dataset, and contains the statistics computed for each variable, which are themselves stored in a list containing the class, the label, the basic statistics and quantiles / tables computed for the variable (in matrix form).
</p>
<p>The object has attributes attached providing the 'name' of the dataset, the number of rows in the dataset ('N'), an attribute 'arstat' indicating whether arrays of statistics where generated by passing arguments (e.g. <code>pid</code>) down to <code>qsu.default</code>, an attribute 'table' indicating whether <code>table = TRUE</code> (i.e. the object could contain tables for categorical variables), and attributes 'groups' and/or 'weights' providing a <code><a href="#topic+GRP">GRP</a></code> object and/or weight vector for grouped and/or weighted data descriptions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qsu">qsu</a></code>, <code><a href="#topic+qtab">qtab</a></code>, <code><a href="#topic+fquantile">fquantile</a></code>, <code><a href="#topic+pwcor">pwcor</a></code>, <a href="#topic+summary-statistics">Summary Statistics</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Use
descr(iris)
descr(wlddev)
descr(GGDC10S)

# Some useful print options (also try stepwise argument)
print(descr(GGDC10S), reverse = TRUE, t.table = FALSE)
# For bigger data consider: descr(big_data, stepwise = TRUE)

# Generating a data frame
as.data.frame(descr(wlddev, table = FALSE))

## Weighted Desciptions
descr(wlddev, w = ~ replace_na(POP)) # replacing NA's with 0's for fquantile()

## Grouped Desciptions
descr(GGDC10S, ~ Variable)
descr(wlddev, ~ income)
print(descr(wlddev, ~ income), compact = TRUE)

## Grouped &amp; Weighted Desciptions
descr(wlddev, ~ income, w = ~ replace_na(POP))

## Passing Arguments down to qsu.default: for Panel Data Statistics
descr(iris, pid = iris$Species)
descr(wlddev, pid = wlddev$iso3c)

</code></pre>

<hr>
<h2 id='efficient-programming'>
Small Functions to Make R Programming More Efficient
</h2><span id='topic+AA2-efficient-programming'></span><span id='topic+efficient-programming'></span><span id='topic+anyv'></span><span id='topic+allv'></span><span id='topic+allNA'></span><span id='topic+whichv'></span><span id='topic+whichNA'></span><span id='topic+alloc'></span><span id='topic+copyv'></span><span id='topic+setv'></span><span id='topic+setop'></span><span id='topic++25+3D+3D+25'></span><span id='topic++25+21+3D+25'></span><span id='topic++25+2B+3D+25'></span><span id='topic++25-+3D+25'></span><span id='topic++25+2A+3D+25'></span><span id='topic++25+2F+3D+25'></span><span id='topic+cinv'></span><span id='topic+vec'></span><span id='topic+vlengths'></span><span id='topic+vtypes'></span><span id='topic+vgcd'></span><span id='topic+fnlevels'></span><span id='topic+fnrow'></span><span id='topic+fncol'></span><span id='topic+fdim'></span><span id='topic+missing_cases'></span><span id='topic+na_rm'></span><span id='topic+na_locf'></span><span id='topic+na_focb'></span><span id='topic+na_omit'></span><span id='topic+na_insert'></span><span id='topic+seq_row'></span><span id='topic+seq_col'></span>

<h3>Description</h3>

<p>A small set of functions to address some common inefficiencies in R, such as the creation of logical vectors to compare quantities, unnecessary copies of objects in elementary mathematical or subsetting operations, obtaining information about objects (esp. data frames), or dealing with missing values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anyv(x, value)              # Faster than any(x == value). See also kit::panyv()
allv(x, value)              # Faster than all(x == value). See also kit::pallv()
allNA(x)                    # Faster than all(is.na(x)). See also kit::pallNA()
whichv(x, value,            # Faster than which(x == value)
       invert = FALSE)      # or which(x != value). See also Note (3)
whichNA(x, invert = FALSE)  # Faster than which((!)is.na(x))
x %==% value                # Infix for whichv(v, value, FALSE), use e.g. in fsubset()
x %!=% value                # Infix for whichv(v, value, TRUE). See also Note (3)
alloc(value, n,             # Fast rep_len(value, n) or replicate(n, value).
      simplify = TRUE)      # simplify only works if length(value) == 1. See Details.
copyv(X, v, R, ..., invert  # Fast replace(X, v, R), replace(X, X (!/=)= v, R) or
    = FALSE, vind1 = FALSE, # replace(X, (!)v, R[(!)v]). See Details and Note (4).
    xlist = FALSE)          # For multi-replacement see also kit::vswitch()
setv(X, v, R, ..., invert   # Same for X[v] &lt;- r, X[x (!/=)= v] &lt;- r or
    = FALSE, vind1 = FALSE, # x[(!)v] &lt;- r[(!)v]. Modifies X by reference, fastest.
    xlist = FALSE)          # X/R/V can also be lists/DFs. See Details and Examples.
setop(X, op, V, ...,        # Faster than X &lt;- X +\-\*\/ V (modifies by reference)
      rowwise = FALSE)      # optionally can also add v to rows of a matrix or list
X %+=% V                    # Infix for setop(X, "+", V). See also Note (2)
X %-=% V                    # Infix for setop(X, "-", V). See also Note (2)
X %*=% V                    # Infix for setop(X, "*", V). See also Note (2)
X %/=% V                    # Infix for setop(X, "/", V). See also Note (2)
na_rm(x)                    # Fast: if(anyNA(x)) x[!is.na(x)] else x, last
na_locf(x, set = FALSE)     # obs. carried forward and first obs. carried back.
na_focb(x, set = FALSE)     # (by reference). These also support lists (NULL/empty)
na_omit(X, cols = NULL,     # Faster na.omit for matrices and data frames,
        na.attr = FALSE,    # can use selected columns to check, attach indices,
        prop = 0, ...)      # and remove cases with a proportion of values missing
na_insert(X, prop = 0.1,    # Insert missing values at random
          value = NA)
missing_cases(X, cols=NULL, # The opposite of complete.cases(), faster for DF's.
  prop = 0, count = FALSE)  # See also kit::panyNA(), kit::pallNA(), kit::pcountNA()
vlengths(X, use.names=TRUE) # Faster lengths() and nchar() (in C, no method dispatch)
vtypes(X, use.names = TRUE) # Get data storage types (faster vapply(X, typeof, ...))
vgcd(x)                     # Greatest common divisor of positive integers or doubles
fnlevels(x)                 # Faster version of nlevels(x) (for factors)
fnrow(X)                    # Faster nrow for data frames (not faster for matrices)
fncol(X)                    # Faster ncol for data frames (not faster for matrices)
fdim(X)                     # Faster dim for data frames (not faster for matrices)
seq_row(X)                  # Fast integer sequences along rows of X
seq_col(X)                  # Fast integer sequences along columns of X
vec(X)                      # Vectorization (stacking) of matrix or data frame/list
cinv(x)                     # Choleski (fast) inverse of symmetric PD matrix, e.g. X'X
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficient-programming_+3A_x">X</code>, <code id="efficient-programming_+3A_v">V</code>, <code id="efficient-programming_+3A_r">R</code></td>
<td>
<p>a vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_x">x</code>, <code id="efficient-programming_+3A_v">v</code></td>
<td>
<p>a (atomic) vector or matrix (<code>na_rm</code> also supports lists).</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_value">value</code></td>
<td>
<p>a single value of any (atomic) vector type. For <code>whichv</code> it can also be a <code>length(x)</code> vector.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_invert">invert</code></td>
<td>
<p>logical. <code>TRUE</code> considers elements <code>x != value</code>.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_set">set</code></td>
<td>
<p>logical. <code>TRUE</code> transforms <code>x</code> by reference.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_simplify">simplify</code></td>
<td>
<p>logical. If <code>value</code> is a length-1 atomic vector, <code>alloc()</code> with <code>simplify = TRUE</code> returns a length-n atomic vector. If <code>simplify = FALSE</code>, the result is always a list.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_vind1">vind1</code></td>
<td>
<p>logical. If <code>length(v) == 1L</code>, setting <code>vind1 = TRUE</code> will interpret <code>v</code> as an index, rather than a value to search and replace.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_xlist">xlist</code></td>
<td>
<p>logical. If <code>X</code> is a list, the default is to treat it like a data frame and replace rows. Setting <code>xlist = TRUE</code> will treat <code>X</code> and its replacement <code>R</code> like 1-dimensional list vectors.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_op">op</code></td>
<td>
<p>an integer or character string indicating the operation to perform.
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"+"</code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> add <code>V</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"-"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract <code>V</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"*"</code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> multiply by <code>V</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"/"</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> divide by <code>V</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</td></tr>
<tr><td><code id="efficient-programming_+3A_rowwise">rowwise</code></td>
<td>
<p>logical. <code>TRUE</code> performs the operation between <code>V</code> and each row of <code>X</code>.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_cols">cols</code></td>
<td>
<p>select columns to check for missing values using column names, indices, a logical vector or a function (e.g. <code>is.numeric</code>). The default is to check all columns, which could be inefficient.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_n">n</code></td>
<td>
<p>integer. The length of the vector to allocate with <code>value</code>.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_na.attr">na.attr</code></td>
<td>
<p>logical. <code>TRUE</code> adds an attribute containing the removed cases. For compatibility reasons this is exactly the same format as <code>na.omit</code> i.e. the attribute is called &quot;na.action&quot; and of class &quot;omit&quot;.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_prop">prop</code></td>
<td>
<p>double. For <code>na_insert</code>: the proportion of observations to be randomly replaced with <code>NA</code>. For <code>missing_cases</code> and <code>na_omit</code>: the proportion of values missing for the case to be considered missing (within <code>cols</code> if specified). For matrices this is implemented in R as <code>rowSums(is.na(X)) &gt;= max(as.integer(prop * ncol(X)), 1L)</code>. The C code for data frames works equivalently, and skips list- and raw-columns (<code>ncol(X)</code> is adjusted downwards).</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_count">count</code></td>
<td>
<p>logical. <code>TRUE</code> returns the row-wise missing value count (within <code>cols</code>). This ignores <code>prop</code>.</p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_use.names">use.names</code></td>
<td>
<p>logical. Preserve names if <code>X</code> is a list. </p>
</td></tr>
<tr><td><code id="efficient-programming_+3A_...">...</code></td>
<td>
<p>for <code>na_omit</code>: further arguments passed to <code>[</code> for vectors and matrices. With indexed data it is also possible to specify the <code>drop.index.levels</code> argument, see <a href="#topic+indexing">indexing</a>. For <code>copyv</code>, <code>setv</code> and <code>setop</code>, the argument is unused, and serves as a placeholder for possible future arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alloc</code> is a fusion of <code><a href="base.html#topic+rep_len">rep_len</a></code> and <code><a href="base.html#topic+replicate">replicate</a></code> that is faster in both cases. If <code>value</code> is a length one atomic vector (logical, integer, double, string, complex or raw) and <code>simplify = TRUE</code>, the functionality is as <code>rep_len(value, n)</code> i.e. the output is a length <code>n</code> atomic vector with the same attributes as <code>value</code> (apart from <code>"names"</code>, <code>"dim"</code> and <code>"dimnames"</code>). For all other cases the functionality is as <code>replicate(n, value, simplify = FALSE)</code> i.e. the output is a length-<code>n</code> list of the objects. For efficiency reasons the object is not copied i.e. only the pointer to the object is replicated.
</p>
<p><code>copyv</code> and <code>setv</code> are designed to optimize operations that require replacing data in objects in the broadest sense. The only difference between them is that <code>copyv</code> first deep-copies <code>X</code> before doing replacements whereas <code>setv</code> modifies <code>X</code> in place and returns the result invisibly. There are 3 ways these functions can be used:
</p>

<ol>
<li><p> To replace a single value, <code>setv(X, v, R)</code> is an efficient alternative to <code>X[X == v] &lt;- R</code>, and  <code>copyv(X, v, R)</code> is more efficient than <code>replace(X, X == v, R)</code>. This can be inverted using <code>setv(X, v, R, invert = TRUE)</code>, equivalent to <code>X[X != v] &lt;- R</code>.
</p>
</li>
<li><p> To do standard replacement with integer or logical indices i.e. <code>X[v] &lt;- R</code> is more efficient using <code>setv(X, v, R)</code>, and, if <code>v</code> is logical, <code>setv(X, v, R, invert = TRUE)</code> is efficient for <code>X[!v] &lt;- R</code>. To distinguish this from use case (1) when <code>length(v) == 1</code>, the argument <code>vind1 = TRUE</code> can be set to ensure that <code>v</code> is always interpreted as an index.
</p>
</li>
<li><p> To copy values from objects of equal size i.e. <code>setv(X, v, R)</code> is faster than <code>X[v] &lt;- R[v]</code>, and <code>setv(X, v, R, invert = TRUE)</code> is faster than <code>X[!v] &lt;- R[!v]</code>.
</p>
</li></ol>

<p>Both <code>X</code> and <code>R</code> can be atomic or data frames / lists. If <code>X</code> is a list, the default behavior is to interpret it like a data frame, and apply <code>setv/copyv</code> to each element/column of <code>X</code>. If <code>R</code> is also a list, this is done using <code><a href="base.html#topic+mapply">mapply</a></code>. Thus <code>setv/copyv</code> can also be used to replace elements or rows in data frames, or copy rows from equally sized frames. Note that for replacing subsets in data frames <code><a href="data.table.html#topic+set">set</a></code> from <code>data.table</code> provides a more convenient interface (and there is also <code><a href="data.table.html#topic+copy">copy</a></code> if you just want to deep-copy an object without any modifications to it).
</p>
<p>If <code>X</code> should not be interpreted like a data frame, setting <code>xlist = TRUE</code> will interpret it like a 1D list-vector analogous to atomic vectors, except that use case (1) is not permitted i.e. no value comparisons on list elements.

</p>



<h3>Note</h3>


<ol>
<li><p> None of these functions (apart from <code>alloc</code>) currently support complex vectors.
</p>
</li>
<li> <p><code>setop</code> and the operators <code>%+=%</code>, <code>%-=%</code>, <code>%*=%</code> and <code>%/=%</code> also work with integer data, but do not perform any integer related checks. R's integers are bounded between +-2,147,483,647 and <code>NA_integer_</code> is stored as the value -2,147,483,648. Thus computations resulting in values exceeding +-2,147,483,647 will result in integer overflows, and <code>NA_integer_</code> should not occur on either side of a <code>setop</code> call. These are programmers functions and meant to provide the most efficient math possible to responsible users.
</p>
</li>
<li><p> It is possible to compare factors by the levels (e.g. <code>iris$Species %==% "setosa")</code>) or using integers (<code>iris$Species %==% 1L</code>). The latter is slightly more efficient. Nothing special is implemented for other objects apart from basic types, e.g. for dates (which are stored as doubles) you need to generate a date object i.e. <code>wlddev$date %==% as.Date("2019-01-01")</code>. Using <code>wlddev$date %==% "2019-01-01"</code> will give <code>integer(0)</code>.
</p>
</li>
<li> <p><code>setv/copyv</code> only allow positive integer indices being passed to <code>v</code>, and, for efficiency reasons, they only check the first and the last index. Thus if there are indices in the middle that fall outside of the data range it will terminate R.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+small-helpers">Small (Helper) Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldopts &lt;- options(max.print = 70)
## Which value
whichNA(wlddev$PCGDP)                # Same as which(is.na(wlddev$PCGDP))
whichNA(wlddev$PCGDP, invert = TRUE) # Same as which(!is.na(wlddev$PCGDP))
whichv(wlddev$country, "Chad")       # Same as which(wlddev$county == "Chad")
wlddev$country %==% "Chad"           # Same thing
whichv(wlddev$country, "Chad", TRUE) # Same as which(wlddev$county != "Chad")
wlddev$country %!=% "Chad"           # Same thing
lvec &lt;- wlddev$country == "Chad"     # If we already have a logical vector...
whichv(lvec, FALSE)                  # is fastver than which(!lvec)
rm(lvec)

# Using the %==% operator can yield tangible performance gains
fsubset(wlddev, iso3c %==% "DEU") # 3x faster than:
fsubset(wlddev, iso3c == "DEU")

# With multiple categories we can use %iin%
fsubset(wlddev, iso3c %iin% c("DEU", "ITA", "FRA"))

## Math by reference: permissible types of operations
x &lt;- alloc(1.0, 1e5) # Vector
x %+=% 1
x %+=% 1:1e5
xm &lt;- matrix(alloc(1.0, 1e5), ncol = 100) # Matrix
xm %+=% 1
xm %+=% 1:1e3
setop(xm, "+", 1:100, rowwise = TRUE)
xm %+=% xm
xm %+=% 1:1e5
xd &lt;- qDF(replicate(100, alloc(1.0, 1e3), simplify = FALSE)) # Data Frame
xd %+=% 1
xd %+=% 1:1e3
setop(xd, "+", 1:100, rowwise = TRUE)
xd %+=% xd
rm(x, xm, xd)

## setv() and copyv()
x &lt;- rnorm(100)
y &lt;- sample.int(10, 100, replace = TRUE)
setv(y, 5, 0)            # Faster than y[y == 5] &lt;- 0
setv(y, 4, x)            # Faster than y[y == 4] &lt;- x[y == 4]
setv(y, 20:30, y[40:50]) # Faster than y[20:30] &lt;- y[40:50]
setv(y, 20:30, x)        # Faster than y[20:30] &lt;- x[20:30]
rm(x, y)

# Working with data frames, here returning copies of the frame
copyv(mtcars, 20:30, ss(mtcars, 10:20))
copyv(mtcars, 20:30, fscale(mtcars))
ftransform(mtcars, new = copyv(cyl, 4, vs))
# Column-wise:
copyv(mtcars, 2:3, fscale(mtcars), xlist = TRUE)
copyv(mtcars, 2:3, mtcars[4:5], xlist = TRUE)

## Missing values
mtc_na &lt;- na_insert(mtcars, 0.15)    # Set 15% of values missing at random
fnobs(mtc_na)                        # See observation count
missing_cases(mtc_na)                # Fast equivalent to !complete.cases(mtc_na)
missing_cases(mtc_na, cols = 3:4)    # Missing cases on certain columns?
missing_cases(mtc_na, count = TRUE)  # Missing case count
missing_cases(mtc_na, prop = 0.8)    # Cases with 80% or more missing
missing_cases(mtc_na, cols = 3:4, prop = 1)     # Cases mssing columns 3 and 4
missing_cases(mtc_na, cols = 3:4, count = TRUE) # Missing case count on columns 3 and 4

na_omit(mtc_na)                      # 12x faster than na.omit(mtc_na)
na_omit(mtc_na, prop = 0.8)          # Only remove cases missing 80% or more
na_omit(mtc_na, na.attr = TRUE)      # Adds attribute with removed cases, like na.omit
na_omit(mtc_na, cols = .c(vs, am))   # Removes only cases missing vs or am
na_omit(qM(mtc_na))                  # Also works for matrices
na_omit(mtc_na$vs, na.attr = TRUE)   # Also works with vectors
na_rm(mtc_na$vs)                     # For vectors na_rm is faster ...
rm(mtc_na)

## Efficient vectorization
head(vec(EuStockMarkets)) # Atomic objects: no copy at all
head(vec(mtcars))         # Lists: directly in C

options(oldopts)
</code></pre>

<hr>
<h2 id='fast-data-manipulation'>Fast Data Manipulation</h2><span id='topic+A3-fast-data-manipulation'></span><span id='topic+fast-data-manipulation'></span>

<h3>Description</h3>

<p><em>collapse</em> provides the following functions for fast manipulation of (mostly) data frames.
</p>

<ul>
<li> <p><code><a href="#topic+fselect">fselect</a></code> is a much faster alternative to <code>dplyr::select</code> to select columns using expressions involving column names. <code><a href="#topic+get_vars">get_vars</a></code> is a more versatile and programmer friendly function to efficiently select and replace columns by names, indices, logical vectors, regular expressions or using functions to identify columns.
</p>
</li>
<li><p> The functions <code><a href="#topic+num_vars">num_vars</a></code>, <code><a href="#topic+cat_vars">cat_vars</a></code>, <code><a href="#topic+char_vars">char_vars</a></code>, <code><a href="#topic+fact_vars">fact_vars</a></code>, <code><a href="#topic+logi_vars">logi_vars</a></code> and <code><a href="#topic+date_vars">date_vars</a></code> are convenience functions to efficiently select and replace columns by data type.
</p>
</li>
<li> <p><code><a href="#topic+add_vars">add_vars</a></code> efficiently adds new columns at any position within a data frame (default at the end). This can be done vie replacement (i.e. <code>add_vars(data) &lt;- newdata</code>) or returning the appended data (i.e. <code>add_vars(data, newdata1, newdata2, ...)</code>). Because of the latter, <code>add_vars</code> is also a more efficient alternative to <code>cbind.data.frame</code>.
</p>
</li>
<li> <p><code><a href="#topic+rowbind">rowbind</a></code> efficiently combines data frames / lists row-wise. The implementation is derived from <code>data.table::rbindlist</code>, it is also a fast alternative to <code>rbind.data.frame</code>.
</p>
</li>
<li> <p><code><a href="#topic+join">join</a></code> provides fast class-agnostic and verbose table joins.
</p>
</li>
<li> <p><code><a href="#topic+pivot">pivot</a></code> efficiently reshapes data, supporting longer, wider and recast pivoting, as well as multi-column-pivots and taking along variable labels.
</p>
</li>
<li> <p><code><a href="#topic+fsubset">fsubset</a></code> is a much faster version of <code><a href="base.html#topic+subset">subset</a></code> to efficiently subset vectors, matrices and data frames. If the non-standard evaluation offered by <code><a href="#topic+fsubset">fsubset</a></code> is not needed, the function <code><a href="#topic+ss">ss</a></code> is a much faster and also more secure alternative to <code>[.data.frame</code>.
</p>
</li>
<li> <p><code><a href="#topic+fsummarise">fsummarise</a></code> is a much faster version of <code>dplyr::summarise</code> when used together with the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> and <code><a href="#topic+fgroup_by">fgroup_by</a></code>, with whom it also supports super fast weighted aggregation.
</p>
</li>
<li> <p><code><a href="#topic+fmutate">fmutate</a></code> is a much faster version of <code>dplyr::mutate</code> when used together with the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> as well as fast <a href="#topic+data-transformations">Data Transformation Functions</a> and <code><a href="#topic+fgroup_by">fgroup_by</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+ftransform">ftransform</a></code> is a much faster version of <code><a href="base.html#topic+transform">transform</a></code>, which also supports list input and nested pipelines. <code><a href="#topic+settransform">settransform</a></code> does all of that by reference, i.e. it modifies the data frame in the global environment. <code><a href="#topic+fcompute">fcompute</a></code> is similar to <code><a href="#topic+ftransform">ftransform</a></code> but only returns modified and computed columns in a new data frame. 
</p>
</li>
<li> <p><code><a href="#topic+roworder">roworder</a></code> is a fast substitute for <code>dplyr::arrange</code>, but the syntax is inspired by <code>data.table::setorder</code>.
</p>
</li>
<li> <p><code><a href="#topic+colorder">colorder</a></code> efficiently reorders columns in a data frame, see also <code>data.table::setcolorder</code>.
</p>
</li>
<li> <p><code><a href="#topic+frename">frename</a></code> is a fast substitute for <code>dplyr::rename</code>, to efficiently rename various objects. <code><a href="#topic+setrename">setrename</a></code> renames objects by reference. <code><a href="#topic+relabel">relabel</a></code> and <code><a href="#topic+setrelabel">setrelabel</a></code> do the same thing for variable labels (see also <code><a href="#topic+vlabels">vlabels</a></code>).
</p>
</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> Function / S3 Generic </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Methods </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fselect">fselect(&lt;-)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast select or replace columns (non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+get_vars">get_vars(&lt;-)</a></code>, <code><a href="#topic+num_vars">num_vars(&lt;-)</a></code>, <code><a href="#topic+cat_vars">cat_vars(&lt;-)</a></code>, <code><a href="#topic+char_vars">char_vars(&lt;-)</a></code>, <code><a href="#topic+fact_vars">fact_vars(&lt;-)</a></code>, <code><a href="#topic+logi_vars">logi_vars(&lt;-)</a></code>, <code><a href="#topic+date_vars">date_vars(&lt;-)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast select or replace columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+add_vars">add_vars(&lt;-)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast add columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+rowbind">rowbind</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for lists of lists/data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast row-binding lists </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+join">join</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast table joins </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+pivot">pivot</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast reshaping </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fsubset">fsubset</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast subset data (non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+ss">ss</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast subset data frames </td>
</tr>
<tr>
 <td style="text-align: left;">

                 <code><a href="#topic+fsummarise">fsummarise</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast data aggregation </td>
</tr>
<tr>
 <td style="text-align: left;">

                <code><a href="#topic+fmutate">fmutate</a></code>, <code><a href="#topic+ftransform">(f/set)ftransform(&lt;-)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute, modify or delete columns (non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 
                 <code><a href="#topic+fcompute">fcompute(v)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute or modify columns, returned in a new data frame (non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+roworder">roworder(v)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames incl. pdata.frame </td><td style="text-align: left;"></td><td style="text-align: left;"> Reorder rows and return data frame (standard and non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+colorder">colorder(v)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Reorder columns and return data frame (standard and non-standard evaluation) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+frename">(f/set)rename</a></code>, <code><a href="#topic+frename">(set)relabel</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for all objects with 'names' attribute </td><td style="text-align: left;"></td><td style="text-align: left;"> Rename and return object / relabel columns in a data frame. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+quick-conversion">Quick Data Conversion</a>, <a href="#topic+recode-replace">Recode and Replace Values</a>
</p>

<hr>
<h2 id='fast-grouping-ordering'>Fast Grouping and Ordering</h2><span id='topic+A2-fast-grouping-ordering'></span><span id='topic+fast-grouping-ordering'></span>

<h3>Description</h3>

<p><em>collapse</em> provides the following functions to efficiently group and order data:
</p>

<ul>
<li> <p><code><a href="#topic+radixorder">radixorder</a></code>, provides fast radix-ordering through direct access to the method <code><a href="base.html#topic+order">order(..., method = &quot;radix&quot;)</a></code>, as well as the possibility to return some attributes very useful for grouping data and finding unique elements. <code><a href="#topic+radixorderv">radixorderv</a></code> exists as a programmers alternative. The function <code><a href="#topic+roworder">roworder(v)</a></code> efficiently reorders a data frame based on an ordering computed by <code><a href="#topic+radixorderv">radixorderv</a></code>. 

</p>
</li>
<li> <p><code><a href="#topic+group">group</a></code> provides fast grouping in first-appearance order of rows, based on a hashing algorithm in C. Objects have class 'qG', see below.
</p>
</li>
<li> <p><code><a href="#topic+GRP">GRP</a></code> creates <em>collapse</em> grouping objects of class 'GRP' based on <code><a href="#topic+radixorderv">radixorderv</a></code> or <code><a href="#topic+group">group</a></code>. 'GRP' objects form the central building block for grouped operations and programming in <em>collapse</em> and are very efficient inputs to all <em>collapse</em> functions supporting grouped operations. 
</p>
</li>
<li> <p><code><a href="#topic+fgroup_by">fgroup_by</a></code> provides a fast replacement for <code>dplyr::group_by</code>, creating a grouped data frame (or data.table / tibble etc.) with a 'GRP' object attached. This grouped frame can be used for grouped operations using <em>collapse</em>'s fast functions. 
</p>
</li>
<li> <p><code><a href="#topic+fmatch">fmatch</a></code> is a fast alternative to <code><a href="base.html#topic+match">match</a></code>, which also supports matching of data frame rows.
</p>
</li>
<li> <p><code><a href="#topic+funique">funique</a></code> is a faster version of <code><a href="base.html#topic+unique">unique</a></code>. The data frame method also allows selecting unique rows according to a subset of the columns. <code><a href="#topic+fnunique">fnunique</a></code> efficiently calculates the number of unique values/rows. <code><a href="#topic+fduplicated">fduplicated</a></code> is a fast alternative to <code><a href="base.html#topic+duplicated">duplicated</a></code>. <code><a href="#topic+any_duplicated">any_duplicated</a></code> is a simpler and faster alternative to <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+fcount">fcount</a></code> computes group counts based on a subset of columns in the data, and is a fast replacement for <code>dplyr::count</code>. <code><a href="#topic+fcountv">fcountv</a></code> is a programmers version of the function.
</p>
</li>
<li> <p><code><a href="#topic+qF">qF</a></code>, shorthand for 'quick-factor' implements very fast factor generation from atomic vectors using either radix ordering <code>method = "radix"</code> or hashing <code>method = "hash"</code>. Factors can also be used for efficient grouped programming with <em>collapse</em> functions, especially if they are generated using <code>qF(x, na.exclude = FALSE)</code> which assigns a level to missing values and attaches a class 'na.included' ensuring that no additional missing value checks are executed by <em>collapse</em> functions.
</p>
</li>
<li> <p><code><a href="#topic+qG">qG</a></code>, shorthand for 'quick-group', generates a kind of factor-light without the levels attribute but instead an attribute providing the number of levels. Optionally the levels / groups can be attached, but without converting them to character. Objects have a class 'qG', which is also recognized in the <em>collapse</em> ecosystem.
</p>
</li>
<li> <p><code><a href="#topic+fdroplevels">fdroplevels</a></code> is a substantially faster replacement for <code><a href="base.html#topic+droplevels">droplevels</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+finteraction">finteraction</a></code> is a fast alternative to <code><a href="base.html#topic+interaction">interaction</a></code> implemented as a wrapper around <code>as_factor_GRP(GRP(...))</code>. It can be used to generate a factor from multiple vectors, factors or a list of vectors / factors. Unused factor levels are always dropped.
</p>
</li>
<li> <p><code><a href="#topic+groupid">groupid</a></code> is a generalization of <code>data.table::rleid</code> providing a run-length type group-id from atomic vectors. It is generalization as it also supports passing an ordering vector and skipping missing values. For example <code><a href="#topic+qF">qF</a></code> and <code><a href="#topic+qG">qG</a></code> with <code>method = "radix"</code> are essentially implemented using <code>groupid(x, radixorder(x))</code>.
</p>
</li>
<li> <p><code><a href="#topic+seqid">seqid</a></code> is a specialized function which creates a group-id from sequences of integer values. For any regular panel dataset <code>groupid(id, order(id, time))</code> and <code>seqid(time, order(id, time))</code> provide the same id variable. <code><a href="#topic+seqid">seqid</a></code> is especially useful for identifying discontinuities in time-sequences.
</p>
</li>
<li> <p><code><a href="#topic+timeid">timeid</a></code> is a specialized function to convert integer or double vectors representing time (such as 'Date', 'POSIXct' etc.) to factor or 'qG' object based on the greatest common divisor of elements (thus preserving gaps in time intervals).
</p>
</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> Function / S3 Generic </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Methods </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+radixorder">radixorder(v)</a></code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames and vectors  </td><td style="text-align: left;"></td><td style="text-align: left;"> Radix-based ordering + grouping information </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+roworder">roworder(v)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames incl. pdata.frame </td><td style="text-align: left;"></td><td style="text-align: left;"> Row sorting/reordering </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+group">group</a></code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames and vectors  </td><td style="text-align: left;"></td><td style="text-align: left;"> Hash-based grouping + grouping information </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+GRP">GRP</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, GRP, factor, qG, grouped_df, pseries, pdata.frame</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast grouping and a flexible grouping object </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fgroup_by">fgroup_by</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast grouped data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fmatch">fmatch</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for vectors and data frames  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast matching </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+funique">funique</a></code>, <code><a href="#topic+fnunique">fnunique</a></code>, <code><a href="#topic+fduplicated">fduplicated</a></code>, <code><a href="#topic+any_duplicated">any_duplicated</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, data.frame, sf, pseries, pdata.frame, list</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (number of) unique values/rows </td>
</tr>
<tr>
 <td style="text-align: left;">
                <code><a href="#topic+fcount">fcount(v)</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Internal generic, supports vectors, matrices, data.frames, lists, grouped_df and pdata.frame </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast group counts </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+qF">qF</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Quick factor generation </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+qG">qG</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Quick grouping of vectors and a 'factor-light' class </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fdroplevels">fdroplevels</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>factor, data.frame, list</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast removal of unused factor levels </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+finteraction">finteraction</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames and vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast interactions </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+groupid">groupid</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Run-length type group-id </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+seqid">seqid</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for integer vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Run-length type integer sequence-id </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+timeid">timeid</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for integer or double vectors </td><td style="text-align: left;"></td><td style="text-align: left;"> Integer-id from time/date sequences </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>
</p>

<hr>
<h2 id='fast-statistical-functions'>Fast (Grouped, Weighted) Statistical Functions for Matrix-Like Objects</h2><span id='topic+A1-fast-statistical-functions'></span><span id='topic+fast-statistical-functions'></span><span id='topic+.FAST_STAT_FUN'></span><span id='topic+.FAST_FUN'></span>

<h3>Description</h3>

<p>With <code><a href="#topic+fsum">fsum</a></code>, <code><a href="#topic+fprod">fprod</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmedian">fmedian</a></code>, <code><a href="#topic+fmode">fmode</a></code>, <code><a href="#topic+fvar">fvar</a></code>, <code><a href="#topic+fsd">fsd</a></code>, <code><a href="#topic+fmin">fmin</a></code>, <code><a href="#topic+fmax">fmax</a></code>, <code><a href="#topic+fnth">fnth</a></code>, <code><a href="#topic+ffirst">ffirst</a></code>, <code><a href="#topic+flast">flast</a></code>, <code><a href="#topic+fnobs">fnobs</a></code> and <code><a href="#topic+fndistinct">fndistinct</a></code>, <em>collapse</em> presents a coherent set of extremely fast and flexible statistical functions (S3 generics) to perform column-wise, grouped and weighted computations on vectors, matrices and data frames, with special support for grouped data frames / tibbles (<em>dplyr</em>) and <em>data.table</em>'s.
</p>


<h3>Usage</h3>

<pre>
## All functions (FUN) follow a common syntax in 4 methods:
FUN(x, ...)

## Default S3 method:
FUN(x, g = NULL, [w = NULL,] TRA = NULL, [na.rm = TRUE,]
    use.g.names = TRUE, [nthreads = 1L,] ...)

## S3 method for class 'matrix'
FUN(x, g = NULL, [w = NULL,] TRA = NULL, [na.rm = TRUE,]
    use.g.names = TRUE, drop = TRUE, [nthreads = 1L,] ...)

## S3 method for class 'data.frame'
FUN(x, g = NULL, [w = NULL,] TRA = NULL, [na.rm = TRUE,]
    use.g.names = TRUE, drop = TRUE, [nthreads = 1L,] ...)

## S3 method for class 'grouped_df'
FUN(x, [w = NULL,] TRA = NULL, [na.rm = TRUE,]
    use.g.names = FALSE, keep.group_vars = TRUE,
    [keep.w = TRUE,] [stub = TRUE,] [nthreads = 1L,] ...)
</pre>


<h3>Arguments</h3>


<table>
<tr>
 <td style="text-align: left;">
<code>x</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> a vector, matrix, data frame or grouped data frame (class 'grouped_df'). </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>g</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>w</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> a numeric vector of (non-negative) weights, may contain missing values. Supported by <code><a href="#topic+fsum">fsum</a></code>, <code><a href="#topic+fprod">fprod</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmedian">fmedian</a></code>, <code><a href="#topic+fnth">fnth</a></code>, <code><a href="#topic+fvar">fvar</a></code>, <code><a href="#topic+fsd">fsd</a></code> and <code><a href="#topic+fmode">fmode</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>TRA</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> an integer or quoted operator indicating the transformation to perform:
0 - "na"     |     1 - "fill"     |     2 - "replace"     |     3 - "-"     |     4 - "-+"     |     5 - "/"     |     6 - "%"     |     7 - "+"     |     8 - "*"     |     9 - "%%"     |     10 - "-%%". See <code><a href="#topic+TRA">TRA</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>na.rm</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> in all functions and implemented at very little computational cost. Not available for <code><a href="#topic+fnobs">fnobs</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>use.g.names</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>nthreads</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> integer. The number of threads to utilize. Supported by <code><a href="#topic+fsum">fsum</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmedian">fmedian</a></code>, <code><a href="#topic+fnth">fnth</a></code>, <code><a href="#topic+fmode">fmode</a></code> and <code><a href="#topic+fndistinct">fndistinct</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>drop</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <em>matrix and data.frame methods:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>keep.group_vars</code>  </td><td style="text-align: left;"> </td><td style="text-align: left;"> <em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation. By default grouping variables are added, even if not present in the grouped_df. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>keep.w</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <em>grouped_df method:</em> Logical. <code>TRUE</code> (default) also aggregates weights and saves them in a column, <code>FALSE</code> removes weighting variable after computation (if contained in <code>grouped_df</code>). </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>stub</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> <em>grouped_df method:</em> Character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the aggregated weights column is prefixed by the name of the aggregation function (mostly <code>"sum."</code>). Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>...</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly (except for the grouped_df method which always returns visible output). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Please see the documentation of individual functions.
</p>


<h3>Value</h3>

<p><code>x</code> suitably aggregated or transformed. Data frame column-attributes and overall attributes are generally preserved if the output is of the same data type.
</p>


<h3>Related Functionality</h3>


<ul>
<li><p> Functions <code><a href="#topic+fquantile">fquantile</a></code> and <code><a href="#topic+frange">frange</a></code> are for atomic vectors.
</p>
</li>
<li><p> Panel-decomposed (i.e. between and within) statistics as well as grouped and weighted skewness and kurtosis are implemented in <code><a href="#topic+qsu">qsu</a></code>.
</p>
</li>
<li><p> The vector-valued functions and operators <code><a href="#topic+fcumsum">fcumsum</a></code>, <code><a href="#topic+fscale">fscale/STD</a></code>, <code><a href="#topic+fbetween">fbetween/B</a></code>, <code><a href="#topic+fhdbetween">fhdbetween/HDB</a></code>, <code><a href="#topic+fwithin">fwithin/W</a></code>, <code><a href="#topic+fhdwithin">fhdwithin/HDW</a></code>, <code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code> and <code><a href="#topic+fgrowth">fgrowth/G</a></code> are grouped under <a href="#topic+data-transformations">Data Transformations</a> and <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>. These functions also support <a href="#topic+indexing">indexed data</a> (<em>plm</em>).
</p>
</li></ul>



<h3>Examples</h3>

<pre>
## default vector method
mpg &lt;- mtcars$mpg
fsum(mpg)                         # Simple sum
fsum(mpg, TRA = "/")              # Simple transformation: divide all values by the sum
fsum(mpg, mtcars$cyl)             # Grouped sum
fmean(mpg, mtcars$cyl)            # Grouped mean
fmean(mpg, w = mtcars$hp)         # Weighted mean, weighted by hp
fmean(mpg, mtcars$cyl, mtcars$hp) # Grouped mean, weighted by hp
fsum(mpg, mtcars$cyl, TRA = "/")  # Proportions / division by group sums
fmean(mpg, mtcars$cyl, mtcars$hp, # Subtract weighted group means, see also ?fwithin
      TRA = "-")

## data.frame method
fsum(mtcars)
fsum(mtcars, TRA = "%")                  # This computes percentages
fsum(mtcars, mtcars[c(2,8:9)])           # Grouped column sum
g &lt;- GRP(mtcars, ~ cyl + vs + am)        # Here precomputing the groups!
fsum(mtcars, g)                          # Faster !!
fmean(mtcars, g, mtcars$hp)
fmean(mtcars, g, mtcars$hp, "-")         # Demeaning by weighted group means..
fmean(fgroup_by(mtcars, cyl, vs, am), hp, "-")  # Another way of doing it..


fmode(wlddev, drop = FALSE)              # Compute statistical modes of variables in this data
fmode(wlddev, wlddev$income)             # Grouped statistical modes ..

## matrix method
m &lt;- qM(mtcars)
fsum(m)
fsum(m, g) # ..
\donttest{ 
## method for grouped data frames - created with dplyr::group_by or fgroup_by
library(dplyr)
mtcars |&gt; group_by(cyl,vs,am) |&gt; select(mpg,carb) |&gt; fsum()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg,carb) |&gt; fsum() # equivalent and faster !!
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsum(TRA = "%")
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean(hp)         # weighted grouped mean, save sum of weights
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean(hp, keep.group_vars = FALSE)
}
</pre>


<h3>Benchmark</h3>

<pre>
## This compares fsum with data.table (2 threads) and base::rowsum
# Starting with small data
mtcDT &lt;- qDT(mtcars)
f &lt;- qF(mtcars$cyl)

library(microbenchmark)
microbenchmark(mtcDT[, lapply(.SD, sum), by = f],
               rowsum(mtcDT, f, reorder = FALSE),
               fsum(mtcDT, f, na.rm = FALSE), unit = "relative")

                              expr        min         lq      mean    median        uq       max neval cld
 mtcDT[, lapply(.SD, sum), by = f] 145.436928 123.542134 88.681111 98.336378 71.880479 85.217726   100   c
 rowsum(mtcDT, f, reorder = FALSE)   2.833333   2.798203  2.489064  2.937889  2.425724  2.181173   100  b
     fsum(mtcDT, f, na.rm = FALSE)   1.000000   1.000000  1.000000  1.000000  1.000000  1.000000   100 a

# Now larger data
tdata &lt;- qDT(replicate(100, rnorm(1e5), simplify = FALSE)) # 100 columns with 100.000 obs
f &lt;- qF(sample.int(1e4, 1e5, TRUE))                        # A factor with 10.000 groups

microbenchmark(tdata[, lapply(.SD, sum), by = f],
               rowsum(tdata, f, reorder = FALSE),
               fsum(tdata, f, na.rm = FALSE), unit = "relative")

                              expr      min       lq     mean   median       uq       max neval cld
 tdata[, lapply(.SD, sum), by = f] 2.646992 2.975489 2.834771 3.081313 3.120070 1.2766475   100   c
 rowsum(tdata, f, reorder = FALSE) 1.747567 1.753313 1.629036 1.758043 1.839348 0.2720937   100  b
     fsum(tdata, f, na.rm = FALSE) 1.000000 1.000000 1.000000 1.000000 1.000000 1.0000000   100 a
</pre>


<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>
</p>

<hr>
<h2 id='fbetween-fwithin'>
Fast Between (Averaging) and (Quasi-)Within (Centering) Transformations
</h2><span id='topic+B'></span><span id='topic+B.default'></span><span id='topic+B.matrix'></span><span id='topic+B.data.frame'></span><span id='topic+B.pseries'></span><span id='topic+B.pdata.frame'></span><span id='topic+B.grouped_df'></span><span id='topic+W'></span><span id='topic+W.default'></span><span id='topic+W.matrix'></span><span id='topic+W.data.frame'></span><span id='topic+W.pseries'></span><span id='topic+W.pdata.frame'></span><span id='topic+W.grouped_df'></span><span id='topic+fbetween'></span><span id='topic+fbetween.default'></span><span id='topic+fbetween.matrix'></span><span id='topic+fbetween.data.frame'></span><span id='topic+fbetween.pseries'></span><span id='topic+fbetween.pdata.frame'></span><span id='topic+fbetween.grouped_df'></span><span id='topic+fwithin'></span><span id='topic+fwithin.default'></span><span id='topic+fwithin.matrix'></span><span id='topic+fwithin.data.frame'></span><span id='topic+fwithin.pseries'></span><span id='topic+fwithin.pdata.frame'></span><span id='topic+fwithin.grouped_df'></span>

<h3>Description</h3>

<p><code>fbetween</code> and <code>fwithin</code> are S3 generics to efficiently obtain between-transformed (averaged) or (quasi-)within-transformed (demeaned) data. These operations can be performed groupwise and/or weighted. <code>B</code> and <code>W</code> are wrappers around <code>fbetween</code> and <code>fwithin</code> representing the 'between-operator' and the 'within-operator'.
</p>
<p>(<code>B</code> / <code>W</code> provide more flexibility than <code>fbetween</code> / <code>fwithin</code> when applied to data frames (i.e.  column subsetting, formula input, auto-renaming and id-variable-preservation capabilities...), but are otherwise identical.)
</p>



<h3>Usage</h3>

<pre><code class='language-R'>fbetween(x, ...)
 fwithin(x, ...)
       B(x, ...)
       W(x, ...)

## Default S3 method:
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## Default S3 method:
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## Default S3 method:
B(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## Default S3 method:
W(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)

## S3 method for class 'matrix'
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'matrix'
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'matrix'
B(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, stub = .op[["stub"]], ...)
## S3 method for class 'matrix'
W(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
  stub = .op[["stub"]], ...)

## S3 method for class 'data.frame'
fbetween(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'data.frame'
fwithin(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'data.frame'
B(x, by = NULL, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  fill = FALSE, stub = .op[["stub"]], keep.by = TRUE, keep.w = TRUE, ...)
## S3 method for class 'data.frame'
W(x, by = NULL, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  mean = 0, theta = 1, stub = .op[["stub"]], keep.by = TRUE, keep.w = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fbetween(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pseries'
fwithin(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'pseries'
B(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pseries'
W(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)

## S3 method for class 'pdata.frame'
fbetween(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, ...)
## S3 method for class 'pdata.frame'
fwithin(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1, ...)
## S3 method for class 'pdata.frame'
B(x, effect = 1L, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  fill = FALSE, stub = .op[["stub"]], keep.ids = TRUE, keep.w = TRUE, ...)
## S3 method for class 'pdata.frame'
W(x, effect = 1L, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
  mean = 0, theta = 1, stub = .op[["stub"]], keep.ids = TRUE, keep.w = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fbetween(x, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
         keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
fwithin(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
        keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
B(x, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
  stub = .op[["stub"]], keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
W(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, theta = 1,
  stub = .op[["stub"]], keep.group_vars = TRUE, keep.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbetween-fwithin_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_by">by</code></td>
<td>
<p><em>B and W data.frame method</em>: Same as g, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights. <code>B</code>/<code>W</code> data frame and <code>pdata.frame</code> methods also allow a one-sided formula i.e. <code>~ weightcol</code>. The <code>grouped_df</code> (<em>dplyr</em>) method supports lazy-evaluation. See Examples.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_cols">cols</code></td>
<td>
<p><em>B/W (p)data.frame methods</em>: Select columns to scale using a function, column names, indices or a logical vector. Default: All numeric columns. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code> and <code>w</code> when computing averages. If <code>na.rm = FALSE</code> and a <code>NA</code> or <code>NaN</code> is encountered, the average for that group will be <code>NA</code>, and all data points belonging to that group in the output vector will also be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifier should be used as grouping variable. 1L takes the first variable in the <a href="#topic+indexing">index</a>, 2L the second etc. Index variables can also be called by name using a character string. If more than one variable is supplied, the corresponding index-factors are interacted. </p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_stub">stub</code></td>
<td>
<p>character. A prefix/stub to add to the names of all transformed columns. <code>TRUE</code> (default) uses <code>"W."/"B."</code>, <code>FALSE</code> will not rename columns.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_fill">fill</code></td>
<td>
<p><em>option to <code>fbetween</code>/<code>B</code></em>: Logical. <code>TRUE</code> will overwrite missing values in <code>x</code> with the respective average. By default missing values in <code>x</code> are preserved.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_mean">mean</code></td>
<td>
<p><em>option to <code>fwithin</code>/<code>W</code></em>: The mean to center on, default is 0, but a different mean can be supplied and will be added to the data after the centering is performed. A special option when performing grouped centering is <code>mean = "overall.mean"</code>. In that case the overall mean of the data will be added after subtracting out group means.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_theta">theta</code></td>
<td>
<p><em>option to <code>fwithin</code>/<code>W</code></em>: Double. An optional scalar parameter for quasi-demeaning i.e. <code>x - theta * xi.</code>. This is useful for variance components ('random-effects') estimators. see Details.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_keep.by">keep.by</code>, <code id="fbetween-fwithin_+3A_keep.ids">keep.ids</code>, <code id="fbetween-fwithin_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>B and W data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain grouping / panel-identifier columns in the output. For data frames this only works if grouping variables were passed in a formula.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_keep.w">keep.w</code></td>
<td>
<p><em>B and W data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain column containing the weights in the output. Only works if <code>w</code> is passed as formula / lazy-expression.</p>
</td></tr>
<tr><td><code id="fbetween-fwithin_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without groups, <code>fbetween</code>/<code>B</code> replaces all data points in <code>x</code> with their mean or weighted mean (if <code>w</code> is supplied). Similarly <code>fwithin/W</code> subtracts the (weighted) mean from all data points i.e. centers the data on the mean. <br />
</p>
<p>With groups supplied to <code>g</code>, the replacement / centering performed by <code>fbetween/B</code> | <code>fwithin/W</code> becomes groupwise. In terms of panel data notation: If <code>x</code> is a vector in such a panel dataset, <code>xit</code> denotes a single data-point belonging to group <code>i</code> in time-period <code>t</code> (<code>t</code> need not be a time-period). Then <code>xi.</code> denotes <code>x</code>, averaged over <code>t</code>. <code>fbetween</code>/<code>B</code> now returns <code>xi.</code> and <code>fwithin</code>/<code>W</code> returns <code>x - xi.</code>. Thus for any data <code>x</code> and any grouping vector <code>g</code>: <code>B(x,g) + W(x,g) = xi. + x - xi. = x</code>. In terms of variance, <code>fbetween/B</code> only retains the variance between group averages, while <code>fwithin</code>/<code>W</code>, by subtracting out group means, only retains the variance within those groups. <br />
</p>
<p>The data replacement performed by <code>fbetween</code>/<code>B</code> can keep (default) or overwrite missing values (option <code>fill = TRUE</code>) in <code>x</code>. <code>fwithin/W</code> can center data simply (default), or add back a mean after centering (option <code>mean = value</code>), or add the overall mean in groupwise computations (option <code>mean = "overall.mean"</code>). Let <code>x..</code> denote the overall mean of <code>x</code>, then <code>fwithin</code>/<code>W</code> with <code>mean = "overall.mean"</code> returns <code>x - xi. + x..</code> instead of <code>x - xi.</code>. This is useful to get rid of group-differences but preserve the overall level of the data. In regression analysis, centering with <code>mean = "overall.mean"</code> will only change the constant term. See Examples.
</p>
<p>If <code>theta != 1</code>, <code>fwithin</code>/<code>W</code> performs quasi-demeaning <code>x - theta * xi.</code>. If <code>mean = "overall.mean"</code>, <code>x - theta * xi. + theta * x..</code> is returned, so that the mean of the partially demeaned data is still equal to the overall data mean <code>x..</code>. A numeric value passed to <code>mean</code> will simply be added back to the quasi-demeaned data i.e. <code>x - theta * xi. + mean</code>.
</p>
<p>Now in the case of a linear panel model <code class="reqn">y_{it} = \beta_0 + \beta_1 X_{it} + u_{it}</code> with <code class="reqn">u_{it} = \alpha_i + \epsilon_{it}</code>. If <code class="reqn">\alpha_i \neq \alpha = const.</code> (there exists individual heterogeneity), then pooled OLS is at least inefficient and inference on <code class="reqn">\beta_1</code> is invalid. If <code class="reqn">E[\alpha_i|X_{it}] = 0</code> (mean independence of individual heterogeneity <code class="reqn">\alpha_i</code>), the variance components or 'random-effects' estimator provides an asymptotically efficient FGLS solution by estimating a transformed model <code class="reqn">y_{it}-\theta y_{i.}  = \beta_0 + \beta_1 (X_{it} - \theta X_{i.}) + (u_{it} - \theta u_{i.}</code>), where <code class="reqn">\theta = 1 - \frac{\sigma_\alpha}{\sqrt(\sigma^2_\alpha + T \sigma^2_\epsilon)}</code>. An estimate of <code class="reqn">\theta</code> can be obtained from the an estimate of <code class="reqn">\hat{u}_{it}</code> (the residuals from the pooled model). If <code class="reqn">E[\alpha_i|X_{it}] \neq 0</code>, pooled OLS is biased and inconsistent, and taking <code class="reqn">\theta = 1</code> gives an unbiased and consistent fixed-effects estimator of <code class="reqn">\beta_1</code>. See Examples.
</p>


<h3>Value</h3>

<p><code>fbetween</code>/<code>B</code> returns <code>x</code> with every element replaced by its (groupwise) mean (<code>xi.</code>). Missing values are preserved if <code>fill = FALSE</code> (the default). <code>fwithin/W</code> returns <code>x</code> where every element was subtracted its (groupwise) mean (<code>x - theta * xi. + mean</code> or, if <code>mean = "overall.mean"</code>, <code>x - theta * xi. + theta * x..</code>). See Details.
</p>


<h3>References</h3>

<p>Mundlak, Yair. 1978. On the Pooling of Time Series and Cross Section Data. <em>Econometrica</em> 46 (1): 69-85.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HDW">fhdbetween/HDB and fhdwithin/HDW</a></code>, <code><a href="#topic+fscale">fscale/STD</a></code>, <code><a href="#topic+TRA">TRA</a></code>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple centering and averaging
head(fbetween(mtcars))
head(B(mtcars))
head(fwithin(mtcars))
head(W(mtcars))
all.equal(fbetween(mtcars) + fwithin(mtcars), mtcars)

## Groupwise centering and averaging
head(fbetween(mtcars, mtcars$cyl))
head(fwithin(mtcars, mtcars$cyl))
all.equal(fbetween(mtcars, mtcars$cyl) + fwithin(mtcars, mtcars$cyl), mtcars)

head(W(wlddev, ~ iso3c, cols = 9:13))    # Center the 5 series in this dataset by country
head(cbind(get_vars(wlddev,"iso3c"),     # Same thing done manually using fwithin..
      add_stub(fwithin(get_vars(wlddev,9:13), wlddev$iso3c), "W.")))

## Using B() and W() for fixed-effects regressions:

# Several ways of running the same regression with cyl-fixed effects
lm(W(mpg,cyl) ~ W(carb,cyl), data = mtcars)                     # Centering each individually
lm(mpg ~ carb, data = W(mtcars, ~ cyl, stub = FALSE))           # Centering the entire data
lm(mpg ~ carb, data = W(mtcars, ~ cyl, stub = FALSE,            # Here only the intercept changes
                        mean = "overall.mean"))
lm(mpg ~ carb + B(carb,cyl), data = mtcars)                     # Procedure suggested by
# ..Mundlak (1978) - partialling out group averages amounts to the same as demeaning the data
plm::plm(mpg ~ carb, mtcars, index = "cyl", model = "within")   # "Proof"..

# This takes the interaction of cyl, vs and am as fixed effects
lm(W(mpg) ~ W(carb), data = iby(mtcars, id = finteraction(cyl, vs, am)))
lm(mpg ~ carb, data = W(mtcars, ~ cyl + vs + am, stub = FALSE))
lm(mpg ~ carb + B(carb,list(cyl,vs,am)), data = mtcars)

# Now with cyl fixed effects weighted by hp:
lm(W(mpg,cyl,hp) ~ W(carb,cyl,hp), data = mtcars)
lm(mpg ~ carb, data = W(mtcars, ~ cyl, ~ hp, stub = FALSE))
lm(mpg ~ carb + B(carb,cyl,hp), data = mtcars)       # WRONG ! Gives a different coefficient!!

## Manual variance components (random-effects) estimation
res &lt;- HDW(mtcars, mpg ~ carb)[[1]]  # Get residuals from pooled OLS
sig2_u &lt;- fvar(res)
sig2_e &lt;- fvar(fwithin(res, mtcars$cyl))
T &lt;- length(res) / fndistinct(mtcars$cyl)
sig2_alpha &lt;- sig2_u - sig2_e
theta &lt;- 1 - sqrt(sig2_alpha) / sqrt(sig2_alpha + T * sig2_e)
lm(mpg ~ carb, data = W(mtcars, ~ cyl, theta = theta, mean = "overall.mean", stub = FALSE))

# A slightly different method to obtain theta...
plm::plm(mpg ~ carb, mtcars, index = "cyl", model = "random")
</code></pre>

<hr>
<h2 id='fcount'>
Efficiently Count Observations by Group
</h2><span id='topic+fcount'></span><span id='topic+fcountv'></span>

<h3>Description</h3>

<p>A much faster replacement for <code>dplyr::count</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcount(x, ..., w = NULL, name = "N", add = FALSE,
      sort = FALSE, decreasing = FALSE)

fcountv(x, cols = NULL, w = NULL, name = "N", add = FALSE,
        sort = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcount_+3A_x">x</code></td>
<td>
<p>a data frame or list-like object, including 'grouped_df' or 'indexed_frame'. Atomic vectors or matrices can also be passed, but will be sent through <code><a href="#topic+qDF">qDF</a></code>. </p>
</td></tr>
<tr><td><code id="fcount_+3A_...">...</code></td>
<td>
<p>for <code>fcount</code>: names or sequences of columns to count cases by - passed to <code><a href="#topic+fselect">fselect</a></code>. For <code>fcountv</code>: further arguments passed to <code><a href="#topic+GRP">GRP</a></code> (such as <code>decreasing</code>, <code>na.last</code>, <code>method</code>, <code>effect</code> etc.). Leaving this empty will count on all columns. </p>
</td></tr>
<tr><td><code id="fcount_+3A_cols">cols</code></td>
<td>
<p>select columns to count cases by, using column names, indices, a logical vector or a selector function (e.g. <code>is_categorical</code>).</p>
</td></tr>
<tr><td><code id="fcount_+3A_w">w</code></td>
<td>
<p>a numeric vector of weights, may contain missing values. In <code>fcount</code> this can also be the (unquoted) name of a column in the data frame. <code>fcountv</code> also supports a single character name. <em>Note</em> that the corresponding argument in <code>dplyr::count</code> is called <code>wt</code>, but <em>collapse</em> has a global default for weights arguments to be called <code>w</code>.</p>
</td></tr>
<tr><td><code id="fcount_+3A_name">name</code></td>
<td>
<p>character. The name of the column containing the count or sum of weights. <code>dplyr::count</code> it is called <code>"n"</code>, but <code>"N"</code> is more consistent with the rest of <em>collapse</em> and <em>data.table</em>.</p>
</td></tr>
<tr><td><code id="fcount_+3A_add">add</code></td>
<td>
<p><code>TRUE</code> adds the count column to <code>x</code>. Alternatively <code>add = "group_vars"</code> (or <code>add = "gv"</code> for parsimony) can be used to retain only the variables selected for counting in <code>x</code> and the count.</p>
</td></tr>
<tr><td><code id="fcount_+3A_sort">sort</code>, <code id="fcount_+3A_decreasing">decreasing</code></td>
<td>
<p>arguments passed to <code><a href="#topic+GRP">GRP</a></code> affecting the order of rows in the output (if <code>add = FALSE</code>), and the algorithm used for counting. In general, <code>sort = FALSE</code> is faster unless data is already sorted by the columns used for counting.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a list, an object of the same type as <code>x</code> with a column (<code>name</code>) added at the end giving the count. Otherwise, if <code>x</code> is atomic, a data frame returned from <code><a href="#topic+qDF">qDF(x)</a></code> with the count column added. By default (<code>add = FALSE</code>) only the unique rows of <code>x</code> of the columns used for counting are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GRPN">GRPN</a></code>, <code><a href="#topic+fnobs">fnobs</a></code>, <code><a href="#topic+fndistinct">fndistinct</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fcount(mtcars, cyl, vs, am)
fcountv(mtcars, cols = .c(cyl, vs, am))
fcount(mtcars, cyl, vs, am, sort = TRUE)
fcount(mtcars, cyl, vs, am, add = TRUE)
fcount(mtcars, cyl, vs, am, add = "group_vars")

## With grouped data
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt; fcount()
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt; fcount(add = TRUE)
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt; fcount(add = "group_vars")

## With indexed data: by default counting on the first index variable
wlddev |&gt; findex_by(country, year) |&gt; fcount()
wlddev |&gt; findex_by(country, year) |&gt; fcount(add = TRUE)
# Use fcountv to pass additional arguments to GRP.pdata.frame,
# here using the effect argument to choose a different index variable
wlddev |&gt; findex_by(country, year) |&gt; fcountv(effect = "year")
wlddev |&gt; findex_by(country, year) |&gt; fcountv(add = "group_vars", effect = "year")

</code></pre>

<hr>
<h2 id='fcumsum'>
Fast (Grouped, Ordered) Cumulative Sum for Matrix-Like Objects
</h2><span id='topic+fcumsum'></span><span id='topic+fcumsum.default'></span><span id='topic+fcumsum.matrix'></span><span id='topic+fcumsum.data.frame'></span><span id='topic+fcumsum.pseries'></span><span id='topic+fcumsum.pdata.frame'></span><span id='topic+fcumsum.grouped_df'></span>

<h3>Description</h3>

<p><code>fcumsum</code> is a generic function that computes the (column-wise) cumulative sum of <code>x</code>, (optionally) grouped by <code>g</code> and/or ordered by <code>o</code>. Several options to deal with missing values are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcumsum(x, ...)

## Default S3 method:
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

## S3 method for class 'matrix'
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

## S3 method for class 'data.frame'
fcumsum(x, g = NULL, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fcumsum(x, na.rm = .op[["na.rm"]], fill = FALSE, shift = "time", ...)

## S3 method for class 'pdata.frame'
fcumsum(x, na.rm = .op[["na.rm"]], fill = FALSE, shift = "time", ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fcumsum(x, o = NULL, na.rm = .op[["na.rm"]], fill = FALSE, check.o = TRUE,
        keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcumsum_+3A_x">x</code></td>
<td>
<p>a numeric vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_o">o</code></td>
<td>
<p>a vector or list of vectors providing the order in which the elements of <code>x</code> are cumulatively summed. Will be passed to <code><a href="#topic+radixorderv">radixorderv</a></code> unless <code>check.o = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_fill">fill</code></td>
<td>
<p>if <code>na.rm = TRUE</code>, setting <code>fill = TRUE</code> will overwrite missing values with the previous value of the cumulative sum, starting from 0.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_check.o">check.o</code></td>
<td>
<p>logical. Programmers option: <code>FALSE</code> prevents passing <code>o</code> to <code><a href="#topic+radixorderv">radixorderv</a></code>, requiring <code>o</code> to be a valid ordering vector that is integer typed with each element in the range <code>[1, length(x)]</code>. This gives some extra speed, but will terminate R if any element of <code>o</code> is too large or too small. </p>
</td></tr>
<tr><td><code id="fcumsum_+3A_shift">shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> or <code>"row"</code>. See <code><a href="#topic+flag">flag</a></code> for details. The argument here does not control 'shifting' of data but rather the order in which elements are summed.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_keep.ids">keep.ids</code></td>
<td>
<p><em>pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all grouping variables and variables passed to <code>o</code>). <em>Note</em>: For grouped / panel data frames identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td></tr>
<tr><td><code id="fcumsum_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>na.rm = FALSE</code>, <code>fcumsum</code> works like <code><a href="base.html#topic+cumsum">cumsum</a></code> and propagates missing values. The default <code>na.rm = TRUE</code> skips missing values and computes the cumulative sum on the non-missing values. Missing values are kept. If <code>fill = TRUE</code>, missing values are replaced with the previous value of the cumulative sum (starting from 0), computed on the non-missing values.
</p>
<p>By default the cumulative sum is computed in the order in which elements appear in <code>x</code>. If <code>o</code> is provided, the cumulative sum is computed in the order given by <code>radixorderv(o)</code>, without the need to first sort <code>x</code>. This applies as well if groups are used (<code>g</code>), in which case the cumulative sum is computed separately in each group.
</p>
<p>The <em>pseries</em> and <em>pdata.frame</em> methods assume that the last factor in the <a href="#topic+findex">index</a> is the time-variable and the rest are grouping variables. The time-variable is passed to <code>radixorderv</code> and used for ordered computation, so that cumulative sums are accurately computed regardless of whether the panel-data is ordered or balanced.
</p>
<p><code>fcumsum</code> explicitly supports integers. Integers in R are bounded at bounded at +-2,147,483,647, and an integer overflow error will be provided if the cumulative sum (within any group) exceeds +-2,147,483,647. In that case data should be converted to double beforehand.
</p>


<h3>Value</h3>

<p>the cumulative sum of values in <code>x</code>, (optionally) grouped by <code>g</code> and/or ordered by <code>o</code>. See Details and Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdiff">fdiff</a></code>, <code><a href="#topic+fgrowth">fgrowth</a></code>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Non-grouped
fcumsum(AirPassengers)
head(fcumsum(EuStockMarkets))
fcumsum(mtcars)

# Non-grouped but ordered
o &lt;- order(rnorm(nrow(EuStockMarkets)))
all.equal(copyAttrib(fcumsum(EuStockMarkets[o, ], o = o)[order(o), ], EuStockMarkets),
          fcumsum(EuStockMarkets))

## Grouped
head(with(wlddev, fcumsum(PCGDP, iso3c)))

## Grouped and ordered
head(with(wlddev, fcumsum(PCGDP, iso3c, year)))
head(with(wlddev, fcumsum(PCGDP, iso3c, year, fill = TRUE)))
</code></pre>

<hr>
<h2 id='fdiff'> 
Fast (Quasi-, Log-) Differences for Time Series and Panel Data
</h2><span id='topic+fdiff'></span><span id='topic+fdiff.default'></span><span id='topic+fdiff.matrix'></span><span id='topic+fdiff.data.frame'></span><span id='topic+fdiff.list'></span><span id='topic+fdiff.pseries'></span><span id='topic+fdiff.pdata.frame'></span><span id='topic+fdiff.grouped_df'></span><span id='topic+D'></span><span id='topic+D.default'></span><span id='topic+D.matrix'></span><span id='topic+D.data.frame'></span><span id='topic+D.list'></span><span id='topic+D.pseries'></span><span id='topic+D.pdata.frame'></span><span id='topic+D.grouped_df'></span><span id='topic+Dlog'></span><span id='topic+Dlog.default'></span><span id='topic+Dlog.matrix'></span><span id='topic+Dlog.data.frame'></span><span id='topic+Dlog.list'></span><span id='topic+Dlog.pseries'></span><span id='topic+Dlog.pdata.frame'></span><span id='topic+Dlog.grouped_df'></span>

<h3>Description</h3>

<p><code>fdiff</code> is a S3 generic to compute (sequences of) suitably lagged / leaded and iterated differences, quasi-differences or (quasi-)log-differences. The difference and log-difference operators <code>D</code> and <code>Dlog</code> also exists as parsimonious wrappers around <code>fdiff</code>, providing more flexibility than <code>fdiff</code> when applied to data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fdiff(x, n = 1, diff = 1, ...)
      D(x, n = 1, diff = 1, ...)
   Dlog(x, n = 1, diff = 1, ...)

## Default S3 method:
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = TRUE, ...)
## Default S3 method:
D(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1,
  stubs = .op[["stub"]], ...)
## Default S3 method:
Dlog(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     ...)

## S3 method for class 'matrix'
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'matrix'
D(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1,
  stubs = .op[["stub"]], ...)
## S3 method for class 'matrix'
Dlog(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     ...)

## S3 method for class 'data.frame'
fdiff(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'data.frame'
D(x, n = 1, diff = 1, by = NULL, t = NULL, cols = is.numeric,
  fill = NA, rho = 1, stubs = .op[["stub"]], keep.ids = TRUE, ...)
## S3 method for class 'data.frame'
Dlog(x, n = 1, diff = 1, by = NULL, t = NULL, cols = is.numeric,
     fill = NA, rho = 1, stubs = .op[["stub"]], keep.ids = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fdiff(x, n = 1, diff = 1, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pseries'
D(x, n = 1, diff = 1, fill = NA, rho = 1, stubs = .op[["stub"]], shift = "time", ...)
## S3 method for class 'pseries'
Dlog(x, n = 1, diff = 1, fill = NA, rho = 1, stubs = .op[["stub"]], shift = "time", ...)

## S3 method for class 'pdata.frame'
fdiff(x, n = 1, diff = 1, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pdata.frame'
D(x, n = 1, diff = 1, cols = is.numeric, fill = NA, rho = 1, stubs = .op[["stub"]],
  shift = "time", keep.ids = TRUE, ...)
## S3 method for class 'pdata.frame'
Dlog(x, n = 1, diff = 1, cols = is.numeric, fill = NA, rho = 1, stubs = .op[["stub"]],
     shift = "time", keep.ids = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fdiff(x, n = 1, diff = 1, t = NULL, fill = NA, log = FALSE, rho = 1,
      stubs = length(n) + length(diff) &gt; 2L, keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
D(x, n = 1, diff = 1, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
  keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
Dlog(x, n = 1, diff = 1, t = NULL, fill = NA, rho = 1, stubs = .op[["stub"]],
     keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdiff_+3A_x">x</code></td>
<td>
<p>a numeric vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td></tr>
<tr><td><code id="fdiff_+3A_n">n</code></td>
<td>
<p>integer. A vector indicating the number of lags or leads.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_diff">diff</code></td>
<td>
<p>integer. A vector of integers &gt; 1 indicating the order of differencing / log-differencing.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>. <em>Note</em> that without <code>t</code>, all values in a group need to be consecutive and in the right order. See Details of <code><a href="#topic+flag">flag</a></code>.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_t">t</code></td>
<td>
<p>a time vector or list of vectors. See <code><a href="#topic+flag">flag</a></code>.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to difference using a function, column names, indices or a logical vector. Default: All numeric variables. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_fill">fill</code></td>
<td>
<p>value to insert when vectors are shifted. Default is <code>NA</code>. </p>
</td></tr>
<tr><td><code id="fdiff_+3A_log">log</code></td>
<td>
<p>logical. <code>TRUE</code> computes log-differences. See Details.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_rho">rho</code></td>
<td>
<p>double. Autocorrelation parameter. Set to a value between 0 and 1 for quasi-differencing. Any numeric value can be supplied. </p>
</td></tr>
<tr><td><code id="fdiff_+3A_stubs">stubs</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will rename all differenced columns by adding prefixes &quot;L<code>n</code>D<code>diff</code>.&quot; / &quot;F<code>n</code>D<code>diff</code>.&quot; for differences &quot;L<code>n</code>Dlog<code>diff</code>.&quot; / &quot;F<code>n</code>Dlog<code>diff</code>.&quot; for log-differences and replacing &quot;D&quot; / &quot;Dlog&quot; with &quot;QD&quot; / &quot;QDlog&quot; for quasi-differences. </p>
</td></tr>
<tr><td><code id="fdiff_+3A_shift">shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> or <code>"row"</code>. See <code><a href="#topic+flag">flag</a></code> for details.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_keep.ids">keep.ids</code></td>
<td>
<p><em>data.frame / pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all variables passed to <code>by</code> or <code>t</code> using formulas). <em>Note</em>: For 'grouped_df' / 'pdata.frame' identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td></tr>
<tr><td><code id="fdiff_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>fdiff/D/Dlog</code> return <code>x</code> with all columns differenced / log-differenced. Differences are computed as <code>repeat(diff) x[i] - rho*x[i-n]</code>, and log-differences as <code>log(x[i]) - rho*log(x[i-n])</code> for <code>diff = 1</code> and <code>repeat(diff-1) x[i] - rho*x[i-n]</code> is used to compute subsequent differences (usually <code>diff = 1</code> for log-differencing). If <code>rho &lt; 1</code>, this becomes quasi- (or partial) differencing, which is a technique suggested by Cochrane and Orcutt (1949) to deal with serial correlation in regression models, where <code>rho</code> is typically estimated by running a regression of the model residuals on the lagged residuals. 
It is also possible to compute forward differences by passing negative <code>n</code> values. <code>n</code> also supports arbitrary vectors of integers (lags), and <code>diff</code> supports positive sequences of integers (differences):
</p>
<p>If more than one value is passed to <code>n</code> and/or <code>diff</code>, the data is expanded-wide as follows: If <code>x</code> is an atomic vector or time series, a (time series) matrix is returned with columns ordered first by lag, then by difference. If <code>x</code> is a matrix or data frame, each column is expanded in like manor such that the output has <code>ncol(x)*length(n)*length(diff)</code> columns ordered first by column name, then by lag, then by difference.
</p>



<p>For further computational details and efficiency considerations see the help page of <code><a href="#topic+flag">flag</a></code>. 
</p>




<h3>Value</h3>

<p><code>x</code> differenced <code>diff</code> times using lags <code>n</code> of itself. Quasi and log-differences are toggled by the <code>rho</code> and <code>log</code> arguments or the <code>Dlog</code> operator. Computations can be grouped by <code>g/by</code> and/or ordered by <code>t</code>. See Details and Examples.
</p>


<h3>References</h3>

<p>Cochrane, D.; Orcutt, G. H. (1949). Application of Least Squares Regression to Relationships Containing Auto-Correlated Error Terms. <em>Journal of the American Statistical Association</em>. 44 (245): 32-61.
</p>
<p>Prais, S. J. &amp; Winsten, C. B. (1954). Trend Estimators and Serial Correlation. <em>Cowles Commission Discussion Paper No. 383.</em> Chicago.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fgrowth">fgrowth/G</a></code>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Time Series: AirPassengers
D(AirPassengers)                      # 1st difference, same as fdiff(AirPassengers)
D(AirPassengers, -1)                  # Forward difference
Dlog(AirPassengers)                   # Log-difference
D(AirPassengers, 1, 2)                # Second difference
Dlog(AirPassengers, 1, 2)             # Second log-difference
D(AirPassengers, 12)                  # Seasonal difference (data is monthly)
D(AirPassengers,                      # Quasi-difference, see a better example below
  rho = pwcor(AirPassengers, L(AirPassengers)))

head(D(AirPassengers, -2:2, 1:3))     # Sequence of leaded/lagged and iterated differences

# let's do some visual analysis
plot(AirPassengers)                   # Plot the series - seasonal pattern is evident
plot(stl(AirPassengers, "periodic"))  # Seasonal decomposition
plot(D(AirPassengers,c(1,12),1:2))    # Plotting ordinary and seasonal first and second differences
plot(stl(window(D(AirPassengers,12),  # Taking seasonal differences removes most seasonal variation
                1950), "periodic"))


## Time Series Matrix of 4 EU Stock Market Indicators, recorded 260 days per year
plot(D(EuStockMarkets, c(0, 260)))                      # Plot series and annual differnces
mod &lt;- lm(DAX ~., L(EuStockMarkets, c(0, 260)))         # Regressing the DAX on its annual lag
summary(mod)                                            # and the levels and annual lags others
r &lt;- residuals(mod)                                     # Obtain residuals
pwcor(r, L(r))                                          # Residual Autocorrelation
fFtest(r, L(r))                                         # F-test of residual autocorrelation
                                                        # (better use lmtest :: bgtest)
modCO &lt;- lm(QD1.DAX ~., D(L(EuStockMarkets, c(0, 260)), # Cochrane-Orcutt (1949) estimation
                        rho = pwcor(r, L(r))))
summary(modCO)
rCO &lt;- residuals(modCO)
fFtest(rCO, L(rCO))                                     # No more autocorrelation

## World Development Panel Data
head(fdiff(num_vars(wlddev), 1, 1,                      # Computes differences of numeric variables
             wlddev$country, wlddev$year))              # fdiff requires external inputs..
head(D(wlddev, 1, 1, ~country, ~year))                  # Differences of numeric variables
head(D(wlddev, 1, 1, ~country))                         # Without t: Works because data is ordered
head(D(wlddev, 1, 1, PCGDP + LIFEEX ~ country, ~year))  # Difference of GDP &amp; Life Expectancy
head(D(wlddev, 0:1, 1, ~ country, ~year, cols = 9:10))  # Same, also retaining original series
head(D(wlddev, 0:1, 1, ~ country, ~year, 9:10,          # Dropping id columns
       keep.ids = FALSE))

## Indexed computations:
wldi &lt;- findex_by(wlddev, iso3c, year)

# Dynamic Panel Data Models:
summary(lm(D(PCGDP) ~ L(PCGDP) + D(LIFEEX), data = wldi))            # Simple case
summary(lm(Dlog(PCGDP) ~ L(log(PCGDP)) + Dlog(LIFEEX), data = wldi)) # In log-differneces
# Adding a lagged difference...
summary(lm(D(PCGDP) ~ L(D(PCGDP, 0:1)) + L(D(LIFEEX), 0:1), data = wldi))
summary(lm(Dlog(PCGDP) ~ L(Dlog(PCGDP, 0:1)) + L(Dlog(LIFEEX), 0:1), data = wldi))
# Same thing:
summary(lm(D1.PCGDP ~., data = L(D(wldi,0:1,1,9:10),0:1,keep.ids = FALSE)[,-1]))

## Grouped data
library(magrittr)
wlddev |&gt; fgroup_by(country) |&gt;
             fselect(PCGDP,LIFEEX) |&gt; fdiff(0:1,1:2)       # Adding a first and second difference
wlddev |&gt; fgroup_by(country) |&gt;
             fselect(year,PCGDP,LIFEEX) |&gt; D(0:1,1:2,year) # Also using t (safer)
wlddev |&gt; fgroup_by(country) |&gt;                            # Dropping id's
             fselect(year,PCGDP,LIFEEX) |&gt; D(0:1,1:2,year, keep.ids = FALSE)
</code></pre>

<hr>
<h2 id='fdist'>
Fast and Flexible Distance Computations
</h2><span id='topic+fdist'></span>

<h3>Description</h3>

<p>A fast and flexible replacement for <code><a href="stats.html#topic+dist">dist</a></code>, to compute euclidean distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdist(x, v = NULL, ..., method = "euclidean", nthreads = .op[["nthreads"]])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdist_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix. Data frames/lists can be passed but will be converted to matrix using <code><a href="#topic+qM">qM</a></code>. Non-numeric (double) inputs will be coerced. </p>
</td></tr>
<tr><td><code id="fdist_+3A_v">v</code></td>
<td>
<p>an (optional) numeric (double) vector such that <code>length(v) == NCOL(x)</code>, to compute distances with (the rows of) <code>x</code>. Other vector types will be coerced.</p>
</td></tr>
<tr><td><code id="fdist_+3A_...">...</code></td>
<td>
<p>not used. A placeholder for possible future arguments.</p>
</td></tr>
<tr><td><code id="fdist_+3A_method">method</code></td>
<td>
<p>an integer or character string indicating the method of computing distances.
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"euclidean"</code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> euclidean distance </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>"euclidean_squared"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> squared euclidean distance (more efficient) </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>


</td></tr>
<tr><td><code id="fdist_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to use. If <code>v = NULL</code> (full distance matrix), multithreading is along the distance matrix columns (decreasing thread loads as matrix is lower triangular). If <code>v</code> is supplied, multithreading is at the sub-column level (across elements).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>v = NULL</code>, a full lower-triangular distance matrix between the rows of <code>x</code> is computed and returned as a 'dist' object (all methods apply, see <code><a href="stats.html#topic+dist">dist</a></code>). Otherwise, a numeric vector of distances of each row of <code>x</code> with <code>v</code> is returned. See Examples.
</p>


<h3>Note</h3>

<p><code>fdist</code> does not check for missing values, so <code>NA</code>'s will result in <code>NA</code> distances.
</p>
<p><code>kit::topn</code> is a suitable complimentary function to find nearest neighbors. It is very efficient and skips missing values by default.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flm">flm</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Distance matrix
m = as.matrix(mtcars)
str(fdist(m)) # Same as dist(m)

# Distance with vector
d = fdist(m, fmean(m))
kit::topn(d, 5)  # Index of 5 nearest neighbours

# Mahalanobis distance
m_mahal = t(forwardsolve(t(chol(cov(m))), t(m)))
fdist(m_mahal, fmean(m_mahal))
sqrt(unattrib(mahalanobis(m, fmean(m), cov(m))))

# Distance of two vectors
x &lt;- rnorm(1e6)
y &lt;- rnorm(1e6)
microbenchmark::microbenchmark(
  fdist(x, y),
  fdist(x, y, nthreads = 2),
  sqrt(sum((x-y)^2))
)

</code></pre>

<hr>
<h2 id='fdroplevels'>
Fast Removal of Unused Factor Levels
</h2><span id='topic+fdroplevels'></span><span id='topic+fdroplevels.factor'></span><span id='topic+fdroplevels.data.frame'></span>

<h3>Description</h3>

<p>A substantially faster replacement for <code><a href="base.html#topic+droplevels">droplevels</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdroplevels(x, ...)

## S3 method for class 'factor'
fdroplevels(x, ...)

## S3 method for class 'data.frame'
fdroplevels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdroplevels_+3A_x">x</code></td>
<td>
<p>a factor, or data frame / list containing one or more factors.</p>
</td></tr>
<tr><td><code id="fdroplevels_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+droplevels">droplevels</a></code> passes a factor from which levels are to be dropped to <code><a href="base.html#topic+factor">factor</a></code>, which first calls <code><a href="base.html#topic+unique">unique</a></code> and then <code><a href="base.html#topic+match">match</a></code> to drop unused levels. Both functions internally use a hash table, which is highly inefficient. <code>fdroplevels</code> does not require mapping values at all, but uses a super fast boolean vector method to determine which levels are unused and remove those levels. In addition, if no unused levels are found, <code>x</code> is simply returned. Any missing values found in <code>x</code> are efficiently skipped in the process of checking and replacing levels. All other attributes of <code>x</code> are preserved.
</p>


<h3>Value</h3>

<p><code>x</code> with unused factor levels removed.
</p>


<h3>Note</h3>

<p>If <code>x</code> is malformed e.g. has too few levels, this function can cause a segmentation fault terminating the R session, thus only use with ordinary / proper factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qF">qF</a></code>, <code><a href="#topic+funique">funique</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- iris$Species[1:100]
fdroplevels(f)
identical(fdroplevels(f), droplevels(f))

fNA &lt;- na_insert(f)
fdroplevels(fNA)
identical(fdroplevels(fNA), droplevels(fNA))

identical(fdroplevels(ss(iris, 1:100)), droplevels(ss(iris, 1:100)))
</code></pre>

<hr>
<h2 id='ffirst-flast'>Fast (Grouped) First and Last Value for Matrix-Like Objects</h2><span id='topic+ffirst'></span><span id='topic+ffirst.default'></span><span id='topic+ffirst.matrix'></span><span id='topic+ffirst.data.frame'></span><span id='topic+ffirst.grouped_df'></span><span id='topic+flast'></span><span id='topic+flast.default'></span><span id='topic+flast.matrix'></span><span id='topic+flast.data.frame'></span><span id='topic+flast.grouped_df'></span>

<h3>Description</h3>

<p><code>ffirst</code> and <code>flast</code> are S3 generic functions that (column-wise) returns the first and last values in <code>x</code>, (optionally) grouped by <code>g</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (groupwise) first and last values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffirst(x, ...)
flast(x, ...)

## Default S3 method:
ffirst(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
       use.g.names = TRUE, ...)
## Default S3 method:
flast(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, ...)

## S3 method for class 'matrix'
ffirst(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
       use.g.names = TRUE, drop = TRUE, ...)
## S3 method for class 'matrix'
flast(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'data.frame'
ffirst(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
       use.g.names = TRUE, drop = TRUE, ...)
## S3 method for class 'data.frame'
flast(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'grouped_df'
ffirst(x, TRA = NULL, na.rm = .op[["na.rm"]],
       use.g.names = FALSE, keep.group_vars = TRUE, ...)
## S3 method for class 'grouped_df'
flast(x, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = FALSE, keep.group_vars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffirst-flast_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. <code>TRUE</code> skips missing values and returns the first / last non-missing value i.e. if the first (1) / last (n) value is <code>NA</code>, take the second (2) / second-to-last (n-1) value etc..</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="ffirst-flast_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ffirst</code> returns the first value in <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its first value, grouped by <code>g</code>. Similarly <code>flast</code> returns the last value in <code>x</code>, ...
</p>


<h3>Note</h3>

<p>Both functions are significantly faster if <code>na.rm = FALSE</code>, particularly <code>ffirst</code> which can take direct advantage of the 'group.starts' elements in <code><a href="#topic+GRP">GRP</a></code> objects.
</p>


<h3>See Also</h3>

<p><a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
ffirst(airquality$Ozone)                   # Simple first value
ffirst(airquality$Ozone, airquality$Month) # Grouped first value
ffirst(airquality$Ozone, airquality$Month,
       na.rm = FALSE)                      # Grouped first, but without skipping initial NA's

## data.frame method
ffirst(airquality)
ffirst(airquality, airquality$Month)
ffirst(airquality, airquality$Month, na.rm = FALSE) # Again first Ozone measurement in month 6 is NA

## matrix method
aqm &lt;- qM(airquality)
ffirst(aqm)
ffirst(aqm, airquality$Month) # etc..
 
## method for grouped data frames - created with dplyr::group_by or fgroup_by
library(dplyr)
airquality |&gt; group_by(Month) |&gt; ffirst()
airquality |&gt; group_by(Month) |&gt; select(Ozone) |&gt; ffirst(na.rm = FALSE)

# Note: All examples generalize to flast.
</code></pre>

<hr>
<h2 id='fFtest'>
Fast (Weighted) F-test for Linear Models (with Factors)
</h2><span id='topic+fFtest'></span><span id='topic+fFtest.default'></span><span id='topic+fFtest.formula'></span>

<h3>Description</h3>

<p><code>fFtest</code> computes an R-squared based F-test for the exclusion of the variables in <code>exc</code>, where the full (unrestricted) model is defined by variables supplied to both <code>exc</code> and <code>X</code>. The test is efficient and designed for cases where both <code>exc</code> and <code>X</code> may contain multiple factors and continuous variables. There is also an efficient 2-part formula method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fFtest(...) # Internal method dispatch: formula if is.call(..1) || is.call(..2)

## Default S3 method:
fFtest(y, exc, X = NULL, w = NULL, full.df = TRUE, ...)

## S3 method for class 'formula'
fFtest(formula, data = NULL, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fFtest_+3A_y">y</code></td>
<td>
<p>a numeric vector: the dependent variable.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_exc">exc</code></td>
<td>
<p>a numeric vector, factor, numeric matrix or list / data frame of numeric vectors and/or factors: variables to test / exclude.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_x">X</code></td>
<td>
<p>a numeric vector, factor, numeric matrix or list / data frame of numeric vectors and/or factors: covariates to include in both the restricted (without <code>exc</code>) and unrestricted model. If left empty (<code>X = NULL</code>), the test amounts to the F-test of the regression of <code>y</code> on <code>exc</code>.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_w">w</code></td>
<td>
<p>numeric. A vector of (frequency) weights.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_formula">formula</code></td>
<td>
<p>a 2-part formula: <code>y ~ exc | X</code>, where both <code>exc</code> and <code>X</code> are expressions connected with <code>+</code>, and <code>X</code> can be omitted. <em>Note</em> that other operators (<code>:</code>, <code>*</code>, <code>^</code>, <code>-</code>, etc.) are not supported, you can interact variables using standard functions like <code><a href="#topic+itn">finteraction/itn</a></code> or <code>magrittr::multiply_by</code> inside the formula e.g. <code>log(y) ~ x1 + itn(x2, x3) | x4</code> or <code>log(y) ~ x1 + multiply_by(x2, x3) | x4</code>.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_data">data</code></td>
<td>
<p>a named list or data frame.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_weights">weights</code></td>
<td>
<p>a weights vector or expression that results in a vector when evaluated in the <code>data</code> environment.</p>
</td></tr>
<tr><td><code id="fFtest_+3A_full.df">full.df</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the degrees of freedom are calculated as if both restricted and unrestricted models were estimated using <code>lm()</code> (i.e. as if factors were expanded to matrices of dummies). <code>FALSE</code> only uses one degree of freedom per factor.  </p>
</td></tr>
<tr><td><code id="fFtest_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>fFtest.default</code> or to <code>fhdwithin</code>. Sensible options might be the <code>lm.method</code> argument or further control parameters to <code>fixest::demean</code>, the workhorse function underlying <code>fhdwithin</code> for higher-order centering tasks. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factors and continuous regressors are efficiently projected out using <code><a href="#topic+fhdwithin">fhdwithin</a></code>, and the option <code>full.df</code> regulates whether a degree of freedom is subtracted for each used factor level (equivalent to dummy-variable estimator / expanding factors), or only one degree of freedom per factor (treating factors as variables). The test automatically removes missing values and considers only the complete cases of <code>y, exc</code> and <code>X</code>. Unused factor levels in <code>exc</code> and <code>X</code> are dropped.
</p>
<p><em>Note</em> that an intercept is always added by <code><a href="#topic+fhdwithin">fhdwithin</a></code>, so it is not necessary to include an intercept in data supplied to <code>exc</code> / <code>X</code>.
</p>


<h3>Value</h3>

<p>A 5 x 3 numeric matrix of statistics. The columns contain statistics:
</p>

<ol>
<li><p> the R-squared of the model
</p>
</li>
<li><p> the numerator degrees of freedom i.e. the number of variables (k) and used factor levels if <code>full.df = TRUE</code>
</p>
</li>
<li><p> the denominator degrees of freedom: N - k - 1.
</p>
</li>
<li><p> the F-statistic
</p>
</li>
<li><p> the corresponding P-value
</p>
</li></ol>

<p>The rows show these statistics for:
</p>

<ol>
<li><p> the Full (unrestricted) Model (<code>y ~ exc + X</code>)
</p>
</li>
<li><p> the Restricted Model (<code>y ~ X</code>)
</p>
</li>
<li><p> the Exclusion Restriction of <code>exc</code>. The R-squared shown is simply the difference of the full and restricted R-Squared's, not the R-Squared of the model <code>y ~ exc</code>.
</p>
</li></ol>

<p>If <code>X = NULL</code>, only a vector of the same 5 statistics testing the model (<code>y ~ exc</code>) is shown.
</p>







<h3>See Also</h3>

<p><code><a href="#topic+flm">flm</a></code>, <code><a href="#topic+fhdwithin">fhdwithin</a></code>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## We could use fFtest as a simple seasonality test:
fFtest(AirPassengers, qF(cycle(AirPassengers)))         # Testing for level-seasonality
fFtest(AirPassengers, qF(cycle(AirPassengers)),         # Seasonality test around a cubic trend
        poly(seq_along(AirPassengers), 3))
fFtest(fdiff(AirPassengers), qF(cycle(AirPassengers)))  # Seasonality in first-difference

## A more classical example with only continuous variables
fFtest(mpg ~ cyl + vs | hp + carb, mtcars)
fFtest(mtcars$mpg, mtcars[c("cyl","vs")], mtcars[c("hp","carb")])
 
## Now encoding cyl and vs as factors
fFtest(mpg ~ qF(cyl) + qF(vs) | hp + carb, mtcars)
fFtest(mtcars$mpg, lapply(mtcars[c("cyl","vs")], qF), mtcars[c("hp","carb")])

## Using iris data: A factor and a continuous variable excluded
fFtest(Sepal.Length ~ Petal.Width + Species | Sepal.Width + Petal.Length, iris)
fFtest(iris$Sepal.Length, iris[4:5], iris[2:3])

## Testing the significance of country-FE in regression of GDP on life expectancy
fFtest(log(PCGDP) ~ iso3c | LIFEEX, wlddev)
fFtest(log(wlddev$PCGDP), wlddev$iso3c, wlddev$LIFEEX)
 
## Ok, country-FE are significant, what about adding time-FE
fFtest(log(PCGDP) ~ qF(year) | iso3c + LIFEEX, wlddev)
fFtest(log(wlddev$PCGDP), qF(wlddev$year), wlddev[c("iso3c","LIFEEX")])

# Same test done using lm:
data &lt;- na_omit(get_vars(wlddev, c("iso3c","year","PCGDP","LIFEEX")))
full &lt;- lm(PCGDP ~ LIFEEX + iso3c + qF(year), data)
rest &lt;- lm(PCGDP ~ LIFEEX + iso3c, data)
anova(rest, full)

</code></pre>

<hr>
<h2 id='fgrowth'> 
Fast Growth Rates for Time Series and Panel Data
</h2><span id='topic+fgrowth'></span><span id='topic+fgrowth.default'></span><span id='topic+fgrowth.matrix'></span><span id='topic+fgrowth.data.frame'></span><span id='topic+fgrowth.list'></span><span id='topic+fgrowth.pseries'></span><span id='topic+fgrowth.pdata.frame'></span><span id='topic+fgrowth.grouped_df'></span><span id='topic+G'></span><span id='topic+G.default'></span><span id='topic+G.matrix'></span><span id='topic+G.data.frame'></span><span id='topic+G.list'></span><span id='topic+G.pseries'></span><span id='topic+G.pdata.frame'></span><span id='topic+G.grouped_df'></span>

<h3>Description</h3>

<p><code>fgrowth</code> is a S3 generic to compute (sequences of) suitably lagged / leaded, iterated and compounded growth rates, obtained with via the exact method of computation or through log differencing. By default growth rates are provided in percentage terms, but any scale factor can be applied. The growth operator <code>G</code> is a parsimonious wrapper around <code>fgrowth</code>, and also provides more flexibility when applied to data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgrowth(x, n = 1, diff = 1, ...)
      G(x, n = 1, diff = 1, ...)

## Default S3 method:
fgrowth(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA,
        logdiff = FALSE, scale = 100, power = 1, stubs = TRUE, ...)
## Default S3 method:
G(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, logdiff = FALSE,
  scale = 100, power = 1, stubs = .op[["stub"]], ...)

## S3 method for class 'matrix'
fgrowth(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA,
        logdiff = FALSE, scale = 100, power = 1,
        stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'matrix'
G(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA, logdiff = FALSE,
  scale = 100, power = 1, stubs = .op[["stub"]], ...)

## S3 method for class 'data.frame'
fgrowth(x, n = 1, diff = 1, g = NULL, t = NULL, fill = NA,
        logdiff = FALSE, scale = 100, power = 1,
        stubs = length(n) + length(diff) &gt; 2L, ...)
## S3 method for class 'data.frame'
G(x, n = 1, diff = 1, by = NULL, t = NULL, cols = is.numeric,
  fill = NA, logdiff = FALSE, scale = 100, power = 1, stubs = .op[["stub"]],
  keep.ids = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fgrowth(x, n = 1, diff = 1, fill = NA, logdiff = FALSE, scale = 100,
        power = 1, stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pseries'
G(x, n = 1, diff = 1, fill = NA, logdiff = FALSE, scale = 100,
  power = 1, stubs = .op[["stub"]], shift = "time", ...)

## S3 method for class 'pdata.frame'
fgrowth(x, n = 1, diff = 1, fill = NA, logdiff = FALSE, scale = 100,
        power = 1, stubs = length(n) + length(diff) &gt; 2L, shift = "time", ...)
## S3 method for class 'pdata.frame'
G(x, n = 1, diff = 1, cols = is.numeric, fill = NA, logdiff = FALSE,
  scale = 100, power = 1, stubs = .op[["stub"]], shift = "time", keep.ids = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fgrowth(x, n = 1, diff = 1, t = NULL, fill = NA, logdiff = FALSE,
        scale = 100, power = 1, stubs = length(n) + length(diff) &gt; 2L,
        keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
G(x, n = 1, diff = 1, t = NULL, fill = NA, logdiff = FALSE,
  scale = 100, power = 1, stubs = .op[["stub"]], keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgrowth_+3A_x">x</code></td>
<td>
<p>a numeric vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_n">n</code></td>
<td>
<p>integer. A vector indicating the number of lags or leads.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_diff">diff</code></td>
<td>
<p>integer. A vector of integers &gt; 1 indicating the order of taking growth rates, e.g. <code>diff = 2</code> means computing the growth rate of the growth rate.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>. <em>Note</em> that without <code>t</code>, all values in a group need to be consecutive and in the right order. See Details of <code><a href="#topic+flag">flag</a></code>.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_t">t</code></td>
<td>
<p>a time vector or list of vectors. See <code><a href="#topic+flag">flag</a></code>.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to compute growth rates using a function, column names, indices or a logical vector. Default: All numeric variables. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_fill">fill</code></td>
<td>
<p>value to insert when vectors are shifted. Default is <code>NA</code>. </p>
</td></tr>
<tr><td><code id="fgrowth_+3A_logdiff">logdiff</code></td>
<td>
<p>logical. Compute log-difference growth rates instead of exact growth rates. See Details.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_scale">scale</code></td>
<td>
<p>logical. Scale factor post-applied to growth rates, default is 100 which gives growth rates in percentage terms. See Details.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_power">power</code></td>
<td>
<p>numeric. Apply a power to annualize or compound growth rates e.g. <code>fgrowth(AirPassengers, 12, power = 1/12)</code> is equivalent to <code>((AirPassengers/flag(AirPassengers, 12))^(1/12)-1)*100</code>.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_stubs">stubs</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will rename all computed columns by adding a prefix &quot;L<code>n</code>G<code>diff</code>.&quot; / &quot;F<code>n</code>G<code>diff</code>.&quot;, or &quot;L<code>n</code>Dlog<code>diff</code>.&quot; / &quot;F<code>n</code>Dlog<code>diff</code>.&quot; if <code>logdiff = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_shift">shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> or <code>"row"</code>. See <code><a href="#topic+flag">flag</a></code> for details.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_keep.ids">keep.ids</code></td>
<td>
<p><em>data.frame / pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all variables passed to <code>by</code> or <code>t</code> using formulas). <em>Note</em>: For 'grouped_df' / 'pdata.frame' identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td></tr>
<tr><td><code id="fgrowth_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fgrowth/G</code> by default computes exact growth rates using <code>repeat(diff) ((x[i]/x[i-n])^power - 1)*scale</code>, so for <code>diff &gt; 1</code> it computes growth rate of growth rates. If <code>logdiff = TRUE</code>, approximate growth rates are computed using <code>log(x[i]/x[i-n])*scale</code> for <code>diff = 1</code> and <code>repeat(diff-1) x[i] - x[i-n]</code> thereafter (usually <code>diff = 1</code> for log-differencing). For further details see the help pages of <code><a href="#topic+fdiff">fdiff</a></code> and <code><a href="#topic+flag">flag</a></code>.
</p>


<h3>Value</h3>

<p><code>x</code> where the growth rate was taken <code>diff</code> times using lags <code>n</code> of itself, scaled by <code>scale</code>. Computations can be grouped by <code>g/by</code> and/or ordered by <code>t</code>. See Details and Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag">flag/L/F</a></code>, <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Time Series: AirPassengers
G(AirPassengers)                      # Growth rate, same as fgrowth(AirPassengers)
G(AirPassengers, logdiff = TRUE)      # Log-difference
G(AirPassengers, 1, 2)                # Growth rate of growth rate
G(AirPassengers, 12)                  # Seasonal growth rate (data is monthly)

head(G(AirPassengers, -2:2, 1:3))     # Sequence of leaded/lagged and iterated growth rates

# let's do some visual analysis
plot(G(AirPassengers, c(0, 1, 12)))
plot(stl(window(G(AirPassengers, 12), # Taking seasonal growth rate removes most seasonal variation
                1950), "periodic"))


## Time Series Matrix of 4 EU Stock Market Indicators, recorded 260 days per year
plot(G(EuStockMarkets,c(0,260)))                    # Plot series and annual growth rates
summary(lm(L260G1.DAX ~., G(EuStockMarkets,260)))   # Annual growth rate of DAX regressed on the
                                                    # growth rates of the other indicators

## World Development Panel Data
head(fgrowth(num_vars(wlddev), 1, 1,                    # Computes growth rates of numeric variables
             wlddev$country, wlddev$year))              # fgrowth requires external inputs..
head(G(wlddev, 1, 1, ~country, ~year))                  # Growth of numeric variables, id's attached
head(G(wlddev, 1, 1, ~country))                         # Without t: Works because data is ordered
head(G(wlddev, 1, 1, PCGDP + LIFEEX ~ country, ~year))  # Growth of GDP per Capita &amp; Life Expectancy
head(G(wlddev, 0:1, 1, ~ country, ~year, cols = 9:10))  # Same, also retaining original series
head(G(wlddev, 0:1, 1, ~ country, ~year, 9:10,          # Dropping id columns
       keep.ids = FALSE))

</code></pre>

<hr>
<h2 id='fhdbetween-fhdwithin'>
Higher-Dimensional Centering and Linear Prediction
</h2><span id='topic+fhdbetween'></span><span id='topic+fhdbetween.default'></span><span id='topic+fhdbetween.matrix'></span><span id='topic+fhdbetween.data.frame'></span><span id='topic+fhdbetween.pseries'></span><span id='topic+fhdbetween.pdata.frame'></span><span id='topic+fhdwithin'></span><span id='topic+fhdwithin.default'></span><span id='topic+fhdwithin.matrix'></span><span id='topic+fhdwithin.data.frame'></span><span id='topic+fhdwithin.pseries'></span><span id='topic+fhdwithin.pdata.frame'></span><span id='topic+HDW'></span><span id='topic+HDW.default'></span><span id='topic+HDW.matrix'></span><span id='topic+HDW.data.frame'></span><span id='topic+HDW.pseries'></span><span id='topic+HDW.pdata.frame'></span><span id='topic+HDB'></span><span id='topic+HDB.default'></span><span id='topic+HDB.matrix'></span><span id='topic+HDB.data.frame'></span><span id='topic+HDB.pseries'></span><span id='topic+HDB.pdata.frame'></span>

<h3>Description</h3>

<p><code>fhdbetween</code> is a generalization of <code>fbetween</code> to efficiently predict with multiple factors and linear models (i.e. predict with vectors/factors, matrices, or data frames/lists where the latter may contain multiple factor variables). Similarly, <code>fhdwithin</code> is a generalization of <code>fwithin</code> to center on multiple factors and partial-out linear models.
</p>
<p>The corresponding operators <code>HDB</code> and <code>HDW</code> additionally allow to predict / partial out full <code>lm()</code> formulas with interactions between variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhdbetween(x, ...)
 fhdwithin(x, ...)
       HDB(x, ...)
       HDW(x, ...)

## Default S3 method:
fhdbetween(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)
## Default S3 method:
fhdwithin(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)
## Default S3 method:
HDB(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)
## Default S3 method:
HDW(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)

## S3 method for class 'matrix'
fhdbetween(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)
## S3 method for class 'matrix'
fhdwithin(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, lm.method = "qr", ...)
## S3 method for class 'matrix'
HDB(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, stub = .op[["stub"]],
    lm.method = "qr", ...)
## S3 method for class 'matrix'
HDW(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE, stub = .op[["stub"]],
    lm.method = "qr", ...)

## S3 method for class 'data.frame'
fhdbetween(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
           variable.wise = FALSE, lm.method = "qr", ...)
## S3 method for class 'data.frame'
fhdwithin(x, fl, w = NULL, na.rm = .op[["na.rm"]], fill = FALSE,
          variable.wise = FALSE, lm.method = "qr", ...)
## S3 method for class 'data.frame'
HDB(x, fl, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]], fill = FALSE,
    variable.wise = FALSE, stub = .op[["stub"]], lm.method = "qr", ...)
## S3 method for class 'data.frame'
HDW(x, fl, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]], fill = FALSE,
    variable.wise = FALSE, stub = .op[["stub"]], lm.method = "qr", ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fhdbetween(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE, ...)
## S3 method for class 'pseries'
fhdwithin(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE, ...)
## S3 method for class 'pseries'
HDB(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE, ...)
## S3 method for class 'pseries'
HDW(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE, ...)

## S3 method for class 'pdata.frame'
fhdbetween(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE,
           variable.wise = TRUE, ...)
## S3 method for class 'pdata.frame'
fhdwithin(x, effect = "all", w = NULL, na.rm = .op[["na.rm"]], fill = TRUE,
          variable.wise = TRUE, ...)
## S3 method for class 'pdata.frame'
HDB(x, effect = "all", w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
    fill = TRUE, variable.wise = TRUE, stub = .op[["stub"]], ...)
## S3 method for class 'pdata.frame'
HDW(x, effect = "all", w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
    fill = TRUE, variable.wise = TRUE, stub = .op[["stub"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fhdbetween-fhdwithin_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame, 'indexed_series' ('pseries') or 'indexed_frame' ('pdata.frame').</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_fl">fl</code></td>
<td>
<p>a numeric vector, factor, matrix, data frame or list (which may or may not contain factors). In the <code>HDW/HDB</code> data frame method <code>fl</code> can also be a one-or two sided <code>lm()</code> formula with variables contained in <code>x</code>. Interactions <code>(:)</code> and full interactions <code>(*)</code> are supported. See Examples and the Note.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_w">w</code></td>
<td>
<p>a vector of (non-negative) weights.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_cols">cols</code></td>
<td>
<p><em>data.frame methods</em>: Select columns to center (partial-out) or predict using column names, indices, a logical vector or a function. Unless specified otherwise all numeric columns are selected. If <code>NULL</code>, all columns are selected.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values from both <code>x</code> and <code>fl</code>. by default rows with missing values in <code>x</code> or <code>fl</code> are removed. In that case an attribute &quot;na.rm&quot; is attached containing the rows removed.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_fill">fill</code></td>
<td>
<p>If <code>na.rm = TRUE</code>, <code>fill = TRUE</code> will not remove rows with missing values in <code>x</code> or <code>fl</code>, but fill them with <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_variable.wise">variable.wise</code></td>
<td>
<p><em>(p)data.frame methods</em>: Setting <code>variable.wise = TRUE</code> will process each column individually i.e. use all non-missing cases in each column and in <code>fl</code> (<code>fl</code> is only checked for missing values if <code>na.rm = TRUE</code>). This is a lot less efficient but uses all data available in each column. </p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifiers should be used for centering. 1L takes the first variable in the <a href="#topic+indexing">index</a>, 2L the second etc.. Index variables can also be called by name using a character vector. The keyword <code>"all"</code> uses all identifiers. </p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_stub">stub</code></td>
<td>
<p>character. A prefix/stub to add to the names of all transformed columns. <code>TRUE</code> (default) uses <code>"HDW."/"HDB."</code>, <code>FALSE</code> will not rename columns.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_lm.method">lm.method</code></td>
<td>
<p>character. The linear fitting method. Supported are <code>"chol"</code> and <code>"qr"</code>. See <code><a href="#topic+flm">flm</a></code>.</p>
</td></tr>
<tr><td><code id="fhdbetween-fhdwithin_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>fixest::demean</code> (other than <code>notes</code> and <code>im_confident</code>) and <code><a href="Matrix.html#topic+chol">chol</a></code> / <code><a href="Matrix.html#topic+qr">qr</a></code>. Possible choices are <code>tol</code> to set a uniform numerical tolerance for the entire fitting process, or <code>nthreads</code> and <code>iter</code> to govern the higher-order centering process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fhdbetween/HDB</code> and <code>fhdwithin/HDW</code> are powerful functions for high-dimensional linear prediction problems involving large factors and datasets, but can just as well handle ordinary regression problems. They are implemented as efficient wrappers around <code><a href="#topic+fwithin">fbetween / fwithin</a></code>, <code><a href="#topic+flm">flm</a></code> and some C++ code from the <code>fixest</code> package that is imported for higher-order centering tasks (thus <code>fixest</code> needs to be installed for problems involving more than one factor).
</p>
<p>Intended areas of use are to efficiently obtain residuals and predicted values from data, and to prepare data for complex linear models involving multiple levels of fixed effects. Such models can now be fitted using <code>(g)lm()</code> on data prepared with <code>fhdwithin / HDW</code> (relying on bootstrapped SE's for inference, or implementing the appropriate corrections). See Examples.
</p>
<p>If <code>fl</code> is a vector or matrix, the result are identical to <code>lm</code> i.e. <code>fhdbetween / HDB</code> returns <code>fitted(lm(x ~ fl))</code> and <code>fhdwithin / HDW</code> <code>residuals(lm(x ~ fl))</code>. If <code>fl</code> is a list containing factors, all variables in <code>x</code> and non-factor variables in <code>fl</code> are centered on these factors using either <code><a href="#topic+fwithin">fbetween / fwithin</a></code> for a single factor or <code>fixest</code> C++ code for multiple factors. Afterwards the centered data is regressed on the centered predictors. If <code>fl</code> is just a list of factors, <code>fhdwithin/HDW</code> returns the centered data and <code>fhdbetween/HDB</code> the corresponding means. Take as a most general example a list <code>fl = list(fct1, fct2, ..., var1, var2, ...)</code> where <code>fcti</code> are factors and <code>vari</code> are continuous variables. The output of <code>fhdwithin/HDW | fhdbetween/HDB</code> will then be identical to calling <code>resid | fitted</code> on <code>lm(x ~ fct1 + fct2 + ... + var1 + var2 + ...)</code>. The computations performed by <code>fhdwithin/HDW</code> and <code>fhdbetween/HDB</code> are however much faster and more memory efficient than <code>lm</code> because factors are not passed to <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> and expanded to matrices of dummies but projected out beforehand.
</p>
<p>The formula interface to the data.frame method (only supported by the operators <code>HDW | HDB</code>) provides ease of use and allows for additional modeling complexity. For example it is possible to project out formulas like <code>HDW(data, ~ fct1*var1  + fct2:fct3 + var2:fct2:fct3 + var2:var3 + poly(var5,3)*fct5)</code> containing simple <code>(:)</code> or full <code>(*)</code> interactions of factors with continuous variables or polynomials of continuous variables, and two-or three-way interactions of factors and continuous variables. If the formula is one-sided as in the example above (the space left of <code>(~)</code> is left empty), the formula is applied to all variables selected through <code>cols</code>. The specification provided in <code>cols</code> (default: all numeric variables not used in the formula) can be overridden by supplying one-or more dependent variables. For example <code>HDW(data, var1 + var2 ~ fct1 + fct2)</code> will return a data.frame with <code>var1</code> and <code>var2</code> centered on <code>fct1</code> and <code>fct2</code>.
</p>
<p>The special methods for 'indexed_series' (<code>plm::pseries</code>) and 'indexed_frame's (<code>plm::pdata.frame</code>) center a panel series or variables in a panel data frame on all panel-identifiers. By default in these methods <code>fill = TRUE</code> and <code>variable.wise = TRUE</code>, so missing values are kept. This change in the default arguments was done to ensure a coherent framework of functions and operators applied to <em>plm</em> panel data classes.
</p>


<h3>Value</h3>

<p><code>HDB</code> returns fitted values of regressing <code>x</code> on <code>fl</code>. <code>HDW</code> returns residuals. See Details and Examples.
</p>


<h3>Note</h3>






<h4>On the differences between <code>fhdwithin/HDW</code>... and <code>fwithin/W</code>...:</h4>


<ul>
<li> <p><code>fhdwithin/HDW</code> can center data on multiple factors and also partial out continuous variables and factor-continuous interactions while <code>fwithin/W</code> only centers on one factor or the interaction of a set of factors, and does that very efficiently.
</p>
</li>
<li> <p><code>HDW(data, ~ qF(group1) + qF(group2))</code> simultaneously centers numeric variables in data on <code>group1</code> and <code>group2</code>, while <code>W(data, ~ group1 + group2)</code> centers data on the interaction of <code>group1</code> and <code>group2</code>. The equivalent operation in <code>HDW</code> would be: <code>HDW(data, ~ qF(group1):qF(group2))</code>.
</p>
</li>
<li> <p><code>W</code> always does computations on the variable-wise complete observations (in both matrices and data frames), whereas by default <code>HDW</code> removes all cases missing in either <code>x</code> or <code>fl</code>. In short, <code>W(data, ~ group1 + group2)</code> is actually equivalent to <code>HDW(data, ~ qF(group1):qF(group2), variable.wise = TRUE)</code>. <code>HDW(data, ~ qF(group1):qF(group2))</code> would remove any missing cases.
</p>
</li>
<li> <p><code>fbetween/B</code> and <code>fwithin/W</code> have options to fill missing cases using group-averages and to add the overall mean back to group-demeaned data. These options are not available in <code>fhdbetween/HDB</code> and <code>fhdwithin/HDW</code>. Since <code>HDB</code> and <code>HDW</code> by default remove missing cases, they also don't have options to keep grouping-columns as in <code>B</code> and <code>W</code>.
</p>
</li></ul>




<h3>See Also</h3>

<p><code><a href="#topic+fbetween">fbetween, fwithin</a></code>, <code><a href="#topic+fscale">fscale</a></code>, <code><a href="#topic+TRA">TRA</a></code>, <code><a href="#topic+flm">flm</a></code>, <code><a href="#topic+fFtest">fFtest</a></code>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HDW(mtcars$mpg, mtcars$carb)                   # Simple regression problems
HDW(mtcars$mpg, mtcars[-1])
HDW(mtcars$mpg, qM(mtcars[-1]))
head(HDW(qM(mtcars[3:4]), mtcars[1:2]))
head(HDW(iris[1:2], iris[3:4]))                # Partialling columns 3 and 4 out of columns 1 and 2
head(HDW(iris[1:2], iris[3:5]))                # Adding the Species factor -&gt; fixed effect

head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c + qF(year))) # Partialling out 2 fixed effects
head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c + qF(year), variable.wise = TRUE)) # Variable-wise
head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c + qF(year) + ODA)) # Adding ODA as a continuous regressor
head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c:qF(decade) + qF(year) + ODA)) # Country-decade and year FE's

head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c*year))          # Country specific time trends
head(HDW(wlddev, PCGDP + LIFEEX ~ iso3c*poly(year, 3))) # Country specific cubic trends

# More complex examples
lm(HDW.mpg ~ HDW.hp, data = HDW(mtcars, ~ factor(cyl)*carb + vs + wt:gear + wt:gear:carb))
lm(mpg ~ hp + factor(cyl)*carb + vs + wt:gear + wt:gear:carb, data = mtcars)

lm(HDW.mpg ~ HDW.hp, data = HDW(mtcars, ~ factor(cyl)*carb + vs + wt:gear))
lm(mpg ~ hp + factor(cyl)*carb + vs + wt:gear, data = mtcars)

lm(HDW.mpg ~ HDW.hp, data = HDW(mtcars, ~ cyl*carb + vs + wt:gear))
lm(mpg ~ hp + cyl*carb + vs + wt:gear, data = mtcars)

lm(HDW.mpg ~ HDW.hp, data = HDW(mtcars, mpg + hp ~ cyl*carb + factor(cyl)*poly(drat,2)))
lm(mpg ~ hp + cyl*carb + factor(cyl)*poly(drat,2), data = mtcars)

</code></pre>

<hr>
<h2 id='flag'>
Fast Lags and Leads for Time Series and Panel Data
</h2><span id='topic+flag'></span><span id='topic+flag.default'></span><span id='topic+flag.matrix'></span><span id='topic+flag.data.frame'></span><span id='topic+flag.pseries'></span><span id='topic+flag.pdata.frame'></span><span id='topic+flag.grouped_df'></span><span id='topic+L'></span><span id='topic+L.default'></span><span id='topic+L.matrix'></span><span id='topic+L.data.frame'></span><span id='topic+L.pseries'></span><span id='topic+L.pdata.frame'></span><span id='topic+L.grouped_df'></span><span id='topic+F'></span><span id='topic+F.default'></span><span id='topic+F.matrix'></span><span id='topic+F.data.frame'></span><span id='topic+F.pseries'></span><span id='topic+F.pdata.frame'></span><span id='topic+F.grouped_df'></span>

<h3>Description</h3>

<p><code>flag</code> is an S3 generic to compute (sequences of) lags and leads. <code>L</code> and <code>F</code> are wrappers around <code>flag</code> representing the lag- and lead-operators, such that <code>L(x,-1) = F(x,1) = F(x)</code> and <code>L(x,-3:3) = F(x,3:-3)</code>. <code>L</code> and <code>F</code> provide more flexibility than <code>flag</code> when applied to data frames (i.e.  column subsetting, formula input and id-variable-preservation capabilities...), but are otherwise identical.
</p>
<p><em>Note:</em> Since v1.9.0, <code>F</code> is no longer exported, but can be accessed using <code>collapse:::F</code>, or through setting <code>options(collapse_export_F = TRUE)</code> before loading the package. The syntax is the same as <code>L</code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>flag(x, n = 1, ...)
   L(x, n = 1, ...)

## Default S3 method:
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = TRUE, ...)
## Default S3 method:
L(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = .op[["stub"]], ...)

## S3 method for class 'matrix'
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = length(n) &gt; 1L, ...)
## S3 method for class 'matrix'
L(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = .op[["stub"]], ...)

## S3 method for class 'data.frame'
flag(x, n = 1, g = NULL, t = NULL, fill = NA, stubs = length(n) &gt; 1L, ...)
## S3 method for class 'data.frame'
L(x, n = 1, by = NULL, t = NULL, cols = is.numeric,
  fill = NA, stubs = .op[["stub"]], keep.ids = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
flag(x, n = 1, fill = NA, stubs = length(n) &gt; 1L, shift = "time", ...)
## S3 method for class 'pseries'
L(x, n = 1, fill = NA, stubs = .op[["stub"]], shift = "time", ...)

## S3 method for class 'pdata.frame'
flag(x, n = 1, fill = NA, stubs = length(n) &gt; 1L, shift = "time", ...)
## S3 method for class 'pdata.frame'
L(x, n = 1, cols = is.numeric, fill = NA, stubs = .op[["stub"]],
  shift = "time", keep.ids = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
flag(x, n = 1, t = NULL, fill = NA, stubs = length(n) &gt; 1L, keep.ids = TRUE, ...)
## S3 method for class 'grouped_df'
L(x, n = 1, t = NULL, fill = NA, stubs = .op[["stub"]], keep.ids = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_+3A_x">x</code></td>
<td>
<p>a vector / time series, (time series) matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df'). Data must not be numeric.</p>
</td></tr>
<tr><td><code id="flag_+3A_n">n</code></td>
<td>
<p>integer. A vector indicating the lags / leads to compute (passing negative integers to <code>flag</code> or <code>L</code> computes leads, passing negative integers to <code>F</code> computes lags).</p>
</td></tr>
<tr><td><code id="flag_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>. <em>Note</em> that without <code>t</code>, all values in a group need to be consecutive and in the right order. See Details.</p>
</td></tr>
<tr><td><code id="flag_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="flag_+3A_t">t</code></td>
<td>
<p>a time vector or list of vectors. Data frame methods also allows one-sided formula i.e. <code>~time</code>. grouped_df method supports lazy-evaluation i.e. <code>time</code> (no quotes). Either support wrapping a transformation function e.g. <code>~timeid(time)</code>, <code>qG(time)</code> etc.. See also Details on how <code>t</code> is processed.</p>
</td></tr>
<tr><td><code id="flag_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to lag using a function, column names, indices or a logical vector. Default: All numeric variables. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="flag_+3A_fill">fill</code></td>
<td>
<p>value to insert when vectors are shifted. Default is <code>NA</code>. </p>
</td></tr>
<tr><td><code id="flag_+3A_stubs">stubs</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will rename all lagged / leaded columns by adding a stub or prefix &quot;L<code>n</code>.&quot; / &quot;F<code>n</code>.&quot;.</p>
</td></tr>
<tr><td><code id="flag_+3A_shift">shift</code></td>
<td>
<p><em>pseries / pdata.frame methods</em>: character. <code>"time"</code> performs a fully identified time-lag (if the index contains a time variable), whereas <code>"row"</code> performs a simple (group) lag, where observations are shifted based on the present order of rows (in each group). The latter is significantly faster, but requires time series / panels to be regularly spaced and sorted by time within each group.</p>
</td></tr>
<tr><td><code id="flag_+3A_keep.ids">keep.ids</code></td>
<td>
<p><em>data.frame / pdata.frame / grouped_df methods</em>: Logical. Drop all identifiers from the output (which includes all variables passed to <code>by</code> or <code>t</code> using formulas). <em>Note</em>: For 'grouped_df' / 'pdata.frame' identifiers are dropped, but the <code>"groups"</code> / <code>"index"</code> attributes are kept.</p>
</td></tr>
<tr><td><code id="flag_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a single integer is passed to <code>n</code>, and <code>g/by</code> and <code>t</code> are left empty, <code>flag/L/F</code> just returns <code>x</code> with all columns lagged / leaded by <code>n</code>. If <code>length(n)&gt;1</code>, and <code>x</code> is an atomic vector (time series), <code>flag/L/F</code> returns a (time series) matrix with lags / leads computed in the same order as passed to <code>n</code>. If instead <code>x</code> is a matrix / data frame, a matrix / data frame with <code>ncol(x)*length(n)</code> columns is returned where columns are sorted first by variable and then by lag (so all lags computed on a variable are grouped together). <code>x</code> can be of any standard data type.
</p>
<p>With groups/panel-identifiers supplied to <code>g/by</code>, <code>flag/L/F</code> efficiently computes a panel-lag/lead by shifting the entire vector(s) but inserting <code>fill</code> elements in the right places. If <code>t</code> is left empty, the data needs to be ordered such that all values belonging to a group are consecutive and in the right order. It is not necessary that the groups themselves are alphabetically ordered. If a time-variable is supplied to <code>t</code> (or a list of time-variables uniquely identifying the time-dimension), the series / panel is fully identified and lags / leads can be securely computed even if the data is unordered / irregular.
</p>





<p><b>Note</b> that the <code>t</code> argument is processed as follows: If <code>is.factor(t) || (is.numeric(t) &amp;&amp; !is.object(t))</code> (i.e. <code>t</code> is a factor or plain numeric vector), it is assumed to represent unit timesteps (e.g. a 'year' variable in a typical dataset), and thus coerced to integer using <code>as.integer(t)</code> and directly passed to C++ without further checks or transformations at the R-level. Otherwise, if <code>is.object(t) &amp;&amp; is.numeric(unclass(t))</code> (i.e. <code>t</code> is a numeric time object, most likely 'Date' or 'POSIXct'), this object is passed through <code><a href="#topic+timeid">timeid</a></code> before going to C++. Else (e.g. <code>t</code> is character), it is passed through <code><a href="#topic+qG">qG</a></code> which performs ordered grouping. If <code>t</code> is a list of multiple variables, it is passed through <code><a href="#topic+finteraction">finteraction</a></code>. You can customize this behavior by calling any of these functions (including <code>unclass/as.integer</code>) on your time variable beforehand.
</p>
<p>At the C++ level, if both <code>g/by</code> and <code>t</code> are supplied, <code>flag</code> works as follows: Use two initial passes to create an ordering through which the data are accessed. First-pass: Calculate minimum and maximum time-value for each individual. Second-pass: Generate an internal ordering vector (<code>o</code>) by placing the current element index into the vector slot obtained by adding the cumulative group size and the current time-value subtracted its individual-minimum together. This method of computation is faster than any sort-based method and delivers optimal performance if the panel-id supplied to <code>g/by</code> is already a factor variable, and if <code>t</code> is an integer/factor variable. For irregular time/panel series, <code>length(o) &gt; length(x)</code>, and <code>o</code> represents the unobserved 'complete series'. If <code>length(o) &gt; 1e7 &amp;&amp; length(o) &gt; 3*length(x)</code>, a warning is issued to make you aware of potential performance implications of the oversized ordering vector.
</p>


<p>The 'indexed_series' ('pseries') and 'indexed_frame' ('pdata.frame')  methods automatically utilize the identifiers attached to these objects, which are already factors, thus lagging is quite efficient. However, the internal ordering vector still needs to be computed, thus if data are known to be ordered and regularly spaced, using <code>shift = "row"</code> to toggle a simple group-lag (same as utilizing <code>g</code> but not <code>t</code> in other methods) can yield a significant performance gain.
</p>



<h3>Value</h3>

<p><code>x</code> lagged / leaded <code>n</code>-times, grouped by <code>g/by</code>, ordered by <code>t</code>. See Details and Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdiff">fdiff</a></code>, <code><a href="#topic+fgrowth">fgrowth</a></code>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Time Series: AirPassengers
L(AirPassengers)                      # 1 lag
flag(AirPassengers)                   # Same
L(AirPassengers, -1)                  # 1 lead

head(L(AirPassengers, -1:3))          # 1 lead and 3 lags - output as matrix

## Time Series Matrix of 4 EU Stock Market Indicators, 1991-1998
tsp(EuStockMarkets)                                     # Data is recorded on 260 days per year
freq &lt;- frequency(EuStockMarkets)
plot(stl(EuStockMarkets[,"DAX"], freq))                 # There is some obvious seasonality
head(L(EuStockMarkets, -1:3 * freq))                    # 1 annual lead and 3 annual lags
summary(lm(DAX ~., data = L(EuStockMarkets,-1:3*freq))) # DAX regressed on its own annual lead,
                                                        # lags and the lead/lags of the other series
## World Development Panel Data
head(flag(wlddev, 1, wlddev$iso3c, wlddev$year))        # This lags all variables,
head(L(wlddev, 1, ~iso3c, ~year))                       # This lags all numeric variables
head(L(wlddev, 1, ~iso3c))                              # Without t: Works because data is ordered
head(L(wlddev, 1, PCGDP + LIFEEX ~ iso3c, ~year))       # This lags GDP per Capita &amp; Life Expectancy
head(L(wlddev, 0:2, ~ iso3c, ~year, cols = 9:10))       # Same, also retaining original series
head(L(wlddev, 1:2, PCGDP + LIFEEX ~ iso3c, ~year,      # Two lags, dropping id columns
       keep.ids = FALSE))

# Regressing GDP on its's lags and life-Expectancy and its lags
summary(lm(PCGDP ~ ., L(wlddev, 0:2, ~iso3c, ~year, 9:10, keep.ids = FALSE)))

## Indexing the data: facilitates time-based computations
wldi &lt;- findex_by(wlddev, iso3c, year)
head(L(wldi, 0:2, cols = 9:10))                              # Again 2 lags of GDP and LIFEEX
head(L(wldi$PCGDP))                                          # Lagging an indexed series
summary(lm(PCGDP ~ L(PCGDP,1:2) + L(LIFEEX,0:2), wldi))      # Running the lm again
summary(lm(PCGDP ~ ., L(wldi, 0:2, 9:10, keep.ids = FALSE))) # Same thing

## Using grouped data:
library(magrittr)
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(PCGDP,LIFEEX) |&gt; flag(0:2)
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(year,PCGDP,LIFEEX) |&gt; flag(0:2,year) # Also using t (safer)
</code></pre>

<hr>
<h2 id='flm'>
Fast (Weighted) Linear Model Fitting 
</h2><span id='topic+flm'></span><span id='topic+flm.default'></span><span id='topic+flm.formula'></span>

<h3>Description</h3>

<p><code>flm</code> is a fast linear model command that (by default) only returns a coefficient matrix. 6 different efficient fitting methods are implemented: 4 using base R linear algebra, and 2 utilizing the <em>RcppArmadillo</em> and <em>RcppEigen</em> packages. The function itself only has an overhead of 5-10 microseconds, and is thus well suited as a bootstrap workhorse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flm(...)  # Internal method dispatch: default if is.atomic(..1)

## Default S3 method:
flm(y, X, w = NULL, add.icpt = FALSE, return.raw = FALSE, 
    method = c("lm", "solve", "qr", "arma", "chol", "eigen"),
    eigen.method = 3L, ...)

## S3 method for class 'formula'
flm(formula, data = NULL, weights = NULL, add.icpt = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flm_+3A_y">y</code></td>
<td>
<p>a response vector or matrix. Multiple dependent variables are only supported by methods &quot;lm&quot;, &quot;solve&quot;, &quot;qr&quot; and &quot;chol&quot;.</p>
</td></tr>
<tr><td><code id="flm_+3A_x">X</code></td>
<td>
<p>a matrix of regressors.</p>
</td></tr>
<tr><td><code id="flm_+3A_w">w</code></td>
<td>
<p>a weight vector.</p>
</td></tr>
<tr><td><code id="flm_+3A_add.icpt">add.icpt</code></td>
<td>
<p>logical. <code>TRUE</code> adds an intercept column named '(Intercept)' to <code>X</code>.</p>
</td></tr>
<tr><td><code id="flm_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+lm">lm</a></code> formula, without factors, interaction terms or other operators (<code>:</code>, <code>*</code>, <code>^</code>, <code>-</code>, etc.), may include regular transformations e.g. <code>log(var)</code>, <code>cbind(y1, y2)</code>, <code>magrittr::multiply_by(var1, var2)</code>, <code>magrittr::raise_to_power(var, 2)</code>.</p>
</td></tr>
<tr><td><code id="flm_+3A_data">data</code></td>
<td>
<p>a named list or data frame.</p>
</td></tr>
<tr><td><code id="flm_+3A_weights">weights</code></td>
<td>
<p>a weights vector or expression that results in a vector when evaluated in the <code>data</code> environment.</p>
</td></tr>

<tr><td><code id="flm_+3A_return.raw">return.raw</code></td>
<td>
<p>logical. <code>TRUE</code> returns the original output from the different methods. For 'lm', 'arma' and 'eigen', this includes additional statistics such as residuals, fitted values or standard errors. The other methods just return coefficients but in different formats. </p>
</td></tr>
<tr><td><code id="flm_+3A_method">method</code></td>
<td>
<p>an integer or character string specifying the method of computation:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "lm"   </td><td style="text-align: left;"></td><td style="text-align: left;"> uses <code><a href="stats.html#topic+.lm.fit">.lm.fit</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "solve" </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>solve(crossprod(X), crossprod(X, y))</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "qr"   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>qr.coef(qr(X), y)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "arma"   </td><td style="text-align: left;"></td><td style="text-align: left;"> uses <code>RcppArmadillo::fastLmPure</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "chol"   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>chol2inv(chol(crossprod(X))) %*% crossprod(X, y)</code> (quite fast, requires <code>crossprod(X)</code> to be positive definite i.e. problematic if multicollinearity).  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "eigen"   </td><td style="text-align: left;"></td><td style="text-align: left;"> uses <code>RcppEigen::fastLmPure</code> (very fast but, depending on the method, also unstable if multicollinearity). </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="flm_+3A_eigen.method">eigen.method</code></td>
<td>
<p>integer. Select the method of computation used by <code>RcppEigen::fastLmPure</code>:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em> </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 0 </td><td style="text-align: left;"></td><td style="text-align: left;"> column-pivoted QR decomposition. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> unpivoted QR decomposition. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> LLT Cholesky. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> LDLT Cholesky. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> Jacobi singular value decomposition (SVD).  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> method based on the eigenvalue-eigenvector decomposition of X'X. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>See <code>vignette("RcppEigen-Introduction", package = "RcppEigen")</code> for details on these methods and benchmark results. Run <code>source(system.file("examples", "lmBenchmark.R", package = "RcppEigen"))</code> to re-run the benchmark on your machine.
</p>
</td></tr>
<tr><td><code id="flm_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods. For the formula method further arguments passed to the default method. Additional arguments can also be passed to the default method e.g. <code>tol = value</code> to set a numerical tolerance for the solution - applicable with methods &quot;lm&quot;, &quot;solve&quot; and &quot;qr&quot; (default is <code>1e-7</code>), or <code>LAPACK = TRUE</code> with method &quot;qr&quot; to use LAPACK routines to for the qr decomposition (typically faster than the LINPACK default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.raw = FALSE</code>, a matrix of coefficients with the rows corresponding to the columns of <code>X</code>, otherwise the raw results from the various methods are returned.
</p>


<h3>Note</h3>

<p>Method &quot;qr&quot; supports sparse matrices, so for an <code>X</code> matrix with many dummy variables consider method &quot;qr&quot; passing <code>as(X, "dgCMatrix")</code> instead of just <code>X</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HDW">fhdwithin/HDW</a></code>, <code><a href="#topic+fFtest">fFtest</a></code>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple usage
coef &lt;- flm(mpg ~ hp + carb, mtcars, w = wt)

# Same thing in programming usage
flm(mtcars$mpg, qM(mtcars[c("hp","carb")]), mtcars$wt, add.icpt = TRUE)

# Check this is correct
lmcoef &lt;- coef(lm(mpg ~ hp + carb, weights = wt, mtcars))
all.equal(drop(coef), lmcoef)

# Multi-dependent variable (only some methods)
flm(cbind(mpg, qsec) ~ hp + carb, mtcars, w = wt)

# Returning raw results from solver: different for different methods
flm(mpg ~ hp + carb, mtcars, return.raw = TRUE)
flm(mpg ~ hp + carb, mtcars, method = "qr", return.raw = TRUE)
 
# Test that all methods give the same result
all_obj_equal(lapply(1:6, function(i)
  flm(mpg ~ hp + carb, mtcars, w = wt, method = i)))

</code></pre>

<hr>
<h2 id='fmatch'>Fast Matching</h2><span id='topic+fmatch'></span><span id='topic+ckmatch'></span><span id='topic++25+21in+25'></span><span id='topic++25+21iin+25'></span><span id='topic++25iin+25'></span>

<h3>Description</h3>

<p>Fast matching of elements/rows in <code>x</code> to elements/rows in <code>table</code>.
</p>
<p>This is a much faster replacement for <code><a href="base.html#topic+match">match</a></code> that works
with atomic vectors and data frames / lists of equal-length vectors. It is the workhorse function of <code><a href="#topic+join">join</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmatch(x, table, nomatch = NA_integer_,
       count = FALSE, overid = 1L)

# Check match: throws an informative error for non-matched elements
# Default message reflects frequent internal use to check data frame columns
ckmatch(x, table, e = "Unknown columns:", ...)

# Infix operators based on fmatch():
x %!in% table   # Opposite of %in%
x %iin% table   # = which(x %in% table), but more efficient
x %!iin% table  # = which(x %!in% table), but more efficient
# Use set_collapse(mask = "%in%") to replace %in% with
# a much faster version based on fmatch()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmatch_+3A_x">x</code></td>
<td>
<p>a vector, list or data frame whose elements are matched against <code>table</code>. If a list/data frame, matches are found by comparing rows, unlike <code><a href="base.html#topic+match">match</a></code> which compares columns. </p>
</td></tr>
<tr><td><code id="fmatch_+3A_table">table</code></td>
<td>
<p>a vector, list or data frame to match against.</p>
</td></tr>
<tr><td><code id="fmatch_+3A_nomatch">nomatch</code></td>
<td>
<p>integer. Value to be returned in the case when no match is found. Default is <code>NA_integer_</code>.</p>
</td></tr>
<tr><td><code id="fmatch_+3A_count">count</code></td>
<td>
<p>logical. Counts number of (unique) matches and attaches 4 attributes:
</p>

<ul>
<li> <p><code>"N.nomatch"</code>: The number of elements in <code>x</code> not matched <code>= sum(result == nomatch)</code>.
</p>
</li>
<li> <p><code>"N.groups"</code>: The size of the table <code> = NROW(table)</code>.
</p>
</li>
<li> <p><code>"N.distinct"</code>: The number of unique matches <code> = fndistinct(result[result != nomatch])</code>.
</p>
</li>
<li> <p><code>"class"</code>: The <code><a href="#topic+qG">&quot;qG&quot;</a></code> class: needed for optimized computations on the results object (e.g. <code>funique(result)</code>, which is needed for a full join).
</p>
</li></ul>

<p><em>Note</em> that computing these attributes requires an extra pass through the matching vector. Also note that these attributes contain no general information about whether either <code>x</code> or <code>table</code> are unique, except for two special cases when N.groups = N.distinct (table is unique) or length(result) = N.distinct (x is unique). Otherwise use <code><a href="#topic+any_duplicated">any_duplicated</a></code> to check x/table.
</p>
</td></tr>
<tr><td><code id="fmatch_+3A_overid">overid</code></td>
<td>
<p>integer. If <code>x/table</code> are lists/data frames, <code>fmatch</code> compares the rows incrementally, starting with the first two columns, and matching further columns as necessary (see Details). Overidentification corresponds to the case when a subset of the columns uniquely identify the data. In this case this argument controls the behavior:
</p>

<ul>
<li> <p><code>0</code>: Early termination: stop matching additional columns. Most efficient.
</p>
</li>
<li> <p><code>1</code>: Continue matching columns and issue a warning that the data is overidentified.
</p>
</li>
<li> <p><code>2</code>: Continue matching columns without warning.
</p>
</li></ul>

</td></tr>
<tr><td><code id="fmatch_+3A_e">e</code></td>
<td>
<p>the error message thrown by <code>ckmatch</code> for non-matched elements. The message is followed by the comma-separated non-matched elements.</p>
</td></tr>
<tr><td><code id="fmatch_+3A_...">...</code></td>
<td>
<p>further arguments to <code>fmatch</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With data frames / lists, <code>fmatch</code> compares the rows but moves through the data on a column-by-column basis (like a vectorized hash join algorithm). With two or more columns, the first two columns are hashed simultaneously for speed. Further columns can be added to this match. It is likely that the first 2, 3, 4 etc. columns of a data frame fully identify the data. After each column <code>fmatch()</code> internally checks whether the <code>table</code> rows that are still eligible for matching (eliminating <code>nomatch</code> rows from earlier columns) are unique. If this is the case and <code>overid = 0</code>, <code>fmatch()</code> terminates early without considering further columns. This is efficient but may give undesirable/wrong results if considering further columns would turn some additional elements of the result vector into <code>nomatch</code> values.
</p>


<h3>Value</h3>

<p>Integer vector containing the positions of first matches of <code>x</code> in <code>table</code>. <code>nomatch</code> is returned for elements of <code>x</code> that have no match in <code>table</code>. If <code>count = TRUE</code>, the result has additional attributes and a class <code><a href="#topic+qG">&quot;qG&quot;</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+join">join</a></code>, <code><a href="#topic+funique">funique</a></code>, <code><a href="#topic+group">group</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("b", "c", "a", "e", "f", "ff")
fmatch(x, letters)
fmatch(x, letters, nomatch = 0)
fmatch(x, letters, count = TRUE)

# Table 1
df1 &lt;- data.frame(
  id1 = c(1, 1, 2, 3),
  id2 = c("a", "b", "b", "c"),
  name = c("John", "Bob", "Jane", "Carl")
)
head(df1)
# Table 2
df2 &lt;- data.frame(
  id1 = c(1, 2, 3, 3),
  id2 = c("a", "b", "c", "e"),
  name = c("John", "Janne", "Carl", "Lynne")
)
head(df2)

# This gives an overidentification warning: columns 1:2 identify the data
if(FALSE) fmatch(df1, df2)
# This just runs through without warning
fmatch(df1, df2, overid = 2)
# This terminates computation after first 2 columns
fmatch(df1, df2, overid = 0)
fmatch(df1[1:2], df2[1:2])  # Same thing!
# -&gt; note that here we get an additional match based on the unique ids,
# which we didn't get before because "Jane" != "Janne"
</code></pre>

<hr>
<h2 id='fmean'>Fast (Grouped, Weighted) Mean for Matrix-Like Objects</h2><span id='topic+fmean'></span><span id='topic+fmean.default'></span><span id='topic+fmean.matrix'></span><span id='topic+fmean.data.frame'></span><span id='topic+fmean.grouped_df'></span>

<h3>Description</h3>

<p><code>fmean</code> is a generic function that computes the (column-wise) mean of <code>x</code>, (optionally) grouped by <code>g</code> and/or weighted by <code>w</code>.
The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped, weighted) mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmean(x, ...)

## Default S3 method:
fmean(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'matrix'
fmean(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'data.frame'
fmean(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'grouped_df'
fmean(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = FALSE, keep.group_vars = TRUE,
      keep.w = TRUE, stub = .op[["stub"]], nthreads = .op[["nthreads"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmean_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fmean_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fmean_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values.</p>
</td></tr>
<tr><td><code id="fmean_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fmean_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fmean_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fmean_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. See Details of <code><a href="#topic+fsum">fsum</a></code>. </p>
</td></tr>
<tr><td><code id="fmean_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fmean_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fmean_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain summed weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fmean_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fmean_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>



<p>The weighted mean is computed as <code>sum(x * w) / sum(w)</code>, using a single pass in C. If <code>na.rm = TRUE</code>, missing values will be removed from both <code>x</code> and <code>w</code> i.e. utilizing only <code>x[complete.cases(x,w)]</code> and <code>w[complete.cases(x,w)]</code>.
</p>


<p>For further computational details see <code><a href="#topic+fsum">fsum</a></code>, which works equivalently.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) mean of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighted) mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmedian">fmedian</a></code>, <code><a href="#topic+fmode">fmode</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
mpg &lt;- mtcars$mpg
fmean(mpg)                         # Simple mean
fmean(mpg, w = mtcars$hp)          # Weighted mean: Weighted by hp
fmean(mpg, TRA = "-")              # Simple transformation: demeaning (See also ?W)
fmean(mpg, mtcars$cyl)             # Grouped mean
fmean(mpg, mtcars[8:9])            # another grouped mean.
g &lt;- GRP(mtcars[c(2,8:9)])
fmean(mpg, g)                      # Pre-computing groups speeds up the computation
fmean(mpg, g, mtcars$hp)           # Grouped weighted mean
fmean(mpg, g, TRA = "-")           # Demeaning by group
fmean(mpg, g, mtcars$hp, "-")      # Group-demeaning using weighted group means

## data.frame method
fmean(mtcars)
fmean(mtcars, g)
fmean(fgroup_by(mtcars, cyl, vs, am))  # Another way of doing it..
head(fmean(mtcars, g, TRA = "-"))      # etc..

## matrix method
m &lt;- qM(mtcars)
fmean(m)
fmean(m, g)
head(fmean(m, g, TRA = "-")) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean()         # Ordinary
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean(hp)       # Weighted
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean(hp, "-")  # Weighted Transform
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt;
               fselect(mpg,hp) |&gt; fmean(hp, "-")  # Only mpg

</code></pre>

<hr>
<h2 id='fmin-fmax'>Fast (Grouped) Maxima and Minima for Matrix-Like Objects</h2><span id='topic+fmax'></span><span id='topic+fmax.default'></span><span id='topic+fmax.matrix'></span><span id='topic+fmax.data.frame'></span><span id='topic+fmax.grouped_df'></span><span id='topic+fmin'></span><span id='topic+fmin.default'></span><span id='topic+fmin.matrix'></span><span id='topic+fmin.data.frame'></span><span id='topic+fmin.grouped_df'></span>

<h3>Description</h3>

<p><code>fmax</code> and <code>fmin</code> are generic functions that compute the (column-wise) maximum and minimum value of all values in <code>x</code>, (optionally) grouped by <code>g</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped) maximum or minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmax(x, ...)
fmin(x, ...)

## Default S3 method:
fmax(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, ...)
## Default S3 method:
fmin(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, ...)

## S3 method for class 'matrix'
fmax(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ...)
## S3 method for class 'matrix'
fmin(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'data.frame'
fmax(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ...)
## S3 method for class 'data.frame'
fmin(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'grouped_df'
fmax(x, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, ...)
## S3 method for class 'grouped_df'
fmin(x, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmin-fmax_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fmin-fmax_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing-value removal as controlled by the <code>na.rm</code> argument is done at no extra cost since in C++ any logical comparison involving <code>NA</code> or <code>NaN</code> evaluates to <code>FALSE</code>. Large performance gains can nevertheless be achieved in the presence of missing values if <code>na.rm = FALSE</code>, since then the corresponding computation is terminated once a <code>NA</code> is encountered and <code>NA</code> is returned (unlike <code><a href="base.html#topic+max">max</a></code> and <code><a href="base.html#topic+min">min</a></code> which just run through without any checks).
</p>


<p>For further computational details see <code><a href="#topic+fsum">fsum</a></code>.
</p>


<h3>Value</h3>

<p><code>fmax</code> returns the maximum value of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped) maximum value. Analogous, <code>fmin</code> returns the minimum value ...
</p>


<h3>See Also</h3>

<p><a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
mpg &lt;- mtcars$mpg
fmax(mpg)                         # Maximum value
fmin(mpg)                         # Minimum value (all examples below use fmax but apply to fmin)
fmax(mpg, TRA = "%")              # Simple transformation: Take percentage of maximum value
fmax(mpg, mtcars$cyl)             # Grouped maximum value
fmax(mpg, mtcars[c(2,8:9)])       # More groups..
g &lt;- GRP(mtcars, ~ cyl + vs + am) # Precomputing groups gives more speed !
fmax(mpg, g)
fmax(mpg, g, TRA = "%")           # Groupwise percentage of maximum value
fmax(mpg, g, TRA = "replace")     # Groupwise replace by maximum value

## data.frame method
fmax(mtcars)
head(fmax(mtcars, TRA = "%"))
fmax(mtcars, g)
fmax(mtcars, g, use.g.names = FALSE) # No row-names generated

## matrix method
m &lt;- qM(mtcars)
fmax(m)
head(fmax(m, TRA = "%"))
fmax(m, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmax()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmax("%")
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg) |&gt; fmax()
</code></pre>

<hr>
<h2 id='fmode'>Fast (Grouped, Weighted) Statistical Mode for Matrix-Like Objects</h2><span id='topic+fmode'></span><span id='topic+fmode.default'></span><span id='topic+fmode.matrix'></span><span id='topic+fmode.data.frame'></span><span id='topic+fmode.grouped_df'></span>

<h3>Description</h3>

<p><code>fmode</code> is a generic function and returns the (column-wise) statistical mode i.e. the most frequent value of <code>x</code>, (optionally) grouped by <code>g</code> and/or weighted by <code>w</code>.
The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped, weighted) mode. Ties between multiple possible modes can be resolved by taking the minimum, maximum, (default) first or last occurring mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmode(x, ...)

## Default S3 method:
fmode(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, ties = "first", nthreads = .op[["nthreads"]], ...)

## S3 method for class 'matrix'
fmode(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ties = "first", nthreads = .op[["nthreads"]], ...)

## S3 method for class 'data.frame'
fmode(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ties = "first", nthreads = .op[["nthreads"]], ...)

## S3 method for class 'grouped_df'
fmode(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
      ties = "first", nthreads = .op[["nthreads"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmode_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fmode_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fmode_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values.</p>
</td></tr>
<tr><td><code id="fmode_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fmode_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code>, <code>NA</code> is treated as any other value.</p>
</td></tr>
<tr><td><code id="fmode_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fmode_+3A_ties">ties</code></td>
<td>
<p>an integer or character string specifying the method to resolve ties between multiple possible modes i.e. multiple values with the maximum frequency or sum of weights:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "first"   </td><td style="text-align: left;"></td><td style="text-align: left;"> take the first occurring mode. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "min" </td><td style="text-align: left;"></td><td style="text-align: left;"> take the smallest of the possible modes. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "max"   </td><td style="text-align: left;"></td><td style="text-align: left;"> take the largest of the possible modes. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "last"   </td><td style="text-align: left;"></td><td style="text-align: left;"> take the last occurring mode. </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td>
</tr>

</table>

<p><em>Note:</em> <code>"min"/"max"</code> don't work with character data. 
See also Details.
</p>
</td></tr>
<tr><td><code id="fmode_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. Parallelism is across groups for grouped computations and at the column-level otherwise. </p>
</td></tr>
<tr><td><code id="fmode_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fmode_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fmode_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain <code>sum</code> of weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fmode_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fmode_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmode</code> implements a pretty fast C-level hashing algorithm inspired by the <em>kit</em> package to find the statistical mode. 
</p>

<p>If <code>na.rm = FALSE</code>, <code>NA</code> is not removed but treated as any other value (i.e. its frequency is counted). If all values are <code>NA</code>, <code>NA</code> is always returned.
</p>
<p>The weighted mode is computed by summing up the weights for all distinct values and choosing the value with the largest sum. If <code>na.rm = TRUE</code>, missing values will be removed from both <code>x</code> and <code>w</code> i.e. utilizing only <code>x[complete.cases(x,w)]</code> and <code>w[complete.cases(x,w)]</code>.
</p>
<p>It is possible that multiple values have the same mode (the maximum frequency or sum of weights). Typical cases are simply when all values are either all the same or all distinct. In such cases, the default option <code>ties = "first"</code> returns the first occurring value in the data reaching the maximum frequency count or sum of weights. For example in a sample <code>x = c(1, 3, 2, 2, 4, 4, 1, 7)</code>, the first mode is 2 as <code>fmode</code> goes through the data from left to right. <code>ties = "last"</code> on the other hand gives 1. It is also possible to take the minimum or maximum mode, i.e. <code>fmode(x, ties = "min")</code> returns 1, and <code>fmode(x, ties = "max")</code> returns 4. It should be noted that options <code>ties = "min"</code> and <code>ties = "max"</code> give unintuitive results for character data (no strict alphabetic sorting, similar to using <code>&lt;</code> and <code>&gt;</code> to compare character values in R). These options are also best avoided if missing values are counted (<code>na.rm = FALSE</code>) since no proper logical comparison with missing values is possible: With numeric data it depends, since in C++ any comparison with <code>NA_real_</code> evaluates to <code>FALSE</code>, <code>NA_real_</code> is chosen as the min or max mode only if it is also the first mode, and never otherwise. For integer data, <code>NA_integer_</code> is stored as the smallest integer in C++, so it will always be chosen as the min mode and never as the max mode. For character data, <code>NA_character_</code> is stored as the string <code>"NA"</code> in C++ and thus the behavior depends on the other character content. 
</p>

<p><code>fmode</code> preserves all the attributes of the objects it is applied to (apart from names or row-names which are adjusted as necessary in grouped operations). If a data frame is passed to <code>fmode</code> and <code>drop = TRUE</code> (the default), <code><a href="base.html#topic+unlist">unlist</a></code> will be called on the result, which might not be sensible depending on the data at hand.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) statistical mode of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighed) mode. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmedian">fmedian</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 3, 2, 2, 4, 4, 1, 7, NA, NA, NA)
fmode(x)                            # Default is ties = "first"
fmode(x, ties = "last")
fmode(x, ties = "min")
fmode(x, ties = "max")
fmode(x, na.rm = FALSE)             # Here NA is the mode, regardless of ties option
fmode(x[-length(x)], na.rm = FALSE) # Not anymore..

## World Development Data
attach(wlddev)
## default vector method
fmode(PCGDP)                      # Numeric mode
head(fmode(PCGDP, iso3c))         # Grouped numeric mode
head(fmode(PCGDP, iso3c, LIFEEX)) # Grouped and weighted numeric mode
fmode(region)                     # Factor mode
fmode(date)                       # Date mode (defaults to first value since panel is balanced)
fmode(country)                    # Character mode (also defaults to first value)
fmode(OECD)                       # Logical mode
                                  # ..all the above can also be performed grouped and weighted
## matrix method
m &lt;- qM(airquality)
fmode(m)
fmode(m, na.rm = FALSE)         # NA frequency is also counted
fmode(m, airquality$Month)      # Groupwise
fmode(m, w = airquality$Day)    # Weighted: Later days in the month are given more weight
fmode(m&gt;50, airquality$Month)   # Groupwise logical mode
                                # etc..
## data.frame method
fmode(wlddev)                      # Calling unlist -&gt; coerce to character vector
fmode(wlddev, drop = FALSE)        # Gives one row
head(fmode(wlddev, iso3c))         # Grouped mode
head(fmode(wlddev, iso3c, LIFEEX)) # Grouped and weighted mode

detach(wlddev)
</code></pre>

<hr>
<h2 id='fndistinct'>Fast (Grouped) Distinct Value Count for Matrix-Like Objects</h2><span id='topic+fndistinct'></span><span id='topic+fndistinct.default'></span><span id='topic+fndistinct.matrix'></span><span id='topic+fndistinct.data.frame'></span><span id='topic+fndistinct.grouped_df'></span>

<h3>Description</h3>

<p><code>fndistinct</code> is a generic function that (column-wise) computes the number of distinct values in <code>x</code>, (optionally) grouped by <code>g</code>. It is significantly faster than <code>length(unique(x))</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped) distinct value count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fndistinct(x, ...)

## Default S3 method:
fndistinct(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
           use.g.names = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'matrix'
fndistinct(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
           use.g.names = TRUE, drop = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'data.frame'
fndistinct(x, g = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
           use.g.names = TRUE, drop = TRUE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'grouped_df'
fndistinct(x, TRA = NULL, na.rm = .op[["na.rm"]],
           use.g.names = FALSE, keep.group_vars = TRUE, nthreads = .op[["nthreads"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fndistinct_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. <code>TRUE</code>: Skip missing values in <code>x</code> (faster computation). <code>FALSE</code>: Also consider 'NA' as one distinct value.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. Parallelism is across groups for grouped computations and at the column-level otherwise. </p>
</td></tr>
<tr><td><code id="fndistinct_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fndistinct_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fndistinct</code> implements a pretty fast C-level hashing algorithm inspired by the <em>kit</em> package to find the number of distinct values.

</p>
<p>If <code>na.rm = TRUE</code> (the default), missing values will be skipped yielding substantial performance gains in data with many missing values. If <code>na.rm = FALSE</code>, missing values will simply be treated as any other value and read into the hash-map. Thus with the former, a numeric vector <code>c(1.25,NaN,3.56,NA)</code> will have a distinct value count of 2, whereas the latter will return a distinct value count of 4.
</p>

<p><code>fndistinct</code> preserves all attributes of non-classed vectors / columns, and only the 'label' attribute (if available) of classed vectors / columns (i.e. dates or factors). When applied to data frames and matrices, the row-names are adjusted as necessary.
</p>


<h3>Value</h3>

<p>Integer. The number of distinct values in <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its distinct value count, grouped by <code>g</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fnunique">fnunique</a></code>, <code><a href="#topic+fnobs">fnobs</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
fndistinct(airquality$Solar.R)                   # Simple distinct value count
fndistinct(airquality$Solar.R, airquality$Month) # Grouped distinct value count

## data.frame method
fndistinct(airquality)
fndistinct(airquality, airquality$Month)
fndistinct(wlddev)                               # Works with data of all types!
head(fndistinct(wlddev, wlddev$iso3c))

## matrix method
aqm &lt;- qM(airquality)
fndistinct(aqm)                                  # Also works for character or logical matrices
fndistinct(aqm, airquality$Month)

## method for grouped data frames - created with dplyr::group_by or fgroup_by
airquality |&gt; fgroup_by(Month) |&gt; fndistinct()
wlddev |&gt; fgroup_by(country) |&gt;
             fselect(PCGDP,LIFEEX,GINI,ODA) |&gt; fndistinct()
</code></pre>

<hr>
<h2 id='fnobs'>Fast (Grouped) Observation Count for Matrix-Like Objects</h2><span id='topic+fnobs'></span><span id='topic+fnobs.default'></span><span id='topic+fnobs.matrix'></span><span id='topic+fnobs.data.frame'></span><span id='topic+fnobs.grouped_df'></span>

<h3>Description</h3>

<p><code>fnobs</code> is a generic function that (column-wise) computes the number of non-missing values in <code>x</code>, (optionally) grouped by <code>g</code>. It is much faster than <code>sum(!is.na(x))</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped) observation count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnobs(x, ...)

## Default S3 method:
fnobs(x, g = NULL, TRA = NULL, use.g.names = TRUE, ...)

## S3 method for class 'matrix'
fnobs(x, g = NULL, TRA = NULL, use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'data.frame'
fnobs(x, g = NULL, TRA = NULL, use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'grouped_df'
fnobs(x, TRA = NULL, use.g.names = FALSE, keep.group_vars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnobs_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fnobs_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fnobs_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fnobs_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fnobs_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fnobs_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fnobs_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fnobs</code> preserves all attributes of non-classed vectors / columns, and only the 'label' attribute (if available) of classed vectors / columns (i.e. dates or factors). When applied to data frames and matrices, the row-names are adjusted as necessary.
</p>


<h3>Value</h3>

<p>Integer. The number of non-missing observations in <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its number of non-missing observations, grouped by <code>g</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fndistinct">fndistinct</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
fnobs(airquality$Solar.R)                   # Simple Nobs
fnobs(airquality$Solar.R, airquality$Month) # Grouped Nobs

## data.frame method
fnobs(airquality)
fnobs(airquality, airquality$Month)
fnobs(wlddev)                               # Works with data of all types!
head(fnobs(wlddev, wlddev$iso3c))

## matrix method
aqm &lt;- qM(airquality)
fnobs(aqm)                                  # Also works for character or logical matrices
fnobs(aqm, airquality$Month)

## method for grouped data frames - created with dplyr::group_by or fgroup_by
airquality |&gt; fgroup_by(Month) |&gt; fnobs()
wlddev |&gt; fgroup_by(country) |&gt;
           fselect(PCGDP,LIFEEX,GINI,ODA) |&gt; fnobs()
</code></pre>

<hr>
<h2 id='fnth-fmedian'>
Fast (Grouped, Weighted) N'th Element/Quantile for Matrix-Like Objects
</h2><span id='topic+fnth'></span><span id='topic+fnth.default'></span><span id='topic+fnth.matrix'></span><span id='topic+fnth.data.frame'></span><span id='topic+fnth.grouped_df'></span><span id='topic+fmedian'></span><span id='topic+fmedian.default'></span><span id='topic+fmedian.matrix'></span><span id='topic+fmedian.data.frame'></span><span id='topic+fmedian.grouped_df'></span>

<h3>Description</h3>

<p><code>fnth</code> (column-wise) returns the n'th smallest element from a set of unsorted elements <code>x</code> corresponding to an integer index (<code>n</code>), or to a probability between 0 and 1. If <code>n</code> is passed as a probability, ties can be resolved using the lower, upper, or average of the possible elements, or, since v1.9.0, continuous quantile estimation. The new default is quantile type 7 (as in <code><a href="stats.html#topic+quantile">quantile</a></code>). For <code>n &gt; 1</code>, the lower element is always returned (as in <code>sort(x, partial = n)[n]</code>). See Details.
</p>
<p><code>fmedian</code> is a simple wrapper around <code>fnth</code>, which fixes <code>n = 0.5</code> and (default) <code>ties = "mean"</code> i.e. it averages eligible elements. See Details. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnth(x, n = 0.5, ...)
fmedian(x, ...)

## Default S3 method:
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, ties = "q7", nthreads = .op[["nthreads"]],
     o = NULL, check.o = is.null(attr(o, "sorted")), ...)
## Default S3 method:
fmedian(x, ..., ties = "mean")

## S3 method for class 'matrix'
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'matrix'
fmedian(x, ..., ties = "mean")

## S3 method for class 'data.frame'
fnth(x, n = 0.5, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'data.frame'
fmedian(x, ..., ties = "mean")

## S3 method for class 'grouped_df'
fnth(x, n = 0.5, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
     ties = "q7", nthreads = .op[["nthreads"]], ...)
## S3 method for class 'grouped_df'
fmedian(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
        use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
        ties = "mean", nthreads = .op[["nthreads"]], ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnth-fmedian_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_n">n</code></td>
<td>
<p>the element to return using a single integer index such that <code>1 &lt; n &lt; NROW(x)</code>, or a probability <code>0 &lt; n &lt; 1</code>. See Details. </p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values only where <code>x</code> is also missing.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_ties">ties</code></td>
<td>
<p>an integer or character string specifying the method to resolve ties between adjacent qualifying elements:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "mean"   </td><td style="text-align: left;"></td><td style="text-align: left;"> take the arithmetic mean of all qualifying elements. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "min" </td><td style="text-align: left;"></td><td style="text-align: left;"> take the smallest of the elements. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "max"   </td><td style="text-align: left;"></td><td style="text-align: left;"> take the largest of the elements. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5-9 </td><td style="text-align: left;"></td><td style="text-align: left;"> "qn" </td><td style="text-align: left;"></td><td style="text-align: left;"> continuous quantile types 5-9, see <code><a href="#topic+fquantile">fquantile</a></code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td>
</tr>

</table>

</td></tr>
<tr><td><code id="fnth-fmedian_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. Parallelism is across groups for grouped computations on vectors and data frames, and at the column-level otherwise. See Details. </p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_o">o</code></td>
<td>
<p>integer. A valid ordering of <code>x</code>, e.g. <code>radixorder(x)</code>. With groups, the grouping needs to be accounted e.g. <code>radixorder(g, x)</code>.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_check.o">check.o</code></td>
<td>
<p>logical. <code>TRUE</code> checks that each element of <code>o</code> is within <code>[1, length(x)]</code>. The default uses the fact that orderings from <code><a href="#topic+radixorder">radixorder</a></code> have a <code>"sorted"</code> attribute which let's <code>fnth</code> infer that the ordering is valid. The length and data type of <code>o</code> is always checked, regardless of <code>check.o</code>.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain <code>sum</code> of weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fnth-fmedian_+3A_...">...</code></td>
<td>
<p>for <code>fmedian</code>: further arguments passed to <code>fnth</code> (apart from <code>n</code>). If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For v1.9.0 <code>fnth</code> was completely rewritten in C and offers significantly enhanced speed and functionality. It uses a combination of quickselect, quicksort, and radixsort algorithms, combined with several (weighted) quantile estimation methods and, where possible, OpenMP multithreading. This synthesis can be summarised as follows:
</p>

<ul>
<li><p> without weights, quickselect is used to determine a (lower) order statistic. If <code>ties %!in% c("min", "max")</code> a second order statistic is found by taking the max of the upper part of the partitioned array, and the two statistics are averaged using a simple mean (<code>ties = "mean"</code>), or weighted average according to a <code><a href="stats.html#topic+quantile">quantile</a></code> method (<code>ties = "q5"-"q9"</code>). For <code>n = 0.5</code>, all supported quantile methods give the sample median. With matrices, multithreading is always across columns, for vectors and data frames it is across groups unless <code>is.null(g)</code> for data frames.
</p>
</li>
<li><p> with weights and no groups (<code>is.null(g)</code>), <code><a href="#topic+radixorder">radixorder</a></code> is called internally (on each column of <code>x</code>). The ordering is used to sum the weights in order of <code>x</code> and determine weighted order statistics or quantiles. See details below. Multithreading is disabled as <code><a href="#topic+radixorder">radixorder</a></code> cannot be called concurrently on the same memory stack.
</p>
</li>
<li><p> with weights and groups (<code>!is.null(g)</code>), R's quicksort algorithm is used to sort the data in each group and return an index which can be used to sum the weights in order and proceed as before. This is multithreaded across columns for matrices, and across groups otherwise.
</p>
</li>
<li><p> in <code>fnth.default</code>, an ordering of <code>x</code> can be supplied to '<code>o</code>' e.g. <code>fnth(x, 0.75, o = radixorder(x))</code>. This dramatically speeds up the estimation both with and without weights, and is useful if <code>fnth</code> is to be invoked repeatedly on the same data. With groups, <code>o</code> needs to also account for the grouping e.g. <code>fnth(x, 0.75, g, o = radixorder(g, x))</code>. Multithreading is possible across groups. See Examples.
</p>
</li></ul>



<p>If <code>n &gt; 1</code>, the result is equivalent to (column-wise) <code>sort(x, partial = n)[n]</code>. Internally, <code>n</code> is converted to a probability using <code>p = (n-1)/(NROW(x)-1)</code>, and that probability is applied to the set of non-missing elements to find the <code>as.integer(p*(fnobs(x)-1))+1L</code>'th element (which corresponds to option <code>ties = "min"</code>). 
When using grouped computations with <code>n &gt; 1</code>, <code>n</code> is transformed to a probability <code>p = (n-1)/(NROW(x)/ng-1)</code> (where <code>ng</code> contains the number of unique groups in <code>g</code>).
</p>
<p>If weights are used and <code>ties = "q5"-"q9"</code>, weighted continuous quantile estimation is done as described in <code><a href="#topic+fquantile">fquantile</a></code>.
</p>
<p>For <code>ties %in% c("mean", "min", "max")</code>, a target partial sum of weights <code>p*sum(w)</code> is calculated, and the weighted n'th element is the element k such that all elements smaller than k have a sum of weights <code>&lt;= p*sum(w)</code>, and all elements larger than k have a sum of weights <code>&lt;= (1 - p)*sum(w)</code>. If the partial-sum of weights (<code>p*sum(w)</code>) is reached exactly for some element k, then (summing from the lower end) both k and k+1 would qualify as the weighted n'th element. If the weight of element k+1 is zero, k, k+1 and k+2 would qualify... . If <code>n &gt; 1</code>, k is chosen (consistent with the unweighted behavior). 
If <code>0 &lt; n &lt; 1</code>, the <code>ties</code> option regulates how to resolve such conflicts, yielding lower (<code>ties = "min"</code>: k), upper (<code>ties = "max"</code>: k+2) or average weighted (<code>ties = "mean"</code>: mean(k, k+1, k+2)) n'th elements.
</p>
<p>Thus, in the presence of zero weights, the weighted median (default <code>ties = "mean"</code>) can be an arithmetic average of &gt;2 qualifying elements. Users may prefer a quantile based weighted median by setting <code>ties = "q5"-"q9"</code>, which is a continuous function of <code>p</code> and ignores elements with zero weights.
</p>
<p>For data frames, column-attributes and overall attributes are preserved if <code>g</code> is used or <code>drop = FALSE</code>.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) n'th element/quantile of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighted) n'th element/quantile.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fquantile">fquantile</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <code><a href="#topic+fmode">fmode</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
mpg &lt;- mtcars$mpg
fnth(mpg)                         # Simple nth element: Median (same as fmedian(mpg))
fnth(mpg, 5)                      # 5th smallest element
sort(mpg, partial = 5)[5]         # Same using base R, fnth is 2x faster.
fnth(mpg, 0.75)                   # Third quartile
fnth(mpg, 0.75, w = mtcars$hp)    # Weighted third quartile: Weighted by hp
fnth(mpg, 0.75, TRA = "-")        # Simple transformation: Subtract third quartile
fnth(mpg, 0.75, mtcars$cyl)             # Grouped third quartile
fnth(mpg, 0.75, mtcars[c(2,8:9)])       # More groups..
g &lt;- GRP(mtcars, ~ cyl + vs + am)       # Precomputing groups gives more speed !
fnth(mpg, 0.75, g)
fnth(mpg, 0.75, g, mtcars$hp)           # Grouped weighted third quartile
fnth(mpg, 0.75, g, TRA = "-")           # Groupwise subtract third quartile
fnth(mpg, 0.75, g, mtcars$hp, "-")      # Groupwise subtract weighted third quartile

## data.frame method
fnth(mtcars, 0.75)
head(fnth(mtcars, 0.75, TRA = "-"))
fnth(mtcars, 0.75, g)
fnth(fgroup_by(mtcars, cyl, vs, am), 0.75)   # Another way of doing it..
fnth(mtcars, 0.75, g, use.g.names = FALSE)   # No row-names generated

## matrix method
m &lt;- qM(mtcars)
fnth(m, 0.75)
head(fnth(m, 0.75, TRA = "-"))
fnth(m, 0.75, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75)
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75, hp)         # Weighted
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fnth(0.75, TRA = "/")  # Divide by third quartile
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg, hp) |&gt;    # Faster selecting
      fnth(0.75, hp, "/")  # Divide mpg by its third weighted group-quartile, using hp as weights

# Efficient grouped estimation of multiple quantiles
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt;
    fmutate(o = radixorder(GRPid(), mpg)) |&gt;
    fsummarise(mpg_Q1 = fnth(mpg, 0.25, o = o),
               mpg_median = fmedian(mpg, o = o),
               mpg_Q3 = fnth(mpg, 0.75, o = o))

## fmedian()
fmedian(mpg)                         # Simple median value
fmedian(mpg, w = mtcars$hp)          # Weighted median: Weighted by hp
fmedian(mpg, TRA = "-")              # Simple transformation: Subtract median value
fmedian(mpg, mtcars$cyl)             # Grouped median value
fmedian(mpg, mtcars[c(2,8:9)])       # More groups..
fmedian(mpg, g)
fmedian(mpg, g, mtcars$hp)           # Grouped weighted median
fmedian(mpg, g, TRA = "-")           # Groupwise subtract median value
fmedian(mpg, g, mtcars$hp, "-")      # Groupwise subtract weighted median value

## data.frame method
fmedian(mtcars)
head(fmedian(mtcars, TRA = "-"))
fmedian(mtcars, g)
fmedian(fgroup_by(mtcars, cyl, vs, am))   # Another way of doing it..
fmedian(mtcars, g, use.g.names = FALSE)   # No row-names generated

## matrix method
fmedian(m)
head(fmedian(m, TRA = "-"))
fmedian(m, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian(hp)           # Weighted
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmedian(TRA = "-")    # De-median
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg, hp) |&gt;   # Faster selecting
      fmedian(hp, "-")  # Weighted de-median mpg, using hp as weights
</code></pre>

<hr>
<h2 id='fprod'>Fast (Grouped, Weighted) Product for Matrix-Like Objects</h2><span id='topic+fprod'></span><span id='topic+fprod.default'></span><span id='topic+fprod.matrix'></span><span id='topic+fprod.data.frame'></span><span id='topic+fprod.grouped_df'></span>

<h3>Description</h3>

<p><code>fprod</code> is a generic function that computes the (column-wise) product of all values in <code>x</code>, (optionally) grouped by <code>g</code> and/or weighted by <code>w</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped, weighted) product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fprod(x, ...)

## Default S3 method:
fprod(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, ...)

## S3 method for class 'matrix'
fprod(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'data.frame'
fprod(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'grouped_df'
fprod(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
      use.g.names = FALSE, keep.group_vars = TRUE,
      keep.w = TRUE, stub = .op[["stub"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fprod_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fprod_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fprod_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values.</p>
</td></tr>
<tr><td><code id="fprod_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fprod_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fprod_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fprod_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fprod_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fprod_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain product of weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fprod_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the weights column is prefixed by <code>"prod."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fprod_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-grouped product computations internally utilize long-doubles in C, for additional numeric precision.
</p>


<p>The weighted product is computed as <code>prod(x * w)</code>, using a single pass in C. If <code>na.rm = TRUE</code>, missing values will be removed from both <code>x</code> and <code>w</code> i.e. utilizing only <code>x[complete.cases(x,w)]</code> and <code>w[complete.cases(x,w)]</code>.
</p>

<p>For further computational details see <code><a href="#topic+fsum">fsum</a></code>, which works equivalently.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) product of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighted) product.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsum">fsum</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
mpg &lt;- mtcars$mpg
fprod(mpg)                         # Simple product
fprod(mpg, w = mtcars$hp)          # Weighted product
fprod(mpg, TRA = "/")              # Simple transformation: Divide by product
fprod(mpg, mtcars$cyl)             # Grouped product
fprod(mpg, mtcars$cyl, mtcars$hp)  # Weighted grouped product
fprod(mpg, mtcars[c(2,8:9)])       # More groups..
g &lt;- GRP(mtcars, ~ cyl + vs + am)  # Precomputing groups gives more speed !
fprod(mpg, g)
fprod(mpg, g, TRA = "/")           # Groupwise divide by product

## data.frame method
fprod(mtcars)
head(fprod(mtcars, TRA = "/"))
fprod(mtcars, g)
fprod(mtcars, g, use.g.names = FALSE) # No row-names generated

## matrix method
m &lt;- qM(mtcars)
fprod(m)
head(fprod(m, TRA = "/"))
fprod(m, g) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fprod()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fprod(TRA = "/")
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg) |&gt; fprod()
</code></pre>

<hr>
<h2 id='fquantile'>
Fast (Weighted) Sample Quantiles and Range</h2><span id='topic+fquantile'></span><span id='topic+.quantile'></span><span id='topic+frange'></span><span id='topic+.range'></span>

<h3>Description</h3>

<p>A faster alternative to <code><a href="stats.html#topic+quantile">quantile</a></code> (written fully in C), that supports sampling weights, and can also quickly compute quantiles from an ordering vector (e.g. <code>order(x)</code>). <code>frange</code> provides a fast alternative to <code><a href="base.html#topic+range">range</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fquantile(x, probs = c(0, 0.25, 0.5, 0.75, 1), w = NULL,
          o = if(length(x) &gt; 1e5L &amp;&amp; length(probs) &gt; log(length(x)))
              radixorder(x) else NULL,
          na.rm = .op[["na.rm"]], type = 7L, names = TRUE,
          check.o = is.null(attr(o, "sorted")))

# Programmers version: no names, intelligent defaults, or checks
.quantile(x, probs = c(0, 0.25, 0.5, 0.75, 1), w = NULL, o = NULL,
          na.rm = TRUE, type = 7L, names = FALSE, check.o = FALSE)

# Fast range (min and max)
frange(x, na.rm = .op[["na.rm"]], finite = FALSE)
.range(x, na.rm = TRUE, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fquantile_+3A_x">x</code></td>
<td>
<p>a numeric or integer vector.</p>
</td></tr>
<tr><td><code id="fquantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1].</p>
</td></tr>
<tr><td><code id="fquantile_+3A_w">w</code></td>
<td>
<p>a numeric vector of sampling weights. Missing weights are only supported if <code>x</code> is also missing.</p>
</td></tr>
<tr><td><code id="fquantile_+3A_o">o</code></td>
<td>
<p>integer. An vector giving the ordering of the elements in <code>x</code>, such that <code>identical(x[o], sort(x))</code>. If available this considerably speeds up the estimation.</p>
</td></tr>
<tr><td><code id="fquantile_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove missing values, default <code>TRUE</code>. </p>
</td></tr>
<tr><td><code id="fquantile_+3A_finite">finite</code></td>
<td>
<p>logical. Omit all non-finite values.</p>
</td></tr>
<tr><td><code id="fquantile_+3A_type">type</code></td>
<td>
<p>integer. Quantile types 5-9. See <code><a href="stats.html#topic+quantile">quantile</a></code>. Further details are provided in Hyndman and Fan (1996) who recommended type 8. The default method is type 7.</p>
</td></tr>
<tr><td><code id="fquantile_+3A_names">names</code></td>
<td>
<p>logical. Generates names of the form <code>paste0(round(probs * 100, 1), "%")</code> (in C). Set to <code>FALSE</code> for speedup. </p>
</td></tr>
<tr><td><code id="fquantile_+3A_check.o">check.o</code></td>
<td>
<p>logical. If <code>o</code> is supplied, <code>TRUE</code> runs through <code>o</code> once and checks that it is valid, i.e. that each element is in <code>[1, length(x)]</code>. Set to <code>FALSE</code> for significant speedup if <code>o</code> is known to be valid. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fquantile</code> is implemented using a quickselect algorithm in C, inspired by <em>data.table</em>'s <code>gmedian</code>. The algorithm is applied incrementally to different sections of the array to find individual quantiles. If many quantile probabilities are requested, sorting the whole array with the fast <code><a href="#topic+radixorder">radixorder</a></code> algorithm is more efficient. The default threshold for this (<code>length(x) &gt; 1e5L &amp;&amp; length(probs) &gt; log(length(x))</code>) is conservative, given that quickselect is generally more efficient on longitudinal data with similar values repeated by groups. With random data, my investigations yield that a threshold of <code>length(probs) &gt; log10(length(x))</code> would be more appropriate.
</p>
<p>Weighted quantile estimation, in a nutshell, is done by internally calling <code>radixorder(x)</code> (unless <code>o</code> is supplied), and summing the weights in order until the lowest required order statistic <code>j</code> is found, which corresponds to exceeding a target sum of weights that is a function of the probability <code>p</code>, the quantile method (see <code><a href="stats.html#topic+quantile">quantile</a></code>), the total sum of weights, and the smallest (non-zero) weight. For quantile type 7 the target sum is <code>sumwp = (sum(w) - min(w)) * p</code> (resembling <code>(n - 1) * p</code> in the unweighted case). Then, a continuous index <code>h</code> in [0, 1] is determined as one minus the difference between the sum of weights associated with <code>j</code> and the target sum, divided by the weight of element <code>j</code>, that is <code>h = 1 - (sumwj - sumwp) / w[j]</code>. A weighted quantile can then be computed as a weighted average of 2 order statistics, exactly as in the unweighted case: <code>WQ[i](p) = (1 - h) x[j] + h x[j+1]</code>. If the order statistic <code>j+1</code> has a zero weight, <code>j+2</code> is taken (or <code>j+3</code> if <code>j+2</code> also has zero weight etc..). The Examples section provides a demonstration in R that is roughly equivalent to the algorithm just outlined.
</p>
<p><code>frange</code> is considerably more efficient than <code><a href="base.html#topic+range">range</a></code>, which calls both <code><a href="base.html#topic+min">min</a></code> and <code><a href="base.html#topic+max">max</a></code>, and thus requires 2 full passes instead of 1 required by <code>frange</code>. If only probabilities <code>0</code> and <code>1</code> are requested, <code>fquantile</code> internally calls <code>frange</code>.
</p>


<h3>Value</h3>

<p>A vector of quantiles. If <code>names = TRUE</code>, <code>fquantile</code> generates names as <code>paste0(round(probs * 100, 1), "%")</code> (in C).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fnth">fnth</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frange(mtcars$mpg)

## Checking computational equivalence to stats::quantile()
w = alloc(abs(rnorm(1)), 32)
o = radixorder(mtcars$mpg)
for (i in 5:9) print(all_obj_equal(fquantile(mtcars$mpg, type = i),
                                   fquantile(mtcars$mpg, type = i, w = w),
                                   fquantile(mtcars$mpg, type = i, o = o),
                                   fquantile(mtcars$mpg, type = i, w = w, o = o),
                                    quantile(mtcars$mpg, type = i)))

## Demonstaration: weighted quantiles type 7 in R
wquantile7R &lt;- function(x, w, probs = c(0.25, 0.5, 0.75), na.rm = TRUE, names = TRUE) {
  if(na.rm &amp;&amp; anyNA(x)) {             # Removing missing values (only in x)
    cc = whichNA(x, invert = TRUE)    # The C code first calls radixorder(x), which places
    x = x[cc]; w = w[cc]              # missing values last, so removing = early termination
  }
  if(anyv(w, 0)) {                    # Removing zero weights
    nzw = whichv(w, 0, invert = TRUE) # In C, skipping zero weight order statistics is built
    x = x[nzw]; w = w[nzw]            # into the quantile algorithm, as outlined above
  }
  o = radixorder(x)                   # Ordering
  wo = w[o]
  w_cs = cumsum(wo)                   # Cumulative sum
  sumwp = sum(w)                      # Computing sum(w) - min(w)
  sumwp = sumwp - wo[1L]
  sumwp = sumwp * probs               # Target sums of weights for quantile type 7
  res = sapply(sumwp, function(tsump) {
    j = which.max(w_cs &gt; tsump)           # Lower order statistic
    hl = (w_cs[j] - tsump) / wo[j]        # Index weight of x[j]  (h = 1 - hl)
    hl * x[o[j]] + (1 - hl) * x[o[j+1L]]  # Weighted quantile
  })
  if(names) names(res) = paste0(as.integer(probs * 100), "%")
  res
} # Note: doesn't work for min and max. Overall the C code is significantly more rigorous.

wquantile7R(mtcars$mpg, mtcars$wt)

all.equal(wquantile7R(mtcars$mpg, mtcars$wt),
          fquantile(mtcars$mpg, c(0.25, 0.5, 0.75), mtcars$wt))

## Efficient grouped quantile estimation: use .quantile for less call overhead
BY(mtcars$mpg, mtcars$cyl, .quantile, names = TRUE, expand.wide = TRUE)
BY(mtcars, mtcars$cyl, .quantile, names = TRUE)
library(magrittr)
mtcars |&gt; fgroup_by(cyl) |&gt; BY(.quantile)

## With weights
BY(mtcars$mpg, mtcars$cyl, .quantile, w = mtcars$wt, names = TRUE, expand.wide = TRUE)
BY(mtcars, mtcars$cyl, .quantile, w = mtcars$wt, names = TRUE)
mtcars |&gt; fgroup_by(cyl) |&gt; fselect(-wt) |&gt; BY(.quantile, w = mtcars$wt)
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(across(-wt, .quantile, w = wt))

</code></pre>

<hr>
<h2 id='frename'>
Fast Renaming and Relabelling Objects
</h2><span id='topic+rnm'></span><span id='topic+frename'></span><span id='topic+setrename'></span><span id='topic+relabel'></span><span id='topic+setrelabel'></span>

<h3>Description</h3>

<p><code>frename</code> returns a renamed shallow-copy, <code>setrename</code> renames objects by reference. These functions also work with objects other than data frames that have a 'names' attribute. <code>relabel</code> and <code>setrelabel</code> do that same for labels attached to data frame columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frename(.x, ..., cols = NULL, .nse = TRUE)
rnm(.x, ..., cols = NULL, .nse = TRUE)     # Shorthand for frename()

setrename(.x, ..., cols = NULL, .nse = TRUE)

relabel(.x, ..., cols = NULL, attrn = "label")

setrelabel(.x, ..., cols = NULL, attrn = "label")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frename_+3A_.x">.x</code></td>
<td>
<p>for <code>(f/set)rename</code>: an R object with a <code>"names"</code> attribute. For <code>(set)relabel</code>: a named list.
</p>
</td></tr>
<tr><td><code id="frename_+3A_...">...</code></td>
<td>
<p>either tagged vector expressions of the form <code>name = newname</code> / <code>name = newlabel</code> (<code>frename</code> also supports <code>newname = name</code>), a (named) vector of names/labels, or a single function (+ optional arguments to the function) applied to all names/labels (of columns/elements selected in <code>cols</code>).
</p>
</td></tr>
<tr><td><code id="frename_+3A_cols">cols</code></td>
<td>
<p>If <code>...</code> is a function, select a subset of columns/elements to rename/relabel using names, indices, a logical vector or a function applied to the columns if <code>.x</code> is a list (e.g. <code>is.numeric</code>).</p>
</td></tr>
<tr><td><code id="frename_+3A_.nse">.nse</code></td>
<td>
<p>logical. <code>TRUE</code> allows non-standard evaluation of tagged vector expressions, allowing you to supply new names without quotes. Set to <code>FALSE</code> for programming or passing vectors of names.</p>
</td></tr>
<tr><td><code id="frename_+3A_attrn">attrn</code></td>
<td>
<p>character. Name of attribute to store labels or retrieve labels from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.x</code> renamed / relabelled. <code>setrename</code> and <code>setrelabel</code> return <code>.x</code> invisibly.
</p>


<h3>Note</h3>

<p>Note that both <code>relabel</code> and <code>setrelabel</code> modify <code>.x</code> by reference. This is because labels are attached to columns themselves, making it impossible to avoid permanent modification by taking a shallow copy of the encompassing list / data.frame. On the other hand <code>frename</code> makes a shallow copy whereas <code>setrename</code> also modifies by reference.
</p>


<h3>See Also</h3>

<p><a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using tagged expressions
head(frename(iris, Sepal.Length = SL, Sepal.Width = SW,
                   Petal.Length = PL, Petal.Width = PW))
head(frename(iris, Sepal.Length = "S L", Sepal.Width = "S W",
                   Petal.Length = "P L", Petal.Width = "P W"))

## Since v2.0.0 this is also supported
head(frename(iris, SL = Sepal.Length, SW = Sepal.Width,
                   PL = Petal.Length, PW = Petal.Width))

## Using a function
head(frename(iris, tolower))
head(frename(iris, tolower, cols = 1:2))
head(frename(iris, tolower, cols = is.numeric))
head(frename(iris, paste, "new", sep = "_", cols = 1:2))

## Using vectors of names and programming
newname = "sepal_length"
head(frename(iris, Sepal.Length = newname, .nse = FALSE))
newnames = c("sepal_length", "sepal_width")
head(frename(iris, newnames, cols = 1:2))
newnames = c(Sepal.Length = "sepal_length", Sepal.Width = "sepal_width")
head(frename(iris, newnames, .nse = FALSE))
# Since v2.0.0, this works as well
newnames = c(sepal_length = "Sepal.Length", sepal_width = "Sepal.Width")
head(frename(iris, newnames, .nse = FALSE))

## Renaming by reference
# setrename(iris, tolower)
# head(iris)
# rm(iris)
# etc...

## Relabelling (by reference)
# namlab(relabel(wlddev, PCGDP = "GDP per Capita", LIFEEX = "Life Expectancy"))
# namlab(relabel(wlddev, toupper))


</code></pre>

<hr>
<h2 id='fscale'>
Fast (Grouped, Weighted) Scaling and Centering of Matrix-like Objects
</h2><span id='topic+fscale'></span><span id='topic+fscale.default'></span><span id='topic+fscale.matrix'></span><span id='topic+fscale.data.frame'></span><span id='topic+fscale.pseries'></span><span id='topic+fscale.pdata.frame'></span><span id='topic+fscale.grouped_df'></span><span id='topic+STD'></span><span id='topic+STD.default'></span><span id='topic+STD.matrix'></span><span id='topic+STD.data.frame'></span><span id='topic+STD.pseries'></span><span id='topic+STD.pdata.frame'></span><span id='topic+STD.grouped_df'></span>

<h3>Description</h3>

<p><code>fscale</code> is a generic function to efficiently standardize (scale and center) data. <code>STD</code> is a wrapper around <code>fscale</code> representing the 'standardization operator', with more options than <code>fscale</code> when applied to matrices and data frames.  Standardization can be simple or groupwise, ordinary or weighted. Arbitrary target means and standard deviations can be set, with special options for grouped scaling and centering. It is also possible to scale data without centering i.e. perform mean-preserving scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fscale(x, ...)
   STD(x, ...)

## Default S3 method:
fscale(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)
## Default S3 method:
STD(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)

## S3 method for class 'matrix'
fscale(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)
## S3 method for class 'matrix'
STD(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1,
    stub = .op[["stub"]], ...)

## S3 method for class 'data.frame'
fscale(x, g = NULL, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)
## S3 method for class 'data.frame'
STD(x, by = NULL, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
    mean = 0, sd = 1, stub = .op[["stub"]], keep.by = TRUE, keep.w = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fscale(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)
## S3 method for class 'pseries'
STD(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)

## S3 method for class 'pdata.frame'
fscale(x, effect = 1L, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1, ...)
## S3 method for class 'pdata.frame'
STD(x, effect = 1L, w = NULL, cols = is.numeric, na.rm = .op[["na.rm"]],
    mean = 0, sd = 1, stub = .op[["stub"]], keep.ids = TRUE, keep.w = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
fscale(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1,
       keep.group_vars = TRUE, keep.w = TRUE, ...)
## S3 method for class 'grouped_df'
STD(x, w = NULL, na.rm = .op[["na.rm"]], mean = 0, sd = 1,
    stub = .op[["stub"]], keep.group_vars = TRUE, keep.w = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fscale_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df').</p>
</td></tr>
<tr><td><code id="fscale_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fscale_+3A_by">by</code></td>
<td>
<p><em>STD data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="fscale_+3A_cols">cols</code></td>
<td>
<p><em>STD (p)data.frame method</em>: Select columns to scale using a function, column names, indices or a logical vector. Default: All numeric columns. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="fscale_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights. <code>STD</code> data frame and <code>pdata.frame</code> methods also allow a one-sided formula i.e. <code>~ weightcol</code>. The <code>grouped_df</code> (<em>dplyr</em>) method supports lazy-evaluation. See Examples.</p>
</td></tr>
<tr><td><code id="fscale_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code> or <code>w</code> when computing means and sd's.</p>
</td></tr>
<tr><td><code id="fscale_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifier should be used as group-id. 1L takes the first variable in the <a href="#topic+indexing">index</a>, 2L the second etc.. Index variables can also be called by name using a character string. More than one variable can be supplied. </p>
</td></tr>
<tr><td><code id="fscale_+3A_stub">stub</code></td>
<td>
<p>character. A prefix/stub to add to the names of all transformed columns. <code>TRUE</code> (default) uses <code>"STD."</code>, <code>FALSE</code> will not rename columns.</p>
</td></tr>
<tr><td><code id="fscale_+3A_mean">mean</code></td>
<td>
<p>the mean to center on (default is 0). If <code>mean = FALSE</code>, no centering will be performed. In that case the scaling is mean-preserving. A numeric value different from 0 (i.e. <code>mean = 5</code>) will be added to the data after subtracting out the mean(s), such that the data will have a mean of 5. A special option when performing grouped scaling and centering is <code>mean = "overall.mean"</code>. In that case the overall mean of the data will be added after subtracting out group means.</p>
</td></tr>
<tr><td><code id="fscale_+3A_sd">sd</code></td>
<td>
<p>the standard deviation to scale the data to (default is 1). A numeric value different from 0 (i.e. <code>sd = 3</code>) will scale the data to have a standard deviation  of 3. A special option when performing grouped scaling is <code>sd = "within.sd"</code>. In that case the within standard deviation (= the standard deviation of the group-centered series) will be calculated and applied to each group. The results is that the variance of the data within each group is harmonized without forcing a certain variance (such as 1).</p>
</td></tr>
<tr><td><code id="fscale_+3A_keep.by">keep.by</code>, <code id="fscale_+3A_keep.ids">keep.ids</code>, <code id="fscale_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain grouping / panel-identifier columns in the output. For <code>STD.data.frame</code> this only works if grouping variables were passed in a formula.</p>
</td></tr>
<tr><td><code id="fscale_+3A_keep.w">keep.w</code></td>
<td>
<p><em>data.frame, pdata.frame and grouped_df methods</em>: Logical. Retain column containing the weights in the output. Only works if <code>w</code> is passed as formula / lazy-expression.</p>
</td></tr>
<tr><td><code id="fscale_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>g = NULL</code>, <code>fscale</code> by default (column-wise) subtracts the mean or weighted mean (if <code>w</code> is supplied) from all data points in <code>x</code>, and then divides this difference by the standard deviation or frequency-weighted standard deviation. The result is that all columns in <code>x</code> will have a (weighted) mean 0 and (weighted) standard deviation 1. Alternatively, data can be scaled to have a mean of <code>mean</code> and a standard deviation of <code>sd</code>. If <code>mean = FALSE</code> the data is only scaled (not centered) such that the mean of the data is preserved. <br />
</p>
<p>Means and standard deviations are computed using Welford's numerically stable online algorithm.
</p>
<p>With groups supplied to <code>g</code>, this standardizing becomes groupwise, so that in each group (in each column) the data points will have mean <code>mean</code> and standard deviation <code>sd</code>. Naturally if <code>mean = FALSE</code> then each group is just scaled and the mean is preserved. For centering without scaling see <code><a href="#topic+fwithin">fwithin</a></code>.
</p>
<p>If <code>na.rm = FALSE</code> and a <code>NA</code> or <code>NaN</code> is encountered, the mean and sd for that group will be <code>NA</code>, and all data points belonging to that group will also be <code>NA</code> in the output.
</p>
<p>If <code>na.rm = TRUE</code>, means and sd's are computed (column-wise) on the available data points, and also the weight vector can have missing values. In that case, the weighted mean an sd are computed on (column-wise) <code>complete.cases(x, w)</code>, and <code>x</code> is scaled using these statistics. <em>Note</em> that <code>fscale</code> will not insert a missing value in <code>x</code> if the weight for that value is missing, rather, that value will be scaled using a weighted mean and standard-deviated computed without itself! (The intention here is that a few (randomly) missing weights shouldn't break the computation when <code>na.rm = TRUE</code>, but it is not meant for weight vectors with many missing values. If you don't like this behavior, you should prepare your data using <code>x[is.na(w), ] &lt;- NA</code>, or impute your weight vector for non-missing <code>x</code>).
</p>
<p>Special options for grouped scaling are <code>mean = "overall.mean"</code> and <code>sd = "within.sd"</code>. The former group-centers vectors on the overall mean of the data (see <code><a href="#topic+fwithin">fwithin</a></code> for more details) and the latter scales the data in each group to have the within-group standard deviation (= the standard deviation of the group-centered data). Thus scaling a grouped vector with options <code>mean = "overall.mean"</code> and <code>sd = "within.sd"</code> amounts to removing all differences in the mean and standard deviations between these groups. In weighted computations, <code>mean = "overall.mean"</code> will subtract weighted group-means from the data and add the overall weighted mean of the data, whereas <code>sd = "within.sd"</code> will compute the weighted within- standard deviation and apply it to each group.
</p>


<h3>Value</h3>

<p><code>x</code> standardized (mean = mean, standard deviation = sd), grouped by <code>g/by</code>, weighted with <code>w</code>. See Details.
</p>


<h3>Note</h3>

<p>For centering without scaling see <code><a href="#topic+fwithin">fwithin/W</a></code>. For simple not mean-preserving scaling use <code><a href="#topic+fsd">fsd(..., TRA = &quot;/&quot;)</a></code>. To sweep pre-computed means and scale-factors out of data see <code><a href="#topic+TRA">TRA</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwithin">fwithin</a></code>, <code><a href="#topic+fsd">fsd</a></code>, <code><a href="#topic+TRA">TRA</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Scaling &amp; Centering / Standardizing
head(fscale(mtcars))               # Doesn't rename columns
head(STD(mtcars))                  # By default adds a prefix
qsu(STD(mtcars))                   # See that is works
qsu(STD(mtcars, mean = 5, sd = 3)) # Assigning a mean of 5 and a standard deviation of 3
qsu(STD(mtcars, mean = FALSE))     # No centering: Scaling is mean-preserving

## Panel Data
head(fscale(get_vars(wlddev,9:12), wlddev$iso3c))   # Standardizing 4 series within each country
head(STD(wlddev, ~iso3c, cols = 9:12))              # Same thing using STD, id's added
pwcor(fscale(get_vars(wlddev,9:12), wlddev$iso3c))  # Correlaing panel series after standardizing

fmean(get_vars(wlddev, 9:12))                       # This calculates the overall means
fsd(fwithin(get_vars(wlddev, 9:12), wlddev$iso3c))  # This calculates the within standard deviations
head(qsu(fscale(get_vars(wlddev, 9:12),             # This group-centers on the overall mean and
    wlddev$iso3c,                                   # group-scales to the within standard deviation
    mean = "overall.mean", sd = "within.sd"),       # -&gt; data harmonized in the first 2 moments
    by = wlddev$iso3c))

## Indexed data
wldi &lt;- findex_by(wlddev, iso3c, year)
head(STD(wldi))                                  # Standardizing all numeric variables by country
head(STD(wldi, effect = 2L))                     # Standardizing all numeric variables by year

## Weighted Standardizing
weights = abs(rnorm(nrow(wlddev)))
head(fscale(get_vars(wlddev,9:12), wlddev$iso3c, weights))
head(STD(wlddev, ~iso3c, weights, 9:12))

# Grouped data
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(PCGDP,LIFEEX) |&gt; STD()
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(PCGDP,LIFEEX) |&gt; STD(weights) # weighted standardizing
wlddev |&gt; fgroup_by(iso3c) |&gt; fselect(PCGDP,LIFEEX,POP) |&gt; STD(POP) # weighting by POP -&gt;
# ..keeps the weight column unless keep.w = FALSE
</code></pre>

<hr>
<h2 id='fselect-get_vars-add_vars'>Fast Select, Replace or Add Data Frame Columns</h2><span id='topic+fselect'></span><span id='topic+fselect+3C-'></span><span id='topic+slt'></span><span id='topic+slt+3C-'></span><span id='topic+get_vars'></span><span id='topic+gv'></span><span id='topic+gvr'></span><span id='topic+num_vars'></span><span id='topic+nv'></span><span id='topic+cat_vars'></span><span id='topic+char_vars'></span><span id='topic+fact_vars'></span><span id='topic+logi_vars'></span><span id='topic+date_vars'></span><span id='topic+add_vars'></span><span id='topic+av'></span><span id='topic+get_vars+3C-'></span><span id='topic+gv+3C-'></span><span id='topic+gvr+3C-'></span><span id='topic+num_vars+3C-'></span><span id='topic+nv+3C-'></span><span id='topic+cat_vars+3C-'></span><span id='topic+char_vars+3C-'></span><span id='topic+fact_vars+3C-'></span><span id='topic+logi_vars+3C-'></span><span id='topic+date_vars+3C-'></span><span id='topic+add_vars+3C-'></span><span id='topic+av+3C-'></span>

<h3>Description</h3>

<p>Efficiently select and replace (or add) a subset of columns from (to) a data frame. This can be done by data type, or using expressions, column names, indices, logical vectors, selector functions or regular expressions matching column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Select and replace variables, analgous to dplyr::select but significantly faster
fselect(.x, ..., return = "data")
fselect(x, ...) &lt;- value
slt(.x, ..., return = "data")   # Shorthand for fselect
slt(x, ...) &lt;- value            # Shorthand for fselect&lt;-

## Select and replace columns by names, indices, logical vectors,
## regular expressions or using functions to identify columns

get_vars(x, vars, return = "data", regex = FALSE, rename = FALSE, ...)
      gv(x, vars, return = "data", ...)   # Shorthand for get_vars
     gvr(x, vars, return = "data", ...)   # Shorthand for get_vars(..., regex = TRUE)

get_vars(x, vars, regex = FALSE, ...) &lt;- value
      gv(x, vars, ...) &lt;- value           # Shorthand for get_vars&lt;-
     gvr(x, vars, ...) &lt;- value           # Shorthand for get_vars&lt;-(..., regex = TRUE)

## Add columns at any position within a data.frame

add_vars(x, ..., pos = "end")
add_vars(x, pos = "end") &lt;- value
      av(x, ..., pos = "end")             # Shorthand for add_vars
      av(x, pos = "end") &lt;- value         # Shorthand for add_vars&lt;-

## Select and replace columns by data type

num_vars(x, return = "data")
num_vars(x) &lt;- value
      nv(x, return = "data")       # Shorthand for num_vars
      nv(x) &lt;- value               # Shorthand for num_vars&lt;-
cat_vars(x, return = "data")       # Categorical variables, see is_categorical
cat_vars(x) &lt;- value
char_vars(x, return = "data")
char_vars(x) &lt;- value
fact_vars(x, return = "data")
fact_vars(x) &lt;- value
logi_vars(x, return = "data")
logi_vars(x) &lt;- value
date_vars(x, return = "data")      # See is_date
date_vars(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fselect-get_vars-add_vars_+3A_x">x</code>, <code id="fselect-get_vars-add_vars_+3A_.x">.x</code></td>
<td>
<p>a data frame or list.</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_value">value</code></td>
<td>
<p>a data frame or list of columns whose dimensions exactly match those of the extracted subset of <code>x</code>. If only 1 variable is in the subset of <code>x</code>, <code>value</code> can also be an atomic vector or matrix, provided that <code>NROW(value) == nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_vars">vars</code></td>
<td>
<p>a vector of column names, indices (can be negative), a suitable logical vector, or a vector of regular expressions matching column names (if <code>regex = TRUE</code>). It is also possible to pass a function returning <code>TRUE</code> or <code>FALSE</code> when applied to the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_return">return</code></td>
<td>
<p>an integer or string specifying what the selector function should return. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "data"   </td><td style="text-align: left;"></td><td style="text-align: left;"> subset of data frame (default) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "names" </td><td style="text-align: left;"></td><td style="text-align: left;"> column names </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "indices"   </td><td style="text-align: left;"></td><td style="text-align: left;"> column indices </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_indices"  </td><td style="text-align: left;"></td><td style="text-align: left;"> named column indices </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "logical"   </td><td style="text-align: left;"></td><td style="text-align: left;"> logical selection vector </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_logical"     </td><td style="text-align: left;"></td><td style="text-align: left;"> named logical vector </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><em>Note</em>: replacement functions only replace data, however column names are replaced together with the data (if available).
</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_regex">regex</code></td>
<td>
<p>logical. <code>TRUE</code> will do regular expression search on the column names of <code>x</code> using a (vector of) regular expression(s) passed to <code>vars</code>. Matching is done using <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_rename">rename</code></td>
<td>
<p>logical. If <code>vars</code> is a named vector of column names or indices, <code>rename = TRUE</code> will use the (non missing) names to rename columns.</p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_pos">pos</code></td>
<td>
<p>the position where columns are added in the data frame. <code>"end"</code> (default) will append the data frame at the end (right) side. &quot;front&quot; will add columns in front (left). Alternatively one can pass a vector of positions (matching <code>length(value)</code> if value is a list). In that case the other columns will be shifted around the new ones while maintaining their order. </p>
</td></tr>
<tr><td><code id="fselect-get_vars-add_vars_+3A_...">...</code></td>
<td>
<p>for <code>fselect</code>: column names and expressions e.g. <code>fselect(mtcars, newname = mpg, hp, carb:vs)</code>. for <code>get_vars</code>: further arguments passed to <code><a href="base.html#topic+grep">grep</a></code>, if <code>regex = TRUE</code>. For <code>add_vars</code>: multiple lists/data frames or vectors (which should be given names e.g. <code>name = vector</code>). A single argument passed may also be an (unnamed) vector or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_vars(&lt;-)</code> is around 2x faster than <code>`[.data.frame`</code> and 8x faster than <code>`[&lt;-.data.frame`</code>, so the common operation <code>data[cols] &lt;- someFUN(data[cols])</code> can be made 10x more efficient (abstracting from computations performed by <code>someFUN</code>) using <code>get_vars(data, cols) &lt;- someFUN(get_vars(data, cols))</code> or the shorthand <code>gv(data, cols) &lt;- someFUN(gv(data, cols))</code>.
</p>
<p>Similarly type-wise operations like <code>data[sapply(data, is.numeric)]</code> or <code>data[sapply(data, is.numeric)] &lt;- value</code> are facilitated and more efficient using <code>num_vars(data)</code> and <code>num_vars(data) &lt;- value</code> or the shortcuts <code>nv</code> and <code>nv&lt;-</code> etc.
</p>
<p><code>fselect</code> provides an efficient alternative to <code>dplyr::select</code>, allowing the selection of variables based on expressions evaluated within the data frame, see Examples. It is about 100x faster than <code>dplyr::select</code> but also more simple as it does not provide special methods (except for 'sf' and 'data.table' which are handled internally) .
</p>
<p>Finally, <code>add_vars(data1, data2, data3, ...)</code> is a lot faster than <code>cbind(data1, data2, data3, ...)</code>, and preserves the attributes of <code>data1</code> (i.e. it is like adding columns to <code>data1</code>). The replacement function <code>add_vars(data) &lt;- someFUN(get_vars(data, cols))</code> efficiently appends <code>data</code> with computed columns. The <code>pos</code> argument allows adding columns at positions other than the end (right) of the data frame, see Examples. <em>Note</em> that <code>add_vars</code> does not check duplicated column names or <code>NULL</code> columns, and does not evaluate expressions in a data environment, or replicate length 1 inputs like <code><a href="base.html#topic+cbind">cbind</a></code>. All of this is provided by <code><a href="#topic+ftransform">ftransform</a></code>.
</p>
<p>All functions introduced here perform their operations class-independent. They all basically work like this: (1) save the attributes of <code>x</code>, (2) unclass <code>x</code>, (3) subset, replace or append <code>x</code> as a list, (4) modify the &quot;names&quot; component of the attributes of <code>x</code> accordingly and (5) efficiently attach the attributes again to the result from step (3).
Thus they can freely be applied to data.table's, grouped tibbles, panel data frames and other classes and will return an object of exactly the same class and the same attributes.
</p>



<h3>Note</h3>

<p>In many cases functions here only check the length of the first column, which is one of the reasons why they are so fast. When lists of unequal-length columns are offered as replacements this yields a malformed data frame (which will also print a warning in the console i.e. you will notice that).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fsubset">fsubset</a></code>, <code><a href="#topic+ftransform">ftransform</a></code>, <code><a href="#topic+rowbind">rowbind</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Wold Development Data
head(fselect(wlddev, Country = country, Year = year, ODA)) # Fast dplyr-like selecting
head(fselect(wlddev, -country, -year, -PCGDP))
head(fselect(wlddev, country, year, PCGDP:ODA))
head(fselect(wlddev, -(PCGDP:ODA)))
fselect(wlddev, country, year, PCGDP:ODA) &lt;- NULL          # Efficient deleting
head(wlddev)
rm(wlddev)

head(num_vars(wlddev))                                     # Select numeric variables
head(cat_vars(wlddev))                                     # Select categorical (non-numeric) vars
head(get_vars(wlddev, is_categorical))                     # Same thing

num_vars(wlddev) &lt;- num_vars(wlddev)                       # Replace Numeric Variables by themselves
get_vars(wlddev,is.numeric) &lt;- get_vars(wlddev,is.numeric) # Same thing

head(get_vars(wlddev, 9:12))                               # Select columns 9 through 12, 2x faster
head(get_vars(wlddev, -(9:12)))                            # All except columns 9 through 12
head(get_vars(wlddev, c("PCGDP","LIFEEX","GINI","ODA")))   # Select using column names
head(get_vars(wlddev, "[[:upper:]]", regex = TRUE))        # Same thing: match upper-case var. names
head(gvr(wlddev, "[[:upper:]]"))                           # Same thing

get_vars(wlddev, 9:12) &lt;- get_vars(wlddev, 9:12)           # 9x faster wlddev[9:12] &lt;- wlddev[9:12]
add_vars(wlddev) &lt;- STD(gv(wlddev,9:12), wlddev$iso3c)     # Add Standardized columns 9 through 12
head(wlddev)                                               # gv and av are shortcuts

get_vars(wlddev, 14:17) &lt;- NULL                            # Efficient Deleting added columns again
av(wlddev, "front") &lt;- STD(gv(wlddev,9:12), wlddev$iso3c)  # Again adding in Front
head(wlddev)
get_vars(wlddev, 1:4) &lt;- NULL                              # Deleting
av(wlddev,c(10,12,14,16)) &lt;- W(wlddev,~iso3c, cols = 9:12, # Adding next to original variables
                               keep.by = FALSE)
head(wlddev)
get_vars(wlddev, c(10,12,14,16)) &lt;- NULL                   # Deleting

head(add_vars(wlddev, new = STD(wlddev$PCGDP)))                  # Can also add columns like this
head(add_vars(wlddev, STD(nv(wlddev)), new = W(wlddev$PCGDP)))   # etc...

head(add_vars(mtcars, mtcars, mpg = mtcars$mpg, mtcars), 2)      # add_vars does not check names!
</code></pre>

<hr>
<h2 id='fsubset'>Fast Subsetting Matrix-Like Objects</h2><span id='topic+fsubset'></span><span id='topic+sbt'></span><span id='topic+ss'></span><span id='topic+fsubset.default'></span><span id='topic+fsubset.matrix'></span><span id='topic+fsubset.data.frame'></span><span id='topic+fsubset.pseries'></span><span id='topic+fsubset.pdata.frame'></span>

<h3>Description</h3>

<p><code>fsubset</code> returns subsets of vectors, matrices or data frames which meet conditions. It is programmed very efficiently and uses C source code from the <em>data.table</em> package. 
The methods also provide enhanced functionality compared to <code><a href="base.html#topic+subset">subset</a></code>. The function <code>ss</code> provides an (internal generic) programmers alternative to <code>[</code> that does not drop dimensions and is significantly faster than <code>[</code> for data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsubset(.x, ...)
sbt(.x, ...)     # Shorthand for fsubset

## Default S3 method:
fsubset(.x, subset, ...)

## S3 method for class 'matrix'
fsubset(.x, subset, ..., drop = FALSE)

## S3 method for class 'data.frame'
fsubset(.x, subset, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
fsubset(.x, subset, ..., drop.index.levels = "id")

## S3 method for class 'pdata.frame'
fsubset(.x, subset, ..., drop.index.levels = "id")


# Fast subsetting (replaces `[` with drop = FALSE, programmers choice)
ss(x, i, j, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsubset_+3A_.x">.x</code></td>
<td>
<p>object to be subsetted according to different methods.</p>
</td></tr>
<tr><td><code id="fsubset_+3A_x">x</code></td>
<td>
<p>a data frame / list, matrix or vector/array (only <code>i</code>).</p>
</td></tr>
<tr><td><code id="fsubset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements or rows to keep:
missing values are taken as <code>FALSE</code>. The default, matrix and pseries methods only support logical vectors or row-indices (or a character vector of rownames if the matrix has rownames). </p>
</td></tr>
<tr><td><code id="fsubset_+3A_...">...</code></td>
<td>
<p>For the matrix or data frame method: multiple comma-separated expressions indicating columns to select. Otherwise: further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="fsubset_+3A_drop">drop</code></td>
<td>
<p>passed on to <code>[</code> indexing operator. Only available for the matrix method.</p>
</td></tr>
<tr><td><code id="fsubset_+3A_i">i</code></td>
<td>
<p>positive or negative row-indices or a logical vector to subset the rows of <code>x</code>.</p>
</td></tr>
<tr><td><code id="fsubset_+3A_j">j</code></td>
<td>
<p>a vector of column names, positive or negative indices or a suitable logical vector to subset the columns of <code>x</code>. <em>Note:</em> Negative indices are converted to positive ones using <code>j &lt;- seq_along(x)[j]</code>.</p>
</td></tr>
<tr><td><code id="fsubset_+3A_check">check</code></td>
<td>
<p>logical. <code>FALSE</code> skips checks on <code>i</code> and <code>j</code>, e.g. whether indices are negative. This offers a speedup to programmers, but can terminate R if zero or negative indices are passed. </p>
</td></tr>
<tr><td><code id="fsubset_+3A_drop.index.levels">drop.index.levels</code></td>
<td>
<p>character. Either <code>"id"</code>, <code>"time"</code>, <code>"all"</code> or <code>"none"</code>. See <a href="#topic+indexing">indexing</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fsubset</code> is a generic function, with methods supplied for vectors, matrices, and data
frames (including lists). It represents an improvement over <code><a href="base.html#topic+subset">subset</a></code> in terms of both speed and functionality. The function <code>ss</code> is an improvement of <code>[</code> to subset (vectors) matrices and data frames without dropping dimensions. It is significantly faster than <code>[.data.frame</code>.
</p>
<p>For ordinary vectors, <code>subset</code> can be integer or logical, subsetting is done in C and more efficient than <code>[</code> for large vectors.
</p>
<p>For matrices the implementation is all base-R but slightly more efficient and more versatile than <code><a href="base.html#topic+subset.matrix">subset.matrix</a></code>. Thus it is possible to <code>subset</code> matrix rows using logical or integer vectors, or character vectors matching rownames. The <code>drop</code> argument is passed on to the <code>[</code> method for matrices.
</p>
<p>For both matrices and data frames, the <code>...</code> argument can be used to subset columns, and is evaluated in a non-standard way. Thus it can support vectors of column names, indices or logical vectors, but also multiple comma separated column names passed without quotes, each of which may also be replaced by a sequence of columns i.e. <code>col1:coln</code>, and new column names may be assigned e.g. <code>fsubset(data, col1 &gt; 20, newname =  col2, col3:col6)</code> (see examples).
</p>
<p>For data frames, the <code>subset</code> argument is also evaluated in a non-standard way. Thus next to vector of row-indices or logical vectors, it supports logical expressions of the form <code>col2 &gt; 5 &amp; col2 &lt; col3</code> etc. (see examples). The data frame method is implemented in C, hence it is significantly faster than <code><a href="base.html#topic+subset.data.frame">subset.data.frame</a></code>. If fast data frame subsetting is required but no non-standard evaluation, the function <code>ss</code> is slightly simpler and faster.
</p>
<p>Factors may have empty levels after subsetting; unused levels are not automatically removed.  See <code><a href="#topic+fdroplevels">fdroplevels</a></code> to drop all unused levels from a data frame.
</p>


<h3>Value</h3>

<p>An object similar to <code>.x/x</code> containing just the selected elements (for
a vector), rows and columns (for a matrix or data frame).
</p>


<h3>Note</h3>

<p><code>ss</code> offers no support for indexed data. Use <code>fsubset</code> with indices instead.
</p>
<p>No replacement method <code>fsubset&lt;-</code> or <code>ss&lt;-</code> is offered in <em>collapse</em>. For efficient subset replacement (without copying) use <code>data.table::set</code>, which can also be used with data frames and tibbles. To search and replace certain elements without copying, and to efficiently copy elements / rows from an equally sized vector / data frame, see <code><a href="#topic+setv">setv</a></code>.
</p>
<p>For subsetting columns alone, please also see <a href="#topic+fselect">selecting and replacing columns</a>.
</p>
<p>Note that the use of <code><a href="#topic++25+3D+3D+25">%==%</a></code> can yield significant performance gains on large data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fselect">fselect</a></code>,
<code><a href="#topic+get_vars">get_vars</a></code>,
<code><a href="#topic+ftransform">ftransform</a></code>,
<a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsubset(airquality, Temp &gt; 90, Ozone, Temp)
fsubset(airquality, Temp &gt; 90, OZ = Ozone, Temp) # With renaming
fsubset(airquality, Day == 1, -Temp)
fsubset(airquality, Day == 1, -(Day:Temp))
fsubset(airquality, Day == 1, Ozone:Wind)
fsubset(airquality, Day == 1 &amp; !is.na(Ozone), Ozone:Wind, Month)
fsubset(airquality, Day %==% 1, -Temp)  # Faster for big data, as %==% directly returns indices

ss(airquality, 1:10, 2:3)         # Significantly faster than airquality[1:10, 2:3]
fsubset(airquality, 1:10, 2:3)    # This is possible but not advised
</code></pre>

<hr>
<h2 id='fsum'>Fast (Grouped, Weighted) Sum for Matrix-Like Objects</h2><span id='topic+fsum'></span><span id='topic+fsum.default'></span><span id='topic+fsum.matrix'></span><span id='topic+fsum.data.frame'></span><span id='topic+fsum.grouped_df'></span>

<h3>Description</h3>

<p><code>fsum</code> is a generic function that computes the (column-wise) sum of all values in <code>x</code>, (optionally) grouped by <code>g</code> and/or weighted by <code>w</code> (e.g. to calculate survey totals). The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped, weighted) sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsum(x, ...)

## Default S3 method:
fsum(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, fill = FALSE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'matrix'
fsum(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, fill = FALSE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'data.frame'
fsum(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, fill = FALSE, nthreads = .op[["nthreads"]], ...)

## S3 method for class 'grouped_df'
fsum(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE, stub = .op[["stub"]],
     fill = FALSE, nthreads = .op[["nthreads"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsum_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fsum_+3A_g">g</code></td>
<td>
<p>a factor, <code>GRP</code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code>GRP</code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fsum_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values.</p>
</td></tr>
<tr><td><code id="fsum_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fsum_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fsum_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fsum_+3A_fill">fill</code></td>
<td>
<p>logical. Initialize result with <code>0</code> instead of <code>NA</code> when <code>na.rm = TRUE</code> e.g. <code>fsum(NA, fill = TRUE)</code> returns <code>0</code> instead of <code>NA</code>. </p>
</td></tr>
<tr><td><code id="fsum_+3A_nthreads">nthreads</code></td>
<td>
<p>integer. The number of threads to utilize. See Details. </p>
</td></tr>
<tr><td><code id="fsum_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fsum_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fsum_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain summed weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fsum_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fsum_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>



<p>The weighted sum (e.g. survey total) is computed as <code>sum(x * w)</code>, but in one pass and about twice as efficient. If <code>na.rm = TRUE</code>, missing values will be removed from both <code>x</code> and <code>w</code> i.e. utilizing only <code>x[complete.cases(x,w)]</code> and <code>w[complete.cases(x,w)]</code>.
</p>
<p>This all seamlessly generalizes to grouped computations, which are performed in a single pass (without splitting the data) and are therefore extremely fast. See Benchmark and Examples below.
</p>
<p>When applied to data frames with groups or <code>drop = FALSE</code>, <code>fsum</code> preserves all column attributes. The attributes of the data frame itself are also preserved.
</p>
<p>Since v1.6.0 <code>fsum</code> explicitly supports integers. Integers are summed using the long long type in C which is bounded at +-9,223,372,036,854,775,807 (so ~4.3 billion times greater than the minimum/maximum R integer bounded at +-2,147,483,647). If the value of the sum is outside +-2,147,483,647, a double containing the result is returned, otherwise an integer is returned. With groups, an integer results vector is initialized, and an integer overflow error is provided if the sum in any group is outside +-2,147,483,647. Data needs to be coerced to double beforehand in such cases.
</p>
<p>Multithreading, added in v1.8.0, applies at the column-level unless <code>g = NULL</code> and <code>nthreads &gt; NCOL(x)</code>. Parallelism over groups is not available because sums are computed simultaneously within each group. <code>nthreads = 1L</code> uses a serial version of the code, not parallel code running on one thread. This serial code is always used with less than 100,000 obs (<code>length(x) &lt; 100000</code> for vectors and matrices), because parallel execution itself has some overhead.
</p>


<h3>Value</h3>

<p>The (<code>w</code> weighted) sum of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighted) sum.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fprod">fprod</a></code>, <code><a href="#topic+fmean">fmean</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
mpg &lt;- mtcars$mpg
fsum(mpg)                         # Simple sum
fsum(mpg, w = mtcars$hp)          # Weighted sum (total): Weighted by hp
fsum(mpg, TRA = "%")              # Simple transformation: obtain percentages of mpg
fsum(mpg, mtcars$cyl)             # Grouped sum
fsum(mpg, mtcars$cyl, mtcars$hp)  # Weighted grouped sum (total)
fsum(mpg, mtcars[c(2,8:9)])       # More groups..
g &lt;- GRP(mtcars, ~ cyl + vs + am) # Precomputing groups gives more speed !
fsum(mpg, g)
fmean(mpg, g) == fsum(mpg, g) / fnobs(mpg, g)
fsum(mpg, g, TRA = "%")           # Percentages by group

## data.frame method
fsum(mtcars)
fsum(mtcars, TRA = "%")
fsum(mtcars, g)
fsum(mtcars, g, TRA = "%")

## matrix method
m &lt;- qM(mtcars)
fsum(m)
fsum(m, TRA = "%")
fsum(m, g)
fsum(m, g, TRA = "%")

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsum(hp)  # Weighted grouped sum (total)
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsum(TRA = "%")
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fselect(mpg) |&gt; fsum()

 
## This compares fsum with data.table and base::rowsum
# Starting with small data
library(data.table)
opts &lt;- set_collapse(nthreads = getDTthreads())
mtcDT &lt;- qDT(mtcars)
f &lt;- qF(mtcars$cyl)

library(microbenchmark)
microbenchmark(mtcDT[, lapply(.SD, sum), by = f],
               rowsum(mtcDT, f, reorder = FALSE),
               fsum(mtcDT, f, na.rm = FALSE), unit = "relative")

# Now larger data
tdata &lt;- qDT(replicate(100, rnorm(1e5), simplify = FALSE)) # 100 columns with 100.000 obs
f &lt;- qF(sample.int(1e4, 1e5, TRUE))                        # A factor with 10.000 groups

microbenchmark(tdata[, lapply(.SD, sum), by = f],
               rowsum(tdata, f, reorder = FALSE),
               fsum(tdata, f, na.rm = FALSE), unit = "relative")
# Reset options
set_collapse(opts)

</code></pre>

<hr>
<h2 id='fsummarise'>
Fast Summarise
</h2><span id='topic+fsummarise'></span><span id='topic+fsummarize'></span><span id='topic+smr'></span>

<h3>Description</h3>

<p><code>fsummarise</code> is a much faster version of <code>dplyr::summarise</code>, when used together with the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>.
</p>
<p><code>fsummarize</code> and <code>fsummarise</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsummarise(.data, ..., keep.group_vars = TRUE, .cols = NULL)
fsummarize(.data, ..., keep.group_vars = TRUE, .cols = NULL)
smr(.data, ..., keep.group_vars = TRUE, .cols = NULL)        # Shorthand
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsummarise_+3A_.data">.data</code></td>
<td>

<p>a (grouped) data frame or named list of columns. Grouped data can be created with <code><a href="#topic+fgroup_by">fgroup_by</a></code> or <code>dplyr::group_by</code>.
</p>
</td></tr>
<tr><td><code id="fsummarise_+3A_...">...</code></td>
<td>

<p>name-value pairs of summary functions, <code><a href="#topic+across">across</a></code> statements, or arbitrary expressions resulting in a list. See Examples. For fast performance use the <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>. 
</p>
</td></tr>
<tr><td><code id="fsummarise_+3A_keep.group_vars">keep.group_vars</code></td>
<td>

<p>logical. <code>FALSE</code> removes grouping variables after computation.
</p>
</td></tr>
<tr><td><code id="fsummarise_+3A_.cols">.cols</code></td>
<td>

<p>for expressions involving <code>.data</code>, <code>.cols</code> can be used to subset columns, e.g. <code>mtcars |&gt; gby(cyl) |&gt; smr(mctl(cor(.data), TRUE), .cols = 5:7)</code>. Can pass column names, indices, a logical vector or a selector function (e.g. <code>is.numericr</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>.data</code> is grouped by <code><a href="#topic+fgroup_by">fgroup_by</a></code> or <code>dplyr::group_by</code>, the result is a data frame of the same class and attributes with rows reduced to the number of groups. If <code>.data</code> is not grouped, the result is a data frame of the same class and attributes with 1 row.
</p>


<h3>Note</h3>

<p>Since v1.7, <code>fsummarise</code> is fully featured, allowing expressions using functions and columns of the data as well as external scalar values (just like <code>dplyr::summarise</code>). <b>NOTE</b> however that once a <a href="#topic+fast-statistical-functions">Fast Statistical Function</a> is used, the execution will be vectorized instead of split-apply-combine computing over groups. Please see the first Example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+across">across</a></code>, <code><a href="#topic+collap">collap</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Since v1.7, fsummarise supports arbitrary expressions, and expressions
## containing fast statistical functions receive vectorized execution:

# (a) This is an expression using base R functions which is executed by groups
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(res = mean(mpg) + min(qsec))

# (b) Here, the use of fmean causes the whole expression to be executed
# in a vectorized way i.e. the expression is translated to something like
# fmean(mpg, g = cyl) + min(mpg) and executed, thus the result is different
# from (a), because the minimum is calculated over the entire sample
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(mpg = fmean(mpg) + min(qsec))

# (c) For fully vectorized execution, use fmin. This yields the same as (a)
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(mpg = fmean(mpg) + fmin(qsec))

# More advanced use: vectorized grouped regression slopes: mpg ~ carb
mtcars |&gt;
  fgroup_by(cyl) |&gt;
  fmutate(dm_carb = fwithin(carb)) |&gt;
  fsummarise(beta = fsum(mpg, dm_carb) %/=% fsum(dm_carb^2))


# In across() statements it is fine to mix different functions, each will
# be executed on its own terms (i.e. vectorized for fmean and standard for sum)
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(across(mpg:hp, list(fmean, sum)))

# Note that this still detects fmean as a fast function, the names of the list
# are irrelevant, but the function name must be typed or passed as a character vector,
# Otherwise functions will be executed by groups e.g. function(x) fmean(x) won't vectorize
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(across(mpg:hp, list(mu = fmean, sum = sum)))

# We can force none-vectorized execution by setting .apply = TRUE
mtcars |&gt; fgroup_by(cyl) |&gt; fsummarise(across(mpg:hp, list(mu = fmean, sum = sum), .apply = TRUE))

# Another argument of across(): Order the result first by function, then by column
mtcars |&gt; fgroup_by(cyl) |&gt;
     fsummarise(across(mpg:hp, list(mu = fmean, sum = sum), .transpose = FALSE))


# Since v1.9.0, can also evaluate arbitrary expressions
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt;
   fsummarise(mctl(cor(cbind(mpg, wt, carb)), names = TRUE))

# This can also be achieved using across():
corfun &lt;- function(x) mctl(cor(x), names = TRUE)
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt;
   fsummarise(across(c(mpg, wt, carb), corfun, .apply = FALSE))

#----------------------------------------------------------------------------
# Examples that also work for pre 1.7 versions

# Simple use
fsummarise(mtcars, mean_mpg = fmean(mpg),
                   sd_mpg = fsd(mpg))

# Using base functions (not a big difference without groups)
fsummarise(mtcars, mean_mpg = mean(mpg),
                   sd_mpg = sd(mpg))

# Grouped use
mtcars |&gt; fgroup_by(cyl) |&gt;
  fsummarise(mean_mpg = fmean(mpg),
             sd_mpg = fsd(mpg))

# This is still efficient but quite a bit slower on large data (many groups)
mtcars |&gt; fgroup_by(cyl) |&gt;
  fsummarise(mean_mpg = mean(mpg),
             sd_mpg = sd(mpg))

# Weighted aggregation
mtcars |&gt; fgroup_by(cyl) |&gt;
  fsummarise(w_mean_mpg = fmean(mpg, wt),
             w_sd_mpg = fsd(mpg, wt))

 
## Can also group with dplyr::group_by, but at a conversion cost, see ?GRP
library(dplyr)
mtcars |&gt; group_by(cyl) |&gt;
  fsummarise(mean_mpg = fmean(mpg),
             sd_mpg = fsd(mpg))

# Again less efficient...
mtcars |&gt; group_by(cyl) |&gt;
  fsummarise(mean_mpg = mean(mpg),
             sd_mpg = sd(mpg))


</code></pre>

<hr>
<h2 id='ftransform'>Fast Transform and Compute Columns on a Data Frame</h2><span id='topic+fmutate'></span><span id='topic+mtt'></span><span id='topic+ftransform'></span><span id='topic+tfm'></span><span id='topic+ftransformv'></span><span id='topic+tfmv'></span><span id='topic+ftransform+3C-'></span><span id='topic+tfm+3C-'></span><span id='topic+settransform'></span><span id='topic+settfm'></span><span id='topic+settransformv'></span><span id='topic+settfmv'></span><span id='topic+fcompute'></span><span id='topic+fcomputev'></span>

<h3>Description</h3>

<p><code>ftransform</code> is a much faster version of <code><a href="base.html#topic+transform">transform</a></code> for data frames. It returns the data frame with new columns computed and/or existing columns modified or deleted. <code>settransform</code> does all of that by reference. <code>fcompute</code> computes and returns new columns. These functions evaluate all arguments simultaneously, allow list-input (nested pipelines) and disregard grouped data.
</p>
<p>Catering to the <em>tidyverse</em> user, v1.7.0 introduced <code>fmutate</code>, providing familiar functionality i.e. arguments are evaluated sequentially, computation on grouped data is done by groups, and functions can be applied to multiple columns using <code><a href="#topic+across">across</a></code>. See also the Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># dplyr-style mutate (sequential evaluation + across() feature)
fmutate(.data, ..., .keep = "all", .cols = NULL)
mtt(.data, ..., .keep = "all", .cols = NULL) # Shorthand for fmutate

# Modify and return data frame
ftransform(.data, ...)
ftransformv(.data, vars, FUN, ..., apply = TRUE)
tfm(.data, ...)               # Shorthand for ftransform
tfmv(.data, vars, FUN, ..., apply = TRUE)

# Modify data frame by reference
settransform(.data, ...)
settransformv(.data, ...)     # Same arguments as ftransformv
settfm(.data, ...)            # Shorthand for settransform
settfmv(.data, ...)

# Replace/add modified columns in/to a data frame
ftransform(.data) &lt;- value
tfm(.data) &lt;- value           # Shorthand for ftransform&lt;-

# Compute columns, returned as a new data frame
fcompute(.data, ..., keep = NULL)
fcomputev(.data, vars, FUN, ..., apply = TRUE, keep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftransform_+3A_.data">.data</code></td>
<td>
<p>a data frame or named list of columns.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_...">...</code></td>
<td>
<p>further arguments of the form <code>column = value</code>. The <code>value</code> can be a combination of other columns, a scalar value, or <code>NULL</code>, which deletes <code>column</code>. Alternatively it is also possible to place a single list here, which will be treated like a list of <code>column = value</code> arguments. For <code>ftransformv</code> and <code>fcomputev</code>, <code>...</code> can be used to pass further arguments to <code>FUN</code>. The ellipsis (<code>...</code>) is always evaluated within the data frame (<code>.data</code>) environment. See Examples.
<code>fmutate</code> additionally supports <code><a href="#topic+across">across</a></code> statements, and evaluates tagged vector expressions sequentially. With grouped execution, <code>dots</code> can also contain arbitrary expressions that result in a list of data-length columns. See Examples.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_vars">vars</code></td>
<td>
<p>variables to be transformed by applying <code>FUN</code> to them: select using names, indices, a logical vector or a selector function (e.g. <code>is.numeric</code>). Since v1.7 <code>vars</code> is evaluated within the <code>.data</code> environment, permitting expressions on columns e.g. <code>c(col1, col3:coln)</code>.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_fun">FUN</code></td>
<td>
<p>a single function yielding a result of length <code>NROW(.data)</code> or 1. See also <code>apply</code>.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_apply">apply</code></td>
<td>
<p>logical. <code>TRUE</code> (default) will apply <code>FUN</code> to each column selected in <code>vars</code>; <code>FALSE</code> will apply <code>FUN</code> to the subsetted data frame i.e. <code>FUN(get_vars(.data, vars), ...)</code>. The latter is useful for <em>collapse</em> functions with data frame or grouped / panel data frame methods, yielding performance gains and enabling grouped transformations. See Examples.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_value">value</code></td>
<td>
<p>a named list of replacements, it will be treated like an evaluated list of <code>column = value</code> arguments.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_keep">keep</code></td>
<td>
<p>select columns to preserve using column names, indices or a function (e.g. <code>is.numeric</code>). By default computed columns are added after the preserved ones, unless they are assigned the same name in which case the preserved columns will be replaced in order.</p>
</td></tr>
<tr><td><code id="ftransform_+3A_.keep">.keep</code></td>
<td>
<p>either one of <code>"all", "used", "unused"</code> or <code>"none"</code> (see <code><a href="dplyr.html#topic+mutate">mutate</a></code>), or columns names/indices/function as <code>keep</code>. <em>Note</em> that this does not work well with <code>across()</code> or other expressions supported since v1.9.0. The only sensible option you have there is to supply a character vector of all columns in the final dataset that you want to keep.   </p>
</td></tr>
<tr><td><code id="ftransform_+3A_.cols">.cols</code></td>
<td>
<p>for expressions involving <code>.data</code>, <code>.cols</code> can be used to subset columns, e.g. <code>mtcars |&gt; gby(cyl) |&gt; mtt(broom::augment(lm(mpg ~., .data)), .cols = 1:7)</code>. Can pass column names, indices, a logical vector or a selector function (e.g. <code>is.numericr</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>...</code> arguments to <code>ftransform</code> are tagged
vector expressions, which are evaluated in the data frame
<code>.data</code>.  The tags are matched against <code>names(.data)</code>, and for
those that match, the values replace the corresponding variable in
<code>.data</code>, whereas the others are appended to <code>.data</code>. It is also possible to delete columns by assigning <code>NULL</code> to them, i.e. <code>ftransform(data, colk = NULL)</code> removes <code>colk</code> from the data. <em>Note</em> that <code>names(.data)</code> and the names of the <code>...</code> arguments are checked for uniqueness beforehand, yielding an error if this is not the case.
</p>
<p>Since <em>collapse</em> v1.3.0, is is also possible to pass a single named list to <code>...</code>, i.e. <code>ftransform(data, newdata)</code>. This list will be treated like a list of tagged vector expressions. <em>Note</em> the different behavior: <code>ftransform(data, list(newcol = col1))</code> is the same as <code>ftransform(data, newcol = col1)</code>, whereas <code>ftransform(data, newcol = as.list(col1))</code> creates a list column. Something like <code>ftransform(data, as.list(col1))</code> gives an error because the list is not named. See Examples.   
</p>


<p>The function <code>ftransformv</code> added in v1.3.2 provides a fast replacement for the functions <code>dplyr::mutate_at</code> and <code>dplyr::mutate_if</code> (without the grouping feature) facilitating mutations of groups of columns (<code>dplyr::mutate_all</code> is already accounted for by <code><a href="#topic+dapply">dapply</a></code>). See Examples.
</p>
<p>The function <code>settransform</code> does all of that by reference, but uses base-R's copy-on modify semantics, which is equivalent to replacing the data with <code>&lt;-</code> (thus it is still memory efficient but the data will have a different memory address afterwards).
</p>
<p>The function <code>fcompute(v)</code> works just like <code>ftransform(v)</code>, but returns only the changed / computed columns without modifying or appending the data in <code>.data</code>. See Examples.
</p>
<p>The function <code>fmutate</code> added in v1.7.0, provides functionality familiar from <em>dplyr</em> 1.0.0 and higher. It evaluates tagged vector expressions sequentially and does operations by groups on a grouped frame (thus it is slower than <code>ftransform</code> if you have many tagged expressions or a grouped data frame). Note however that <em>collapse</em> does not depend on <em>rlang</em>, so things like lambda expressions are not available. <em>Note also</em> that <code>fmutate</code> operates differently on grouped data whether you use <code>.FAST_FUN</code> or base R functions / functions from other packages. With <code>.FAST_FUN</code> (including <code>.OPERATOR_FUN</code>, excluding <code>fhdbetween</code> / <code>fhdwithin</code> / <code>HDW</code> / <code>HDB</code>), <code>fmutate</code> performs an efficient vectorized execution, i.e. the grouping object from the grouped data frame is passed to the <code>g</code> argument of these functions, and for <code>.FAST_STAT_FUN</code> also <code>TRA = "replace_fill"</code> is set (if not overwritten by the user), yielding internal grouped computation by these functions without the need for splitting the data by groups. For base R and other functions, <code>fmutate</code> performs classical split-apply combine computing i.e. the relevant columns of the data are selected and split into groups, the expression is evaluated for each group, and the result is recombined and suitably expanded to match the original data frame. <b>Note</b> that it is not possible to mix vectorized and standard execution in the same expression!! Vectorized execution is performed if <b>any</b> <code>.FAST_FUN</code> or <code>.OPERATOR_FUN</code> is part of the expression, thus a code like <code>mtcars |&gt; gby(cyl) |&gt; fmutate(new = fmin(mpg) / min(mpg))</code> will be expanded to something like <code>mtcars |&gt; gby(cyl) |&gt; ftransform(new = fmin(mpg, g = GRP(.), TRA = "replace_fill") / min(mpg))</code> and then executed, i.e. <code>fmin(mpg)</code> will be executed in a vectorized way, and <code>min(mpg)</code> will not be executed by groups at all.
</p>


<h3>Value</h3>

<p>The modified data frame <code>.data</code>, or, for <code>fcompute</code>, a new data frame with the columns computed on <code>.data</code>. All attributes of <code>.data</code> are preserved.
</p>


<h3>Note</h3>

<p><code>ftransform</code> ignores grouped data. This is on purpose as it allows non-grouped transformation inside a pipeline on grouped data, and affords greater flexibility and performance in programming with the <code>.FAST_FUN</code>. In particular, you can run a nested pipeline inside <code>ftransform</code>, and decide which expressions should be grouped, and you can use the ad-hoc grouping functionality of the <code>.FAST_FUN</code>, allowing operations where different groupings are applied simultaneously in an expression. See Examples or the answer provided <a href="https://stackoverflow.com/questions/67349744/using-ftransform-along-with-fgroup-by-from-collapse-r-package">here</a>.
</p>
<p><code>fmutate</code> on the other hand supports grouped operations just like <code>dplyr::mutate</code>, but works in two different ways depending on whether you use <code>.FAST_FUN</code> in an expression or other functions. See the Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+across">across</a></code>, <code><a href="#topic+fsummarise">fsummarise</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fmutate() examples ---------------------------------------------------------------

# Please note that expressions are vectorized whenever they contain 'ANY' fast function
mtcars |&gt;
  fgroup_by(cyl, vs, am) |&gt;
  fmutate(mean_mpg = fmean(mpg),                     # Vectorized
          mean_mpg_base = mean(mpg),                 # Non-vectorized
          mpg_cumpr = fcumsum(mpg) / fsum(mpg),      # Vectorized
          mpg_cumpr_base = cumsum(mpg) / sum(mpg),   # Non-vectorized
          mpg_cumpr_mixed = fcumsum(mpg) / sum(mpg)) # Vectorized: division by overall sum

# Using across: here fmean() gets vectorized across both groups and columns (requiring a single
# call to fmean.data.frame which goes to C), whereas weighted.mean needs to be called many times.
mtcars |&gt; fgroup_by(cyl, vs, am) |&gt;
  fmutate(across(disp:qsec, list(mu = fmean, mu2 = weighted.mean), w = wt, .names = "flip"))

# Can do more complex things...
mtcars |&gt; fgroup_by(cyl) |&gt;
  fmutate(res = resid(lm(mpg ~ carb + hp, weights = wt)))

# Since v1.9.0: supports arbitrary expressions returning suitable lists
## Not run:  
mtcars |&gt; fgroup_by(cyl) |&gt;
  fmutate(broom::augment(lm(mpg ~ carb + hp, weights = wt)))

# Same thing using across() (supported before 1.9.0)
modelfun &lt;- function(data) broom::augment(lm(mpg ~ carb + hp, data, weights = wt))
mtcars |&gt; fgroup_by(cyl) |&gt;
  fmutate(across(c(mpg, carb, hp, wt), modelfun, .apply = FALSE))

## End(Not run)


## ftransform() / fcompute() examples: ----------------------------------------------

## ftransform modifies and returns a data.frame
head(ftransform(airquality, Ozone = -Ozone))
head(ftransform(airquality, new = -Ozone, Temp = (Temp-32)/1.8))
head(ftransform(airquality, new = -Ozone, new2 = 1, Temp = NULL))  # Deleting Temp
head(ftransform(airquality, Ozone = NULL, Temp = NULL))            # Deleting columns

# With collapse's grouped and weighted functions, complex operations are done on the fly
head(ftransform(airquality, # Grouped operations by month:
                Ozone_Month_median = fmedian(Ozone, Month, TRA = "fill"),
                Ozone_Month_sd = fsd(Ozone, Month, TRA = "replace"),
                Ozone_Month_centered = fwithin(Ozone, Month)))

# Grouping by month and above/below average temperature in each month
head(ftransform(airquality, Ozone_Month_high_median =
                  fmedian(Ozone, list(Month, Temp &gt; fbetween(Temp, Month)), TRA = "fill")))

## ftransformv can be used to modify multiple columns using a function
head(ftransformv(airquality, 1:3, log))
head(`[&lt;-`(airquality, 1:3, value = lapply(airquality[1:3], log))) # Same thing in base R

head(ftransformv(airquality, 1:3, log, apply = FALSE))
head(`[&lt;-`(airquality, 1:3, value = log(airquality[1:3])))         # Same thing in base R

# Using apply = FALSE yields meaningful performance gains with collapse functions
# This calls fwithin.default, and repeates the grouping by month 3 times:
head(ftransformv(airquality, 1:3, fwithin, Month))

# This calls fwithin.data.frame, and only groups one time -&gt; 5x faster!
head(ftransformv(airquality, 1:3, fwithin, Month, apply = FALSE))

# This also works for grouped and panel data frames (calling fwithin.grouped_df)
airquality |&gt; fgroup_by(Month) |&gt;
  ftransformv(1:3, fwithin, apply = FALSE) |&gt; head()

# But this gives the WRONG result (calling fwithin.default). Need option apply = FALSE!!
airquality |&gt; fgroup_by(Month) |&gt;
  ftransformv(1:3, fwithin) |&gt; head()

# For grouped modification of single columns in a grouped dataset, we can use GRP():
library(magrittr)
airquality |&gt; fgroup_by(Month) %&gt;%
  ftransform(W_Ozone = fwithin(Ozone, GRP(.)),                 # Grouped centering
             sd_Ozone_m = fsd(Ozone, GRP(.), TRA = "replace"), # In-Month standard deviation
             sd_Ozone = fsd(Ozone, TRA = "replace"),           # Overall standard deviation
             sd_Ozone2 = fsd(Ozone, TRA = "fill"),             # Same, overwriting NA's
             sd_Ozone3 = fsd(Ozone)) |&gt; head()                 # Same thing (calling alloc())

## For more complex mutations we can use ftransform with compound pipes
airquality |&gt; fgroup_by(Month) %&gt;%
  ftransform(get_vars(., 1:3) |&gt; fwithin() |&gt; flag(0:2)) |&gt; head()

airquality %&gt;% ftransform(STD(., cols = 1:3) |&gt; replace_na(0)) |&gt; head()

# The list argument feature also allows flexible operations creating multiple new columns
airquality |&gt; # The variance of Wind and Ozone, by month, weighted by temperature:
  ftransform(fvar(list(Wind_var = Wind, Ozone_var = Ozone), Month, Temp, "replace")) |&gt; head()

# Same as above using a grouped data frame (a bit more complex)
airquality |&gt; fgroup_by(Month) %&gt;%
  ftransform(fselect(., Wind, Ozone) |&gt; fvar(Temp, "replace") |&gt; add_stub("_var", FALSE)) |&gt;
  fungroup() |&gt; head()

# This performs 2 different multi-column grouped operations (need c() to make it one list)
ftransform(airquality, c(fmedian(list(Wind_Day_median = Wind,
                                      Ozone_Day_median = Ozone), Day, TRA = "replace"),
                         fsd(list(Wind_Month_sd = Wind,
                                  Ozone_Month_sd = Ozone), Month, TRA = "replace"))) |&gt; head()

## settransform(v) works like ftransform(v) but modifies a data frame in the global environment..
settransform(airquality, Ratio = Ozone / Temp, Ozone = NULL, Temp = NULL)
head(airquality)
rm(airquality)

# Grouped and weighted centering
settransformv(airquality, 1:3, fwithin, Month, Temp, apply = FALSE)
head(airquality)
rm(airquality)

# Suitably lagged first-differences
settransform(airquality, get_vars(airquality, 1:3) |&gt; fdiff() |&gt; flag(0:2))
head(airquality)
rm(airquality)

# Same as above using magrittr::`%&lt;&gt;%`
airquality %&lt;&gt;% ftransform(get_vars(., 1:3) |&gt; fdiff() |&gt; flag(0:2))
head(airquality)
rm(airquality)

# It is also possible to achieve the same thing via a replacement method (if needed)
ftransform(airquality) &lt;- get_vars(airquality, 1:3) |&gt; fdiff() |&gt; flag(0:2)
head(airquality)
rm(airquality)

## fcompute only returns the modified / computed columns
head(fcompute(airquality, Ozone = -Ozone))
head(fcompute(airquality, new = -Ozone, Temp = (Temp-32)/1.8))
head(fcompute(airquality, new = -Ozone, new2 = 1))

# Can preserve existing columns, computed ones are added to the right if names are different
head(fcompute(airquality, new = -Ozone, new2 = 1, keep = 1:3))

# If given same name as preserved columns, preserved columns are replaced in order...
head(fcompute(airquality, Ozone = -Ozone, new = 1, keep = 1:3))

# Same holds for fcomputev
head(fcomputev(iris, is.numeric, log)) # Same as:
iris |&gt; get_vars(is.numeric) |&gt; dapply(log) |&gt; head()

head(fcomputev(iris, is.numeric, log, keep = "Species"))   # Adds in front
head(fcomputev(iris, is.numeric, log, keep = names(iris))) # Preserve order

# Keep a subset of the data, add standardized columns
head(fcomputev(iris, 3:4, STD, apply = FALSE, keep = names(iris)[3:5]))
</code></pre>

<hr>
<h2 id='funique'>
Fast Unique Elements / Rows
</h2><span id='topic+funique'></span><span id='topic+funique.default'></span><span id='topic+funique.data.frame'></span><span id='topic+funique.sf'></span><span id='topic+funique.pseries'></span><span id='topic+funique.pdata.frame'></span><span id='topic+fnunique'></span><span id='topic+fduplicated'></span><span id='topic+any_duplicated'></span>

<h3>Description</h3>

<p><code>funique</code> is an efficient alternative to <code><a href="base.html#topic+unique">unique</a></code> (or <code>unique.data.table, kit::funique, dplyr::distinct</code>).
</p>
<p><code>fnunique</code> is an alternative to <code>NROW(unique(x))</code> (or <code>data.table::uniqueN, kit::uniqLen, dplyr::n_distinct</code>).
</p>
<p><code>fduplicated</code> is an alternative to <code><a href="base.html#topic+duplicated">duplicated</a></code> (or <code>duplicated.data.table</code>, <code>kit::fduplicated</code>).
</p>
<p>The <em>collapse</em> versions are versatile and highly competitive. 
</p>
<p><code>any_duplicated(x)</code> is faster than <code>any(fduplicated(x))</code>. <em>Note</em> that for atomic vectors, <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code> is currently more efficient if there are duplicates at the beginning of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funique(x, ...)

## Default S3 method:
funique(x, sort = FALSE, method = "auto", ...)

## S3 method for class 'data.frame'
funique(x, cols = NULL, sort = FALSE, method = "auto", ...)

## S3 method for class 'sf'
funique(x, cols = NULL, sort = FALSE, method = "auto", ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
funique(x, sort = FALSE, method = "auto", drop.index.levels = "id", ...)

## S3 method for class 'pdata.frame'
funique(x, cols = NULL, sort = FALSE, method = "auto", drop.index.levels = "id", ...)


fnunique(x)                  # Fast NROW(unique(x)), for vectors and lists
fduplicated(x, all = FALSE)  # Fast duplicated(x), for vectors and lists
any_duplicated(x)            # Simple logical TRUE|FALSE duplicates check
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funique_+3A_x">x</code></td>
<td>
<p>a atomic vector or data frame / list of equal-length columns. </p>
</td></tr>
<tr><td><code id="funique_+3A_sort">sort</code></td>
<td>
<p>logical. <code>TRUE</code> orders the unique elements / rows. <code>FALSE</code> returns unique values in order of first occurrence. </p>
</td></tr>
<tr><td><code id="funique_+3A_method">method</code></td>
<td>
<p>an integer or character string specifying the method of computation:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "auto"   </td><td style="text-align: left;"></td><td style="text-align: left;"> automatic selection: hash if <code>sort = FALSE</code> else radix. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "radix" </td><td style="text-align: left;"></td><td style="text-align: left;"> use radix ordering to determine unique values. Supports <code>sort = FALSE</code> but only for character data. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "hash"   </td><td style="text-align: left;"></td><td style="text-align: left;"> use index hashing to determine unique values. Supports <code>sort = TRUE</code> but only for atomic vectors (default method). </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="funique_+3A_cols">cols</code></td>
<td>
<p>compute unique rows according to a subset of columns. Columns can be selected using column names, indices, a logical vector or a selector function (e.g. <code>is.character</code>). <em>Note:</em> All columns are returned. </p>
</td></tr>
<tr><td><code id="funique_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+radixorderv">radixorderv</a></code>, e.g. <code>decreasing</code> or <code>na.last</code>. Only applicable if <code>method = "radix"</code>.</p>
</td></tr>
<tr><td><code id="funique_+3A_drop.index.levels">drop.index.levels</code></td>
<td>
<p>character. Either <code>"id"</code>, <code>"time"</code>, <code>"all"</code> or <code>"none"</code>. See <a href="#topic+indexing">indexing</a>.</p>
</td></tr>
<tr><td><code id="funique_+3A_all">all</code></td>
<td>
<p>logical. <code>TRUE</code> returns all duplicated values, including the first occurrence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If all values/rows are already unique, then <code>x</code> is returned. Otherwise a copy of <code>x</code> with duplicate rows removed is returned.  See <code><a href="#topic+group">group</a></code> for some additional computational details.
</p>
<p>The <em>sf</em> method simply ignores the geometry column when determining unique values.
</p>
<p>Methods for indexed data also subset the index accordingly.
</p>
<p><code>any_duplicated</code> is currently simply implemented as <code>fnunique(x) &lt; NROW(x)</code>, which means it does not have facilities to terminate early, and users are advised to use <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code> with atomic vectors if chances are high that there are duplicates at the beginning of the vector. With no duplicate values or data frames, <code>any_duplicated</code> is considerably faster than <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>.
</p>


<h3>Value</h3>

<p><code>funique</code> returns <code>x</code> with duplicate elements/rows removed, <code>fnunique</code> returns an integer giving the number of unique values/rows, <code>fduplicated</code> gives a logical vector with <code>TRUE</code> indicating duplicated elements/rows. 
</p>


<h3>Note</h3>

<p>These functions treat lists like data frames, unlike <code><a href="base.html#topic+unique">unique</a></code> which has a list method to determine uniqueness of (non-atomic/heterogeneous) elements in a list.
</p>
<p>No matrix method is provided. Please use the alternatives provided in package <em>kit</em> with matrices. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fndistinct">fndistinct</a></code>, <code><a href="#topic+group">group</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>funique(mtcars$cyl)
funique(gv(mtcars, c(2,8,9)))
funique(mtcars, cols = c(2,8,9))
fnunique(gv(mtcars, c(2,8,9)))
fduplicated(gv(mtcars, c(2,8,9)))
fduplicated(gv(mtcars, c(2,8,9)), all = TRUE)
any_duplicated(gv(mtcars, c(2,8,9)))
any_duplicated(mtcars)
</code></pre>

<hr>
<h2 id='fvar-fsd'>Fast (Grouped, Weighted) Variance and Standard Deviation for Matrix-Like Objects</h2><span id='topic+fvar'></span><span id='topic+fvar.default'></span><span id='topic+fvar.matrix'></span><span id='topic+fvar.data.frame'></span><span id='topic+fvar.grouped_df'></span><span id='topic+fsd'></span><span id='topic+fsd.default'></span><span id='topic+fsd.matrix'></span><span id='topic+fsd.data.frame'></span><span id='topic+fsd.grouped_df'></span>

<h3>Description</h3>

<p><code>fvar</code> and <code>fsd</code> are generic functions that compute the (column-wise) variance and standard deviation of <code>x</code>, (optionally) grouped by <code>g</code> and/or frequency-weighted by <code>w</code>. The <code><a href="#topic+TRA">TRA</a></code> argument can further be used to transform <code>x</code> using its (grouped, weighted) variance/sd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fvar(x, ...)
fsd(x, ...)

## Default S3 method:
fvar(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, stable.algo = .op[["stable.algo"]], ...)
## Default S3 method:
fsd(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
    use.g.names = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'matrix'
fvar(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, stable.algo = .op[["stable.algo"]], ...)
## S3 method for class 'matrix'
fsd(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
    use.g.names = TRUE, drop = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'data.frame'
fvar(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = TRUE, drop = TRUE, stable.algo = .op[["stable.algo"]], ...)
## S3 method for class 'data.frame'
fsd(x, g = NULL, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
    use.g.names = TRUE, drop = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'grouped_df'
fvar(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
     use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE,
     stub = .op[["stub"]], stable.algo = .op[["stable.algo"]], ...)
## S3 method for class 'grouped_df'
fsd(x, w = NULL, TRA = NULL, na.rm = .op[["na.rm"]],
    use.g.names = FALSE, keep.group_vars = TRUE, keep.w = TRUE,
    stub = .op[["stub"]], stable.algo = .op[["stable.algo"]], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fvar-fsd_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_w">w</code></td>
<td>
<p>a numeric vector of (non-negative) weights, may contain missing values.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_tra">TRA</code></td>
<td>
<p>an integer or quoted operator indicating the transformation to perform:
0 - &quot;na&quot;     |     1 - &quot;fill&quot;     |     2 - &quot;replace&quot;     |     3 - &quot;-&quot;     |     4 - &quot;-+&quot;     |     5 - &quot;/&quot;     |     6 - &quot;%&quot;     |     7 - &quot;+&quot;     |     8 - &quot;*&quot;     |     9 - &quot;%%&quot;     |     10 - &quot;-%%&quot;. See <code><a href="#topic+TRA">TRA</a></code>.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Skip missing values in <code>x</code>. Defaults to <code>TRUE</code> and implemented at very little computational cost. If <code>na.rm = FALSE</code> a <code>NA</code> is returned when encountered.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame method:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if <code>g = NULL</code> and <code>TRA = NULL</code>.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_keep.w">keep.w</code></td>
<td>
<p><em>grouped_df method:</em> Logical. Retain summed weighting variable after computation (if contained in <code>grouped_df</code>).</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_stub">stub</code></td>
<td>
<p>character. If <code>keep.w = TRUE</code> and <code>stub = TRUE</code> (default), the summed weights column is prefixed by <code>"sum."</code>. Users can specify a different prefix through this argument, or set it to <code>FALSE</code> to avoid prefixing.</p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_stable.algo">stable.algo</code></td>
<td>
<p>logical. <code>TRUE</code> (default) use Welford's numerically stable online algorithm. <code>FALSE</code> implements a faster but numerically unstable one-pass method. See Details. </p>
</td></tr>
<tr><td><code id="fvar-fsd_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods. If <code>TRA</code> is used, passing <code>set = TRUE</code> will transform data by reference and return the result invisibly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Welford's online algorithm</em> used by default to compute the variance is well described <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">here</a> (the section <em>Weighted incremental algorithm</em> also shows how the weighted variance is obtained by this algorithm).
</p>
<p>If <code>stable.algo = FALSE</code>, the variance is computed in one-pass as <code>(sum(x^2)-n*mean(x)^2)/(n-1)</code>, where <code>sum(x^2)</code> is the sum of squares from which the expected sum of squares <code>n*mean(x)^2</code> is subtracted, normalized by <code>n-1</code> (Bessel's correction). This is numerically unstable if <code>sum(x^2)</code> and <code>n*mean(x)^2</code> are large numbers very close together, which will be the case for large <code>n</code>, large <code>x</code>-values and small variances (catastrophic cancellation occurs, leading to a loss of numeric precision). Numeric precision is however still maximized through the internal use of long doubles in C++, and the fast algorithm can be up to 4-times faster compared to Welford's method.
</p>
<p>The weighted variance is computed with frequency weights as <code>(sum(x^2*w)-sum(w)*weighted.mean(x,w)^2)/(sum(w)-1)</code>. If <code>na.rm = TRUE</code>, missing values will be removed from both <code>x</code> and <code>w</code> i.e. utilizing only <code>x[complete.cases(x,w)]</code> and <code>w[complete.cases(x,w)]</code>.
</p>



<p>For further computational detail see <code><a href="#topic+fsum">fsum</a></code>.
</p>


<h3>Value</h3>

<p><code>fvar</code> returns the (<code>w</code> weighted) variance of <code>x</code>, grouped by <code>g</code>, or (if <code><a href="#topic+TRA">TRA</a></code> is used) <code>x</code> transformed by its (grouped, weighted) variance. <code>fsd</code> computes the standard deviation of <code>x</code> in like manor.
</p>


<h3>References</h3>

<p>Welford, B. P. (1962). Note on a method for calculating corrected sums of squares and products. <em>Technometrics</em>. 4 (3): 419-420. doi:10.2307/1266577.
</p>


<h3>See Also</h3>

<p><a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default vector method
fvar(mtcars$mpg)                            # Simple variance (all examples also hold for fvar!)
fsd(mtcars$mpg)                             # Simple standard deviation
fsd(mtcars$mpg, w = mtcars$hp)              # Weighted sd: Weighted by hp
fsd(mtcars$mpg, TRA = "/")                  # Simple transformation: scaling (See also ?fscale)
fsd(mtcars$mpg, mtcars$cyl)                 # Grouped sd
fsd(mtcars$mpg, mtcars$cyl, mtcars$hp)      # Grouped weighted sd
fsd(mtcars$mpg, mtcars$cyl, TRA = "/")      # Scaling by group
fsd(mtcars$mpg, mtcars$cyl, mtcars$hp, "/") # Group-scaling using weighted group sds

## data.frame method
fsd(iris)                           # This works, although 'Species' is a factor variable
fsd(mtcars, drop = FALSE)           # This works, all columns are numeric variables
fsd(iris[-5], iris[5])              # By Species: iris[5] is still a list, and thus passed to GRP()
fsd(iris[-5], iris[[5]])            # Same thing much faster: fsd recognizes 'Species' is a factor
head(fsd(iris[-5], iris[[5]], TRA = "/")) # Data scaled by species (see also fscale)

## matrix method
m &lt;- qM(mtcars)
fsd(m)
fsd(m, mtcars$cyl) # etc..

## method for grouped data frames - created with dplyr::group_by or fgroup_by
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsd()
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsd(keep.group_vars = FALSE) # Remove grouping columns
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsd(hp)      # Weighted by hp
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsd(hp, "/") # Weighted scaling transformation
</code></pre>

<hr>
<h2 id='get_elem'>Find and Extract / Subset List Elements</h2><span id='topic+atomic_elem'></span><span id='topic+atomic_elem+3C-'></span><span id='topic+list_elem'></span><span id='topic+list_elem+3C-'></span><span id='topic+reg_elem'></span><span id='topic+irreg_elem'></span><span id='topic+has_elem'></span><span id='topic+get_elem'></span>

<h3>Description</h3>

<p>A suite of functions to subset or extract from (potentially complex) lists and list-like structures. Subsetting may occur according to certain data types, using identifier functions, element names or regular expressions to search the list for certain objects.
</p>

<ul>
<li> <p><code>atomic_elem</code> and <code>list_elem</code> are non-recursive functions to extract and replace the atomic and sub-list elements at the top-level of the list tree.
</p>
</li>
<li> <p><code>reg_elem</code> is the recursive equivalent of <code>atomic_elem</code> and returns the 'regular' part of the list - with atomic elements in the final nodes. <code>irreg_elem</code> returns all the non-regular elements (i.e. call and terms objects, formulas, etc...). See Examples.
</p>
</li>
<li> <p><code>get_elem</code> returns the part of the list responding to either an identifier function, regular expression, exact element names or indices applied to all final objects. <code>has_elem</code> checks for the existence of an element and returns <code>TRUE</code> if a match is found. See Examples.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## Non-recursive (top-level) subsetting and replacing
atomic_elem(l, return = "sublist", keep.class = FALSE)
atomic_elem(l) &lt;- value
list_elem(l, return = "sublist", keep.class = FALSE)
list_elem(l) &lt;- value

## Recursive separation of regular (atomic) and irregular (non-atomic) parts
reg_elem(l, recursive = TRUE, keep.tree = FALSE, keep.class = FALSE)
irreg_elem(l, recursive = TRUE, keep.tree = FALSE, keep.class = FALSE)

## Extract elements / subset list tree
get_elem(l, elem, recursive = TRUE, DF.as.list = FALSE, keep.tree = FALSE,
         keep.class = FALSE, regex = FALSE, invert = FALSE, ...)

## Check for the existence of elements
has_elem(l, elem, recursive = TRUE, DF.as.list = FALSE, regex = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_elem_+3A_l">l</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_value">value</code></td>
<td>
<p>a list of the same length as the extracted subset of <code>l</code>.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_elem">elem</code></td>
<td>
<p>a function returning <code>TRUE</code> or <code>FALSE</code> when applied to elements of <code>l</code>, or a character vector of element names or regular expressions (if <code>regex = TRUE</code>). <code>get_elem</code> also supports a vector or indices which will be used to subset all final objects.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_return">return</code></td>
<td>
<p>an integer or string specifying what the selector function should return. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "sublist"   </td><td style="text-align: left;"></td><td style="text-align: left;"> subset of list (default) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "names" </td><td style="text-align: left;"></td><td style="text-align: left;"> column names </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "indices"   </td><td style="text-align: left;"></td><td style="text-align: left;"> column indices </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_indices"  </td><td style="text-align: left;"></td><td style="text-align: left;"> named column indices </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "logical"   </td><td style="text-align: left;"></td><td style="text-align: left;"> logical selection vector </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_logical"     </td><td style="text-align: left;"></td><td style="text-align: left;"> named logical vector </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><em>Note</em>: replacement functions only replace data, names are replaced together with the data.
</p>
</td></tr>
<tr><td><code id="get_elem_+3A_recursive">recursive</code></td>
<td>
<p>logical. Should the list search be recursive (i.e. go though all the elements), or just at the top-level?</p>
</td></tr>
<tr><td><code id="get_elem_+3A_df.as.list">DF.as.list</code></td>
<td>
<p>logical. <code>TRUE</code> treats data frames like (sub-)lists; <code>FALSE</code> like atomic elements.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_keep.tree">keep.tree</code></td>
<td>
<p>logical. <code>TRUE</code> always returns the entire list tree leading up to all matched results, while <code>FALSE</code> drops the top-level part of the tree if possible.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_keep.class">keep.class</code></td>
<td>
<p>logical. For list-based objects: should the class be retained? This only works if these objects have a <code>[</code> method that retains the class.</p>
</td></tr>
<tr><td><code id="get_elem_+3A_regex">regex</code></td>
<td>
<p>logical. Should regular expression search be used on the list names, or only exact matches?</p>
</td></tr>
<tr><td><code id="get_elem_+3A_invert">invert</code></td>
<td>
<p>logical. Invert search i.e. exclude matched elements from the list?</p>
</td></tr>
<tr><td><code id="get_elem_+3A_...">...</code></td>
<td>
<p>further arguments to <code>grep</code> (if <code>regex = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a lack of better terminology, <em>collapse</em> defines 'regular' R objects as objects that are either atomic or a list. <code>reg_elem</code> with <code>recursive = TRUE</code> extracts the subset of the list tree leading up to atomic elements in the final nodes. This part of the list tree is unlistable - calling <code>is_unlistable(reg_elem(l))</code> will be <code>TRUE</code> for all lists <code>l</code>. Conversely, all elements left behind by <code>reg_elem</code> will be picked up be <code>irreg_elem</code>. Thus <code>is_unlistable(irreg_elem(l))</code> is always <code>FALSE</code> for lists with irregular elements (otherwise <code>irreg_elem</code> returns an empty list). <br />
</p>
<p>If <code>keep.tree = TRUE</code>, <code>reg_elem</code>, <code>irreg_elem</code> and <code>get_elem</code> always return the entire list tree, but cut off all of the branches not leading to the desired result. If <code>keep.tree = FALSE</code>, top-level parts of the tree are omitted as far as possible. For example in a nested list with three levels and one data-matrix in one of the final branches, <code>get_elem(l, is.matrix, keep.tree = TRUE)</code> will return a list (<code>lres</code>) of depth 3, from which the matrix can be accessed as <code>lres[[1]][[1]][[1]]</code>. This however does not make much sense. <code>get_elem(l, is.matrix, keep.tree = FALSE)</code> will therefore figgure out that it can drop the entire tree and return just the matrix. <code>keep.tree = FALSE</code> makes additional optimizations if matching elements are at far-apart corners in a nested structure, by only preserving the hierarchy if elements are above each other on the same branch. Thus for a list <code>l &lt;- list(list(2,list("a",1)),list(1,list("b",2)))</code> calling <code>get_elem(l, is.character)</code> will just return <code>list("a","b")</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- qM(mtcars)
get_elem(list(list(list(m))), is.matrix)
get_elem(list(list(list(m))), is.matrix, keep.tree = TRUE)

l &lt;- list(list(2,list("a",1)),list(1,list("b",2)))
has_elem(l, is.logical)
has_elem(l, is.numeric)
get_elem(l, is.character)
get_elem(l, is.character, keep.tree = TRUE)

l &lt;- lm(mpg ~ cyl + vs, data = mtcars)
str(reg_elem(l))
str(irreg_elem(l))
get_elem(l, is.matrix)
get_elem(l, "residuals")
get_elem(l, "fit", regex = TRUE)
has_elem(l, "tol")
get_elem(l, "tol")

</code></pre>

<hr>
<h2 id='GGDC10S'>
Groningen Growth and Development Centre 10-Sector Database
</h2><span id='topic+GGDC10S'></span>

<h3>Description</h3>

<p>The GGDC 10-Sector Database provides a long-run internationally comparable dataset on sectoral productivity performance in Africa, Asia, and Latin America. Variables covered in the data set are annual series of value added (in local currency), and persons employed for 10 broad sectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GGDC10S")</code></pre>


<h3>Format</h3>

<p>A data frame with 5027 observations on the following 16 variables.
</p>

<dl>
<dt><code>Country</code></dt><dd><p><em>char</em>: Country (43 countries)</p>
</dd>
<dt><code>Regioncode</code></dt><dd><p><em>char</em>: ISO3 Region code</p>
</dd>
<dt><code>Region</code></dt><dd><p><em>char</em>: Region (6 World Regions)</p>
</dd>
<dt><code>Variable</code></dt><dd><p><em>char</em>: Variable (Value Added or Employment)</p>
</dd>
<dt><code>Year</code></dt><dd><p><em>num</em>: Year (67 Years, 1947-2013)</p>
</dd>
<dt><code>AGR</code></dt><dd><p><em>num</em>: Agriculture</p>
</dd>
<dt><code>MIN</code></dt><dd><p><em>num</em>: Mining</p>
</dd>
<dt><code>MAN</code></dt><dd><p><em>num</em>: Manufacturing</p>
</dd>
<dt><code>PU</code></dt><dd><p><em>num</em>: Utilities</p>
</dd>
<dt><code>CON</code></dt><dd><p><em>num</em>: Construction</p>
</dd>
<dt><code>WRT</code></dt><dd><p><em>num</em>: Trade, restaurants and hotels</p>
</dd>
<dt><code>TRA</code></dt><dd><p><em>num</em>: Transport, storage and communication</p>
</dd>
<dt><code>FIRE</code></dt><dd><p><em>num</em>: Finance, insurance, real estate and business services</p>
</dd>
<dt><code>GOV</code></dt><dd><p><em>num</em>: Government services</p>
</dd>
<dt><code>OTH</code></dt><dd><p><em>num</em>: Community, social and personal services</p>
</dd>
<dt><code>SUM</code></dt><dd><p><em>num</em>: Summation of sector GDP</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.rug.nl/ggdc/productivity/10-sector/">https://www.rug.nl/ggdc/productivity/10-sector/</a>
</p>


<h3>References</h3>

<p>Timmer, M. P., de Vries, G. J., &amp; de Vries, K. (2015). &quot;Patterns of Structural Change in Developing Countries.&quot; . In J. Weiss, &amp; M. Tribe (Eds.), <em>Routledge Handbook of Industry and Development.</em> (pp. 65-83). Routledge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlddev">wlddev</a></code>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>namlab(GGDC10S, class = TRUE)
# aperm(qsu(GGDC10S, ~ Variable, ~ Variable + Country, vlabels = TRUE))

library(ggplot2)

## World Regions Structural Change Plot

GGDC10S |&gt;
  fmutate(across(AGR:OTH, `*`, 1 / SUM),
          Variable = ifelse(Variable == "VA","Value Added Share", "Employment Share")) |&gt;
  replace_outliers(0, NA, "min") |&gt;
  collap( ~ Variable + Region + Year, cols = 6:15) |&gt; qDT() |&gt;
  pivot(1:3, names = list(variable = "Sector"), na.rm = TRUE) |&gt;

  ggplot(aes(x = Year, y = value, fill = Sector)) +
    geom_area(position = "fill", alpha = 0.9) + labs(x = NULL, y = NULL) +
    theme_linedraw(base_size = 14) +
    facet_grid(Variable ~ Region, scales = "free_x") +
    scale_fill_manual(values = sub("#00FF66", "#00CC66", rainbow(10))) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 7), expand = c(0, 0))+
    scale_y_continuous(breaks = scales::pretty_breaks(n = 10), expand = c(0, 0),
                       labels = scales::percent) +
    theme(axis.text.x = element_text(angle = 315, hjust = 0, margin = ggplot2::margin(t = 0)),
          strip.background = element_rect(colour = "grey30", fill = "grey30"))

# A function to plot the structural change of an arbitrary country

plotGGDC &lt;- function(ctry) {

  GGDC10S |&gt;
  fsubset(Country == ctry, Variable, Year, AGR:SUM) |&gt;
  fmutate(across(AGR:OTH, `*`, 1 / SUM), SUM = NULL,
          Variable = ifelse(Variable == "VA","Value Added Share", "Employment Share")) |&gt;
  replace_outliers(0, NA, "min") |&gt; qDT() |&gt;
  pivot(1:2, names = list(variable = "Sector"), na.rm = TRUE) |&gt;

  ggplot(aes(x = Year, y = value, fill = Sector)) +
    geom_area(position = "fill", alpha = 0.9) + labs(x = NULL, y = NULL) +
    theme_linedraw(base_size = 14) + facet_wrap( ~ Variable) +
    scale_fill_manual(values = sub("#00FF66", "#00CC66", rainbow(10))) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 7), expand = c(0, 0)) +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 10), expand = c(0, 0),
                       labels = scales::percent) +
    theme(axis.text.x = element_text(angle = 315, hjust = 0, margin = ggplot2::margin(t = 0)),
          strip.background = element_rect(colour = "grey20", fill = "grey20"),
          strip.text = element_text(face = "bold"))
}

plotGGDC("BWA")



</code></pre>

<hr>
<h2 id='group'>
Fast Hash-Based Grouping
</h2><span id='topic+group'></span>

<h3>Description</h3>

<p><code>group()</code> scans the rows of a data frame (or atomic vector / list of atomic vectors), assigning to each unique row an integer id - starting with 1 and proceeding in first-appearance order of the rows. The function is written in C and optimized for R's data structures. It is the workhorse behind functions like <code><a href="#topic+GRP">GRP</a></code> / <code><a href="#topic+fgroup_by">fgroup_by</a></code>, <code><a href="#topic+collap">collap</a></code>, <code><a href="#topic+qF">qF</a></code>, <code><a href="#topic+qG">qG</a></code>, <code><a href="#topic+finteraction">finteraction</a></code> and <code><a href="#topic+funique">funique</a></code>, when called with argument <code>sort = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(x, starts = FALSE, group.sizes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_+3A_x">x</code></td>
<td>
<p>an atomic vector or data frame / list of equal-length atomic vectors.
</p>
</td></tr>
<tr><td><code id="group_+3A_starts">starts</code></td>
<td>
<p>logical. If <code>TRUE</code>, an additional attribute <code>"starts"</code> is attached giving a vector of group starts (= index of first-occurrence of unique rows).
</p>
</td></tr>
<tr><td><code id="group_+3A_group.sizes">group.sizes</code></td>
<td>

<p>logical. If <code>TRUE</code>, an additional attribute <code>"group.sizes"</code> is attached giving the size of each group.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data frame is grouped on a column-by-column basis, starting from the leftmost column. For each new column the grouping vector obtained after the previous column is also fed back into the hash function so that unique values are determined on a running basis. The algorithm terminates as soon as the number of unique rows reaches the size of the data frame. Missing values are also grouped just like any other values. Invoking arguments <code>starts</code> and/or <code>group.sizes</code> requires an additional pass through the final grouping vector.
</p>


<h3>Value</h3>

<p>An object is of class 'qG' see <code><a href="#topic+qG">qG</a></code>.
</p>


<h3>Author(s)</h3>

<p>The Hash Function and inspiration was taken from the excellent <em>kit</em> package by Morgan Jacob, the algorithm was developed by Sebastian Krantz.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GRPid">GRPid</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's replicate what funique does
g &lt;- group(wlddev, starts = TRUE)
if(attr(g, "N.groups") == fnrow(wlddev)) wlddev else
   ss(wlddev, attr(g, "starts"))

</code></pre>

<hr>
<h2 id='groupid'>
Generate Run-Length Type Group-Id
</h2><span id='topic+groupid'></span>

<h3>Description</h3>

<p><code>groupid</code> is an enhanced version of <code>data.table::rleid</code> for atomic vectors. It generates a run-length type group-id where consecutive identical values are assigned the same integer. It is a generalization as it can be applied to unordered vectors, generate group id's starting from an arbitrary value, and skip missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupid(x, o = NULL, start = 1L, na.skip = FALSE, check.o = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupid_+3A_x">x</code></td>
<td>
<p>an atomic vector of any type. Attributes are not considered.</p>
</td></tr>
<tr><td><code id="groupid_+3A_o">o</code></td>
<td>
<p>an (optional) integer ordering vector specifying the order by which to pass through <code>x</code>.</p>
</td></tr>
<tr><td><code id="groupid_+3A_start">start</code></td>
<td>
<p>integer. The starting value of the resulting group-id. Default is starting from 1.</p>
</td></tr> 
<tr><td><code id="groupid_+3A_na.skip">na.skip</code></td>
<td>
<p>logical. Skip missing values i.e. if <code>TRUE</code> something like <code>groupid(c("a", NA, "a"))</code> gives <code>c(1, NA, 1)</code> whereas <code>FALSE</code> gives <code>c(1, 2, 3)</code>.</p>
</td></tr>
<tr><td><code id="groupid_+3A_check.o">check.o</code></td>
<td>
<p>logical. Programmers option: <code>FALSE</code> prevents checking that each element of <code>o</code> is in the range <code>[1, length(x)]</code>, it only checks the length of <code>o</code>. This gives some extra speed, but will terminate R if any element of <code>o</code> is too large or too small. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of class 'qG'. See <code><a href="#topic+qG">qG</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqid">seqid</a></code>, <code><a href="#topic+timeid">timeid</a></code>, <code><a href="#topic+qG">qG</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>groupid(airquality$Month)
groupid(airquality$Month, start = 0)
groupid(wlddev$country)[1:100]

## Same thing since country is alphabetically ordered: (groupid is faster..)
all.equal(groupid(wlddev$country), qG(wlddev$country, na.exclude = FALSE))

## When data is unordered, group-id can be generated through an ordering..
uo &lt;- order(rnorm(fnrow(airquality)))
monthuo &lt;- airquality$Month[uo]
o &lt;- order(monthuo)
groupid(monthuo, o)
identical(groupid(monthuo, o)[o], unattrib(groupid(airquality$Month)))
</code></pre>

<hr>
<h2 id='GRP'>Fast Grouping / <em>collapse</em> Grouping Objects</h2><span id='topic+GRP'></span><span id='topic+GRP.GRP'></span><span id='topic+GRP.default'></span><span id='topic+GRP.factor'></span><span id='topic+GRP.qG'></span><span id='topic+GRP.pseries'></span><span id='topic+GRP.pdata.frame'></span><span id='topic+GRP.grouped_df'></span><span id='topic+fgroup_by'></span><span id='topic+gby'></span><span id='topic+fgroup_vars'></span><span id='topic+fungroup'></span><span id='topic+gsplit'></span><span id='topic+greorder'></span><span id='topic+is_GRP'></span><span id='topic+length.GRP'></span><span id='topic+print.GRP'></span><span id='topic+plot.GRP'></span><span id='topic+GRPnames'></span><span id='topic+GRPid'></span><span id='topic+GRPN'></span><span id='topic+as_factor_GRP'></span>

<h3>Description</h3>

<p><code>GRP</code> performs fast, ordered and unordered, groupings of vectors and data frames (or lists of vectors) using <code><a href="#topic+radixorderv">radixorderv</a></code> or <code><a href="#topic+group">group</a></code>. The output is a list-like object of class 'GRP' which can be printed, plotted and used as an efficient input to all of <em>collapse</em>'s fast statistical and transformation functions and operators (see macros <code>.FAST_FUN</code> and <code>.OPERATOR_FUN</code>), as well as to <code><a href="#topic+collap">collap</a></code>, <code><a href="#topic+BY">BY</a></code> and <code><a href="#topic+TRA">TRA</a></code>.
</p>
<p><code>fgroup_by</code> is similar to <code>dplyr::group_by</code> but faster and class-agnostic. It creates a grouped data frame with a 'GRP' object attached - for fast dplyr-like programming with <em>collapse</em>'s fast functions.
</p>
<p>There are also several conversion methods to and from 'GRP' objects. Notable among these is <code>GRP.grouped_df</code>, which returns a 'GRP' object from a grouped data frame created with <code>dplyr::group_by</code> or <code>fgroup_by</code>, and the duo <code>GRP.factor</code> and <code>as_factor_GRP</code>.
</p>
<p><code>gsplit</code> efficiently splits a vector based on a 'GRP' object, and <code>greorder</code> helps to recombine the results. These are the workhorses behind functions like <code><a href="#topic+BY">BY</a></code>, and <code><a href="#topic+collap">collap</a></code>, <code><a href="#topic+fsummarise">fsummarise</a></code> and <code><a href="#topic+fmutate">fmutate</a></code> when evaluated with base R and user-defined functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRP(X, ...)

## Default S3 method:
GRP(X, by = NULL, sort = .op[["sort"]], decreasing = FALSE, na.last = TRUE,
    return.groups = TRUE, return.order = sort, method = "auto",
    call = TRUE, ...)

## S3 method for class 'factor'
GRP(X, ..., group.sizes = TRUE, drop = FALSE, return.groups = TRUE,
    call = TRUE)

## S3 method for class 'qG'
GRP(X, ..., group.sizes = TRUE, return.groups = TRUE, call = TRUE)

## S3 method for class 'pseries'
GRP(X, effect = 1L, ..., group.sizes = TRUE, return.groups = TRUE,
    call = TRUE)

## S3 method for class 'pdata.frame'
GRP(X, effect = 1L, ..., group.sizes = TRUE, return.groups = TRUE,
    call = TRUE)

## S3 method for class 'grouped_df'
GRP(X, ..., return.groups = TRUE, call = TRUE)

# Identify 'GRP' objects
is_GRP(x)

## S3 method for class 'GRP'
length(x)                          # Length of data being grouped
GRPN(x, expand = TRUE, ...)        # Group sizes (default: expanded to match data length)
GRPid(x, sort = FALSE, ...)        # Group id (data length, same as GRP(.)$group.id)
GRPnames(x, force.char = TRUE, sep = ".")  # Group names

as_factor_GRP(x, ordered = FALSE, sep = ".") # 'GRP'-object to (ordered) factor conversion

# Efficiently split a vector using a 'GRP' object
gsplit(x, g, use.g.names = FALSE, ...)

# Efficiently reorder y = unlist(gsplit(x, g)) such that identical(greorder(y, g), x)
greorder(x, g, ...)

# Fast, class-agnostic pendant to dplyr::group_by for use with fast functions, see details
fgroup_by(.X, ..., sort = .op[["sort"]], decreasing = FALSE, na.last = TRUE,
          return.groups = TRUE, return.order = sort, method = "auto")
# Shorthand for fgroup_by
      gby(.X, ..., sort = .op[["sort"]], decreasing = FALSE, na.last = TRUE,
          return.groups = TRUE, return.order = sort, method = "auto")

# Get grouping columns from a grouped data frame created with dplyr::group_by or fgroup_by
fgroup_vars(X, return = "data")

# Ungroup grouped data frame created with dplyr::group_by or fgroup_by
fungroup(X, ...)

## S3 method for class 'GRP'
print(x, n = 6, ...)

## S3 method for class 'GRP'
plot(x, breaks = "auto", type = "l", horizontal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRP_+3A_x">X</code></td>
<td>
<p>a vector, list of columns or data frame (default method), or a suitable object (conversion / extractor methods).</p>
</td></tr>
<tr><td><code id="GRP_+3A_.x">.X</code></td>
<td>
<p>a data frame or list.</p>
</td></tr>
<tr><td><code id="GRP_+3A_x">x</code>, <code id="GRP_+3A_g">g</code></td>
<td>
<p>a 'GRP' object. For <code>gsplit/greorder</code>, <code>x</code> can be a vector of any type, or <code>NULL</code> to return the integer indices of the groups. <code>gsplit/greorder/GRPN/GRPid</code> also support vectors or data frames to be passed to <code>g/x</code>.</p>
</td></tr>
<tr><td><code id="GRP_+3A_by">by</code></td>
<td>
<p>if <code>X</code> is a data frame or list, <code>by</code> can indicate columns to use for the grouping (by default all columns are used). Columns must be passed using a vector of column names, indices, or using a one-sided formula i.e. <code>~ col1 + col2</code>.</p>
</td></tr>
<tr><td><code id="GRP_+3A_sort">sort</code></td>
<td>
<p>logical. If <code>FALSE</code>, groups are not ordered but simply grouped in the order of first appearance of unique elements / rows. This often provides a performance gain if the data was not sorted beforehand. See also <code>method</code>.</p>
</td></tr>
<tr><td><code id="GRP_+3A_ordered">ordered</code></td>
<td>
<p>logical. <code>TRUE</code> adds a class 'ordered' i.e. generates an ordered factor.</p>
</td></tr>
<tr><td><code id="GRP_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or decreasing? Can be a vector of length equal to the number of arguments in <code>X</code> / <code>by</code> (argument passed to <code><a href="#topic+radixorderv">radixorderv</a></code>).</p>
</td></tr>
<tr><td><code id="GRP_+3A_na.last">na.last</code></td>
<td>
<p>logical. If missing values are encountered in grouping vector/columns, assign them to the last group (argument passed to <code><a href="#topic+radixorderv">radixorderv</a></code>).</p>
</td></tr>
<tr><td><code id="GRP_+3A_return.groups">return.groups</code></td>
<td>
<p>logical. Include the unique groups in the created GRP object.</p>
</td></tr>
<tr><td><code id="GRP_+3A_return.order">return.order</code></td>
<td>
<p>logical. If <code>sort = TRUE</code>, include the output from <code><a href="#topic+radixorderv">radixorderv</a></code> in the created GRP object. This brings performance improvements in <code>gsplit</code> (and thus also benefits grouped execution of base R functions). </p>
</td></tr>
<tr><td><code id="GRP_+3A_method">method</code></td>
<td>
<p>character. The algorithm to use for grouping: either <code>"radix"</code>, <code>"hash"</code> or <code>"auto"</code>. <code>"auto"</code> will chose <code>"radix"</code> when <code>sort = TRUE</code>, yielding ordered grouping via <code><a href="#topic+radixorderv">radixorderv</a></code>, and <code>"hash"</code>-based grouping in first-appearance order via <code><a href="#topic+group">group</a></code> otherwise. It is possibly to put <code>method = "radix"</code> and <code>sort = FALSE</code>, which will group character data in first appearance order but sort numeric data (a good hybrid option). <code>method = "hash"</code> currently does not support any sorting, thus putting <code>sort = TRUE</code> will simply be ignored.</p>
</td></tr>
<tr><td><code id="GRP_+3A_group.sizes">group.sizes</code></td>
<td>
<p>logical. <code>TRUE</code> tabulates factor levels using <code><a href="base.html#topic+tabulate">tabulate</a></code> to create a vector of group sizes; <code>FALSE</code> leaves that slot empty when converting from factors.</p>
</td></tr>
<tr><td><code id="GRP_+3A_drop">drop</code></td>
<td>
<p>logical. <code>TRUE</code> efficiently drops unused factor levels beforehand using <code><a href="#topic+fdroplevels">fdroplevels</a></code>.</p>
</td></tr>
<tr><td><code id="GRP_+3A_call">call</code></td>
<td>
<p>logical. <code>TRUE</code> calls <code><a href="base.html#topic+match.call">match.call</a></code> and saves it in the final slot of the GRP object.</p>
</td></tr>
<tr><td><code id="GRP_+3A_expand">expand</code></td>
<td>
<p>logical. <code>TRUE</code> returns a vector the same length as the data. <code>FALSE</code> returns the group sizes (computed in first-appearance-order of groups if <code>x</code> is not already a 'GRP' object). </p>
</td></tr>
<tr><td><code id="GRP_+3A_force.char">force.char</code></td>
<td>
<p>logical. Always output group names as character vector, even if a single numeric vector was passed to <code>GRP.default</code>.</p>
</td></tr>
<tr><td><code id="GRP_+3A_sep">sep</code></td>
<td>
<p>character. The separator passed to <code><a href="base.html#topic+paste">paste</a></code> when creating group names from multiple grouping variables by pasting them together.</p>
</td></tr>
<tr><td><code id="GRP_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> / indexed data methods: Select which panel identifier should be used as grouping variable. 1L takes the first variable in the <a href="#topic+findex">index</a>, 2L the second etc., identifiers can also be passed as a character string. More than one variable can be supplied. </p>
</td></tr>
<tr><td><code id="GRP_+3A_return">return</code></td>
<td>
<p>an integer or string specifying what <code>fgroup_vars</code> should return. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "data"   </td><td style="text-align: left;"></td><td style="text-align: left;"> full grouping columns (default) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "unique"   </td><td style="text-align: left;"></td><td style="text-align: left;"> unique rows of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "names" </td><td style="text-align: left;"></td><td style="text-align: left;"> names of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "indices"   </td><td style="text-align: left;"></td><td style="text-align: left;"> integer indices of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_indices"  </td><td style="text-align: left;"></td><td style="text-align: left;"> named integer indices of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "logical"   </td><td style="text-align: left;"></td><td style="text-align: left;"> logical selection vector of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
                 7 </td><td style="text-align: left;"></td><td style="text-align: left;"> "named_logical"     </td><td style="text-align: left;"></td><td style="text-align: left;"> named logical selection vector of grouping columns </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td>
</tr>

</table>

</td></tr>
<tr><td><code id="GRP_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. <code>TRUE</code> returns a named list, like <code><a href="base.html#topic+split">split</a></code>. <code>FALSE</code> is slightly more efficient. </p>
</td></tr>

<tr><td><code id="GRP_+3A_n">n</code></td>
<td>
<p>integer. Number of groups to print out.</p>
</td></tr>
<tr><td><code id="GRP_+3A_breaks">breaks</code></td>
<td>
<p>integer. Number of breaks in the histogram of group-sizes.</p>
</td></tr>
<tr><td><code id="GRP_+3A_type">type</code></td>
<td>
<p>linetype for plot.</p>
</td></tr>
<tr><td><code id="GRP_+3A_horizontal">horizontal</code></td>
<td>
<p>logical. <code>TRUE</code> arranges plots next to each other, instead of above each other. <em>Note</em> that the size of each group is only plotted for objects with less than 10,000 groups.</p>
</td></tr>
<tr><td><code id="GRP_+3A_...">...</code></td>
<td>
<p>for <code>fgroup_by</code>: unquoted comma-separated column names, sequences of columns, expressions involving columns, and column names, indices, logical vectors or selector functions. See Examples. For <code>gsplit</code>, <code>greorder</code>, <code>GRPN</code> and <code>GRPid</code>: further arguments passed to <code>GRP</code> (if <code>g/x</code> is not already a 'GRP' object). For example the <code>by</code> argument could be used if a data frame is passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GRP</code> is a central function in the <em>collapse</em> package because it provides, in the form of integer vectors, some key pieces of information to efficiently perform grouped operations at the <code>C/C++</code> level.
</p>
<p>Most statistical function require information about (1) the number of groups (2) an integer group-id indicating which values / rows belong to which group and (3) information about the size of each group. Provided with these, <em>collapse</em>'s <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> pre-allocate intermediate and result vectors of the right sizes and (in most cases) perform grouped statistical computations in a single pass through the data.
</p>
<p>The sorting functionality of <code>GRP.default</code> lets groups receive different integer-id's depending on whether the groups are sorted <code>sort = TRUE</code> (<code>FALSE</code> gives first-appearance order), and in which order (argument <code>decreasing</code>). This affects the order of values/rows in the output whenever an aggregation is performed. 
</p>

<p>Other elements in the object provide information about whether the data was sorted by the variables defining the grouping (6) and the ordering vector (7). These also feed into optimizations in <code>gsplit/greorder</code> that benefit the execution of base R functions across groups.
</p>
<p>Complimentary to <code>GRP</code>, the function <code>fgroup_by</code> is a significantly faster and class-agnostic alternative to <code>dplyr::group_by</code> for programming with <em>collapse</em>. It creates a grouped data frame with a 'GRP' object attached in a <code>"groups"</code> attribute. This data frame has classes 'GRP_df', ..., 'grouped_df' and 'data.frame', where ... stands for any other classes the input frame inherits such as 'data.table', 'sf', 'tbl_df', 'indexed_frame' etc.. <em>collapse</em> functions with a 'grouped_df' method respond to 'grouped_df' objects created with either <code>fgroup_by</code> or <code>dplyr::group_by</code>. The method <code>GRP.grouped_df</code> takes the <code>"groups"</code> attribute from a 'grouped_df' and converts it to a 'GRP' object if created with <code>dplyr::group_by</code>. 
</p>
<p>The 'GRP_df' class in front responds to <code>print.GRP_df</code> which first calls <code>print(fungroup(x), ...)</code> and prints one line below the object indicating the grouping variables, followed, in square brackets, by some statistics on the group sizes: <code>[N | Mean (SD) Min-Max]</code>. The mean is rounded to a full number and the standard deviation (SD) to one digit. Minimum and maximum are only displayed if the SD is non-zero. There also exist a method <code>[.GRP_df</code> which calls <code><a href="base.html#topic+NextMethod">NextMethod</a></code> but makes sure that the grouping information is preserved or dropped depending on the dimensions of the result (subsetting rows or aggregation with <em>data.table</em> drops the grouping object).
</p>


<p><code>GRP.default</code> supports vector and list input and will also return 'GRP' objects if passed. There is also a hidden method <code>GRP.GRP</code> which simply returns grouping objects (no re-grouping functionality is offered).
</p>
<p>Apart from <code>GRP.grouped_df</code> there are several further conversion methods:
</p>
<p>The conversion of factors to 'GRP' objects by <code>GRP.factor</code> involves obtaining the number of groups calling <code>ng &lt;- fnlevels(f)</code> and then computing the count of each level using <code><a href="base.html#topic+tabulate">tabulate(f, ng)</a></code>. The integer group-id (2) is already given by the factor itself after removing the levels and class attributes and replacing any missing values with <code>ng + 1L</code>. The levels are put in a list and moved to position (4) in the 'GRP' object, which is reserved for the unique groups. Finally, a sortedness check <code>!is.unsorted(id)</code> is run on the group-id to check if the data represented by the factor was sorted (6). <code>GRP.qG</code> works similarly (see also <code><a href="#topic+qG">qG</a></code>), and the 'pseries' and 'pdata.frame' methods simply group one or more factors in the <a href="#topic+indexing">index</a> (selected using the <code>effect</code> argument) .
</p>
<p>Creating a factor from a 'GRP' object using <code>as_factor_GRP</code> does not involve any computations, but may involve interacting multiple grouping columns using the <code>paste</code> function to produce unique factor levels. 
</p>



<h3>Value</h3>

<p>A list-like object of class &lsquo;GRP&rsquo; containing information about the number of groups, the observations (rows) belonging to each group, the size of each group, the unique group names / definitions, whether the groups are ordered and data grouped is sorted or not, the ordering vector used to perform the ordering and the group start positions. The object is structured as follows:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> List-index </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Element-name </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Content type </em> </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Content description</em> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[1]] </td><td style="text-align: left;"></td><td style="text-align: left;"> N.groups   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>integer(1)</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Number of Groups </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[2]] </td><td style="text-align: left;"></td><td style="text-align: left;"> group.id </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>integer(NROW(X))</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> An integer group-identifier </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[3]] </td><td style="text-align: left;"></td><td style="text-align: left;"> group.sizes    </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>integer(N.groups)</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Vector of group sizes </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[4]] </td><td style="text-align: left;"></td><td style="text-align: left;"> groups    </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>unique(X)</code> or <code>NULL</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Unique groups (same format as input, except for <code>fgroup_by</code> which uses a plain list, sorted if <code>sort = TRUE</code>), or <code>NULL</code> if <code>return.groups = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[5]] </td><td style="text-align: left;"></td><td style="text-align: left;"> group.vars   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> The names of the grouping variables </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 [[6]] </td><td style="text-align: left;"></td><td style="text-align: left;"> ordered   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>logical(2)</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>[1]</code> Whether the groups are ordered: equal to the <code>sort</code> argument in the default method, or <code>TRUE</code> if converted objects inherit a class <code>"ordered"</code> and <code>NA</code> otherwise, <code>[2]</code> Whether the data (<code>X</code>) is already sorted: the result of <code>!is.unsorted(group.id)</code>. If <code>sort = FALSE</code> (default method) the second entry is <code>NA</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[7]] </td><td style="text-align: left;"></td><td style="text-align: left;"> order     </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>integer(NROW(X))</code> or <code>NULL</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Ordering vector from <code>radixorderv</code> (with <code>"starts"</code> attribute), or <code>NULL</code> if <code>return.order = FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 [[8]] </td><td style="text-align: left;"></td><td style="text-align: left;"> group.starts </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>integer(N.groups)</code> or <code>NULL</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> The first-occurrence positions/rows of the groups. Useful e.g. with <code>ffirst(x, g, na.rm = FALSE)</code>. <code>NULL</code> if <code>return.groups = FALSE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

                 [[9]] </td><td style="text-align: left;"></td><td style="text-align: left;"> call </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>match.call()</code> or <code>NULL</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> The <code>GRP()</code> call, obtained from <code>match.call()</code>, or <code>NULL</code> if <code>call = FALSE</code>
                 </td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+radixorder">radixorder</a></code>, <code><a href="#topic+group">group</a></code>, <code><a href="#topic+qF">qF</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default method
GRP(mtcars$cyl)
GRP(mtcars, ~ cyl + vs + am)       # Or GRP(mtcars, c("cyl","vs","am")) or GRP(mtcars, c(2,8:9))
g &lt;- GRP(mtcars, ~ cyl + vs + am)  # Saving the object
print(g)                           # Printing it
plot(g)                            # Plotting it
GRPnames(g)                        # Retain group names
GRPid(g)                           # Retain group id (same as g$group.id), useful inside fmutate()
fsum(mtcars, g)                    # Compute the sum of mtcars, grouped by variables cyl, vs and am
gsplit(mtcars$mpg, g)              # Use the object to split a vector
gsplit(NULL, g)                    # The indices of the groups
identical(mtcars$mpg,              # greorder and unlist undo the effect of gsplit
          greorder(unlist(gsplit(mtcars$mpg, g)), g))

## Convert factor to GRP object and vice-versa
GRP(iris$Species)
as_factor_GRP(g)
 
## dplyr integration
library(dplyr)
mtcars |&gt; group_by(cyl,vs,am) |&gt; GRP()    # Get GRP object from a dplyr grouped tibble
mtcars |&gt; group_by(cyl,vs,am) |&gt; fmean()  # Grouped mean using dplyr grouping
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmean() # Faster alternative with collapse grouping

mtcars |&gt; fgroup_by(cyl,vs,am)            # Print method for grouped data frame

## Adding a column of group sizes.
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fsummarise(Sizes = GRPN())
# Note: can also set_collapse(mask = "n") to use n() instead, see help("collapse-options")
# Other usage modes:
mtcars |&gt; fgroup_by(cyl,vs,am) |&gt; fmutate(Sizes = GRPN())
mtcars |&gt; fmutate(Sizes = GRPN(list(cyl,vs,am)))  # Same thing, slightly more efficient

## Various options for programming and interactive use
fgroup_by(GGDC10S, Variable, Decade = floor(Year / 10) * 10) |&gt; head(3)
fgroup_by(GGDC10S, 1:3, 5) |&gt; head(3)
fgroup_by(GGDC10S, c("Variable", "Country")) |&gt; head(3)
fgroup_by(GGDC10S, is.character) |&gt; head(3)
fgroup_by(GGDC10S, Country:Variable, Year) |&gt; head(3)
fgroup_by(GGDC10S, Country:Region, Var = Variable, Year) |&gt; head(3)

## Note that you can create a grouped data frame without materializing the unique grouping columns
fgroup_by(GGDC10S, Variable, Country, return.groups = FALSE) |&gt; fmutate(across(AGR:SUM, fscale))
fgroup_by(GGDC10S, Variable, Country, return.groups = FALSE) |&gt; fselect(AGR:SUM) |&gt; fmean()

## Note also that setting sort = FALSE on unsorted data can be much faster... if not required...
library(microbenchmark)
microbenchmark(gby(GGDC10S, Variable, Country), gby(GGDC10S, Variable, Country, sort = FALSE))

</code></pre>

<hr>
<h2 id='indexing'>
Fast Indexed Time Series and Panels
</h2><span id='topic+indexing'></span><span id='topic+findex_by'></span><span id='topic+iby'></span><span id='topic+findex'></span><span id='topic+ix'></span><span id='topic+unindex'></span><span id='topic+reindex'></span><span id='topic+is_irregular'></span><span id='topic+to_plm'></span><span id='topic++5B.indexed_series'></span><span id='topic++5B.indexed_frame'></span><span id='topic++24.indexed_frame'></span><span id='topic++5B+5B.indexed_frame'></span><span id='topic++5B.index_df'></span><span id='topic+print.index_df'></span><span id='topic++5B+3C-.indexed_frame'></span><span id='topic++24+3C-.indexed_frame'></span><span id='topic++5B+5B+3C-.indexed_frame'></span>

<h3>Description</h3>

<p>A fast and flexible indexed time series and panel data class that inherits from <em>plm</em>'s 'pseries' and 'pdata.frame', but is more rigorous, natively handles irregularity, can be superimposed on any data.frame/list, matrix or vector, and supports ad-hoc computations inside data masking functions and model formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Create an 'indexed_frame' containing 'indexed_series'
findex_by(.X, ..., single = "auto", interact.ids = TRUE)
iby(.X, ..., single = "auto", interact.ids = TRUE)  # Shorthand

## Retrieve the index ('index_df') from an 'indexed_frame' or 'indexed_series'
findex(x)
ix(x)     # Shorthand

## Remove index from 'indexed_frame' or 'indexed_series' (i.e. get .X back)
unindex(x)

## Reindex 'indexed_frame' or 'indexed_series' (or index vectors / matrices)
reindex(x, index = findex(x), single = "auto")

## Check if 'indexed_frame', 'indexed_series', index or time vector is irregular
is_irregular(x, any_id = TRUE)

## Convert 'indexed_frame'/'indexed_series' to normal 'pdata.frame'/'pseries'
to_plm(x, row.names = FALSE)

# Subsetting &amp; replacement methods: [(&lt;-) methods call NextMethod().
# Also methods for fsubset, funique and roworder(v), na_omit (internal).

## S3 method for class 'indexed_series'
x[i, ..., drop.index.levels = "id"]

## S3 method for class 'indexed_frame'
x[i, ..., drop.index.levels = "id"]

## S3 replacement method for class 'indexed_frame'
x[i, j] &lt;- value

## S3 method for class 'indexed_frame'
x$name

## S3 replacement method for class 'indexed_frame'
x$name &lt;- value

## S3 method for class 'indexed_frame'
x[[i, ...]]

## S3 replacement method for class 'indexed_frame'
x[[i]] &lt;- value

# Index subsetting and printing: optimized using ss()

## S3 method for class 'index_df'
x[i, j, drop = FALSE, drop.index.levels = "id"]

## S3 method for class 'index_df'
print(x, topn = 5, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexing_+3A_.x">.X</code></td>
<td>
<p>a data frame or list-like object of equal-length columns.</p>
</td></tr>
<tr><td><code id="indexing_+3A_x">x</code></td>
<td>
<p>an 'indexed_frame' or 'indexed_series'. <code>findex</code> also works with 'pseries' and 'pdata.frame's created with <em>plm</em>. For <code>is_irregular</code> <code>x</code> can also be an index (inherits 'pindex') or a vector representing time. </p>
</td></tr>
<tr><td><code id="indexing_+3A_...">...</code></td>
<td>
<p>for <code>findex_by</code>: variables identifying the individual (id) and/or time dimensions of the data. Passed either as unquoted comma-separated column names or (tagged) expressions involving columns, or as a vector of column names, indices, a logical vector or a selector function. The time variable must enter last. See Examples. Otherwise: further arguments passed to <code><a href="base.html#topic+NextMethod">NextMethod()</a></code>.</p>
</td></tr>
<tr><td><code id="indexing_+3A_single">single</code></td>
<td>
<p>character. If only one indexing variable is supplied, this can be declared as <code>"id"</code> or <code>"time"</code> variable. <code>"auto"</code> chooses <code>"id"</code> if the variable has <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code> values.  </p>
</td></tr>
<tr><td><code id="indexing_+3A_interact.ids">interact.ids</code></td>
<td>
<p>logical. If <code>n &gt; 2</code> indexing variables are passed, <code>TRUE</code> calls <code><a href="#topic+finteraction">finteraction</a></code> on the first <code>n-1</code> of them (<code>n</code>'th variable must be time). <code>FALSE</code> keeps all variables in the index. The latter slows down computations of lags / differences etc. because ad-hoc interactions need to be computed, but gives more flexibility for scaling / centering / summarising over different data dimensions.  </p>
</td></tr>
<tr><td><code id="indexing_+3A_index">index</code></td>
<td>
<p>and index (inherits 'pindex'), or an atomic vector or list of factors matching the data dimensions. Atomic vectors or lists with 1 factor will must be declared, see <code>single</code>. Atomic vectors will additionally be grouped / turned into time-factors. See Details. </p>
</td></tr>
<tr><td><code id="indexing_+3A_drop.index.levels">drop.index.levels</code></td>
<td>
<p>character. Subset methods also subset the index (= a data.frame of factors), and this argument regulates which factor levels should be dropped: either <code>"all"</code>, <code>"id"</code>, <code>"time"</code> or <code>"none"</code>. The default <code>"id"</code> only drops levels from id's. <code>"all"</code> or <code>"time"</code> should be used with caution because time-factors may contain levels for missing time periods (gaps in irregular sequences, or periods within a sequence removed through subsetting), and dropping those levels would create a variable that is ordinal but no longer represents time. The benefit of dropping levels is that it can speed-up subsequent computations by reducing the size of intermediate vectors created in C++.   </p>
</td></tr>
<tr><td><code id="indexing_+3A_any_id">any_id</code></td>
<td>
<p>logical. For panel series: <code>FALSE</code> returns the irregularity check performed for each id, <code>TRUE</code> calls <code><a href="base.html#topic+any">any</a></code> on those checks.</p>
</td></tr>
<tr><td><code id="indexing_+3A_row.names">row.names</code></td>
<td>
<p>logical. <code>TRUE</code> creates descriptive row-names (or names for pseries) as in <code>plm</code>. This can be expensive and is usually not required for <code>plm</code> models to work.</p>
</td></tr>
<tr><td><code id="indexing_+3A_topn">topn</code></td>
<td>
<p>integer. The number of first and last rows to print.</p>
</td></tr>
<tr><td><code id="indexing_+3A_i">i</code>, <code id="indexing_+3A_j">j</code>, <code id="indexing_+3A_name">name</code>, <code id="indexing_+3A_drop">drop</code>, <code id="indexing_+3A_value">value</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+NextMethod">NextMethod</a></code>, or as in the <a href="base.html#topic++5B.data.frame">data.frame methods</a>. Note that for index subsetting to work, <code>i</code> needs to be integer or logical (or an expression evaluation to integer or logical if <code>x</code> is a <em>data.table</em>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first thing to note about these new 'indexed_frame', 'indexed_series' and 'index_df' classes is that they inherit <em>plm</em>'s 'pdata.frame', 'pseries' and 'pindex' classes, respectively. They add, improve, and, in some cases, remove functionality offered by <em>plm</em>, with the aim of striking an optimal balance of flexibility and performance. The inheritance means that all 'pseries' and 'pdata.frame' methods in <em>collapse</em>, and also some methods in <em>plm</em>, apply to them. Where compatibility or performance considerations allow for it, <em>collapse</em> will continue to create methods for <em>plm</em>'s classes instead of the new classes.
</p>
<p>The use of these classes does not require much knowledge of <em>plm</em>, but as a basic background: A 'pdata.frame' is a data.frame with an index attribute: a data.frame of 2 factors identifying the individual and time-dimension of the data. When pulling a variable out of the pdata.frame using a method like <code>$.pdata.frame</code> or <code>[[.pdata.frame</code> (defined in <em>plm</em>), a 'pseries' is created by transferring the index attribute to the vector. Methods defined for functions like <code><a href="stats.html#topic+lag">lag</a></code> / <code><a href="#topic+flag">flag</a></code> etc. use the index for correct computations on this panel data, also inside <em>plm</em>'s estimation commands.
</p>
<p><b>Main Features and Enhancements</b>
</p>
<p>The 'indexed_frame' and 'indexed_series' classes extend and enhance 'pdata.frame' and 'pseries' in a number of critical dimensions. Most notably they:
</p>

<ul>
<li><p> Support <b>both time series and panel data</b>, by allowing indexation of data with one, two or more variables.
</p>
</li>
<li><p> Are <b>class-agnostic</b>: any data.frame/list (such as data.table, tibble, tsibble, sf etc.) can become an 'indexed_frame' and continue to function as usual for most use cases. Similarly, any vector or matrix (such as ts, mts, xts) can become an 'indexed_series'. This also allows for transient workflows e.g. <code>some_df |&gt; findex_by(...) |&gt; 'do something using collapse functions' |&gt; unindex() |&gt; 'continue working with some_df'</code>.
</p>
</li>
<li><p> Have a comprehensive and efficient set of <b>methods for subsetting and manipulation</b>, including methods for <code><a href="#topic+fsubset">fsubset</a></code>, <code><a href="#topic+funique">funique</a></code>, <code><a href="#topic+roworder">roworder(v)</a></code> (internal) and <code><a href="#topic+na_omit">na_omit</a></code> (internal, <code><a href="stats.html#topic+na.omit">na.omit</a></code> also works but is slower). It is also possible to group indexed data with <code><a href="#topic+fgroup_by">fgroup_by</a></code> for transformations e.g. using <code><a href="#topic+fmutate">fmutate</a></code>, but aggregation requires <code>unindex()</code>ing.
</p>
</li>
<li> <p><b>Natively handle irregularity</b>: time objects (such as 'Date', 'POSIXct' etc.) are passed to <code><a href="#topic+timeid">timeid</a></code>, which efficiently determines the temporal structure by finding the greatest common divisor (GCD), and creates a time-factor with levels corresponding to a complete time-sequence. The latter is also done with plain numeric vectors, which are assumed to represent unit time steps (GDC = 1) and coerced to integer (but can also be passed through <code><a href="#topic+timeid">timeid</a></code> if non-unitary). Character time variables are converted to factor, which might also capture irregular gaps in panel series. Using this time-factor in the index, <em>collapse</em>'s functions efficiently perform correct computations on irregular sequences and panels without the need to 'expand' the data / fill gaps. <code>is_irregular</code> can be used to check for irregularity in the entire sequence / panel or separately for each individual in panel data.
</p>
</li>
<li><p> Support computations inside <b>data-masking functions and formulas</b>, by virtue of &quot;<b>deep indexation</b>&quot;: Each variable inside an 'indexed_frame' is an 'indexed_series' which contains in its 'index_df' attribute an external pointer to the 'index_df' attribute of the frame. Functions operating on 'indexed_series' stored inside the frame (such as <code>with(data, flag(column))</code>) can fetch the index from this pointer. This allows worry-free application inside arbitrary data masking environments (<code>with</code>, <code>%$%</code>, <code>attach</code>, etc..) and estimation commands (<code>glm</code>, <code>feols</code>, <code>lmrob</code> etc..) without duplication of the index in memory. A limitation is that external pointers are only valid during the present R session, thus when saving an 'indexed_frame' and loading it again, you need to call <code>data = reindex(data)</code> before computing on it.
</p>
</li></ul>

<p>Indexed series also have simple <a href="base.html#topic+Math">Math</a> and <a href="base.html#topic+Ops">Ops</a> methods, which apply the operation to the unindexed series and shallow copy the attributes of the original object to the result, unless the result it is a logical vector (from operations like <code>!</code>, <code>==</code> etc.). For <a href="base.html#topic+Ops">Ops</a> methods, if the LHS object is an 'indexed_series' its attributes are taken, otherwise the attributes of the RHS object are taken.
</p>
<p><b>Limits to plm Compatibility</b>
</p>
<p>In contrast to 'pseries' and 'pdata.frame's, 'indexed_series' and 'indexed_frames' do not have descriptive &quot;names&quot; or &quot;row.names&quot; attributes attached to them, mainly for efficiency reasons.
</p>
<p>Furthermore, the index is stored in an attribute named 'index_df' (same as the class name), not 'index' as in <em>plm</em>, mainly to make these classes work with <em>data.table</em>, <em>tsibble</em> and <em>xts</em>, which also utilize 'index' attributes. This for the most part poses no problem to plm compatibility because plm source code fetches the index using <code>attr(x, "index")</code>, and <code><a href="base.html#topic+attr">attr</a></code> by default performs partial matching. 
</p>
<p>A much greater obstacle in working with <em>plm</em> is that some internal <em>plm</em> code is hinged on there being no <code>[.pseries</code> method, and the existence of <code>[.indexed_series</code> limits the use of these classes in most <em>plm</em> estimation commands. Therefore the <code>to_plm</code> function is provided to efficiently coerce the classes to ordinary plm objects before estimation. See Examples.
</p>
<p>Overall these classes don't really benefit <em>plm</em>, especially given that collapse's plm methods also support native plm objects. However, they work very well inside other models and software, including <em>stats</em> models, <em>fixest</em> / <em>lfe</em>, and a whole bunch of time series and ML models. See Examples.
</p>
<p><b>Performance Considerations</b>
</p>
<p>When indexing long time-series or panels with a single variable, setting <code>single = "id" or "time"</code> avoids a potentially expensive call to <code><a href="base.html#topic+anyDuplicated">anyDuplicated</a></code>. Note also that when panel-data are regular and sorted, omitting the time variable in the index can bring &gt;= 2x performance improvements in operations like lagging and differencing (alternatively use <code>shift = "row"</code> argument to <code><a href="#topic+flag">flag</a></code>, <code><a href="#topic+fdiff">fdiff</a></code> etc.) .
</p>
<p>When dealing with long Date or POSIXct time sequences, it may also be that the internal processing by <code><a href="#topic+timeid">timeid</a></code> is slow simply because calling <code><a href="base.html#topic+strftime">strftime</a></code> on these sequences to create factor levels is slow. In this case you may choose to generate an index factor with integer levels by passing <code>timeid(t)</code> to <code>findex_by</code> or <code>reindex</code> (which by default generates a 'qG' object which is internally converted to factor using <code>as_factor_qG</code>. The lazy evaluation of expressions like <code>as.character(seq_len(nlev))</code> in modern R makes this extremely efficient).
</p>
<p>With multiple id variables e.g. <code>findex_by(data, id1, id2, id3, time)</code>, the default call to <code>finteraction()</code> can be expensive because of pasting the levels together. In this case, users may gain performance by manually invoking <code>finteraction()</code> (or its shorthand <code>itn()</code>) with argument <code>factor = FALSE</code> e.g. <code>findex_by(data, ids = itn(id1, id2, id3, factor = FALSE), time)</code>. This will generate a factor with integer levels instead.
</p>
<p><b>Print Method</b>
</p>
<p>The print methods for 'indexed_frame' and 'indexed_series' first call <code>print(unindex(x), ...)</code>, followed by the index variables with the number of categories (index factor levels) in square brackets. If the time factor contains unused levels (= irregularity in the sequence), the square brackets indicate the number of used levels (periods), followed by the total number of levels (periods in the sequence) in parentheses.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeid">timeid</a></code>,
<a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>oldopts &lt;- options(max.print = 70)
# Indexing panel data ----------------------------------------------------------

wldi &lt;- findex_by(wlddev, iso3c, year)
wldi
wldi[1:100,1]                 # Works like a data frame
POP &lt;- wldi$POP               # indexed_series
qsu(POP)                      # Summary statistics
G(POP)                        # Population growth
STD(G(POP, c(1, 10)))         # Within-standardized 1 and 10-year growth rates
psmat(POP)                    # Panel-Series Matrix
plot(psmat(log10(POP)))

POP[30:5000]                  # Subsetting indexed_series
Dlog(POP[30:5000])            # Log-difference of subset
psacf(identity(POP[30:5000])) # ACF of subset
L(Dlog(POP[30:5000], c(1, 10)), -1:1) # Multiple computations on subset

# Fast Statistical Functions don't have dedicated methods
# Thus for aggregation we need to unindex beforehand ...
fmean(unindex(POP))
wldi |&gt; unindex() |&gt;
  fgroup_by(iso3c) |&gt; num_vars() |&gt; fmean()

library(magrittr)
# ... or unindex after taking group identifiers from the index
fmean(unindex(fgrowth(POP)), ix(POP)$iso3c)
wldi |&gt; num_vars() %&gt;%
  fgroup_by(iso3c = ix(.)$iso3c) |&gt;
  unindex() |&gt; fmean()

# With matrix methods it is easier as most attributes are dropped upon aggregation.
G(POP, c(1, 10)) %&gt;% fmean(ix(.)$iso3c)

# Example of index with multiple ids
GGDC10S |&gt; findex_by(Variable, Country, Year) |&gt; head() # default is interact.ids = TRUE
GGDCi &lt;- GGDC10S |&gt; findex_by(Variable, Country, Year, interact.ids = FALSE)
head(GGDCi)
findex(GGDCi)
# The benefit is increased flexibility for summary statistics and data transformation
qsu(GGDCi, effect = "Country")
STD(GGDCi$SUM, effect = "Variable")            # Standardizing by variable
STD(GGDCi$SUM, effect = c("Variable", "Year")) # ... by variable and year
# But time-based operations are a bit more expensive because of the necessary interactions
D(GGDCi$SUM)

# Panel-Data modelling ---------------------------------------------------------

# Linear model of 5-year annualized growth rates of GDP on Life Expactancy + 5y lag
lm(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), wldi) # p abbreviates "power"

# Same, adding time fixed effects via plm package: need to utilize to_plm function
plm::plm(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), to_plm(wldi), effect = "time")

# With country and time fixed effects via fixest
fixest::feols(G(PCGDP, 5, p=1/5) ~ L(G(LIFEEX, 5, p=1/5), c(0, 5)), wldi, fixef = .c(iso3c, year))
## Not run:  
# Running a robust MM regression without fixed effects
robustbase::lmrob(G(PCGDP, 5, p = 1/5) ~ L(G(LIFEEX, 5, p = 1/5), c(0, 5)), wldi)

# Running a robust MM regression with country and time fixed effects
wldi |&gt; fselect(PCGDP, LIFEEX) |&gt;
  fgrowth(5, power = 1/5) |&gt; ftransform(LIFEEX_L5 = L(LIFEEX, 5)) |&gt;
  # drop abbreviates drop.index.levels (not strictly needed here but more consistent)
  na_omit(drop = "all") |&gt; fhdwithin(na.rm = FALSE) |&gt; # For TFE use fwithin(effect = "year")
  unindex() |&gt; robustbase::lmrob(formula = PCGDP ~.)    # using lm() gives same result as fixest

# Using a random forest model without fixed effects
# ranger does not support these kinds of formulas, thus we need some preprocessing...
wldi |&gt; fselect(PCGDP, LIFEEX) |&gt;
  fgrowth(5, power = 1/5) |&gt; ftransform(LIFEEX_L5 = L(LIFEEX, 5)) |&gt;
  unindex() |&gt; na_omit() |&gt; ranger::ranger(formula = PCGDP ~.)

## End(Not run)

# Indexing other data frame based classes --------------------------------------

library(tibble)
wlditbl &lt;- qTBL(wlddev) |&gt; findex_by(iso3c, year)
wlditbl[,2] # Works like a tibble...
wlditbl[[2]]
wlditbl[1:1000, 10]
head(wlditbl)

library(data.table)
wldidt &lt;- qDT(wlddev) |&gt; findex_by(iso3c, year)
wldidt[1:1000]      # Works like a data.table...
wldidt[year &gt; 2000]
wldidt[, .(sum_PCGDP = sum(PCGDP, na.rm = TRUE)), by = country] # Aggregation unindexes the result
wldidt[, lapply(.SD, sum, na.rm = TRUE), by = country, .SDcols = .c(PCGDP, LIFEEX)]
# This also works but is a bit inefficient since the index is subset and then dropped
# -&gt; better unindex beforehand
wldidt[year &gt; 2000, .(sum_PCGDP = sum(PCGDP, na.rm = TRUE)), by = country]
wldidt[, PCGDP_gr_5Y := G(PCGDP, 5, power = 1/5)]  # Can add Variables by reference
# Note that .SD is a data.table of indexed_series, not an indexed_frame, so this is WRONG!
wldidt[, .c(PCGDP_gr_5Y, LIFEEX_gr_5Y) := G(slt(.SD, PCGDP, LIFEEX), 5, power = 1/5)]
# This gives the correct outcome
wldidt[, .c(PCGDP_gr_5Y, LIFEEX_gr_5Y) := lapply(slt(.SD, PCGDP, LIFEEX), G, 5, power = 1/5)]

## Not run: 
library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
nci &lt;- findex_by(nc, SID74)
nci[1:10, "AREA"]
st_centroid(nci) # The geometry column is never indexed, thus sf computations work normally
st_coordinates(nci)
fmean(st_area(nci))

library(tsibble)
pedi &lt;- findex_by(pedestrian, Sensor, Date_Time)
pedi[1:5, ]
findex(pedi) # Time factor with 17k levels from POSIXct
# Now here is a case where integer levels in the index can really speed things up
ix(iby(pedestrian, Sensor, timeid(Date_Time)))
library(microbenchmark)
microbenchmark(descriptive_levels = findex_by(pedestrian, Sensor, Date_Time),
               integer_levels = findex_by(pedestrian, Sensor, timeid(Date_Time)))
# Data has irregularity
is_irregular(pedi)
is_irregular(pedi, any_id = FALSE) # irregularity in all sequences
# Manipulation such as lagging with tsibble/dplyr requires expanding rows and grouping
# Collapse can just compute correct lag on indexed series or frames
library(dplyr)
microbenchmark(
  dplyr = fill_gaps(pedestrian) |&gt; group_by_key() |&gt; mutate(Lag_Count = lag(Count)),
  collapse = fmutate(pedi, Lag_Count = flag(Count)), times = 10)

## End(Not run)
# Indexing Atomic objects ---------------------------------------------------------

## ts
print(AirPassengers)
AirPassengers[-(20:30)]        # Ts class does not support irregularity, subsetting drops class
G(AirPassengers[-(20:30)], 12) # Annual Growth Rate: Wrong!
# Now indexing AirPassengers (identity() is a trick so that the index is named time(AirPassengers))
iAP &lt;- reindex(AirPassengers, identity(time(AirPassengers)))
iAP
findex(iAP)    # See the index
iAP[-(20:30)]  # Subsetting
G(iAP[-(20:30)], 12)                # Annual Growth Rate: Correct!
L(G(iAP[-(20:30)], c(0,1,12)), 0:1) # Lagged level, period and annual growth rates...
 
## xts
library(xts)
library(zoo) # Needed for as.yearmon() and index() functions
X &lt;- wlddev |&gt; fsubset(iso3c == "DEU", date, PCGDP:POP) %&gt;% {
  xts(num_vars(.), order.by = as.yearmon(.$date))
  } |&gt; ss(-(30:40)) %&gt;% reindex(identity(index(.))) # Introducing a gap
# plot(G(unindex(X)))
diff(unindex(X))    # diff.xts gixes wrong result
fdiff(X)            # fdiff gives right result

# But xts range-based subsets do not work...
## Not run: 
X["1980/"]

## End(Not run)
# Thus a better way is not to index and perform ad-hoc omputations on the xts index
X &lt;- unindex(X)
X["1980/"] %&gt;% fdiff(t = index(.)) # xts index is internally processed by timeid()

## Of course you can also index plain vectors / matrices...
options(oldopts)
</code></pre>

<hr>
<h2 id='is_unlistable'>
Unlistable Lists
</h2><span id='topic+is_unlistable'></span>

<h3>Description</h3>

<p>A (nested) list with atomic objects in all final nodes of the list-tree is unlistable - checked with <code>is_unlistable</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_unlistable(l, DF.as.list = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="is_unlistable_+3A_l">l</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="is_unlistable_+3A_df.as.list">DF.as.list</code></td>
<td>
<p>logical. <code>TRUE</code> treats data frames like (sub-)lists; <code>FALSE</code> like atomic elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_unlistable</code> with <code>DF.as.list = TRUE</code> is defined as <code>all(rapply(l, is.atomic))</code>, whereas <code>DF.as.list = FALSE</code> yields checking using <code>all(unlist(rapply2d(l, function(x) is.atomic(x) || is.list(x)), use.names = FALSE))</code>, assuming that data frames are lists composed of atomic elements.  If <code>l</code> contains data frames, the latter can be a lot faster than applying <code>is.atomic</code> to every data frame column.
</p>


<h3>Value</h3>

<p><code>logical(1)</code> - <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ldepth">ldepth</a></code>, <code><a href="#topic+has_elem">has_elem</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(1, 2, list(3, 4, "b", FALSE))
is_unlistable(l)
l &lt;- list(1, 2, list(3, 4, "b", FALSE, e ~ b))
is_unlistable(l)

</code></pre>

<hr>
<h2 id='join'>Fast Table Joins</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Join two data frame like objects <code>x</code> and <code>y</code> <code>on</code> columns. Inspired by <em>polars</em> and by default uses a vectorized hash join algorithm (workhorse function <code><a href="#topic+fmatch">fmatch</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(x, y,
     on = NULL,
     how = "left",
     suffix = NULL,
     validate = "m:m",
     multiple = FALSE,
     sort = FALSE,
     keep.col.order = TRUE,
     drop.dup.cols = FALSE,
     verbose = .op[["verbose"]],
     column = NULL,
     attr = NULL,
     ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_x">x</code></td>
<td>
<p>a data frame-like object. The result will inherit the attributes of this object. </p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>a data frame-like object to join with <code>x</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_on">on</code></td>
<td>
<p>character. vector of columns to join on. <code>NULL</code> uses <code>union(names(x), names(y))</code>. Use a named vector to match columns named differently in <code>x</code> and <code>y</code>, e.g. <code>c("x_id" = "y_id")</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_how">how</code></td>
<td>
<p>character. Join type: <code>"left"</code>, <code>"right"</code>, <code>"inner"</code>, <code>"full"</code>, <code>"semi"</code> or <code>"anti"</code>. The first letter suffices. </p>
</td></tr>
<tr><td><code id="join_+3A_suffix">suffix</code></td>
<td>
<p>character(1 or 2). Suffix to add to duplicate column names. <code>NULL</code> renames duplicate <code>y</code> columns as <code>paste(col, y_name, sep = "_")</code>, where <code>y_name = as.character(substitute(y))</code> i.e. the name of the data frame as passed into the function. In general, passing <code>suffix</code> length 1 will only rename <code>y</code>, whereas a length 2 suffix will rename both <code>x</code> and <code>y</code>, respectively. If <code>verbose &gt; 0</code> a message will be printed. </p>
</td></tr>
<tr><td><code id="join_+3A_validate">validate</code></td>
<td>
<p>character. (Optional) check if join is of specified type. One of <code>"1:1"</code>, <code>"1:m"</code>, <code>"m:1"</code> or <code>"m:m"</code>. The default <code>"m:m"</code> does not perform any checks. Checks are done before the actual join step and failure results in an error. <em>Note</em> that this argument does not affect the result, it only triggers a check.</p>
</td></tr>
<tr><td><code id="join_+3A_multiple">multiple</code></td>
<td>
<p>logical. Handling of rows in <code>x</code> with multiple matches in <code>y</code>. The default <code>FALSE</code> takes the first match in <code>y</code>. <code>TRUE</code> returns every match in <code>y</code>, increasing the size of the joined table.</p>
</td></tr>
<tr><td><code id="join_+3A_sort">sort</code></td>
<td>
<p>logical. <code>TRUE</code> implements a sort-merge-join: a completely separate join algorithm that sorts both datasets on the join columns using <code><a href="#topic+radixorder">radixorder</a></code> and then matches the rows without hashing. <em>Note</em> that in this case the result will be sorted by the join columns, whereas <code>sort = FALSE</code> preserves the order of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_keep.col.order">keep.col.order</code></td>
<td>
<p>logical. Keep order of columns in <code>x</code>? <code>FALSE</code> places the <code>on</code> columns in front.</p>
</td></tr>
<tr><td><code id="join_+3A_drop.dup.cols">drop.dup.cols</code></td>
<td>
<p>instead of renaming duplicate columns in <code>x</code> and <code>y</code> using <code>suffix</code>, this option simply drops them: <code>TRUE</code> or <code>"y"</code> drops them from <code>y</code>, <code>"x"</code> from <code>x</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_verbose">verbose</code></td>
<td>
<p>integer. Prints information about the join. One of 0 (off), 1 (default) or 2 (additionally prints the classes of the <code>on</code> columns). <em>Note:</em> <code>verbose &gt; 0</code> or <code>validate != "m:m"</code> invoke the <code>count</code> argument to <code><a href="#topic+fmatch">fmatch</a></code>, so <code>verbose = 0</code> is slightly more efficient.</p>
</td></tr>
<tr><td><code id="join_+3A_column">column</code></td>
<td>
<p>(optional) name for an extra column to generate in the output indicating which dataset a record came from. <code>TRUE</code> calls this column <code>".join"</code> (inspired by STATA's '_merge' column). By default this column is generated as the last column, but, if <code>keep.col.order = FALSE</code>, it is placed after the 'on' columns. The column is a factor variable with levels corresponding to the dataset names (inferred from the input) or <code>"matched"</code> for matched records. Alternatively, it is possible to specify a list of 2, where the first element is the column name, and the second a length 3 (!) vector of levels e.g. <code>column = list("joined", c("x", "y", "x_y"))</code>, where <code>"x_y"</code> replaces <code>"matched"</code>. The column has an additional attribute <code>"on.cols"</code> giving the join columns corresponding to the factor levels. See Examples. </p>
</td></tr>
<tr><td><code id="join_+3A_attr">attr</code></td>
<td>
<p>(optional) name for attribute providing information about the join performed (including the output of <code><a href="#topic+fmatch">fmatch</a></code>) to the result. <code>TRUE</code> calls this attribute <code>"join.match"</code>.</p>
</td></tr>
<tr><td><code id="join_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+fmatch">fmatch</a></code> (if <code>sort = FALSE</code>). Notably, <code>overid</code> can bet set to 0 or 2 (default 1) to control the matching process if the join condition more than identifies the records.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame-like object of the same type and attributes as <code>x</code>. <code>"row.names"</code> of <code>x</code> are only preserved in left-join operations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmatch">fmatch</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  id1 = c(1, 1, 2, 3),
  id2 = c("a", "b", "b", "c"),
  name = c("John", "Jane", "Bob", "Carl"),
  age = c(35, 28, 42, 50)
)
df2 &lt;- data.frame(
  id1 = c(1, 2, 3, 3),
  id2 = c("a", "b", "c", "e"),
  salary = c(60000, 55000, 70000, 80000),
  dept = c("IT", "Marketing", "Sales", "IT")
)

# Different types of joins
for(i in c("l","i","r","f","s","a"))
    join(df1, df2, how = i) |&gt; print()

# Adding join column: useful esp. for full join
join(df1, df2, how = "f", column = TRUE)
# Custom column + rearranging
join(df1, df2, how = "f", column = list("join", c("x", "y", "x_y")), keep = FALSE)

# Attaching match attribute
str(join(df1, df2, attr = TRUE))

</code></pre>

<hr>
<h2 id='ldepth'>
Determine the Depth / Level of Nesting of a List
</h2><span id='topic+ldepth'></span>

<h3>Description</h3>

<p><code>ldepth</code> provides the depth of a list or list-like structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldepth(l, DF.as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldepth_+3A_l">l</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="ldepth_+3A_df.as.list">DF.as.list</code></td>
<td>
<p>logical. <code>TRUE</code> treats data frames like (sub-)lists; <code>FALSE</code> like atomic elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The depth or level or nesting of a list or list-like structure (e.g. a model object) is found by recursing down to the bottom of the list and adding an integer count of 1 for each level passed. For example the depth of a data frame is 1. If a data frame has list-columns, the depth is 2. However for reasons of efficiency, if <code>l</code> is not a data frame and <code>DF.as.list = FALSE</code>, data frames found inside <code>l</code> will not be checked for list column's but assumed to have a depth of 1.
</p>


<h3>Value</h3>

<p>A single integer indicating the depth of the list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_unlistable">is_unlistable</a></code>, <code><a href="#topic+has_elem">has_elem</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(1, 2)
ldepth(l)
l &lt;- list(1, 2, mtcars)
ldepth(l)
ldepth(l, DF.as.list = FALSE)
l &lt;- list(1, 2, list(4, 5, list(6, mtcars)))
ldepth(l)
ldepth(l, DF.as.list = FALSE)
</code></pre>

<hr>
<h2 id='list-processing'>List Processing</h2><span id='topic+A8-list-processing'></span><span id='topic+list-processing'></span>

<h3>Description</h3>

<p><em>collapse</em> provides the following set of functions to efficiently work with lists of R objects:
</p>

<ul>
<li> <p><b>Search and Identification</b></p>

<ul>
<li> <p><code><a href="#topic+is_unlistable">is_unlistable</a></code> checks whether a (nested) list is composed of atomic objects in all final nodes, and thus unlistable to an atomic vector using <code><a href="base.html#topic+unlist">unlist</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+ldepth">ldepth</a></code> determines the level of nesting of the list (i.e. the maximum number of nodes of the list-tree).
</p>
</li>
<li> <p><code><a href="#topic+has_elem">has_elem</a></code> searches elements in a list using element names, regular expressions applied to element names, or a function applied to the elements, and returns <code>TRUE</code> if any matches were found.
</p>
</li></ul>

</li>
<li> <p><b>Subsetting</b> </p>

<ul>
<li> <p><code><a href="#topic+atomic_elem">atomic_elem</a></code> examines the top-level of a list and returns a sublist with the atomic elements. Conversely <code><a href="#topic+list_elem">list_elem</a></code> returns the sublist of elements which are themselves lists or list-like objects.
</p>
</li>
<li> <p><code><a href="#topic+reg_elem">reg_elem</a></code> and <code><a href="#topic+irreg_elem">irreg_elem</a></code> are recursive versions of the former. <code><a href="#topic+reg_elem">reg_elem</a></code> extracts the 'regular' part of the list-tree leading to atomic elements in the final nodes, while <code><a href="#topic+irreg_elem">irreg_elem</a></code> extracts the 'irregular' part of the list tree leading to non-atomic elements in the final nodes. (<em>Tip</em>: try calling both on an <code>lm</code> object). Naturally for all lists <code>l</code>, <code>is_unlistable(reg_elem(l))</code> evaluates to <code>TRUE</code>.
</p>
</li>
<li> <p><code><a href="#topic+get_elem">get_elem</a></code> extracts elements from a list using element names, regular expressions applied to element names, a function applied to the elements, or element-indices used to subset the lowest-level sub-lists. by default the result is presented as a simplified list containing all matching elements. With the <code>keep.tree</code> option however <code><a href="#topic+get_elem">get_elem</a></code> can also be used to subset lists i.e. maintain the full tree but cut off non-matching branches.
</p>
</li></ul>

</li>
<li> <p><b>Splitting and Transposition</b> </p>

<ul>
<li> <p><code><a href="#topic+rsplit">rsplit</a></code> recursively splits a vector or data frame into subsets according to combinations of (multiple) vectors / factors - by default returning a (nested) list. If <code>flatten = TRUE</code>, the list is flattened yielding the same result as <code><a href="base.html#topic+split">split</a></code>. <code>rsplit</code> is also faster than <code><a href="base.html#topic+split">split</a></code>, particularly for data frames.
</p>
</li>
<li> <p><code><a href="#topic+t_list">t_list</a></code> efficiently transposes nested lists of lists, such as those obtained from splitting a data frame by multiple variables using <code><a href="#topic+rsplit">rsplit</a></code>.
</p>
</li></ul>

</li>
<li> <p><b>Apply Functions</b> </p>

<ul>
<li> <p><code><a href="#topic+rapply2d">rapply2d</a></code> is a recursive version of <code><a href="base.html#topic+lapply">lapply</a></code> with two key differences to <code><a href="base.html#topic+rapply">rapply</a></code> to apply a function to nested lists of data frames or other list-based objects.
</p>
</li></ul>

</li>
<li> <p><b>Unlisting / Row-Binding</b> </p>

<ul>
<li> <p><code><a href="#topic+unlist2d">unlist2d</a></code> efficiently unlists unlistable lists in 2-dimensions and creates a data frame (or <em>data.table</em>) representation of the list. This is done by recursively flattening and row-binding R objects in the list while creating identifier columns for each level of the list-tree and (optionally) saving the row-names of the objects in a separate column. <code><a href="#topic+unlist2d">unlist2d</a></code> can thus also be understood as a recursive generalization of <code>do.call(rbind, l)</code>, for lists of vectors, data frames, arrays or heterogeneous objects. A simpler version for non-recursive row-binding lists of lists / data.frames, is also available by <code><a href="#topic+rowbind">rowbind</a></code>.
</p>
</li></ul>

</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> Function </em>  </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  
  <code><a href="#topic+is_unlistable">is_unlistable</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Checks if list is unlistable </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ldepth">ldepth</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Level of nesting / maximum depth of list-tree </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+has_elem">has_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Checks if list contains a certain element </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+get_elem">get_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Subset list / extract certain elements </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+atomic_elem">atomic_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Top-level subset atomic elements </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+list_elem">list_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Top-level subset list/list-like elements </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+reg_elem">reg_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Recursive version of <code>atomic_elem</code>: Subset / extract 'regular' part of list </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+irreg_elem">irreg_elem</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Subset / extract non-regular part of list </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rsplit">rsplit</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Recursively split vectors or data frames / lists </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+t_list">t_list</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Transpose lists of lists </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rapply2d">rapply2d</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Recursively apply functions to lists of data objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+unlist2d">unlist2d</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Recursively unlist/row-bind lists of data objects in 2D, to data frame or <em>data.table</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rowbind">rowbind</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Non-recursive binding of lists of lists / data.frames. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>
</p>

<hr>
<h2 id='pad'>
Pad Matrix-Like Objects with a Value
</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>The <code>pad</code> function inserts elements / rows filled with <code>value</code> into a vector matrix or data frame <code>X</code> at positions given by <code>i</code>. It is particularly useful to expand objects returned by statistical procedures which remove missing values to the original data dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(X, i, value = NA, method = c("auto", "xpos", "vpos"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">X</code></td>
<td>

<p>a vector, matrix, data frame or list of equal-length columns.
</p>
</td></tr>
<tr><td><code id="pad_+3A_i">i</code></td>
<td>

<p>either an integer (positive or negative) or logical vector giving positions / rows of <code>X</code> into which <code>value</code>'s should be inserted, or, alternatively, a positive integer vector with <code>length(i) == NROW(X)</code>, but with some gaps in the indices into which <code>value</code>'s can be inserted, or a logical vector with <code>sum(i) == NROW(X)</code> such that <code>value</code>'s can be inserted for <code>FALSE</code> values in the logical vector. See also <code>method</code> and Examples.
</p>
</td></tr>
<tr><td><code id="pad_+3A_value">value</code></td>
<td>

<p>a scalar value to be replicated and inserted into <code>X</code> at positions / rows given by <code>i</code>. Default is <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="pad_+3A_method">method</code></td>
<td>

<p>an integer or string specifying the use of <code>i</code>. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "auto" </td><td style="text-align: left;"></td><td style="text-align: left;"> automatic method selection: If <code>i</code> is positive integer and <code>length(i) == NROW(X)</code> or if <code>i</code> is logical and <code>sum(i) == NROW(X)</code>, choose method "xpos", else choose "vpos". </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "xpos"   </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>i</code> is a vector of positive integers or a logical vector giving the positions of the the elements / rows of <code>X</code>. <code>values</code>'s are inserted where there are gaps / <code>FALSE</code> values in <code>i</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "vpos" </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>i</code> is a vector of positive / negative integers or a logical vector giving the positions at which <code>values</code>'s / rows should be inserted into <code>X</code>.
  </td>
</tr>

</table>

</td></tr>
</table>


<h3>Value</h3>

<p><code>X</code> with elements / rows filled with <code>value</code> inserted at positions given by <code>i</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+append">append</a></code>, <a href="#topic+recode-replace">Recode and Replace Values</a>, <a href="#topic+small-helpers">Small (Helper) Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- 1:3

pad(v, 1:2)       # Automatic selection of method "vpos"
pad(v, -(1:2))    # Same thing
pad(v, c(TRUE, TRUE, FALSE, FALSE, FALSE)) # Same thing

pad(v, c(1, 3:4)) # Automatic selection of method "xpos"
pad(v, c(TRUE, FALSE, TRUE, TRUE, FALSE))  # Same thing

head(pad(wlddev, 1:3)) # Insert 3 missing rows at the beginning of the data
head(pad(wlddev, 2:4)) # ... at rows positions 2-4

# pad() is mostly useful for statistical models which only use the complete cases:
mod &lt;- lm(LIFEEX ~ PCGDP, wlddev)
# Generating a residual column in the original data (automatic selection of method "vpos")
settfm(wlddev, resid = pad(resid(mod), mod$na.action))
# Another way to do it:
r &lt;- resid(mod)
i &lt;- as.integer(names(r))
resid2 &lt;- pad(r, i)        # automatic selection of method "xpos"
# here we need to add some elements as flast(i) &lt; nrow(wlddev)
resid2 &lt;- c(resid2, rep(NA, nrow(wlddev)-length(resid2)))
# See that these are identical:
identical(unattrib(wlddev$resid), resid2)

# Can also easily get a model matrix at the dimensions of the original data
mm &lt;- pad(model.matrix(mod), mod$na.action)

</code></pre>

<hr>
<h2 id='pivot'>
Fast and Easy Data Reshaping
</h2><span id='topic+pivot'></span>

<h3>Description</h3>

<p><code>pivot()</code> is <em>collapse</em>'s data reshaping command. It combines longer-, wider-, and recast-pivoting functionality in a single parsimonious API. Notably, it can also accommodate variable labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot(data,               # Summary of Documentation:
      ids = NULL,         # identifier cols to preserve
      values = NULL,      # cols containing the data
      names = NULL,       # name(s) of new col(s) | col(s) containing names
      labels = NULL,      # name of new labels col | col(s) containing labels
      how = "longer",     # method: "longer"/"l", "wider"/"w" or "recast"/"r"
      na.rm = FALSE,      # remove rows missing 'values' in reshaped data
      factor = c("names", "labels"), # create new id col(s) as factor variable(s)?
      check.dups = FALSE, # detect duplicate 'ids'+'names' combinations

      # Only apply if how = "wider" or "recast"
      nthreads = .op[["nthreads"]], # minor gains as grouping remains serial
      fill = NULL,        # value to insert for unbalanced data (default NA/NULL)
      drop = TRUE,        # drop unused levels (=columns) if 'names' is factor
      sort = FALSE,       # "ids": sort 'ids' and/or "names": alphabetic casting

      # Only applies if how = "wider" with multiple long columns ('values')
      transpose = FALSE   # "columns": applies t_list() before flattening, and/or
)                         # "names": sets names nami_colj. default: colj_nami
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_+3A_data">data</code></td>
<td>
<p>data frame-like object (list of equal-length columns).</p>
</td></tr>
<tr><td><code id="pivot_+3A_ids">ids</code></td>
<td>
<p>identifier columns to keep. Specified using column names, indices, a logical vector or an identifier function e.g. <code><a href="#topic+is_categorical">is_categorical</a></code>.</p>
</td></tr>
<tr><td><code id="pivot_+3A_values">values</code></td>
<td>
<p>columns containing the data to be reshaped. Specified like <code>ids</code>.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_names">names</code></td>
<td>
<p>names of columns to generate, or retrieve variable names from:
</p>

<table>
<tr>
 <td style="text-align: left;"><code> how </code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code>"longer"</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> list of names for the variable and value column in the long format, respectively. If <code>NULL</code>, <code>list("variable", "value")</code> will be chosen. Alternatively, a named list length 1 or 2 can be provided using "variable"/"value" as keys e.g. <code>list(value = "data_col")</code>.   </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code> "wider"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> column(s) containing names of the new variables. Specified using a vector of column names, indices, a logical vector or selector function e.g. <code>is.character</code>. Multiple columns will be combined using <code><a href="#topic+finteraction">finteraction</a></code> with <code>"_"</code> as separator.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code> "recast"</code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> (named) list with the following elements: [[1]]/[["from"]] - column(s) containing names of the new variables, specified as in <code>"wider"</code>; [[2]]/[["to"]] - name of the variable to generate containing old column names. If <code>NULL</code>, <code>list("variable", "variable")</code> will be chosen.   </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td>
</tr>

</table>

</td></tr>
<tr><td><code id="pivot_+3A_labels">labels</code></td>
<td>

<p>names of columns to generate, or retrieve variable labels from:
</p>

<table>
<tr>
 <td style="text-align: left;"><code> how </code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code>"longer"</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> A string specifying the name of the column to store labels - retrieved from the data using <code>vlabels(values)</code>. <code>TRUE</code> will create a column named <code>"label"</code>. Alternatively, a (named) list with two elements: [[1]]/[["name"]] - the name of the labels column; [[2]]/[["new"]] - a (named) character vector of new labels for the 'variable', 'label' and 'value' columns in the long-format frame. See Examples.   </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code> "wider"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> column(s) containing labels of the new variables. Specified using a vector of column names, indices, a logical vector or selector function e.g. <code>is.character</code>. Multiple columns will be combined using <code><a href="#topic+finteraction">finteraction</a></code> with <code>" - "</code> as separator.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code> "recast"</code>   </td><td style="text-align: left;"></td><td style="text-align: left;"> (named) list with the following elements: [[1]]/[["from"]] - column(s) containing labels for the new variables, specified as in <code>"wider"</code>; [[2]]/[["to"]] - name of the variable to generate containing old labels; [[3]]/[["new"]] - a (named) character vector of new labels for the generated 'variable' and 'label' columns. If [[1]]/[["from"]] is not supplied, this can also include labels for new variables. Omitting one of the elements via a named list or setting it to <code>NULL</code> in a list of 3 will omit the corresponding operation i.e. either not saving existing labels or not assigning new ones.  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 </td>
</tr>

</table>

</td></tr>
<tr><td><code id="pivot_+3A_how">how</code></td>
<td>

<p>character. The pivoting method: one of <code>"longer"</code>, <code>"wider"</code> or <code>"recast"</code>. These can be abbreviated by the first letter i.e. <code>"l"/"w"/"r"</code>.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. <code>TRUE</code> will remove missing values such that in the reshaped data there is no row missing all data columns - selected through 'values'.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_factor">factor</code></td>
<td>

<p>character. Whether to generate new 'names' and/or 'labels' columns as factor variables. This is generally recommended as factors are more memory efficient than character vectors and also faster in subsequent filtering and grouping. Internally, this argument is evaluated as <code>factor &lt;- c("names", "labels") %in% factor</code>, so passing anything other than <code>"names"</code> and/or <code>"labels"</code> will disable it.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_check.dups">check.dups</code></td>
<td>

<p>logical. <code>TRUE</code> checks for duplicate 'ids'+'names' combinations, and, if 'labels' are specified, also for duplicate 'names'+'labels' combinations. The default <code>FALSE</code> implies that the algorithm just runs through the data, leading effectively to the last value being chosen i.e. the data is aggregated using the last value. See Details.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_nthreads">nthreads</code></td>
<td>

<p>integer. if <code>how = "wider"|"recast"</code>: number of threads to use with OpenMP (default <code>get_collapse("nthreads")</code>, initialized to 1). Only the distribution of values to columns with <code>how = "wider"|"recast"</code> is multithreaded here. Since grouping id columns on a long data frame is expensive and serial, the gains are minor. With <code>how = "long"</code>, multithreading does not make much sense as the most expensive operation is allocating the long results vectors. The rest is a couple of <code>memset()</code>'s in C to copy the values.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_fill">fill</code></td>
<td>
<p>if <code>how = "wider"|"recast"</code>: value to insert for 'ids'-'names' combinations not present in the long format. <code>NULL</code> uses <code>NA</code> for atomic vectors and <code>NULL</code> for lists.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_drop">drop</code></td>
<td>

<p>logical. if <code>how = "wider"|"recast"</code> and 'names' is a single factor variable: <code>TRUE</code> will check for and drop unused levels in that factor, avoiding the generation of empty columns.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_sort">sort</code></td>
<td>

<p>if <code>how = "wider"|"recast"</code>: specifying <code>"ids"</code> applies ordered grouping on the id-columns, returning data sorted by ids. Specifying <code>"names"</code> sorts the names before casting (unless 'names' is a factor), yielding columns cast in alphabetic order. Both options can be passed as a character vector, or, alternatively, <code>TRUE</code> can be used to enable both.
</p>
</td></tr>
<tr><td><code id="pivot_+3A_transpose">transpose</code></td>
<td>

<p>if <code>how = "wider"|"recast"</code> and multiple columns are selected through 'values': specifying <code>"columns"</code> applies <code><a href="#topic+t_list">t_list</a></code> to the result before flattening, resulting in a different column order. Specifying <code>"names"</code> generates names of the form nami_colj, instead of colj_nami. Both options can be passed as a character vector, or, alternatively, <code>TRUE</code> can be used to enable both.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pivot wider essentially works as follows: compute <code>g_rows = group(ids)</code> and also <code>g_cols = group(names)</code> (using <code><a href="#topic+group">group</a></code> if <code>sort = FALSE</code>). <code>g_rows</code> gives the row-numbers of the wider data frame and <code>g_cols</code> the column numbers. Then, a C function generates a wide data frame and runs through each long column ('values'), assigning each value to the corresponding row and column in the wide frame. If there are duplicates, some observations will be assigned to the same slot the new data frame, overwriting the value already set. Since the algorithm runs through the data from first to last row, this amounts to removing duplicates by taking the last value for each set of 'ids' - in first-appearance order. If <code>check.dups = TRUE</code>, a check of the form  <code>fnunique(list(g_rows, g_cols)) &lt; fnrow(data)</code> is run, and an informative warning is issued if duplicates are found. Recast pivoting works similarly, and in long pivoting the check simply amounts to <code>fnunique(ids) &lt; fnrow(data)</code>. Making this check optional ensures greater performance, but also requires the user to exercise discretion i.e. know your data or invoke the check.
</p>


<h3>Value</h3>

<p>A reshaped data frame with the same class and attributes (except for 'names'/'row-names') as the input frame.
</p>


<h3>Note</h3>

<p>Leaving either 'ids' or 'values' empty will assign all other columns (except for <code>"variable"</code> if <code>how = "wider"|"recast"</code>) to the non-specified argument. It is also possible to leave both empty, e.g. for complete melting if <code>how = "wider"</code> or data transposition if <code>how = "recast"</code> (similar to <code>data.table::transpose</code> but supporting multiple names columns and variable labels). See Examples.
</p>
<p><code>pivot</code> currently does not support concurrently melting/pivoting longer to multiple columns. See <code>data.table::melt</code> or <code>pivot_longer</code> from <em>tidyr</em> or <em>tidytable</em> for an efficient alternative with this feature. It is also possible to achieve this with just a little bit of programming. An example is provided below. Currently I don't see a 'complete' (like <code>pivot_longer</code>) way of including this feature in the API, and in general I don't see this as a very well-defined operation. But I am open to suggestions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collap">collap</a></code>, <code><a href="#topic+vec">vec</a></code>, <code><a href="#topic+rowbind">rowbind</a></code>, <code><a href="#topic+unlist2d">unlist2d</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -------------------------------- PIVOT LONGER ---------------------------------
# Simple Melting (Reshaping Long)
pivot(mtcars) |&gt; head()
pivot(iris, "Species") |&gt; head()
pivot(iris, values = 1:4) |&gt; head() # Same thing

# Using collapse's datasets
head(wlddev)
pivot(wlddev, 1:8, na.rm = TRUE) |&gt; head()
pivot(wlddev, c("iso3c", "year"), c("PCGDP", "LIFEEX"), na.rm = TRUE) |&gt; head()
head(GGDC10S)
pivot(GGDC10S, 1:5, names = list("Sectorcode", "Value"), na.rm = TRUE) |&gt; head()
# Can also set by name: variable and/or value. Note that 'value' here remains lowercase
pivot(GGDC10S, 1:5, names = list(variable = "Sectorcode"), na.rm = TRUE) |&gt; head()

# Melting including saving labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = TRUE) |&gt; head()
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = "description") |&gt; head()

# Also assigning new labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = list("description",
            c("Sector Code", "Sector Description", "Value"))) |&gt; namlab()

# Can leave out value column by providing named vector of labels
pivot(GGDC10S, 1:5, na.rm = TRUE, labels = list("description",
          c(variable = "Sector Code", description = "Sector Description"))) |&gt; namlab()

# Now here is a nice example that is explicit and respects the dataset naming conventions
pivot(GGDC10S, ids = 1:5, na.rm = TRUE,
      names = list(variable = "Sectorcode",
                   value = "Value"),
      labels = list(name = "Sector",
                    new = c(Sectorcode = "GGDC10S Sector Code",
                            Sector = "Long Sector Description",
                            Value = "Employment or Value Added"))) |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# Note that pivot() currently does not support melting to multiple columns
# But you can tackle the issue with a bit of programming:
wide &lt;- pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable",
              how = "wider", na.rm = TRUE)
head(wide)
library(magrittr)
wide %&gt;% {av(pivot(., 1:2, grep("_VA", names(.))), pivot(gvr(., "_EMP")))} |&gt; head()
wide %&gt;% {av(av(gv(., 1:2), rm_stub(gvr(., "_VA"), "_VA", pre = FALSE)) |&gt;
                   pivot(1:2, names = list("Sectorcode", "VA"), labels = "Sector"),
             EMP = vec(gvr(., "_EMP")))} |&gt; head()
rm(wide)

# -------------------------------- PIVOT WIDER ---------------------------------
iris_long &lt;- pivot(iris, "Species") # Getting a long frame
head(iris_long)
# If 'names'/'values' not supplied, searches for 'variable' and 'value' columns
pivot(iris_long, how = "wider")
# But here the records are not identified by 'Species': thus aggregation with last value:
pivot(iris_long, how = "wider", check = TRUE) # issues a warning
rm(iris_long)

# This works better, these two are inverse operations
wlddev |&gt; pivot(1:8) |&gt; pivot(how = "w") |&gt; head()
# ...but not perfect, we loose labels
namlab(wlddev)
wlddev |&gt; pivot(1:8) |&gt; pivot(how = "w") |&gt; namlab()
# But pivot() supports labels: these are perfect inverse operations
wlddev |&gt; pivot(1:8, labels = "label") |&gt; print(max = 50) |&gt; # Notice the "label" column
  pivot(how = "w", labels = "label") |&gt; namlab()

# If the data does not have 'variable'/'value' cols: need to specify 'names'/'values'
# Using a single column:
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w") |&gt; head()
SUM_wide &lt;- pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w", na.rm = TRUE)
head(SUM_wide) # na.rm = TRUE here removes all new rows completely missing data
tail(SUM_wide) # But there may still be NA's, notice the NA in the final row
# We could use fill to set another value
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", how = "w",
      na.rm = TRUE, fill = -9999) |&gt; tail()
# This will keep the label of "SUM", unless we supply a column with new labels
namlab(SUM_wide)
# Such a column is not available here, but we could use "Variable" twice
pivot(GGDC10S, c("Country", "Year"), "SUM", "Variable", "Variable", how = "w",
      na.rm = TRUE) |&gt; namlab()
# Alternatively, can of course relabel ex-post
SUM_wide |&gt; relabel(VA = "Value Added", EMP = "Employment") |&gt; namlab()
rm(SUM_wide)

# Multiple-column pivots
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE) |&gt; head()
# Here we may prefer a transposed column order
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = "columns") |&gt; head()
# Can also flip the order of names (independently of columns)
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = "names") |&gt; head()
# Can also enable both (complete transposition)
pivot(GGDC10S, c("Country", "Year"), c("AGR", "MAN", "SUM"), "Variable", how = "w",
      na.rm = TRUE, transpose = TRUE) |&gt; head() # or tranpose = c("columns", "names")

# Finally, here is a nice, simple way to reshape the entire dataset.
pivot(GGDC10S, values = 6:16, names = "Variable", na.rm = TRUE, how = "w") |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# -------------------------------- PIVOT RECAST ---------------------------------
# Look at the data again
head(GGDC10S)
# Let's stack the sectors and instead create variable columns
pivot(GGDC10S, .c(Country, Regioncode, Region, Year),
      names = list("Variable", "Sectorcode"), how = "r") |&gt; head()
# Same thing (a bit easier)
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"), how = "r") |&gt; head()
# Removing missing values
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"), how = "r",
      na.rm = TRUE) |&gt; head()
# Saving Labels
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"),
      labels = list(to = "Sector"), how = "r", na.rm = TRUE) |&gt; head()

# Supplying new labels for generated columns: as complete as it gets
pivot(GGDC10S, values = 6:16, names = list("Variable", "Sectorcode"),
      labels = list(to = "Sector",
                    new = c(Sectorcode = "GGDC10S Sector Code",
                            Sector = "Long Sector Description",
                            VA = "Value Added",
                            EMP = "Employment")), how = "r", na.rm = TRUE) |&gt;
  namlab(N = TRUE, Nd = TRUE, class = TRUE)

# Now another (slightly unconventional) use case here is data transposition
# Let's get the data for Botswana
BWA &lt;- GGDC10S |&gt; fsubset(Country == "BWA", Variable, Year, AGR:SUM)
head(BWA)
# By supplying no ids or values, we are simply requesting a transpose operation
pivot(BWA, names = list(from = c("Variable", "Year"), to = "Sectorcode"), how = "r")
# Same with labels
pivot(BWA, names = list(from = c("Variable", "Year"), to = "Sectorcode"),
      labels = list(to = "Sector"), how = "r")
# For simple cases, data.table::transpose() will be more efficient, but with multiple
# columns to generate names and/or variable labels to be saved/assigned, pivot() is handy
rm(BWA)
</code></pre>

<hr>
<h2 id='psacf'>
Auto- and Cross- Covariance and Correlation Function Estimation for Panel Series
</h2><span id='topic+psacf'></span><span id='topic+psacf.default'></span><span id='topic+psacf.pseries'></span><span id='topic+psacf.data.frame'></span><span id='topic+psacf.pdata.frame'></span><span id='topic+pspacf'></span><span id='topic+pspacf.default'></span><span id='topic+pspacf.pseries'></span><span id='topic+pspacf.data.frame'></span><span id='topic+pspacf.pdata.frame'></span><span id='topic+psccf'></span><span id='topic+psccf.default'></span><span id='topic+psccf.pseries'></span>

<h3>Description</h3>

<p><code>psacf</code>, <code>pspacf</code> and <code>psccf</code> compute (and by default plot) estimates of the auto-, partial auto- and cross- correlation or covariance functions for panel series. They are analogues to <code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="stats.html#topic+pacf">pacf</a></code> and <code><a href="stats.html#topic+ccf">ccf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psacf(x, ...)
pspacf(x, ...)
psccf(x, y, ...)

## Default S3 method:
psacf(x, g, t = NULL, lag.max = NULL, type = c("correlation", "covariance","partial"),
      plot = TRUE, gscale = TRUE, ...)
## Default S3 method:
pspacf(x, g, t = NULL, lag.max = NULL, plot = TRUE, gscale = TRUE, ...)
## Default S3 method:
psccf(x, y, g, t = NULL, lag.max = NULL, type = c("correlation", "covariance"),
      plot = TRUE, gscale = TRUE, ...)

## S3 method for class 'data.frame'
psacf(x, by, t = NULL, cols = is.numeric, lag.max = NULL,
      type = c("correlation", "covariance","partial"), plot = TRUE, gscale = TRUE, ...)
## S3 method for class 'data.frame'
pspacf(x, by, t = NULL, cols = is.numeric, lag.max = NULL,
       plot = TRUE, gscale = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
psacf(x, lag.max = NULL, type = c("correlation", "covariance","partial"),
      plot = TRUE, gscale = TRUE, ...)
## S3 method for class 'pseries'
pspacf(x, lag.max = NULL, plot = TRUE, gscale = TRUE, ...)
## S3 method for class 'pseries'
psccf(x, y, lag.max = NULL, type = c("correlation", "covariance"),
      plot = TRUE, gscale = TRUE, ...)

 ## S3 method for class 'pdata.frame'
psacf(x, cols = is.numeric, lag.max = NULL,
      type = c("correlation", "covariance","partial"), plot = TRUE, gscale = TRUE, ...)
## S3 method for class 'pdata.frame'
pspacf(x, cols = is.numeric, lag.max = NULL, plot = TRUE, gscale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psacf_+3A_x">x</code>, <code id="psacf_+3A_y">y</code></td>
<td>
<p>a numeric vector, 'indexed_series' ('pseries'), data frame or 'indexed_frame' ('pdata.frame').</p>
</td></tr>
<tr><td><code id="psacf_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, or atomic vector / list of vectors (internally grouped with <code><a href="#topic+group">group</a></code>) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="psacf_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same input as <code>g</code>, but also allows one- or two-sided formulas using the variables in <code>x</code>, i.e. <code>~ idvar</code> or <code>var1 + var2 ~ idvar1 + idvar2</code>.</p>
</td></tr>
<tr><td><code id="psacf_+3A_t">t</code></td>
<td>
<p>a time vector or list of vectors. See <code><a href="#topic+flag">flag</a></code>.</p>
</td></tr>
<tr><td><code id="psacf_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns using a function, column names, indices or a logical vector. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="psacf_+3A_lag.max">lag.max</code></td>
<td>
<p>integer. Maximum lag at which to calculate the acf. Default is <code>2*sqrt(length(x)/ng)</code> where <code>ng</code> is the number of groups in the panel series / supplied to <code>g</code>.</p>
</td></tr>
<tr><td><code id="psacf_+3A_type">type</code></td>
<td>
<p>character. String giving the type of acf to be computed. Allowed values are &quot;correlation&quot; (the default), &quot;covariance&quot; or &quot;partial&quot;.</p>
</td></tr>
<tr><td><code id="psacf_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) the acf is plotted.</p>
</td></tr>
<tr><td><code id="psacf_+3A_gscale">gscale</code></td>
<td>
<p>logical. Do a groupwise scaling / standardization of <code>x, y</code> (using <code><a href="#topic+fscale">fscale</a></code> and the groups supplied to <code>g</code>) before computing panel-autocovariances / correlations. See Details.</p>
</td></tr>
<tr><td><code id="psacf_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="stats.html#topic+plot.acf">plot.acf</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>gscale = TRUE</code> data are standardized within each group (using <code><a href="#topic+fscale">fscale</a></code>) such that the group-mean is 0 and the group-standard deviation is 1. This is strongly recommended for most panels to get rid of individual-specific heterogeneity which would corrupt the ACF computations.
</p>
<p>After scaling, <code>psacf</code>, <code>pspacf</code> and <code>psccf</code> compute the ACF/CCF by creating a matrix of panel-lags of the series using <code><a href="#topic+flag">flag</a></code> and then computing the covariance of this matrix with the series (<code>x, y</code>) using <code><a href="stats.html#topic+cov">cov</a></code> and pairwise-complete observations, and dividing by the variance (of <code>x, y</code>). Creating the lag matrix may require a lot of memory on large data, but passing a sequence of lags to <code><a href="#topic+flag">flag</a></code> and thus calling <code><a href="#topic+flag">flag</a></code> and <code><a href="stats.html#topic+cov">cov</a></code> one time is generally much faster than calling them <code>lag.max</code> times. The partial ACF is computed from the ACF using a Yule-Walker decomposition, in the same way as in <code><a href="stats.html#topic+pacf">pacf</a></code>.
</p>


<h3>Value</h3>

<p>An object of class 'acf', see <code><a href="stats.html#topic+acf">acf</a></code>. The result is returned invisibly if <code>plot = TRUE</code>.</p>


<h3>See Also</h3>

<p><a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## World Development Panel Data
head(wlddev)                                                    # See also help(wlddev)
psacf(wlddev$PCGDP, wlddev$country, wlddev$year)                # ACF of GDP per Capita
psacf(wlddev, PCGDP ~ country, ~year)                           # Same using data.frame method
psacf(wlddev$PCGDP, wlddev$country)                             # The Data is sorted, can omit t
pspacf(wlddev$PCGDP, wlddev$country)                            # Partial ACF
psccf(wlddev$PCGDP, wlddev$LIFEEX, wlddev$country)              # CCF with Life-Expectancy at Birth

psacf(wlddev, PCGDP + LIFEEX + ODA ~ country, ~year)            # ACF and CCF of GDP, LIFEEX and ODA
psacf(wlddev, ~ country, ~year, c(9:10,12))                     # Same, using cols argument
pspacf(wlddev, ~ country, ~year, c(9:10,12))                    # Partial ACF

## Using indexed data:
wldi &lt;- findex_by(wlddev, iso3c, year)  # Creating a indexed frame
PCGDP &lt;- wldi$PCGDP                     # Indexed Series of GDP per Capita
LIFEEX &lt;- wldi$LIFEEX                   # Indexed Series of Life Expectancy
psacf(PCGDP)                            # Same as above, more parsimonious
pspacf(PCGDP)
psccf(PCGDP, LIFEEX)
psacf(wldi[c(9:10,12)])
pspacf(wldi[c(9:10,12)])

</code></pre>

<hr>
<h2 id='psmat'>
Matrix / Array from Panel Series
</h2><span id='topic+psmat'></span><span id='topic+psmat.default'></span><span id='topic+psmat.pseries'></span><span id='topic+psmat.data.frame'></span><span id='topic+psmat.pdata.frame'></span><span id='topic+plot.psmat'></span><span id='topic+aperm.psmat'></span><span id='topic++5B.psmat'></span>

<h3>Description</h3>

<p><code>psmat</code> efficiently expands a panel-vector or 'indexed_series' ('pseries') into a matrix. If a data frame or 'indexed_frame' ('pdata.frame') is passed, <code>psmat</code> returns a 3D array or a list of matrices.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psmat(x, ...)

## Default S3 method:
psmat(x, g, t = NULL, transpose = FALSE, ...)

## S3 method for class 'data.frame'
psmat(x, by, t = NULL, cols = NULL, transpose = FALSE, array = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
psmat(x, transpose = FALSE, drop.index.levels = "none", ...)

## S3 method for class 'pdata.frame'
psmat(x, cols = NULL, transpose = FALSE, array = TRUE, drop.index.levels = "none", ...)


## S3 method for class 'psmat'
plot(x, legend = FALSE, colours = legend, labs = NULL, grid = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psmat_+3A_x">x</code></td>
<td>
<p>a vector, indexed series 'indexed_series' ('pseries'), data frame or 'indexed_frame' ('pdata.frame').</p>
</td></tr>
<tr><td><code id="psmat_+3A_g">g</code></td>
<td>
<p>a factor, <code>GRP</code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code>GRP</code> object) used to group <code>x</code>. If the panel is balanced an integer indicating the number of groups can also be supplied. See Examples.</p>
</td></tr>
<tr><td><code id="psmat_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same input as <code>g</code>, but also allows one- or two-sided formulas using the variables in <code>x</code>, i.e. <code>~ idvar</code> or <code>var1 + var2 ~ idvar1 + idvar2</code>.</p>
</td></tr>
<tr><td><code id="psmat_+3A_t">t</code></td>
<td>
<p>same inputs as <code>g/by</code>, to indicate the time-variable(s) or second identifier(s). <code>g</code> and <code>t</code> together should fully identify the panel. If <code>t = NULL</code>, the data is assumed sorted and <code>seq_col</code> is used to generate rownames for the output matrix.</p>
</td></tr>
<tr><td><code id="psmat_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns using a function, column names, indices or a logical vector. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="psmat_+3A_transpose">transpose</code></td>
<td>
<p>logical. <code>TRUE</code> generates the matrix such that <code>g/by -&gt; columns, t -&gt; rows</code>. Default is <code>g/by -&gt; rows, t -&gt; columns</code>.</p>
</td></tr>
<tr><td><code id="psmat_+3A_array">array</code></td>
<td>
<p><em>data.frame / pdata.frame methods</em>: logical. <code>TRUE</code> returns a 3D array (if just one column is selected a matrix is returned). <code>FALSE</code> returns a list of matrices.</p>
</td></tr>
<tr><td><code id="psmat_+3A_drop.index.levels">drop.index.levels</code></td>
<td>
<p>character. Either <code>"id"</code>, <code>"time"</code>, <code>"all"</code> or <code>"none"</code>. See <a href="#topic+indexing">indexing</a>.</p>
</td></tr>
<tr><td><code id="psmat_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods, or for the plot method additional arguments passed to <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>.</p>
</td></tr>
<tr><td><code id="psmat_+3A_legend">legend</code></td>
<td>
<p>logical. Automatically create a legend of panel-groups.</p>
</td></tr>
<tr><td><code id="psmat_+3A_colours">colours</code></td>
<td>
<p>either <code>TRUE</code> to automatically colour by panel-groups using <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> or a character vector of colours matching the number of panel-groups (series).</p>
</td></tr>
<tr><td><code id="psmat_+3A_labs">labs</code></td>
<td>
<p>character. Provide a character-vector of variable labels / series titles when plotting an array.</p>
</td></tr>
<tr><td><code id="psmat_+3A_grid">grid</code></td>
<td>
<p>logical. Calls <code><a href="graphics.html#topic+grid">grid</a></code> to draw gridlines on the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If n &gt; 2 index variables are attached to an indexed series or frame, the first n-1 variables in the index are interacted.
</p>


<h3>Value</h3>

<p>A matrix or 3D array containing the data in <code>x</code>, where by default the rows constitute the groups-ids (<code>g/by</code>) and the columns the time variable or individual ids (<code>t</code>). 3D arrays contain the variables in the 3rd dimension. The objects have a class 'psmat', and also a 'transpose' attribute indicating whether <code>transpose = TRUE</code>.
</p>


<h3>Note</h3>

<p>The <code>pdata.frame</code> method only works for properly subsetted objects of class 'pdata.frame'. A list of 'pseries' won't work. There also exist simple <code>aperm</code> and <code>[</code> (subset) methods for 'psmat' objects. These differ from the default methods only by keeping the class and the 'transpose' attribute.
</p>


<h3>See Also</h3>

<p><a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## World Development Panel Data
head(wlddev)                                                    # View data
qsu(wlddev, pid = ~ iso3c, cols = 9:12, vlabels = TRUE)         # Sumarizing data
str(psmat(wlddev$PCGDP, wlddev$iso3c, wlddev$year))             # Generating matrix of GDP
r &lt;- psmat(wlddev, PCGDP ~ iso3c, ~ year)                       # Same thing using data.frame method
plot(r, main = vlabels(wlddev)[9], xlab = "Year")               # Plot the matrix
str(r)                                                          # See srructure
str(psmat(wlddev$PCGDP, wlddev$iso3c))                          # The Data is sorted, could omit t
str(psmat(wlddev$PCGDP, 216))                                   # This panel is also balanced, so
# ..indicating the number of groups would be sufficient to obtain a matrix

ar &lt;- psmat(wlddev, ~ iso3c, ~ year, 9:12)                      # Get array of transposed matrices
str(ar)
plot(ar)
plot(ar, legend = TRUE)
plot(psmat(collap(wlddev, ~region+year, cols = 9:12),           # More legible and fancy plot
           ~region, ~year), legend = TRUE,
     labs = vlabels(wlddev)[9:12])

psml &lt;- psmat(wlddev, ~ iso3c, ~ year, 9:12, array = FALSE)     # This gives list of ps-matrices
head(unlist2d(psml, "Variable", "Country", id.factor = TRUE),2) # Using unlist2d, can generate DF

## Indexing simplifies things
wldi &lt;- findex_by(wlddev, iso3c, year)  # Creating an indexed frame
PCGDP &lt;- wldi$PCGDP                     # An indexed_series of GDP per Capita
head(psmat(PCGDP), 2)                   # Same as above, more parsimonious
plot(psmat(PCGDP))
plot(psmat(wldi[9:12]))
plot(psmat(G(wldi[9:12])))              # Here plotting panel-growth rates

</code></pre>

<hr>
<h2 id='pwcor-pwcov-pwnobs'>
(Pairwise, Weighted) Correlations, Covariances and Observation Counts
</h2><span id='topic+pwcor'></span><span id='topic+pwcov'></span><span id='topic+pwnobs'></span><span id='topic+print.pwcov'></span><span id='topic+print.pwcor'></span>

<h3>Description</h3>

<p>Computes (pairwise, weighted) Pearson's correlations, covariances and observation counts. Pairwise correlations and covariances can be computed together with observation counts and p-values, and output as 3D array (default) or list of matrices. <code>pwcor</code> and <code>pwcov</code> offer an elaborate print method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwcor(X, ..., w = NULL, N = FALSE, P = FALSE, array = TRUE, use = "pairwise.complete.obs")

pwcov(X, ..., w = NULL, N = FALSE, P = FALSE, array = TRUE, use = "pairwise.complete.obs")

pwnobs(X)

## S3 method for class 'pwcor'
print(x, digits = .op[["digits"]], sig.level = 0.05,
      show = c("all","lower.tri","upper.tri"), spacing = 1L, return = FALSE, ...)

## S3 method for class 'pwcov'
print(x, digits = .op[["digits"]], sig.level = 0.05,
      show = c("all","lower.tri","upper.tri"), spacing = 1L, return = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_x">X</code></td>
<td>
<p>a matrix or data.frame, for <code>pwcor</code> and <code>pwcov</code> all columns must be numeric. All functions are faster on matrices, so converting is advised for large data (see <code><a href="#topic+qM">qM</a></code>).</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_x">x</code></td>
<td>
<p>an object of class 'pwcor' / 'pwcov'. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_w">w</code></td>
<td>
<p>numeric. A vector of (frequency) weights. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_n">N</code></td>
<td>
<p>logical. <code>TRUE</code> also computes pairwise observation counts.</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_p">P</code></td>
<td>
<p>logical. <code>TRUE</code> also computes pairwise p-values (same as <code><a href="stats.html#topic+cor.test">cor.test</a></code> and <code>Hmisc::rcorr</code>).</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_array">array</code></td>
<td>
<p>logical. If <code>N = TRUE</code> or <code>P = TRUE</code>, <code>TRUE</code> (default) returns output as 3D array whereas <code>FALSE</code> returns a list of matrices.</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_use">use</code></td>
<td>
<p>argument passed to <code><a href="stats.html#topic+cor">cor</a></code> / <code><a href="stats.html#topic+cov">cov</a></code>. If <code>use != "pairwise.complete.obs"</code>, <code>sum(complete.cases(X))</code> is used for <code>N</code>, and p-values are computed accordingly. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits to round to in print. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric. P-value threshold below which a <code>'*'</code> is displayed above significant coefficients if <code>P = TRUE</code>. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_show">show</code></td>
<td>
<p>character. The part of the correlation / covariance matrix to display. </p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_spacing">spacing</code></td>
<td>
<p>integer. Controls the spacing between different reported quantities in the printout of the matrix: 0 - compressed, 1 - single space, 2 - double space.</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_return">return</code></td>
<td>
<p>logical. <code>TRUE</code> returns the formatted object from the print method for exporting. The default is to return <code>x</code> invisibly.</p>
</td></tr>
<tr><td><code id="pwcor-pwcov-pwnobs_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+cor">cor</a></code> or <code><a href="stats.html#topic+cov">cov</a></code>. Only sensible if <code>P = FALSE</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix, 3D array or list of matrices with the computed statistics. For <code>pwcor</code> and <code>pwcov</code> the object has a class 'pwcor' and 'pwcov', respectively.
</p>


<h3>Note</h3>

<p><code>weights::wtd.cors</code> is imported for weighted pairwise correlations (written in C for speed). For weighted correlations with bootstrap SE's see <code>weights::wtd.cor</code> (bootstrap can be slow). Weighted correlations for complex surveys are implemented in <code>jtools::svycor</code>. An equivalent and faster implementation of <code>pwcor</code> (without weights) is provided in <code>Hmisc::rcorr</code> (written in Fortran).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qsu">qsu</a></code>, <a href="#topic+summary-statistics">Summary Statistics</a>, <a href="#topic+collapse-documentation">Collapse Overview</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mna &lt;- na_insert(mtcars)
pwcor(mna)
pwcov(mna)
pwnobs(mna)
pwcor(mna, N = TRUE)
pwcor(mna, P = TRUE)
pwcor(mna, N = TRUE, P = TRUE)
aperm(pwcor(mna, N = TRUE, P = TRUE))
print(pwcor(mna, N = TRUE, P = TRUE), digits = 3, sig.level = 0.01, show = "lower.tri")
pwcor(mna, N = TRUE, P = TRUE, array = FALSE)
print(pwcor(mna, N = TRUE, P = TRUE, array = FALSE), show = "lower.tri")


</code></pre>

<hr>
<h2 id='qF-qG-finteraction'>
Fast Factor Generation, Interactions and Vector Grouping
</h2><span id='topic+qF'></span><span id='topic+qG'></span><span id='topic+is_qG'></span><span id='topic+as_factor_qG'></span><span id='topic+finteraction'></span><span id='topic+itn'></span>

<h3>Description</h3>

<p><code>qF</code>, shorthand for 'quick-factor' implements very fast factor generation from atomic vectors using either radix ordering or index hashing followed by sorting.
</p>
<p><code>qG</code>, shorthand for 'quick-group', generates a kind of factor-light without the levels attribute but instead an attribute providing the number of levels. Optionally the levels / groups can be attached, but without converting them to character (which can have large performance implications). Objects have a class 'qG'.
</p>
<p><code>finteraction</code> generates a factor or 'qG' object by interacting multiple vectors or factors. In that process missing values are always replaced with a level and unused levels/combinations are always dropped.
</p>
<p><em>collapse</em> internally makes optimal use of factors and 'qG' objects when passed as grouping vectors to statistical functions (<code>g/by</code>, or <code>t</code> arguments) i.e. typically no further grouping or ordering is performed and objects are used directly by statistical C/C++ code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qF(x, ordered = FALSE, na.exclude = TRUE, sort = .op[["sort"]], drop = FALSE,
   keep.attr = TRUE, method = "auto")

qG(x, ordered = FALSE, na.exclude = TRUE, sort = .op[["sort"]],
   return.groups = FALSE, method = "auto")

is_qG(x)

as_factor_qG(x, ordered = FALSE, na.exclude = TRUE)

finteraction(..., factor = TRUE, ordered = FALSE, sort = factor &amp;&amp; .op[["sort"]],
             method = "auto", sep = ".")
itn(...) # Shorthand for finteraction
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qF-qG-finteraction_+3A_x">x</code></td>
<td>
<p>a atomic vector, factor or quick-group.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_ordered">ordered</code></td>
<td>
<p>logical. Adds a class 'ordered'.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_na.exclude">na.exclude</code></td>
<td>
<p>logical. <code>TRUE</code> preserves missing values (i.e. no level is generated for <code>NA</code>). <code>FALSE</code> attaches an additional class <code>"na.included"</code> which is used to skip missing value checks performed before sending objects to C/C++. See Details. </p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_sort">sort</code></td>
<td>
<p>logical. <code>TRUE</code> sorts the levels in ascending order (like <code><a href="base.html#topic+factor">factor</a></code>); <code>FALSE</code> provides the levels in order of first appearance, which can be significantly faster. Note that if a factor is passed as input, only <code>sort = FALSE</code> takes effect and unused levels will be dropped (as factors usually have sorted levels and checking sortedness can be expensive).</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>x</code> is a factor, <code>TRUE</code> efficiently drops unused factor levels beforehand using <code><a href="#topic+fdroplevels">fdroplevels</a></code>.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_keep.attr">keep.attr</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>x</code> has additional attributes apart from 'levels' and 'class', these are preserved in the conversion to factor.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_method">method</code></td>
<td>
<p>an integer or character string specifying the method of computation:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "auto"   </td><td style="text-align: left;"></td><td style="text-align: left;"> automatic selection: <code>if(is.double(x) &amp;&amp; sort) "radix" else if(sort &amp;&amp; length(x) &lt; 1e5) "rcpp_hash" else "hash"</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "radix" </td><td style="text-align: left;"></td><td style="text-align: left;"> use radix ordering to generate factors. Supports <code>sort = FALSE</code> only for character vectors. See Details. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "hash"   </td><td style="text-align: left;"></td><td style="text-align: left;"> use hashing to generate factors. Since v1.8.3 this is a fast hybrid implementation using <code><a href="#topic+group">group</a></code> and radix ordering applied to the unique elements. See Details. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "rcpp_hash" </td><td style="text-align: left;"></td><td style="text-align: left;"> the previous "hash" algorithm prior to v1.8.3: uses <code>Rcpp::sugar::sort_unique</code> and <code>Rcpp::sugar::match</code>. Only supports <code>sort = TRUE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Note that for <code>finteraction</code>, <code>method = "hash"</code> is always unsorted and <code>method = "rcpp_hash"</code> is not available.
</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_return.groups">return.groups</code></td>
<td>
<p>logical. <code>TRUE</code> returns the unique elements / groups / levels of <code>x</code> in an attribute called <code>"groups"</code>. Unlike <code>qF</code>, they are not converted to character.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_factor">factor</code></td>
<td>
<p>logical. <code>TRUE</code> returns an factor, <code>FALSE</code> returns a 'qG' object. </p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_sep">sep</code></td>
<td>
<p>character. The separator passed to <code><a href="base.html#topic+paste">paste</a></code> when creating factor levels from multiple grouping variables.</p>
</td></tr>
<tr><td><code id="qF-qG-finteraction_+3A_...">...</code></td>
<td>
<p>multiple atomic vectors or factors, or a single list of equal-length vectors or factors. See Details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever a vector is passed to a <a href="#topic+fast-statistical-functions">Fast Statistical Function</a> such as <code>fmean(mtcars, mtcars$cyl)</code>, is is grouped using <code>qF</code>, or <code>qG</code> if <code>use.g.names = FALSE</code>.
</p>
<p><code>qF</code> is a combination of <code>as.factor</code> and <code>factor</code>. Applying it to a vector i.e. <code>qF(x)</code> gives the same result as <code>as.factor(x)</code>. <code>qF(x, ordered = TRUE)</code> generates an ordered factor (same as <code>factor(x, ordered = TRUE)</code>), and <code>qF(x, na.exclude = FALSE)</code> generates a level for missing values (same as <code>factor(x, exclude = NULL)</code>). An important addition is that <code>qF(x, na.exclude = FALSE)</code> also adds a class 'na.included'. This prevents <em>collapse</em> functions from checking missing values in the factor, and is thus computationally more efficient. Therefore factors used in grouped operations should preferably be generated using <code>qF(x, na.exclude = FALSE)</code>. Setting <code>sort = FALSE</code> gathers the levels in first-appearance order (unless <code>method = "radix"</code> and <code>x</code> is numeric, in which case the levels are always sorted). This often gives a noticeable speed improvement. 
</p>
<p>There are 3 internal methods of computation: radix ordering, hashing, and Rcpp sugar hashing. Radix ordering is done by combining the functions <code><a href="#topic+radixorder">radixorder</a></code> and <code><a href="#topic+groupid">groupid</a></code>. It is generally faster than hashing for large numeric data and pre-sorted data (although there are exceptions). Hashing uses <code><a href="#topic+group">group</a></code>, followed by <code><a href="#topic+radixorder">radixorder</a></code> on the unique elements if <code>sort = TRUE</code>. It is generally fastest for character data. Rcpp hashing uses <code>Rcpp::sugar::sort_unique</code> and <code>Rcpp::sugar::match</code>. This is often less efficient than the former on large data, but the sorting properties (relying on <code>std::sort</code>) may be superior in borderline cases where <code><a href="#topic+radixorder">radixorder</a></code> fails to deliver exact lexicographic ordering of factor levels.  
</p>
<p>Regarding speed: In general <code>qF</code> is around 5x faster than <code>as.factor</code> on character data and about 30x faster on numeric data. Automatic method dispatch typically does a good job delivering optimal performance.
</p>
<p><code>qG</code> is in the first place a programmers function. It generates a factor-'light' class 'qG' consisting of only an integer grouping vector and an attribute providing the number of groups. It is slightly faster and more memory efficient than <code><a href="#topic+GRP">GRP</a></code> for grouping atomic vectors, and also convenient as it can be stored in a data frame column, which are the main reasons for its existence. 
</p>
<p><code>finteraction</code> is simply a wrapper around <code>as_factor_GRP(GRP.default(X))</code>, where X is replaced by the arguments in '...' combined in a list (so its not really an interaction function but just a multivariate grouping converted to factor, see <code><a href="#topic+GRP">GRP</a></code> for computational details). In general: All vectors, factors, or lists of vectors / factors passed can be interacted. Interactions always create a level for missing values and always drop unused levels.
</p>


<h3>Value</h3>

<p><code>qF</code> returns an (ordered) factor. <code>qG</code> returns an object of class 'qG': an integer grouping vector with an attribute <code>"N.groups"</code> indicating the number of groups, and, if <code>return.groups = TRUE</code>, an attribute <code>"groups"</code> containing the vector of unique groups / elements in <code>x</code> corresponding to the integer-id. <code>finteraction</code> can return either.
</p>


<h3>Note</h3>

<p>An efficient alternative for character vectors with multithreading support is provided by <code>kit::charToFact</code>.
</p>
<p><code>qG(x, sort = FALSE, na.exclude = FALSE, method = "hash")</code> internally calls <code><a href="#topic+group">group(x)</a></code> which can also be used directly and also supports multivariate groupings where <code>x</code> can be a list of vectors.
</p>
<p>Neither <code>qF</code> nor <code>qG</code> reorder groups / factor levels. An exception was added in v1.7, when calling <code>qF(f, sort = FALSE)</code> on a factor <code>f</code>, the levels are recast in first appearance order. These objects can however be converted into one another using <code>qF/qG</code> or the direct method <code>as_factor_qG</code> (called inside <code>qF</code>). It is also possible to add a class 'ordered' (<code>ordered = TRUE</code>) and to create am extra level / integer for missing values (<code>na.exclude = FALSE</code>) if factors or 'qG' objects are passed to <code>qF</code> or <code>qG</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group">group</a></code>, <code><a href="#topic+groupid">groupid</a></code>, <code><a href="#topic+GRP">GRP</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cylF &lt;- qF(mtcars$cyl)     # Factor from atomic vector
cylG &lt;- qG(mtcars$cyl)     # Quick-group from atomic vector
cylG                       # See the simple structure of this object

cf  &lt;- qF(wlddev$country)  # Bigger data
cf2 &lt;- qF(wlddev$country, na.exclude = FALSE)  # With na.included class
dat &lt;- num_vars(wlddev)
 
# cf2 is faster in grouped operations because no missing value check is performed
library(microbenchmark)
microbenchmark(fmax(dat, cf), fmax(dat, cf2))

finteraction(mtcars$cyl, mtcars$vs)  # Interacting two variables (can be factors)
head(finteraction(mtcars))           # A more crude example..

finteraction(mtcars$cyl, mtcars$vs, factor = FALSE) # Returns 'qG', by default unsorted
group(mtcars[c("cyl", "vs")]) # Same thing. Use whatever syntax is more convenient

</code></pre>

<hr>
<h2 id='qsu'>
Fast (Grouped, Weighted) Summary Statistics for Cross-Sectional and Panel Data
</h2><span id='topic+qsu'></span><span id='topic+qsu.default'></span><span id='topic+qsu.matrix'></span><span id='topic+qsu.data.frame'></span><span id='topic+qsu.grouped_df'></span><span id='topic+qsu.pseries'></span><span id='topic+qsu.pdata.frame'></span><span id='topic+qsu.sf'></span><span id='topic+print.qsu'></span><span id='topic+as.data.frame.qsu'></span>

<h3>Description</h3>

<p><code>qsu</code>, shorthand for quick-summary, is an extremely fast summary command inspired by the (xt)summarize command in the STATA statistical software.
</p>
<p>It computes a set of 7 statistics (nobs, mean, sd, min, max, skewness and kurtosis) using a numerically stable one-pass method generalized from Welford's Algorithm. Statistics can be computed weighted, by groups, and also within-and between entities (for panel data, see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsu(x, ...)

## Default S3 method:
qsu(x, g = NULL, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'matrix'
qsu(x, g = NULL, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'data.frame'
qsu(x, by = NULL, pid = NULL, w = NULL, cols = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'grouped_df'
qsu(x, pid = NULL, w = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
qsu(x, g = NULL, w = NULL, effect = 1L, higher = FALSE,
    array = TRUE, stable.algo = .op[["stable.algo"]], ...)

## S3 method for class 'pdata.frame'
qsu(x, by = NULL, w = NULL, cols = NULL, effect = 1L, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)

# Methods for compatibility with sf:

## S3 method for class 'sf'
qsu(x, by = NULL, pid = NULL, w = NULL, cols = NULL, higher = FALSE,
    array = TRUE, labels = FALSE, stable.algo = .op[["stable.algo"]], ...)


## S3 method for class 'qsu'
as.data.frame(x, ..., gid = "Group", stringsAsFactors = TRUE)

## S3 method for class 'qsu'
print(x, digits = .op[["digits"]] + 2L, nonsci.digits = 9, na.print = "-",
      return = FALSE, print.gap = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsu_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame, 'indexed_series' ('pseries') or 'indexed_frame' ('pdata.frame').</p>
</td></tr>
<tr><td><code id="qsu_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="qsu_+3A_by">by</code></td>
<td>
<p><em>(p)data.frame method</em>: Same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1 + group2</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="qsu_+3A_pid">pid</code></td>
<td>
<p>same input as <code>g/by</code>: Specify a panel-identifier to also compute statistics on between- and within- transformed data. Data frame method also supports one- or two-sided formulas, grouped_df method supports expressions evaluated in the data environment. Transformations are taken independently from grouping with <code>g/by</code> (grouped statistics are computed on the transformed data if <code>g/by</code> is also used). However, passing any LHS variables to <code>pid</code> will overwrite any <code>LHS</code> variables passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="qsu_+3A_w">w</code></td>
<td>
<p>a vector of (non-negative) weights. Adding weights will compute the weighted mean, sd, skewness and kurtosis, and transform the data using weighted individual means if <code>pid</code> is used. Data frame method supports formula, grouped_df method supports expression.</p>
</td></tr>
<tr><td><code id="qsu_+3A_cols">cols</code></td>
<td>
<p>select columns to summarize using column names, indices, a logical vector or a function (e.g. <code>is.numeric</code>). Two-sided formulas passed to <code>by</code> or <code>pid</code> overwrite <code>cols</code>.</p>
</td></tr>
<tr><td><code id="qsu_+3A_higher">higher</code></td>
<td>
<p>logical. Add higher moments (skewness and kurtosis).</p>
</td></tr>
<tr><td><code id="qsu_+3A_array">array</code></td>
<td>
<p>logical. If computations have more than 2 dimensions (up to a maximum of 4D: variables, statistics, groups and panel-decomposition) <code>TRUE</code> returns an array, while <code>FALSE</code> returns a (nested) list of matrices.</p>
</td></tr>
<tr><td><code id="qsu_+3A_stable.algo">stable.algo</code></td>
<td>
<p>logical. <code>FALSE</code> uses a faster but less stable method to calculate the standard deviation (see Details of <code><a href="#topic+fsd">fsd</a></code>). Only available if <code>w = NULL</code> and <code>higher = FALSE</code>.</p>
</td></tr>
<tr><td><code id="qsu_+3A_labels">labels</code></td>
<td>
<p>logical <code>TRUE</code> or a function: to display variable labels in the summary. See Details.</p>
</td></tr>
<tr><td><code id="qsu_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> methods: Select which panel identifier should be used for between and within transformations of the data. 1L takes the first variable in the <a href="#topic+indexing">index</a>, 2L the second etc.. Index variables can also be called by name using a character string. More than one variable can be supplied. </p>
</td></tr>
<tr><td><code id="qsu_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="qsu_+3A_gid">gid</code></td>
<td>
<p>character. Name assigned to the group-id column, when summarising variables by groups.</p>
</td></tr>
<tr><td><code id="qsu_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical. Make factors from dimension names of 'qsu' array. Same as option to <code><a href="base.html#topic+as.data.frame.table">as.data.frame.table</a></code>.</p>
</td></tr>
<tr><td><code id="qsu_+3A_digits">digits</code></td>
<td>
<p>the number of digits to print after the comma/dot.</p>
</td></tr>
<tr><td><code id="qsu_+3A_nonsci.digits">nonsci.digits</code></td>
<td>
<p>the number of digits to print before resorting to scientific notation (default is to print out numbers with up to 9 digits and print larger numbers scientifically).</p>
</td></tr>
<tr><td><code id="qsu_+3A_na.print">na.print</code></td>
<td>
<p>character string to substitute for missing values.</p>
</td></tr>
<tr><td><code id="qsu_+3A_return">return</code></td>
<td>
<p>logical. Don't print but instead return the formatted object.</p>
</td></tr>
<tr><td><code id="qsu_+3A_print.gap">print.gap</code></td>
<td>
<p>integer. Spacing between printed columns. Passed to <code>print.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used to compute statistics is well described <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">here</a> [see sections <em>Welford's online algorithm</em>, <em>Weighted incremental algorithm</em> and <em>Higher-order statistics</em>. Skewness and kurtosis are calculated as described in <em>Higher-order statistics</em> and are mathematically identical to those implemented in the <em>moments</em> package. Just note that <code>qsu</code> computes the kurtosis (like <code>momens::kurtosis</code>), not the excess-kurtosis (=  kurtosis - 3) defined in <em>Higher-order statistics</em>. The <em>Weighted incremental algorithm</em> described can easily be generalized to higher-order statistics].
</p>
<p>Grouped computations specified with <code>g/by</code> are carried out extremely efficiently as in <code>fsum</code> (in a single pass, without splitting the data).
</p>
<p>If <code>pid</code> is used, <code>qsu</code> performs a panel-decomposition of each variable and computes 3 sets of statistics: Statistics computed on the 'Overall' (raw) data, statistics computed on the 'Between' - transformed (pid - averaged) data, and statistics computed on the 'Within' - transformed (pid - demeaned) data.
</p>
<p>More formally, let <b><code>x</code></b> (bold) be a panel vector of data for <code>N</code> individuals indexed by <code>i</code>, recorded for <code>T</code> periods, indexed by <code>t</code>. <code>xit</code> then denotes a single data-point belonging to individual <code>i</code> in time-period <code>t</code> (<code>t/T</code> must not represent time). Then <code>xi.</code> denotes the average of all values for individual <code>i</code> (averaged over <code>t</code>), and by extension <b><code>xN.</code></b> is the vector (length <code>N</code>) of such averages for all individuals. If no groups are supplied to <code>g/by</code>, the 'Between' statistics are computed on <b><code>xN.</code></b>, the vector of individual averages. (This means that for a non-balanced panel or in the presence of missing values, the 'Overall' mean computed on <b><code>x</code></b> can be slightly different than the 'Between' mean computed on <b><code>xN.</code></b>, and the variance decomposition is not exact). If groups are supplied to <code>g/by</code>, <b><code>xN.</code></b> is expanded to the vector <b><code>xi.</code></b> (length <code>N x T</code>) by replacing each value <code>xit</code> in <b><code>x</code></b> with <code>xi.</code>, while preserving missing values in <b><code>x</code></b>. Grouped Between-statistics are then computed on <b><code>xi.</code></b>, with the only difference that the number of observations ('Between-N') reported for each group is the number of distinct non-missing values of <b><code>xi.</code></b> in each group (not the total number of non-missing values of <b><code>xi.</code></b> in each group, which is already reported in 'Overall-N'). See Examples.
</p>
<p>'Within' statistics are always computed on the vector <b><code>x - xi. + x..</code></b>, where <b><code>x..</code></b> is simply the 'Overall' mean computed from <b><code>x</code></b>, which is added back to preserve the level of the data. The 'Within' mean computed on this data will always be identical to the 'Overall' mean. In the summary output, <code>qsu</code> reports not 'N', which would be identical to the 'Overall-N', but 'T', the average number of time-periods of data available for each individual obtained as 'T' = 'Overall-N / 'Between-N'. See Examples.
</p>
<p>Apart from 'N/T' and the extrema, the standard-deviations ('SD') computed on between- and within- transformed data are extremely valuable because they indicate how much of the variation in a panel-variable is between-individuals and how much of the variation is within-individuals (over time). At the extremes, variables that have common values across individuals (such as the time-variable(s) 't' in a balanced panel), can readily be identified as individual-invariant because the 'Between-SD' on this variable is 0 and the 'Within-SD' is equal to the 'Overall-SD'. Analogous, time-invariant individual characteristics (such as the individual-id 'i') have a 0 'Within-SD' and a 'Between-SD' equal to the 'Overall-SD'. See Examples.
</p>
<p>For data frame methods, if <code>labels = TRUE</code>, <code>qsu</code> uses <code>function(x) paste(names(x), setv(vlabels(x), NA, ""), sep = ": ")</code> to combine variable names and labels for display. Alternatively, the user can pass a custom function which will be applied to the data frame, e.g. using <code>labels = vlabels</code> just displays the labels. See also <code><a href="#topic+vlabels">vlabels</a></code>.
</p>
<p><code>qsu</code> comes with its own print method which by default writes out up to 9 digits at 4 decimal places. Larger numbers are printed in scientific format. for numbers between 7 and 9 digits, an apostrophe (') is placed after the 6th digit to designate the millions. Missing values are printed using '-'.
</p>
<p>The <em>sf</em> method simply ignores the geometry column.
</p>


<h3>Value</h3>

<p>A vector, matrix, array or list of matrices of summary statistics. All matrices and arrays have a class 'qsu' and a class 'table' attached.
</p>


<h3>Note</h3>

<p>In weighted summaries, observations with missing or zero weights are skipped, and thus do not affect any of the calculated statistics, including the observation count. This also implies that a logical vector passed to <code>w</code> can be used to efficiently summarize a subset of the data.
</p>


<h3>Note</h3>

<p>If weights <code>w</code> are used together with <code>pid</code>, transformed data is computed using weighted individual means i.e. weighted <b><code>xi.</code></b> and weighted <b><code>x..</code></b>. Weighted statistics are subsequently computed on this weighted-transformed data.
</p>


<h3>References</h3>

<p>Welford, B. P. (1962). Note on a method for calculating corrected sums of squares and products. <em>Technometrics</em>. 4 (3): 419-420. doi:10.2307/1266577.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+descr">descr</a></code>, <a href="#topic+summary-statistics">Summary Statistics</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## World Development Panel Data
# Simple Summaries -------------------------
qsu(wlddev)                                 # Simple summary
qsu(wlddev, labels = TRUE)                  # Display variable labels
qsu(wlddev, higher = TRUE)                  # Add skewness and kurtosis

# Grouped Summaries ------------------------
qsu(wlddev, ~ region, labels = TRUE)        # Statistics by World Bank Region
qsu(wlddev, PCGDP + LIFEEX ~ income)        # Summarize GDP per Capita and Life Expectancy by
stats &lt;- qsu(wlddev, ~ region + income,     # World Bank Income Level
             cols = 9:10, higher = TRUE)    # Same variables, by both region and income
aperm(stats)                                # A different perspective on the same stats

# Grouped summary
wlddev |&gt; fgroup_by(region) |&gt; fselect(PCGDP, LIFEEX) |&gt; qsu()

# Panel Data Summaries ---------------------
qsu(wlddev, pid = ~ iso3c, labels = TRUE)   # Adding between and within countries statistics
# -&gt; They show amongst other things that year and decade are individual-invariant,
# that we have GINI-data on only 161 countries, with only 8.42 observations per country on average,
# and that GDP, LIFEEX and GINI vary more between-countries, but ODA received varies more within
# countries over time.

# Let's do this manually for PCGDP:
x &lt;- wlddev$PCGDP
g &lt;- wlddev$iso3c

# This is the exact variance decomposion
all.equal(fvar(x), fvar(B(x, g)) + fvar(W(x, g)))

# What qsu does is calculate
r &lt;- rbind(Overall = qsu(x),
           Between = qsu(fmean(x, g)), # Aggregation instead of between-transform
           Within = qsu(fwithin(x, g, mean = "overall.mean"))) # Same as qsu(W(x, g) + fmean(x))
r[3, 1] &lt;- r[1, 1] / r[2, 1]
print.qsu(r)
# Proof:
qsu(x, pid = g)

# Using indexed data:
wldi &lt;- findex_by(wlddev, iso3c, year)   # Creating a Indexed Data Frame frame from this data
qsu(wldi)                                # Summary for pdata.frame -&gt; qsu(wlddev, pid = ~ iso3c)
qsu(wldi$PCGDP)                          # Default summary for Panel Series
qsu(G(wldi$PCGDP))                       # Summarizing GDP growth, see also ?G

# Grouped Panel Data Summaries -------------
qsu(wlddev, ~ region, ~ iso3c, cols = 9:12) # Panel-Statistics by region
psr &lt;- qsu(wldi, ~ region, cols = 9:12)     # Same on indexed data
psr                                         # -&gt; Gives a 4D array
psr[,"N/T",,]                               # Checking out the number of observations:
# In North america we only have 3 countries, for the GINI we only have 3.91 observations on average
# for 45 Sub-Saharan-African countries, etc..
psr[,"SD",,]                                # Considering only standard deviations
# -&gt; In all regions variations in inequality (GINI) between countries are greater than variations
# in inequality within countries. The opposite is true for Life-Expectancy in all regions apart
# from Europe, etc..

# Again let's do this manually for PDGCP:
d &lt;- cbind(Overall = x,
           Between = fbetween(x, g),
           Within = fwithin(x, g, mean = "overall.mean"))

r &lt;- qsu(d, g = wlddev$region)
r[,"N","Between"] &lt;- fndistinct(g[!is.na(x)], wlddev$region[!is.na(x)])
r[,"N","Within"] &lt;- r[,"N","Overall"] / r[,"N","Between"]
r

# Proof:
qsu(wlddev, PCGDP ~ region, ~ iso3c)

# Weighted Summaries -----------------------
n &lt;- nrow(wlddev)
weights &lt;- abs(rnorm(n))                    # Generate random weights
qsu(wlddev, w = weights, higher = TRUE)     # Computed weighted mean, SD, skewness and kurtosis
weightsNA &lt;- weights                        # Weights may contain missing values.. inserting 1000
weightsNA[sample.int(n, 1000)] &lt;- NA
qsu(wlddev, w = weightsNA, higher = TRUE)   # But now these values are removed from all variables

# Grouped and panel-summaries can also be weighted in the same manner

# Alternative Output Formats ---------------
# Simple case
as.data.frame(qsu(mtcars))
# For matrices can also use qDF/qDT/qTBL to assign custom name and get a character-id
qDF(qsu(mtcars), "car")
# DF from 3D array: do not combine with aperm(), might introduce wrong column labels
as.data.frame(stats, gid = "Region_Income")
# DF from 4D array: also no aperm()
as.data.frame(qsu(wlddev, ~ income, ~ iso3c, cols = 9:10), gid = "Region")

# Output as nested list
psrl &lt;- qsu(wlddev, ~ income, ~ iso3c, cols = 9:10, array = FALSE)
psrl

# We can now use unlist2d to create a tidy data frame
unlist2d(psrl, c("Variable", "Trans"), row.names = "Income")
</code></pre>

<hr>
<h2 id='qtab'>
Fast (Weighted) Cross Tabulation
</h2><span id='topic+qtab'></span><span id='topic+qtable'></span>

<h3>Description</h3>

<p>A versatile and computationally more efficient replacement for <code><a href="base.html#topic+table">table</a></code>. Notably, it also supports tabulations with frequency weights, and computation of a statistic over combinations of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtab(..., w = NULL, wFUN = NULL, wFUN.args = NULL,
     dnn = "auto", sort = .op[["sort"]], na.exclude = TRUE,
     drop = FALSE, method = "auto")

qtable(...) # Long-form. Use set_collapse(mask = "table") to replace table()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtab_+3A_...">...</code></td>
<td>

<p>atomic vectors or factors spanning the table dimensions, (optionally) with tags for the dimension names, or a data frame / list of these. See Examples.
</p>
</td></tr>
<tr><td><code id="qtab_+3A_w">w</code></td>
<td>

<p>a single vector to aggregate over the table dimensions e.g. a vector of frequency weights.
</p>
</td></tr>
<tr><td><code id="qtab_+3A_wfun">wFUN</code></td>
<td>

<p>a function used to aggregate <code>w</code> over the table dimensions. The default <code>NULL</code> computes the sum of the non-missing weights via an optimized internal algorithm. <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> also receive vectorized execution.
</p>
</td></tr>
<tr><td><code id="qtab_+3A_wfun.args">wFUN.args</code></td>
<td>

<p>a list of (optional) further arguments passed to <code>wFUN</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="qtab_+3A_dnn">dnn</code></td>
<td>

<p>the names of the table dimensions. Either passed directly as a character vector or list (internally <code><a href="base.html#topic+unlist">unlist</a></code>'ed), a function applied to the <code>...</code> list (e.g. <code><a href="base.html#topic+names">names</a></code>, or <code><a href="#topic+vlabels">vlabels</a></code>), or one of the following options:
</p>

<ul>
<li> <p><code>"auto"</code> constructs names based on the <code>...</code> arguments, or calls <code><a href="base.html#topic+names">names</a></code> if a single list is passed as input.
</p>
</li>
<li> <p><code>"namlab"</code> does the same as <code>"auto"</code>, but also calls <code><a href="#topic+vlabels">vlabels</a></code> on the list and appends the names by the variable labels.
</p>
</li></ul>

<p><code>dnn = NULL</code> will return a table without dimension names.
</p>
</td></tr>
<tr><td><code id="qtab_+3A_sort">sort</code>, <code id="qtab_+3A_na.exclude">na.exclude</code>, <code id="qtab_+3A_drop">drop</code>, <code id="qtab_+3A_method">method</code></td>
<td>

<p>arguments passed down to <code><a href="#topic+qF">qF</a></code>:
</p>

<ul>
<li> <p><code>sort = FALSE</code> orders table dimensions in first-appearance order of items in the data (can be more efficient if vectors are not factors already). Note that for factors this option will both recast levels in first-appearance order and drop unused levels.
</p>
</li>
<li> <p><code>na.exclude = FALSE</code> includes <code>NA</code>'s in the table (equivalent to <code><a href="base.html#topic+table">table</a></code>'s <code>useNA = "ifany"</code>).
</p>
</li>
<li> <p><code>drop = TRUE</code> removes any unused factor levels (= zero frequency rows or columns).
</p>
</li>
<li> <p><code>method %in% c("radix", "hash")</code> provides additional control over the algorithm used to convert atomic vectors to factors.
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>An array of class 'qtab' that inherits from 'table'. Thus all 'table' methods apply to it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+descr">descr</a></code>, <a href="#topic+summary-statistics">Summary Statistics</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic use
qtab(iris$Species)
with(mtcars, qtab(vs, am))
qtab(mtcars[.c(vs, am)])

library(magrittr)
iris %$% qtab(Sepal.Length &gt; mean(Sepal.Length), Species)
iris %$% qtab(AMSL = Sepal.Length &gt; mean(Sepal.Length), Species)

## World after 2015
wlda15 &lt;- wlddev |&gt; fsubset(year &gt;= 2015) |&gt; collap(~ iso3c)

# Regions and income levels (country frequency)
wlda15 %$% qtab(region, income)
wlda15 %$% qtab(region, income, dnn = vlabels)
wlda15 %$% qtab(region, income, dnn = "namlab")

# Population (millions)
wlda15 %$% qtab(region, income, w = POP) |&gt; divide_by(1e6)

# Life expectancy (years)
wlda15 %$% qtab(region, income, w = LIFEEX, wFUN = fmean)

# Life expectancy (years), weighted by population
wlda15 %$% qtab(region, income, w = LIFEEX, wFUN = fmean,
                  wFUN.args = list(w = POP))

# GDP per capita (constant 2010 US$): median
wlda15 %$% qtab(region, income, w = PCGDP, wFUN = fmedian,
                  wFUN.args = list(na.rm = TRUE))

# GDP per capita (constant 2010 US$): median, weighted by population
wlda15 %$% qtab(region, income, w = PCGDP, wFUN = fmedian,
                  wFUN.args = list(w = POP))

# Including OECD membership
tab &lt;- wlda15 %$% qtab(region, income, OECD)
tab

# Various 'table' methods
tab |&gt; addmargins()
tab |&gt; marginSums(margin = c("region", "income"))
tab |&gt; proportions()
tab |&gt; proportions(margin = "income")
as.data.frame(tab) |&gt; head(10)
ftable(tab, row.vars = c("region", "OECD"))

# Other options
tab |&gt; fsum(TRA = "%")    # Percentage table (on a matrix use fsum.default)
tab %/=% (sum(tab)/100)    # Another way (division by reference, preserves integers)
tab

rm(tab, wlda15)
</code></pre>

<hr>
<h2 id='quick-conversion'>Quick Data Conversion</h2><span id='topic+A4-quick-conversion'></span><span id='topic+quick-conversion'></span><span id='topic+qDF'></span><span id='topic+qDT'></span><span id='topic+qTBL'></span><span id='topic+qM'></span><span id='topic+mctl'></span><span id='topic+mrtl'></span><span id='topic+as_numeric_factor'></span><span id='topic+as_character_factor'></span>

<h3>Description</h3>

<p>Fast, flexible and precise conversion of common data objects, without method dispatch and extensive checks:
</p>

<ul>
<li> <p><code>qDF</code>, <code>qDT</code> and <code>qTBL</code> convert vectors, matrices, higher-dimensional arrays and suitable lists to data frame, <em>data.table</em> and <em>tibble</em>, respectively.
</p>
</li>
<li> <p><code>qM</code> converts vectors, higher-dimensional arrays, data frames and suitable lists to matrix.
</p>
</li>
<li> <p><code>mctl</code> and <code>mrtl</code> column- or row-wise convert a matrix to list, data frame or <em>data.table</em>. They are used internally by <code>qDF/qDT/qTBL</code>, <code><a href="#topic+dapply">dapply</a></code>, <code><a href="#topic+BY">BY</a></code>, etc...
</p>
</li>
<li> <p><code><a href="#topic+qF">qF</a></code> converts atomic vectors to factor (documented on a separate page).
</p>
</li>
<li> <p><code>as_numeric_factor</code> and <code>as_character_factor</code> convert factors, or all factor columns in a data frame / list, to character or numeric (by converting the levels).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'># Converting between matrices, data frames / tables / tibbles

 qDF(X, row.names.col = FALSE, keep.attr = FALSE, class = "data.frame")
 qDT(X, row.names.col = FALSE, keep.attr = FALSE, class = c("data.table", "data.frame"))
qTBL(X, row.names.col = FALSE, keep.attr = FALSE, class = c("tbl_df","tbl","data.frame"))
  qM(X, row.names.col = NULL , keep.attr = FALSE, class = NULL, sep = ".")

# Programmer functions: matrix rows or columns to list / DF / DT - fully in C++

mctl(X, names = FALSE, return = "list")
mrtl(X, names = FALSE, return = "list")

# Converting factors or factor columns

  as_numeric_factor(X, keep.attr = TRUE)
as_character_factor(X, keep.attr = TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quick-conversion_+3A_x">X</code></td>
<td>
<p>a vector, factor, matrix, higher-dimensional array, data frame or list. <code>mctl</code> and <code>mrtl</code> only accept matrices, <code>as_numeric_factor</code> and <code>as_character_factor</code> only accept factors, data frames or lists.</p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_row.names.col">row.names.col</code></td>
<td>
<p>can be used to add an column saving names or row.names when converting objects to data frame using <code>qDF/qDT/qTBL</code>. <code>TRUE</code> will add a column <code>"row.names"</code>, or you can supply a name e.g. <code>row.names.col = "variable"</code>. With <code>qM</code>, the argument has the opposite meaning, and can be used to select one or more columns in a data frame/list which will be used to create the rownames of the matrix e.g. <code>qM(iris, row.names.col = "Species")</code>. In this case the column(s) can be specified using names, indices, a logical vector or a selector function. See Examples.</p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_keep.attr">keep.attr</code></td>
<td>
<p>logical. <code>FALSE</code> (default) yields a <em>hard</em> / <em>thorough</em> object conversion: All unnecessary attributes are removed from the object yielding a plain matrix / data.frame / <em>data.table</em>. <code>FALSE</code> yields a <em>soft</em> / <em>minimal</em> object conversion: Only the attributes 'names', 'row.names', 'dim', 'dimnames' and 'levels' are modified in the conversion. Other attributes are preserved. See also <code>class</code>.</p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_class">class</code></td>
<td>
<p>if a vector of classes is passed here, the converted object will be assigned these classes. If <code>NULL</code> is passed, the default classes are assigned: <code>qM</code> assigns no class, <code>qDF</code> a class <code>"data.frame"</code>, and <code>qDT</code> a class <code>c("data.table", "data.frame")</code>. If <code>keep.attr = TRUE</code> and <code>class = NULL</code> and the object already inherits the default classes, further inherited classes are preserved. See Details and the Example. </p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_sep">sep</code></td>
<td>
<p>character. Separator used for interacting multiple variables selected through <code>row.names.col</code>.</p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_names">names</code></td>
<td>
<p>logical. Should the list be named using row/column names from the matrix?</p>
</td></tr>
<tr><td><code id="quick-conversion_+3A_return">return</code></td>
<td>
<p>an integer or string specifying what to return. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "list"   </td><td style="text-align: left;"></td><td style="text-align: left;"> returns a plain list </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "data.frame" </td><td style="text-align: left;"></td><td style="text-align: left;"> returns a plain data.frame </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "data.table"   </td><td style="text-align: left;"></td><td style="text-align: left;"> returns a plain <em>data.table</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr>
</table>


<h3>Details</h3>

<p>Object conversions using these functions are maximally efficient and involve 3 consecutive steps: (1) Converting the storage mode / dimensions / data of the object, (2) converting / modifying the attributes and (3) modifying the class of the object:
</p>
<p>(1) is determined by the choice of function and the optional <code>row.names.col</code> argument. Higher-dimensional arrays are converted by expanding the second dimension (adding columns, same as <code>as.matrix, as.data.frame, as.data.table</code>).
</p>
<p>(2) is determined by the <code>keep.attr</code> argument: <code>keep.attr = TRUE</code> seeks to preserve the attributes of the object. Its effect is like copying <code>attributes(converted) &lt;- attributes(original)</code>, and then modifying the <code>"dim", "dimnames", "names", "row.names"</code> and <code>"levels"</code> attributes as necessitated by the conversion task. <code>keep.attr = FALSE</code> only converts / assigns / removes these attributes and drops all others.
</p>
<p>(3) is determined by the <code>class</code> argument: Setting <code>class = "myclass"</code> will yield a converted object of class <code>"myclass"</code>, with any other / prior classes being removed by this replacement. Setting <code>class = NULL</code> does NOT mean that a class <code>NULL</code> is assigned (which would remove the class attribute), but rather that the default classes are assigned: <code>qM</code> assigns no class, <code>qDF</code> a class <code>"data.frame"</code>, and <code>qDT</code> a class <code>c("data.table", "data.frame")</code>. At this point there is an interaction with <code>keep.attr</code>: If <code>keep.attr = TRUE</code> and <code>class = NULL</code> and the object converted already inherits the respective default classes, then any other inherited classes will also be preserved (with <code>qM(x, keep.attr = TRUE, class = NULL)</code> any class will be preserved if <code>is.matrix(x)</code> evaluates to <code>TRUE</code>.)
</p>
<p>The default <code>keep.attr = FALSE</code> ensures <em>hard</em> conversions so that all unnecessary attributes are dropped. Furthermore in <code>qDF/qDT/qTBL</code> the default classes were explicitly assigned. This is to ensure that the default methods apply, even if the user chooses to preserve further attributes. For <code>qM</code> a more lenient default setup was chosen to enable the full preservation of time series matrices with <code>keep.attr = TRUE</code>. If the user wants to keep attributes attached to a matrix but make sure that all default methods work properly, either one of <code>qM(x, keep.attr = TRUE, class = "matrix")</code> or <code>unclass(qM(x, keep.attr = TRUE))</code> should be employed.
</p>


<h3>Value</h3>

<p><code>qDF</code> - returns a data.frame<br />
<code>qDT</code> - returns a <em>data.table</em><br />
<code>qTBL</code> - returns a <em>tibble</em><br />
<code>qM</code> - returns a matrix<br />
<code>mctl</code>, <code>mrtl</code> - return a list, data frame or <em>data.table</em> <br />
<code>qF</code> - returns a factor<br />
<code>as_numeric_factor</code> - returns X with factors converted to numeric variables<br />
<code>as_character_factor</code> - returns X with factors converted to character variables
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qF">qF</a></code>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic Examples
mtcarsM &lt;- qM(mtcars)                   # Matrix from data.frame
mtcarsDT &lt;- qDT(mtcarsM)                # data.table from matrix columns
mtcarsTBL &lt;- qTBL(mtcarsM)              # tibble from matrix columns
head(mrtl(mtcarsM, TRUE, "data.frame")) # data.frame from matrix rows, etc..
head(qDF(mtcarsM, "cars"))              # Adding a row.names column when converting from matrix
head(qDT(mtcars, "cars"))               # Saving row.names when converting data frame to data.table
head(qM(iris, "Species"))               # Examples converting data to matrix, saving information
head(qM(GGDC10S, is.character))         # as rownames
head(qM(gv(GGDC10S, -(2:3)), 1:3, sep = "-")) # plm-style rownames

# mrtl() and mctl() are very useful for iteration over matrices
# Think of a coordninates matrix e.g. from sf::st_coordinates()
coord &lt;- matrix(rnorm(10), ncol = 2, dimnames = list(NULL, c("X", "Y")))
# Then we can
for (d in mrtl(coord)) {
  cat("lon =", d[1], ", lat =", d[2], fill = TRUE)
  # do something complicated ...
}
rm(coord)

## Factors
cylF &lt;- qF(mtcars$cyl)                  # Factor from atomic vector
cylF

# Factor to numeric conversions
identical(mtcars,  as_numeric_factor(dapply(mtcars, qF)))


</code></pre>

<hr>
<h2 id='radixorder'>
Fast Radix-Based Ordering
</h2><span id='topic+radixorder'></span><span id='topic+radixorderv'></span>

<h3>Description</h3>

<p>A slight modification of <code><a href="base.html#topic+order">order(..., method = &quot;radix&quot;)</a></code> that is more programmer friendly and, importantly, provides features for ordered grouping of data (similar to <code>data.table:::forderv</code> which has more or less the same source code). <code>radixorderv</code> is a programmers version directly supporting vector and list input. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radixorder(..., na.last = TRUE, decreasing = FALSE, starts = FALSE,
           group.sizes = FALSE, sort = TRUE)

radixorderv(x, na.last = TRUE, decreasing = FALSE, starts = FALSE,
            group.sizes = FALSE, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radixorder_+3A_...">...</code></td>
<td>
<p>comma-separated atomic vectors to order.
</p>
</td></tr>
<tr><td><code id="radixorder_+3A_x">x</code></td>
<td>

<p>an atomic vector or list of atomic vectors such as a data frame.
</p>
</td></tr>
<tr><td><code id="radixorder_+3A_na.last">na.last</code></td>
<td>
<p>logical. for controlling the treatment of <code>NA</code>'s. If <code>TRUE</code>, missing values in the data are put last; if <code>FALSE</code>, they are put first; if NA, they are removed.
</p>
</td></tr>
<tr><td><code id="radixorder_+3A_decreasing">decreasing</code></td>
<td>

<p>logical. Should the sort order be increasing or decreasing? Can be a vector of length equal to the number of arguments in <code>...</code> / <code>x</code>.
</p>
</td></tr>
<tr><td><code id="radixorder_+3A_starts">starts</code></td>
<td>
<p>logical. <code>TRUE</code> returns an attribute 'starts' containing the first element of each new group i.e. the row denoting the start of each new group if the data were sorted using the computed ordering vector. See Examples.

</p>
</td></tr>
<tr><td><code id="radixorder_+3A_group.sizes">group.sizes</code></td>
<td>
<p>logical. <code>TRUE</code> returns an attribute 'group.sizes' containing sizes of each group in the same order as groups are encountered if the data were sorted using the computed ordering vector. See Examples.
</p>
</td></tr>
<tr><td><code id="radixorder_+3A_sort">sort</code></td>
<td>
<p>logical. This argument only affects character vectors / columns passed. If <code>FALSE</code>, these are not ordered but simply grouped in the order of first appearance of unique elements. This provides a slight performance gain if only grouping but not alphabetic ordering is required. See also <code><a href="#topic+group">group</a></code>.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer ordering vector with attributes: Unless <code>na.last = NA</code> an attribute <code>"sorted"</code> indicating whether the input data was already sorted is attached. If <code>starts = TRUE</code>, <code>"starts"</code> giving a vector of group starts in the ordered data, and if <code>group.sizes = TRUE</code>, <code>"group.sizes"</code> giving the vector of group sizes are attached. In either case an attribute <code>"maxgrpn"</code> providing the size of the largest group is also attached.
</p>


<h3>Author(s)</h3>

<p>The C code was taken - with slight modifications - from <a href="https://github.com/wch/r-source/blob/79298c499218846d14500255efd622b5021c10ec/src/main/radixsort.c">base R source code</a>, and is originally due to <em>data.table</em> authors Matt Dowle and Arun Srinivasan.
</p>


<h3>See Also</h3>

<p><a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>radixorder(mtcars$mpg)
head(mtcars[radixorder(mtcars$mpg), ])
radixorder(mtcars$cyl, mtcars$vs)

o &lt;- radixorder(mtcars$cyl, mtcars$vs, starts = TRUE)
st &lt;- attr(o, "starts")
head(mtcars[o, ])
mtcars[o[st], c("cyl", "vs")]  # Unique groups

# Note that if attr(o, "sorted") == TRUE, then all(o[st] == st)
radixorder(rep(1:3, each = 3), starts = TRUE)

# Group sizes
radixorder(mtcars$cyl, mtcars$vs, group.sizes = TRUE)

# Both
radixorder(mtcars$cyl, mtcars$vs, starts = TRUE, group.sizes = TRUE)

</code></pre>

<hr>
<h2 id='rapply2d'>
Recursively Apply a Function to a List of Data Objects
</h2><span id='topic+rapply2d'></span>

<h3>Description</h3>

<p><code>rapply2d</code> is a recursive version of <code>lapply</code> with three differences to <code><a href="base.html#topic+rapply">rapply</a></code>:
</p>

<ol>
<li><p> data frames (or other list-based objects specified in <code>classes</code>) are considered as atomic, not as (sub-)lists
</p>
</li>
<li> <p><code>FUN</code> is applied to all 'atomic' objects in the nested list
</p>
</li>
<li><p> the result is not simplified / unlisted.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>rapply2d(l, FUN, ..., classes = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapply2d_+3A_l">l</code></td>
<td>
<p>a list.</p>
</td></tr>
<tr><td><code id="rapply2d_+3A_fun">FUN</code></td>
<td>
<p>a function that can be applied to all 'atomic' elements in l.</p>
</td></tr>
<tr><td><code id="rapply2d_+3A_...">...</code></td>
<td>
<p>additional elements passed to FUN.</p>
</td></tr>
<tr><td><code id="rapply2d_+3A_classes">classes</code></td>
<td>
<p>character. Classes of list-based objects inside <code>l</code> that should be considered as atomic. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same structure as <code>l</code>, where <code>FUN</code> was applied to all atomic elements and list-based objects of a class included in <code>classes</code>.
</p>


<h3>Note</h3>

<p>The main reason <code>rapply2d</code> exists is to have a recursive function that out-of-the-box applies a function to a nested list of data frames.
</p>
<p>For most other purposes <code><a href="base.html#topic+rapply">rapply</a></code>, or by extension the excellent <a href="https://cran.r-project.org/package=rrapply">rrapply</a> function / package, provide more advanced functionality and greater performance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsplit">rsplit</a></code>, <code><a href="#topic+unlist2d">unlist2d</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- list(mtcars, list(mtcars, as.matrix(mtcars)))
rapply2d(l, fmean)
unlist2d(rapply2d(l, fmean))
</code></pre>

<hr>
<h2 id='recode-replace'>
Recode and Replace Values in Matrix-Like Objects
</h2><span id='topic+AA1-recode-replace'></span><span id='topic+recode-replace'></span><span id='topic+recode_num'></span><span id='topic+recode_char'></span><span id='topic+replace_na'></span><span id='topic+replace_inf'></span><span id='topic+replace_outliers'></span>

<h3>Description</h3>

<p>A small suite of functions to efficiently perform common recoding and replacing tasks in matrix-like objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_num(X, ..., default = NULL, missing = NULL, set = FALSE)

recode_char(X, ..., default = NULL, missing = NULL, regex = FALSE,
            ignore.case = FALSE, fixed = FALSE, set = FALSE)

replace_na(X, value = 0, cols = NULL, set = FALSE, type = "const")

replace_inf(X, value = NA, replace.nan = FALSE, set = FALSE)

replace_outliers(X, limits, value = NA,
                 single.limit = c("sd", "mad", "min", "max"),
                 ignore.groups = FALSE, set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode-replace_+3A_x">X</code></td>
<td>
<p>a vector, matrix, array, data frame or list of atomic objects. <code>replace_outliers</code> has internal methods for <a href="#topic+fgroup_by">grouped</a> and <a href="#topic+findex_by">indexed</a> data.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_...">...</code></td>
<td>
<p>comma-separated recode arguments of the form: <code>value = replacement, `2` = 0, Secondary = "SEC"</code> etc. <code>recode_char</code> with <code>regex = TRUE</code> also supports regular expressions i.e. <code>`^S|D$` = "STD"</code> etc.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_default">default</code></td>
<td>
<p>optional argument to specify a scalar value to replace non-matched elements with.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_missing">missing</code></td>
<td>
<p>optional argument to specify a scalar value to replace missing elements with. <em>Note</em> that to increase efficiency this is done before the rest of the recoding i.e. the recoding is performed on data where missing values are filled!</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_set">set</code></td>
<td>
<p>logical. <code>TRUE</code> does replacements by reference (i.e. in-place modification of the data) and returns the result invisibly.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_type">type</code></td>
<td>
<p>character. One of <code>"const"</code>, <code>"locf"</code> (last non-missing observation carried forward) or <code>"focb"</code> (first non-missing observation carried back). The latter two ignore <code>value</code>.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_regex">regex</code></td>
<td>
<p>logical. If <code>TRUE</code>, all recode-argument names are (sequentially) passed to <code><a href="base.html#topic+grepl">grepl</a></code> as a pattern to search <code>X</code>. All matches are replaced. <em>Note</em> that <code>NA</code>'s are also matched as strings by <code>grepl</code>. </p>
</td></tr>
<tr><td><code id="recode-replace_+3A_value">value</code></td>
<td>
<p>a single (scalar) value to replace matching elements with. In <code>replace_outliers</code> setting <code>value = "clip"</code> will replace outliers with the corresponding threshold values. See Examples.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_cols">cols</code></td>
<td>
<p>select columns to replace missing values in using a function, column names, indices or a logical vector.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_replace.nan">replace.nan</code></td>
<td>
<p>logical. <code>TRUE</code> replaces <code>NaN/Inf/-Inf</code>. <code>FALSE</code> (default) replaces only <code>Inf/-Inf</code>.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_limits">limits</code></td>
<td>
<p>either a vector of two-numeric values <code>c(minval, maxval)</code> constituting a two-sided outlier threshold, or a single numeric value:</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_single.limit">single.limit</code></td>
<td>
<p>character, controls the behavior if <code>length(limits) == 1</code>:
</p>

<ul>
<li> <p><code>"sd"/"mad":</code> <code>limits</code> will be interpreted as a (two-sided) outlier threshold in terms of (column) standard deviations/median absolute deviations. For the standard deviation this is equivalent to <code>X[abs(fscale(X)) &gt; limits] &lt;- value</code>. Since <code>fscale</code> is S3 generic with methods for 'grouped_df', 'pseries' and 'pdata.frame', the standardizing will be grouped if such objects are passed (i.e. the outlier threshold is then measured in within-group standard deviations) unless <code>ignore.groups = TRUE</code>. The same holds for median absolute deviations.
</p>
</li>
<li> <p><code>"min"/"max":</code> <code>limits</code> will be interpreted as a (one-sided) minimum/maximum threshold. The underlying code is equivalent to <code>X[X &lt;/&gt; limits] &lt;- value</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="recode-replace_+3A_ignore.groups">ignore.groups</code></td>
<td>
<p>logical. If <code>length(limits) == 1</code> and <code>single.limit %in% c("sd", "mad")</code> and <code>X</code> is a 'grouped_df', 'pseries' or 'pdata.frame', <code>TRUE</code> will ignore the grouped nature of the data and calculate outlier thresholds on the entire dataset rather than within each group.</p>
</td></tr>
<tr><td><code id="recode-replace_+3A_ignore.case">ignore.case</code>, <code id="recode-replace_+3A_fixed">fixed</code></td>
<td>
<p>logical. Passed to <code><a href="base.html#topic+grepl">grepl</a></code> and only applicable if <code>regex = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>recode_num</code> and <code>recode_char</code> can be used to efficiently recode multiple numeric or character values, respectively. The syntax is inspired by <code>dplyr::recode</code>, but the functionality is enhanced in the following respects: (1) when passed a data frame / list, all appropriately typed columns will be recoded. (2) They preserve the attributes of the data object and of columns in a data frame / list, and (3) <code>recode_char</code> also supports regular expression matching using <code><a href="base.html#topic+grepl">grepl</a></code>.
</p>
</li>
<li> <p><code>replace_na</code> efficiently replaces <code>NA/NaN</code> with a value (default is <code>0</code>). data can be multi-typed, in which case appropriate columns can be selected through the <code>cols</code> argument. For numeric data a more versatile alternative is provided by <code>data.table::nafill</code> and <code>data.table::setnafill</code>.
</p>
</li>
<li> <p><code>replace_inf</code> replaces <code>Inf/-Inf</code> (or optionally <code>NaN/Inf/-Inf</code>) with a value (default is <code>NA</code>). It skips non-numeric columns in a data frame.
</p>
</li>
<li> <p><code>replace_outliers</code> replaces values falling outside a 1- or 2-sided numeric threshold or outside a certain number of standard deviations or median absolute deviation with a value (default is <code>NA</code>). It skips non-numeric columns in a data frame.
</p>
</li></ul>



<h3>Note</h3>

<p>These functions are not generic and do not offer support for factors or date(-time) objects. see <code>dplyr::recode_factor</code>, <em>forcats</em> and other appropriate packages for dealing with these classes.
</p>
<p>Simple replacing tasks on a vector can also effectively be handled by, <code><a href="#topic+setv">setv</a></code> / <code><a href="#topic+copyv">copyv</a></code>. Fast vectorized switches are offered by package <em>kit</em> (functions <code>iif</code>, <code>nif</code>, <code>vswitch</code>, <code>nswitch</code>) as well as <code>data.table::fcase</code> and <code>data.table::fifelse</code>. Using switches is more efficient than <code>recode_*</code>, as <code>recode_*</code> creates an internal copy of the object to enable cross-replacing.
</p>
<p>Function <code><a href="#topic+TRA">TRA</a></code>, and the associated <code>TRA</code> ('transform') argument to <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> also has option <code>"replace_na"</code>, to replace missing values with a statistic computed on the non-missing observations, e.g. <code>fmedian(airquality, TRA = "replace_na")</code> does median imputation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pad">pad</a></code>, <a href="#topic+efficient-programming">Efficient Programming</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recode_char(c("a","b","c"), a = "b", b = "c")
recode_char(month.name, ber = NA, regex = TRUE)
mtcr &lt;- recode_num(mtcars, `0` = 2, `4` = Inf, `1` = NaN)
replace_inf(mtcr)
replace_inf(mtcr, replace.nan = TRUE)
replace_outliers(mtcars, c(2, 100))                 # Replace all values below 2 and above 100 w. NA
replace_outliers(mtcars, c(2, 100), value = "clip") # Clipping outliers to the thresholds
replace_outliers(mtcars, 2, single.limit = "min")   # Replace all value smaller than 2 with NA
replace_outliers(mtcars, 100, single.limit = "max") # Replace all value larger than 100 with NA
replace_outliers(mtcars, 2)                         # Replace all values above or below 2 column-
                                                    # standard-deviations from the column-mean w. NA
replace_outliers(fgroup_by(iris, Species), 2)       # Passing a grouped_df, pseries or pdata.frame
                                                    # allows to remove outliers according to
                                                    # in-group standard-deviation. see ?fscale
</code></pre>

<hr>
<h2 id='rowbind'>
Row-Bind Lists / Data Frame-Like Objects
</h2><span id='topic+rowbind'></span>

<h3>Description</h3>

<p><em>collapse</em>'s version of <code>data.table::rbindlist</code> and <code>rbind.data.frame</code>. The core code is copied from <em>data.table</em>, which deserves all credit for the implementation. <code>rowbind</code> only binds lists/data.frame's. For a more flexible recursive version see <code><a href="#topic+unlist2d">unlist2d</a></code>. To combine lists column-wise see <code><a href="#topic+add_vars">add_vars</a></code> or <code><a href="#topic+ftransform">ftransform</a></code> (with replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowbind(..., idcol = NULL, row.names = FALSE,
        use.names = TRUE, fill = FALSE, id.factor = "auto",
        return = c("as.first", "data.frame", "data.table", "tibble", "list"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowbind_+3A_...">...</code></td>
<td>
<p>a single list of list-like objects (data.frames) or comma separated objects (internally assembled using <code>list(...)</code>). Names can be supplied if <code>!is.null(idcol)</code>.</p>
</td></tr>
<tr><td><code id="rowbind_+3A_idcol">idcol</code></td>
<td>
<p>character. The name of an id-column to be generated identifying the source of rows in the final object. Using <code>idcol = TRUE</code> will set the name to <code>".id"</code>. If the input list has names, these will form the content of the id column, otherwise integers are used. To save memory, it is advised to keep <code>id.factor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowbind_+3A_row.names">row.names</code></td>
<td>
<p><code>TRUE</code> extracts row names from all the objects in <code>l</code> and adds them to the output in a column named <code>"row.names"</code>. Alternatively, a column name i.e. <code>row.names = "variable"</code> can be supplied. </p>
</td></tr>
<tr><td><code id="rowbind_+3A_use.names">use.names</code></td>
<td>
<p>logical. <code>TRUE</code> binds by matching column name, <code>FALSE</code> by position. </p>
</td></tr>
<tr><td><code id="rowbind_+3A_fill">fill</code></td>
<td>
<p>logical. <code>TRUE</code> fills missing columns with NAs. When <code>TRUE</code>, <code>use.names</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rowbind_+3A_id.factor">id.factor</code></td>
<td>
<p>if <code>TRUE</code> and <code>!isFALSE(idcols)</code>, create id column as factor instead of character or integer vector. It is also possible to specify <code>"ordered"</code> to generate an ordered factor id. <code>"auto"</code> uses <code>TRUE</code> if <code>!is.null(names(l))</code> where <code>l</code> is the input list (because factors are much more memory efficient than character vectors). </p>
</td></tr>
<tr><td><code id="rowbind_+3A_return">return</code></td>
<td>
<p>an integer or string specifying what to return. <code>1 - "as.first"</code> preserves the attributes of the first element of the list, <code>2/3/4 - "data.frame"/"data.table"/"tibble"</code> coerces to specific objects, and <code>5 - "list"</code> returns a (named) list. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a long list or data frame-like object formed by combining the rows / elements of the input objects. The <code>return</code> argument controls the exact format of the output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unlist2d">unlist2d</a></code>, <code><a href="#topic+add_vars">add_vars</a></code>, <code><a href="#topic+ftransform">ftransform</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These are the same
rowbind(mtcars, mtcars)
rowbind(list(mtcars, mtcars))

# With id column
rowbind(mtcars, mtcars, idcol = "id")
rowbind(a = mtcars, b = mtcars, idcol = "id")

# With saving row-names
rowbind(mtcars, mtcars, row.names = "cars")
rowbind(a = mtcars, b = mtcars, idcol = "id", row.names = "cars")

# Filling up columns
rowbind(mtcars, mtcars[2:8], fill = TRUE)
</code></pre>

<hr>
<h2 id='roworder'>
Fast Reordering of Data Frame Rows
</h2><span id='topic+roworder'></span><span id='topic+roworderv'></span>

<h3>Description</h3>

<p>A fast substitute for <code>dplyr::arrange</code>. It returns a sorted copy of the data frame, unless the data is already sorted in which case no copy is made. In addition, rows can be manually re-ordered. Use <code>data.table::setorder</code> to sort a data frame without creating a copy. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roworder(X, ..., na.last = TRUE, verbose = .op[["verbose"]])

roworderv(X, cols = NULL, neworder = NULL, decreasing = FALSE,
          na.last = TRUE, pos = "front", verbose = .op[["verbose"]])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roworder_+3A_x">X</code></td>
<td>
<p>a data frame or list of equal-length columns. </p>
</td></tr>
<tr><td><code id="roworder_+3A_...">...</code></td>
<td>
<p>comma-separated columns of <code>X</code> to sort by e.g. <code>var1, var2</code>. Negatives i.e. <code>-var1, var2</code> can be used to sort in decreasing order of <code>var1</code>. Internally all expressions are turned into strings and <code>startsWith(expr, "-")</code> is used to detect this, thus it does not negate the actual values (which may as well be strings), and you cannot apply any other functions to columns inside <code>roworder()</code> to induce different sorting behavior.</p>
</td></tr>
<tr><td><code id="roworder_+3A_cols">cols</code></td>
<td>
<p>select columns to sort by using a function, column names, indices or a logical vector. The default <code>NULL</code> sorts by all columns in order of occurrence (from left to right). </p>
</td></tr>
<tr><td><code id="roworder_+3A_na.last">na.last</code></td>
<td>
<p>logical. If <code>TRUE</code>, missing values in the sorting columns are placed last; if <code>FALSE</code>, they are placed first; if <code>NA</code> they are removed (argument passed to <code><a href="#topic+radixorderv">radixorderv</a></code>).</p>
</td></tr>
<tr><td><code id="roworder_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or decreasing? Can also be a vector of length equal to the number of arguments in <code>cols</code> (argument passed to <code><a href="#topic+radixorderv">radixorderv</a></code>).</p>
</td></tr>
<tr><td><code id="roworder_+3A_neworder">neworder</code></td>
<td>
<p>an ordering vector, can be <code>&lt; nrow(X)</code>. if <code>pos = "front"</code> or <code>pos = "end"</code>, a logical vector can also be supplied. This argument overwrites <code>cols</code>.</p>
</td></tr>
<tr><td><code id="roworder_+3A_pos">pos</code></td>
<td>
<p>integer or character. Different arrangement options if <code>!is.null(neworder) &amp;&amp; length(neworder) &lt; nrow(X)</code>.
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "front"   </td><td style="text-align: left;"></td><td style="text-align: left;"> move rows in <code>neworder</code> to the front (top) of <code>X</code> (the default). </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "end" </td><td style="text-align: left;"></td><td style="text-align: left;"> move rows in <code>neworder</code> to the end (bottom) of <code>X</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "exchange"   </td><td style="text-align: left;"></td><td style="text-align: left;"> just exchange the order of rows in <code>neworder</code>, other rows remain in the same position. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "after"  </td><td style="text-align: left;"></td><td style="text-align: left;"> place all further selected rows behind the first selected row. </td>
</tr>
<tr>
 <td style="text-align: left;">

  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="roworder_+3A_verbose">verbose</code></td>
<td>
<p>logical. <code>TRUE</code> (default) prints a message when ordering a grouped or indexed frame, indicating that this is not efficient and encouraging reordering the data prior to the grouping/indexing step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>X</code> with rows reordered. If <code>X</code> is already sorted, <code>X</code> is simply returned.
</p>


<h3>Note</h3>

<p>If you don't require a copy of the data, use <code>data.table::setorder</code> (you can also use it in a piped call as it invisibly returns the data).
</p>
<p><code>roworder(v)</code> has internal facilities to deal with <a href="#topic+indexing">indexed data</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorder">colorder</a></code>, <a href="#topic+fast-data-manipulation">Data Frame Manipulation</a>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(roworder(airquality, Month, -Ozone))
head(roworder(airquality, Month, -Ozone, na.last = NA))  # Removes the missing values in Ozone

## Same in standard evaluation
head(roworderv(airquality, c("Month", "Ozone"), decreasing = c(FALSE, TRUE)))
head(roworderv(airquality, c("Month", "Ozone"), decreasing = c(FALSE, TRUE), na.last = NA))

## Custom reordering
head(roworderv(mtcars, neworder = 3:4))               # Bring rows 3 and 4 to the front
head(roworderv(mtcars, neworder = 3:4, pos = "end"))  # Bring them to the end
head(roworderv(mtcars, neworder = mtcars$vs == 1))    # Bring rows with vs == 1 to the top
</code></pre>

<hr>
<h2 id='rsplit'>
Fast (Recursive) Splitting
</h2><span id='topic+rsplit'></span><span id='topic+rsplit.default'></span><span id='topic+rsplit.matrix'></span><span id='topic+rsplit.data.frame'></span>

<h3>Description</h3>

<p><code>rsplit</code> (recursively) splits a vector, matrix or data frame into subsets according to combinations of (multiple) vectors / factors and returns a (nested) list. If <code>flatten = TRUE</code>, the list is flattened yielding the same result as <code><a href="base.html#topic+split">split</a></code>. <code>rsplit</code> is implemented as a wrapper around <code><a href="#topic+gsplit">gsplit</a></code>, and significantly faster than <code><a href="base.html#topic+split">split</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsplit(x, ...)

## Default S3 method:
rsplit(x, fl, drop = TRUE, flatten = FALSE, use.names = TRUE, ...)

## S3 method for class 'matrix'
rsplit(x, fl, drop = TRUE, flatten = FALSE, use.names = TRUE,
       drop.dim = FALSE, ...)

## S3 method for class 'data.frame'
rsplit(x, by, drop = TRUE, flatten = FALSE, cols = NULL,
       keep.by = FALSE, simplify = TRUE, use.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsplit_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data.frame or list like object.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_fl">fl</code></td>
<td>
<p>a <code><a href="#topic+GRP">GRP</a></code> object, or a (list of) vector(s) / factor(s) (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object(s)) used to split <code>x</code>.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_by">by</code></td>
<td>
<p><em>data.frame method</em>: Same as <code>fl</code>, but also allows one- or two-sided formulas i.e. <code>~ group1</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_drop">drop</code></td>
<td>
<p>logical. <code>TRUE</code> removes unused levels or combinations of levels from factors before splitting; <code>FALSE</code> retains those combinations yielding empty list elements in the output.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_flatten">flatten</code></td>
<td>
<p>logical. If <code>fl</code> is a list of vectors / factors, <code>TRUE</code> calls <code><a href="#topic+GRP">GRP</a></code> on the list, creating a single grouping used for splitting; <code>FALSE</code> yields recursive splitting.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_use.names">use.names</code></td>
<td>
<p>logical. <code>TRUE</code> returns a named list (like <code><a href="base.html#topic+split">split</a></code>); <code>FALSE</code> returns a plain list.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_drop.dim">drop.dim</code></td>
<td>
<p>logical. <code>TRUE</code> returns atomic vectors for matrix-splits consisting of one row. </p>
</td></tr>
<tr><td><code id="rsplit_+3A_cols">cols</code></td>
<td>
<p><em>data.frame method</em>: Select columns to split using a function, column names, indices or a logical vector. <em>Note</em>: <code>cols</code> is ignored if a two-sided formula is passed to <code>by</code>.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_keep.by">keep.by</code></td>
<td>
<p>logical. If a formula is passed to <code>by</code>, then <code>TRUE</code> preserves the splitting (right-hand-side) variables in the data frame.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_simplify">simplify</code></td>
<td>
<p><em>data.frame method</em>: Logical. <code>TRUE</code> calls <code>rsplit.default</code> if a single column is split e.g. <code>rsplit(data, col1 ~ group1)</code> becomes the same as <code>rsplit(data$col1, data$group1)</code>.</p>
</td></tr>
<tr><td><code id="rsplit_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+GRP">GRP</a></code>. Sensible choices would be <code>sort = FALSE</code>, <code>decreasing = TRUE</code> or <code>na.last = FALSE</code>. Note that these options only apply if <code>fl</code> is not already a (list of) factor(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (nested) list containing the subsets of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsplit">gsplit</a></code>, <code><a href="#topic+rapply2d">rapply2d</a></code>, <code><a href="#topic+unlist2d">unlist2d</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rsplit(mtcars$mpg, mtcars$cyl)
rsplit(mtcars, mtcars$cyl)

rsplit(mtcars, mtcars[.c(cyl, vs, am)])
rsplit(mtcars, ~ cyl + vs + am, keep.by = TRUE)  # Same thing
rsplit(mtcars, ~ cyl + vs + am)

rsplit(mtcars, ~ cyl + vs + am, flatten = TRUE)

rsplit(mtcars, mpg ~ cyl)
rsplit(mtcars, mpg ~ cyl, simplify = FALSE)
rsplit(mtcars, mpg + hp ~ cyl + vs + am)
rsplit(mtcars, mpg + hp ~ cyl + vs + am, keep.by = TRUE)

# Split this sectoral data, first by Variable (Emloyment and Value Added), then by Country
GGDCspl &lt;- rsplit(GGDC10S, ~ Variable + Country, cols = 6:16)
str(GGDCspl)

# The nested list can be reassembled using unlist2d()
head(unlist2d(GGDCspl, idcols = .c(Variable, Country)))
rm(GGDCspl)

# Another example with mtcars (not as clean because of row.names)
nl &lt;- rsplit(mtcars, mpg + hp ~ cyl + vs + am)
str(nl)
unlist2d(nl, idcols = .c(cyl, vs, am), row.names = "car")
rm(nl)
</code></pre>

<hr>
<h2 id='seqid'>
Generate Group-Id from Integer Sequences
</h2><span id='topic+seqid'></span>

<h3>Description</h3>

<p><code>seqid</code> can be used to group sequences of integers in a vector, e.g. <code>seqid(c(1:3, 5:7))</code> becomes <code>c(rep(1,3), rep(2,3))</code>. It also supports increments <code>&gt; 1</code>, unordered sequences, and missing values in the sequence.
</p>
<p>Some applications are to facilitate identification of, and grouped operations on, (irregular) time series and panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqid(x, o = NULL, del = 1L, start = 1L, na.skip = FALSE,
      skip.seq = FALSE, check.o = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqid_+3A_x">x</code></td>
<td>
<p>a factor or integer vector. Numeric vectors will be converted to integer i.e. rounded downwards.</p>
</td></tr>
<tr><td><code id="seqid_+3A_o">o</code></td>
<td>
<p>an (optional) integer ordering vector specifying the order by which to pass through <code>x</code>.</p>
</td></tr>
<tr><td><code id="seqid_+3A_del">del</code></td>
<td>
<p>integer. The integer deliminating two consecutive points in a sequence. <code>del = 1</code> lets <code>seqid</code> track sequences of the form <code>c(1,2,3,..)</code>, <code>del = 2</code> tracks sequences <code>c(1,3,5,..)</code> etc.</p>
</td></tr>
<tr><td><code id="seqid_+3A_start">start</code></td>
<td>
<p>integer. The starting value of the resulting sequence id. Default is starting from 1. </p>
</td></tr>
<tr><td><code id="seqid_+3A_na.skip">na.skip</code></td>
<td>
<p>logical. <code>TRUE</code> skips missing values in the sequence. The default behavior is skipping such that <code>seqid(c(1, NA, 2))</code> is regarded as one sequence and coded as <code>c(1, NA, 1)</code>.</p>
</td></tr>
<tr><td><code id="seqid_+3A_skip.seq">skip.seq</code></td>
<td>
<p>logical. If <code>na.skip = TRUE</code>, this changes the behavior such that missing values are viewed as part of the sequence, i.e. <code>seqid(c(1, NA, 3))</code> is regarded as one sequence and coded as <code>c(1, NA, 1)</code>.</p>
</td></tr>
<tr><td><code id="seqid_+3A_check.o">check.o</code></td>
<td>
<p>logical. Programmers option: <code>FALSE</code> prevents checking that each element of <code>o</code> is in the range <code>[1, length(x)]</code>, it only checks the length of <code>o</code>. This gives some extra speed, but will terminate R if any element of <code>o</code> is too large or too small. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seqid</code> was created primarily as a workaround to deal with problems of computing lagged values, differences and growth rates on irregularly spaced time series and panels before <em>collapse</em> version 1.5.0 (<a href="https://github.com/SebKrantz/collapse/issues/26">#26</a>). Now <code>flag</code>, <code>fdiff</code> and <code>fgrowth</code> natively support irregular data so this workaround is superfluous, except for iterated differencing which is not yet supported with irregular data.
</p>

<p>The theory of the workaround was to express an irregular time series or panel series as a regular panel series with a group-id created such that the time-periods within each group are consecutive. <code>seqid</code> makes this very easy: For an irregular panel with some gaps or repeated values in the time variable, an appropriate id variable can be generated using <code>settransform(data, newid = seqid(time, radixorder(id, time)))</code>. Lags can then be computed using <code>L(data, 1, ~newid, ~time)</code> etc.
</p>


<p>In general, for any regularly spaced panel the identity given by <code>identical(groupid(id, order(id, time)), seqid(time, order(id, time)))</code> should hold.
</p>







<p>For the opposite operation of creating a new time-variable that is consecutive in each group, see <code>data.table::rowid</code>.
</p>


<h3>Value</h3>

<p>An integer vector of class 'qG'. See <code><a href="#topic+qG">qG</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+timeid">timeid</a></code>, <code><a href="#topic+groupid">groupid</a></code>, <code><a href="#topic+qG">qG</a></code>, <a href="#topic+fast-grouping-ordering">Fast Grouping and Ordering</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This creates an irregularly spaced panel, with a gap in time for id = 2
data &lt;- data.frame(id = rep(1:3, each = 4),
                   time = c(1:4, 1:2, 4:5, 1:4),
                   value = rnorm(12))
data

## This gave a gaps in time error previous to collapse 1.5.0
L(data, 1, value ~ id, ~time)

## Generating new id variable (here seqid(time) would suffice as data is sorted)
settransform(data, newid = seqid(time, order(id, time)))
data

## Lag the panel this way
L(data, 1, value ~ newid, ~time)

## A different possibility: Creating a consecutive time variable
settransform(data, newtime = data.table::rowid(id))
data
L(data, 1, value ~ id, ~newtime)

## With sorted data, the time variable can also just be omitted..
L(data, 1, value ~ id)

</code></pre>

<hr>
<h2 id='small-helpers'>
Small (Helper) Functions 
</h2><span id='topic+AA3-small-helpers'></span><span id='topic+small-helpers'></span><span id='topic+.c'></span><span id='topic+vlabels'></span><span id='topic+vlabels+3C-'></span><span id='topic+setLabels'></span><span id='topic+vclasses'></span><span id='topic+namlab'></span><span id='topic+add_stub'></span><span id='topic+rm_stub'></span><span id='topic+massign'></span><span id='topic++25+3D+25'></span><span id='topic+all_identical'></span><span id='topic+all_obj_equal'></span><span id='topic+all_funs'></span><span id='topic+setRownames'></span><span id='topic+setColnames'></span><span id='topic+setDimnames'></span><span id='topic+unattrib'></span><span id='topic+setattrib'></span><span id='topic+setAttrib'></span><span id='topic+copyAttrib'></span><span id='topic+copyMostAttrib'></span><span id='topic+is_categorical'></span><span id='topic+is_date'></span>

<h3>Description</h3>

<p>Convenience functions in the <em>collapse</em> package that help to deal with object attributes such as variable names and labels, object checking, metaprogramming, and that improve the workflow. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.c(...)                       # Non-standard concatenation i.e. .c(a, b) == c("a", "b")
nam %=% values                # Multiple-assignment e.g. .c(x, y) %=% c(1, 2),
massign(nam, values,          # can also assign to different environment.
        envir = parent.frame())
vlabels(X, attrn = "label",   # Get labels of variables in X, in attr(X[[i]], attrn)
        use.names = TRUE)
vlabels(X, attrn = "label") &lt;- value    # Set labels of variables in X (by reference)
setLabels(X, value = NULL,    # Set labels of variables in X (by reference) and return X
          attrn = "label", cols = NULL)
vclasses(X, use.names = TRUE) # Get classes of variables in X
namlab(X, class = FALSE,      # Return data frame of names and labels,
  attrn = "label", N = FALSE, # and (optionally) classes, number of observations
  Ndistinct = FALSE)          # and number of non-missing distinct values
add_stub(X, stub, pre = TRUE, # Add a stub (i.e. prefix or postfix) to column names
         cols = NULL)
rm_stub(X, stub, pre = TRUE,  # Remove stub from column names, also supports general
        regex = FALSE,        # regex matching and removing of characters
        cols = NULL, ...)
all_identical(...)            # Check exact equality of multiple objects or list-elements
all_obj_equal(...)            # Check near equality of multiple objects or list-elements
all_funs(expr)                # Find all functions called in an R language expression
setRownames(object,           # Set rownames of object and return object
    nm = if(is.atomic(object)) seq_row(object) else NULL)
setColnames(object, nm)       # Set colnames of object and return object
setDimnames(object, dn,       # Set dimension names of object and return object
            which = NULL)
unattrib(object)              # Remove all attributes from object
setAttrib(object, a)          # Replace all attributes with list of attributes 'a'
setattrib(object, a)          # Same thing by reference, returning object invisibly
copyAttrib(to, from)          # Copy all attributes from object 'from' to object 'to'
copyMostAttrib(to, from)      # Copy most attributes from object 'from' to object 'to'
is_categorical(x)             # The opposite of is.numeric
is_date(x)                    # Check if object is of class "Date", "POSIXlt" or "POSIXct"

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="small-helpers_+3A_x">X</code></td>
<td>
<p>a matrix or data frame (some functions also support vectors and arrays although that is less common).</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_x">x</code></td>
<td>
<p>a (atomic) vector.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_expr">expr</code></td>
<td>
<p>an expression of type &quot;language&quot; e.g. <code>quote(x / sum(x))</code>.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_object">object</code>, <code id="small-helpers_+3A_to">to</code>, <code id="small-helpers_+3A_from">from</code></td>
<td>
<p>a suitable R object.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_a">a</code></td>
<td>
<p>a suitable list of attributes.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_attrn">attrn</code></td>
<td>
<p>character. Name of attribute to store labels or retrieve labels from.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_n">N</code>, <code id="small-helpers_+3A_ndistinct">Ndistinct</code></td>
<td>
<p>logical. Options to display the number of observations or number of distinct non-missing values.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_value">value</code></td>
<td>
<p>for <code>whichv</code> and <code>alloc</code>: a single value of any vector type. For <code>vlabels&lt;-</code> and <code>setLabels</code>: a matching character vector or list of variable labels. </p>
</td></tr>
<tr><td><code id="small-helpers_+3A_use.names">use.names</code></td>
<td>
<p>logical. Preserve names if <code>X</code> is a list. </p>
</td></tr>
<tr><td><code id="small-helpers_+3A_cols">cols</code></td>
<td>
<p>integer. (optional) indices of columns to apply the operation to. Note that for these small functions this needs to be integer, whereas for other functions in the package this argument is more flexible. </p>
</td></tr>
<tr><td><code id="small-helpers_+3A_class">class</code></td>
<td>
<p>logical. Also show the classes of variables in X in a column?</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_stub">stub</code></td>
<td>
<p>a single character stub, i.e. &quot;log.&quot;, which by default will be pre-applied to all variables or column names in X.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_pre">pre</code></td>
<td>
<p>logical. <code>FALSE</code> will post-apply <code>stub</code>.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_regex">regex</code></td>
<td>
<p>logical. Match pattern anywhere in names using a regular expression and remove it with <code><a href="base.html#topic+gsub">gsub</a></code>.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_nm">nm</code></td>
<td>
<p>a suitable vector of row- or column-names.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_dn">dn</code></td>
<td>
<p>a suitable vector or list of names for dimension(s).</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_which">which</code></td>
<td>
<p>integer. If <code>NULL</code>, <code>dn</code> has to be a list fully specifying the dimension names of the object. Alternatively, a vector or list of names for dimensions <code>which</code> can be supplied. See Examples. </p>
</td></tr>
<tr><td><code id="small-helpers_+3A_nam">nam</code></td>
<td>
<p>character. A vector of object names.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_values">values</code></td>
<td>
<p>a matching atomic vector or list of objects.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_envir">envir</code></td>
<td>
<p>the environment to assign into.</p>
</td></tr>
<tr><td><code id="small-helpers_+3A_...">...</code></td>
<td>
<p>for <code>.c</code>: Comma-separated expressions. For <code>all_identical / all_obj_equal</code>: Either multiple comma-separated objects or a single list of objects in which all elements will be checked for exact / numeric equality. For <code>rm_stub</code>: further arguments passed to <code><a href="base.html#topic+gsub">gsub</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>all_funs</code> is the opposite of <code><a href="base.html#topic+all.vars">all.vars</a></code>, to return the functions called rather than the variables in an expression. See Examples.
</p>
<p><code>copyAttrib</code> and <code>copyMostAttrib</code> take a shallow copy of the attribute list, i.e. they don't duplicate in memory the attributes themselves. They also, along with <code>setAttrib</code>, take a shallow copy of lists passed to the <code>to</code> argument, so that lists are not modified by reference. Atomic <code>to</code> arguments are however modified by reference. The function <code>setattrib</code>, added in v1.8.9, modifies the <code>object</code> by reference i.e. no shallow copies are taken.
</p>
<p><code>copyMostAttrib</code> copies all attributes except for <code>"names"</code>, <code>"dim"</code> and <code>"dimnames"</code> (like the corresponding C-API function), and further only copies the <code>"row.names"</code> attribute of data frames if known to be valid. Thus it is a suitable choice if objects should be of the same type but are not of equal dimensions.
</p>


<h3>See Also</h3>

<p><a href="#topic+efficient-programming">Efficient Programming</a>, <a href="#topic+collapse-documentation">Collapse Overview</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Non-standard concatenation
.c(a, b, "c d", e == f)

## Multiple assignment
.c(a, b) %=% list(1, 2)
.c(T, N) %=% dim(EuStockMarkets)
names(iris) %=% iris
list2env(iris)          # Same thing
rm(list = c("a", "b", "T", "N", names(iris)))

## Variable labels
namlab(wlddev)
namlab(wlddev, class = TRUE, N = TRUE, Ndistinct = TRUE)
vlabels(wlddev)
vlabels(wlddev) &lt;- vlabels(wlddev)

## Stub-renaming
log_mtc &lt;- add_stub(log(mtcars), "log.")
head(log_mtc)
head(rm_stub(log_mtc, "log."))
rm(log_mtc)

## Setting dimension names of an object
head(setRownames(mtcars))
ar &lt;- array(1:9, c(3,3,3))
setRownames(ar)
setColnames(ar, c("a","b","c"))
setDimnames(ar, c("a","b","c"), which = 3)
setDimnames(ar, list(c("d","e","f"), c("a","b","c")), which = 2:3)
setDimnames(ar, list(c("g","h","i"), c("d","e","f"), c("a","b","c")))

## Checking exact equality of multiple objects
all_identical(iris, iris, iris, iris)
l &lt;- replicate(100, fmean(num_vars(iris), iris$Species), simplify = FALSE)
all_identical(l)
rm(l)

## Function names from expressions
ex = quote(sum(x) + mean(y) / z)
all.names(ex)
all.vars(ex)
all_funs(ex)
rm(ex)
</code></pre>

<hr>
<h2 id='summary-statistics'>Summary Statistics</h2><span id='topic+A9-summary-statistics'></span><span id='topic+summary-statistics'></span>

<h3>Description</h3>

<p><em>collapse</em> provides the following functions to efficiently summarize and examine data:
</p>

<ul>
<li> <p><code><a href="#topic+qsu">qsu</a></code>, shorthand for quick-summary, is an extremely fast summary command inspired by the (xt)summarize command in the STATA statistical software. It computes a set of 7 statistics (nobs, mean, sd, min, max, skewness and kurtosis) using a numerically stable one-pass method. Statistics can be computed weighted, by groups, and also within-and between entities (for multilevel / panel data).
</p>
</li>
<li> <p><code><a href="#topic+qtab">qtab</a></code>, shorthand for quick-table, is a faster and more versatile alternative to <code><a href="base.html#topic+table">table</a></code>. Notably, it also supports tabulations with frequency weights, as well as computing a statistic over combinations of variables. 'qtab's inherit the 'table' class, allowing for seamless application of 'table' methods.
</p>
</li>
<li> <p><code><a href="#topic+descr">descr</a></code> computes a concise and detailed description of a data frame, including (sorted) frequency tables for categorical variables and various statistics and quantiles for numeric variables. It is inspired by <code>Hmisc::describe</code>, but about 10x faster.
</p>
</li>
<li> <p><code><a href="#topic+pwcor">pwcor</a></code>, <code><a href="#topic+pwcov">pwcov</a></code> and <code><a href="#topic+pwnobs">pwnobs</a></code> compute (weighted) pairwise correlations, covariances and observation counts on matrices and data frames. Pairwise correlations and covariances can be computed together with observation counts and p-values. The elaborate print method displays all of these statistics in a single correlation table.
</p>
</li>
<li> <p><code><a href="#topic+varying">varying</a></code> very efficiently checks for the presence of any variation in data (optionally) within groups (such as panel-identifiers). A variable is variant if it has at least 2 distinct non-missing data points.
</p>

</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> Function / S3 Generic </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Methods </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+qsu">qsu</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, grouped_df, pseries, pdata.frame, sf</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (grouped, weighted, panel-decomposed) summary statistics </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+qtab">qtab</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for data frames or vectors  </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast (weighted) cross tabulation </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+descr">descr</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, grouped_df</code>  (default method handles most objects)  </td><td style="text-align: left;"></td><td style="text-align: left;"> Detailed statistical description of data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+pwcor">pwcor</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for matrices or data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Pairwise (weighted) correlations </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+pwcov">pwcov</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for matrices or data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Pairwise (weighted) covariances </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+pwnobs">pwnobs</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> No methods, for matrices or data frames </td><td style="text-align: left;"></td><td style="text-align: left;"> Pairwise observation counts </td>
</tr>
<tr>
 <td style="text-align: left;">
                <code><a href="#topic+varying">varying</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast variation check </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>
</p>

<hr>
<h2 id='t_list'>
Efficient List Transpose
</h2><span id='topic+t_list'></span>

<h3>Description</h3>

<p><code>t_list</code> turns a list of lists inside-out. The performance is quite efficient regardless of the size of the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_list(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_list_+3A_l">l</code></td>
<td>
<p>a list of lists. Elements inside the sublists can be heterogeneous, including further lists.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>l</code> transposed such that the second layer of the list becomes the top layer and the top layer the second layer. See Examples.
</p>


<h3>Note</h3>

<p>To transpose a data frame / list of atomic vectors see <code>data.table::transpose()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsplit">rsplit</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Homogenous list of lists
l &lt;- list(a = list(c = 1, d = 2), b = list(c = 3, d = 4))
str(l)
str(t_list(l))

# Heterogenous case
l2 &lt;- list(a = list(c = 1, d = letters), b = list(c = 3:10, d = list(4, e = 5)))
attr(l2, "bla") &lt;- "abc"  # Attributes other than names are preserved
str(l2)
str(t_list(l2))

rm(l, l2)
</code></pre>

<hr>
<h2 id='time-series-panel-series'>Time Series and Panel Series</h2><span id='topic+A7-time-series-panel-series'></span><span id='topic+time-series-panel-series'></span>

<h3>Description</h3>

<p><em>collapse</em> provides a flexible and powerful set of functions and classes to work with time-dependent data:
</p>

<ul>
<li> <p><code><a href="#topic+findex_by">findex_by/iby</a></code> creates an 'indexed_frame': a flexible structure that can be imposed upon any data-frame like object and facilitates <b>indexed (time-aware) computations on time series and panel data</b>. Indexed frames are composed of 'indexed_series', which can also be created from vector and matrix-based objects using the <code>reindex</code> function. Further functions <code>findex/ix</code>, <code>unindex</code>, <code>is_irregular</code> and <code>to_plm</code> help operate these classes, check for irregularity, and ensure <em>plm</em> compatibility. Methods are defined for various time series, data transformation and data manipulation functions in <em>collapse</em>.
</p>
</li>
<li> <p><code><a href="#topic+timeid">timeid</a></code> efficiently converts numeric time sequences, such as 'Date' or 'POSIXct' vectors, to a <b>time-factor / integer id</b>, where a unit-step represents the greatest common divisor of the underlying sequence.
</p>
</li>
<li> <p><code><a href="#topic+flag">flag</a></code>, and the lag- and lead- operators <code><a href="#topic+L">L</a></code> and <code><a href="#topic+F">F</a></code> are S3 generics to efficiently compute sequences of <b>lags and leads</b> on regular or irregular / unbalanced time series and panel data.
</p>
</li>
<li><p> Similarly, <code><a href="#topic+fdiff">fdiff</a></code>, <code><a href="#topic+fgrowth">fgrowth</a></code>, and the operators <code><a href="#topic+D">D</a></code>, <code><a href="#topic+Dlog">Dlog</a></code> and <code><a href="#topic+G">G</a></code> are S3 generics to efficiently compute sequences of suitably lagged / leaded and iterated <b>differences, log-differences and growth rates</b>. <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code> can also compute <b>quasi-differences</b> of the form <code class="reqn">x_t - \rho x_{t-1}</code>.
</p>
</li>
<li> <p><code><a href="#topic+fcumsum">fcumsum</a></code> is an S3 generic to efficiently compute <b>cumulative sums</b> on time series and panel data. In contrast to <code><a href="base.html#topic+cumsum">cumsum</a></code>, it can handle missing values and supports both grouped and indexed / ordered computations.
</p>
</li>
<li> <p><code><a href="#topic+psmat">psmat</a></code> is an S3 generic to efficiently convert panel-vectors / 'indexed_series' and data frames / 'indexed_frame's to <b>panel series matrices and 3D arrays</b>, respectively (where time, individuals and variables receive different dimensions, allowing for fast indexation, visualization, and computations).
</p>
</li>
<li> <p><code><a href="#topic+psacf">psacf</a></code>, <code><a href="#topic+pspacf">pspacf</a></code> and <code><a href="#topic+psccf">psccf</a></code> are S3 generics to compute estimates of the <b>auto-, partial auto- and cross- correlation or covariance functions</b> for panel-vectors / 'indexed_series', and multivariate versions for data frames / 'indexed_frame's.
</p>
</li></ul>



<h3>Table of Functions</h3>


<table>
<tr>
 <td style="text-align: left;"><em> S3 Generic </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Methods </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;"> 
                 <code><a href="#topic+findex_by">findex_by/iby</a></code>, <code>findex/ix</code>, <code>reindex</code>, <code>unindex</code>, <code>is_irregular</code>, <code>to_plm</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> For vectors, matrices and data frames / lists.   </td><td style="text-align: left;"></td><td style="text-align: left;"> Fast and flexible time series and panel data classes 'indexed_series' and 'indexed_frame'. </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+timeid">timeid</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> For time sequences represented by integer or double vectors / objects.  </td><td style="text-align: left;"></td><td style="text-align: left;"> Generate integer time-id/factor </td>
</tr>
<tr>
 <td style="text-align: left;">

                 <code><a href="#topic+flag">flag/L/F</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute (sequences of) lags and leads </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fdiff">fdiff/D/Dlog</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute (sequences of lagged / leaded and iterated) (quasi-)differences or log-differences </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fgrowth">fgrowth/G</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute (sequences of lagged / leaded and iterated) growth rates (exact, via log-differencing, or compounded) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+fcumsum">fcumsum</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, matrix, data.frame, pseries, pdata.frame, grouped_df</code>  </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute cumulative sums </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+psmat">psmat</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, pseries, data.frame, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Convert panel data to matrix / array </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+psacf">psacf</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, pseries, data.frame, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute ACF on panel data </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+pspacf">pspacf</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, pseries, data.frame, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute PACF on panel data </td>
</tr>
<tr>
 <td style="text-align: left;">
                 <code><a href="#topic+psccf">psccf</a></code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code>default, pseries, data.frame, pdata.frame</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Compute CCF on panel data
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+collapse-documentation">Collapse Overview</a>, <a href="#topic+data-transformations">Data Transformations</a>
</p>

<hr>
<h2 id='timeid'>
Generate Integer-Id From Time/Date Sequences
</h2><span id='topic+timeid'></span>

<h3>Description</h3>

<p><code>timeid</code> groups time vectors in a way that preserves the temporal structure. It generate an integer id where unit steps represent the greatest common divisor in the original sequence e.g <code>c(4, 6, 10) -&gt; c(1, 2, 4)</code> or <code>c(0.25, 0.75, 1) -&gt; c(1, 3, 4)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeid(x, factor = FALSE, ordered = factor, extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeid_+3A_x">x</code></td>
<td>
<p>a numeric time object such as a <code>Date</code>, <code>POSIXct</code> or other integer or double vector representing time.</p>
</td></tr>
<tr><td><code id="timeid_+3A_factor">factor</code></td>
<td>
<p>logical. <code>TRUE</code> returns an (ordered) factor with levels corresponding to the full sequence (without irregular gaps) of time. This is useful for inclusion in the <a href="#topic+findex">index</a> but might be computationally expensive for long sequences, see Details. <code>FALSE</code> returns a simpler object of class '<code><a href="#topic+qG">qG</a></code>'. </p>
</td></tr>
<tr><td><code id="timeid_+3A_ordered">ordered</code></td>
<td>
<p>logical. <code>TRUE</code> adds a class 'ordered'. </p>
</td></tr>
<tr><td><code id="timeid_+3A_extra">extra</code></td>
<td>
<p>logical. <code>TRUE</code> attaches a set of 4 diagnostic items as attributes to the result:
</p>

<ul>
<li> <p><code>"unique_ints"</code>: <code>unique(unattrib(timeid(x)))</code> - the unique integer time steps in first-appearance order. This can be useful to check the size of gaps in the sequence. 
</p>
</li>
<li> <p><code>"sort_unique_x"</code>: <code>sort(unique(x))</code>.
</p>
</li>
<li> <p><code>"range_x"</code>: <code>range(x)</code>.
</p>
</li>
<li> <p><code>"step_x"</code>: <code>vgcd(sort(unique(diff(sort(unique(x))))))</code> - the greatest common divisor.
</p>
</li></ul>

<p><em>Note</em> that returning these attributes does not incur additional computations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>range_x</code> and <code>step_x</code> be the like-named attributes returned when <code>extra = TRUE</code>, then, if <code>factor = TRUE</code>, a complete sequence of levels is generated as <code>seq(range_x[1], range_x[2], by = step_x) |&gt; copyMostAttrib(x) |&gt; as.character()</code>. If <code>factor = FALSE</code>, the number of timesteps recorded in the <code>"N.groups"</code> attribute is computed as <code>(range_x[2]-range_x[1])/step_x + 1</code>, which is equal to the number of factor levels. In both cases the underlying integer id is the same and preserves gaps in time. Large gaps (strong irregularity) can result in many unused factor levels, the generation of which can become expensive. Using <code>factor = FALSE</code> (the default) is thus more efficient.
</p>


<h3>Value</h3>

<p>A factor or '<code><a href="#topic+qG">qG</a></code>' object, optionally with additional attributes attached.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seqid">seqid</a></code>, <a href="#topic+indexing">Indexing</a>, <a href="#topic+time-series-panel-series">Time Series and Panel Series</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldopts &lt;- options(max.print = 30)

# A normal use case
timeid(wlddev$decade)
timeid(wlddev$decade, factor = TRUE)
timeid(wlddev$decade, extra = TRUE)

# Here a large number of levels is generated, which is expensive
timeid(wlddev$date, factor = TRUE)
tid &lt;- timeid(wlddev$date, extra = TRUE) # Much faster
str(tid)

# The reason for step = 1 are leap years with 366 days every 4 years
diff(attr(tid, "unique"))

# So in this case simple factor generation gives a better result
qF(wlddev$date, ordered = TRUE, na.exclude = FALSE)

# The best way to deal with this data would be to convert it
# to zoo::yearmon and then use timeid:
timeid(zoo::as.yearmon(wlddev$date), factor = TRUE, extra = TRUE)

options(oldopts)
rm(oldopts, tid)
</code></pre>

<hr>
<h2 id='TRA'>
Transform Data by (Grouped) Replacing or Sweeping out Statistics
</h2><span id='topic+TRA'></span><span id='topic+setTRA'></span><span id='topic+TRA.default'></span><span id='topic+TRA.matrix'></span><span id='topic+TRA.data.frame'></span><span id='topic+TRA.grouped_df'></span>

<h3>Description</h3>

<p><code>TRA</code> is an S3 generic that efficiently transforms data by either (column-wise) replacing data values with supplied statistics or sweeping the statistics out of the data. <code>TRA</code> supports grouped operations and data transformation by reference, and is thus a generalization of <code><a href="base.html#topic+sweep">sweep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   TRA(x, STATS, FUN = "-", ...)
setTRA(x, STATS, FUN = "-", ...) # Shorthand for invisible(TRA(..., set = TRUE))

## Default S3 method:
TRA(x, STATS, FUN = "-", g = NULL, set = FALSE, ...)

## S3 method for class 'matrix'
TRA(x, STATS, FUN = "-", g = NULL, set = FALSE, ...)

## S3 method for class 'data.frame'
TRA(x, STATS, FUN = "-", g = NULL, set = FALSE, ...)

## S3 method for class 'grouped_df'
TRA(x, STATS, FUN = "-", keep.group_vars = TRUE, set = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TRA_+3A_x">x</code></td>
<td>
<p>a atomic vector, matrix, data frame or grouped data frame (class 'grouped_df').</p>
</td></tr>
<tr><td><code id="TRA_+3A_stats">STATS</code></td>
<td>
<p>a matching set of summary statistics. See Details and Examples.</p>
</td></tr>
<tr><td><code id="TRA_+3A_fun">FUN</code></td>
<td>
<p>an integer or character string indicating the operation to perform. There are 11 supported operations:
</p>

<table>
<tr>
 <td style="text-align: left;"><em> Int. </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> String </em>   </td><td style="text-align: left;"></td><td style="text-align: left;"> <em> Description </em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
                 0 </td><td style="text-align: left;"></td><td style="text-align: left;"> "na" or "replace_na"   </td><td style="text-align: left;"></td><td style="text-align: left;"> replace missing values in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 1 </td><td style="text-align: left;"></td><td style="text-align: left;"> "fill" or "replace_fill"   </td><td style="text-align: left;"></td><td style="text-align: left;"> replace data and missing values in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 2 </td><td style="text-align: left;"></td><td style="text-align: left;"> "replace" </td><td style="text-align: left;"></td><td style="text-align: left;"> replace data but preserve missing values in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
                 3 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-"   </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract (i.e. center) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 4 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-+"  </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract group-statistics but add group-frequency weighted average of group statistics (i.e. center on overall average statistic) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 5 </td><td style="text-align: left;"></td><td style="text-align: left;"> "/"   </td><td style="text-align: left;"></td><td style="text-align: left;"> divide (i.e. scale. For mean-preserving scaling see also <code><a href="#topic+fscale">fscale</a></code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 6 </td><td style="text-align: left;"></td><td style="text-align: left;"> "%"     </td><td style="text-align: left;"></td><td style="text-align: left;"> compute percentages (i.e. divide and multiply by 100) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 7 </td><td style="text-align: left;"></td><td style="text-align: left;"> "+" </td><td style="text-align: left;"></td><td style="text-align: left;"> add </td>
</tr>
<tr>
 <td style="text-align: left;">
                 8 </td><td style="text-align: left;"></td><td style="text-align: left;"> "*" </td><td style="text-align: left;"></td><td style="text-align: left;"> multiply </td>
</tr>
<tr>
 <td style="text-align: left;">
                 9 </td><td style="text-align: left;"></td><td style="text-align: left;"> "%%" </td><td style="text-align: left;"></td><td style="text-align: left;"> modulus (i.e. remainder from division by  <code>STATS</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
                 10 </td><td style="text-align: left;"></td><td style="text-align: left;"> "-%%" </td><td style="text-align: left;"></td><td style="text-align: left;"> subtract modulus (i.e. make data divisible by <code>STATS</code>)
  </td>
</tr>

</table>

</td></tr>
<tr><td><code id="TRA_+3A_g">g</code></td>
<td>
<p>a factor, <code><a href="#topic+GRP">GRP</a></code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code><a href="#topic+GRP">GRP</a></code> object) used to group <code>x</code>. Number of groups must match rows of <code>STATS</code>. See Details.</p>
</td></tr>
<tr><td><code id="TRA_+3A_set">set</code></td>
<td>
<p>logical. <code>TRUE</code> transforms data by reference i.e. performs in-place modification of the data without creating a copy.</p>
</td></tr>
<tr><td><code id="TRA_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation. See Details and Examples.</p>
</td></tr>
<tr><td><code id="TRA_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without groups (<code>g = NULL</code>), <code>TRA</code> is little more than a column based version of <code><a href="base.html#topic+sweep">sweep</a></code>, albeit many times more efficient. In this case all methods support an atomic vector of statistics of length <code>NCOL(x)</code> passed to <code>STATS</code>. The matrix and data frame methods also support a 1-row matrix or 1-row data frame / list, respectively. <code>TRA</code> always preserves all attributes of <code>x</code>.
</p>
<p>With groups passed to <code>g</code>, <code>STATS</code> needs to be of the same type as <code>x</code> and of appropriate dimensions [such that <code>NCOL(x) == NCOL(STATS)</code> and <code>NROW(STATS)</code> equals the number of groups (i.e. the number of levels if <code>g</code> is a factor)]. If this condition is satisfied, <code>TRA</code> will assume that the first row of <code>STATS</code> is the set of statistics computed on the first group/level of <code>g</code>, the second row on the second group/level etc. and do groupwise replacing or sweeping out accordingly.
</p>
<p>For example Let <code>x = c(1.2, 4.6, 2.5, 9.1, 8.7, 3.3)</code>, g is an integer vector in 3 groups <code>g = c(1,3,3,2,1,2)</code> and <code>STATS = fmean(x,g) = c(4.95, 6.20, 3.55)</code>. Then <code>out = TRA(x,STATS,"-",g) = c(-3.75,  1.05, -1.05,  2.90,  3.75, -2.90)</code> [same as <code>fmean(x, g, TRA = "-")</code>] does the equivalent of the following for-loop: <code>for(i in 1:6) out[i] = x[i] - STATS[g[i]]</code>.
</p>
<p>Correct computation requires that <code>g</code> as used in <code>fmean</code> and <code>g</code> passed to <code>TRA</code> are exactly the same vector. Using <code>g = c(1,3,3,2,1,2)</code> for <code>fmean</code> and <code>g = c(3,1,1,2,3,2)</code> for <code>TRA</code> will not give the right result. The safest way of programming with <code>TRA</code> is thus to repeatedly employ the same factor or <code><a href="#topic+GRP">GRP</a></code> object for all grouped computations. Atomic vectors passed to <code>g</code> will be converted to factors (see <code><a href="#topic+qF">qF</a></code>) and lists will be converted to <code><a href="#topic+GRP">GRP</a></code> objects. This is also done by all <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> and <code><a href="#topic+BY">BY</a></code>, thus together with these functions, <code>TRA</code> can also safely be used with atomic- or list-groups (as long as all functions apply sorted grouping, which is the default in <em>collapse</em>). 
</p>

<p>If <code>x</code> is a grouped data frame ('grouped_df'), <code>TRA</code> matches the columns of <code>x</code> and <code>STATS</code> and also checks for grouping columns in <code>x</code> and <code>STATS</code>. <code>TRA.grouped_df</code> will then only transform those columns in <code>x</code> for which matching counterparts were found in <code>STATS</code> (exempting grouping columns) and return <code>x</code> again (with columns in the same order). If <code>keep.group_vars = FALSE</code>, the grouping columns are dropped after computation, however the &quot;groups&quot; attribute is not dropped (it can be removed using <code><a href="#topic+fungroup">fungroup()</a></code> or <code>dplyr::ungroup()</code>).
</p>


<h3>Value</h3>

<p><code>x</code> with columns replaced or swept out using <code>STATS</code>, (optionally) grouped by <code>g</code>.
</p>


<h3>Note</h3>

<p>In most cases there is no need to call the <code>TRA()</code> function, because of the TRA-argument to all <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a> (ensuring that the exact same grouping vector is used for computing statistics and subsequent transformation). In addition the functions <code><a href="#topic+fbetween">fbetween/B</a></code> and <code><a href="#topic+fwithin">fwithin/W</a></code> and <code><a href="#topic+fscale">fscale/STD</a></code> provide optimized solutions for frequent scaling, centering and averaging tasks. 
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sweep">sweep</a></code>, <a href="#topic+fast-statistical-functions">Fast Statistical Functions</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- iris$Sepal.Length          # A numeric vector
f &lt;- iris$Species               # A factor
dat &lt;- num_vars(iris)           # Numeric columns
m &lt;- qM(dat)                    # Matrix of numeric data

head(TRA(v, fmean(v)))                # Simple centering [same as fmean(v, TRA = "-") or W(v)]
head(TRA(m, fmean(m)))                # [same as sweep(m, 2, fmean(m)), fmean(m, TRA = "-") or W(m)]
head(TRA(dat, fmean(dat)))            # [same as fmean(dat, TRA = "-") or W(dat)]
head(TRA(v, fmean(v), "replace"))     # Simple replacing [same as fmean(v, TRA = "replace") or B(v)]
head(TRA(m, fmean(m), "replace"))     # [same as sweep(m, 2, fmean(m)), fmean(m, TRA = 1L) or B(m)]
head(TRA(dat, fmean(dat), "replace")) # [same as fmean(dat, TRA = "replace") or B(dat)]
head(TRA(m, fsd(m), "/"))             # Simple scaling... [same as fsd(m, TRA = "/")]...

# Note: All grouped examples also apply for v and dat...
head(TRA(m, fmean(m, f), "-", f))       # Centering [same as fmean(m, f, TRA = "-") or W(m, f)]
head(TRA(m, fmean(m, f), "replace", f)) # Replacing [same fmean(m, f, TRA = "replace") or B(m, f)]
head(TRA(m, fsd(m, f), "/", f))         # Scaling [same as fsd(m, f, TRA = "/")]

head(TRA(m, fmean(m, f), "-+", f))      # Centering on the overall mean ...
                                        # [same as fmean(m, f, TRA = "-+") or
                                        #           W(m, f, mean = "overall.mean")]
head(TRA(TRA(m, fmean(m, f), "-", f),   # Also the same thing done manually !!
     fmean(m), "+"))

# Grouped data method
library(magrittr)
iris %&gt;% fgroup_by(Species) %&gt;% TRA(fmean(.))
iris %&gt;% fgroup_by(Species) %&gt;% fmean(TRA = "-")        # Same thing
iris %&gt;% fgroup_by(Species) %&gt;% TRA(fmean(.)[c(2,4)])   # Only transforming 2 columns
iris %&gt;% fgroup_by(Species) %&gt;% TRA(fmean(.)[c(2,4)],   # Dropping species column
                                        keep.group_vars = FALSE)
</code></pre>

<hr>
<h2 id='unlist2d'>
Recursive Row-Binding / Unlisting in 2D - to Data Frame
</h2><span id='topic+unlist2d'></span>

<h3>Description</h3>

<p><code>unlist2d</code> efficiently unlists lists of regular R objects (objects built up from atomic elements) and creates a data frame representation of the list through recursive flattening and intelligent row-binding operations. It is a full 2-dimensional generalization of <code><a href="base.html#topic+unlist">unlist</a></code>, and best understood as a recursive generalization of <code>do.call(rbind, ...)</code>.
</p>
<p>It is a powerful tool to create a tidy data frame representation from (nested) lists of vectors, data frames, matrices, arrays or heterogeneous objects. For simple row-wise combining lists/data.frame's use the non-recursive <code><a href="#topic+rowbind">rowbind</a></code> function.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlist2d(l, idcols = ".id", row.names = FALSE, recursive = TRUE,
         id.factor = FALSE, DT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlist2d_+3A_l">l</code></td>
<td>
<p>a unlistable list (with atomic elements in all final nodes, see <code><a href="#topic+is_unlistable">is_unlistable</a></code>).</p>
</td></tr>
<tr><td><code id="unlist2d_+3A_idcols">idcols</code></td>
<td>
<p>a character stub or a vector of names for id-columns automatically added - one for each level of nesting in <code>l</code>. By default the stub is <code>".id"</code>, so columns will be of the form <code>".id.1", ".id.2",</code> etc... . if <code>idcols = TRUE</code>, the stub is also set to <code>".id"</code>. If <code>idcols = FALSE</code>, id-columns are omitted. The content of the id columns are the list names, or (if missing) integers for the list elements. Missing elements in asymmetric nested structures are filled up with <code>NA</code>. See Examples. </p>
</td></tr>
<tr><td><code id="unlist2d_+3A_row.names">row.names</code></td>
<td>
<p><code>TRUE</code> extracts row names from all the objects in <code>l</code> (where available) and adds them to the output in a column named <code>"row.names"</code>. Alternatively, a column name i.e. <code>row.names = "variable"</code> can be supplied. For plain matrices in <code>l</code>, integer row names are generated. </p>
</td></tr>
<tr><td><code id="unlist2d_+3A_recursive">recursive</code></td>
<td>
<p>logical. if <code>FALSE</code>, only process the lowest (deepest) level of <code>l</code>. See Details.</p>
</td></tr>
<tr><td><code id="unlist2d_+3A_id.factor">id.factor</code></td>
<td>
<p>if <code>TRUE</code> and <code>!isFALSE(idcols)</code>, create id columns as factors instead of character or integer vectors. Alternatively it is possible to specify <code>id.factor = "ordered"</code> to generate ordered factor id's. This is <b>strongly recommended</b> when binding lists of larger data frames, as factors are much more memory efficient than character vectors and also speed up subsequent grouping operations on these columns. </p>
</td></tr>
<tr><td><code id="unlist2d_+3A_dt">DT</code></td>
<td>
<p>logical. <code>TRUE</code> returns a <em>data.table</em>, not a data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame representation created by <code>unlist2d</code> is built as follows:
</p>

<ul>
<li><p> Recurse down to the lowest level of the list-tree, data frames are exempted and treated as a final (atomic) elements.
</p>
</li>
<li><p> Identify the objects, if they are vectors, matrices or arrays convert them to data frame (in the case of atomic vectors each element becomes a column).
</p>
</li>
<li><p> Row-bind these data frames using <em>data.table</em>'s <code>rbindlist</code> function. Columns are matched by name. If the number of columns differ, fill empty spaces with <code>NA</code>'s. If <code>!isFALSE(idcols)</code>, create id-columns on the left, filled with the object names or indices (if the (sub-)list is unnamed). If <code>!isFALSE(row.names)</code>, store rownames of the objects (if available) in a separate column.
</p>
</li>
<li><p> Move up to the next higher level of the list-tree and repeat: Convert atomic objects to data frame and row-bind while matching all columns and filling unmatched ones with <code>NA</code>'s. Create another id-column for each level of nesting passed through. If the list-tree is asymmetric, fill empty spaces in lower-level id columns with <code>NA</code>'s.
</p>
</li></ul>

<p>The result of this iterative procedure is a single data frame containing on the left side id-columns for each level of nesting (from higher to lower level), followed by a column containing all the rownames of the objects (if <code>!isFALSE(row.names)</code>), followed by the data columns, matched at each level of recursion. Optimal results are obtained with symmetric lists of arrays, matrices or data frames, which <code>unlist2d</code> efficiently binds into a beautiful data frame ready for plotting or further analysis. See examples below.
</p>


<h3>Value</h3>

<p>A data frame or (if <code>DT = TRUE</code>) a <em>data.table</em>.
</p>


<h3>Note</h3>

<p>For lists of data frames <code>unlist2d</code> works just like <code>data.table::rbindlist(l, use.names = TRUE, fill = TRUE, idcol = ".id")</code> however for lists of lists <code>unlist2d</code> does not produce the same output as <code>data.table::rbindlist</code> because <code>unlist2d</code> is a recursive function. You can use <code><a href="#topic+rowbind">rowbind</a></code> as a faithful alternative to <code>data.table::rbindlist</code>.
</p>
<p>The function <code>rrapply::rrapply(l, how = "melt"|"bind")</code> is a fast alternative (written fully in C) for nested lists of atomic elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowbind">rowbind</a></code>, <code><a href="#topic+rsplit">rsplit</a></code>, <code><a href="#topic+rapply2d">rapply2d</a></code>, <a href="#topic+list-processing">List Processing</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic Examples:
l &lt;- list(mtcars, list(mtcars, mtcars))
tail(unlist2d(l))
unlist2d(rapply2d(l, fmean))
l = list(a = qM(mtcars[1:8]),
         b = list(c = mtcars[4:11], d = list(e = mtcars[2:10], f = mtcars)))
tail(unlist2d(l, row.names = TRUE))
unlist2d(rapply2d(l, fmean))
unlist2d(rapply2d(l, fmean), recursive = FALSE)

## Groningen Growth and Development Center 10-Sector Database
head(GGDC10S) # See ?GGDC10S
namlab(GGDC10S, class = TRUE)

# Panel-Summarize this data by Variable (Emloyment and Value Added)
l &lt;- qsu(GGDC10S, by = ~ Variable,             # Output as list (instead of 4D array)
         pid = ~ Variable + Country,
         cols = 6:16, array = FALSE)
str(l, give.attr = FALSE)                      # A list of 2-levels with matrices of statistics
head(unlist2d(l))                              # Default output, missing the variables (row-names)
head(unlist2d(l, row.names = TRUE))            # Here we go, but this is still not very nice
head(unlist2d(l, idcols = c("Sector","Trans"), # Now this is looking pretty good
              row.names = "Variable"))

dat &lt;- unlist2d(l, c("Sector","Trans"),        # Id-columns can also be generated as factors
                "Variable", id.factor = TRUE)
str(dat)

# Split this sectoral data, first by Variable (Emloyment and Value Added), then by Country
sdat &lt;- rsplit(GGDC10S, ~ Variable + Country, cols = 6:16)

# Compute pairwise correlations between sectors and recombine:
dat &lt;- unlist2d(rapply2d(sdat, pwcor),
                idcols = c("Variable","Country"),
                row.names = "Sector")
head(dat)
plot(hclust(as.dist(1-pwcor(dat[-(1:3)]))))    # Using corrs. as distance metric to cluster sectors

# List of panel-series matrices
psml &lt;- psmat(fsubset(GGDC10S, Variable == "VA"), ~Country, ~Year, cols = 6:16, array = FALSE)

# Recombining with unlist2d() (effectively like reshapig the data)
head(unlist2d(psml, idcols = "Sector", row.names = "Country"))

rm(l, dat, sdat, psml)
</code></pre>

<hr>
<h2 id='varying'>Fast Check of Variation in Data</h2><span id='topic+varying'></span><span id='topic+varying.default'></span><span id='topic+varying.matrix'></span><span id='topic+varying.data.frame'></span><span id='topic+varying.pseries'></span><span id='topic+varying.pdata.frame'></span><span id='topic+varying.grouped_df'></span><span id='topic+varying.sf'></span>

<h3>Description</h3>

<p><code>varying</code> is a generic function that (column-wise) checks for variation in the values of <code>x</code>, (optionally) within the groups <code>g</code> (e.g. a panel-identifier).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varying(x, ...)

## Default S3 method:
varying(x, g = NULL, any_group = TRUE, use.g.names = TRUE, ...)

## S3 method for class 'matrix'
varying(x, g = NULL, any_group = TRUE, use.g.names = TRUE, drop = TRUE, ...)

## S3 method for class 'data.frame'
varying(x, by = NULL, cols = NULL, any_group = TRUE, use.g.names = TRUE, drop = TRUE, ...)

# Methods for indexed data / compatibility with plm:

## S3 method for class 'pseries'
varying(x, effect = 1L, any_group = TRUE, use.g.names = TRUE, ...)

## S3 method for class 'pdata.frame'
varying(x, effect = 1L, cols = NULL, any_group = TRUE, use.g.names = TRUE,
        drop = TRUE, ...)

# Methods for grouped data frame / compatibility with dplyr:

## S3 method for class 'grouped_df'
varying(x, any_group = TRUE, use.g.names = FALSE, drop = TRUE,
        keep.group_vars = TRUE, ...)

# Methods for grouped data frame / compatibility with sf:

## S3 method for class 'sf'
varying(x, by = NULL, cols = NULL, any_group = TRUE, use.g.names = TRUE, drop = TRUE, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varying_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data frame, 'indexed_series' ('pseries'), 'indexed_frame' ('pdata.frame') or grouped data frame ('grouped_df'). Data must not be numeric.</p>
</td></tr>
<tr><td><code id="varying_+3A_g">g</code></td>
<td>
<p>a factor, <code>GRP</code> object, atomic vector (internally converted to factor) or a list of vectors / factors (internally converted to a <code>GRP</code> object) used to group <code>x</code>.</p>
</td></tr>
<tr><td><code id="varying_+3A_by">by</code></td>
<td>
<p>same as <code>g</code>, but also allows one- or two-sided formulas i.e. <code>~ group1 + group2</code> or <code>var1 + var2 ~ group1 + group2</code>. See Examples</p>
</td></tr>
<tr><td><code id="varying_+3A_any_group">any_group</code></td>
<td>
<p>logical. If <code>!is.null(g)</code>, <code>FALSE</code> will check and report variation in all groups, whereas the default <code>TRUE</code> only checks if there is variation within any group. See Examples.</p>
</td></tr>
<tr><td><code id="varying_+3A_cols">cols</code></td>
<td>
<p>select columns using column names, indices or a function (e.g. <code>is.numeric</code>). Two-sided formulas passed to <code>by</code> overwrite <code>cols</code>.</p>
</td></tr>
<tr><td><code id="varying_+3A_use.g.names">use.g.names</code></td>
<td>
<p>logical. Make group-names and add to the result as names (default method) or row-names (matrix and data frame methods). No row-names are generated for <em>data.table</em>'s.</p>
</td></tr>
<tr><td><code id="varying_+3A_drop">drop</code></td>
<td>
<p><em>matrix and data.frame methods:</em> Logical. <code>TRUE</code> drops dimensions and returns an atomic vector if the result is 1-dimensional.</p>
</td></tr>
<tr><td><code id="varying_+3A_effect">effect</code></td>
<td>
<p><em>plm</em> methods: Select the panel identifier by which variation in the data should be examined. 1L takes the first variable in the <a href="#topic+indexing">index</a>, 2L the second etc.. Index variables can also be called by name. More than one index variable can be supplied, which will be interacted.</p>
</td></tr>
<tr><td><code id="varying_+3A_keep.group_vars">keep.group_vars</code></td>
<td>
<p><em>grouped_df method:</em> Logical. <code>FALSE</code> removes grouping variables after computation.</p>
</td></tr>
<tr><td><code id="varying_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Without groups passed to <code>g</code>, <code>varying</code> simply checks if there is any variation in the columns of <code>x</code> and returns <code>TRUE</code> for each column where this is the case and <code>FALSE</code> otherwise. A set of data points is defined as varying if it contains at least 2 distinct non-missing values (such that a non-0 standard deviation can be computed on numeric data). <code>varying</code> checks for variation in both numeric and non-numeric data.
</p>
<p>If groups are supplied to <code>g</code> (or alternatively a <em>grouped_df</em> to <code>x</code>), <code>varying</code> can operate in one of 2 modes:
</p>

<ul>
<li><p> If <code>any_group = TRUE</code> (the default), <code>varying</code> checks each column for variation in any of the groups defined by <code>g</code>, and returns <code>TRUE</code> if such within-variation was detected and <code>FALSE</code> otherwise. Thus only one logical value is returned for each column and the computation on each column is terminated as soon as any variation within any group was found.
</p>
</li>
<li><p> If <code>any_group = FALSE</code>, <code>varying</code> runs through the entire data checking each group for variation and returns, for each column in <code>x</code>, a logical vector reporting the variation check for all groups. If a group contains only missing values, a <code>NA</code> is returned for that group.
</p>
</li></ul>

<p>The <em>sf</em> method simply ignores the geometry column.
</p>


<h3>Value</h3>

<p>A logical vector or (if <code>!is.null(g)</code> and <code>any_group = FALSE</code>), a matrix or data frame of logical vectors indicating whether the data vary (over the dimension supplied by <code>g</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+summary-statistics">Summary Statistics</a>, <a href="#topic+data-transformations">Data Transformations</a>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Checks overall variation in all columns
varying(wlddev)

## Checks whether data are time-variant i.e. vary within country
varying(wlddev, ~ country)

## Same as above but done for each country individually, countries without data are coded NA
head(varying(wlddev, ~ country, any_group = FALSE))
</code></pre>

<hr>
<h2 id='wlddev'>
World Development Dataset
</h2><span id='topic+wlddev'></span>

<h3>Description</h3>

<p>This dataset contains 5 indicators from the World Bank's World Development Indicators (WDI) database: (1) GDP per capita, (2) Life expectancy at birth, (3) GINI index, (4) Net ODA and official aid received and (5) Population. The panel data is balanced and covers 216 present and historic countries from 1960-2020 (World Bank aggregates and regional entities are excluded).
</p>
<p>Apart from the indicators the data contains a number of identifiers (character country name, factor ISO3 country code, World Bank region and income level, numeric year and decade) and 2 generated variables: A logical variable indicating whether the country is an OECD member, and a fictitious variable stating the date the data was recorded. These variables were added so that all common data-types are represented in this dataset, making it an ideal test-dataset for certain <em>collapse</em> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("wlddev")</code></pre>


<h3>Format</h3>

<p>A data frame with 13176 observations on the following 13 variables. All variables are labeled e.g. have a 'label' attribute.
</p>

<dl>
<dt><code>country</code></dt><dd><p><em>chr</em> Country Name</p>
</dd>
<dt><code>iso3c</code></dt><dd><p><em>fct</em> Country Code</p>
</dd>
<dt><code>date</code></dt><dd><p><em>date</em> Date Recorded (Fictitious)</p>
</dd>
<dt><code>year</code></dt><dd><p><em>int</em> Year</p>
</dd>
<dt><code>decade</code></dt><dd><p><em>int</em> Decade</p>
</dd>
<dt><code>region</code></dt><dd><p><em>fct</em> World Bank Region</p>
</dd>
<dt><code>income</code></dt><dd><p><em>fct</em> World Bank Income Level</p>
</dd>
<dt><code>OECD</code></dt><dd><p><em>log</em> Is OECD Member Country?</p>
</dd>
<dt><code>PCGDP</code></dt><dd><p><em>num</em> GDP per capita (constant 2010 US$)</p>
</dd>
<dt><code>LIFEEX</code></dt><dd><p><em>num</em> Life expectancy at birth, total (years)</p>
</dd>
<dt><code>GINI</code></dt><dd><p><em>num</em> GINI index (World Bank estimate)</p>
</dd>
<dt><code>ODA</code></dt><dd><p><em>num</em> Net official development assistance and official aid received (constant 2018 US$)</p>
</dd>
<dt><code>POP</code></dt><dd><p><em>num</em> Population, total</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://data.worldbank.org/">https://data.worldbank.org/</a>, accessed via the <code>WDI</code> package. The codes for the series are <code>c("NY.GDP.PCAP.KD", "SP.DYN.LE00.IN", "SI.POV.GINI", "DT.ODA.ALLD.KD", "SP.POP.TOTL")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GGDC10S">GGDC10S</a></code>, <a href="#topic+collapse-documentation">Collapse Overview</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wlddev)

# Panel-summarizing the 5 series
qsu(wlddev, pid = ~iso3c, cols = 9:13, vlabels = TRUE)

# By Region
qsu(wlddev, by = ~region, cols = 9:13, vlabels = TRUE)

# Panel-summary by region
qsu(wlddev, by = ~region, pid = ~iso3c, cols = 9:13, vlabels = TRUE)

# Pairwise correlations: Ovarall
print(pwcor(get_vars(wlddev, 9:13), N = TRUE, P = TRUE), show = "lower.tri")

# Pairwise correlations: Between Countries
print(pwcor(fmean(get_vars(wlddev, 9:13), wlddev$iso3c), N = TRUE, P = TRUE), show = "lower.tri")

# Pairwise correlations: Within Countries
print(pwcor(fwithin(get_vars(wlddev, 9:13), wlddev$iso3c), N = TRUE, P = TRUE), show = "lower.tri")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
