<!DOCTYPE html><html><head><title>Help for package mod2rm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mod2rm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mod2rm'><p>Moderation Analysis for Two-Instance Repeated Measures Designs</p></a></li>
<li><a href='#summary.mod2rm'><p>Print and summary function for objects of class &quot;mod2rm&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Moderation Analysis for Two-Instance Repeated Measures Designs</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple moderation analysis for two-instance repeated measures designs, with up to three simultaneous moderators (dichotomous and/or continuous) with additive or multiplicative relationship. Includes analyses of simple slopes and conditional effects at (automatically determined or manually set) values of the moderator(s), as well as an implementation of the Johnson-Neyman procedure for determining regions of significance in single moderator models. Based on Montoya, A. K. (2018) "Moderation analysis in two-instance repeated measures designs: Probing methods and multiple moderator models" &lt;<a href="https://doi.org/10.3758%2Fs13428-018-1088-6">doi:10.3758/s13428-018-1088-6</a>&gt; .</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-29</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, ggplot2, scales</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Forstmann &lt;matthias.forstmann@uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-29 18:44:24 UTC; matfor</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Forstmann [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-30 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mod2rm'>Moderation Analysis for Two-Instance Repeated Measures Designs</h2><span id='topic+mod2rm'></span>

<h3>Description</h3>

<p>Multiple moderation analysis for two-instance repeated measures designs, including analyses of simple slopes and conditional effects at values of the moderator(s).<br /><br />
Currently supports both single- and multi-moderator models, with up to three simultaneous moderators (continuous and/or binary). Multi-moderator models support both additive (method = 1) and multiplicative (method = 2) moderation.<br /><br />
Also supports the Johnson-Neyman procedure for determining regions of significance in single moderator models (jn = T). Plots of the JN region can be obtained from the summary function (plotjn = T).<br /><br />
Moderator values at which to test for conditional effects are determined automatically (at -1, 0, and +1 SD of the mean if the moderator is countinuous, and at both values of the moderator if it is binary), but any number of test values can also be set manually for each moderator.<br /><br />
Method and output based on: Montoya, A. K. (2018). Moderation analysis in two-instance repeated measures designs: Probing methods and multiple moderator models. <em>Behavior Research Methods, 51(1)</em>, 61-82.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod2rm(
  data,
  Y1,
  Y2,
  MOD1,
  MOD2 = NULL,
  MOD3 = NULL,
  MOD1val = NULL,
  MOD2val = NULL,
  MOD3val = NULL,
  method = 1,
  standardize = FALSE,
  jn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod2rm_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_y1">Y1</code></td>
<td>
<p>Name of the first outcome variable</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_y2">Y2</code></td>
<td>
<p>Name of the second outcome variable</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod1">MOD1</code></td>
<td>
<p>Name of moderator1 variable</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod2">MOD2</code></td>
<td>
<p>Name of moderator2 variable (optional)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod3">MOD3</code></td>
<td>
<p>Name of moderator3 variable (optional)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod1val">MOD1val</code></td>
<td>
<p>A vector containing values of moderator1 at which to test for conditional effects (even when variables have been standardized!)(optional)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod2val">MOD2val</code></td>
<td>
<p>A vector containing values of moderator2 at which to test for conditional effects (even when variables have been standardized!)(optional)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_mod3val">MOD3val</code></td>
<td>
<p>A vector containing values of moderator3 at which to test for conditional effects (even when variables have been standardized!)(optional)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_method">method</code></td>
<td>
<p>Method for dealing with two or more moderators (1 = additive, 2 = multiplicative) (default: additive)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_standardize">standardize</code></td>
<td>
<p>boolean variable indicating whether all predictor variables (moderators) should be standardized prior to the analyses (default: FALSE)</p>
</td></tr>
<tr><td><code id="mod2rm_+3A_jn">jn</code></td>
<td>
<p>boolean variable indicating whether the Johnson-Neyman procedure should be calculated (only available for single moderator models)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>total</code></td>
<td>
<p>A list of class &quot;mod2rm&quot; containing:</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>A named number vector containing values for the number of moderators in the model (num_mods), the number of binary moderators (num_binary_mods), the sample size (sample_size), the method of moderation (method; 1 = additive, 2 = multiplicative), and whether the Johnson-Neyman procedure was run (jn)</p>
</td></tr>
<tr><td><code>var_names</code></td>
<td>
<p>A named character vector containing the name of the original dataframe (dataframe), the two outcome variables (y1,y2), and up to three moderators (mod1,mod2,mod3)</p>
</td></tr>
<tr><td><code>res_mod</code></td>
<td>
<p>A list including the results of a simple regression, regressing the difference between y1 and y2 on the moderator</p>
</td></tr>
<tr><td><code>res_simple_y1</code></td>
<td>
<p>A list including the results of a simple regression, regressing the y1 on the moderator</p>
</td></tr>
<tr><td><code>res_simple_y2</code></td>
<td>
<p>A list including the results of a simple regression, regressing the y2 on the moderator</p>
</td></tr>
<tr><td><code>res_cond_eff</code></td>
<td>
<p>A list including the results of an analysis of conditional effects at different levels of the moderator(s)</p>
</td></tr>
<tr><td><code>res_y1y2_diff</code></td>
<td>
<p>A list including the results of a repeated measures t-test for y1 and y2</p>
</td></tr>
<tr><td><code>res_jn_area</code></td>
<td>
<p>A list containing information on the Johnson-Neyman procedure, incluing the number of significance points identified within the data range (num_jn), the moderator values of these points, as well as the proportion of the sample scoring higher than these values (jn_values), and information on whether the JN region is significant or non-significent (center_significant; used for plotting.)</p>
</td></tr>
<tr><td><code>res_jn_cond_eff</code></td>
<td>
<p>A list containing additional conditonal effects at levels of the moderator around the JN region. Values span the entir data range in 20 steps.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a dataset with a Johnson-Neyman (non-)significance region within the response range:

repeat{
  df = data.frame(out1 = runif(n = 100, min = 1, max = 9), 
                  out2 = runif(n = 100, min = 1, max = 9), 
                  w1 = runif(n = 100, min = 1, max = 9),  
                  w2 = runif(n = 100, min = 1, max = 9),
                  w3 = runif(n = 100, min = 1, max = 9))
  res = mod2rm(df, out1, out2, w1, jn = TRUE)
  if(res$res_jn_area["num_jn"] == 2 &amp; res$res_jn_area["center_significant"] == FALSE)
    break
}

# Show summary including plot
summary.mod2rm(res, plotjn = TRUE, plotstyle = "simple")

# Multiple regression (3 moderators, additive)
res1 = mod2rm(df, out1, out2, w1, w2, w3, method = 1)
summary.mod2rm(res1)

# Multiple regression (2 moderators, multiplicative, manually defined conditional effects)
res2 = mod2rm(df, out1, out2, w1, w2, MOD1val = c(2,3,4), MOD2val = c(4,5), method = 2)
summary.mod2rm(res2)


</code></pre>

<hr>
<h2 id='summary.mod2rm'>Print and summary function for objects of class &quot;mod2rm&quot;</h2><span id='topic+summary.mod2rm'></span>

<h3>Description</h3>

<p>Prints a summary of a list object of class &quot;mod2rm&quot;, and (if requested) plot the results of the Johnson-Neyman procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mod2rm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mod2rm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;mod2rm&quot;</p>
</td></tr>
<tr><td><code id="summary.mod2rm_+3A_...">...</code></td>
<td>
<p>Additional parameters. &quot;plotjn = TRUE&quot; produces a ggplot for the Johnson-Neyman procedure, &quot;plotstyle&quot; can be set to &quot;simple&quot; or &quot;points&quot; (including data points in the plot)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a summary for the results of an object of the type mod2rm, and can further be used to plot a graph showing the results of the JN procedure, if it is included in the mod2rm object.
#' Results include number and name(s) of moderator(s), sample size, results of a paired t-test between both dependent variables, the results of the moderation analysis, conditional effects of the moderator on each of the dependent variables, conditional effects at values of the moderator, and the results of the Johnson-Neyman procedure (including critical values, proportion of the sample above/below these values, and conditional effects around the significance regions.
</p>


<h3>Value</h3>

<p>Prints summary of the object, then returns NULL or (when requested) a ggplot2 object for the Johnson-Neyman plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a dataset with a Johnson-Neyman (non-)significance region within the response range:

repeat{
  df = data.frame(out1 = runif(n = 100, min = 1, max = 9), 
                  out2 = runif(n = 100, min = 1, max = 9), 
                  w1 = runif(n = 100, min = 1, max = 9),  
                  w2 = runif(n = 100, min = 1, max = 9),
                  w3 = runif(n = 100, min = 1, max = 9))
  res = mod2rm(df, out1, out2, w1, jn = TRUE)
  if(res$res_jn_area["num_jn"] == 2 &amp; res$res_jn_area["center_significant"] == FALSE)
    break
}

# Show summary including plot
summary.mod2rm(res, plotjn = TRUE, plotstyle = "simple")

# Multiple regression (3 moderators, additive)
res1 = mod2rm(df, out1, out2, w1, w2, w3, method = 1)
summary.mod2rm(res1)

# Multiple regression (2 moderators, multiplicative, manually defined conditional effects)
res2 = mod2rm(df, out1, out2, w1, w2, MOD1val = c(2,3,4), MOD2val = c(4,5), method = 2)
summary.mod2rm(res2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
