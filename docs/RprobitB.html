<!DOCTYPE html><html lang="en"><head><title>Help for package RprobitB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RprobitB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RprobitB-package'><p>RprobitB: Bayesian Probit Choice Modeling</p></a></li>
<li><a href='#as_cov_names'><p>Re-label alternative specific covariates</p></a></li>
<li><a href='#check_form'><p>Check model formula</p></a></li>
<li><a href='#check_prior'><p>Check prior parameters</p></a></li>
<li><a href='#choice_probabilities'><p>Compute choice probabilities</p></a></li>
<li><a href='#classification'><p>Classify deciders preference-based</p></a></li>
<li><a href='#coef.RprobitB_fit'><p>Extract model effects</p></a></li>
<li><a href='#compute_choice_probabilities'><p>Compute probit choice probabilities</p></a></li>
<li><a href='#compute_p_si'><p>Compute choice probabilities at posterior samples</p></a></li>
<li><a href='#cov_mix'><p>Extract estimated covariance matrix of mixing distribution</p></a></li>
<li><a href='#create_labels_alpha'><p>Create labels for <code>alpha</code></p></a></li>
<li><a href='#create_labels_b'><p>Create labels for <code>b</code></p></a></li>
<li><a href='#create_labels_d'><p>Create labels for <code>d</code></p></a></li>
<li><a href='#create_labels_Omega'><p>Create labels for <code>Omega</code></p></a></li>
<li><a href='#create_labels_s'><p>Create labels for <code>s</code></p></a></li>
<li><a href='#create_labels_Sigma'><p>Create labels for <code>Sigma</code></p></a></li>
<li><a href='#create_lagged_cov'><p>Create lagged choice covariates</p></a></li>
<li><a href='#d_to_gamma'><p>Transform threshold increments to thresholds</p></a></li>
<li><a href='#dmvnorm'><p>Density of multivariate normal distribution</p></a></li>
<li><a href='#draw_from_prior'><p>Sample from prior distributions</p></a></li>
<li><a href='#euc_dist'><p>Euclidean distance</p></a></li>
<li><a href='#filter_gibbs_samples'><p>Filter Gibbs samples</p></a></li>
<li><a href='#fit_model'><p>Fit probit model to choice data</p></a></li>
<li><a href='#get_cov'><p>Extract covariates of choice occasion</p></a></li>
<li><a href='#gibbs_sampling'><p>Markov chain Monte Carlo simulation for the probit model</p></a></li>
<li><a href='#ll_ordered'><p>Log-likelihood in the ordered probit model</p></a></li>
<li><a href='#missing_covariates'><p>Handle missing covariates</p></a></li>
<li><a href='#mml'><p>Approximate marginal model likelihood</p></a></li>
<li><a href='#model_selection'><p>Compare fitted models</p></a></li>
<li><a href='#npar'><p>Extract number of model parameters</p></a></li>
<li><a href='#overview_effects'><p>Print effect overview</p></a></li>
<li><a href='#parameter_labels'><p>Create parameters labels</p></a></li>
<li><a href='#plot_acf'><p>Autocorrelation plot of Gibbs samples</p></a></li>
<li><a href='#plot_class_allocation'><p>Plot class allocation (for <code>P_r = 2</code> only)</p></a></li>
<li><a href='#plot_class_seq'><p>Visualizing the number of classes during Gibbs sampling</p></a></li>
<li><a href='#plot_mixture_contour'><p>Plot bivariate contour of mixing distributions</p></a></li>
<li><a href='#plot_mixture_marginal'><p>Plot marginal mixing distributions</p></a></li>
<li><a href='#plot_roc'><p>Plot ROC curve</p></a></li>
<li><a href='#plot_trace'><p>Visualizing the trace of Gibbs samples.</p></a></li>
<li><a href='#plot.RprobitB_data'><p>Visualize choice data</p></a></li>
<li><a href='#plot.RprobitB_fit'><p>Visualize fitted probit model</p></a></li>
<li><a href='#point_estimates'><p>Compute point estimates</p></a></li>
<li><a href='#posterior_pars'><p>Parameter sets from posterior samples</p></a></li>
<li><a href='#pred_acc'><p>Compute prediction accuracy</p></a></li>
<li><a href='#predict.RprobitB_fit'><p>Predict choices</p></a></li>
<li><a href='#preference_flip'><p>Check for flip in preferences after change in model scale.</p></a></li>
<li><a href='#prepare_data'><p>Prepare choice data for estimation</p></a></li>
<li><a href='#R_hat'><p>Compute Gelman-Rubin statistic</p></a></li>
<li><a href='#rdirichlet'><p>Draw from Dirichlet distribution</p></a></li>
<li><a href='#rmvnorm'><p>Draw from multivariate normal distribution</p></a></li>
<li><a href='#RprobitB_data'><p>Create object of class <code>RprobitB_data</code></p></a></li>
<li><a href='#RprobitB_fit'><p>Create object of class <code>RprobitB_fit</code></p></a></li>
<li><a href='#RprobitB_gibbs_samples_statistics'><p>Create object of class <code>RprobitB_gibbs_samples_statistics</code></p></a></li>
<li><a href='#RprobitB_latent_classes'><p>Create object of class <code>RprobitB_latent_classes</code></p></a></li>
<li><a href='#RprobitB_normalization'><p>Create object of class <code>RprobitB_normalization</code></p></a></li>
<li><a href='#RprobitB_parameter'><p>Define probit model parameter</p></a></li>
<li><a href='#rtnorm'><p>Draw from one-sided truncated normal</p></a></li>
<li><a href='#rttnorm'><p>Draw from two-sided truncated normal</p></a></li>
<li><a href='#rwishart'><p>Draw from Wishart distribution</p></a></li>
<li><a href='#set_initial_gibbs_values'><p>Set initial values for the Gibbs sampler</p></a></li>
<li><a href='#simulate_choices'><p>Simulate choice data</p></a></li>
<li><a href='#sufficient_statistics'><p>Compute sufficient statistics</p></a></li>
<li><a href='#train_choice'><p>Stated Preferences for Train Traveling</p></a></li>
<li><a href='#train_test'><p>Split choice data in train and test subset</p></a></li>
<li><a href='#transform_gibbs_samples'><p>Transformation of Gibbs samples</p></a></li>
<li><a href='#transform_parameter'><p>Transformation of parameter values</p></a></li>
<li><a href='#transform.RprobitB_fit'><p>Transform fitted probit model</p></a></li>
<li><a href='#undiff_Sigma'><p>Transform differenced to non-differenced error term covariance matrix</p></a></li>
<li><a href='#update_b'><p>Update class means</p></a></li>
<li><a href='#update_classes_dp'><p>Dirichlet process-based update of latent classes</p></a></li>
<li><a href='#update_classes_wb'><p>Weight-based update of latent classes</p></a></li>
<li><a href='#update_d'><p>Update utility threshold increments</p></a></li>
<li><a href='#update_m'><p>Update class sizes</p></a></li>
<li><a href='#update_Omega'><p>Update class covariances</p></a></li>
<li><a href='#update_reg'><p>Update coefficient vector of multiple linear regression</p></a></li>
<li><a href='#update_s'><p>Update class weight vector</p></a></li>
<li><a href='#update_Sigma'><p>Update error term covariance matrix of multiple linear regression</p></a></li>
<li><a href='#update_U'><p>Update latent utility vector</p></a></li>
<li><a href='#update_U_ranked'><p>Update latent utility vector in the ranked probit case</p></a></li>
<li><a href='#update_z'><p>Update class allocation vector</p></a></li>
<li><a href='#update.RprobitB_fit'><p>Update and re-fit probit model</p></a></li>
<li><a href='#WAIC'><p>Compute WAIC value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Probit Choice Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Bayes estimation of probit choice models, both in the cross-sectional and 
    panel setting. The package can analyze binary, multivariate, ordered, and 
    ranked choices, as well as heterogeneity of choice behavior among deciders. 
    The main functionality includes model fitting via Markov chain Monte Carlo m
    ethods, tools for convergence  diagnostic, choice data simulation, in-sample 
    and out-of-sample choice prediction, and model selection using information 
    criteria and Bayes factors. The latent class model extension facilitates 
    preference-based decider classification, where the number of latent classes 
    can be inferred via the Dirichlet process or a weight-based updating 
    heuristic. This allows for flexible modeling of choice behavior without the 
    need to impose structural constraints. 
    For a reference on the method see Oelschlaeger and Bauer (2021) 
    <a href="https://trid.trb.org/view/1759753">https://trid.trb.org/view/1759753</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://loelschlaeger.de/RprobitB/">https://loelschlaeger.de/RprobitB/</a>,
<a href="https://github.com/loelschlaeger/RprobitB">https://github.com/loelschlaeger/RprobitB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/loelschlaeger/RprobitB/issues">https://github.com/loelschlaeger/RprobitB/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, cli, crayon, doSNOW, foreach, ggplot2, graphics,
gridExtra, MASS, mixtools, mvtnorm, oeli (&ge; 0.4.1), parallel,
plotROC, progress, Rcpp, Rdpack, rlang, stats, utils, viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mlogit, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 10:52:22 UTC; loelschlaeger@ad.uni-bielefeld.de</td>
</tr>
<tr>
<td>Author:</td>
<td>Lennart Oelschläger
    <a href="https://orcid.org/0000-0001-5421-9313"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Dietmar Bauer <a href="https://orcid.org/0000-0003-2920-7032"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sebastian Büscher [ctb],
  Manuel Batram [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lennart Oelschläger &lt;oelschlaeger.lennart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 14:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='RprobitB-package'>RprobitB: Bayesian Probit Choice Modeling</h2><span id='topic+RprobitB'></span><span id='topic+RprobitB-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Bayes estimation of probit choice models, both in the cross-sectional and panel setting. The package can analyze binary, multivariate, ordered, and ranked choices, as well as heterogeneity of choice behavior among deciders. The main functionality includes model fitting via Markov chain Monte Carlo m ethods, tools for convergence diagnostic, choice data simulation, in-sample and out-of-sample choice prediction, and model selection using information criteria and Bayes factors. The latent class model extension facilitates preference-based decider classification, where the number of latent classes can be inferred via the Dirichlet process or a weight-based updating heuristic. This allows for flexible modeling of choice behavior without the need to impose structural constraints. For a reference on the method see Oelschlaeger and Bauer (2021) <a href="https://trid.trb.org/view/1759753">https://trid.trb.org/view/1759753</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lennart Oelschläger <a href="mailto:oelschlaeger.lennart@gmail.com">oelschlaeger.lennart@gmail.com</a> (<a href="https://orcid.org/0000-0001-5421-9313">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Dietmar Bauer <a href="mailto:dietmar.bauer@uni-bielefeld.de">dietmar.bauer@uni-bielefeld.de</a> (<a href="https://orcid.org/0000-0003-2920-7032">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sebastian Büscher <a href="mailto:sebastian.buescher@uni-bielefeld.de">sebastian.buescher@uni-bielefeld.de</a> [contributor]
</p>
</li>
<li><p> Manuel Batram <a href="mailto:manuel.batram@uni-bielefeld.de">manuel.batram@uni-bielefeld.de</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://loelschlaeger.de/RprobitB/">https://loelschlaeger.de/RprobitB/</a>
</p>
</li>
<li> <p><a href="https://github.com/loelschlaeger/RprobitB">https://github.com/loelschlaeger/RprobitB</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/loelschlaeger/RprobitB/issues">https://github.com/loelschlaeger/RprobitB/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_cov_names'>Re-label alternative specific covariates</h2><span id='topic+as_cov_names'></span>

<h3>Description</h3>

<p>In <code>{RprobitB}</code>, alternative specific covariates must be named in the format
<code>"&lt;covariate&gt;_&lt;alternative&gt;"</code>. This convenience function generates
the format for a given <code>choice_data</code> set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cov_names(choice_data, cov, alternatives)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_cov_names_+3A_choice_data">choice_data</code></td>
<td>
<p>A <code>data.frame</code> of choice data in wide format, i.e. each row represents
one choice occasion.</p>
</td></tr>
<tr><td><code id="as_cov_names_+3A_cov">cov</code></td>
<td>
<p>A character vector of the names of alternative specific covariates in
<code>choice_data</code>.</p>
</td></tr>
<tr><td><code id="as_cov_names_+3A_alternatives">alternatives</code></td>
<td>
<p>A (character or numeric) vector of the alternative names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>choice_data</code> input with updated column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Electricity", package = "mlogit")
cov &lt;- c("pf", "cl", "loc", "wk", "tod", "seas")
alternatives &lt;- 1:4
colnames(Electricity)
Electricity &lt;- as_cov_names(Electricity, cov, alternatives)
colnames(Electricity)

</code></pre>

<hr>
<h2 id='check_form'>Check model formula</h2><span id='topic+check_form'></span>

<h3>Description</h3>

<p>This function checks the input <code>form</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_form(form, re = NULL, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_form_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="check_form_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="check_form_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains the following elements:
</p>

<ul>
<li><p> The input <code>form</code>.
</p>
</li>
<li><p> The name <code>choice</code> of the dependent variable in <code>form</code>.
</p>
</li>
<li><p> The input <code>re</code>.
</p>
</li>
<li><p> A list <code>vars</code> of three character vectors of covariate names of
the three covariate types.
</p>
</li>
<li><p> A boolean <code>ASC</code>, determining whether the model has ASCs.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+overview_effects">overview_effects()</a></code> for an overview of the model effects
</p>

<hr>
<h2 id='check_prior'>Check prior parameters</h2><span id='topic+check_prior'></span>

<h3>Description</h3>

<p>This function checks the compatibility of submitted parameters for the prior
distributions and sets missing values to default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prior(
  P_f,
  P_r,
  J,
  ordered = FALSE,
  eta = numeric(P_f),
  Psi = diag(P_f),
  delta = 1,
  xi = numeric(P_r),
  D = diag(P_r),
  nu = P_r + 2,
  Theta = diag(P_r),
  kappa = if (ordered) 4 else (J + 1),
  E = if (ordered) diag(1) else diag(J - 1),
  zeta = numeric(J - 2),
  Z = diag(J - 2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_prior_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="check_prior_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="check_prior_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_eta">eta</code></td>
<td>
<p>The mean vector of length <code>P_f</code> of the normal prior for <code>alpha</code>.
Per default, <code>eta = numeric(P_f)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_psi">Psi</code></td>
<td>
<p>The covariance matrix of dimension <code>P_f</code> x <code>P_f</code> of the normal prior for
<code>alpha</code>.
Per default, <code>Psi = diag(P_f)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_delta">delta</code></td>
<td>
<p>A numeric for the concentration parameter vector <code>rep(delta,C)</code> of the
Dirichlet prior for <code>s</code>.
Per default, <code>delta = 1</code>. In case of Dirichlet process-based updates of the
latent classes, <code>delta = 0.1</code> per default.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_xi">xi</code></td>
<td>
<p>The mean vector of length <code>P_r</code> of the normal prior for each <code>b_c</code>.
Per default, <code>xi = numeric(P_r)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_d">D</code></td>
<td>
<p>The covariance matrix of dimension <code>P_r</code> x <code>P_r</code> of the normal prior for
each <code>b_c</code>.
Per default, <code>D = diag(P_r)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_nu">nu</code></td>
<td>
<p>The degrees of freedom (a natural number greater than <code>P_r</code>) of the Inverse
Wishart prior for each <code>Omega_c</code>.
Per default, <code>nu = P_r + 2</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_theta">Theta</code></td>
<td>
<p>The scale matrix of dimension <code>P_r</code> x <code>P_r</code> of the Inverse Wishart prior for
each <code>Omega_c</code>.
Per default, <code>Theta = diag(P_r)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_kappa">kappa</code></td>
<td>
<p>The degrees of freedom (a natural number greater than <code>J-1</code>) of the Inverse
Wishart prior for <code>Sigma</code>.
Per default, <code>kappa = J + 1</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_e">E</code></td>
<td>
<p>The scale matrix of dimension <code>J-1</code> x <code>J-1</code> of the Inverse Wishart
prior for <code>Sigma</code>.
Per default, <code>E = diag(J - 1)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_zeta">zeta</code></td>
<td>
<p>The mean vector of length <code>J - 2</code> of the normal prior for the logarithmic
increments <code>d</code> of the utility thresholds in the ordered probit model.
Per default, <code>zeta = numeric(J - 2)</code>.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_z">Z</code></td>
<td>
<p>The covariance matrix of dimension <code>J-2</code> x <code>J-2</code> of the normal prior for the
logarithmic increments <code>d</code> of the utility thresholds in the ordered probit
model. Per default, <code>Z = diag(J - 2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A priori, we assume that the model parameters follow these distributions:
</p>

<ul>
<li> <p><code class="reqn">\alpha \sim N(\eta, \Psi)</code>
</p>
</li>
<li> <p><code class="reqn">s \sim Dir(\delta)</code>
</p>
</li>
<li> <p><code class="reqn">b_c \sim N(\xi, D)</code> for all classes <code class="reqn">c</code>
</p>
</li>
<li> <p><code class="reqn">\Omega_c \sim IW(\nu,\Theta)</code> for all classes <code class="reqn">c</code>
</p>
</li>
<li> <p><code class="reqn">\Sigma \sim IW(\kappa,E)</code>
</p>
</li>
<li> <p><code class="reqn">d \sim N(\zeta, Z)</code>
</p>
</li></ul>

<p>where <code class="reqn">N</code> denotes the normal, <code class="reqn">Dir</code> the Dirichlet, and <code class="reqn">IW</code>
the Inverted Wishart distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>RprobitB_prior</code>, which is a list containing all
prior parameters. Parameters that are not relevant for the model
configuration are set to <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_prior(P_f = 1, P_r = 2, J = 3, ordered = TRUE)
</code></pre>

<hr>
<h2 id='choice_probabilities'>Compute choice probabilities</h2><span id='topic+choice_probabilities'></span>

<h3>Description</h3>

<p>This function returns the choice probabilities of an <code>RprobitB_fit</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choice_probabilities(x, data = NULL, par_set = mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choice_probabilities_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="choice_probabilities_+3A_data">data</code></td>
<td>
<p>Either <code>NULL</code> or an object of class <code>RprobitB_data</code>. In the former
case, choice probabilities are computed for the data that was used for model
fitting. Alternatively, a new data set can be provided.</p>
</td></tr>
<tr><td><code id="choice_probabilities_+3A_par_set">par_set</code></td>
<td>
<p>Specifying the parameter set for calculation and either
</p>

<ul>
<li><p> a function that computes a posterior point estimate (the default is
<code>mean()</code>),
</p>
</li>
<li> <p><code>"true"</code> to select the true parameter set,
</p>
</li>
<li><p> an object of class <code>RprobitB_parameter</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of choice probabilities with choice situations in rows and
alternatives in columns. The first two columns are the decider identifier
<code>"id"</code> and the choice situation identifier <code>"idc"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_choices(form = choice ~ covariate, N = 10, T = 10, J = 2)
x &lt;- fit_model(data)
choice_probabilities(x)

</code></pre>

<hr>
<h2 id='classification'>Classify deciders preference-based</h2><span id='topic+classification'></span>

<h3>Description</h3>

<p>This function classifies the deciders based on their allocation to the
components of the mixing distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classification(x, add_true = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classification_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="classification_+3A_add_true">add_true</code></td>
<td>
<p>Set to <code>TRUE</code> to add true class memberships to output (if available).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can only be used if the model has at least one random effect
(i.e. <code>P_r &gt;= 1</code>) and at least two latent classes (i.e. <code>C &gt;= 2</code>).
</p>
<p>In that case, let <code class="reqn">z_1,\dots,z_N</code> denote the class allocations
of the <code class="reqn">N</code> deciders based on their estimated mixed coefficients
<code class="reqn">\beta = (\beta_1,\dots,\beta_N)</code>.
Independently for each decider <code class="reqn">n</code>, the conditional probability
<code class="reqn">\Pr(z_n = c \mid s,\beta_n,b,\Omega)</code> of having <code class="reqn">\beta_n</code>
allocated to class <code class="reqn">c</code> for <code class="reqn">c=1,\dots,C</code> depends on the class
allocation vector <code class="reqn">s</code>, the class means <code class="reqn">b=(b_c)_c</code> and the class
covariance matrices <code class="reqn">Omega=(Omega_c)_c</code> and is proportional to
</p>
<p style="text-align: center;"><code class="reqn">s_c \phi(\beta_n \mid b_c,Omega_c).</code>
</p>

<p>This function displays the relative frequencies of which each decider
was allocated to the classes during the Gibbs sampling. Only the
thinned samples after the burn-in period are considered.
</p>


<h3>Value</h3>

<p>A data frame. The row names are the decider ids. The first <code>C</code> columns
contain the relative frequencies with which the deciders are allocated to
the <code>C</code> classes. Next, the column <code>est</code> contains the estimated
class of the decider based on the highest allocation frequency. If
<code>add_true</code>, the next column <code>true</code> contains the true class
memberships.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_z">update_z()</a></code> for the updating function of the class allocation vector.
</p>

<hr>
<h2 id='coef.RprobitB_fit'>Extract model effects</h2><span id='topic+coef.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function extracts the estimated model effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_fit'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.RprobitB_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="coef.RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_coef</code>.
</p>

<hr>
<h2 id='compute_choice_probabilities'>Compute probit choice probabilities</h2><span id='topic+compute_choice_probabilities'></span>

<h3>Description</h3>

<p>This is a helper function for <code><a href="#topic+choice_probabilities">choice_probabilities</a></code> and computes
the probit choice probabilities for a single choice situation with <code>J</code>
alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_choice_probabilities(X, alternatives, parameter, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_choice_probabilities_+3A_x">X</code></td>
<td>
<p>A matrix of covariates with <code>J</code> rows and <code>P_f + P_r</code> columns, where
the first <code>P_f</code> columns are connected to fixed coefficients and the last
<code>P_r</code> columns are connected to random coefficients.</p>
</td></tr>
<tr><td><code id="compute_choice_probabilities_+3A_alternatives">alternatives</code></td>
<td>
<p>A vector with unique integers from <code>1</code> to <code>J</code>, indicating the
alternatives for which choice probabilities are to be computed.</p>
</td></tr>
<tr><td><code id="compute_choice_probabilities_+3A_parameter">parameter</code></td>
<td>
<p>An object of class <code>RprobitB_parameter</code>.</p>
</td></tr>
<tr><td><code id="compute_choice_probabilities_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A probability vector of length <code>length(alternatives)</code>.
</p>

<hr>
<h2 id='compute_p_si'>Compute choice probabilities at posterior samples</h2><span id='topic+compute_p_si'></span>

<h3>Description</h3>

<p>This function computes the probability for each observed choice at the
(normalized, burned and thinned) samples from the posterior. These
probabilities are required to compute the <code><a href="#topic+WAIC">WAIC</a></code> and the
marginal model likelihood <code><a href="#topic+mml">mml</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_p_si(x, ncores = parallel::detectCores() - 1, recompute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_p_si_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="compute_p_si_+3A_ncores">ncores</code></td>
<td>
<p>This function is parallelized, set the number of cores here.</p>
</td></tr>
<tr><td><code id="compute_p_si_+3A_recompute">recompute</code></td>
<td>
<p>Set to <code>TRUE</code> to recompute the probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object <code>x</code>, including the object <code>p_si</code>, which is a matrix of
probabilities, observations in rows and posterior samples in columns.
</p>

<hr>
<h2 id='cov_mix'>Extract estimated covariance matrix of mixing distribution</h2><span id='topic+cov_mix'></span>

<h3>Description</h3>

<p>This convenience function returns the estimated covariance matrix of the
mixing distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_mix(x, cor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_mix_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="cov_mix_+3A_cor">cor</code></td>
<td>
<p>If <code>TRUE</code>, returns the correlation matrix instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated covariance matrix of the mixing distribution. In case of
multiple classes, a list of matrices for each class.
</p>

<hr>
<h2 id='create_labels_alpha'>Create labels for <code>alpha</code></h2><span id='topic+create_labels_alpha'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_alpha(P_f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_alpha_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>alpha</code> of length <code>P_f</code>
if <code>P_f &gt; 0</code> and <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_alpha(P_f = 3)
</code></pre>

<hr>
<h2 id='create_labels_b'>Create labels for <code>b</code></h2><span id='topic+create_labels_b'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_b(P_r, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_b_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The labels are of the form <code>"c.p"</code>, where <code>c</code> is the latent class
number and <code>p</code> the index of the random coefficient.
</p>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>b</code> of length <code>P_r * C</code>
if <code>P_r &gt; 0</code> and <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_b(2, 3)
</code></pre>

<hr>
<h2 id='create_labels_d'>Create labels for <code>d</code></h2><span id='topic+create_labels_d'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_d(J, ordered)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_d_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="create_labels_d_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>J</code> must be greater or equal <code>3</code> in the ordered probit
model.
</p>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>d</code> of length <code>J - 2</code> if
<code>ordered = TRUE</code> and <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_d(5, TRUE)
</code></pre>

<hr>
<h2 id='create_labels_Omega'>Create labels for <code>Omega</code></h2><span id='topic+create_labels_Omega'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>Omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_Omega(P_r, C, cov_sym)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_Omega_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="create_labels_Omega_+3A_cov_sym">cov_sym</code></td>
<td>
<p>Set to <code>TRUE</code> for labels of symmetric covariance elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The labels are of the form <code>"c.p1,p2"</code>, where <code>c</code> is the latent class
number and <code>p1,p2</code> the indeces of two random coefficients.
</p>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>Omega</code> of length
<code>P_r^2 * C</code> if <code>P_r &gt; 0</code> and <code>cov_sym = TRUE</code>
or of length <code>P_r*(P_r+1)/2*C</code> if <code>cov_sym = FALSE</code> and <code>NULL</code>
otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_Omega(2, 3, cov_sym = TRUE)
RprobitB:::create_labels_Omega(2, 3, cov_sym = FALSE)
</code></pre>

<hr>
<h2 id='create_labels_s'>Create labels for <code>s</code></h2><span id='topic+create_labels_s'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>s</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_s(P_r, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_s_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>s</code> of length <code>C</code> if
<code>P_r &gt; 0</code> and <code>NULL</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_s(1, 3)
</code></pre>

<hr>
<h2 id='create_labels_Sigma'>Create labels for <code>Sigma</code></h2><span id='topic+create_labels_Sigma'></span>

<h3>Description</h3>

<p>This function creates labels for the model parameter <code>Sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_labels_Sigma(J, cov_sym, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_labels_Sigma_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="create_labels_Sigma_+3A_cov_sym">cov_sym</code></td>
<td>
<p>Set to <code>TRUE</code> for labels of symmetric covariance elements.</p>
</td></tr>
<tr><td><code id="create_labels_Sigma_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The labels are of the form <code>"j1,j2"</code>, where <code>j1,j2</code> are indices
of the two alternatives <code>j1</code> and <code>j2</code>.
</p>


<h3>Value</h3>

<p>A vector of labels for the model parameter <code>Sigma</code> of length
<code>(J-1)^2</code> if <code>cov_sym = TRUE</code> or of length <code>J*(J-1)/2</code>
if <code>cov_sym = FALSE</code>.
If <code>ordered = TRUE</code>, <code>Sigma</code> has only one element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::create_labels_Sigma(3, cov_sym = TRUE)
RprobitB:::create_labels_Sigma(4, cov_sym = FALSE)
RprobitB:::create_labels_Sigma(4, ordered = TRUE)
</code></pre>

<hr>
<h2 id='create_lagged_cov'>Create lagged choice covariates</h2><span id='topic+create_lagged_cov'></span>

<h3>Description</h3>

<p>This function creates lagged choice covariates from the <code>data.frame</code>
<code>choice_data</code>, which is assumed to be sorted by the choice occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lagged_cov(choice_data, column, k = 1, id = "id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_lagged_cov_+3A_choice_data">choice_data</code></td>
<td>
<p>A <code>data.frame</code> of choice data in wide format, i.e. each row represents
one choice occasion.</p>
</td></tr>
<tr><td><code id="create_lagged_cov_+3A_column">column</code></td>
<td>
<p>A character, the column name in <code>choice_data</code>, i.e. the covariate name.
Can be a vector.</p>
</td></tr>
<tr><td><code id="create_lagged_cov_+3A_k">k</code></td>
<td>
<p>A positive number, the number of lags (in units of observations), see the
details. Can be a vector. The default is <code>k = 1</code>.</p>
</td></tr>
<tr><td><code id="create_lagged_cov_+3A_id">id</code></td>
<td>
<p>A character, the name of the column in <code>choice_data</code> that contains
unique identifier for each decision maker. The default is <code>"id"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Say that <code>choice_data</code> contains the column <code>column</code>. Then, the
function call
</p>
<pre>
create_lagged_cov(choice_data, column, k, id)
</pre>
<p>returns the input <code>choice_data</code> which includes a new column named
<code>column.k</code>. This column contains for each decider (based on <code>id</code>)
and each choice occasion the covariate faced before <code>k</code> choice
occasions. If this data point is not available, it is set to
<code>NA</code>. In particular, the first <code>k</code> values of <code>column.k</code> will
be <code>NA</code> (initial condition problem).
</p>


<h3>Value</h3>

<p>The input <code>choice_data</code> with the additional columns named
<code>column.k</code> for each element <code>column</code> and each number <code>k</code>
containing the lagged covariates.
</p>

<hr>
<h2 id='d_to_gamma'>Transform threshold increments to thresholds</h2><span id='topic+d_to_gamma'></span>

<h3>Description</h3>

<p>This helper function transforms the threshold increments <code>d</code> to the
thresholds <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_to_gamma(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_to_gamma_+3A_d">d</code></td>
<td>
<p>A numeric vector of threshold increments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold vector <code>gamma</code> is computed from the threshold increments
<code>d</code> as <code>c(-100,0,cumsum(exp(d)),100)</code>, where the bounds
<code>-100</code> and <code>100</code> exist for numerical reasons and the first
threshold is fixed to <code>0</code> for identification.
</p>


<h3>Value</h3>

<p>A numeric vector of the thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d_to_gamma(c(0,0,0))
</code></pre>

<hr>
<h2 id='dmvnorm'>Density of multivariate normal distribution</h2><span id='topic+dmvnorm'></span>

<h3>Description</h3>

<p>This function computes the density of a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm(x, mean, Sigma, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmvnorm_+3A_x">x</code></td>
<td>
<p>A quantile vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_mean">mean</code></td>
<td>
<p>The mean vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of dimension <code>n</code> x <code>n</code>.</p>
</td></tr>
<tr><td><code id="dmvnorm_+3A_log">log</code></td>
<td>
<p>A boolean, if <code>TRUE</code> the logarithm of the density value is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(0,0)
mean = c(0,0)
Sigma = diag(2)
dmvnorm(x = x, mean = mean, Sigma = Sigma)
dmvnorm(x = x, mean = mean, Sigma = Sigma, log = TRUE)
</code></pre>

<hr>
<h2 id='draw_from_prior'>Sample from prior distributions</h2><span id='topic+draw_from_prior'></span>

<h3>Description</h3>

<p>This function returns a sample from each parameter's prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_from_prior(prior, C = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_from_prior_+3A_prior">prior</code></td>
<td>
<p>An object of class <code>RprobitB_prior</code>, which is the output of
<code><a href="#topic+check_prior">check_prior</a></code>.</p>
</td></tr>
<tr><td><code id="draw_from_prior_+3A_c">C</code></td>
<td>
<p>The number of latent classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of draws for <code>alpha</code>, <code>s</code>, <code>b</code>, <code>Omega</code>, and
<code>Sigma</code> (if specified for the model).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior &lt;- check_prior(P_f = 1, P_r = 2, J = 3)
RprobitB:::draw_from_prior(prior, C = 2)
</code></pre>

<hr>
<h2 id='euc_dist'>Euclidean distance</h2><span id='topic+euc_dist'></span>

<h3>Description</h3>

<p>This function computes the euclidean distance between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euc_dist(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euc_dist_+3A_a">a</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="euc_dist_+3A_b">b</code></td>
<td>
<p>Another numeric vector of the same length as <code>a</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The euclidean distance.
</p>

<hr>
<h2 id='filter_gibbs_samples'>Filter Gibbs samples</h2><span id='topic+filter_gibbs_samples'></span>

<h3>Description</h3>

<p>This is a helper function that filters Gibbs samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_gibbs_samples(
  x,
  P_f,
  P_r,
  J,
  C,
  cov_sym,
  ordered = FALSE,
  keep_par = c("s", "alpha", "b", "Omega", "Sigma", "d"),
  drop_par = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_gibbs_samples_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_gibbs_samples</code>.</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_cov_sym">cov_sym</code></td>
<td>
<p>Set to <code>TRUE</code> for labels of symmetric covariance elements.</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_keep_par">keep_par</code></td>
<td>
<p>A vector of parameter names which are kept.</p>
</td></tr>
<tr><td><code id="filter_gibbs_samples_+3A_drop_par">drop_par</code></td>
<td>
<p>A vector of parameter names which get dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_gibbs_samples</code> filtered by the labels of
<code><a href="#topic+parameter_labels">parameter_labels</a></code>.
</p>

<hr>
<h2 id='fit_model'>Fit probit model to choice data</h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>This function performs Markov chain Monte Carlo simulation for fitting
different types of probit models (binary, multivariate, mixed, latent class,
ordered, ranked) to discrete choice data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  data,
  scale = "Sigma_1,1 := 1",
  R = 1000,
  B = R/2,
  Q = 1,
  print_progress = getOption("RprobitB_progress"),
  prior = NULL,
  latent_classes = NULL,
  seed = NULL,
  fixed_parameter = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_model_+3A_data">data</code></td>
<td>
<p>An object of class <code>RprobitB_data</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_scale">scale</code></td>
<td>
<p>A character which determines the utility scale. It is of the form
<code style="white-space: pre;">&#8288;&lt;parameter&gt; := &lt;value&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;parameter&gt;&#8288;</code> is either the name of a fixed
effect or <code style="white-space: pre;">&#8288;Sigma_&lt;j&gt;,&lt;j&gt;&#8288;</code> for the <code style="white-space: pre;">&#8288;&lt;j&gt;&#8288;</code>th diagonal element of <code>Sigma</code>, and
<code style="white-space: pre;">&#8288;&lt;value&gt;&#8288;</code> is the value of the fixed parameter.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_r">R</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_q">Q</code></td>
<td>
<p>The thinning factor for the Gibbs samples, i.e. only every <code>Q</code>th
sample is kept.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_print_progress">print_progress</code></td>
<td>
<p>A boolean, determining whether to print the Gibbs sampler progress and the
estimated remaining computation time.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for the prior distributions. See the documentation
of <code><a href="#topic+check_prior">check_prior</a></code> for details about which parameters can be
specified.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_latent_classes">latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_model_+3A_seed">seed</code></td>
<td>
<p>Set a seed for the Gibbs sampling.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fixed_parameter">fixed_parameter</code></td>
<td>
<p>Optionally specify a named list with fixed parameter values for <code>alpha</code>,
<code>C</code>, <code>s</code>, <code>b</code>, <code>Omega</code>, <code>Sigma</code>, <code>Sigma_full</code>,
<code>beta</code>, <code>z</code>, or <code>d</code> for the simulation.
See <a href="https://loelschlaeger.de/RprobitB/articles/v01_model_definition.html">the vignette on model definition</a>
for definitions of these variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://loelschlaeger.de/RprobitB/articles/v03_model_fitting.html">the vignette on model fitting</a>
for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>RprobitB_fit</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+prepare_data">prepare_data()</a></code> and <code><a href="#topic+simulate_choices">simulate_choices()</a></code> for building an
<code>RprobitB_data</code> object
</p>
</li>
<li> <p><code><a href="stats.html#topic+update">update()</a></code> for estimating nested models
</p>
</li>
<li> <p><code><a href="base.html#topic+transform">transform()</a></code> for transforming a fitted model
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_choices(
  form = choice ~ var | 0, N = 100, T = 10, J = 3, seed = 1
)
model &lt;- fit_model(data = data, R = 1000, seed = 1)
summary(model)

</code></pre>

<hr>
<h2 id='get_cov'>Extract covariates of choice occasion</h2><span id='topic+get_cov'></span>

<h3>Description</h3>

<p>This convenience function returns the covariates and the choices of specific
choice occasions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cov(x, id, idc, idc_label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cov_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>RprobitB_data</code> or <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="get_cov_+3A_id">id</code></td>
<td>
<p>A numeric (vector), that specifies the decider(s).</p>
</td></tr>
<tr><td><code id="get_cov_+3A_idc">idc</code></td>
<td>
<p>A numeric (vector), that specifies the choice occasion(s).</p>
</td></tr>
<tr><td><code id="get_cov_+3A_idc_label">idc_label</code></td>
<td>
<p>The name of the column that contains the choice occasion identifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of the <code>choice_data</code> data frame specified in <code>prepare_data()</code>.
</p>

<hr>
<h2 id='gibbs_sampling'>Markov chain Monte Carlo simulation for the probit model</h2><span id='topic+gibbs_sampling'></span>

<h3>Description</h3>

<p>This function draws from the posterior distribution of the probit model via
Markov chain Monte Carlo simulation-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_sampling(
  sufficient_statistics,
  prior,
  latent_classes,
  fixed_parameter,
  init,
  R,
  B,
  print_progress,
  ordered,
  ranked
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gibbs_sampling_+3A_sufficient_statistics">sufficient_statistics</code></td>
<td>
<p>The output of <code><a href="#topic+sufficient_statistics">sufficient_statistics</a></code>.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for the prior distributions. See the documentation
of <code><a href="#topic+check_prior">check_prior</a></code> for details about which parameters can be
specified.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_latent_classes">latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_fixed_parameter">fixed_parameter</code></td>
<td>
<p>Optionally specify a named list with fixed parameter values for <code>alpha</code>,
<code>C</code>, <code>s</code>, <code>b</code>, <code>Omega</code>, <code>Sigma</code>, <code>Sigma_full</code>,
<code>beta</code>, <code>z</code>, or <code>d</code> for the simulation.
See <a href="https://loelschlaeger.de/RprobitB/articles/v01_model_definition.html">the vignette on model definition</a>
for definitions of these variables.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_init">init</code></td>
<td>
<p>The output of <code><a href="#topic+set_initial_gibbs_values">set_initial_gibbs_values</a></code>.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_r">R</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_print_progress">print_progress</code></td>
<td>
<p>A boolean, determining whether to print the Gibbs sampler progress and the
estimated remaining computation time.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="gibbs_sampling_+3A_ranked">ranked</code></td>
<td>
<p>TBA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not supposed to be called directly, but rather via
<code><a href="#topic+fit_model">fit_model</a></code>.
</p>


<h3>Value</h3>

<p>A list of Gibbs samples for
</p>

<ul>
<li> <p><code>Sigma</code>,
</p>
</li>
<li> <p><code>alpha</code> (if <code>P_f&gt;0</code>),
</p>
</li>
<li> <p><code>s</code>, <code>z</code>, <code>b</code>, <code>Omega</code> (if <code>P_r&gt;0</code>),
</p>
</li>
<li> <p><code>d</code> (if <code>ordered = TRUE</code>),
</p>
</li></ul>

<p>and a vector <code>class_sequence</code> of length <code>R</code>, where the <code>r</code>th
entry is the number of latent classes after iteration <code>r</code>.
</p>

<hr>
<h2 id='ll_ordered'>Log-likelihood in the ordered probit model</h2><span id='topic+ll_ordered'></span>

<h3>Description</h3>

<p>This function computes the log-likelihood value given the threshold
increments <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll_ordered(d, y, mu, Tvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ll_ordered_+3A_d">d</code></td>
<td>
<p>A numeric vector of threshold increments.</p>
</td></tr>
<tr><td><code id="ll_ordered_+3A_y">y</code></td>
<td>
<p>A matrix of the choices.</p>
</td></tr>
<tr><td><code id="ll_ordered_+3A_mu">mu</code></td>
<td>
<p>A matrix of the systematic utilities.</p>
</td></tr>
<tr><td><code id="ll_ordered_+3A_tvec">Tvec</code></td>
<td>
<p>The element <code>Tvec</code> in <code><a href="#topic+sufficient_statistics">sufficient_statistics</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll_ordered(c(0,0,0), matrix(1), matrix(1), 1)
</code></pre>

<hr>
<h2 id='missing_covariates'>Handle missing covariates</h2><span id='topic+missing_covariates'></span>

<h3>Description</h3>

<p>This function checks for and replaces missing covariate entries in
<code>choice_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_covariates(
  choice_data,
  impute = "complete_cases",
  col_ignore = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_covariates_+3A_choice_data">choice_data</code></td>
<td>
<p>A <code>data.frame</code> of choice data in wide format, i.e. each row represents
one choice occasion.</p>
</td></tr>
<tr><td><code id="missing_covariates_+3A_impute">impute</code></td>
<td>
<p>A character that specifies how to handle missing covariate entries in
<code>choice_data</code>, one of:
</p>

<ul>
<li> <p><code>"complete_cases"</code>, removes all rows containing missing
covariate entries (the default),
</p>
</li>
<li> <p><code>"zero"</code>, replaces missing covariate entries by zero
(only for numeric columns),
</p>
</li>
<li> <p><code>"mean"</code>, imputes missing covariate entries by the mean
(only for numeric columns).
</p>
</li></ul>
</td></tr>
<tr><td><code id="missing_covariates_+3A_col_ignore">col_ignore</code></td>
<td>
<p>A character vector of columns that are ignored (none per default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>choice_data</code>, in which missing covariates are addressed.
</p>

<hr>
<h2 id='mml'>Approximate marginal model likelihood</h2><span id='topic+mml'></span>

<h3>Description</h3>

<p>This function approximates the model's marginal likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mml(x, S = 0, ncores = parallel::detectCores() - 1, recompute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mml_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="mml_+3A_s">S</code></td>
<td>
<p>The number of prior samples for the prior arithmetic mean estimate. Per
default, <code>S = 0</code>. In this case, only the posterior samples are used
for the approximation via the posterior harmonic mean estimator, see the
details section.</p>
</td></tr>
<tr><td><code id="mml_+3A_ncores">ncores</code></td>
<td>
<p>Computation of the prior arithmetic mean estimate is parallelized, set the
number of cores.</p>
</td></tr>
<tr><td><code id="mml_+3A_recompute">recompute</code></td>
<td>
<p>Set to <code>TRUE</code> to recompute the likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model's marginal likelihood <code class="reqn">p(y\mid M)</code> for a model <code class="reqn">M</code> and data
<code class="reqn">y</code> is required for the computation of Bayes factors. In general, the
term has no closed form and must be approximated numerically.
</p>
<p>This function uses the posterior Gibbs samples to approximate the model's
marginal likelihood via the posterior harmonic mean estimator.
To check the convergence, call <code>plot(x$mml)</code>, where <code>x</code> is the output
of this function. If the estimation does not seem to have
converged, you can improve the approximation by combining the value
with the prior arithmetic mean estimator. The final approximation of the
model's marginal likelihood than is a weighted sum of the posterior harmonic
mean estimate and the prior arithmetic mean estimate,
where the weights are determined by the sample sizes.
</p>


<h3>Value</h3>

<p>The object <code>x</code>, including the object <code>mml</code>, which is the model's
approximated marginal likelihood value.
</p>

<hr>
<h2 id='model_selection'>Compare fitted models</h2><span id='topic+model_selection'></span>

<h3>Description</h3>

<p>This function returns a table with several criteria for model comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_selection(
  ...,
  criteria = c("npar", "LL", "AIC", "BIC"),
  add_form = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_selection_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_criteria">criteria</code></td>
<td>
<p>A vector of one or more of the following characters:
</p>

<ul>
<li> <p><code>"npar"</code> for the number of model parameters (see <code><a href="#topic+npar">npar</a></code>),
</p>
</li>
<li> <p><code>"LL"</code> for the log-likelihood value (see <code><a href="stats.html#topic+logLik">logLik</a></code>),
</p>
</li>
<li> <p><code>"AIC"</code> for the AIC value (see <code><a href="stats.html#topic+AIC">AIC</a></code>),
</p>
</li>
<li> <p><code>"BIC"</code> for the BIC value (see <code><a href="stats.html#topic+BIC">BIC</a></code>),
</p>
</li>
<li> <p><code>"WAIC"</code> for the WAIC value (also shows its standard error
<code>sd(WAIC)</code> and the number <code>pWAIC</code> of effective model parameters,
see <code><a href="#topic+WAIC">WAIC</a></code>),
</p>
</li>
<li> <p><code>"MMLL"</code> for the marginal model log-likelihood,
</p>
</li>
<li> <p><code>"BF"</code> for the Bayes factor,
</p>
</li>
<li> <p><code>"pred_acc"</code> for the prediction accuracy (see <code><a href="#topic+pred_acc">pred_acc</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="model_selection_+3A_add_form">add_form</code></td>
<td>
<p>Set to <code>TRUE</code> to add the model formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette on model selection for more details.
</p>


<h3>Value</h3>

<p>A data frame, criteria in columns, models in rows.
</p>

<hr>
<h2 id='npar'>Extract number of model parameters</h2><span id='topic+npar'></span><span id='topic+npar.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function extracts the number of model parameters of an
<code>RprobitB_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npar(object, ...)

## S3 method for class 'RprobitB_fit'
npar(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npar_+3A_object">object</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="npar_+3A_...">...</code></td>
<td>
<p>Optionally more objects of class <code>RprobitB_fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric value (if just one object is provided) or a numeric vector.
</p>

<hr>
<h2 id='overview_effects'>Print effect overview</h2><span id='topic+overview_effects'></span>

<h3>Description</h3>

<p>This function gives an overview of the effect names, whether the covariate
is alternative-specific, whether the coefficient is alternative-specific,
and whether it is a random effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overview_effects(
  form,
  re = NULL,
  alternatives,
  base = tail(alternatives, 1),
  ordered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overview_effects_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="overview_effects_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="overview_effects_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="overview_effects_+3A_base">base</code></td>
<td>
<p>A character, the name of the base alternative for covariates that are not
alternative specific (i.e. type 2 covariates and ASCs). Ignored and set to
<code>NULL</code> if the model has no alternative specific covariates (e.g. in the
ordered probit model).
Per default, <code>base</code> is the last element of <code>alternatives</code>.</p>
</td></tr>
<tr><td><code id="overview_effects_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, each row is a effect, columns are the effect name
<code>"effect"</code>, and booleans whether the covariate is alternative-specific
<code>"as_value"</code>, whether the coefficient is alternative-specific
<code>"as_coef"</code>, and whether it is a random effect <code>"random"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_form">check_form()</a></code> for checking the model formula specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>overview_effects(
  form = choice ~ price + time + comfort + change | 1,
  re = c("price", "time"),
  alternatives = c("A", "B"),
  base = "A"
)

</code></pre>

<hr>
<h2 id='parameter_labels'>Create parameters labels</h2><span id='topic+parameter_labels'></span>

<h3>Description</h3>

<p>This function creates model parameter labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_labels(
  P_f,
  P_r,
  J,
  C,
  cov_sym,
  ordered = FALSE,
  keep_par = c("s", "alpha", "b", "Omega", "Sigma", "d"),
  drop_par = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameter_labels_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_cov_sym">cov_sym</code></td>
<td>
<p>Set to <code>TRUE</code> for labels of symmetric covariance elements.</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_keep_par">keep_par</code></td>
<td>
<p>A vector of parameter names which are kept.</p>
</td></tr>
<tr><td><code id="parameter_labels_+3A_drop_par">drop_par</code></td>
<td>
<p>A vector of parameter names which get dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of labels for the selected model parameters.
</p>

<hr>
<h2 id='plot_acf'>Autocorrelation plot of Gibbs samples</h2><span id='topic+plot_acf'></span>

<h3>Description</h3>

<p>This function plots the autocorrelation of the Gibbs samples. The plots
include the total Gibbs sample size <code>TSS</code> and the effective sample size
<code>ESS</code>, see the details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_acf(gibbs_samples, par_labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_acf_+3A_gibbs_samples">gibbs_samples</code></td>
<td>
<p>A matrix of Gibbs samples.</p>
</td></tr>
<tr><td><code id="plot_acf_+3A_par_labels">par_labels</code></td>
<td>
<p>A character vector with labels for the Gibbs samples, of length equal to the
number of columns of <code>gibbs_samples</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effective sample size is the value
</p>
<p style="text-align: center;"><code class="reqn">TSS / \sqrt{1 + 2\sum_{k\geq 1} \rho_k}</code>
</p>
<p>,
where <code class="reqn">\rho_k</code> is the auto correlation between the chain offset by
<code class="reqn">k</code> positions. The auto correlations are estimated via
<code><a href="stats.html#topic+spec.ar">spec.ar</a></code>.
</p>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='plot_class_allocation'>Plot class allocation (for <code>P_r = 2</code> only)</h2><span id='topic+plot_class_allocation'></span>

<h3>Description</h3>

<p>This function plots the allocation of decision-maker specific coefficient vectors
<code>beta</code> given the allocation vector <code>z</code>, the class means <code>b</code>,
and the class covariance matrices <code>Omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_class_allocation(beta, z, b, Omega, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_class_allocation_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="plot_class_allocation_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="plot_class_allocation_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="plot_class_allocation_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="plot_class_allocation_+3A_...">...</code></td>
<td>
<p>Optional visualization parameters:
</p>

<ul>
<li> <p><code>colors</code>, a character vector of color specifications,
</p>
</li>
<li> <p><code>perc</code>, a numeric between 0 and 1 to draw the <code>perc</code> percentile
ellipsoids for the underlying Gaussian distributions (<code>perc = 0.95</code> per default),
</p>
</li>
<li> <p><code>r</code>, the current iteration number of the Gibbs sampler to be displayed in the legend,
</p>
</li>
<li> <p><code>sleep</code>, the number of seconds to pause after plotting.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Only applicable in the two-dimensional case, i.e. only if <code>P_r = 2</code>.
</p>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='plot_class_seq'>Visualizing the number of classes during Gibbs sampling</h2><span id='topic+plot_class_seq'></span>

<h3>Description</h3>

<p>This function plots the number of latent Glasses during Gibbs sampling
to visualize the class updating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_class_seq(class_sequence, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_class_seq_+3A_class_sequence">class_sequence</code></td>
<td>
<p>The sequence of class numbers during Gibbs sampling of length <code>R</code>.</p>
</td></tr>
<tr><td><code id="plot_class_seq_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='plot_mixture_contour'>Plot bivariate contour of mixing distributions</h2><span id='topic+plot_mixture_contour'></span>

<h3>Description</h3>

<p>This function plots an estimated bivariate contour mixing distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mixture_contour(means, covs, weights, names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mixture_contour_+3A_means">means</code></td>
<td>
<p>The class means.</p>
</td></tr>
<tr><td><code id="plot_mixture_contour_+3A_covs">covs</code></td>
<td>
<p>The class covariances.</p>
</td></tr>
<tr><td><code id="plot_mixture_contour_+3A_weights">weights</code></td>
<td>
<p>The class weights.</p>
</td></tr>
<tr><td><code id="plot_mixture_contour_+3A_names">names</code></td>
<td>
<p>The covariate names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ggplot</code>.
</p>

<hr>
<h2 id='plot_mixture_marginal'>Plot marginal mixing distributions</h2><span id='topic+plot_mixture_marginal'></span>

<h3>Description</h3>

<p>This function plots an estimated marginal mixing distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mixture_marginal(mean, cov, weights, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mixture_marginal_+3A_mean">mean</code></td>
<td>
<p>The class means.</p>
</td></tr>
<tr><td><code id="plot_mixture_marginal_+3A_cov">cov</code></td>
<td>
<p>The class covariances.</p>
</td></tr>
<tr><td><code id="plot_mixture_marginal_+3A_weights">weights</code></td>
<td>
<p>The class weights.</p>
</td></tr>
<tr><td><code id="plot_mixture_marginal_+3A_name">name</code></td>
<td>
<p>The covariate name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ggplot</code>.
</p>

<hr>
<h2 id='plot_roc'>Plot ROC curve</h2><span id='topic+plot_roc'></span>

<h3>Description</h3>

<p>This function draws receiver operating characteristic (ROC) curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_roc(..., reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_roc_+3A_...">...</code></td>
<td>
<p>One or more <code>RprobitB_fit</code> objects or <code>data.frame</code>s of choice
probability.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_reference">reference</code></td>
<td>
<p>The reference alternative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='plot_trace'>Visualizing the trace of Gibbs samples.</h2><span id='topic+plot_trace'></span>

<h3>Description</h3>

<p>This function plots traces of the Gibbs samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trace(gibbs_samples, par_labels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_trace_+3A_gibbs_samples">gibbs_samples</code></td>
<td>
<p>A matrix of Gibbs samples.</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_par_labels">par_labels</code></td>
<td>
<p>A character vector of length equal to the number of columns of
<code>gibbs_samples</code>, containing labels for the Gibbs samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='plot.RprobitB_data'>Visualize choice data</h2><span id='topic+plot.RprobitB_data'></span>

<h3>Description</h3>

<p>This function is the plot method for an object of class <code>RprobitB_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_data'
plot(x, by_choice = FALSE, alpha = 1, position = "dodge", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.RprobitB_data_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_data</code>.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_data_+3A_by_choice">by_choice</code></td>
<td>
<p>Set to <code>TRUE</code> to group the covariates by the chosen alternatives.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_data_+3A_alpha">alpha</code>, <code id="plot.RprobitB_data_+3A_position">position</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_data_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_choices(
  form = choice ~ cost | 0,
  N = 100,
  T = 10,
  J = 2,
  alternatives = c("bus", "car"),
  true_parameter = list("alpha" = -1)
)
plot(data, by_choice = TRUE)
</code></pre>

<hr>
<h2 id='plot.RprobitB_fit'>Visualize fitted probit model</h2><span id='topic+plot.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function is the plot method for an object of class <code>RprobitB_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_fit'
plot(x, type, ignore = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.RprobitB_fit_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+RprobitB_fit">RprobitB_fit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_fit_+3A_type">type</code></td>
<td>
<p>The type of plot, which can be one of:
</p>

<ul>
<li> <p><code>"mixture"</code> to visualize the mixing distribution,
</p>
</li>
<li> <p><code>"acf"</code> for autocorrelation plots of the Gibbs samples,
</p>
</li>
<li> <p><code>"trace"</code> for trace plots of the Gibbs samples,
</p>
</li>
<li> <p><code>"class_seq"</code> to visualize the sequence of class numbers.
</p>
</li></ul>

<p>See the details section for visualization options.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_fit_+3A_ignore">ignore</code></td>
<td>
<p>A character (vector) of covariate or parameter names that do not get
visualized.</p>
</td></tr>
<tr><td><code id="plot.RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Draws a plot to the current device.
</p>

<hr>
<h2 id='point_estimates'>Compute point estimates</h2><span id='topic+point_estimates'></span>

<h3>Description</h3>

<p>This function computes the point estimates of an <code><a href="#topic+RprobitB_fit">RprobitB_fit</a></code>.
Per default, the <code>mean</code> of the Gibbs samples is used as a point estimate.
However, any statistic that computes a single numeric value out of a vector of
Gibbs samples can be specified for <code>FUN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_estimates(x, FUN = mean)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point_estimates_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+RprobitB_fit">RprobitB_fit</a></code>.</p>
</td></tr>
<tr><td><code id="point_estimates_+3A_fun">FUN</code></td>
<td>
<p>A function that computes a single numeric value out of a vector of numeric
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+RprobitB_parameter">RprobitB_parameter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_choices(form = choice ~ covariate, N = 10, T = 10, J = 2)
model &lt;- fit_model(data)
point_estimates(model)
point_estimates(model, FUN = median)

</code></pre>

<hr>
<h2 id='posterior_pars'>Parameter sets from posterior samples</h2><span id='topic+posterior_pars'></span>

<h3>Description</h3>

<p>This function builds parameter sets from the normalized, burned and
thinned posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_pars(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_pars_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>RprobitB_parameter</code> objects.
</p>

<hr>
<h2 id='pred_acc'>Compute prediction accuracy</h2><span id='topic+pred_acc'></span>

<h3>Description</h3>

<p>This function computes the prediction accuracy of an <code>RprobitB_fit</code>
object. Prediction accuracy means the share of choices that are correctly
predicted by the model, where prediction is based on the maximum choice
probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_acc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred_acc_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="pred_acc_+3A_...">...</code></td>
<td>
<p>Optionally specify more <code>RprobitB_fit</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='predict.RprobitB_fit'>Predict choices</h2><span id='topic+predict.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function predicts the discrete choice behavior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_fit'
predict(object, data = NULL, overview = TRUE, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.RprobitB_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="predict.RprobitB_fit_+3A_data">data</code></td>
<td>
<p>Either
</p>

<ul>
<li> <p><code>NULL</code>, using the data in <code>object</code>,
</p>
</li>
<li><p> an object of class <code>RprobitB_data</code>, for example the test part
generated by <code><a href="#topic+train_test">train_test</a></code>,
</p>
</li>
<li><p> or a data frame of custom choice characteristics. It must have the
same structure as <code>choice_data</code> used in <code><a href="#topic+prepare_data">prepare_data</a></code>.
Missing columns or <code>NA</code> values are set to 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.RprobitB_fit_+3A_overview">overview</code></td>
<td>
<p>If <code>TRUE</code>, returns a confusion matrix.</p>
</td></tr>
<tr><td><code id="predict.RprobitB_fit_+3A_digits">digits</code></td>
<td>
<p>The number of digits of the returned choice probabilities. <code>digits = 2</code> per
default.</p>
</td></tr>
<tr><td><code id="predict.RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions are made based on the maximum predicted probability for each
choice alternative. See the vignette on choice prediction for a demonstration
on how to visualize the model's sensitivity and specificity by means of a
receiver operating characteristic (ROC) curve.
</p>


<h3>Value</h3>

<p>Either a table if <code>overview = TRUE</code> or a data frame otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_choices(
  form = choice ~ cov, N = 10, T = 10, J = 2, seed = 1
)
data &lt;- train_test(data, test_proportion = 0.5)
model &lt;- fit_model(data$train)

predict(model)
predict(model, overview = FALSE)
predict(model, data = data$test)
predict(
  model,
  data = data.frame("cov_A" = c(1, 1, NA, NA), "cov_B" = c(1, NA, 1, NA)),
  overview = FALSE
)

</code></pre>

<hr>
<h2 id='preference_flip'>Check for flip in preferences after change in model scale.</h2><span id='topic+preference_flip'></span>

<h3>Description</h3>

<p>This function checks if a change in the model scale flipped the preferences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference_flip(model_old, model_new)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preference_flip_+3A_model_old">model_old</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>, the model before the scale change.</p>
</td></tr>
<tr><td><code id="preference_flip_+3A_model_new">model_new</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>, the model after the scale change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side-effects.
</p>

<hr>
<h2 id='prepare_data'>Prepare choice data for estimation</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>This function prepares choice data for estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  form,
  choice_data,
  re = NULL,
  alternatives = NULL,
  ordered = FALSE,
  ranked = FALSE,
  base = NULL,
  id = "id",
  idc = NULL,
  standardize = NULL,
  impute = "complete_cases"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_data_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_choice_data">choice_data</code></td>
<td>
<p>A <code>data.frame</code> of choice data in wide format, i.e. each row represents
one choice occasion.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_ranked">ranked</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_base">base</code></td>
<td>
<p>A character, the name of the base alternative for covariates that are not
alternative specific (i.e. type 2 covariates and ASCs). Ignored and set to
<code>NULL</code> if the model has no alternative specific covariates (e.g. in the
ordered probit model).
Per default, <code>base</code> is the last element of <code>alternatives</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_id">id</code></td>
<td>
<p>A character, the name of the column in <code>choice_data</code> that contains
unique identifier for each decision maker. The default is <code>"id"</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_idc">idc</code></td>
<td>
<p>A character, the name of the column in <code>choice_data</code> that contains
unique identifier for each choice situation of each decision maker.
Per default, these identifier are generated by the order of appearance.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_standardize">standardize</code></td>
<td>
<p>A character vector of names of covariates that get standardized.
Covariates of type 1 or 3 have to be addressed by
<code>&lt;covariate&gt;_&lt;alternative&gt;</code>.
If <code>standardize = "all"</code>, all covariates get standardized.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_impute">impute</code></td>
<td>
<p>A character that specifies how to handle missing covariate entries in
<code>choice_data</code>, one of:
</p>

<ul>
<li> <p><code>"complete_cases"</code>, removes all rows containing missing
covariate entries (the default),
</p>
</li>
<li> <p><code>"zero"</code>, replaces missing covariate entries by zero
(only for numeric columns),
</p>
</li>
<li> <p><code>"mean"</code>, imputes missing covariate entries by the mean
(only for numeric columns).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Requirements for the <code>data.frame</code> <code>choice_data</code>:
</p>

<ul>
<li><p> It <strong>must</strong> contain a column named <code>id</code> which contains unique
identifier for each decision maker.
</p>
</li>
<li><p> It <strong>can</strong> contain a column named <code>idc</code> which contains unique
identifier for each choice situation of each decision maker.
If this information is missing, these identifier are generated
automatically by the appearance of the choices in the data set.
</p>
</li>
<li><p> It <strong>can</strong> contain a column named <code>choice</code> with the observed
choices, where <code>choice</code> must match the name of the dependent
variable in <code>form</code>.
Such a column is required for model fitting but not for prediction.
</p>
</li>
<li><p> It <strong>must</strong> contain a numeric column named <em>p_j</em> for each alternative
specific covariate <em>p</em> in <code>form</code> and each choice alternative <em>j</em>
in <code>alternatives</code>.
</p>
</li>
<li><p> It <strong>must</strong> contain a numeric column named <em>q</em> for each covariate <em>q</em>
in <code>form</code> that is constant across alternatives.
</p>
</li></ul>

<p>In the ordered case (<code>ordered = TRUE</code>), the column <code>choice</code> must
contain the full ranking of the alternatives in each choice occasion as a
character, where the alternatives are separated by commas, see the examples.
</p>
<p>See <a href="https://loelschlaeger.de/RprobitB/articles/v02_choice_data.html">the vignette on choice data</a>
for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>RprobitB_data</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+check_form">check_form()</a></code> for checking the model formula
</p>
</li>
<li> <p><code><a href="#topic+overview_effects">overview_effects()</a></code> for an overview of the model effects
</p>
</li>
<li> <p><code><a href="#topic+create_lagged_cov">create_lagged_cov()</a></code> for creating lagged covariates
</p>
</li>
<li> <p><code><a href="#topic+as_cov_names">as_cov_names()</a></code> for re-labeling alternative-specific covariates
</p>
</li>
<li> <p><code><a href="#topic+simulate_choices">simulate_choices()</a></code> for simulating choice data
</p>
</li>
<li> <p><code><a href="#topic+train_test">train_test()</a></code> for splitting choice data into a train and test subset
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- prepare_data(
  form = choice ~ price + time + comfort + change | 0,
  choice_data = train_choice,
  re = c("price", "time"),
  id = "deciderID",
  idc = "occasionID",
  standardize = c("price", "time")
)

### ranked case
choice_data &lt;- data.frame(
  "id" = 1:3, "choice" = c("A,B,C", "A,C,B", "B,C,A"), "cov" = 1
)
data &lt;- prepare_data(
  form = choice ~ 0 | cov + 0,
  choice_data = choice_data,
  ranked = TRUE
)

</code></pre>

<hr>
<h2 id='R_hat'>Compute Gelman-Rubin statistic</h2><span id='topic+R_hat'></span>

<h3>Description</h3>

<p>This function computes the Gelman-Rubin statistic <code>R_hat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_hat(samples, parts = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R_hat_+3A_samples">samples</code></td>
<td>
<p>A vector or a matrix of samples from a Markov chain, e.g. Gibbs samples.
If <code>samples</code> is a matrix, each column gives the samples for a separate
run.</p>
</td></tr>
<tr><td><code id="R_hat_+3A_parts">parts</code></td>
<td>
<p>The number of parts to divide each chain into sub-chains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value, the Gelman-Rubin statistic.
</p>


<h3>References</h3>

<p><a href="https://bookdown.org/rdpeng/advstatcomp/monitoring-convergence.html">https://bookdown.org/rdpeng/advstatcomp/monitoring-convergence.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>no_chains &lt;- 2
length_chains &lt;- 1e3
samples &lt;- matrix(NA_real_, length_chains, no_chains)
samples[1, ] &lt;- 1
Gamma &lt;- matrix(c(0.8, 0.1, 0.2, 0.9), 2, 2)
for (c in 1:no_chains) {
  for (t in 2:length_chains) {
    samples[t, c] &lt;- sample(1:2, 1, prob = Gamma[samples[t - 1, c], ])
  }
}
R_hat(samples)

</code></pre>

<hr>
<h2 id='rdirichlet'>Draw from Dirichlet distribution</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Function to draw from a Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdirichlet_+3A_delta">delta</code></td>
<td>
<p>A vector, the concentration parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, the sample from the Dirichlet distribution of the same length as <code>delta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet(delta = 1:3)
</code></pre>

<hr>
<h2 id='rmvnorm'>Draw from multivariate normal distribution</h2><span id='topic+rmvnorm'></span>

<h3>Description</h3>

<p>This function draws from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm(mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmvnorm_+3A_mu">mu</code></td>
<td>
<p>The mean vector of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="rmvnorm_+3A_sigma">Sigma</code></td>
<td>
<p>The covariance matrix of dimension <code>n</code> x <code>n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function builds upon the following fact: If <code class="reqn">\epsilon = (\epsilon_1,\dots,\epsilon_n)</code>,
where each <code class="reqn">\epsilon_i</code> is drawn independently from a standard normal distribution,
then <code class="reqn">\mu+L\epsilon</code> is a draw from the multivariate normal distribution
<code class="reqn">N(\mu,\Sigma)</code>, where <code class="reqn">L</code> is the lower triangular factor of the
Choleski decomposition of <code class="reqn">\Sigma</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(0,0)
Sigma &lt;- diag(2)
rmvnorm(mu = mu, Sigma = Sigma)
</code></pre>

<hr>
<h2 id='RprobitB_data'>Create object of class <code>RprobitB_data</code></h2><span id='topic+RprobitB_data'></span>

<h3>Description</h3>

<p>This function constructs an object of class <code>RprobitB_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_data(
  data,
  choice_data,
  N,
  T,
  J,
  P_f,
  P_r,
  alternatives,
  ordered,
  ranked,
  base,
  form,
  re,
  ASC,
  effects,
  standardize,
  simulated,
  choice_available,
  true_parameter,
  res_var_names
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_data_+3A_data">data</code></td>
<td>
<p>A list with the choice data.
The list has <code>N</code> elements.
Each element is a list with two elements, <code>X</code> and <code>y</code>, which are
the covariates and decisions for a decision maker. More precisely,
<code>X</code> is a list of <code>T</code> elements, where each element is a matrix of
dimension <code>J</code>x(<code>P_f</code>+<code>P_r</code>) and contains the characteristics
for one choice occasion.
<code>y</code> is a vector of length <code>T</code> and contains the labels for the
chosen alternatives.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_choice_data">choice_data</code></td>
<td>
<p>A <code>data.frame</code> of choice data in wide format, i.e. each row represents
one choice occasion.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_n">N</code></td>
<td>
<p>The number (greater or equal 1) of decision makers.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_t">T</code></td>
<td>
<p>The number (greater or equal 1) of choice occasions or a vector of choice
occasions of length <code>N</code> (i.e. a decision maker specific number).
Per default, <code>T = 1</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_ranked">ranked</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_base">base</code></td>
<td>
<p>A character, the name of the base alternative for covariates that are not
alternative specific (i.e. type 2 covariates and ASCs). Ignored and set to
<code>NULL</code> if the model has no alternative specific covariates (e.g. in the
ordered probit model).
Per default, <code>base</code> is the last element of <code>alternatives</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_asc">ASC</code></td>
<td>
<p>A boolean, determining whether the model has ASCs.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_effects">effects</code></td>
<td>
<p>A data frame with the effect names and booleans indicating whether
they are connected to random effects.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_standardize">standardize</code></td>
<td>
<p>A character vector of names of covariates that get standardized.
Covariates of type 1 or 3 have to be addressed by
<code>&lt;covariate&gt;_&lt;alternative&gt;</code>.
If <code>standardize = "all"</code>, all covariates get standardized.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_simulated">simulated</code></td>
<td>
<p>A boolean, if <code>TRUE</code> then <code>data</code> is simulated, otherwise
<code>data</code> is empirical.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_choice_available">choice_available</code></td>
<td>
<p>A boolean, if <code>TRUE</code> then <code>data</code> contains observed choices.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_true_parameter">true_parameter</code></td>
<td>
<p>An object of class <code>RprobitB_parameters</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_data_+3A_res_var_names">res_var_names</code></td>
<td>
<p>A names list of reserved variable names in <code>choice_data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_data</code> with the arguments of this function
as elements.
</p>

<hr>
<h2 id='RprobitB_fit'>Create object of class <code>RprobitB_fit</code></h2><span id='topic+RprobitB_fit'></span><span id='topic+summary.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>RprobitB_fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_fit(
  data,
  scale,
  level,
  normalization,
  R,
  B,
  Q,
  latent_classes,
  prior,
  gibbs_samples,
  class_sequence,
  comp_time
)

## S3 method for class 'RprobitB_fit'
summary(object, FUN = c(mean = mean, sd = stats::sd, `R^` = R_hat), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_fit_+3A_data">data</code></td>
<td>
<p>An object of class <code>RprobitB_data</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_scale">scale</code></td>
<td>
<p>A character which determines the utility scale. It is of the form
<code style="white-space: pre;">&#8288;&lt;parameter&gt; := &lt;value&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;parameter&gt;&#8288;</code> is either the name of a fixed
effect or <code style="white-space: pre;">&#8288;Sigma_&lt;j&gt;,&lt;j&gt;&#8288;</code> for the <code style="white-space: pre;">&#8288;&lt;j&gt;&#8288;</code>th diagonal element of <code>Sigma</code>, and
<code style="white-space: pre;">&#8288;&lt;value&gt;&#8288;</code> is the value of the fixed parameter.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_normalization">normalization</code></td>
<td>
<p>An object of class <code>RprobitB_normalization</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_r">R</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_q">Q</code></td>
<td>
<p>The thinning factor for the Gibbs samples, i.e. only every <code>Q</code>th
sample is kept.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_latent_classes">latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for the prior distributions. See the documentation
of <code><a href="#topic+check_prior">check_prior</a></code> for details about which parameters can be
specified.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_gibbs_samples">gibbs_samples</code></td>
<td>
<p>An object of class <code>RprobitB_gibbs_samples</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_class_sequence">class_sequence</code></td>
<td>
<p>The sequence of class numbers during Gibbs sampling of length <code>R</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_comp_time">comp_time</code></td>
<td>
<p>The time spent for Gibbs sampling.</p>
</td></tr>
<tr><td><code id="RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_fit</code>.
</p>

<hr>
<h2 id='RprobitB_gibbs_samples_statistics'>Create object of class <code>RprobitB_gibbs_samples_statistics</code></h2><span id='topic+RprobitB_gibbs_samples_statistics'></span>

<h3>Description</h3>

<p>This function creates an object of class
<code>RprobitB_gibbs_samples_statistics</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_gibbs_samples_statistics(gibbs_samples, FUN = list(mean = mean))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_gibbs_samples_statistics_+3A_gibbs_samples">gibbs_samples</code></td>
<td>
<p>An object of class <code>RprobitB_gibbs_samples</code>, which generally is located
as object <code>gibbs_samples</code> in an <code>RprobitB_model</code> object.</p>
</td></tr>
<tr><td><code id="RprobitB_gibbs_samples_statistics_+3A_fun">FUN</code></td>
<td>
<p>A (preferably named) list of functions that compute parameter statistics
from the Gibbs samples, for example
</p>

<ul>
<li> <p><code>mean</code> for the mean,
</p>
</li>
<li> <p><code>sd</code> for the standard deviation,
</p>
</li>
<li> <p><code>min</code> for the minimum,
</p>
</li>
<li> <p><code>max</code> for the maximum,
</p>
</li>
<li> <p><code>median</code> for the median,
</p>
</li>
<li> <p><code>function(x) quantile(x, p)</code> for the <code>p</code>th quantile,
</p>
</li>
<li> <p><code>R_hat</code> for the Gelman-Rubin statistic.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_gibbs_samples_statistics</code>, which is a list
of statistics from <code>gibbs_samples</code> obtained by applying the elements of
<code>FUN</code>.
</p>

<hr>
<h2 id='RprobitB_latent_classes'>Create object of class <code>RprobitB_latent_classes</code></h2><span id='topic+RprobitB_latent_classes'></span><span id='topic+print.RprobitB_latent_classes'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>RprobitB_latent_classes</code> which
defines the number of latent classes and their updating scheme.
The <code>RprobitB_latent_classes</code> object generated
by this function is only of relevance if the model possesses at least one
random coefficient, i.e. if <code>P_r&gt;0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_latent_classes(latent_classes = NULL)

## S3 method for class 'RprobitB_latent_classes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_latent_classes_+3A_latent_classes">latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>



<h4>Why update latent classes?</h4>

<p>In order not to have to specify the number of latent classes before
estimation.
</p>



<h4>What options to update latent classes exist?</h4>

<p>Currently two updating schemes are implemented, weight-based and
via a Dirichlet process, see
<a href="https://loelschlaeger.de/RprobitB/articles/v04_modeling_heterogeneity.html">the vignette on modeling heterogeneity</a>.
</p>



<h4>What is the default behavior?</h4>

<p>One latent class without updates is specified per default. Print an
<code>RprobitB_latent_classes</code>-object to see a summary of all relevant
(default) parameter settings.
</p>



<h4>Why is <code>Cmax</code> required?</h4>

<p>The implementation requires an upper bound on the number of latent classes
for saving the Gibbs samples. However, this is not a restriction since the
number of latent classes is bounded by the number of deciders in any case.
A plot method for visualizing the sequence of class numbers after estimation
and can be used to check if <code>Cmax</code> was reached, see
<code><a href="#topic+plot.RprobitB_fit">plot.RprobitB_fit</a></code>.
</p>



<h3>Value</h3>

<p>An object of class <code>RprobitB_latent_classes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### default setting
RprobitB:::RprobitB_latent_classes()

### setting for a fixed number of two latent classes
RprobitB:::RprobitB_latent_classes(list(C = 2))

### setting for weight-based on Dirichlet process-based updates
RprobitB:::RprobitB_latent_classes(
  list("weight_update" = TRUE, "dp_update" = TRUE)
)

</code></pre>

<hr>
<h2 id='RprobitB_normalization'>Create object of class <code>RprobitB_normalization</code></h2><span id='topic+RprobitB_normalization'></span><span id='topic+print.RprobitB_normalization'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>RprobitB_normalization</code>,
which determines the utility scale and level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_normalization(
  level,
  scale = "Sigma_1,1 := 1",
  form,
  re = NULL,
  alternatives,
  base,
  ordered = FALSE
)

## S3 method for class 'RprobitB_normalization'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_normalization_+3A_level">level</code></td>
<td>
<p>The alternative name with respect to which utility differences are computed.
Currently, only differences with respect to the last alternative can be
computed.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_scale">scale</code></td>
<td>
<p>A character which determines the utility scale. It is of the form
<code style="white-space: pre;">&#8288;&lt;parameter&gt; := &lt;value&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;parameter&gt;&#8288;</code> is either the name of a fixed
effect or <code style="white-space: pre;">&#8288;Sigma_&lt;j&gt;,&lt;j&gt;&#8288;</code> for the <code style="white-space: pre;">&#8288;&lt;j&gt;&#8288;</code>th diagonal element of <code>Sigma</code>, and
<code style="white-space: pre;">&#8288;&lt;value&gt;&#8288;</code> is the value of the fixed parameter.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_base">base</code></td>
<td>
<p>A character, the name of the base alternative for covariates that are not
alternative specific (i.e. type 2 covariates and ASCs). Ignored and set to
<code>NULL</code> if the model has no alternative specific covariates (e.g. in the
ordered probit model).
Per default, <code>base</code> is the last element of <code>alternatives</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_normalization</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_normalization_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any choice model has to be normalized with respect to the utility level and
scale.
</p>

<ul>
<li><p> For level normalization, <code>{RprobitB}</code> takes utility differences
with respect to one alternative.
For the ordered model where only one utility is modeled,
<code>{RprobitB}</code> fixes the first utility threshold to 0.
</p>
</li>
<li><p> For scale normalization, <code>{RprobitB}</code> fixes one model parameter.
Per default, the first error-term variance is fixed to <code>1</code>.
This is specified via <code>scale = "Sigma_1,1 := 1"</code>.
Alternatively, any error-term variance or any non-random coefficient
can be fixed.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>RprobitB_normalization</code>, which is a list of
</p>

<ul>
<li> <p><code>level</code>, a list with the elements <code>level</code> (the number of the
alternative specified by the input <code>level</code>) and <code>name</code> (the name of
the alternative, i.e. the input <code>level</code>), or alternatively
<code>NA</code> in the ordered probit case,
</p>
</li>
<li><p> and <code>scale</code>, a list with the elements <code>parameter</code> (either <code>"s"</code> for
an element of <code>Sigma</code> or <code>"a"</code>for an element of <code>alpha</code>), the
parameter <code>index</code>, and the fixed <code>value</code>. If <code>parameter = "a"</code>, also
the <code>name</code> of the fixed effect.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::RprobitB_normalization(
  level = "B",
  scale = "price := -1",
  form = choice ~ price + time + comfort + change | 1,
  re = "time",
  alternatives = c("A", "B"),
  base = "A"
)

</code></pre>

<hr>
<h2 id='RprobitB_parameter'>Define probit model parameter</h2><span id='topic+RprobitB_parameter'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>RprobitB_parameter</code>, which
contains the parameters of a probit model.
If <code>sample = TRUE</code>, missing parameters are sampled. All parameters are
checked against the values of <code>P_f</code>, <code>P_r</code>, <code>J</code>, and <code>N</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RprobitB_parameter(
  P_f,
  P_r,
  J,
  N,
  ordered = FALSE,
  alpha = NULL,
  C = NULL,
  s = NULL,
  b = NULL,
  Omega = NULL,
  Sigma = NULL,
  Sigma_full = NULL,
  beta = NULL,
  z = NULL,
  d = NULL,
  seed = NULL,
  sample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RprobitB_parameter_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_n">N</code></td>
<td>
<p>The number (greater or equal 1) of decision makers.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_alpha">alpha</code></td>
<td>
<p>The fixed coefficient vector of length <code>P_f</code>.
Set to <code>NA</code> if <code>P_f = 0</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_c">C</code></td>
<td>
<p>The number (greater or equal 1) of latent classes of decision makers.
Set to <code>NA</code> if <code>P_r = 0</code>. Otherwise, <code>C = 1</code> per default.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_s">s</code></td>
<td>
<p>The vector of class weights of length <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.
For identifiability, the vector must be non-ascending.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_sigma">Sigma</code></td>
<td>
<p>The differenced error term covariance matrix of dimension
<code>J-1</code> x <code>J-1</code> with respect to alternative <code>J</code>.
In case of <code>ordered = TRUE</code>, a numeric, the single error term variance.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_sigma_full">Sigma_full</code></td>
<td>
<p>The error term covariance matrix of dimension <code>J</code> x <code>J</code>.
Internally, <code>Sigma_full</code> gets differenced with respect to alternative
<code>J</code>, so it becomes an identified covariance matrix of dimension
<code>J-1</code> x <code>J-1</code>. <code>Sigma_full</code> is ignored if <code>Sigma</code> is
specified or <code>ordered = TRUE</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_d">d</code></td>
<td>
<p>The numeric vector of the logarithmic increases of the utility thresholds
in the ordered probit case (<code>ordered = TRUE</code>) of length <code>J-2</code>.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_seed">seed</code></td>
<td>
<p>Set a seed for the sampling of missing parameters.</p>
</td></tr>
<tr><td><code id="RprobitB_parameter_+3A_sample">sample</code></td>
<td>
<p>A boolean, if <code>TRUE</code> (default) missing parameters get sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_parameter</code>, i.e. a named list with the
model parameters <code>alpha</code>, <code>C</code>, <code>s</code>, <code>b</code>, <code>Omega</code>,
<code>Sigma</code>, <code>Sigma_full</code>, <code>beta</code>, and <code>z</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB_parameter(P_f = 1, P_r = 2, J = 3, N = 10)
</code></pre>

<hr>
<h2 id='rtnorm'>Draw from one-sided truncated normal</h2><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>This function draws from a one-sided truncated univariate normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm(mu, sig, trunpt, above)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtnorm_+3A_mu">mu</code></td>
<td>
<p>The mean.</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_sig">sig</code></td>
<td>
<p>The standard deviation.</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_trunpt">trunpt</code></td>
<td>
<p>The truncation point.</p>
</td></tr>
<tr><td><code id="rtnorm_+3A_above">above</code></td>
<td>
<p>A boolean, if <code>TRUE</code> truncate from above, otherwise from below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### samples from a standard normal truncated at 1 from above
R &lt;- 1e4
draws &lt;- replicate(R, rtnorm(0,1,1,TRUE))
plot(density(draws))
</code></pre>

<hr>
<h2 id='rttnorm'>Draw from two-sided truncated normal</h2><span id='topic+rttnorm'></span>

<h3>Description</h3>

<p>This function draws from a two-sided truncated univariate normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rttnorm(mu, sig, lower_bound, upper_bound)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rttnorm_+3A_mu">mu</code></td>
<td>
<p>The mean.</p>
</td></tr>
<tr><td><code id="rttnorm_+3A_sig">sig</code></td>
<td>
<p>The standard deviation.</p>
</td></tr>
<tr><td><code id="rttnorm_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower truncation point.</p>
</td></tr>
<tr><td><code id="rttnorm_+3A_upper_bound">upper_bound</code></td>
<td>
<p>The upper truncation point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### samples from a standard normal truncated at -2 and 2
R &lt;- 1e4
draws &lt;- replicate(R, rttnorm(0,1,-2,2))
plot(density(draws))
</code></pre>

<hr>
<h2 id='rwishart'>Draw from Wishart distribution</h2><span id='topic+rwishart'></span>

<h3>Description</h3>

<p>This function draws from a Wishart and inverted Wishart distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwishart(nu, V)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rwishart_+3A_nu">nu</code></td>
<td>
<p>A numeric, the degrees of freedom. Must be at least the number of dimensions.</p>
</td></tr>
<tr><td><code id="rwishart_+3A_v">V</code></td>
<td>
<p>A matrix, the scale matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wishart distribution is a generalization to multiple dimensions of the
gamma distributions and draws from the space of covariance matrices.
Its expectation is <code>nu*V</code> and its variance increases both in <code>nu</code>
and in the values of <code>V</code>.
The Wishart distribution is the conjugate prior to the precision matrix of
a multivariate normal distribution and proper if <code>nu</code> is greater than
the number of dimensions.
</p>


<h3>Value</h3>

<p>A list, the draws from the Wishart (<code>W</code>), inverted Wishart (<code>IW</code>), and
corresponding Choleski decomposition (<code>C</code> and <code>CI</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rwishart(nu = 2, V = diag(2))
</code></pre>

<hr>
<h2 id='set_initial_gibbs_values'>Set initial values for the Gibbs sampler</h2><span id='topic+set_initial_gibbs_values'></span>

<h3>Description</h3>

<p>This function sets initial values for the Gibbs sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_initial_gibbs_values(
  N,
  T,
  J,
  P_f,
  P_r,
  C,
  ordered = FALSE,
  ranked = FALSE,
  suff_stat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_initial_gibbs_values_+3A_n">N</code></td>
<td>
<p>The number (greater or equal 1) of decision makers.</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_t">T</code></td>
<td>
<p>The number (greater or equal 1) of choice occasions or a vector of choice
occasions of length <code>N</code> (i.e. a decision maker specific number).
Per default, <code>T = 1</code>.</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_p_f">P_f</code></td>
<td>
<p>The number of covariates connected to a fixed coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_p_r">P_r</code></td>
<td>
<p>The number of covariates connected to a random coefficient (can be 0).</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_c">C</code></td>
<td>
<p>The number (greater or equal 1) of latent classes.</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_ranked">ranked</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="set_initial_gibbs_values_+3A_suff_stat">suff_stat</code></td>
<td>
<p>Optionally the output of <code><a href="#topic+sufficient_statistics">sufficient_statistics</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of initial values for the Gibbs sampler.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RprobitB:::set_initial_gibbs_values(
  N = 2, T = 3, J = 3, P_f = 1, P_r = 2, C = 2
)
</code></pre>

<hr>
<h2 id='simulate_choices'>Simulate choice data</h2><span id='topic+simulate_choices'></span>

<h3>Description</h3>

<p>This function simulates choice data from a probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_choices(
  form,
  N,
  T = 1,
  J,
  re = NULL,
  alternatives = NULL,
  ordered = FALSE,
  ranked = FALSE,
  base = NULL,
  covariates = NULL,
  seed = NULL,
  true_parameter = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_choices_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_n">N</code></td>
<td>
<p>The number (greater or equal 1) of decision makers.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_t">T</code></td>
<td>
<p>The number (greater or equal 1) of choice occasions or a vector of choice
occasions of length <code>N</code> (i.e. a decision maker specific number).
Per default, <code>T = 1</code>.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_j">J</code></td>
<td>
<p>The number (greater or equal 2) of choice alternatives.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_ranked">ranked</code></td>
<td>
<p>TBA</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_base">base</code></td>
<td>
<p>A character, the name of the base alternative for covariates that are not
alternative specific (i.e. type 2 covariates and ASCs). Ignored and set to
<code>NULL</code> if the model has no alternative specific covariates (e.g. in the
ordered probit model).
Per default, <code>base</code> is the last element of <code>alternatives</code>.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_covariates">covariates</code></td>
<td>
<p>A named list of covariate values. Each element must be a vector of length
equal to the number of choice occasions and named according to a covariate.
Covariates for which no values are supplied are drawn from a standard normal
distribution.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_seed">seed</code></td>
<td>
<p>Set a seed for the simulation.</p>
</td></tr>
<tr><td><code id="simulate_choices_+3A_true_parameter">true_parameter</code></td>
<td>
<p>Optionally specify a named list with true parameter values for <code>alpha</code>,
<code>C</code>, <code>s</code>, <code>b</code>, <code>Omega</code>, <code>Sigma</code>, <code>Sigma_full</code>,
<code>beta</code>, <code>z</code>, or <code>d</code> for the simulation.
See <a href="https://loelschlaeger.de/RprobitB/articles/v01_model_definition.html">the vignette on model definition</a>
for definitions of these variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://loelschlaeger.de/RprobitB/articles/v02_choice_data.html">the vignette on choice data</a>
for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>RprobitB_data</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+check_form">check_form()</a></code> for checking the model formula
</p>
</li>
<li> <p><code><a href="#topic+overview_effects">overview_effects()</a></code> for an overview of the model effects
</p>
</li>
<li> <p><code><a href="#topic+create_lagged_cov">create_lagged_cov()</a></code> for creating lagged covariates
</p>
</li>
<li> <p><code><a href="#topic+as_cov_names">as_cov_names()</a></code> for re-labeling alternative-specific covariates
</p>
</li>
<li> <p><code><a href="#topic+prepare_data">prepare_data()</a></code> for preparing empirical choice data
</p>
</li>
<li> <p><code><a href="#topic+train_test">train_test()</a></code> for splitting choice data into a train and test subset
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>### simulate data from a binary probit model with two latent classes
data &lt;- simulate_choices(
  form = choice ~ cost | income | time,
  N = 100,
  T = 10,
  J = 2,
  re = c("cost", "time"),
  alternatives = c("car", "bus"),
  seed = 1,
  true_parameter = list(
    "alpha" = c(-1, 1),
    "b" = matrix(c(-1, -1, -0.5, -1.5, 0, -1), ncol = 2),
    "C" = 2
  )
)

### simulate data from an ordered probit model
data &lt;- simulate_choices(
  form = opinion ~ age + gender,
  N = 10,
  T = 1:10,
  J = 5,
  alternatives = c("very bad", "bad", "indifferent", "good", "very good"),
  ordered = TRUE,
  covariates = list(
    "gender" = rep(sample(c(0, 1), 10, replace = TRUE), times = 1:10)
  ),
  seed = 1
)

### simulate data from a ranked probit model
data &lt;- simulate_choices(
  form = product ~ price,
  N = 10,
  T = 1:10,
  J = 3,
  alternatives = c("A", "B", "C"),
  ranked = TRUE,
  seed = 1
)

</code></pre>

<hr>
<h2 id='sufficient_statistics'>Compute sufficient statistics</h2><span id='topic+sufficient_statistics'></span>

<h3>Description</h3>

<p>This function computes sufficient statistics from an <code>RprobitB_data</code>
object for the Gibbs sampler to save computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sufficient_statistics(data, normalization)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sufficient_statistics_+3A_data">data</code></td>
<td>
<p>An object of class <code>RprobitB_data</code>.</p>
</td></tr>
<tr><td><code id="sufficient_statistics_+3A_normalization">normalization</code></td>
<td>
<p>An object of class <code>RprobitB_normalization</code>, which can be created
via <code><a href="#topic+RprobitB_normalization">RprobitB_normalization</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of sufficient statistics on the data for Gibbs sampling, containing
</p>

<ul>
<li><p> the elements <code>N</code>, <code>T</code>, <code>J</code>, <code>P_f</code> and <code>P_r</code>
from <code>data</code>,
</p>
</li>
<li> <p><code>Tvec</code>, the vector of choice occasions for each decider of
length <code>N</code>,
</p>
</li>
<li> <p><code>csTvec</code>, a vector of length <code>N</code> with the cumulated sums of
<code>Tvec</code> starting from <code>0</code>,
</p>
</li>
<li> <p><code>W</code>, a list of design matrices differenced with respect to
alternative number <code>normalization$level$level</code>
for each decider in each choice occasion with covariates that
are linked to a fixed coefficient (or <code>NA</code> if <code>P_f = 0</code>),
</p>
</li>
<li> <p><code>X</code>, a list of design matrices differenced with respect to
alternative number <code>normalization$level$level</code>
for each decider in each choice occasion with covariates that
are linked to a random coefficient (or <code>NA</code> if <code>P_r = 0</code>),
</p>
</li>
<li> <p><code>y</code>, a matrix of dimension <code>N</code> x <code>max(Tvec)</code> with the
observed choices of deciders in rows and choice occasions in columns,
decoded to numeric values with respect to their appearance in
<code>data$alternatives</code>, where rows are filled with <code>NA</code> in
case of an unbalanced panel,
</p>
</li>
<li> <p><code>WkW</code>, a matrix of dimension <code>P_f^2</code> x <code>(J-1)^2</code>, the
sum over Kronecker products of each transposed element in <code>W</code>
with itself,
</p>
</li>
<li> <p><code>XkX</code>, a list of length <code>N</code>, each element is constructed in
the same way as <code>WkW</code> but with the elements in <code>X</code> and
separately for each decider,
</p>
</li>
<li> <p><code>rdiff</code> (for the ranked case only), a list of matrices that
reverse the base differencing and instead difference in such a way
that the resulting utility vector is negative.
</p>
</li></ul>


<hr>
<h2 id='train_choice'>Stated Preferences for Train Traveling</h2><span id='topic+train_choice'></span>

<h3>Description</h3>

<p>Data set of 2929 stated choices by 235 Dutch individuals deciding between
two virtual train trip options <code>"A"</code> and <code>"B"</code> based on the price,
the travel time, the number of rail-to-rail transfers (changes), and the
level of comfort.
</p>
<p>The data were obtained in 1987 by Hague Consulting Group for the National
Dutch Railways. Prices were recorded in Dutch guilder and in this data set
transformed to Euro at an exchange rate of 2.20371 guilders = 1 Euro.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_choice
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2929 rows and 11 columns:
</p>

<dl>
<dt>deciderID</dt><dd><p><code>integer</code> identifier for the decider</p>
</dd>
<dt>occasionID</dt><dd><p><code>integer</code> identifier for the choice occasion</p>
</dd>
<dt>choice</dt><dd><p><code>character</code> for the chosen alternative (either <code>"A"</code> or <code>"B"</code>)</p>
</dd>
<dt>price_A</dt><dd><p><code>numeric</code> price for alternative <code>"A"</code> in Euro</p>
</dd>
<dt>time_A</dt><dd><p><code>numeric</code> travel time for alternative <code>"A"</code> in hours</p>
</dd>
<dt>change_A</dt><dd><p><code>integer</code> number of changes for alternative <code>"A"</code></p>
</dd>
<dt>comfort_A</dt><dd><p><code>integer</code> comfort level (in decreasing comfort order) for alternative <code>"A"</code></p>
</dd>
<dt>price_B</dt><dd><p><code>numeric</code> price for alternative <code>"B"</code> in Euro</p>
</dd>
<dt>time_B</dt><dd><p><code>numeric</code> travel time for alternative <code>"B"</code> in hours</p>
</dd>
<dt>change_B</dt><dd><p><code>integer</code> number of changes for alternative <code>"B"</code></p>
</dd>
<dt>comfort_B</dt><dd><p><code>integer</code> comfort level (in decreasing comfort order) for alternative <code>"B"</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Ben-Akiva M, Bolduc D, Bradley M (1993).
&ldquo;Estimation of travel choice models with randomly distributed values of time.&rdquo;
<em>Transportation Research Record</em>, <b>1413</b>, 88&ndash;97.
</p>
<p>Meijer E, Rouwendal J (2006).
&ldquo;Measuring welfare effects in models with random coefficients.&rdquo;
<em>Journal of Applied Econometrics</em>, <b>21</b>(2), 227&ndash;244.
</p>

<hr>
<h2 id='train_test'>Split choice data in train and test subset</h2><span id='topic+train_test'></span>

<h3>Description</h3>

<p>This function splits choice data into a train and a test part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_test(
  x,
  test_proportion = NULL,
  test_number = NULL,
  by = "N",
  random = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_test_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_data</code>.</p>
</td></tr>
<tr><td><code id="train_test_+3A_test_proportion">test_proportion</code></td>
<td>
<p>A number between 0 and 1, the proportion of the test subsample.</p>
</td></tr>
<tr><td><code id="train_test_+3A_test_number">test_number</code></td>
<td>
<p>A positive integer, the number of observations in the test subsample.</p>
</td></tr>
<tr><td><code id="train_test_+3A_by">by</code></td>
<td>
<p>One of <code>"N"</code> (split by deciders) and <code>"T"</code> (split by choice
occasions).</p>
</td></tr>
<tr><td><code id="train_test_+3A_random">random</code></td>
<td>
<p>If <code>TRUE</code>, the subsamples are build randomly.</p>
</td></tr>
<tr><td><code id="train_test_+3A_seed">seed</code></td>
<td>
<p>Set a seed for building the subsamples randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://loelschlaeger.de/RprobitB/articles/v02_choice_data.html">the vignette on choice data</a>
for more details.
</p>


<h3>Value</h3>

<p>A list with two objects of class <code>RprobitB_data</code>, named <code>"train"</code>
and <code>"test"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### simulate choices for demonstration
x &lt;- simulate_choices(form = choice ~ covariate, N = 10, T = 10, J = 2)

### 70% of deciders in the train subsample,
### 30% of deciders in the test subsample
train_test(x, test_proportion = 0.3, by = "N")

### 2 randomly chosen choice occasions per decider in the test subsample,
### the rest in the train subsample
train_test(x, test_number = 2, by = "T", random = TRUE, seed = 1)

</code></pre>

<hr>
<h2 id='transform_gibbs_samples'>Transformation of Gibbs samples</h2><span id='topic+transform_gibbs_samples'></span>

<h3>Description</h3>

<p>This function normalizes, burns and thins the Gibbs samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_gibbs_samples(gibbs_samples, R, B, Q, normalization)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_gibbs_samples_+3A_gibbs_samples">gibbs_samples</code></td>
<td>
<p>The output of <code><a href="#topic+gibbs_sampling">gibbs_sampling</a></code>, i.e. a list of Gibbs samples for
</p>

<ul>
<li> <p><code>Sigma</code>,
</p>
</li>
<li> <p><code>alpha</code> (if <code>P_f&gt;0</code>),
</p>
</li>
<li> <p><code>s</code>, <code>z</code>, <code>b</code>, <code>Omega</code> (if <code>P_r&gt;0</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="transform_gibbs_samples_+3A_r">R</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="transform_gibbs_samples_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="transform_gibbs_samples_+3A_q">Q</code></td>
<td>
<p>The thinning factor for the Gibbs samples, i.e. only every <code>Q</code>th
sample is kept.</p>
</td></tr>
<tr><td><code id="transform_gibbs_samples_+3A_normalization">normalization</code></td>
<td>
<p>An object of class <code>RprobitB_normalization</code>, which can be created
via <code><a href="#topic+RprobitB_normalization">RprobitB_normalization</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, the first element <code>gibbs_sampes_raw</code> is the input
<code>gibbs_samples</code>, the second element is the normalized, burned, and
thinned version of <code>gibbs_samples</code> called <code>gibbs_samples_nbt</code>.
The list gets the class <code>RprobitB_gibbs_samples</code>.
</p>

<hr>
<h2 id='transform_parameter'>Transformation of parameter values</h2><span id='topic+transform_parameter'></span>

<h3>Description</h3>

<p>This function transforms parameter values based on <code>normalization</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_parameter(parameter, normalization, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_parameter_+3A_parameter">parameter</code></td>
<td>
<p>An object of class <code>RprobitB_parameter</code>.</p>
</td></tr>
<tr><td><code id="transform_parameter_+3A_normalization">normalization</code></td>
<td>
<p>An object of class <code>RprobitB_normalization</code>.</p>
</td></tr>
<tr><td><code id="transform_parameter_+3A_ordered">ordered</code></td>
<td>
<p>A boolean, <code>FALSE</code> per default. If <code>TRUE</code>, the choice set
<code>alternatives</code> is assumed to be ordered from worst to best.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RprobitB_parameter</code>.
</p>

<hr>
<h2 id='transform.RprobitB_fit'>Transform fitted probit model</h2><span id='topic+transform.RprobitB_fit'></span>

<h3>Description</h3>

<p>Given an object of class <code>RprobitB_fit</code>, this function can:
</p>

<ul>
<li><p> change the length <code>B</code> of the burn-in period,
</p>
</li>
<li><p> change the the thinning factor <code>Q</code> of the Gibbs samples,
</p>
</li>
<li><p> change the utility <code>scale</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_fit'
transform(
  `_data`,
  B = NULL,
  Q = NULL,
  scale = NULL,
  check_preference_flip = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform.RprobitB_fit_+3A__data">_data</code></td>
<td>
<p>An object of class <code><a href="#topic+RprobitB_fit">RprobitB_fit</a></code>.</p>
</td></tr>
<tr><td><code id="transform.RprobitB_fit_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="transform.RprobitB_fit_+3A_q">Q</code></td>
<td>
<p>The thinning factor for the Gibbs samples, i.e. only every <code>Q</code>th
sample is kept.</p>
</td></tr>
<tr><td><code id="transform.RprobitB_fit_+3A_scale">scale</code></td>
<td>
<p>A character which determines the utility scale. It is of the form
<code style="white-space: pre;">&#8288;&lt;parameter&gt; := &lt;value&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;parameter&gt;&#8288;</code> is either the name of a fixed
effect or <code style="white-space: pre;">&#8288;Sigma_&lt;j&gt;,&lt;j&gt;&#8288;</code> for the <code style="white-space: pre;">&#8288;&lt;j&gt;&#8288;</code>th diagonal element of <code>Sigma</code>, and
<code style="white-space: pre;">&#8288;&lt;value&gt;&#8288;</code> is the value of the fixed parameter.</p>
</td></tr>
<tr><td><code id="transform.RprobitB_fit_+3A_check_preference_flip">check_preference_flip</code></td>
<td>
<p>Set to <code>TRUE</code> to check for flip in preferences after new <code>scale</code>.</p>
</td></tr>
<tr><td><code id="transform.RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Model fitting&quot; for more details:
<code>vignette("v03_model_fitting", package = "RprobitB")</code>.
</p>


<h3>Value</h3>

<p>The transformed <code>RprobitB_fit</code> object.
</p>

<hr>
<h2 id='undiff_Sigma'>Transform differenced to non-differenced error term covariance matrix</h2><span id='topic+undiff_Sigma'></span>

<h3>Description</h3>

<p>This function transforms the differenced error term covariance matrix
<code>Sigma</code> back to a non-differenced error term covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undiff_Sigma(Sigma, i, checks = TRUE, pos = TRUE, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undiff_Sigma_+3A_sigma">Sigma</code></td>
<td>
<p>An error term covariance matrix of dimension <code>J-1</code> x <code>J-1</code> which
was differenced with respect to alternative <code>i</code>.</p>
</td></tr>
<tr><td><code id="undiff_Sigma_+3A_i">i</code></td>
<td>
<p>An integer, the alternative number with respect to which <code>Sigma</code>
was differenced.</p>
</td></tr>
<tr><td><code id="undiff_Sigma_+3A_checks">checks</code></td>
<td>
<p>If <code>TRUE</code> the function runs additional input and transformation checks.</p>
</td></tr>
<tr><td><code id="undiff_Sigma_+3A_pos">pos</code></td>
<td>
<p>If <code>TRUE</code> the function returns a positive matrix.</p>
</td></tr>
<tr><td><code id="undiff_Sigma_+3A_labels">labels</code></td>
<td>
<p>If <code>TRUE</code> the function adds labels to the output matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix of dimension <code>J</code> x <code>J</code>. If this covariance
matrix gets differenced with respect to alternative <code>i</code>, the results is
again <code>Sigma</code>.
</p>

<hr>
<h2 id='update_b'>Update class means</h2><span id='topic+update_b'></span>

<h3>Description</h3>

<p>This function updates the class means (independent from the other classes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_b(beta, Omega, z, m, xi, Dinv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_b_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_b_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_b_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_b_+3A_m">m</code></td>
<td>
<p>The vector of class sizes of length <code>C</code>.</p>
</td></tr>
<tr><td><code id="update_b_+3A_xi">xi</code></td>
<td>
<p>The mean vector of length <code>P_r</code> of the normal prior for each <code>b_c</code>.
Per default, <code>xi = numeric(P_r)</code>.</p>
</td></tr>
<tr><td><code id="update_b_+3A_dinv">Dinv</code></td>
<td>
<p>The precision matrix (i.e. the inverse of the covariance matrix) of dimension <code>P_r</code> x <code>P_r</code>
of the normal prior for each <code>b_c</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following holds independently for each class <code class="reqn">c</code>.
Let <code class="reqn">b_c</code> be the mean of class number <code class="reqn">c</code>. A priori, we assume that <code class="reqn">b_c</code> is normally distributed
with mean vector <code class="reqn">\xi</code> and covariance matrix <code class="reqn">D</code>.
Let <code class="reqn">(\beta_n)_{z_n=c}</code> be the collection of <code class="reqn">\beta_n</code> that are currently allocated to class <code class="reqn">c</code>,
<code class="reqn">m_c</code> the class size, and <code class="reqn">\bar{b}_c</code> their arithmetic mean.
Assuming independence across draws, <code class="reqn">(\beta_n)_{z_n=c}</code> has
a normal likelihood of </p>
<p style="text-align: center;"><code class="reqn">\prod_n \phi(\beta_n \mid b_c,\Omega_c),</code>
</p>
<p> where the product is over the values <code class="reqn">n</code>
for which <code class="reqn">z_n=c</code> holds.
Due to the conjugacy of the prior, the posterior <code class="reqn">\Pr(b_c \mid (\beta_n)_{z_n=c})</code> follows a normal distribution
with mean </p>
<p style="text-align: center;"><code class="reqn">(D^{-1} + m_c\Omega_c^{-1})^{-1}(D^{-1}\xi + m_c\Omega_c^{-1}\bar{b}_c)</code>
</p>
<p> and covariance matrix
</p>
<p style="text-align: center;"><code class="reqn">(D^{-1} + m_c \Omega_c^{-1})^{-1}.</code>
</p>



<h3>Value</h3>

<p>A matrix of updated means for each class in columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### N = 100 decider, P_r = 2 random coefficients, and C = 2 latent classes
N &lt;- 100
(b_true &lt;- cbind(c(0,0),c(1,1)))
Omega &lt;- matrix(c(1,0.3,0.3,0.5,1,-0.3,-0.3,0.8), ncol=2)
z &lt;- c(rep(1,N/2),rep(2,N/2))
m &lt;- as.numeric(table(z))
beta &lt;- sapply(z, function(z) rmvnorm(b_true[,z], matrix(Omega[,z],2,2)))
### prior mean vector and precision matrix (inverse of covariance matrix)
xi &lt;- c(0,0)
Dinv &lt;- diag(2)
### updated class means (in columns)
update_b(beta = beta, Omega = Omega, z = z, m = m, xi = xi, Dinv = Dinv)
</code></pre>

<hr>
<h2 id='update_classes_dp'>Dirichlet process-based update of latent classes</h2><span id='topic+update_classes_dp'></span>

<h3>Description</h3>

<p>This function updates the latent classes based on a Dirichlet process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_classes_dp(
  Cmax,
  beta,
  z,
  b,
  Omega,
  delta,
  xi,
  D,
  nu,
  Theta,
  s_desc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_classes_dp_+3A_cmax">Cmax</code></td>
<td>
<p>The maximum number of classes.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_delta">delta</code></td>
<td>
<p>A numeric for the concentration parameter vector <code>rep(delta,C)</code> of the
Dirichlet prior for <code>s</code>.
Per default, <code>delta = 1</code>. In case of Dirichlet process-based updates of the
latent classes, <code>delta = 0.1</code> per default.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_xi">xi</code></td>
<td>
<p>The mean vector of length <code>P_r</code> of the normal prior for each <code>b_c</code>.
Per default, <code>xi = numeric(P_r)</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_d">D</code></td>
<td>
<p>The covariance matrix of dimension <code>P_r</code> x <code>P_r</code> of the normal prior for
each <code>b_c</code>.
Per default, <code>D = diag(P_r)</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_nu">nu</code></td>
<td>
<p>The degrees of freedom (a natural number greater than <code>P_r</code>) of the Inverse
Wishart prior for each <code>Omega_c</code>.
Per default, <code>nu = P_r + 2</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_theta">Theta</code></td>
<td>
<p>The scale matrix of dimension <code>P_r</code> x <code>P_r</code> of the Inverse Wishart prior for
each <code>Omega_c</code>.
Per default, <code>Theta = diag(P_r)</code>.</p>
</td></tr>
<tr><td><code id="update_classes_dp_+3A_s_desc">s_desc</code></td>
<td>
<p>If <code>TRUE</code>, sort the classes in descending class weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be added.
</p>


<h3>Value</h3>

<p>A list of updated values for <code>z</code>, <code>b</code>, <code>Omega</code>, <code>s</code>,
and <code>C</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
z &lt;- c(rep(1,20),rep(2,30))
b &lt;- matrix(c(1,1,1,-1), ncol=2)
Omega &lt;- matrix(c(1,0.3,0.3,0.5,1,-0.3,-0.3,0.8), ncol=2)
beta &lt;- sapply(z, function(z) rmvnorm(b[,z], matrix(Omega[,z],2,2)))
delta &lt;- 1
xi &lt;- numeric(2)
D &lt;- diag(2)
nu &lt;- 4
Theta &lt;- diag(2)
RprobitB:::update_classes_dp(
  Cmax = 10, beta = beta, z = z, b = b, Omega = Omega,
  delta = delta, xi = xi, D = D, nu = nu, Theta = Theta
)
</code></pre>

<hr>
<h2 id='update_classes_wb'>Weight-based update of latent classes</h2><span id='topic+update_classes_wb'></span>

<h3>Description</h3>

<p>This function updates the latent classes based on their class weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_classes_wb(Cmax, epsmin, epsmax, distmin, s, b, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_classes_wb_+3A_cmax">Cmax</code></td>
<td>
<p>The maximum number of classes.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_epsmin">epsmin</code></td>
<td>
<p>The threshold weight (between 0 and 1) for removing a class.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_epsmax">epsmax</code></td>
<td>
<p>The threshold weight (between 0 and 1) for splitting a class.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_distmin">distmin</code></td>
<td>
<p>The (non-negative) threshold difference in class means for joining two
classes.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_s">s</code></td>
<td>
<p>The vector of class weights of length <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.
For identifiability, the vector must be non-ascending.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_classes_wb_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The updating scheme bases on the following rules:
</p>

<ul>
<li><p> We remove class <code class="reqn">c</code>, if <code class="reqn">s_c&lt;\epsilon_{min}</code>, i.e. if the
class weight <code class="reqn">s_c</code> drops below some threshold
<code class="reqn">\epsilon_{min}</code>.
This case indicates that class <code class="reqn">c</code> has a negligible impact on the
mixing distribution.
</p>
</li>
<li><p> We split class <code class="reqn">c</code> into two classes <code class="reqn">c_1</code> and <code class="reqn">c_2</code>, if
<code class="reqn">s_c&gt;\epsilon_{max}</code>.
This case indicates that class <code class="reqn">c</code> has a high influence on the mixing
distribution whose approximation can potentially be improved by
increasing the resolution in directions of high variance.
Therefore, the class means <code class="reqn">b_{c_1}</code> and <code class="reqn">b_{c_2}</code> of the new
classes <code class="reqn">c_1</code> and <code class="reqn">c_2</code> are shifted in opposite directions from
the class mean <code class="reqn">b_c</code> of the old class <code class="reqn">c</code> in the direction of the
highest variance.
</p>
</li>
<li><p> We join two classes <code class="reqn">c_1</code> and <code class="reqn">c_2</code> to one class <code class="reqn">c</code>, if
<code class="reqn">||b_{c_1} - b_{c_2}||&lt;\epsilon_{distmin}</code>, i.e. if
the euclidean distance between the class means <code class="reqn">b_{c_1}</code> and
<code class="reqn">b_{c_2}</code> drops below some threshold <code class="reqn">\epsilon_{distmin}</code>.
This case indicates location redundancy which should be repealed. The
parameters of <code class="reqn">c</code> are assigned by adding the values of <code class="reqn">s</code> from
<code class="reqn">c_1</code> and <code class="reqn">c_2</code> and averaging the values for <code class="reqn">b</code> and
<code class="reqn">\Omega</code>.
The rules are executed in the above order, but only one rule per iteration
and only if <code>Cmax</code> is not exceeded.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of updated values for <code>s</code>, <code>b</code>, and <code>Omega</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### parameter settings
s &lt;- c(0.8,0.2)
b &lt;- matrix(c(1,1,1,-1), ncol=2)
Omega &lt;- matrix(c(0.5,0.3,0.3,0.5,1,-0.1,-0.1,0.8), ncol=2)

### Remove class 2
RprobitB:::update_classes_wb(Cmax = 10, epsmin = 0.3, epsmax = 0.9, distmin = 1,
                             s = s, b = b, Omega = Omega)

### Split class 1
RprobitB:::update_classes_wb(Cmax = 10, epsmin = 0.1, epsmax = 0.7, distmin = 1,
                             s = s, b = b, Omega = Omega)

### Join classes
RprobitB:::update_classes_wb(Cmax = 10, epsmin = 0.1, epsmax = 0.9, distmin = 3,
                             s = s, b = b, Omega = Omega)
</code></pre>

<hr>
<h2 id='update_d'>Update utility threshold increments</h2><span id='topic+update_d'></span>

<h3>Description</h3>

<p>This function updates the utility threshold increments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_d(d, y, mu, ll, zeta, Z, Tvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_d_+3A_d">d</code></td>
<td>
<p>The current vector of utility threshold increments.</p>
</td></tr>
<tr><td><code id="update_d_+3A_y">y</code></td>
<td>
<p>A matrix of the choices.</p>
</td></tr>
<tr><td><code id="update_d_+3A_mu">mu</code></td>
<td>
<p>A matrix of the systematic utilities.</p>
</td></tr>
<tr><td><code id="update_d_+3A_ll">ll</code></td>
<td>
<p>Current log-likelihood value.</p>
</td></tr>
<tr><td><code id="update_d_+3A_zeta">zeta</code></td>
<td>
<p>The mean vector of the normal prior for <code>d</code>.</p>
</td></tr>
<tr><td><code id="update_d_+3A_z">Z</code></td>
<td>
<p>The covariance matrix of the normal prior for <code>d</code>.</p>
</td></tr>
<tr><td><code id="update_d_+3A_tvec">Tvec</code></td>
<td>
<p>The element <code>Tvec</code> in <code><a href="#topic+sufficient_statistics">sufficient_statistics</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated value for <code>d</code>.
</p>

<hr>
<h2 id='update_m'>Update class sizes</h2><span id='topic+update_m'></span>

<h3>Description</h3>

<p>This function updates the class size vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_m(C, z, nozero)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_m_+3A_c">C</code></td>
<td>
<p>The number (greater or equal 1) of latent classes of decision makers.
Set to <code>NA</code> if <code>P_r = 0</code>. Otherwise, <code>C = 1</code> per default.</p>
</td></tr>
<tr><td><code id="update_m_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_m_+3A_nozero">nozero</code></td>
<td>
<p>If <code>TRUE</code>, each element in the output vector <code>m</code> is at least one
(for numerical stability).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated class size vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>update_m(C = 3, z = c(1,1,1,2,2,3), FALSE)
</code></pre>

<hr>
<h2 id='update_Omega'>Update class covariances</h2><span id='topic+update_Omega'></span>

<h3>Description</h3>

<p>This function updates the class covariances (independent from the other classes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Omega(beta, b, z, m, nu, Theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_Omega_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_Omega_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_Omega_+3A_z">z</code></td>
<td>
<p>The vector of the allocation variables of length <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_Omega_+3A_m">m</code></td>
<td>
<p>The vector of class sizes of length <code>C</code>.</p>
</td></tr>
<tr><td><code id="update_Omega_+3A_nu">nu</code></td>
<td>
<p>The degrees of freedom (a natural number greater than <code>P_r</code>) of the Inverse
Wishart prior for each <code>Omega_c</code>.
Per default, <code>nu = P_r + 2</code>.</p>
</td></tr>
<tr><td><code id="update_Omega_+3A_theta">Theta</code></td>
<td>
<p>The scale matrix of dimension <code>P_r</code> x <code>P_r</code> of the Inverse Wishart prior for
each <code>Omega_c</code>.
Per default, <code>Theta = diag(P_r)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following holds independently for each class <code class="reqn">c</code>.
Let <code class="reqn">\Omega_c</code> be the covariance matrix of class number <code>c</code>.
A priori, we assume that <code class="reqn">\Omega_c</code> is inverse Wishart distributed
with <code class="reqn">\nu</code> degrees of freedom and scale matrix <code class="reqn">\Theta</code>.
Let <code class="reqn">(\beta_n)_{z_n=c}</code> be the collection of <code class="reqn">\beta_n</code> that are currently allocated to class <code class="reqn">c</code>,
<code class="reqn">m_c</code> the size of class <code class="reqn">c</code>, and <code class="reqn">b_c</code> the class mean vector.
Due to the conjugacy of the prior, the posterior <code class="reqn">\Pr(\Omega_c \mid (\beta_n)_{z_n=c})</code> follows an inverted Wishart distribution
with <code class="reqn">\nu + m_c</code> degrees of freedom and scale matrix <code class="reqn">\Theta^{-1} + \sum_n (\beta_n - b_c)(\beta_n - b_c)'</code>, where
the product is over the values <code class="reqn">n</code> for which <code class="reqn">z_n=c</code> holds.
</p>


<h3>Value</h3>

<p>A matrix of updated covariance matrices for each class in columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### N = 100 decider, P_r = 2 random coefficients, and C = 2 latent classes
N &lt;- 100
b &lt;- cbind(c(0,0),c(1,1))
(Omega_true &lt;- matrix(c(1,0.3,0.3,0.5,1,-0.3,-0.3,0.8), ncol=2))
z &lt;- c(rep(1,N/2),rep(2,N/2))
m &lt;- as.numeric(table(z))
beta &lt;- sapply(z, function(z) rmvnorm(b[,z], matrix(Omega_true[,z],2,2)))
### degrees of freedom and scale matrix for the Wishart prior
nu &lt;- 1
Theta &lt;- diag(2)
### updated class covariance matrices (in columns)
update_Omega(beta = beta, b = b, z = z, m = m, nu = nu, Theta = Theta)
</code></pre>

<hr>
<h2 id='update_reg'>Update coefficient vector of multiple linear regression</h2><span id='topic+update_reg'></span>

<h3>Description</h3>

<p>This function updates the coefficient vector of a multiple linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_reg(mu0, Tau0, XSigX, XSigU)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_reg_+3A_mu0">mu0</code></td>
<td>
<p>The mean vector of the normal prior distribution for the coefficient vector.</p>
</td></tr>
<tr><td><code id="update_reg_+3A_tau0">Tau0</code></td>
<td>
<p>The precision matrix (i.e. inverted covariance matrix) of the normal prior distribution for the coefficient vector.</p>
</td></tr>
<tr><td><code id="update_reg_+3A_xsigx">XSigX</code></td>
<td>
<p>The matrix <code class="reqn">\sum_{n=1}^N X_n'\Sigma^{-1}X_n</code>. See below for details.</p>
</td></tr>
<tr><td><code id="update_reg_+3A_xsigu">XSigU</code></td>
<td>
<p>The vector <code class="reqn">\sum_{n=1}^N X_n'\Sigma^{-1}U_n</code>. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws from the posterior distribution of <code class="reqn">\beta</code> in the linear utility
equation </p>
<p style="text-align: center;"><code class="reqn">U_n = X_n\beta + \epsilon_n,</code>
</p>
<p> where <code class="reqn">U_n</code> is the
(latent, but here assumed to be known) utility vector of decider <code class="reqn">n = 1,\dots,N</code>, <code class="reqn">X_n</code>
is the design matrix build from the choice characteristics faced by <code class="reqn">n</code>,
<code class="reqn">\beta</code> is the unknown coefficient vector (this can be either the fixed
coefficient vector <code class="reqn">\alpha</code> or the decider-specific coefficient vector <code class="reqn">\beta_n</code>),
and <code class="reqn">\epsilon_n</code> is the error term assumed to be normally distributed with mean <code class="reqn">0</code>
and (known) covariance matrix <code class="reqn">\Sigma</code>.
A priori we assume the (conjugate) normal prior distribution </p>
<p style="text-align: center;"><code class="reqn">\beta \sim N(\mu_0,T_0)</code>
</p>

<p>with mean vector <code class="reqn">\mu_0</code> and precision matrix (i.e. inverted covariance matrix) <code class="reqn">T_0</code>.
The posterior distribution for <code class="reqn">\beta</code> is normal with
covariance matrix </p>
<p style="text-align: center;"><code class="reqn">\Sigma_1 = (T_0 + \sum_{n=1}^N X_n'\Sigma^{-1}X_n)^{-1}</code>
</p>
<p> and mean vector
</p>
<p style="text-align: center;"><code class="reqn">\mu_1 = \Sigma_1(T_0\mu_0 + \sum_{n=1}^N X_n'\Sigma^{-1}U_n)</code>
</p>
<p>.
Note the analogy of <code class="reqn">\mu_1</code> to the generalized least squares estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat{\beta}_{GLS} = (\sum_{n=1}^N X_n'\Sigma^{-1}X_n)^{-1} \sum_{n=1}^N X_n'\Sigma^{-1}U_n</code>
</p>
<p> which
becomes weighted by the prior parameters <code class="reqn">\mu_0</code> and <code class="reqn">T_0</code>.
</p>


<h3>Value</h3>

<p>A vector, a draw from the normal posterior distribution of the coefficient
vector in a multiple linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### true coefficient vector
beta_true &lt;- matrix(c(-1,1), ncol=1)
### error term covariance matrix
Sigma &lt;- matrix(c(1,0.5,0.2,0.5,1,0.2,0.2,0.2,2), ncol=3)
### draw data
N &lt;- 100
X &lt;- replicate(N, matrix(rnorm(6), ncol=2), simplify = FALSE)
eps &lt;- replicate(N, rmvnorm(mu = c(0,0,0), Sigma = Sigma), simplify = FALSE)
U &lt;- mapply(function(X, eps) X %*% beta_true + eps, X, eps, SIMPLIFY = FALSE)
### prior parameters for coefficient vector
mu0 &lt;- c(0,0)
Tau0 &lt;- diag(2)
### draw from posterior of coefficient vector
XSigX &lt;- Reduce(`+`, lapply(X, function(X) t(X) %*% solve(Sigma) %*% X))
XSigU &lt;- Reduce(`+`, mapply(function(X, U) t(X) %*% solve(Sigma) %*% U, X, U, SIMPLIFY = FALSE))
beta_draws &lt;- replicate(100, update_reg(mu0, Tau0, XSigX, XSigU), simplify = TRUE)
rowMeans(beta_draws)
</code></pre>

<hr>
<h2 id='update_s'>Update class weight vector</h2><span id='topic+update_s'></span>

<h3>Description</h3>

<p>This function updates the class weight vector by drawing from its posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_s(delta, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_s_+3A_delta">delta</code></td>
<td>
<p>A numeric for the concentration parameter vector <code>rep(delta,C)</code> of the
Dirichlet prior for <code>s</code>.
Per default, <code>delta = 1</code>. In case of Dirichlet process-based updates of the
latent classes, <code>delta = 0.1</code> per default.</p>
</td></tr>
<tr><td><code id="update_s_+3A_m">m</code></td>
<td>
<p>The vector of current class frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">m=(m_1,\dots,m_C)</code> be the frequencies of <code class="reqn">C</code> classes.
Given the class weight (probability) vector <code class="reqn">s=(s_1,\dots,s_C)</code>, the distribution
of <code class="reqn">m</code> is multinomial and its likelihood is </p>
<p style="text-align: center;"><code class="reqn">L(m\mid s) \propto \prod_{i=1}^C s_i^{m_i}.</code>
</p>

<p>The conjugate prior <code class="reqn">p(s)</code> for <code class="reqn">s</code> is a Dirichlet distribution, which has a density function
proportional to </p>
<p style="text-align: center;"><code class="reqn">\prod_{i=1}^C s_i^{\delta_i-1},</code>
</p>
<p> where <code class="reqn">\delta = (\delta_1,\dots,\delta_C)</code>
is the concentration parameter vector.
Note that in <code>{RprobitB}</code>, <code class="reqn">\delta_1=\dots=\delta_C</code>. This restriction is necessary because the class number <code class="reqn">C</code> can change.
The posterior distribution of <code class="reqn">s</code> is proportional to </p>
<p style="text-align: center;"><code class="reqn">p(s) L(m\mid s) \propto \prod_{i=1}^C s_i^{\delta_i + m_i - 1},</code>
</p>

<p>which in turn is proportional to a Dirichlet distribution with parameters <code class="reqn">\delta+m</code>.
</p>


<h3>Value</h3>

<p>A vector, a draw from the Dirichlet posterior distribution for <code>s</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### number of classes
C &lt;- 4
### current class sizes
m &lt;- sample.int(C)
### concentration parameter for Dirichlet prior (single-valued)
delta &lt;- 1
### updated class weight vector
update_s(delta = 1, m = m)
</code></pre>

<hr>
<h2 id='update_Sigma'>Update error term covariance matrix of multiple linear regression</h2><span id='topic+update_Sigma'></span>

<h3>Description</h3>

<p>This function updates the error term covariance matrix of a multiple linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_Sigma(kappa, E, N, S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_Sigma_+3A_kappa">kappa</code></td>
<td>
<p>The degrees of freedom (a natural number greater than <code>J-1</code>) of the Inverse
Wishart prior for <code>Sigma</code>.
Per default, <code>kappa = J + 1</code>.</p>
</td></tr>
<tr><td><code id="update_Sigma_+3A_e">E</code></td>
<td>
<p>The scale matrix of dimension <code>J-1</code> x <code>J-1</code> of the Inverse Wishart
prior for <code>Sigma</code>.
Per default, <code>E = diag(J - 1)</code>.</p>
</td></tr>
<tr><td><code id="update_Sigma_+3A_n">N</code></td>
<td>
<p>The draw size.</p>
</td></tr>
<tr><td><code id="update_Sigma_+3A_s">S</code></td>
<td>
<p>A matrix, the sum over the outer products of the residuals <code class="reqn">(\epsilon_n)_{n=1,\dots,N}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws from the posterior distribution of the covariance matrix <code class="reqn">\Sigma</code> in the linear utility
equation </p>
<p style="text-align: center;"><code class="reqn">U_n = X_n\beta + \epsilon_n,</code>
</p>
<p> where <code class="reqn">U_n</code> is the
(latent, but here assumed to be known) utility vector of decider <code class="reqn">n = 1,\dots,N</code>, <code class="reqn">X_n</code>
is the design matrix build from the choice characteristics faced by <code class="reqn">n</code>,
<code class="reqn">\beta</code> is the coefficient vector, and <code class="reqn">\epsilon_n</code> is the error term assumed to be
normally distributed with mean <code class="reqn">0</code> and unknown covariance matrix <code class="reqn">\Sigma</code>.
A priori we assume the (conjugate) Inverse Wishart distribution </p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim W(\kappa,E)</code>
</p>

<p>with <code class="reqn">\kappa</code> degrees of freedom and scale matrix <code class="reqn">E</code>.
The posterior for <code class="reqn">\Sigma</code> is the Inverted Wishart distribution with <code class="reqn">\kappa + N</code> degrees of freedom
and scale matrix <code class="reqn">E^{-1}+S</code>, where <code class="reqn">S = \sum_{n=1}^{N} \epsilon_n \epsilon_n'</code> is the sum over
the outer products of the residuals <code class="reqn">(\epsilon_n = U_n - X_n\beta)_n</code>.
</p>


<h3>Value</h3>

<p>A matrix, a draw from the Inverse Wishart posterior distribution of the error term
covariance matrix in a multiple linear regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### true error term covariance matrix
(Sigma_true &lt;- matrix(c(1,0.5,0.2,0.5,1,0.2,0.2,0.2,2), ncol=3))
### coefficient vector
beta &lt;- matrix(c(-1,1), ncol=1)
### draw data
N &lt;- 100
X &lt;- replicate(N, matrix(rnorm(6), ncol=2), simplify = FALSE)
eps &lt;- replicate(N, rmvnorm(mu = c(0,0,0), Sigma = Sigma_true), simplify = FALSE)
U &lt;- mapply(function(X, eps) X %*% beta + eps, X, eps, SIMPLIFY = FALSE)
### prior parameters for covariance matrix
kappa &lt;- 4
E &lt;- diag(3)
### draw from posterior of coefficient vector
outer_prod &lt;- function(X, U) (U - X %*% beta) %*% t(U - X %*% beta)
S &lt;- Reduce(`+`, mapply(outer_prod, X, U, SIMPLIFY = FALSE))
Sigma_draws &lt;- replicate(100, update_Sigma(kappa, E, N, S))
apply(Sigma_draws, 1:2, mean)
apply(Sigma_draws, 1:2, stats::sd)
</code></pre>

<hr>
<h2 id='update_U'>Update latent utility vector</h2><span id='topic+update_U'></span>

<h3>Description</h3>

<p>This function updates the latent utility vector, where (independent across deciders and choice occasions)
the utility for each alternative is updated conditional on the other utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_U(U, y, sys, Sigmainv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_U_+3A_u">U</code></td>
<td>
<p>The current utility vector of length <code>J-1</code>.</p>
</td></tr>
<tr><td><code id="update_U_+3A_y">y</code></td>
<td>
<p>An integer from <code>1</code> to <code>J</code>, the index of the chosen alternative.</p>
</td></tr>
<tr><td><code id="update_U_+3A_sys">sys</code></td>
<td>
<p>A vector of length <code>J-1</code>, the systematic utility part.</p>
</td></tr>
<tr><td><code id="update_U_+3A_sigmainv">Sigmainv</code></td>
<td>
<p>The inverted error term covariance matrix of dimension <code>J-1</code> x <code>J-1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key ingredient to Gibbs sampling for probit models is considering the latent utilities
as parameters themselves which can be updated (data augmentation).
Independently for all deciders <code class="reqn">n=1,\dots,N</code> and choice occasions <code class="reqn">t=1,...,T_n</code>,
the utility vectors <code class="reqn">(U_{nt})_{n,t}</code> in the linear utility equation <code class="reqn">U_{nt} = X_{nt} \beta + \epsilon_{nt}</code>
follow a <code class="reqn">J-1</code>-dimensional truncated normal distribution, where <code class="reqn">J</code> is the number of alternatives,
<code class="reqn">X_{nt} \beta</code> the systematic (i.e. non-random) part of the utility and <code class="reqn">\epsilon_{nt} \sim N(0,\Sigma)</code> the error term.
The truncation points are determined by the choices <code class="reqn">y_{nt}</code>. To draw from a truncated multivariate
normal distribution, this function implemented the approach of Geweke (1998) to conditionally draw each component
separately from a univariate truncated normal distribution. See Oelschläger (2020) for the concrete formulas.
</p>


<h3>Value</h3>

<p>An updated utility vector of length <code>J-1</code>.
</p>


<h3>References</h3>

<p>See Geweke (1998) <em>Efficient Simulation from the Multivariate Normal and Student-t Distributions Subject
to Linear Constraints and the Evaluation of Constraint Probabilities</em> for Gibbs sampling
from a truncated multivariate normal distribution. See Oelschläger and Bauer (2020) <em>Bayes Estimation
of Latent Class Mixed Multinomial Probit Models</em> for its application to probit utilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- c(0,0,0)
y &lt;- 3
sys &lt;- c(0,0,0)
Sigmainv &lt;- solve(diag(3))
update_U(U, y, sys, Sigmainv)
</code></pre>

<hr>
<h2 id='update_U_ranked'>Update latent utility vector in the ranked probit case</h2><span id='topic+update_U_ranked'></span>

<h3>Description</h3>

<p>This function updates the latent utility vector in the ranked probit case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_U_ranked(U, sys, Sigmainv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_U_ranked_+3A_u">U</code></td>
<td>
<p>The current utility vector of length <code>J-1</code>, differenced such that
the vector is negative.</p>
</td></tr>
<tr><td><code id="update_U_ranked_+3A_sys">sys</code></td>
<td>
<p>A vector of length <code>J-1</code>, the systematic utility part.</p>
</td></tr>
<tr><td><code id="update_U_ranked_+3A_sigmainv">Sigmainv</code></td>
<td>
<p>The inverted error term covariance matrix of dimension
<code>J-1</code> x <code>J-1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This update is basically the same as in the non-ranked case, despite that
the truncation point is zero.
</p>


<h3>Value</h3>

<p>An updated utility vector of length <code>J-1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- c(0,0)
sys &lt;- c(0,0)
Sigmainv &lt;- diag(2)
update_U_ranked(U, sys, Sigmainv)
</code></pre>

<hr>
<h2 id='update_z'>Update class allocation vector</h2><span id='topic+update_z'></span>

<h3>Description</h3>

<p>This function updates the class allocation vector (independently for all observations)
by drawing from its conditional distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_z(s, beta, b, Omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_z_+3A_s">s</code></td>
<td>
<p>The vector of class weights of length <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.
For identifiability, the vector must be non-ascending.</p>
</td></tr>
<tr><td><code id="update_z_+3A_beta">beta</code></td>
<td>
<p>The matrix of the decision-maker specific coefficient vectors of dimension
<code>P_r</code> x <code>N</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_z_+3A_b">b</code></td>
<td>
<p>The matrix of class means as columns of dimension <code>P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
<tr><td><code id="update_z_+3A_omega">Omega</code></td>
<td>
<p>The matrix of class covariance matrices as columns of dimension
<code>P_r*P_r</code> x <code>C</code>.
Set to <code>NA</code> if <code>P_r = 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">z = (z_1,\dots,z_N)</code> denote the class allocation vector of the observations (mixed coefficients) <code class="reqn">\beta = (\beta_1,\dots,\beta_N)</code>.
Independently for each <code class="reqn">n</code>, the conditional probability <code class="reqn">\Pr(z_n = c \mid s,\beta_n,b,\Omega)</code> of having <code class="reqn">\beta_n</code>
allocated to class <code class="reqn">c</code> for <code class="reqn">c=1,\dots,C</code> depends on the class allocation vector <code class="reqn">s</code>, the class means <code class="reqn">b=(b_c)_c</code> and the class covariance
matrices <code class="reqn">Omega=(Omega_c)_c</code> and is proportional to </p>
<p style="text-align: center;"><code class="reqn">s_c \phi(\beta_n \mid b_c,Omega_c).</code>
</p>



<h3>Value</h3>

<p>An updated class allocation vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### class weights for C = 2 classes
s &lt;- rdirichlet(c(1,1))
### coefficient vector for N = 1 decider and P_r = 2 random coefficients
beta &lt;- matrix(c(1,1), ncol = 1)
### class means and covariances
b &lt;- cbind(c(0,0),c(1,1))
Omega &lt;- cbind(c(1,0,0,1),c(1,0,0,1))
### updated class allocation vector
update_z(s = s, beta = beta, b = b, Omega = Omega)
</code></pre>

<hr>
<h2 id='update.RprobitB_fit'>Update and re-fit probit model</h2><span id='topic+update.RprobitB_fit'></span>

<h3>Description</h3>

<p>This function estimates a nested probit model based on a given
<code>RprobitB_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RprobitB_fit'
update(
  object,
  form,
  re,
  alternatives,
  id,
  idc,
  standardize,
  impute,
  scale,
  R,
  B,
  Q,
  print_progress,
  prior,
  latent_classes,
  seed,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.RprobitB_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_form">form</code></td>
<td>
<p>A <code>formula</code> object that is used to specify the model equation.
The structure is <code>choice ~ A | B | C</code>, where
</p>

<ul>
<li> <p><code>choice</code> is the name of the dependent variable (the choices),
</p>
</li>
<li> <p><code>A</code> are names of alternative and choice situation specific
covariates with a coefficient that is constant across alternatives,
</p>
</li>
<li> <p><code>B</code> are names of choice situation specific covariates with
alternative specific coefficients,
</p>
</li>
<li><p> and <code>C</code> are names of alternative and choice situation specific
covariates with alternative specific coefficients.
</p>
</li></ul>

<p>Multiple covariates (of one type) are separated by a <code>+</code> sign.
By default, alternative specific constants (ASCs) are added to the model.
They can be removed by adding <code>+0</code> in the second spot.
</p>
<p>In the ordered probit model (<code>ordered = TRUE</code>), the <code>formula</code>
object has the simple structure <code>choice ~ A</code>. ASCs are not estimated.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_re">re</code></td>
<td>
<p>A character (vector) of covariates of <code>form</code> with random effects.
If <code>re = NULL</code> (the default), there are no random effects.
To have random effects for the ASCs, include <code>"ASC"</code> in <code>re</code>.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_alternatives">alternatives</code></td>
<td>
<p>A character vector with the names of the choice alternatives.
If not specified, the choice set is defined by the observed choices.
If <code>ordered = TRUE</code>, <code>alternatives</code> is assumed to be specified with
the alternatives ordered from worst to best.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_id">id</code></td>
<td>
<p>A character, the name of the column in <code>choice_data</code> that contains
unique identifier for each decision maker. The default is <code>"id"</code>.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_idc">idc</code></td>
<td>
<p>A character, the name of the column in <code>choice_data</code> that contains
unique identifier for each choice situation of each decision maker.
Per default, these identifier are generated by the order of appearance.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_standardize">standardize</code></td>
<td>
<p>A character vector of names of covariates that get standardized.
Covariates of type 1 or 3 have to be addressed by
<code>&lt;covariate&gt;_&lt;alternative&gt;</code>.
If <code>standardize = "all"</code>, all covariates get standardized.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_impute">impute</code></td>
<td>
<p>A character that specifies how to handle missing covariate entries in
<code>choice_data</code>, one of:
</p>

<ul>
<li> <p><code>"complete_cases"</code>, removes all rows containing missing
covariate entries (the default),
</p>
</li>
<li> <p><code>"zero"</code>, replaces missing covariate entries by zero
(only for numeric columns),
</p>
</li>
<li> <p><code>"mean"</code>, imputes missing covariate entries by the mean
(only for numeric columns).
</p>
</li></ul>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_scale">scale</code></td>
<td>
<p>A character which determines the utility scale. It is of the form
<code style="white-space: pre;">&#8288;&lt;parameter&gt; := &lt;value&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;parameter&gt;&#8288;</code> is either the name of a fixed
effect or <code style="white-space: pre;">&#8288;Sigma_&lt;j&gt;,&lt;j&gt;&#8288;</code> for the <code style="white-space: pre;">&#8288;&lt;j&gt;&#8288;</code>th diagonal element of <code>Sigma</code>, and
<code style="white-space: pre;">&#8288;&lt;value&gt;&#8288;</code> is the value of the fixed parameter.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_r">R</code></td>
<td>
<p>The number of iterations of the Gibbs sampler.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_b">B</code></td>
<td>
<p>The length of the burn-in period, i.e. a non-negative number of samples to
be discarded.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_q">Q</code></td>
<td>
<p>The thinning factor for the Gibbs samples, i.e. only every <code>Q</code>th
sample is kept.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_print_progress">print_progress</code></td>
<td>
<p>A boolean, determining whether to print the Gibbs sampler progress and the
estimated remaining computation time.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_prior">prior</code></td>
<td>
<p>A named list of parameters for the prior distributions. See the documentation
of <code><a href="#topic+check_prior">check_prior</a></code> for details about which parameters can be
specified.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_latent_classes">latent_classes</code></td>
<td>
<p>Either <code>NULL</code> (for no latent classes) or a list of parameters specifying
the number of latent classes and their updating scheme:
</p>

<ul>
<li> <p><code>C</code>: The fixed number (greater or equal 1) of latent classes,
which is set to 1 per default. If either <code>weight_update = TRUE</code>
or <code>dp_update = TRUE</code> (i.e. if classes are updated), <code>C</code>
equals the initial number of latent classes.
</p>
</li>
<li> <p><code>weight_update</code>: A boolean, set to <code>TRUE</code> to weight-based
update the latent classes. See ... for details.
</p>
</li>
<li> <p><code>dp_update</code>: A boolean, set to <code>TRUE</code> to update the latent
classes based on a Dirichlet process. See ... for details.
</p>
</li>
<li> <p><code>Cmax</code>: The maximum number of latent classes.
</p>
</li>
<li> <p><code>buffer</code>: The number of iterations to wait before a next
weight-based update of the latent classes.
</p>
</li>
<li> <p><code>epsmin</code>: The threshold weight (between 0 and 1) for removing
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>epsmax</code>: The threshold weight (between 0 and 1) for splitting
a latent class in the weight-based updating scheme.
</p>
</li>
<li> <p><code>distmin</code>: The (non-negative) threshold in class mean difference
for joining two latent classes in the weight-based updating scheme.
</p>
</li></ul>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_seed">seed</code></td>
<td>
<p>Set a seed for the Gibbs sampling.</p>
</td></tr>
<tr><td><code id="update.RprobitB_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters (except for <code>object</code>) are optional and if not specified
retrieved from the specification for <code>object</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>RprobitB_fit</code>.
</p>

<hr>
<h2 id='WAIC'>Compute WAIC value</h2><span id='topic+WAIC'></span>

<h3>Description</h3>

<p>This function computes the WAIC value of an <code>RprobitB_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAIC(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WAIC_+3A_x">x</code></td>
<td>
<p>An object of class <code>RprobitB_fit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WAIC is short for Widely Applicable (or Watanabe-Akaike) Information
Criterion. As for AIC and BIC, the smaller the WAIC value the better the
model. Its definition is
</p>
<p style="text-align: center;"><code class="reqn">WAIC = -2 \cdot lppd + 2 \cdot  p_{WAIC},</code>
</p>

<p>where <code class="reqn">lppd</code> stands for log pointwise predictive density and
<code class="reqn">p_{WAIC}</code> is a penalty term proportional to the variance in the
posterior distribution that is sometimes called effective number of
parameters.
The <code class="reqn">lppd</code> is approximated as follows. Let
</p>
<p style="text-align: center;"><code class="reqn">p_{is} = \Pr(y_i\mid \theta_s)</code>
</p>
<p> be the probability of observation
<code class="reqn">y_i</code> given the <code class="reqn">s</code>th set <code class="reqn">\theta_s</code> of parameter samples from
the posterior. Then
</p>
<p style="text-align: center;"><code class="reqn">lppd = \sum_i \log S^{-1} \sum_s p_{si}.</code>
</p>

<p>The penalty term is computed as the sum over the variances in log-probability
for each observation:
</p>
<p style="text-align: center;"><code class="reqn">p_{WAIC} = \sum_i V_{\theta} \left[ \log p_{si} \right].</code>
</p>



<h3>Value</h3>

<p>A numeric, the WAIC value, with the following attributes:
</p>

<ul>
<li> <p><code>se_waic</code>, the standard error of the WAIC value,
</p>
</li>
<li> <p><code>lppd</code>, the log pointwise predictive density,
</p>
</li>
<li> <p><code>p_waic</code>, the effective number of parameters,
</p>
</li>
<li> <p><code>p_waic_vec</code>, the vector of summands of <code>p_waic</code>,
</p>
</li>
<li> <p><code>p_si</code>, the output of <code><a href="#topic+compute_p_si">compute_p_si</a></code>.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
