<!DOCTYPE html><html><head><title>Help for package repeated</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {repeated}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binnest'><p>Binary Random Effects Models with Two Levels of Nesting</p></a></li>
<li><a href='#biv.betab'><p>Bivariate Beta-binomial Regression Models</p></a></li>
<li><a href='#biv.binom'><p>Marginal Bivariate Binomial Regression Models</p></a></li>
<li><a href='#capture'><p>Capture-recapture Models</p></a></li>
<li><a href='#catmiss'><p>Marginal Probabilities for Categorical Repeated Measurements with Missing</p>
Data</a></li>
<li><a href='#chidden'><p>Continuous-time Hidden Markov Chain Models</p></a></li>
<li><a href='#cphidden'><p>Changepoint Location using a Continuous-time Two-state Hidden Markov Chain</p></a></li>
<li><a href='#gar'><p>Generalized Autoregression Models</p></a></li>
<li><a href='#gausscop'><p>Multivariate Gaussian Copula with Arbitrary Marginals</p></a></li>
<li><a href='#glmm'><p>Generalized Linear Mixed Models</p></a></li>
<li><a href='#gnlmix'><p>Generalized Nonlinear Regression with a Random Parameter</p></a></li>
<li><a href='#gnlmm'><p>Generalized Nonlinear Mixed Models</p></a></li>
<li><a href='#gnlmm3'><p>Generalized Nonlinear Mixed Models for Three-parameter Distributions</p></a></li>
<li><a href='#hidden'><p>Discrete-time Hidden Markov Chain Models</p></a></li>
<li><a href='#hnlmix'><p>Generalized Nonlinear Regression using h-likelihood for a Random Parameter</p></a></li>
<li><a href='#kalcount'><p>Repeated Measurements Models for Counts with Frailty or Serial Dependence</p></a></li>
<li><a href='#kalseries'><p>Repeated Measurements Models for Continuous Variables with Frailty or</p>
Serial Dependence</a></li>
<li><a href='#marg.hom'><p>Marginal Homogeneity Models</p></a></li>
<li><a href='#nbkal'><p>Negative Binomial Models with Kalman Update</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.8</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Normal Repeated Measurements Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.4), rmutil</td>
</tr>
<tr>
<td>Description:</td>
<td>Various functions to fit models for non-normal repeated
    measurements, such as Binary Random Effects Models with Two Levels of Nesting,
    Bivariate Beta-binomial Regression Models, Marginal Bivariate Binomial Regression Models,
    Cormack capture-recapture models, Continuous-time Hidden Markov Chain Models, 
    Discrete-time Hidden Markov Chain Models,
    Changepoint Location Models using a Continuous-time Two-state Hidden Markov Chain,
    generalized nonlinear autoregression models, multivariate Gaussian copula models,
    generalized non-linear mixed models with one random effect,  
    generalized non-linear mixed models using h-likelihood for one random effect, 
    Repeated Measurements Models for Counts with Frailty or Serial Dependence,
    Repeated Measurements Models for Continuous Variables with Frailty or Serial Dependence,
    Ordinal Random Effects Models with Dropouts, marginal homogeneity models for square
    contingency tables, correlated negative binomial models with Kalman update.
    References include Lindsey's text books, 
    JK Lindsey (2001) &lt;isbn:10-0198508123&gt; and JK Lindsey (1999) &lt;isbn:10-0198505590&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.commanster.eu/rcode.html">https://www.commanster.eu/rcode.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swihart/repeated/issues">https://github.com/swihart/repeated/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-14 01:40:03 UTC; bruce</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruce Swihart [cre, aut],
  Jim Lindsey [aut] (Jim created this package, Bruce is maintaining the
    CRAN version),
  T.R. Ten Have [ctb, cph] (Wrote Logit_bin_nest.f90 (in binnest.f).),
  Richard Cook [ctb, cph] (Wrote calcs.c, calcs.h, calcs1.c, calcs1.h,
    calcs2.c, calcs2.h, calcs3.c, calcs3.h, calcs4.c, calcs4.h; defs.h;
    gaps.c, gaps.h.),
  Iain MacDonald [ctb, cph] (Wrote chidden.f, cphidden.f, hidden.f.),
  Walter Zucchini [ctb, cph] (Wrote chidden.f, cphidden.f, hidden.f.),
  Burton Garbow [ctb, cph] (Wrote eigen.f.),
  Euginia Zharichenko [ctb, cph] (Wrote logitord.f.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bruce Swihart &lt;bruce.swihart@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-14 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binnest'>Binary Random Effects Models with Two Levels of Nesting</h2><span id='topic+binnest'></span>

<h3>Description</h3>

<p><code>binnest</code> is designed to handle binary and binomial data with two
levels of nesting. The first level is the individual and the second will
consist of clusters within individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binnest(
  response,
  totals = NULL,
  nest = NULL,
  ccov = NULL,
  tvcov = NULL,
  mu = ~1,
  re1 = ~1,
  re2 = ~1,
  preg = NULL,
  pre1 = NULL,
  pre2 = NULL,
  binom.mix = c(10, 10),
  binom.prob = c(0.5, 0.5),
  fcalls = 900,
  eps = 0.01,
  print.level = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binnest_+3A_response">response</code></td>
<td>
<p>A list of three column matrices with counts, corresponding
totals (not necessary if the response is binary), and (second-level)
nesting indicator for each individual, one matrix or dataframe of such
counts, or an object of class, response (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or repeated (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code>).</p>
</td></tr>
<tr><td><code id="binnest_+3A_totals">totals</code></td>
<td>
<p>If <code>response</code> is a matrix or dataframe, a corresponding
matrix or dataframe of totals (not necessary if the response is binary).
Ignored otherwise.</p>
</td></tr>
<tr><td><code id="binnest_+3A_nest">nest</code></td>
<td>
<p>If <code>response</code> is a matrix or dataframe, a corresponding
matrix or dataframe of nesting indicators. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="binnest_+3A_ccov">ccov</code></td>
<td>
<p>If <code>response</code> is a matrix, dataframe, list, or object of
class, <code>response</code>, a matrix of time-constant covariates or an object
of class, <code>tccov</code> (created by <code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>). All of
these covariates are used in the fixed effects part of the model. Ignored
if response has class, <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="binnest_+3A_tvcov">tvcov</code></td>
<td>
<p>If <code>response</code> is a matrix, dataframe, list, or object of
class, <code>response</code>, an object of class, <code>tvcov</code> (created by
<code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>). All of these covariates are used in the
fixed effects part of the model. Ignored if response has class,
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="binnest_+3A_mu">mu</code></td>
<td>
<p>If <code>response</code> has class, <code>repeated</code>, a formula
beginning with ~, specifying a linear regression function for the fixed
effects, in the Wilkinson and Rogers notation, containing selected
covariates in the response object. (A logit link is assumed.)</p>
</td></tr>
<tr><td><code id="binnest_+3A_re1">re1</code></td>
<td>
<p>If <code>response</code> has class, <code>repeated</code>, a formula
beginning with ~, specifying a linear regression function for the variance
of the first level of nesting, in the Wilkinson and Rogers notation,
containing selected covariates in the response object. If NULL, a random
effect is not fitted at this level. (A log link is assumed.)</p>
</td></tr>
<tr><td><code id="binnest_+3A_re2">re2</code></td>
<td>
<p>If <code>response</code> has class, <code>repeated</code>, a formula
beginning with ~, specifying a linear regression function for the variance
of the second level of nesting, in the Wilkinson and Rogers notation,
containing selected covariates in the response object. If NULL, a random
effect is not fitted at this level. (A log link is assumed.)</p>
</td></tr>
<tr><td><code id="binnest_+3A_preg">preg</code></td>
<td>
<p>Initial parameter estimates for the fixed effect regression
model: either the model specified by <code>mu</code> or else the intercept plus
one for each covariate in <code>ccov</code> and <code>tvcov</code>.</p>
</td></tr>
<tr><td><code id="binnest_+3A_pre1">pre1</code></td>
<td>
<p>Initial parameter estimates for the first level of nesting
variance model: either the model specified by <code>re1</code> or just the
intercept. If NULL, a random effect is not fitted at this level.</p>
</td></tr>
<tr><td><code id="binnest_+3A_pre2">pre2</code></td>
<td>
<p>Initial parameter estimates for the second level of nesting
variance model: either the model specified by <code>re1</code> or just the
intercept. If NULL, a random effect is not fitted at this level.</p>
</td></tr>
<tr><td><code id="binnest_+3A_binom.mix">binom.mix</code></td>
<td>
<p>A vector of two values giving the totals for the binomial
distributions used as the mixing distributions at the two levels of
nesting.</p>
</td></tr>
<tr><td><code id="binnest_+3A_binom.prob">binom.prob</code></td>
<td>
<p>A vector of two values giving the probabilities in the
binomial distributions used as the mixing distributions at the two levels
of nesting. If they are 0.5, the mixing distributions approximate normal
mixing distributions; otherwise, they are skewed.</p>
</td></tr>
<tr><td><code id="binnest_+3A_fcalls">fcalls</code></td>
<td>
<p>Number of function calls allowed.</p>
</td></tr>
<tr><td><code id="binnest_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion.</p>
</td></tr>
<tr><td><code id="binnest_+3A_print.level">print.level</code></td>
<td>
<p>If 1, the iterations are printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance components at the two levels can only depend on the covariates
if <code>response</code> has class, <code>repeated</code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>binnest</code> is returned.
</p>


<h3>Author(s)</h3>

<p>T.R. Ten Have and J.K. Lindsey
</p>


<h3>References</h3>

<p>Ten Have, T.R., Kunselman, A.R., and Tran, L. (1999) Statistics
in Medicine 18, 947-960.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gar">gar</a></code>, <code><a href="rmutil.html#topic+read.list">read.list</a></code>,
<code><a href="rmutil.html#topic+restovec">restovec</a></code>, <code><a href="rmutil.html#topic+rmna">rmna</a></code>,
<code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>, <code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#y &lt;- rbind(matrix(rbinom(20,1,0.6), ncol=4),
#	matrix(rbinom(20,1,0.4), ncol=4))
y &lt;- matrix(c(1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,0,1,0,1,1,0,1,0,
              1,1,1,1,1,1,1,1,0,1,1,0),nrow=10,ncol=4,byrow=TRUE)
resp &lt;- restovec(y, nest=1:4, times=FALSE)
ccov &lt;- tcctomat(c(rep(0,5),rep(1,5)), name="treatment")
reps &lt;- rmna(resp, ccov=ccov)

# two random effects
binnest(reps, mu=~treatment, preg=c(1,1), pre1=2, pre2=2)

# first level random effect only
binnest(reps, mu=~treatment, preg=c(1,-1), pre1=1)

# second level random effect only
binnest(reps, mu=~treatment, preg=c(1,-1), pre2=1)

</code></pre>

<hr>
<h2 id='biv.betab'>Bivariate Beta-binomial Regression Models</h2><span id='topic+biv.betab'></span>

<h3>Description</h3>

<p><code>biv.betab</code> fits dependent (logit) linear regression models to a
bivariate beta-binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biv.betab(
  freq,
  x = NULL,
  p,
  depend = TRUE,
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = 10 * sqrt(p %*% p),
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biv.betab_+3A_freq">freq</code></td>
<td>
<p>A matrix containing four columns corresponding to 00, 01, 10,
and 11 responses.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_x">x</code></td>
<td>
<p>A matrix of explanatory variables, containing pairs of columns,
one for each response, and the same number of rows as freq.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_p">p</code></td>
<td>
<p>Initial parameter estimates: intercept, dependence (if depend is
TRUE, and one for each pair of columns of x.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_depend">depend</code></td>
<td>
<p>If FALSE, the independence (logistic) model is fitted.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.betab_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>bivbetab</code> is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- matrix(  c( 2, 1, 1,13,
		 4, 1, 3, 5,
		 3, 3, 1, 4,
		15, 8, 1, 6),ncol=4,byrow=TRUE)
first &lt;- c(0,0,1,1)
second &lt;- c(0,1,0,1)
self &lt;- cbind(first,second)
other &lt;- cbind(second,first)
biv.betab(y,cbind(self,other),p=c(-1,2,1,1))
# independence
biv.betab(y,cbind(self,other),p=c(-1,1,1),dep=FALSE)

</code></pre>

<hr>
<h2 id='biv.binom'>Marginal Bivariate Binomial Regression Models</h2><span id='topic+biv.binom'></span>

<h3>Description</h3>

<p><code>biv.binom</code> fits (logit) linear regression models to a marginal
bivariate binomial distribution. The covariates must be of length K, that
is the number of 2x2 tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biv.binom(
  freq,
  marg1 = ~1,
  marg2 = ~1,
  interaction = ~1,
  pmarg1 = 1,
  pmarg2 = 1,
  pinteraction = 1,
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = 10 * sqrt(p %*% p),
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biv.binom_+3A_freq">freq</code></td>
<td>
<p>A four-column matrix containing K 2x2 frequency tables.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_marg1">marg1</code></td>
<td>
<p>The model formula for the first margin.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_marg2">marg2</code></td>
<td>
<p>The model formula for the second margin.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_interaction">interaction</code></td>
<td>
<p>The model formula for the interaction.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_pmarg1">pmarg1</code></td>
<td>
<p>Initial parameter estimates for the first margin regression.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_pmarg2">pmarg2</code></td>
<td>
<p>Initial parameter estimates for the second margin regression.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_pinteraction">pinteraction</code></td>
<td>
<p>Initial parameter estimates for the interaction
regression.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="biv.binom_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>bivbinom</code> is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 5 2x2 tables
Freq &lt;- matrix(rpois(20,10),ncol=4)
x &lt;- c(6,8,10,12,14)
print(z &lt;- biv.binom(Freq,marg1=~x,marg2=~x,inter=~x,pmarg1=c(-2,0.08),
	pmarg2=c(-2,0.1),pinter=c(3,0)))

</code></pre>

<hr>
<h2 id='capture'>Capture-recapture Models</h2><span id='topic+capture'></span><span id='topic+setup'></span>

<h3>Description</h3>

<p><code>capture</code> fits the Cormack capture-recapture model to <code>n</code> sample
periods. Set <code>n</code> to the appropriate value and type <code>eval(setup)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture(z, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_+3A_z">z</code></td>
<td>
<p>A Poisson generalized linear model object.</p>
</td></tr>
<tr><td><code id="capture_+3A_n">n</code></td>
<td>
<p>The number of repeated observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n &lt;- periods</code> # number of periods
</p>
<p><code>eval(setup)</code>
</p>
<p>This produces the following variables -
</p>
<p><code>p[i]</code>: logit capture probabilities,
</p>
<p><code>pbd</code>: constant capture probability,
</p>
<p><code>d[i]</code>: death parameters,
</p>
<p><code>b[i]</code>: birth parameters,
</p>
<p><code>pw</code>: prior weights.
</p>
<p>Then set up a Poisson model for log linear models:
</p>
<p><code>z &lt;- glm(y~model, family=poisson, weights=pw)</code>
</p>
<p>and call the function, <code>capture</code>.
</p>
<p>If there is constant effort, then all estimates are correct. Otherwise,
<code>n[1]</code>, <code>p[1]</code>, <code>b[1]</code>, are correct only if there is no
birth in period 1.  <code>n[s]</code>, <code>p[s]</code>, are correct only if there is
no death in the last period.  <code>phi[s-1]</code> is correct only if effort is
constant in <code>(s-1, s)</code>.  <code>b[s-1]</code> is correct only if <code>n[s]</code>
and <code>phi[s-1]</code> both are.
</p>


<h3>Value</h3>

<p><code>capture</code> returns a matrix containing the estimates.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- c(0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,14,1,1,0,2,1,2,1,16,0,2,0,11,
	2,13,10,0)
n &lt;- 5
eval(setup)
# closed population
print(z0 &lt;- glm(y~p1+p2+p3+p4+p5, family=poisson, weights=pw))
# deaths and emigration only
print(z1 &lt;- update(z0, .~.+d1+d2+d3))
# immigration only
print(z2 &lt;- update(z1, .~.-d1-d2-d3+b2+b3+b4))
# deaths, emigration, and immigration
print(z3 &lt;- update(z2, .~.+d1+d2+d3))
# add trap dependence
print(z4 &lt;- update(z3, .~.+i2+i3))
# constant capture probability over the three middle periods
print(z5 &lt;- glm(y~p1+pbd+p5+d1+d2+d3+b2+b3+b4, family=poisson, weights=pw))
# print out estimates
capture(z5, n)

</code></pre>

<hr>
<h2 id='catmiss'>Marginal Probabilities for Categorical Repeated Measurements with Missing
Data</h2><span id='topic+catmiss'></span>

<h3>Description</h3>

<p><code>catmiss</code> calculates the marginal probabilities of repeated responses.
If there are missing values, it gives both the complete data estimates and
the estimates using all data. It is useful, for example, when a log linear
model is fitted; the resulting fitted values can be supplied to
<code>catmiss</code> to obtain the estimates of the marginal probabilities for
the model. (Note however that the standard errors do not take into account
the fitting of the model.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catmiss(response, frequency, ccov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catmiss_+3A_response">response</code></td>
<td>
<p>A matrix with one column for each of the repeated measures
and one row for each possible combination of responses, including the
missing values, indicated by NAs.</p>
</td></tr>
<tr><td><code id="catmiss_+3A_frequency">frequency</code></td>
<td>
<p>A vector containing the frequencies. Its length must be a
multiple of the number of rows of <code>response</code>. Responses are arranged
in blocks corresponding to the various possible combinations of values of
the explanatory variables.</p>
</td></tr>
<tr><td><code id="catmiss_+3A_ccov">ccov</code></td>
<td>
<p>An optional matrix containing the explanatory variables
(time-constant covariates) as columns, with one line per block of responses
in <code>frequency</code>. Thus, the number of rows of response times the number
of rows of <code>ccov</code> equals the length of <code>frequency</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the probabilities and their standard errors is
returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rpois(27,15)
r1 &lt;- gl(3,1,27)
r2 &lt;- gl(3,3,27)
r3 &lt;- gl(3,9)
# r1, r2, and r3 are factor variables with 3 indicating missing
# independence model with three binary repeated measures
# with missing values
print(z &lt;- glm(y~r1+r2+r3, family=poisson))
# obtain marginal estimates (no observations with 3 missing values)
resp &lt;- cbind(as.integer(r1), as.integer(r2), as.integer(r3))[1:26,]
resp &lt;- ifelse(resp==3, NA, resp)
catmiss(resp, y[1:26])

</code></pre>

<hr>
<h2 id='chidden'>Continuous-time Hidden Markov Chain Models</h2><span id='topic+chidden'></span>

<h3>Description</h3>

<p><code>chidden</code> fits a two or more state hidden Markov chain model with a
variety of distributions in continuous time. All series on different
individuals are assumed to start at the same time point. If the time points
are equal, discrete steps, use <code><a href="#topic+hidden">hidden</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chidden(
  response = NULL,
  totals = NULL,
  times = NULL,
  distribution = "Bernoulli",
  mu = NULL,
  cmu = NULL,
  tvmu = NULL,
  pgamma,
  pmu = NULL,
  pcmu = NULL,
  ptvmu = NULL,
  pshape = NULL,
  pfamily = NULL,
  par = NULL,
  pintercept = NULL,
  delta = NULL,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chidden_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with counts or
category indicators, times, and possibly totals (if the distribution is
binomial), for each individual, one matrix or dataframe of counts, or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here. If there is only one series, a vector of responses may be
supplied instead.
</p>
<p>Multinomial and ordinal categories must be integers numbered from 0.</p>
</td></tr>
<tr><td><code id="chidden_+3A_totals">totals</code></td>
<td>
<p>If response is a matrix, a corresponding matrix of totals if
the distribution is binomial. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_times">times</code></td>
<td>
<p>If <code>response</code> is a matrix, a vector of corresponding
times, when they are the same for all individuals. Ignored if response has
class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_distribution">distribution</code></td>
<td>
<p>Bernoulli, Poisson, multinomial, proportional odds,
continuation ratio, binomial, exponential, beta binomial, negative
binomial, normal, inverse Gauss, logistic, gamma, Weibull, Cauchy, Laplace,
Levy, Pareto, gen(eralized) gamma, gen(eralized) logistic, Hjorth, Burr,
gen(eralized) Weibull, gen(eralized) extreme value, gen(eralized) inverse
Gauss, power exponential, skew Laplace, Student t, or (time-)discretized
Poisson process. (For definitions of distributions, see the corresponding
[dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="chidden_+3A_mu">mu</code></td>
<td>
<p>A general location function with two possibilities: (1) a list of
formulae (with parameters having different names) or functions (with one
parameter vector numbering for all of them) each returning one value per
observation; or (2) a single formula or function which will be used for all
states (and all categories if multinomial) but with different parameter
values in each so that pmu must be a vector of length the number of
unknowns in the function or formula times the number of states (times the
number of categories minus one if multinomial).</p>
</td></tr>
<tr><td><code id="chidden_+3A_cmu">cmu</code></td>
<td>
<p>A time-constant location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per individual; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that pcmu must be a vector of length the number
of unknowns in the function or formula times the number of states (times
the number of categories minus one if multinomial); or (3) a function
returning an array with one row for each individual, one column for each
state of the hidden Markov chain, and, if multinomial, one layer for each
category but the last. If used, this function or formula should contain the
intercept. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="chidden_+3A_tvmu">tvmu</code></td>
<td>
<p>A time-varying location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per time point; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that ptvmu must be a vector of length the
number of unknowns in the function or formula times the number of states
(times the number of categories minus one if multinomial); or (3) a
function returning an array with one row for each time point, one column
for each state of the hidden Markov chain, and, if multinomial, one layer
for each category but the last. This function or formula is usually a
function of time; it is the same for all individuals. It only contains the
intercept if <code>cmu</code> does not. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pgamma">pgamma</code></td>
<td>
<p>A square <code>mxm</code> matrix of initial estimates of the
continuous-time hidden Markov transition matrix, where <code>m</code> is the
number of hidden states. Rows can either sum to zero or the diagonal
elements can be zero, in which case they will be replaced by minus the sum
of the other values on the rows. If the matrix contains zeroes off
diagonal, these are fixed and not estimated.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pmu">pmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>mu</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pcmu">pcmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>cmu</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_ptvmu">ptvmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>tvmu</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pshape">pshape</code></td>
<td>
<p>Initial estimate(s) of the dispersion parameter, for those
distributions having one. This can be one value or a vector with a
different value for each state.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pfamily">pfamily</code></td>
<td>
<p>Initial estimate of the family parameter, for those
distributions having one.</p>
</td></tr>
<tr><td><code id="chidden_+3A_par">par</code></td>
<td>
<p>Initial estimate of the autoregression parameter.</p>
</td></tr>
<tr><td><code id="chidden_+3A_pintercept">pintercept</code></td>
<td>
<p>For multinomial, proportional odds, and continuation
ratio models, <code>p-2</code> initial estimates for intercept contrasts from the
first intercept, where <code>p</code> is the number of categories.</p>
</td></tr>
<tr><td><code id="chidden_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default. For
example, if a response is measured to two decimals, delta=0.01. If the
response is transformed, this must be multiplied by the Jacobian. For
example, with a log transformation, <code>delta=1/response</code>. Ignored if
response has class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="chidden_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="chidden_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="chidden_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time-discretized Poisson process is a continuous-time hidden Markov
model for Poisson processes where time is then discretized and only
presence or absence of one or more events is recorded in each, perhaps
unequally-spaced, discrete interval.
</p>
<p>For quantitative responses, specifying <code>par</code> allows an &lsquo;observed&rsquo;
autoregression to be fitted as well as the hidden Markov chain.
</p>
<p>All functions and formulae for the location parameter are on the
(generalized) logit scale for the Bernoulli, binomial, and multinomial
distributions. Those for intensities of the discretized Poisson process are
on the log scale.
</p>
<p>If <code>cmu</code> and <code>tvmu</code> are used, these two mean functions are
additive so that interactions between time-constant and time-varying
variables are not possible.
</p>
<p>The algorithm will run more quickly if the most frequently occurring time
step is scaled to be equal to unity.
</p>
<p>The object returned can be plotted to give the probabilities of being in
each hidden state at each time point. See <code><a href="#topic+hidden">hidden</a></code>
for details. For distributions other than the multinomial, proportional
odds, and continuation ratio, the (recursive) predicted values can be
plotted using <code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and
<code><a href="rmutil.html#topic+iprofile">iprofile</a></code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>hidden</code> and <code>recursive</code> (unless
multinomial, proportional odds, or continuation ratio) is returned that
contains all of the relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>MacDonald, I.L. and Zucchini, W. (1997) Hidden Markov and other
Models for Discrete-valued Time Series. Chapman &amp; Hall.
</p>
<p>For time-discretized Poisson processes, see
</p>
<p>Davison, A.C. and Ramesh, N.I. (1996) Some models for discretized series of
events. JASA 91: 601-609.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# model for one randomly-generated binary series
y &lt;- c(rbinom(10,1,0.1), rbinom(10,1,0.9))
mu &lt;- function(p) array(p, c(1,2))
print(z &lt;- chidden(y, times=1:20, dist="Bernoulli",
	pgamma=matrix(c(-0.1,0.2,0.1,-0.2),ncol=2),
	cmu=mu, pcmu=c(-2,2)))
# or equivalently
print(z &lt;- chidden(y, times=1:20, dist="Bernoulli",
	pgamma=matrix(c(-0.1,0.2,0.1,-0.2),ncol=2),
	cmu=~1, pcmu=c(-2,2)))
# or
print(z &lt;- chidden(y, times=1:20, dist="Bernoulli",
	pgamma=matrix(c(-0.1,0.2,0.1,-0.2),ncol=2),
	mu=~rep(a,20), pmu=c(-2,2)))
mexp(z$gamma)
par(mfcol=c(2,2))
plot(z)
plot(iprofile(z), lty=2)
plot(mprofile(z), add=TRUE)
print(z &lt;- chidden(y, times=(1:20)*2, dist="Bernoulli",
	pgamma=matrix(c(-0.05,0.1,0.05,-0.1),ncol=2),
	cmu=~1, pcmu=c(-2,2)))
mexp(z$gamma) %*% mexp(z$gamma)
plot(z)
plot(iprofile(z), lty=2)
plot(mprofile(z), add=TRUE)

</code></pre>

<hr>
<h2 id='cphidden'>Changepoint Location using a Continuous-time Two-state Hidden Markov Chain</h2><span id='topic+cphidden'></span>

<h3>Description</h3>

<p><code>cphidden</code> fits a two-state hidden Markov chain model with a variety
of distributions in continuous time in order to locate a changepoint in the
chosen distribution. All series on different individuals are assumed to
start at the same time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cphidden(
  response = NULL,
  totals = NULL,
  times = NULL,
  distribution = "Bernoulli",
  mu = NULL,
  cmu = NULL,
  tvmu = NULL,
  pgamma,
  pmu = NULL,
  pcmu = NULL,
  ptvmu = NULL,
  pshape = NULL,
  pfamily = NULL,
  par = NULL,
  pintercept = NULL,
  delta = NULL,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cphidden_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with counts or
category indicators, times, and possibly totals (if the distribution is
binomial), for each individual, one matrix or dataframe of counts, or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here. If there is only one series, a vector of responses may be
supplied instead.
</p>
<p>Multinomial and ordinal categories must be integers numbered from 0.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_totals">totals</code></td>
<td>
<p>If response is a matrix, a corresponding matrix of totals if
the distribution is binomial. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_times">times</code></td>
<td>
<p>If <code>response</code> is a matrix, a vector of corresponding
times, when they are the same for all individuals. Ignored if response has
class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_distribution">distribution</code></td>
<td>
<p>Bernoulli, Poisson, multinomial, proportional odds,
continuation ratio, binomial, exponential, beta binomial, negative
binomial, normal, inverse Gauss, logistic, gamma, Weibull, Cauchy, Laplace,
Levy, Pareto, gen(eralized) gamma, gen(eralized) logistic, Hjorth, Burr,
gen(eralized) Weibull, gen(eralized) extreme value, gen(eralized) inverse
Gauss, power exponential, skew Laplace, or Student t. (For definitions of
distributions, see the corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="cphidden_+3A_mu">mu</code></td>
<td>
<p>A general location function with two possibilities: (1) a list of
formulae (with parameters having different names) or functions (with one
parameter vector numbering for all of them) each returning one value per
observation; or (2) a single formula or function which will be used for all
states (and all categories if multinomial) but with different parameter
values in each so that pmu must be a vector of length the number of
unknowns in the function or formula times the number of states (times the
number of categories minus one if multinomial).</p>
</td></tr>
<tr><td><code id="cphidden_+3A_cmu">cmu</code></td>
<td>
<p>A time-constant location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per individual; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that pcmu must be a vector of length the number
of unknowns in the function or formula times the number of states (times
the number of categories minus one if multinomial); or (3) a function
returning an array with one row for each individual, one column for each
state of the hidden Markov chain, and, if multinomial, one layer for each
category but the last. If used, this function or formula should contain the
intercept. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_tvmu">tvmu</code></td>
<td>
<p>A time-varying location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per time point; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that ptvmu must be a vector of length the
number of unknowns in the function or formula times the number of states
(times the number of categories minus one if multinomial); or (3) a
function returning an array with one row for each time point, one column
for each state of the hidden Markov chain, and, if multinomial, one layer
for each category but the last. This function or formula is usually a
function of time; it is the same for all individuals. It only contains the
intercept if <code>cmu</code> does not. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pgamma">pgamma</code></td>
<td>
<p>An initial estimate of the transition intensity between the
two states in the continuous-time hidden Markov chain.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pmu">pmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>mu</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pcmu">pcmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>cmu</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_ptvmu">ptvmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>tvmu</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pshape">pshape</code></td>
<td>
<p>Initial estimate(s) of the dispersion parameter, for those
distributions having one. This can be one value or a vector with a
different value for each state.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pfamily">pfamily</code></td>
<td>
<p>Initial estimate of the family parameter, for those
distributions having one.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_par">par</code></td>
<td>
<p>Initial estimate of the autoregression parameter.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_pintercept">pintercept</code></td>
<td>
<p>For multinomial, proportional odds, and continuation
ratio models, <code>p-2</code> initial estimates for intercept contrasts from the
first intercept, where <code>p</code> is the number of categories.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default. For
example, if a response is measured to two decimals, delta=0.01. If the
response is transformed, this must be multiplied by the Jacobian. For
example, with a log transformation, <code>delta=1/response</code>. Ignored if
response has class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="cphidden_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For quantitative responses, specifying <code>par</code> allows an &lsquo;observed&rsquo;
autoregression to be fitted as well as the hidden Markov chain.
</p>
<p>All functions and formulae for the location parameter are on the
(generalized) logit scale for the Bernoulli, binomial, and multinomial
distributions.
</p>
<p>If <code>cmu</code> and <code>tvmu</code> are used, these two mean functions are
additive so that interactions between time-constant and time-varying
variables are not possible.
</p>
<p>The algorithm will run more quickly if the most frequently occurring time
step is scaled to be equal to unity.
</p>
<p>The object returned can be plotted to give the probabilities of being in
each hidden state at each time point. See <code><a href="#topic+hidden">hidden</a></code>
for details. For distributions other than the multinomial, proportional
odds, and continuation ratio, the (recursive) predicted values can be
plotted using <code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and
<code><a href="rmutil.html#topic+iprofile">iprofile</a></code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>hidden</code> and <code>recursive</code> (unless
multinomial, proportional odds, or continuation ratio) is returned that
contains all of the relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# model for one randomly-generated binary series
y &lt;- c(rbinom(10,1,0.1), rbinom(10,1,0.9))
mu &lt;- function(p) array(p, c(1,2))
print(z &lt;- cphidden(y, times=1:20, dist="Bernoulli",
	pgamma=0.1,cmu=mu, pcmu=c(-2,2)))
# or equivalently
print(z &lt;- cphidden(y, times=1:20, dist="Bernoulli",
	pgamma=0.2,cmu=~1, pcmu=c(-2,2)))
# or
print(z &lt;- cphidden(y, times=1:20, dist="Bernoulli",
	pgamma=0.2,mu=~rep(a,20), pmu=c(-2,2)))
mexp(z$gamma)
par(mfcol=c(2,2))
plot(z)
plot(iprofile(z), lty=2)
print(z &lt;- cphidden(y, times=(1:20)*2, dist="Bernoulli",
	pgamma=0.1,cmu=~1, pcmu=c(-2,2)))
mexp(z$gamma) %*% mexp(z$gamma)
plot(z)
plot(iprofile(z), lty=2)

</code></pre>

<hr>
<h2 id='gar'>Generalized Autoregression Models</h2><span id='topic+gar'></span><span id='topic+volatility'></span><span id='topic+volatility.gar'></span><span id='topic+deviance.gar'></span><span id='topic+fitted.gar'></span><span id='topic+print.gar'></span><span id='topic+residuals.gar'></span>

<h3>Description</h3>

<p><code>gar</code> fits a first- or second-order generalized autoregression,
possibly with Kalman update over time (first-order only).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gar(
  response = NULL,
  distribution = "normal",
  times = NULL,
  totals = NULL,
  censor = NULL,
  delta = NULL,
  mu = NULL,
  shape = NULL,
  depend = NULL,
  shfn = FALSE,
  common = FALSE,
  preg = NULL,
  pshape = NULL,
  pdepend = NULL,
  parch = NULL,
  arch = "square",
  transform = "identity",
  link = "identity",
  autocorr = "exponential",
  order = 1,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gar_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with responses,
corresponding times, and possibly a censor indicator, for each individual,
one matrix or dataframe of responses, or an object of class,
<code>response</code> (created by <code><a href="rmutil.html#topic+restovec">restovec</a></code>) or
<code>repeated</code> (created by <code><a href="rmutil.html#topic+rmna">rmna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td></tr>
<tr><td><code id="gar_+3A_distribution">distribution</code></td>
<td>
<p>The distribution to be fitted: binomial, Poisson,
exponential, negative binomial, mult Poisson, double Poisson, Consul
generalized Poisson, beta binomial, mult binomial, double binomial, normal,
inverse Gauss, logistic, gamma, Weibull, Cauchy, Laplace, Levy, Pareto,
beta, simplex, two-sided power, gen(eralized) gamma, gen(eralized)
logistic, Hjorth, Burr, gen(eralized) Weibull, gen(eralized) extreme value,
gen(eralized) inverse Gauss, power exponential, power variance function
Poisson, skew Laplace, or Student t. (For definitions of distributions, see
the corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="gar_+3A_times">times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_totals">totals</code></td>
<td>
<p>An appropriate scalar, vector, or matrix of binomial totals
(only applicable for binomial, beta binomial, mult binomial, double
binomial). Ignored if response has class, <code>response</code> or
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_censor">censor</code></td>
<td>
<p>If response is a matrix, a matrix of the same size containing
the censor indicator: 1=uncensored, 0=right-censored, -1=left-censored.
Ignored if response has class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. If the response has been
pretransformed, this must be multiplied by the Jacobian. This
transformation cannot contain unknown parameters. For example, with a log
transformation, <code>delta=1/y</code>. (The delta values for the censored
response are ignored.) The jacobian is calculated automatically for the
transform option. Ignored if response has class, <code>response</code> or
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_mu">mu</code></td>
<td>
<p>A user-specified function of <code>pmu</code> giving the regression
equation for the location. It may also be a formula beginning with ~,
specifying either a linear regression function for the location parameter
in the Wilkinson and Rogers notation or a general function with named
unknown parameters. It must yield a value for each observation on each
individual.</p>
</td></tr>
<tr><td><code id="gar_+3A_shape">shape</code></td>
<td>
<p>An optional user-specified shape regression function; this may
depend on the location (function) through its second argument, in which
case, <code>shfn</code> must be set to TRUE. It may also be a formula beginning
with ~, specifying either a linear regression function for the shape
parameter in the Wilkinson and Rogers notation or a general function with
named unknown parameters. If it contains unknown parameters, the keyword
<code>mu</code> may be used to specify a function of the location parameter.</p>
</td></tr>
<tr><td><code id="gar_+3A_depend">depend</code></td>
<td>
<p>An optional user-specified regression function for the log
dependence parameter. It may also be a formula beginning with ~, specifying
either a linear regression function for the dependence parameter in the
Wilkinson and Rogers notation or a general function with named unknown
parameters. If used, <code>order</code> must be one.</p>
</td></tr>
<tr><td><code id="gar_+3A_shfn">shfn</code></td>
<td>
<p>If TRUE, the supplied shape function depends on the location
function. The name of this location function must be the last argument of
the shape function.</p>
</td></tr>
<tr><td><code id="gar_+3A_common">common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>shape</code> must both be either
functions with, as argument, a vector of parameters having some or all
elements in common between them so that indexing is in common between them
or formulae with unknowns. All parameter estimates must be supplied in
<code>preg</code>. If FALSE, parameters are distinct between the two functions
and indexing starts at one in each function.</p>
</td></tr>
<tr><td><code id="gar_+3A_preg">preg</code></td>
<td>
<p>The initial parameter estimates for the location regression
function. If <code>mu</code> is a formula with unknown parameters, their
estimates must be supplied either in their order of appearance in the
expression or in a named list.</p>
</td></tr>
<tr><td><code id="gar_+3A_pshape">pshape</code></td>
<td>
<p>Zero to two estimates for the shape parameters, depending on
the distribution, if <code>shape</code> is not a function; otherwise, estimates
for the parameters in this function, with one extra at the end for
three-parameter distributions. If <code>shape</code> is a formula with unknown
parameters, their estimates must be supplied either in their order of
appearance in the expression or in a named list (only for two-parameter
distributions).</p>
</td></tr>
<tr><td><code id="gar_+3A_pdepend">pdepend</code></td>
<td>
<p>One or two estimates of the dependence parameters for the
Kalman update. With one, it is Markovian and, with two, it is
nonstationary. For the latter, the <code>order</code> must be one. If
<code>depend</code> is a function or formula, the corresponding number of
estimates must be supplied. Either pdepend or parch or both must be
supplied.</p>
</td></tr>
<tr><td><code id="gar_+3A_parch">parch</code></td>
<td>
<p>Estimate for an ARCH model where the shape parameter depends
on the square of the previous residual. Either pdepend or parch or both
must be supplied.</p>
</td></tr>
<tr><td><code id="gar_+3A_arch">arch</code></td>
<td>
<p>If <code>square</code>, then <code>shape+parch^diff*residual^2</code>; if
<code>absolute value</code>, then <code>shape+parch^diff*|residual|</code>; if
<code>exponential</code>, then <code>shape*exp(parch*residual^2*diff)</code>, where
<code>diff</code> is the length of time since the previous observation and
<code>residual</code> is the previous residual or innovation.</p>
</td></tr>
<tr><td><code id="gar_+3A_transform">transform</code></td>
<td>
<p>Transformation of the response variable: <code>identity</code>,
<code>exp</code>, <code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_link">link</code></td>
<td>
<p>Link function for the mean: <code>identity</code>, <code>exp</code>,
<code>square</code>, <code>sqrt</code>, <code>log</code>, <code>logit</code>, <code>cloglog</code> or
<code>loglog</code> (last three only for binary/binomial-type data).</p>
</td></tr>
<tr><td><code id="gar_+3A_autocorr">autocorr</code></td>
<td>
<p>The form of the (second if two) dependence function:
<code>exponential</code> is the usual <code class="reqn">\rho^{|t_i-t_j|}</code>;
<code>gaussian</code> is <code class="reqn">\rho^{(t_i-t_j)^2}</code>;
<code>cauchy</code> is <code class="reqn">1/(1+\rho(t_i-t_j)^2)</code>;
<code>spherical</code> is
<code class="reqn">((|t_i-t_j|\rho)^3-3|t_i-t_j|\rho+2)/2</code>
for <code class="reqn">|t_i-t_j|\leq1/\rho</code> and zero otherwise;
<code>IOU</code> is the integrated Ornstein-Uhlenbeck process, <code class="reqn">(2\rho
\min(t_i,t_j)+\exp(-\rho t_i) </code><code class="reqn">+\exp(-\rho t_j)-1
-\exp(\rho|ti-t_j|))/2\rho^3</code>.</p>
</td></tr>
<tr><td><code id="gar_+3A_order">order</code></td>
<td>
<p>First- or second-order stationary autoregression.</p>
</td></tr>
<tr><td><code id="gar_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="gar_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gar_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>Marginal and individual profiles can be plotted using
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and <code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and
residuals with <code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>
<p>When the dispersion parameter is not constant over time, <code>volatility</code>
extracts the square root of the dispersion parameter for a fitted model.
</p>


<h3>Value</h3>

<p>A list of classes <code>gar</code> and <code>recursive</code> is returned that
contains all of the relevant information calculated, including error codes.
</p>
<p>The volatility vector for models with a shape regression function and ARCH
models contains the square root of the dispersion parameter at each time
point.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>Lindsey, J.K. (1997) Applying Generalized Linear Models.
Springer, pp.\ 93&ndash;101
</p>
<p>Lambert, P. (1996) Statistics in Medicine 15, 1695-1708
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first-order one-compartment model
# data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
                                    (exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
# response
conc &lt;- matrix(rgamma(40,shape(log(c(0.1,0.4))),
                      scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
                                                   ncol=20,byrow=TRUE)[,1:19])
conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01),name="conc")
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
# constant shape parameter
gar(conc, dist="gamma", times=1:20, mu=mu,
    preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=1)
## Not run: # or
gar(conc, dist="gamma", times=1:20, mu=~exp(absorption-volume)*
      dose/(exp(absorption)-exp(elimination))*
      (exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
    preg=list(absorption=1,elimination=log(0.4),volume=log(0.1)),
    pdepend=0.5, pshape=1, envir=reps)
# generalized gamma distribution
gar(conc, dist="gen gamma", times=1:20, mu=mu,
    preg=log(c(1,0.4,0.1)), pdepend=0.3, pshape=c(.1,1))
# (if the covariates contained NAs, reps would have to be used as
# response instead of conc)
#
# time dependent shape parameter
gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape,
    preg=log(c(1,0.4,0.1)), pdepend=0.25, pshape=c(exp(-2),exp(-.57)))
# or
gar(conc, dist="gamma", times=1:20, mu=~exp(absorption-volume)*
      dose/(exp(absorption)-exp(elimination))*
      (exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
    shape=~exp(b1-b2)*times*dose*exp(-exp(b1)*times),
    preg=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
    pdepend=0.3, pshape=list(b1=exp(-2),b2=exp(-.57)), envir=reps)
# generalized gamma distribution
gar(conc, dist="gen gamma", times=1:20, mu=mu, shape=shape,
    preg=log(c(1,0.4,0.1)), pdepend=0.5,
    pshape=c(exp(-2),exp(-.57),2))
#
# shape function depends on location parameter
shape &lt;- function(p, mu) p[1]+p[2]*mu
gar(conc, dist="gamma", times=1:20, mu=mu, shape=shape, shfn=TRUE,
    preg=log(c(1,0.4,.10)), pdepend=0.15, pshape=c(1,2))
# or
gar(conc, dist="gamma", times=1:20, mu=mu, shape=~a+d*mu, shfn=TRUE,
    preg=log(c(1,0.4,.10)), pdepend=0.15, pshape=c(1,2))


## End(Not run)    
</code></pre>

<hr>
<h2 id='gausscop'>Multivariate Gaussian Copula with Arbitrary Marginals</h2><span id='topic+gausscop'></span><span id='topic+fitted.gausscop'></span><span id='topic+residuals.gausscop'></span><span id='topic+deviance.gausscop'></span><span id='topic+print.gausscop'></span>

<h3>Description</h3>

<p><code>gausscop</code> fits multivariate repeated measurements models based on the
Gaussian copula with a choice of marginal distributions. Dependence among
responses is provided by the correlation matrix containing random effects
and/or autoregression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gausscop(
  response = NULL,
  distribution = "gamma",
  mu = NULL,
  shape = NULL,
  autocorr = "exponential",
  pmu = NULL,
  pshape = NULL,
  par = NULL,
  pre = NULL,
  delta = NULL,
  shfn = FALSE,
  common = FALSE,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1,
  stepmax = 10 * sqrt(theta %*% theta),
  typsize = abs(c(theta))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gausscop_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with response
values, times, and possibly nesting categories, for each individual, one
matrix or dataframe of response values, or an object of class,
<code>response</code> (created by <code><a href="rmutil.html#topic+restovec">restovec</a></code>) or
<code>repeated</code> (created by <code><a href="rmutil.html#topic+rmna">rmna</a></code> or
<code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the <code>repeated</code> data object contains
more than one response variable, give that object in <code>envir</code> and give
the name of the response variable to be used here.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_distribution">distribution</code></td>
<td>
<p>The marginal distribution: exponential, gamma, Weibull,
Pareto, inverse Gauss, logistic, Cauchy, Laplace, or Levy.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_mu">mu</code></td>
<td>
<p>The linear or nonlinear regression model to be fitted for the
location parameter. For marginal distributions requiring positive response
values, a log link is used. This model can be a function of the parameters
or a formula beginning with ~, specifying either a linear regression
function for the location parameter in the Wilkinson and Rogers notation or
a general function with named unknown parameters that describes the
location, returning a vector the same length as the number of observations.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_shape">shape</code></td>
<td>
<p>The linear or nonlinear regression model to be fitted for the
log shape parameter. This can be a function of the parameters or a formula
beginning with ~, specifying either a linear regression function for the
location parameter in the Wilkinson and Rogers notation or a general
function with named unknown parameters that describes the location. If it
contains unknown parameters, the keyword <code>mu</code> may be used to specify a
function of the location parameter.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_autocorr">autocorr</code></td>
<td>
<p>The form of the autocorrelation function:
<code>exponential</code> is the usual <code class="reqn">\rho^{|t_i-t_j|}</code>;
<code>gaussian</code> is <code class="reqn">\rho^{(t_i-t_j)^2}</code>;
<code>cauchy</code> is <code class="reqn">1/(1+\rho(t_i-t_j)^2)</code>;
<code>spherical</code> is
<code class="reqn">((|t_i-t_j|\rho)^3-3|t_i-t_j|\rho+2)/2</code>
for <code class="reqn">|t_i-t_j|\leq1/\rho</code> and zero otherwise.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_pmu">pmu</code></td>
<td>
<p>Initial parameter estimates for the location regression model.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_pshape">pshape</code></td>
<td>
<p>Initial parameter estimate for the shape regression model.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_par">par</code></td>
<td>
<p>If supplied, an initial estimate for the autocorrelation
parameter.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_pre">pre</code></td>
<td>
<p>Zero, one or two parameter estimates for the variance
components, depending on the number of levels of nesting.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, <code>delta=0.01</code>. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_shfn">shfn</code></td>
<td>
<p>If TRUE, the supplied shape function depends on the location
function. The name of this location function must be the last argument of
the shape function.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_common">common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>shape</code> must both be functions
with, as argument, a vector of parameters having some or all elements in
common between them so that indexing is in common between them; all
parameter estimates must be supplied in <code>pmu</code>. If FALSE, parameters
are distinct between the two functions and indexing starts at one in each
function.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gausscop_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With two levels of nesting, the first is the individual and the second will
consist of clusters within individuals.
</p>
<p>For clustered (non-longitudinal) data, where only random effects will be
fitted, <code>times</code> are not necessary.
</p>
<p>This function is designed to fit linear and nonlinear models with
time-varying covariates observed at arbitrary time points. A
continuous-time AR(1) and zero, one, or two levels of nesting can be
handled.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>


<h3>Value</h3>

<p>A list of class <code>gausscop</code> is returned that contains all of
the relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>References</h3>

<p>Song, P.X.K. (2000) Multivariate dispersion models generated
from Gaussian copula. Scandinavian Journal of Statistics 27, 305-320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# linear models
y &lt;- matrix(rgamma(40,1,1),ncol=5)+rep(rgamma(8,0.5,1),5)
x1 &lt;- c(rep(0,4),rep(1,4))
reps &lt;- rmna(restovec(y),ccov=tcctomat(x1))
# independence with default gamma marginals
# compare with gnlm::gnlr(y, pmu=1, psh=0, dist="gamma", env=reps)
gausscop(y, pmu=1, pshape=0, env=reps)
gausscop(y, mu=~x1, pmu=c(1,0), pshape=0, env=reps)
# AR(1)
gausscop(y, pmu=1, pshape=0, par=0.1, env=reps)
## Not run: 
# random effect
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps)
# try other marginal distributions
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="Weibull")
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="inverse Gauss",
	stepmax=1)
gausscop(y, pmu=1, pshape=0, pre=0.1, env=reps, dist="Cauchy")
#
# first-order one-compartment model
# create data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
lmu &lt;- function(p) p[1]-p[3]+log(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
lshape &lt;- function(p) p[1]-p[2]+log(times*dose)-exp(p[1])*times
# response
#conc &lt;- matrix(rgamma(40,shape(log(c(0.1,0.4))),
#	scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
#conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
#	ncol=20,byrow=TRUE)[,1:19])
#conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01),name="conc")
conc &lt;- matrix(c(3.65586845,0.01000000,0.01000000,0.01731192,1.68707608,
	0.01000000,4.67338974,4.79679942,1.86429851,1.82886732,1.54708795,
	0.57592054,0.08014232,0.09436425,0.26106139,0.11125534,0.22685364,
	0.22896015,0.04886441,0.01000000,33.59011263,16.89115866,19.99638316,
	16.94021361,9.95440037,7.10473948,2.97769676,1.53785279,2.13059515,
	0.72562344,1.27832563,1.33917155,0.99811111,0.23437424,0.42751355,
	0.65702300,0.41126684,0.15406463,0.03092312,0.14672610),
	ncol=20,byrow=TRUE)
conc &lt;- restovec(conc)
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
# constant shape parameter
gausscop(conc, mu=lmu, pmu=log(c(1,0.4,0.1)), par=0.5, pshape=0, envir=reps)
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=0, envir=reps)
# compare to gar autoregression
gar(conc, dist="gamma", times=1:20, mu=mu,
	preg=log(c(1,0.4,0.1)), pdepend=0.5, pshape=1)
#
# time dependent shape parameter
gausscop(conc, mu=lmu, shape=lshape,
	pmu=log(c(1,0.4,0.1)), par=0.5, pshape=c(-0.1,-0.1))
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	shape=~b1-b2+log(times*dose)-exp(b1)*times,
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=list(b1=-0.1,b2=-0.1), envir=reps)
#
# shape depends on location
lshape &lt;- function(p, mu) p[1]*log(abs(mu))
gausscop(conc, mu=lmu, shape=lshape, shfn=TRUE, pmu=log(c(1,0.4,0.1)),
	par=0.5, pshape=1)
# or
gausscop(conc, mu=~absorption-volume+
	log(dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times))),
	shape=~d*log(abs(mu)), shfn=TRUE,
	pmu=list(absorption=0,elimination=log(0.4),volume=log(0.1)),
	par=0.5, pshape=list(d=1), envir=reps)

## End(Not run)
</code></pre>

<hr>
<h2 id='glmm'>Generalized Linear Mixed Models</h2><span id='topic+glmm'></span>

<h3>Description</h3>

<p><code>glmm</code> fits a generalized linear mixed model with a random intercept
using a normal mixing distribution computed by Gauss-Hermite integration.
For the normal, gamma, and inverse Gaussian distributions, the deviances
supplied are -2 log likelihood, not the usual <code><a href="stats.html#topic+glm">glm</a></code> deviance;
the degrees of freedom take into account estimation of the dispersion
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmm(
  formula,
  family = gaussian,
  data = list(),
  weights = NULL,
  offset = NULL,
  nest,
  delta = 1,
  maxiter = 20,
  points = 10,
  print.level = 0,
  control = glm.control(epsilon = 1e-04, maxit = 10, trace = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmm_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted. If it
contains transformations of the data, including cbind for binomial data, a
dataframe must be supplied.</p>
</td></tr>
<tr><td><code id="glmm_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to
be used in the model; see <code><a href="stats.html#topic+family">family</a></code> for details.</p>
</td></tr>
<tr><td><code id="glmm_+3A_data">data</code></td>
<td>
<p>A dataframe containing the variables in the model, that is
optional in simple cases, but required in certain situations as specified
elsewhere in this help page.</p>
</td></tr>
<tr><td><code id="glmm_+3A_weights">weights</code></td>
<td>
<p>An optional weight vector. If this is used, data must be
supplied in a data.frame.</p>
</td></tr>
<tr><td><code id="glmm_+3A_offset">offset</code></td>
<td>
<p>The known component in the linear predictor. If this is used,
data must be supplied in a data.frame. An offset cannot be specified in the
model formula.</p>
</td></tr>
<tr><td><code id="glmm_+3A_nest">nest</code></td>
<td>
<p>The variable classifying observations by the unit (cluster)
upon which they were observed.</p>
</td></tr>
<tr><td><code id="glmm_+3A_delta">delta</code></td>
<td>
<p>If the response variable has been transformed, this is the
Jacobian of that transformation, so that AICs are comparable.</p>
</td></tr>
<tr><td><code id="glmm_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations of the outer loop for
numerical integration.</p>
</td></tr>
<tr><td><code id="glmm_+3A_points">points</code></td>
<td>
<p>The number of points for Gauss-Hermite integration of the
random effect.</p>
</td></tr>
<tr><td><code id="glmm_+3A_print.level">print.level</code></td>
<td>
<p>If set equal to 2, the log probabilities are printed out
when the underflow error is given.</p>
</td></tr>
<tr><td><code id="glmm_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the fitting process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If weights and/or offset are to be used or the formula transforms some
variables, all of the data must be supplied in a dataframe. Because the
<code><a href="stats.html#topic+glm">glm</a></code> function is such a hack, if this is not done, weird error
messages will result.
</p>
<p>na.omit is not allowed.
</p>


<h3>Value</h3>

<p><code>glmm</code> returns a list of class <code>glmm</code>
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Poisson counts
nest &lt;- gl(5,4)
y &lt;- rpois(20,5+2*as.integer(nest))
# overdispersion model
glmm(y~1, family=poisson, nest=gl(20,1), points=3)
# clustered model
glmm(y~1, family=poisson, nest=nest, points=3)
#
# binomial data with model for overdispersion
df &lt;- data.frame(r=rbinom(10,10,0.5), n=rep(10,10), x=c(rep(0,5),
	rep(1,5)), nest=1:10)
glmm(cbind(r,n-r)~x, family=binomial, nest=nest, data=df)

</code></pre>

<hr>
<h2 id='gnlmix'>Generalized Nonlinear Regression with a Random Parameter</h2><span id='topic+gnlmix'></span>

<h3>Description</h3>

<p><code>gnlmix</code> fits user-specified nonlinear regression equations to one or
both parameters of the common one and two parameter distributions. One
parameter of the location regression is random with some specified mixing
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlmix(
  y = NULL,
  distribution = "normal",
  mixture = "normal",
  random = NULL,
  nest = NULL,
  mu = NULL,
  shape = NULL,
  linear = NULL,
  pmu = NULL,
  pshape = NULL,
  pmix = NULL,
  delta = 1,
  common = FALSE,
  envir = parent.frame(),
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = 10 * sqrt(p %*% p),
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1,
  eps = 1e-04,
  points = 5,
  steps = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlmix_+3A_y">y</code></td>
<td>
<p>A response vector of uncensored data, a two column matrix for
binomial data, or an object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_distribution">distribution</code></td>
<td>
<p>The distribution for the response: binomial, beta
binomial, double binomial, mult(iplicative) binomial, Poisson, negative
binomial, double Poisson, mult(iplicative) Poisson, gamma count, Consul
generalized Poisson, logarithmic series, geometric, normal, inverse Gauss,
logistic, exponential, gamma, Weibull, extreme value, Cauchy, Pareto,
Laplace, Levy, beta, simplex, or two-sided power. (For definitions of
distributions, see the corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_mixture">mixture</code></td>
<td>
<p>The mixing distribution for the random parameter: normal,
Cauchy, logistic, Laplace, inverse Gauss, gamma, inverse gamma, Weibull,
beta, simplex, or two-sided power. The first four have zero location
parameter, the next three have unit location parameter, and the last two
have location parameter set to 0.5.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_random">random</code></td>
<td>
<p>The name of the random parameter in the <code>mu</code> formula.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_nest">nest</code></td>
<td>
<p>The variable classifying observations by the unit upon which
they were observed. Ignored if <code>y</code> or <code>envir</code> has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_mu">mu</code></td>
<td>
<p>A user-specified formula containing named unknown parameters,
giving the regression equation for the location parameter. This may contain
the keyword, <code>linear</code> referring to a linear part.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_shape">shape</code></td>
<td>
<p>A user-specified formula containing named unknown parameters,
giving the regression equation for the shape parameter. This may contain
the keyword, <code>linear</code> referring to a linear part. If nothing is
supplied, this parameter is taken to be constant. This parameter is the
logarithm of the usual one.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_linear">linear</code></td>
<td>
<p>A formula beginning with ~ in W&amp;R notation, specifying the
linear part of the regression function for the location parameter or list
of two such expressions for the location and/or shape parameters.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_pmu">pmu</code></td>
<td>
<p>Vector of initial estimates for the location parameters. These
must be supplied either in their order of appearance in the formula or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_pshape">pshape</code></td>
<td>
<p>Vector of initial estimates for the shape parameters. These
must be supplied either in their order of appearance in the expression or
in a named list.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_pmix">pmix</code></td>
<td>
<p>Initial estimate for the logarithm of the dispersion parameter
of the mixing distribution.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default. For
example, if a response is measured to two decimals, <code>delta=0.01</code>. If
the response is transformed, this must be multiplied by the Jacobian. The
transformation cannot contain unknown parameters. For example, with a log
transformation, <code>delta=1/y</code>. (The delta values for the censored
response are ignored.)</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_common">common</code></td>
<td>
<p>If TRUE, the formulae with unknowns for the location and
shape have names in common. All parameter estimates must be supplied in
<code>pmu</code>.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>y</code>. If <code>y</code> has
class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_eps">eps</code></td>
<td>
<p>Precision of the Romberg integration.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_points">points</code></td>
<td>
<p>For the Romberg integration, the number of extrapolation
points so that 2*points is the order of integration, by default set to 5;
points=2 is Simpson's rule.</p>
</td></tr>
<tr><td><code id="gnlmix_+3A_steps">steps</code></td>
<td>
<p>For the Romberg integration, the maximum number of steps, by
default set to 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended that initial estimates for <code>pmu</code> and <code>pshape</code>
be obtained from <code>gnlr</code>.
</p>
<p>These nonlinear regression models must be supplied as formulae where
parameters are unknowns. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>


<h3>Value</h3>

<p>A list of class <code>gnlm</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dose &lt;- c(9,12,4,9,11,10,2,11,12,9,9,9,4,9,11,9,14,7,9,8)
#y &lt;- rgamma(20,shape=2+0.3*dose,scale=2)+rep(rnorm(4,0,4),rep(5,4))
y &lt;- c(8.674419, 11.506066, 11.386742, 27.414532, 12.135699,  4.359469,
       1.900681, 17.425948,  4.503345,  2.691792,  5.731100, 10.534971,
      11.220260,  6.968932,  4.094357, 16.393806, 14.656584,  8.786133,
      20.972267, 17.178012)
resp &lt;- restovec(matrix(y, nrow=4, byrow=TRUE), name="y")
reps &lt;- rmna(resp, tvcov=tvctomat(matrix(dose, nrow=4, byrow=TRUE), name="dose"))

# same linear normal model with random normal intercept fitted four ways
# compare with growth::elliptic(reps, model=~dose, preg=c(0,0.6), pre=4)
glmm(y~dose, nest=individuals, data=reps)
gnlmm(reps, mu=~dose, pmu=c(8.7,0.25), psh=3.5, psd=3)
gnlmix(reps, mu=~a+b*dose+rand, random="rand", pmu=c(8.7,0.25),
	pshape=3.44, pmix=2.3)
## Not run: 
# gamma model with log link and random normal intercept fitted three ways
glmm(y~dose, family=Gamma(link=log), nest=individuals, data=reps, points=8)
gnlmm(reps, distribution="gamma", mu=~exp(a+b*dose), pmu=c(2,0.03),
	psh=1, psd=0.3)
gnlmix(reps, distribution="gamma", mu=~exp(a+b*dose+rand), random="rand",
	pmu=c(2,0.04), pshape=1, pmix=-2)

# gamma model with log link and random gamma mixtures
gnlmix(reps, distribution="gamma", mixture="gamma",
	mu=~exp(a*rand+b*dose), random="rand", pmu=c(2,0.04),
	pshape=1.24, pmix=3.5)
gnlmix(reps, distribution="gamma", mixture="gamma",
	mu=~exp(a+b*dose)*rand, random="rand", pmu=c(2,0.04),
	pshape=1.24, pmix=2.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='gnlmm'>Generalized Nonlinear Mixed Models</h2><span id='topic+gnlmm'></span>

<h3>Description</h3>

<p><code>gnlmm</code> fits user-specified nonlinear regression equations to one or
both parameters of the common one and two parameter distributions. The
intercept of the location regression has a normally-distributed random
effect. This normal mixing distribution is computed by Gauss-Hermite
integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlmm(
  y = NULL,
  distribution = "normal",
  mu = NULL,
  shape = NULL,
  linear = NULL,
  nest = NULL,
  pmu = NULL,
  pshape = NULL,
  psd = NULL,
  exact = FALSE,
  wt = 1,
  delta = 1,
  shfn = FALSE,
  scale = NULL,
  points = 10,
  common = FALSE,
  envir = parent.frame(),
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = sqrt(p %*% p)/10,
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlmm_+3A_y">y</code></td>
<td>
<p>A response vector for uncensored data, a two column matrix for
binomial data or censored data, with the second column being the censoring
indicator (1: uncensored, 0: right censored, -1: left censored), or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code>) or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here. The beta, simplex, and two-sided power distributions for
proportions do not allow censoring.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_distribution">distribution</code></td>
<td>
<p>Either a character string containing the name of the
distribution or a function giving the -log likelihood and calling the
location and shape functions. Distributions are binomial, beta binomial,
double binomial, mult(iplicative) binomial, Poisson, negative binomial,
double Poisson, mult(iplicative) Poisson, gamma count, Consul generalized
Poisson, logarithmic series, geometric, normal, inverse Gauss, logistic,
exponential, gamma, Weibull, extreme value, Cauchy, Pareto, Laplace, and
Levy, beta, simplex, and two-sided power. All but the binomial-based
distributions and the beta, simplex, and two-sided power may be right
and/or left censored. (For definitions of distributions, see the
corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_mu">mu</code></td>
<td>
<p>A user-specified function of <code>pmu</code>, and possibly
<code>linear</code>, giving the regression equation for the location. This may
contain a linear part as the second argument to the function. It may also
be a formula beginning with ~, specifying a either linear regression
function for the location parameter in the Wilkinson and Rogers notation or
a general function with named unknown parameters. If it contains unknown
parameters, the keyword <code>linear</code> may be used to specify a linear part.
If nothing is supplied, the location is taken to be constant unless the
linear argument is given.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_shape">shape</code></td>
<td>
<p>A user-specified function of <code>pshape</code>, and possibly
<code>linear</code> and/or <code>mu</code>, giving the regression equation for the
dispersion or shape parameter. This may contain a linear part as the second
argument to the function and the location function as last argument (in
which case <code>shfn</code> must be set to TRUE). It may also be a formula
beginning with ~, specifying either a linear regression function for the
shape parameter in the Wilkinson and Rogers notation or a general function
with named unknown parameters. If it contains unknown parameters, the
keyword <code>linear</code> may be used to specify a linear part and the keyword
<code>mu</code> to specify a function of the location parameter. If nothing is
supplied, this parameter is taken to be constant unless the linear argument
is given. This parameter is the logarithm of the usual one.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_linear">linear</code></td>
<td>
<p>A formula beginning with ~ in W&amp;R notation, specifying the
linear part of the regression function for the location parameter or list
of two such expressions for the location and/or shape parameters.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_nest">nest</code></td>
<td>
<p>The variable classifying observations by the unit upon which
they were observed. Ignored if <code>y</code> or <code>envir</code> has class,
response.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_pmu">pmu</code></td>
<td>
<p>Vector of initial estimates for the location parameters. If
<code>mu</code> is a formula with unknown parameters, their estimates must be
supplied either in their order of appearance in the expression or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_pshape">pshape</code></td>
<td>
<p>Vector of initial estimates for the shape parameters. If
<code>shape</code> is a formula with unknown parameters, their estimates must be
supplied either in their order of appearance in the expression or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_psd">psd</code></td>
<td>
<p>Initial estimate of the standard deviation of the normal mixing
distribution.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_exact">exact</code></td>
<td>
<p>If TRUE, fits the exact likelihood function for continuous
data by integration over intervals of observation, i.e. interval censoring.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_wt">wt</code></td>
<td>
<p>Weight vector.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default.
Ignored if y has class, response. For example, if a response is measured to
two decimals, <code>delta=0.01</code>. If the response is transformed, this must
be multiplied by the Jacobian. The transformation cannot contain unknown
parameters. For example, with a log transformation, <code>delta=1/y</code>. (The
delta values for the censored response are ignored.)</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_shfn">shfn</code></td>
<td>
<p>If true, the supplied shape function depends on the location
(function). The name of this location function must be the last argument of
the shape function.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_scale">scale</code></td>
<td>
<p>The scale on which the random effect is applied:
<code>identity</code>, <code>log</code>, <code>logit</code>, <code>reciprocal</code>, or
<code>exp</code>.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_points">points</code></td>
<td>
<p>The number of points for Gauss-Hermite integration of the
random effect.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_common">common</code></td>
<td>
<p>If TRUE, <code>mu</code> and <code>shape</code> must both be either
functions with, as argument, a vector of parameters having some or all
elements in common between them so that indexing is in common between them
or formulae with unknowns. All parameter estimates must be supplied in
<code>pmu</code>. If FALSE, parameters are distinct between the two functions and
indexing starts at one in each function.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>y</code>. If <code>y</code> has
class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>scale</code> of the random effect is the link function to be applied.
For example, if it is <code>log</code>, the supplied mean function, <code>mu</code>, is
transformed as exp(log(mu)+sd), where sd is the random effect parameter.
</p>
<p>It is recommended that initial estimates for <code>pmu</code> and <code>pshape</code>
be obtained from <code>gnlr</code>.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>The printed output includes the -log likelihood (not the deviance), the
corresponding AIC, the maximum likelihood estimates, standard errors, and
correlations.
</p>


<h3>Value</h3>

<p>A list of class <code>gnlm</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data objects
sex &lt;- c(0,1,1)
sx &lt;- tcctomat(sex)
dose &lt;- matrix(rpois(30,10),nrow=3)
dd &lt;- tvctomat(dose)
# vectors for functions
dose &lt;- as.vector(t(dose))
sex &lt;- c(rep(0,10),rep(1,20))
nest &lt;- rbind(rep(1,10),rep(2,10),rep(3,10))
#y &lt;- rgamma(30,2,scale=exp(0.2+0.1*dose+0.1*sex+rep(rnorm(3),rep(10,3)))/2)
y &lt;- c(0.6490851,0.9313931,0.4765569,0.4188045,2.8339637,2.8158090,
	2.6059975,2.9958184,2.7351583,3.2884980,1.1180961,0.9443986,1.7915571,
	9.0013379,2.3969570,3.4227356,0.5045518,0.7452521,1.8712467,3.6814198,
	0.1489849,1.0327552,0.6102406,1.1536620,2.9145237,9.2847798,5.6454605,
	1.9759672,1.5798008,5.1024496)
y &lt;- restovec(matrix(y, nrow=3), nest=nest, name="y")
reps &lt;- rmna(y, ccov=sx, tvcov=dd)
#
# log linear regression with gamma distribution
mu &lt;- function(p) exp(p[1]+p[2]*sex+p[3]*dose)
## print(z &lt;- gnlm::gnlr(y, dist="gamma", mu=mu, pmu=c(1,0,0), pshape=1))
## starting values for pmu and pshape from z$coef[1:3] and z$coef[4] respectively
gnlmm(y, dist="gamma", mu=mu, nest=nest, 
      pmu=10*c(0.59072535, 0.32618702, 0.01024245),pshape=1, psd=0.1, points=3)
# or equivalently
gnlmm(y, dist="gamma", mu=~exp(b0+b1*sex+b2*dose), nest=nest,
      pmu=10*c(0.59072535, 0.32618702, 0.01024245),pshape=1, psd=0.1, points=3, envir=reps)
## Not run: 
# or with identity link
print(z &lt;- gnlm::gnlr(y, dist="gamma", mu=~sex+dose, pmu=c(0.1,0,0), pshape=1))
gnlmm(y, dist="gamma", mu=~sex+dose, nest=nest, pmu=z$coef[1:3],
	pshape=z$coef[4], psd=0.1, points=3)
# or
gnlmm(y, dist="gamma", mu=~b0+b1*sex+b2*dose, nest=nest, pmu=z$coef[1:3],
	pshape=z$coef[4], psd=0.1, points=3, envir=reps)
#
# nonlinear regression with gamma distribution
mu &lt;- function(p) p[1]+exp(p[2]+p[3]*sex+p[4]*dose)
print(z &lt;- gnlm::gnlr(y, dist="gamma", mu=mu, pmu=c(1,1,0,0), pshape=1))
gnlmm(y, dist="gamma", mu=mu, nest=nest, pmu=z$coef[1:4],
	pshape=z$coef[5], psd=0.1, points=3)
# or
mu2 &lt;- function(p, linear) p[1]+exp(linear)
gnlmm(y, dist="gamma", mu=mu2, linear=~sex+dose, nest=nest,
	pmu=z$coef[1:4], pshape=1, psd=0.1, points=3)
# or
gnlmm(y, dist="gamma", mu=~a+exp(linear), linear=~sex+dose, nest=nest,
	pmu=z$coef[1:4], pshape=1, psd=0.1, points=3)
# or
gnlmm(y, dist="gamma", mu=~b4+exp(b0+b1*sex+b2*dose), nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5], psd=0.1,
	points=3, envir=reps)
#
# include regression for the shape parameter with same mu function
shape &lt;- function(p) p[1]+p[2]*sex
print(z &lt;- gnlm::gnlr(y, dist="gamma", mu=mu, shape=shape, pmu=z$coef[1:4],
	pshape=rep(1,2)))
gnlmm(y, dist="gamma", mu=mu, shape=shape, nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5:6], psd=0.1, points=3)
# or
gnlmm(y, dist="gamma", mu=mu, shape=shape, nest=nest, pmu=z$coef[1:4],
	pshape=z$coef[5:6], psd=0.1, points=3, envir=reps)
# or
gnlmm(y, dist="gamma", mu=~b4+exp(b0+b1*sex+b2*dose), shape=~a1+a2*sex,
	nest=nest, pmu=z$coef[1:4], pshape=z$coef[5:6], psd=0.1,
	points=3, envir=reps)

## End(Not run)
</code></pre>

<hr>
<h2 id='gnlmm3'>Generalized Nonlinear Mixed Models for Three-parameter Distributions</h2><span id='topic+gnlmm3'></span>

<h3>Description</h3>

<p><code>gnlmm3</code> fits user-specified nonlinear regression equations to one or
more parameters of the common three parameter distributions. The intercept
of the location regression has a normally-distributed random effect. This
normal mixing distribution is computed by Gauss-Hermite integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlmm3(
  y = NULL,
  distribution = "normal",
  mu = NULL,
  shape = NULL,
  nest = NULL,
  family = NULL,
  linear = NULL,
  pmu = NULL,
  pshape = NULL,
  pfamily = NULL,
  psd = NULL,
  exact = FALSE,
  wt = 1,
  scale = NULL,
  points = 10,
  common = FALSE,
  delta = 1,
  envir = parent.frame(),
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = 10 * sqrt(p %*% p),
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlmm3_+3A_y">y</code></td>
<td>
<p>A response vector for uncensored data, a two column matrix for
binomial data or censored data, with the second column being the censoring
indicator (1: uncensored, 0: right censored, -1: left censored), or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code>) or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_distribution">distribution</code></td>
<td>
<p>Either a character string containing the name of the
distribution or a function giving the -log likelihood and calling the
location, shape, and family functions. Distributions are Box-Cox
transformed normal, generalized inverse Gauss, generalized logistic,
Hjorth, generalized gamma, Burr, generalized Weibull, power exponential,
Student t, generalized extreme value, power variance function Poisson, and
skew Laplace. (For definitions of distributions, see the corresponding
[dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_mu">mu</code></td>
<td>
<p>A user-specified function of <code>pmu</code>, and possibly
<code>linear</code>, giving the regression equation for the location. This may
contain a linear part as the second argument to the function. It may also
be a formula beginning with ~, specifying a either linear regression
function for the location parameter in the Wilkinson and Rogers notation or
a general function with named unknown parameters. If it contains unknown
parameters, the keyword <code>linear</code> may be used to specify a linear part.
If nothing is supplied, the location is taken to be constant unless the
linear argument is given.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_shape">shape</code></td>
<td>
<p>A user-specified function of <code>pshape</code>, and possibly
<code>linear</code> and/or <code>mu</code>, giving the regression equation for the
dispersion or shape parameter. This may contain a linear part as the second
argument to the function and the location function as last argument (in
which case <code>shfn</code> must be set to TRUE). It may also be a formula
beginning with ~, specifying either a linear regression function for the
shape parameter in the Wilkinson and Rogers notation or a general function
with named unknown parameters. If it contains unknown parameters, the
keyword <code>linear</code> may be used to specify a linear part and the keyword
<code>mu</code> to specify a function of the location parameter. If nothing is
supplied, this parameter is taken to be constant unless the linear argument
is given. This parameter is the logarithm of the usual one.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_nest">nest</code></td>
<td>
<p>The variable classifying observations by the unit upon which
they were observed. Ignored if <code>y</code> or <code>envir</code> has class,
response.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_family">family</code></td>
<td>
<p>A user-specified function of <code>pfamily</code>, and possibly
<code>linear</code>, for the regression equation of the third (family) parameter
of the distribution. This may contain a linear part that is the second
argument to the function. It may also be a formula beginning with ~,
specifying either a linear regression function for the family parameter in
the Wilkinson and Rogers notation or a general function with named unknown
parameters. If neither is supplied, this parameter is taken to be constant
unless the linear argument is given. In most cases, this parameter is the
logarithm of the usual one.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_linear">linear</code></td>
<td>
<p>A formula beginning with ~ in W&amp;R notation, specifying the
linear part of the regression function for the location parameter or list
of two such expressions for the location and/or shape parameters.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_pmu">pmu</code></td>
<td>
<p>Vector of initial estimates for the location parameters. If
<code>mu</code> is a formula with unknown parameters, their estimates must be
supplied either in their order of appearance in the expression or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_pshape">pshape</code></td>
<td>
<p>Vector of initial estimates for the shape parameters. If
<code>shape</code> is a formula with unknown parameters, their estimates must be
supplied either in their order of appearance in the expression or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_pfamily">pfamily</code></td>
<td>
<p>Vector of initial estimates for the family parameters. If
<code>family</code> is a formula with unknown parameters, their estimates must be
supplied either in their order of appearance in the expression or in a
named list.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_psd">psd</code></td>
<td>
<p>Initial estimate of the standard deviation of the normal mixing
distribution.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_exact">exact</code></td>
<td>
<p>If TRUE, fits the exact likelihood function for continuous
data by integration over intervals of observation, i.e. interval censoring.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_wt">wt</code></td>
<td>
<p>Weight vector.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_scale">scale</code></td>
<td>
<p>The scale on which the random effect is applied:
<code>identity</code>, <code>log</code>, <code>logit</code>, <code>reciprocal</code>, or
<code>exp</code>.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_points">points</code></td>
<td>
<p>The number of points for Gauss-Hermite integration of the
random effect.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_common">common</code></td>
<td>
<p>If TRUE, at least two of <code>mu</code>, <code>shape</code>, and
<code>family</code> must both be either functions with, as argument, a vector of
parameters having some or all elements in common between them so that
indexing is in common between them or formulae with unknowns. All parameter
estimates must be supplied in <code>pmu</code>. If FALSE, parameters are distinct
between the two functions and indexing starts at one in each function.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default.
Ignored if y has class, response. For example, if a response is measured to
two decimals, <code>delta=0.01</code>. If the response is transformed, this must
be multiplied by the Jacobian. The transformation cannot contain unknown
parameters. For example, with a log transformation, <code>delta=1/y</code>. (The
delta values for the censored response are ignored.)</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>y</code>. If <code>y</code> has
class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="gnlmm3_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>scale</code> of the random effect is the link function to be applied.
For example, if it is <code>log</code>, the supplied mean function, <code>mu</code>, is
transformed as exp(log(mu)+sd), where sd is the random effect parameter.
</p>
<p>It is recommended that initial estimates for <code>pmu</code>, <code>pshape</code>, and
<code>pfamily</code> be obtained from <code>gnlr3</code>.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>The printed output includes the -log likelihood (not the deviance), the
corresponding AIC, the maximum likelihood estimates, standard errors, and
correlations.
</p>


<h3>Value</h3>

<p>A list of class <code>gnlm</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data objects
sex &lt;- c(0,1,1)
sx &lt;- tcctomat(sex)
#dose &lt;- matrix(rpois(30,10),nrow=3)
dose &lt;- matrix(c(8,9,11,9,11,11,7,8,7,12,8,8,9,10,15,10,9,9,20,14,4,7,
	4,13,10,13,6,13,11,17),nrow=3)
dd &lt;- tvctomat(dose)
# vectors for functions
dose &lt;- as.vector(t(dose))
sex &lt;- c(rep(0,10),rep(1,20))
nest &lt;- rbind(rep(1,10),rep(2,10),rep(3,10))
#y &lt;- (rt(30,5)+exp(0.2+0.3*dose+0.5*sex+rep(rnorm(3),rep(10,3))))*3
y &lt;- c(62.39712552,196.94419614,2224.74940087,269.56691601,12.86079662,
	14.96743546, 47.45765042,156.51381687,508.68804438,281.11065302,
	92.32443655, 81.88000484, 40.26357733, 13.04433670, 15.58490237,
	63.62154867, 23.69677549, 53.52885894, 88.02507682, 34.04302506,
	44.28232323,116.80732423,106.72564484, 25.09749055, 12.61839145,
	-0.04060996,153.32670123, 63.25866087, 17.79852591,930.52558064)
y &lt;- restovec(matrix(y, nrow=3), nest=nest, name="y")
reps &lt;- rmna(y, ccov=sx, tvcov=dd)
#
# log linear regression with Student t distribution
mu &lt;- function(p) exp(p[1]+p[2]*sex+p[3]*dose)
## print(z &lt;- gnlm::gnlr3(y, dist="Student", mu=mu, pmu=c(0,0,0), pshape=1, pfamily=1))
## starting values for pmu and pshape from z$coef[1:3] and z$coef[4] respectively
## starting value for pfamily in z$coef[5]
gnlmm3(y, dist="Student", mu=mu, nest=nest, pmu=c(3.69,-1.19, 0.039),
       pshape=5, pfamily=0, psd=40, points=3)
# or equivalently
gnlmm3(y, dist="Student", mu=~exp(b0+b1*sex+b2*dose), nest=nest,
       pmu=c(3.69,-1.19, 0.039), pshape=5, pfamily=0, psd=40,
       points=3, envir=reps)
## Not run: 
# or with identity link
print(z &lt;- gnlm::gnlr3(y, dist="Student", mu=~sex+dose, pmu=c(0.1,0,0), pshape=1,
	pfamily=1))
gnlmm3(y, dist="Student", mu=~sex+dose, nest=nest, pmu=z$coef[1:3],
	pshape=z$coef[4], pfamily=z$coef[5], psd=50, points=3)
# or
gnlmm3(y, dist="Student", mu=~b0+b1*sex+b2*dose, nest=nest, pmu=z$coef[1:3],
	pshape=z$coef[4], pfamily=z$coef[5], psd=50, points=3, envir=reps)
#
# nonlinear regression with Student t distribution
mu &lt;- function(p) p[1]+exp(p[2]+p[3]*sex+p[4]*dose)
print(z &lt;- gnlm::gnlr3(y, dist="Student", mu=mu, pmu=c(1,1,0,0), pshape=1,
	pfamily=1))
gnlmm3(y, dist="Student", mu=mu, nest=nest, pmu=z$coef[1:4],
	pshape=z$coef[5], pfamily=z$coef[6], psd=50, points=3)
# or
mu2 &lt;- function(p, linear) p[1]+exp(linear)
gnlmm3(y, dist="Student", mu=mu2, linear=~sex+dose, nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5], pfamily=z$coef[6], psd=50,
	points=3)
# or
gnlmm3(y, dist="Student", mu=~a+exp(linear), linear=~sex+dose, nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5], pfamily=z$coef[6], psd=50,
	points=3)
# or
gnlmm3(y, dist="Student", mu=~b4+exp(b0+b1*sex+b2*dose), nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5], pfamily=z$coef[6], psd=50,
	points=3, envir=reps)
#
# include regression for the shape parameter with same mu function
shape &lt;- function(p) p[1]+p[2]*sex
print(z &lt;- gnlm::gnlr3(y, dist="Student", mu=mu, shape=shape, pmu=z$coef[1:4],
	pshape=c(z$coef[5],0), pfamily=z$coef[6]))
gnlmm3(y, dist="Student", mu=mu, shape=shape, nest=nest,
	pmu=z$coef[1:4], pshape=z$coef[5:6], pfamily=z$coef[7],
	psd=5, points=3)
# or
gnlmm3(y, dist="Student", mu=mu, shape=shape, nest=nest, pmu=z$coef[1:4],
	pshape=z$coef[5:6], pfamily=z$coef[7], psd=5, points=3,
	envir=reps)
# or
gnlmm3(y, dist="Student", mu=~b4+exp(b0+b1*sex+b2*dose), shape=~a1+a2*sex,
	nest=nest, pmu=z$coef[1:4], pshape=z$coef[5:6],
	pfamily=z$coef[7], psd=5, points=3, envir=reps)

## End(Not run)
</code></pre>

<hr>
<h2 id='hidden'>Discrete-time Hidden Markov Chain Models</h2><span id='topic+hidden'></span><span id='topic+plot.hidden'></span>

<h3>Description</h3>

<p><code>hidden</code> fits a two or more state hidden Markov chain model with a
variety of distributions. All series on different individuals are assumed
to start at the same time point. Time points are equal, discrete steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hidden(
  response = NULL,
  totals = NULL,
  distribution = "Bernoulli",
  mu = NULL,
  cmu = NULL,
  tvmu = NULL,
  pgamma,
  pmu = NULL,
  pcmu = NULL,
  ptvmu = NULL,
  pshape = NULL,
  pfamily = NULL,
  par = NULL,
  pintercept = NULL,
  delta = NULL,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hidden_+3A_response">response</code></td>
<td>
<p>A list of two or three column matrices with counts or
category indicators, times, and possibly totals (if the distribution is
binomial), for each individual, one matrix or dataframe of counts, or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here. If there is only one series, a vector of responses may be
supplied instead.
</p>
<p>Multinomial and ordinal categories must be integers numbered from 0.</p>
</td></tr>
<tr><td><code id="hidden_+3A_totals">totals</code></td>
<td>
<p>If response is a matrix, a corresponding matrix of totals if
the distribution is binomial. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="hidden_+3A_distribution">distribution</code></td>
<td>
<p>Bernoulli, Poisson, multinomial, proportional odds,
continuation ratio, binomial, exponential, beta binomial, negative
binomial, normal, inverse Gauss, logistic, gamma, Weibull, Cauchy, Laplace,
Levy, Pareto, gen(eralized) gamma, gen(eralized) logistic, Hjorth, Burr,
gen(eralized) Weibull, gen(eralized) extreme value, gen(eralized) inverse
Gauss, power exponential, skew Laplace, or Student t. (For definitions of
distributions, see the corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="hidden_+3A_mu">mu</code></td>
<td>
<p>A general location function with two possibilities: (1) a list of
formulae (with parameters having different names) or functions (with one
parameter vector numbering for all of them) each returning one value per
observation; or (2) a single formula or function which will be used for all
states (and all categories if multinomial) but with different parameter
values in each so that pmu must be a vector of length the number of
unknowns in the function or formula times the number of states (times the
number of categories minus one if multinomial).</p>
</td></tr>
<tr><td><code id="hidden_+3A_cmu">cmu</code></td>
<td>
<p>A time-constant location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per individual; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that pcmu must be a vector of length the number
of unknowns in the function or formula times the number of states (times
the number of categories minus one if multinomial); or (3) a function
returning an array with one row for each individual, one column for each
state of the hidden Markov chain, and, if multinomial, one layer for each
category but the last. If used, this function or formula should contain the
intercept. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="hidden_+3A_tvmu">tvmu</code></td>
<td>
<p>A time-varying location function with three possibilities: (1)
a list of formulae (with parameters having different names) or functions
(with one parameter vector numbering for all of them) each returning one
value per time point; (2) a single formula or function which will be used
for all states (and all categories if multinomial) but with different
parameter values in each so that ptvmu must be a vector of length the
number of unknowns in the function or formula times the number of states
(times the number of categories minus one if multinomial); or (3) a
function returning an array with one row for each time point, one column
for each state of the hidden Markov chain, and, if multinomial, one layer
for each category but the last. This function or formula is usually a
function of time; it is the same for all individuals. It only contains the
intercept if <code>cmu</code> does not. Ignored if <code>mu</code> is supplied.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pgamma">pgamma</code></td>
<td>
<p>A square <code>mxm</code> matrix of initial estimates of the hidden
Markov transition matrix, where <code>m</code> is the number of hidden states.
Rows must sum to one. If the matrix contains zeroes or ones, these are
fixed and not estimated. (Ones cannot appear on the diagonal.) If a
<code>1x1</code> matrix or a scalar value of 1 is given, the independence model
is fitted.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pmu">pmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>mu</code>.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pcmu">pcmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>cmu</code>.</p>
</td></tr>
<tr><td><code id="hidden_+3A_ptvmu">ptvmu</code></td>
<td>
<p>Initial estimates of the unknown parameters in <code>tvmu</code>.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pshape">pshape</code></td>
<td>
<p>Initial estimate(s) of the dispersion parameter, for those
distributions having one. This can be one value or a vector with a
different value for each state.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pfamily">pfamily</code></td>
<td>
<p>Initial estimate of the family parameter, for those
distributions having one.</p>
</td></tr>
<tr><td><code id="hidden_+3A_par">par</code></td>
<td>
<p>Initial estimate of the autoregression parameter.</p>
</td></tr>
<tr><td><code id="hidden_+3A_pintercept">pintercept</code></td>
<td>
<p>For multinomial, proportional odds, and continuation
ratio models, <code>p-2</code> initial estimates for intercept contrasts from the
first intercept, where <code>p</code> is the number of categories.</p>
</td></tr>
<tr><td><code id="hidden_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default. For
example, if a response is measured to two decimals, delta=0.01. If the
response is transformed, this must be multiplied by the Jacobian. For
example, with a log transformation, <code>delta=1/response</code>. Ignored if
response has class, <code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="hidden_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="hidden_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hidden_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To fit an &lsquo;observed&rsquo; Markov chain, as well, with Bernoulli or multinomial
responses, use the lagged response as a time-varying covariate. For
quantitative responses, specifying <code>par</code> allows an 'observed&quot;
autoregression to be fitted as well as the hidden Markov chain.
</p>
<p>All functions and formulae for the location parameter are on the
(generalized) logit scale for the Bernoulli, binomial, and multinomial
distributions.
</p>
<p>If <code>cmu</code> and <code>tvmu</code> are used, these two mean functions are
additive so that interactions between time-constant and time-varying
variables are not possible.
</p>
<p>The object returned can be plotted to give the probabilities of being in
each hidden state at each time point. For distributions other than the
multinomial, proportional odds, and continuation ratio, the (recursive)
predicted values can be plotted using <code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and
<code><a href="rmutil.html#topic+iprofile">iprofile</a></code>.
</p>
<p>See MacDonald, I.L. and Zucchini, W. (1997) Hidden Markov and Other Models
for Discrete-valued Time Series. Chapman and Hall.
</p>


<h3>Value</h3>

<p>A list of classes <code>hidden</code> and <code>recursive</code> (unless
multinomial, proportional odds, or continuation ratio) is returned that
contains all of the relevant information calculated, including error codes.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey and P.J. Lindsey
</p>


<h3>References</h3>

<p>MacDonald, I.L. and Zucchini, W. (1997) Hidden Markov and other
Models for Discrete-valued Time Series. Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate two random Poisson sequences with change-points
set.seed(8)
y &lt;- rbind(c(rpois(5,1), rpois(15,5)), c(rpois(15,1), rpois(5,5)))
print(z &lt;- hidden(y,dist="Poisson", cmu=~1, pcmu=c(1,5),
                  pgamma=matrix(c(0.95,0.05,0.05,0.95),ncol=2)))
# or equivalently
mu &lt;- function(p) array(rep(p[1:2],rep(2,2)), c(2,2))
print(z &lt;- hidden(y,dist="Poisson", cmu=mu, pcmu=c(1,5),
                  pgamma=matrix(c(0.95,0.05,0.05,0.95),ncol=2)))
# or
# param nind For plotting: numbers of individuals to plot.
# param state For plotting: states to plot.
print(z &lt;- hidden(y,dist="Poisson", mu=~rep(a,40), pmu=c(1,5),
                  pgamma=matrix(c(0.95,0.05,0.05,0.95),ncol=2)))
par(mfrow=c(3,2))
plot(z, nind=1:2)
plot(z, nind=1:2, smooth=TRUE)
plot(iprofile(z), lty=2)
plot(mprofile(z), add=TRUE)
plot(iprofile(z), nind=2, lty=2)
plot(mprofile(z), nind=2, add=TRUE)


</code></pre>

<hr>
<h2 id='hnlmix'>Generalized Nonlinear Regression using h-likelihood for a Random Parameter</h2><span id='topic+hnlmix'></span><span id='topic+deviance.hnlm'></span><span id='topic+residuals.hnlm'></span><span id='topic+fitted.hnlm'></span><span id='topic+print.hnlm'></span>

<h3>Description</h3>

<p><code>hnlmix</code> fits user-specified nonlinear regression equations to one or
both parameters of the common one and two parameter distributions. One
parameter of the location regression is random with some specified mixing
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hnlmix(
  y = NULL,
  distribution = "normal",
  mixture = "normal",
  random = NULL,
  nest = NULL,
  mu = NULL,
  shape = NULL,
  linear = NULL,
  pmu = NULL,
  pshape = NULL,
  pmix = NULL,
  prandom = NULL,
  delta = 1,
  common = FALSE,
  envir = parent.frame(),
  print.level = 0,
  typsize = abs(p),
  ndigit = 10,
  gradtol = 1e-05,
  stepmax = 10 * sqrt(p %*% p),
  steptol = 1e-05,
  iterlim = 100,
  fscale = 1,
  eps = 1e-04,
  points = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hnlmix_+3A_y">y</code></td>
<td>
<p>A response vector of uncensored data, a two column matrix for
binomial data or censored data, with the second column being the censoring
indicator (1: uncensored, 0: right censored, -1: left censored), or an
object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_distribution">distribution</code></td>
<td>
<p>The distribution for the response: binomial, beta
binomial, double binomial, mult(iplicative) binomial, Poisson, negative
binomial, double Poisson, mult(iplicative) Poisson, gamma count, Consul
generalized Poisson, logarithmic series, geometric, normal, inverse Gauss,
logistic, exponential, gamma, Weibull, extreme value, Cauchy, Pareto,
Laplace, Levy, beta, simplex, or two-sided power. (For definitions of
distributions, see the corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_mixture">mixture</code></td>
<td>
<p>The mixing distribution for the random parameter (whose
initial values are supplied in <code>prandom</code>): normal, logistic, inverse
Gauss, gamma, inverse gamma, Weibull, or beta. The first two have zero
location parameter, the next three have unit location parameter, and the
last one has location parameter set to 0.5.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_random">random</code></td>
<td>
<p>The name of the random parameter in the <code>mu</code> formula.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_nest">nest</code></td>
<td>
<p>The cluster variable classifying observations by the unit upon
which they were observed. Ignored if <code>y</code> or <code>envir</code> has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_mu">mu</code></td>
<td>
<p>A user-specified formula containing named unknown parameters,
giving the regression equation for the location parameter. This may contain
the keyword, <code>linear</code> referring to a linear part.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_shape">shape</code></td>
<td>
<p>A user-specified formula containing named unknown parameters,
giving the regression equation for the shape parameter. This may contain
the keyword, <code>linear</code> referring to a linear part. If nothing is
supplied, this parameter is taken to be constant. This parameter is the
logarithm of the usual one.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_linear">linear</code></td>
<td>
<p>A formula beginning with ~ in W&amp;R notation, specifying the
linear part of the regression function for the location parameter or list
of two such expressions for the location and/or shape parameters.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_pmu">pmu</code></td>
<td>
<p>Vector of initial estimates for the location parameters. These
must be supplied either in their order of appearance in the formula or in a
named list.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_pshape">pshape</code></td>
<td>
<p>Vector of initial estimates for the shape parameters. These
must be supplied either in their order of appearance in the expression or
in a named list.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_pmix">pmix</code></td>
<td>
<p>If NULL, this parameter is estimated from the variances. If a
value is given, it is taken as fixed.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_prandom">prandom</code></td>
<td>
<p>Either one estimate of the random effects or one for each
cluster (see <code>nest</code>), in which case the last value is not used. If the
location parameter of the mixing distribution is zero, the last value is
recalculated so that their sum is zero; if it is unity, they must all be
positive and the last value is recalculated so that the sum of their
logarithms is zero; if it is 0.5, they must all lie in (0,1) and the last
value is recalculated so that the sum of their logits is zero.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement (always one
for discrete data) for each response value, set to unity by default. For
example, if a response is measured to two decimals, <code>delta=0.01</code>. If
the response is transformed, this must be multiplied by the Jacobian. The
transformation cannot contain unknown parameters. For example, with a log
transformation, <code>delta=1/y</code>. (The delta values for the censored
response are ignored.)</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_common">common</code></td>
<td>
<p>If TRUE, the formulae with unknowns for the location and
shape have names in common. All parameter estimates must be supplied in
<code>pmu</code>.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>y</code>. If <code>y</code> has
class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_eps">eps</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="hnlmix_+3A_points">points</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended that initial estimates for <code>pmu</code> and <code>pshape</code>
be obtained from <code>gnlr</code>.
</p>
<p>These nonlinear regression models must be supplied as formulae where
parameters are unknowns. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>


<h3>Value</h3>

<p>A list of class <code>hnlmix</code> is returned that contains all of the
relevant information calculated, including error codes.
</p>
<p>The two variances and shrinkage estimates of the random effects are
provided.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dose &lt;- c(9,12,4,9,11,10,2,11,12,9,9,9,4,9,11,9,14,7,9,8)
#y &lt;- rgamma(20,2+0.3*dose,scale=2)+rep(rnorm(4,0,4),rep(5,4))
y &lt;- c(8.674419, 11.506066, 11.386742, 27.414532, 12.135699,  4.359469,
       1.900681, 17.425948,  4.503345,  2.691792,  5.731100, 10.534971,
      11.220260,  6.968932,  4.094357, 16.393806, 14.656584,  8.786133,
      20.972267, 17.178012)
resp &lt;- restovec(matrix(y, nrow=4, byrow=TRUE), name="y")
reps &lt;- rmna(resp, tvcov=tvctomat(matrix(dose, nrow=4, byrow=TRUE), name="dose"))

# same linear normal model with random normal intercept fitted four ways
# compare with growth::elliptic(reps, model=~dose, preg=c(0,0.6), pre=4)
glmm(y~dose, nest=individuals, data=reps)
gnlmm(reps, mu=~dose, pmu=c(8.7,0.25), psh=3.5, psd=3)
hnlmix(reps, mu=~a+b*dose+rand, random="rand", pmu=c(8.7,0.25),
	pshape=3.44, prandom=0)

# gamma model with log link and random normal intercept fitted three ways
glmm(y~dose, family=Gamma(link=log), nest=individuals, data=reps, points=8)
gnlmm(reps, distribution="gamma", mu=~exp(a+b*dose), pmu=c(2,0.03),
	psh=1, psd=0.3)
hnlmix(reps, distribution="gamma", mu=~exp(a+b*dose+rand), random="rand",
	pmu=c(2,0.04), pshape=1, prandom=0)

# gamma model with log link and random gamma mixtures
hnlmix(reps, distribution="gamma", mixture="gamma",
	mu=~exp(a*rand+b*dose), random="rand", pmu=c(2,0.04),
	pshape=1.24, prandom=1)
hnlmix(reps, distribution="gamma", mixture="gamma",
	mu=~exp(a+b*dose)*rand, random="rand", pmu=c(2,0.04),
	pshape=1.24, prandom=1)

</code></pre>

<hr>
<h2 id='kalcount'>Repeated Measurements Models for Counts with Frailty or Serial Dependence</h2><span id='topic+kalcount'></span><span id='topic+deviance.kalcount'></span><span id='topic+residuals.kalcount'></span><span id='topic+fitted.kalcount'></span><span id='topic+print.kalcount'></span>

<h3>Description</h3>

<p><code>kalcount</code> is designed to handle repeated measurements models with
time-varying covariates. The distributions have two extra parameters as
compared to the functions specified by <code>intensity</code> and are generally
longer tailed than those distributions. Dependence among observations on a
unit can be through gamma or power variance family frailties (a type of
random effect), with or without autoregression, or serial dependence over
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalcount(
  response = NULL,
  times = NULL,
  origin = 0,
  intensity = "exponential",
  depend = "independence",
  update = "Markov",
  mu = NULL,
  shape = NULL,
  density = FALSE,
  ccov = NULL,
  tvcov = NULL,
  preg = NULL,
  ptvc = NULL,
  pbirth = NULL,
  pintercept = NULL,
  pshape = NULL,
  pinitial = 1,
  pdepend = NULL,
  pfamily = NULL,
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalcount_+3A_response">response</code></td>
<td>
<p>A list of two column matrices with counts and corresponding
times for each individual, one matrix or dataframe of counts, or an object
of class, <code>response</code> (created by <code><a href="rmutil.html#topic+restovec">restovec</a></code>) or
<code>repeated</code> (created by <code><a href="rmutil.html#topic+rmna">rmna</a></code> or
<code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the <code>repeated</code> data object contains
more than one response variable, give that object in <code>envir</code> and give
the name of the response variable to be used here.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_times">times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_origin">origin</code></td>
<td>
<p>If the time origin is to be before the start of observations,
a positive constant to be added to all times.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_intensity">intensity</code></td>
<td>
<p>The form of function to be put in the Pareto distribution.
Choices are exponential, Weibull, gamma, log normal, log logistic, log
Cauchy, log Student, and gen(eralized) logistic.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_depend">depend</code></td>
<td>
<p>Type of dependence. Choices are <code>independence</code>,
<code>frailty</code>, and <code>serial</code>.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_update">update</code></td>
<td>
<p>Type of for serial dependence. Choices are <code>Markov</code>,
<code>serial</code>, <code>event</code>, <code>cumulated</code>, <code>count</code>, and
<code>kalman</code>. With <code>frailty</code> dependence, weighting by length of
observation time may be specified by setting update to <code>time</code>.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_mu">mu</code></td>
<td>
<p>A regression function for the location parameter or a formula
beginning with ~, specifying either a linear regression function in the
Wilkinson and Rogers notation (a log link is assumed) or a general function
with named unknown parameters. Give the initial estimates in <code>preg</code> if
there are no time-varying covariates and in <code>ptvc</code> if there are.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_shape">shape</code></td>
<td>
<p>A regression function for the shape parameter or a formula
beginning with ~, specifying either a linear regression function in the
Wilkinson and Rogers notation or a general function with named unknown
parameters. It must yield one value per observation.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_density">density</code></td>
<td>
<p>If TRUE, the density of the function specified in
<code>intensity</code> is used instead of the intensity.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_ccov">ccov</code></td>
<td>
<p>A vector or matrix containing time-constant baseline covariates
with one row per individual, a model formula using vectors of the same
size, or an object of class, <code>tccov</code> (created by
<code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>). If response has class, <code>repeated</code>,
the covariates must be supplied as a Wilkinson and Rogers formula unless
none are to be used or <code>mu</code> is given.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_tvcov">tvcov</code></td>
<td>
<p>A list of matrices with time-varying covariate values,
observed in the time periods in <code>response</code>, for each individual (one
column per variable), one matrix or dataframe of such covariate values, or
an object of class, <code>tvcov</code> (created by
<code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>). If response has class, <code>repeated</code>,
the covariates must be supplied as a Wilkinson and Rogers formula unless
none are to be used or <code>mu</code> is given.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_preg">preg</code></td>
<td>
<p>Initial parameter estimates for the regression model: intercept
plus one for each covariate in <code>ccov</code>. If <code>mu</code> is a formula or
function, the parameter estimates must be given here only if there are no
time-varying covariates. If <code>mu</code> is a formula with unknown parameters,
their estimates must be supplied either in their order of appearance in the
expression or in a named list.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_ptvc">ptvc</code></td>
<td>
<p>Initial parameter estimates for the coefficients of the
time-varying covariates, as many as in <code>tvcov</code>. If <code>mu</code> is a
formula or function, the parameter estimates must be given here if there
are time-varying covariates present.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pbirth">pbirth</code></td>
<td>
<p>If supplied, this is the initial estimate for the coefficient
of the birth model.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pintercept">pintercept</code></td>
<td>
<p>The initial estimate of the intercept for the generalized
logistic intensity.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pshape">pshape</code></td>
<td>
<p>An initial estimate for the shape parameter of the intensity
function (except exponential intensity). If <code>shape</code> is a function or
formula, the corresponding initial estimates. If <code>shape</code> is a formula
with unknown parameters, their estimates must be supplied either in their
order of appearance in the expression or in a named list.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pinitial">pinitial</code></td>
<td>
<p>An initial estimate for the initial parameter. With
<code>frailty</code> dependence, this is the frailty parameter.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pdepend">pdepend</code></td>
<td>
<p>An initial estimate for the serial dependence parameter. For
<code>frailty</code> dependence, if a value is given here, an autoregression is
fitted as well as the frailty.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_pfamily">pfamily</code></td>
<td>
<p>An optional initial estimate for the second parameter of a
two-parameter power variance family mixture instead of the default gamma
mixture. This yields a gamma mixture as <code>family -&gt; 0</code>, an inverse
Gauss mixture for <code>family = 0.5</code>, and a compound distribution of a
Poisson-distributed number of gamma distributions for <code>-1 &lt; family &lt;
0</code>.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalcount_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a gamma mixture of the distribution specified in
<code>intensity</code> is used, as the conditional distribution in the
<code>serial</code> dependence models, and as a symmetric multivariate (random
effect) model for <code>frailty</code> dependence.
</p>
<p>Unless specified otherwise, the time origin is taken to be zero. The given
times are the ends of the periods in which the counts occurred.
</p>
<p>Here, the variance, with exponential intensity, is a quadratic function of
the mean, whereas, for <code><a href="#topic+nbkal">nbkal</a></code>, it is proportional to
the mean function.
</p>
<p>If the counts on a unit are clustered, not longitudinal, use the failty
dependence with the default exponential intensity, yielding a multivariate
negative binomial distribution.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>Marginal and individual profiles can be plotted using
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and <code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and
residuals with <code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>kalcount</code> and <code>recursive</code> is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
treat &lt;- c(0,0,1,1)
tr &lt;- tcctomat(treat)
dose &lt;- 
  matrix(c(9,13,16,7,12,6,9,10,11,9,10,10,7,9,9,9,8,10,15,4),
         ncol=5,byrow=TRUE)
dd &lt;- tvctomat(dose)
y &lt;- restovec(structure(c(6, 4, 0, 0, 3, 6, 1, 1, 1, 5, 0, 0, 0, 4, 0, 1, 0, 
                          13, 0, 3), dim = 4:5))
reps &lt;- rmna(y, ccov=tr, tvcov=dd)
kalcount(y, intensity="log normal", dep="independence", 
        preg=0.3, pshape=0.1)
kalcount(y, intensity="log normal", dep="frailty", pinitial=0.1,
         preg=1, psh=0.1)
kalcount(y, intensity="log normal", dep="serial", pinitial=0.1,
         preg=1, pdep=0.75, psh=0.1)
# random effect and autoregression (commented out: AR difficult to estimate)
#kalcount(y, intensity="log normal", dep="frailty", pinitial=0.1,
#         pdep=0.5, preg=1, psh=0.1)
# add time-constant variable
kalcount(y, intensity="log normal", pinitial=1, psh=1,
         preg=c(0.8,0.11), ccov=treat)
# or
kalcount(y, intensity="log normal", mu=~b0+b1*treat,
         pinitial=1, psh=.1, preg=c(0.4,-0.04), envir=reps)
# add time-varying variable
kalcount(y, intensity="log normal", pinitial=1, psh=1,
         preg=c(-1,2), ccov=treat, ptvc=0, tvc=dose)
# or equivalently, from the environment
dosev &lt;- as.vector(t(dose))
kalcount(y, intensity="log normal", mu=~b0+b1*rep(treat,rep(5,4))+b2*dosev,
         pinitial=1, psh=1, ptvc=c(-1,2,0))
# or from the reps data object
kalcount(y, intensity="log normal", mu=~b0+b1*treat+b2*dose,
        pinitial=1, psh=1, ptvc=c(-1,2,0), envir=reps)
# try power variance family
kalcount(y, intensity="log normal", mu=~b0+b1*treat+b2*dose,
         pinitial=1, psh=1, ptvc=c(-1,2,0.1), envir=reps,
         pfamily=0.8)

</code></pre>

<hr>
<h2 id='kalseries'>Repeated Measurements Models for Continuous Variables with Frailty or
Serial Dependence</h2><span id='topic+kalseries'></span><span id='topic+deviance.kalseries'></span><span id='topic+residuals.kalseries'></span><span id='topic+fitted.kalseries'></span><span id='topic+print.kalseries'></span>

<h3>Description</h3>

<p><code>kalseries</code> is designed to handle repeated measurements models with
time-varying covariates. The distributions have two extra parameters as
compared to the functions specified by <code>intensity</code> and are generally
longer tailed than those distributions. Dependence among observations on a
unit can be through gamma or power variance family frailties (a type of
random effect), with or without autoregression, or one of two types of
serial dependence over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kalseries(
  response = NULL,
  times = NULL,
  intensity = "exponential",
  depend = "independence",
  mu = NULL,
  shape = NULL,
  density = FALSE,
  ccov = NULL,
  tvcov = NULL,
  torder = 0,
  interaction = NULL,
  preg = NULL,
  ptvc = NULL,
  pintercept = NULL,
  pshape = NULL,
  pinitial = 1,
  pdepend = NULL,
  pfamily = NULL,
  delta = NULL,
  transform = "identity",
  link = "identity",
  envir = parent.frame(),
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kalseries_+3A_response">response</code></td>
<td>
<p>A list of two column matrices with responses and
corresponding times for each individual, one matrix or dataframe of
response values, or an object of class, <code>response</code> (created by
<code><a href="rmutil.html#topic+restovec">restovec</a></code>) or <code>repeated</code> (created by
<code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>). If the
<code>repeated</code> data object contains more than one response variable, give
that object in <code>envir</code> and give the name of the response variable to
be used here.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_times">times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
<code>response</code> or <code>repeated</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_intensity">intensity</code></td>
<td>
<p>The form of function to be put in the Pareto distribution.
Choices are exponential, Weibull, gamma, normal, logistic, Cauchy, log
normal, log logistic, log Cauchy, log Student, inverse Gauss, and
gen(eralized) logistic. (For definitions of distributions, see the
corresponding [dpqr]distribution help.)</p>
</td></tr>
<tr><td><code id="kalseries_+3A_depend">depend</code></td>
<td>
<p>Type of dependence. Choices are <code>independence</code>,
<code>Markov</code>, <code>serial</code>, and <code>frailty</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_mu">mu</code></td>
<td>
<p>A regression function for the location parameter or a formula
beginning with ~, specifying either a linear regression function in the
Wilkinson and Rogers notation or a general function with named unknown
parameters. Give the initial estimates in <code>preg</code> if there are no
time-varying covariates and in <code>ptvc</code> if there are.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_shape">shape</code></td>
<td>
<p>A regression function for the shape parameter or a formula
beginning with ~, specifying either a linear regression function in the
Wilkinson and Rogers notation or a general function with named unknown
parameters. It must yield one value per observation.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_density">density</code></td>
<td>
<p>If TRUE, the density of the function specified in
<code>intensity</code> is used instead of the intensity.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_ccov">ccov</code></td>
<td>
<p>A vector or matrix containing time-constant baseline covariates
with one row per individual, a model formula using vectors of the same
size, or an object of class, <code>tccov</code> (created by
<code><a href="rmutil.html#topic+tcctomat">tcctomat</a></code>). If response has class, <code>repeated</code>,
the covariates must be supplied as a Wilkinson and Rogers formula unless
none are to be used or <code>mu</code> is given.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_tvcov">tvcov</code></td>
<td>
<p>A list of matrices with time-varying covariate values,
observed at the event times in <code>response</code>, for each individual (one
column per variable), one matrix or dataframe of such covariate values, or
an object of class, <code>tvcov</code> (created by
<code><a href="rmutil.html#topic+tvctomat">tvctomat</a></code>). If a time-varying covariate is observed at
arbitrary time, <code><a href="rmutil.html#topic+gettvc">gettvc</a></code> can be used to find the most
recent values for each response and create a suitable list. If response has
class, <code>repeated</code>, the covariates must be supplied as a Wilkinson and
Rogers formula unless none are to be used or <code>mu</code> is given.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_torder">torder</code></td>
<td>
<p>The order of the polynomial in time to be fitted.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_interaction">interaction</code></td>
<td>
<p>Vector of length equal to the number of time-constant
covariates, giving the levels of interactions between them and the
polynomial in time in the <code>linear model</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_preg">preg</code></td>
<td>
<p>Initial parameter estimates for the regression model:
intercept, one for each covariate in <code>ccov</code>, and <code>torder</code> plus
sum(<code>interaction</code>). If <code>mu</code> is a formula or function, the
parameter estimates must be given here only if there are no time-varying
covariates. If <code>mu</code> is a formula with unknown parameters, their
estimates must be supplied either in their order of appearance in the
expression or in a named list.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_ptvc">ptvc</code></td>
<td>
<p>Initial parameter estimates for the coefficients of the
time-varying covariates, as many as in <code>tvcov</code>. If <code>mu</code> is a
formula or function, the parameter estimates must be given here if there
are time-varying covariates present.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_pintercept">pintercept</code></td>
<td>
<p>The initial estimate of the intercept for the generalized
logistic intensity.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_pshape">pshape</code></td>
<td>
<p>An initial estimate for the shape parameter of the intensity
function (except exponential intensity). If <code>shape</code> is a function or
formula, the corresponding initial estimates. If <code>shape</code> is a formula
with unknown parameters, their estimates must be supplied either in their
order of appearance in the expression or in a named list.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_pinitial">pinitial</code></td>
<td>
<p>An initial estimate for the initial parameter. With
<code>frailty</code> dependence, this is the frailty parameter.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_pdepend">pdepend</code></td>
<td>
<p>An initial estimate for the serial dependence parameter. For
<code>frailty</code> dependence, if a value is given here, an autoregression is
fitted as well as the frailty.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_pfamily">pfamily</code></td>
<td>
<p>An optional initial estimate for the second parameter of a
two-parameter power variance family mixture instead of the default gamma
mixture. This yields a gamma mixture as <code>family -&gt; 0</code>, an inverse
Gauss mixture for <code>family = 0.5</code>, and a compound distribution of a
Poisson-distributed number of gamma distributions for <code>-1 &lt; family &lt;
0</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_delta">delta</code></td>
<td>
<p>Scalar or vector giving the unit of measurement for each
response value, set to unity by default. For example, if a response is
measured to two decimals, delta=0.01. If the response has been
pretransformed, this must be multiplied by the Jacobian. This
transformation cannot contain unknown parameters. For example, with a log
transformation, <code>delta=1/y</code>. The jacobian is calculated automatically
for the transform option. Ignored if response has class, <code>response</code> or
<code>repeated</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_transform">transform</code></td>
<td>
<p>Transformation of the response variable: <code>identity</code>,
<code>exp</code>, <code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_link">link</code></td>
<td>
<p>Link function for the mean: <code>identity</code>, <code>exp</code>,
<code>square</code>, <code>sqrt</code>, or <code>log</code>.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_envir">envir</code></td>
<td>
<p>Environment in which model formulae are to be interpreted or a
data object of class, <code>repeated</code>, <code>tccov</code>, or <code>tvcov</code>; the
name of the response variable should be given in <code>response</code>. If
<code>response</code> has class <code>repeated</code>, it is used as the environment.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="kalseries_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a gamma mixture of the distribution specified in
<code>intensity</code> is used, as the conditional distribution in the
<code>Markov</code> and <code>serial</code> dependence models, and as a symmetric
multivariate (random effect) model for <code>frailty</code> dependence. For
example, with a Weibull <code>intensity</code> and <code>frailty</code> dependence,
this yields a multivariate Burr distribution and with <code>Markov</code> or
<code>serial</code> dependence, univariate Burr conditional distributions.
</p>
<p>If a value for <code>pfamily</code> is used, the gamma mixture is replaced by a
power variance family mixture.
</p>
<p>Nonlinear regression models can be supplied as formulae where parameters
are unknowns in which case factor variables cannot be used and parameters
must be scalars. (See <code><a href="rmutil.html#topic+finterp">finterp</a></code>.)
</p>
<p>Marginal and individual profiles can be plotted using
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and <code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and
residuals with <code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>kalseries</code> and <code>recursive</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
treat &lt;- c(0,0,1,1)
tr &lt;- tcctomat(treat)
dose &lt;- matrix(rpois(20,10), ncol=5)
dd &lt;- tvctomat(dose)
y &lt;- restovec(matrix(rnorm(20), ncol=5), name="y")
reps &lt;- rmna(y, ccov=tr, tvcov=dd)
#
# normal intensity, independence model
kalseries(y, intensity="normal", dep="independence", preg=1, pshape=5)
## Not run: 
# random effect
kalseries(y, intensity="normal", dep="frailty", preg=1, pinitial=1, psh=5)
# serial dependence
kalseries(y, intensity="normal", dep="serial", preg=1, pinitial=1,
	pdep=0.1, psh=5)
# random effect and autoregression
kalseries(y, intensity="normal", dep="frailty", preg=1, pinitial=1,
	pdep=0.1, psh=5)
#
# add time-constant variable
kalseries(y, intensity="normal", dep="serial", pinitial=1,
	pdep=0.1, psh=5, preg=c(1,0), ccov=treat)
# or equivalently
kalseries(y, intensity="normal", mu=~treat, dep="serial", pinitial=1,
	pdep=0.1, psh=5, preg=c(1,0))
# or
kalseries(y, intensity="normal", mu=~b0+b1*treat, dep="serial",
	pinitial=1, pdep=0.1, psh=5, preg=c(1,0), envir=reps)
#
# add time-varying variable
kalseries(y, intensity="normal", dep="serial", pinitial=1, pdep=0.1,
	psh=5, preg=c(1,0), ccov=treat, ptvc=0, tvc=dose)
# or equivalently, from the environment
dosev &lt;- as.vector(t(dose))
kalseries(y, intensity="normal",
	mu=~b0+b1*rep(treat,rep(5,4))+b2*dosev,
	dep="serial", pinitial=1, pdep=0.1, psh=5, ptvc=c(1,0,0))
# or from the reps data object
kalseries(y, intensity="normal", mu=~b0+b1*treat+b2*dose,
	dep="serial", pinitial=1, pdep=0.1, psh=5, ptvc=c(1,0,0),
	envir=reps)
# try power variance family instead of gamma distribution for mixture
kalseries(y, intensity="normal", mu=~b0+b1*treat+b2*dose,
	dep="serial", pinitial=1, pdep=0.1, psh=5, ptvc=c(1,0,0),
	pfamily=0.1, envir=reps)
# first-order one-compartment model
# data objects for formulae
dose &lt;- c(2,5)
dd &lt;- tcctomat(dose)
times &lt;- matrix(rep(1:20,2), nrow=2, byrow=TRUE)
tt &lt;- tvctomat(times)
# vector covariates for functions
dose &lt;- c(rep(2,20),rep(5,20))
times &lt;- rep(1:20,2)
# functions
mu &lt;- function(p) exp(p[1]-p[3])*(dose/(exp(p[1])-exp(p[2]))*
	(exp(-exp(p[2])*times)-exp(-exp(p[1])*times)))
shape &lt;- function(p) exp(p[1]-p[2])*times*dose*exp(-exp(p[1])*times)
# response
conc &lt;- matrix(rgamma(40,shape(log(c(0.01,1))),
	scale=mu(log(c(1,0.3,0.2))))/shape(log(c(0.1,0.4))),ncol=20,byrow=TRUE)
conc[,2:20] &lt;- conc[,2:20]+0.5*(conc[,1:19]-matrix(mu(log(c(1,0.3,0.2))),
	ncol=20,byrow=TRUE)[,1:19])
conc &lt;- restovec(ifelse(conc&gt;0,conc,0.01))
reps &lt;- rmna(conc, ccov=dd, tvcov=tt)
#
# constant shape parameter
kalseries(reps, intensity="gamma", dep="independence", mu=mu,
	ptvc=c(-1,-1.1,-1), pshape=1.5)
# or
kalseries(reps, intensity="gamma", dep="independence",
	mu=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
	ptvc=list(absorption=-1,elimination=-1.1,volume=-1),
	pshape=1.2)
# add serial dependence
kalseries(reps, intensity="gamma", dep="serial", pdep=0.9,
	mu=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
	ptvc=list(absorption=-1,elimination=-1.1,volume=-1),
	pshape=0.2)
# time dependent shape parameter
kalseries(reps, intensity="gamma", dep="independence", mu=mu,
	shape=shape, ptvc=c(-1,-1.1,-1), pshape=c(-3,0))
# or
kalseries(reps, intensity="gamma", dep="independence",
	mu=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
	ptvc=list(absorption=-1,elimination=-1.1,volume=-1),
	shape=~exp(b1-b2)*times*dose*exp(-exp(b1)*times),
	pshape=list(b1=-3,b2=0))
# add serial dependence
kalseries(reps, intensity="gamma", dep="serial", pdep=0.5,
	mu=~exp(absorption-volume)*
	dose/(exp(absorption)-exp(elimination))*
	(exp(-exp(elimination)*times)-exp(-exp(absorption)*times)),
	ptvc=list(absorption=-1,elimination=-1.1,volume=-1),
	shape=~exp(b1-b2)*times*dose*exp(-exp(b1)*times),
	pshape=list(b1=-3,b2=0))

## End(Not run)
</code></pre>

<hr>
<h2 id='marg.hom'>Marginal Homogeneity Models</h2><span id='topic+marg.hom'></span><span id='topic+print.marginal'></span>

<h3>Description</h3>

<p><code>marg.hom</code> fits a marginal homogeneity model to a contingency table
that has two margins of equal size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.hom(freq, marg1, marg2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg.hom_+3A_freq">freq</code></td>
<td>
<p>Vector of frequencies</p>
</td></tr>
<tr><td><code id="marg.hom_+3A_marg1">marg1</code></td>
<td>
<p>Factor variable for the first margin</p>
</td></tr>
<tr><td><code id="marg.hom_+3A_marg2">marg2</code></td>
<td>
<p>Factor variable for the second margin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the call, the model, the deviance, the degrees of
freedom, the aic, the fitted values, and the residuals is returned.
</p>


<h3>Author(s)</h3>

<p>J.K. Lindsey
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 4x4x2 table in Freq, with margins indexed by Left and Right
Freq &lt;- rpois(32,10)
Left &lt;- gl(4,1,32)
Right &lt;- gl(4,4,32)
marg.hom(Freq, Left, Right)

</code></pre>

<hr>
<h2 id='nbkal'>Negative Binomial Models with Kalman Update</h2><span id='topic+nbkal'></span><span id='topic+print.nbkal'></span>

<h3>Description</h3>

<p><code>nbkal</code> fits a negative binomial regression with Kalman update over
time. The variance is proportional to the mean function, whereas, for
<code><a href="#topic+kalcount">kalcount</a></code> with exponential intensity, it is a
quadratic function of the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbkal(
  response,
  times,
  mu,
  preg,
  pdepend,
  kalman = TRUE,
  print.level = 0,
  ndigit = 10,
  gradtol = 1e-05,
  steptol = 1e-05,
  fscale = 1,
  iterlim = 100,
  typsize = abs(p),
  stepmax = 10 * sqrt(p %*% p)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbkal_+3A_response">response</code></td>
<td>
<p>A list of two column matrices with counts and corresponding
times for each individual, one matrix or dataframe of counts, or an object
of class, response (created by <code><a href="rmutil.html#topic+restovec">restovec</a></code>) or repeated
(created by <code><a href="rmutil.html#topic+rmna">rmna</a></code> or <code><a href="rmutil.html#topic+lvna">lvna</a></code>).</p>
</td></tr>
<tr><td><code id="nbkal_+3A_times">times</code></td>
<td>
<p>When response is a matrix, a vector of possibly unequally
spaced times when they are the same for all individuals or a matrix of
times. Not necessary if equally spaced. Ignored if response has class,
response or repeated.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_mu">mu</code></td>
<td>
<p>The mean function.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_preg">preg</code></td>
<td>
<p>The initial parameter estimates for the mean function.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_pdepend">pdepend</code></td>
<td>
<p>The estimates for the dependence parameters, either one or
three.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_kalman">kalman</code></td>
<td>
<p>If TRUE, fits the kalman update model, otherwise, a standard
negative binomial distribution.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_print.level">print.level</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_ndigit">ndigit</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_gradtol">gradtol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_steptol">steptol</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_fscale">fscale</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_iterlim">iterlim</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_typsize">typsize</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
<tr><td><code id="nbkal_+3A_stepmax">stepmax</code></td>
<td>
<p>Arguments for nlm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marginal and individual profiles can be plotted using
<code><a href="rmutil.html#topic+mprofile">mprofile</a></code> and <code><a href="rmutil.html#topic+iprofile">iprofile</a></code> and
residuals with <code><a href="rmutil.html#topic+plot.residuals">plot.residuals</a></code>.
</p>


<h3>Value</h3>

<p>A list of classes <code>nbkal</code> and <code>recursive</code> is returned.
</p>


<h3>Author(s)</h3>

<p>P. Lambert and J.K. Lindsey
</p>


<h3>References</h3>

<p>Lambert, P. (1996) Applied Statistics 45, 31-38.
</p>
<p>Lambert, P. (1996) Biometrics 52, 50-55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- matrix(rnbinom(20,5,0.5), ncol=5)
times &lt;- matrix(rep(seq(10,50,by=10),4), ncol=5, byrow=TRUE)
y0 &lt;- matrix(rep(rnbinom(5,5,0.5),4), ncol=5, byrow=TRUE)
mu &lt;- function(p) p[1]*log(y0)+(times&lt;30)*p[2]*
	(times-30)+(times&gt;30)*p[3]*(times-30)
nbkal(y, preg=c(1.3,0.008,-0.05), times=times, pdep=1.2, mu=mu)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
