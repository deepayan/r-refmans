<!DOCTYPE html><html><head><title>Help for package cOde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cOde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjointSymb'><p>Compute adjoint equations of a function symbolically</p></a></li>
<li><a href='#bvptwpC'><p>Interface to bvptwp()</p></a></li>
<li><a href='#compileAndLoad'><p>Compile and load shared object implementing the ODE system.</p></a></li>
<li><a href='#forcData'><p>Forcings data.frame</p></a></li>
<li><a href='#funC'><p>Generate C code for a function and compile it</p></a></li>
<li><a href='#getSymbols'><p>Get symbols from a character</p></a></li>
<li><a href='#jacobianSymb'><p>Compute Jacobian of a function symbolically</p></a></li>
<li><a href='#odeC'><p>Interface to ode()</p></a></li>
<li><a href='#oxygenData'><p>Time-course data of O, O2 and O3</p></a></li>
<li><a href='#prodSymb'><p>Compute matrix product symbolically</p></a></li>
<li><a href='#reduceSensitivities'><p>reduceSensitivities</p></a></li>
<li><a href='#replaceNumbers'><p>Replace integer number in a character vector by other double</p></a></li>
<li><a href='#replaceOperation'><p>Replace a binary operator in a string by a function</p></a></li>
<li><a href='#replaceSymbols'><p>Replace symbols in a character vector by other symbols</p></a></li>
<li><a href='#sensitivitiesSymb'><p>Compute sensitivity equations of a function symbolically</p></a></li>
<li><a href='#setForcings'><p>Generate interpolation spline for the forcings and write into list of matrices</p></a></li>
<li><a href='#sumSymb'><p>Compute matrix sumSymbolically</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated C Code Generation for 'deSolve', 'bvpSolve'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deSolve, bvpSolve, testthat</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Kaschek</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Kaschek &lt;daniel.kaschek@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates all necessary C functions allowing the user to work with
    the compiled-code interface of ode() and bvptwp(). The implementation supports
    "forcings" and "events". Also provides functions to symbolically compute
    Jacobians, sensitivity equations and adjoint sensitivities being the basis for
    sensitivity analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-23 21:44:17 UTC; kaschek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-23 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjointSymb'>Compute adjoint equations of a function symbolically</h2><span id='topic+adjointSymb'></span>

<h3>Description</h3>

<p>Compute adjoint equations of a function symbolically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjointSymb(f, states = names(f), parameters = NULL, inputs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjointSymb_+3A_f">f</code></td>
<td>
<p>Named vector of type character, the functions</p>
</td></tr>
<tr><td><code id="adjointSymb_+3A_states">states</code></td>
<td>
<p>Character vector of the ODE states for which observations are available</p>
</td></tr>
<tr><td><code id="adjointSymb_+3A_parameters">parameters</code></td>
<td>
<p>Character vector of the parameters</p>
</td></tr>
<tr><td><code id="adjointSymb_+3A_inputs">inputs</code></td>
<td>
<p>Character vector of the &quot;variable&quot; input states, i.e. time-dependent parameters
(in contrast to the forcings).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjoint equations are computed with respect to the functional 
</p>
<p style="text-align: center;"><code class="reqn">(x, u)\mapsto \int_0^T \|x(t)-x^D(t)\|^2 + \|u(t) - u^D(t)\|^2 dt,</code>
</p>
 
<p>where x are the states being constrained
by the ODE, u are the inputs and xD and uD indicate the trajectories to be best
possibly approached. When the ODE is linear with respect to u, the attribute <code>inputs</code>
of the returned equations can be used to replace all occurences of u by the corresponding
character in the attribute. This guarantees that the input course is optimal with
respect to the above function.
</p>


<h3>Value</h3>

<p>Named vector of type character with the adjoint equations. The vector has attributes
&quot;chi&quot; (integrand of the chisquare functional), &quot;grad&quot; (integrand of the gradient of the chisquare functional),
&quot;forcings&quot; (character vector of the forcings necessary for integration of the adjoint equations) and
&quot;inputs&quot; (the input expressed as a function of the adjoint variables).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

######################################################################
## Solve an optimal control problem:
######################################################################

library(bvpSolve)

# O2 + O &lt;-&gt; O3
# O3 is removed by a variable rate u(t)
f &lt;- c(
  O3 = " build_O3 * O2 * O - decay_O3 * O3 - u * O3",
  O2 = "-build_O3 * O2 * O + decay_O3 * O3",
  O  = "-build_O3 * O2 * O + decay_O3 * O3"
)

# Compute adjoints equations and replace u by optimal input
f_a &lt;- adjointSymb(f, states = c("O3"), inputs = "u")
inputs &lt;- attr(f_a, "inputs")
f_tot &lt;- replaceSymbols("u", inputs, c(f, f_a))
forcings &lt;- attr(f_a, "forcings")

# Initialize times, states, parameters
times &lt;- seq(0, 15, by = .1)
boundary &lt;- data.frame(
  name = c("O3", "O2", "O", "adjO3", "adjO2", "adjO"),
  yini = c(0.5, 2, 2.5, NA, NA, NA),
  yend = c(NA, NA, NA, 0, 0, 0))

pars &lt;- c(build_O3 = .2, decay_O3 = .1, eps = 1)

# Generate ODE function
func &lt;- funC(f = f_tot, forcings = forcings, 
             jacobian = "full", boundary = boundary,
             modelname = "example5")

# Initialize forcings (the objective)
forcData &lt;- data.frame(time = times,
                       name = rep(forcings, each=length(times)),
                       value = rep(
                         c(0.5, 0, 1, 1), each=length(times)))
forc &lt;- setForcings(func, forcData)

# Solve BVP
out &lt;- bvptwpC(x = times, func = func, parms = pars, forcings = forc)

# Plot solution
par(mfcol=c(1,2))
t &lt;- out[,1]
M1 &lt;- out[,2:4]
M2 &lt;- with(list(uD = 0, O3 = out[,2], 
                adjO3 = out[,5], eps = 1, weightuD = 1), 
           eval(parse(text=inputs)))

matplot(t, M1, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="states")
abline(h = .5, lty=2)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1, 
        xlab="time", ylab="value", main="input u")
abline(h = 0, lty=2)


## End(Not run)
</code></pre>

<hr>
<h2 id='bvptwpC'>Interface to bvptwp()</h2><span id='topic+bvptwpC'></span>

<h3>Description</h3>

<p>Interface to bvptwp()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvptwpC(
  yini = NULL,
  x,
  func,
  yend = NULL,
  parms,
  xguess = NULL,
  yguess = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvptwpC_+3A_yini">yini</code></td>
<td>
<p>named vector of type numeric. Initial values to be overwritten.</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_x">x</code></td>
<td>
<p>vector of type numeric. Integration times</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_func">func</code></td>
<td>
<p>return value from funC() with a boundary argument.</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_yend">yend</code></td>
<td>
<p>named vector of type numeric. End values to be overwritten.</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_parms">parms</code></td>
<td>
<p>named vector of type numeric. The dynamic parameters.</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_xguess">xguess</code></td>
<td>
<p>vector of type numeric, the x values</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_yguess">yguess</code></td>
<td>
<p>matrix with as many rows as variables and columns as x values</p>
</td></tr>
<tr><td><code id="bvptwpC_+3A_...">...</code></td>
<td>
<p>further arguments going to <code>bvptwp()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See bvpSolve-package for a full description of possible arguments
</p>


<h3>Value</h3>

<p>matrix with times and states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

######################################################################
## Boundary value problem: Ozon formation with fixed ozon/oxygen ratio
## at final time point
######################################################################

library(bvpSolve)

# O2 + O &lt;-&gt; O3
# diff = O2 - O3
# build_O3 = const.
f &lt;- c(
  O3 = " build_O3 * O2 * O - decay_O3 * O3",
  O2 = "-build_O3 * O2 * O + decay_O3 * O3",
  O  = "-build_O3 * O2 * O + decay_O3 * O3",
  diff = "-2 * build_O3 * O2 * O + 2 * decay_O3 * O3", 
  build_O3 = "0"
)

bound &lt;- data.frame(
    name = names(f),
    yini = c(0, 3, 2, 3, NA),
    yend = c(NA, NA, NA, 0, NA)
)

# Generate ODE function
func &lt;- funC(f, jacobian="full", boundary = bound, modelname = "example4")

# Initialize times, states, parameters and forcings
times &lt;- seq(0, 15, by = .1)
pars &lt;- c(decay_O3 = .1)
xguess &lt;- times
yguess &lt;- matrix(c(1, 1, 1, 1, 1), ncol=length(times), 
                 nrow = length(f))

# Solve BVP
out &lt;- bvptwpC(x = times, func = func, parms = pars, 
               xguess = xguess, yguess = yguess)

# Solve BVP for different ini values, end values and parameters
yini &lt;- c(O3 = 2)
yend &lt;- c(diff = 0.2)
pars &lt;- c(decay_O3 = .01)
out &lt;- bvptwpC(yini = yini, yend = yend, x = times, func = func, 
	       parms = pars, xguess = xguess, yguess = yguess)

# Plot solution
par(mfcol=c(1,2))
t &lt;- out[,1]
M1 &lt;- out[,2:5]
M2 &lt;- cbind(out[,6], pars)

matplot(t, M1, type="l", lty=1, col=1:4, 
        xlab="time", ylab="value", main="states")
legend("topright", legend = c("O3", "O2", "O", "O2 - O3"), 
       lty=1, col=1:4)
matplot(t, M2, type="l", lty=1, col=1:2, 
        xlab="time", ylab="value", main="parameters")
legend("right", legend = c("build_O3", "decay_O3"), lty=1, col=1:2)


## End(Not run)
</code></pre>

<hr>
<h2 id='compileAndLoad'>Compile and load shared object implementing the ODE system.</h2><span id='topic+compileAndLoad'></span>

<h3>Description</h3>

<p>Compile and load shared object implementing the ODE system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileAndLoad(filename, dllname, fcontrol, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compileAndLoad_+3A_filename">filename</code></td>
<td>
<p>Full file name of the source file.</p>
</td></tr>
<tr><td><code id="compileAndLoad_+3A_dllname">dllname</code></td>
<td>
<p>Base name for source and dll file.</p>
</td></tr>
<tr><td><code id="compileAndLoad_+3A_fcontrol">fcontrol</code></td>
<td>
<p>Interpolation method for forcings.</p>
</td></tr>
<tr><td><code id="compileAndLoad_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Kaschek, <a href="mailto:daniel.kaschek@physik.uni-freiburg.de">daniel.kaschek@physik.uni-freiburg.de</a>
</p>
<p>Wolfgang Mader, <a href="mailto:Wolfgang.Mader@fdm.uni-freiburg.de">Wolfgang.Mader@fdm.uni-freiburg.de</a>
</p>

<hr>
<h2 id='forcData'>Forcings data.frame</h2><span id='topic+forcData'></span>

<h3>Description</h3>

<p>Forcings data.frame
</p>

<hr>
<h2 id='funC'>Generate C code for a function and compile it</h2><span id='topic+funC'></span>

<h3>Description</h3>

<p>Generate C code for a function and compile it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funC(
  f,
  forcings = NULL,
  events = NULL,
  fixed = NULL,
  outputs = NULL,
  jacobian = c("none", "full", "inz.lsodes", "jacvec.lsodes"),
  rootfunc = NULL,
  boundary = NULL,
  compile = TRUE,
  fcontrol = c("nospline", "einspline"),
  nGridpoints = -1,
  includeTimeZero = TRUE,
  precision = 1e-05,
  modelname = NULL,
  verbose = FALSE,
  solver = c("deSolve", "Sundials")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funC_+3A_f">f</code></td>
<td>
<p>Named character vector containing the right-hand sides of the ODE.
You may use the key word <code>time</code> in your equations for non-autonomous
ODEs.</p>
</td></tr>
<tr><td><code id="funC_+3A_forcings">forcings</code></td>
<td>
<p>Character vector with the names of the forcings</p>
</td></tr>
<tr><td><code id="funC_+3A_events">events</code></td>
<td>
<p>data.frame of events with columns &quot;var&quot; (character, the name of the state to be
affected), &quot;time&quot; (numeric or character, time point), 
&quot;value&quot; (numeric or character, value), &quot;method&quot; (character, either
&quot;replace&quot; or &quot;add&quot;). See <a href="deSolve.html#topic+events">events</a>. If &quot;var&quot; and &quot;time&quot; are
characters, their values need to be speciefied in the parameter vector
when calling <code><a href="#topic+odeC">odeC</a></code>. An event function is generated and compiled
with the ODE.</p>
</td></tr>
<tr><td><code id="funC_+3A_fixed">fixed</code></td>
<td>
<p>character vector with the names of parameters (initial values
and dynamic) for which no sensitivities are required (will speed up the
integration).</p>
</td></tr>
<tr><td><code id="funC_+3A_outputs">outputs</code></td>
<td>
<p>Named character vector for additional output variables, see
arguments <code>nout</code> and <code>outnames</code> of <a href="deSolve.html#topic+lsode">lsode</a></p>
</td></tr>
<tr><td><code id="funC_+3A_jacobian">jacobian</code></td>
<td>
<p>Character, either &quot;none&quot; (no jacobian is computed), &quot;full&quot;
(full jacobian is computed and written as a function into the C file) or
&quot;inz.lsodes&quot; (only the non-zero elements of the jacobian are determined,
see <a href="deSolve.html#topic+lsodes">lsodes</a>)</p>
</td></tr>
<tr><td><code id="funC_+3A_rootfunc">rootfunc</code></td>
<td>
<p>Named character vector. The root function (see
<a href="deSolve.html#topic+lsoda">lsoda</a>). Besides the variable names (<code>names(f)</code>) also
other symbols are allowed that are treated like new parameters.</p>
</td></tr>
<tr><td><code id="funC_+3A_boundary">boundary</code></td>
<td>
<p>data.frame with columns name, yini, yend specifying the
boundary condition set-up. NULL if not a boundary value problem</p>
</td></tr>
<tr><td><code id="funC_+3A_compile">compile</code></td>
<td>
<p>Logical. If FALSE, only the C file is written</p>
</td></tr>
<tr><td><code id="funC_+3A_fcontrol">fcontrol</code></td>
<td>
<p>Character, either <code>"nospline"</code> (default, forcings are
handled by deSolve) or <code>"einspline"</code> (forcings are handled as splines
within the C code based on the einspline library).</p>
</td></tr>
<tr><td><code id="funC_+3A_ngridpoints">nGridpoints</code></td>
<td>
<p>Integer, defining for which time points the ODE is evaluated
or the solution is returned: Set <code>-1</code> to return only the explicitly requested
time points (default). If additional time points are introduced through events, they
will not be returned. Set <code>&gt;= 0</code> to introduce additional time points between tmin
and tmax where the ODE is evaluated in any case. Additional time points that might be
introduced by events will be returned.
If splines are used with <code>fcontrol = "einspline"</code>, <code>nGridpoinnts</code> also
indicates the number of spline nodes.</p>
</td></tr>
<tr><td><code id="funC_+3A_includetimezero">includeTimeZero</code></td>
<td>
<p>Logical. Include t = 0 in the integration time points if <code>TRUE</code> 
(default). Consequently,
integration starts at t = 0 if only positive time points are provided by the user and at
tmin, if also negtive time points are provided.</p>
</td></tr>
<tr><td><code id="funC_+3A_precision">precision</code></td>
<td>
<p>Numeric. Only used when <code>fcontrol = "einspline"</code>.</p>
</td></tr>
<tr><td><code id="funC_+3A_modelname">modelname</code></td>
<td>
<p>Character. The C file is generated in the working directory
and is named &lt;modelname&gt;.c. If <code>NULL</code>, a random name starting with
&quot;.f&quot; is chosen, i.e. the file is hidden on a UNIX system.</p>
</td></tr>
<tr><td><code id="funC_+3A_verbose">verbose</code></td>
<td>
<p>Print compiler output to R command line.</p>
</td></tr>
<tr><td><code id="funC_+3A_solver">solver</code></td>
<td>
<p>Select the solver suite as either <code>deSolve</code> or
<code>Sundials</code> (not available any more). Defaults to <code>deSolve</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function replaces variables by arrays <code>y[i]</code>, etc. and
replaces &quot;^&quot; by pow() in order to have the correct C syntax. The file name
of the C-File is derived from <code>f</code>. I.e. <code>funC(abc, ...</code> will
generate a file abc.c in the current directory. Currently, only explicit
ODE specification is supported, i.e. you need to have the right-hand sides
of the ODE.
</p>


<h3>Value</h3>

<p>the name of the generated shared object file together with a number
of attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Exponential decay plus constant supply
f &lt;- c(x = "-k*x + supply")
func &lt;- funC(f, forcings = "supply")

# Example 2: root function
f &lt;- c(A = "-k1*A + k2*B", B = "k1*A - k2*B")
rootfunc &lt;- c(steadyState = "-k1*A + k2*B - tol")

func &lt;- funC(f, rootfunc = rootfunc, modelname = "test")

yini &lt;- c(A = 1, B = 2)
parms &lt;- c(k1 = 1, k2 = 5, tol = 0.1)
times &lt;- seq(0, 10, len = 100)

odeC(yini, times, func, parms)

## End(Not run)
</code></pre>

<hr>
<h2 id='getSymbols'>Get symbols from a character</h2><span id='topic+getSymbols'></span>

<h3>Description</h3>

<p>Get symbols from a character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSymbols(char, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSymbols_+3A_char">char</code></td>
<td>
<p>Character vector (e.g. equation)</p>
</td></tr>
<tr><td><code id="getSymbols_+3A_exclude">exclude</code></td>
<td>
<p>Character vector, the symbols to be excluded from the return value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with the symbols
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getSymbols(c("A*AB+B^2"))
</code></pre>

<hr>
<h2 id='jacobianSymb'>Compute Jacobian of a function symbolically</h2><span id='topic+jacobianSymb'></span>

<h3>Description</h3>

<p>Compute Jacobian of a function symbolically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobianSymb(f, variables = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobianSymb_+3A_f">f</code></td>
<td>
<p>named vector of type character, the functions</p>
</td></tr>
<tr><td><code id="jacobianSymb_+3A_variables">variables</code></td>
<td>
<p>other variables, e.g. paramters, f depends on. If variables is
given, f is derived with respect to variables instead of <code>names(f)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector of type character with the symbolic derivatives
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jacobianSymb(c(A="A*B", B="A+B"))
jacobianSymb(c(x="A*B", y="A+B"), c("A", "B"))
</code></pre>

<hr>
<h2 id='odeC'>Interface to ode()</h2><span id='topic+odeC'></span>

<h3>Description</h3>

<p>Interface to ode()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odeC(y, times, func, parms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odeC_+3A_y">y</code></td>
<td>
<p>named vector of type numeric. Initial values for the integration</p>
</td></tr>
<tr><td><code id="odeC_+3A_times">times</code></td>
<td>
<p>vector of type numeric. Integration times. If <code>includeTimeZero</code>
is <code>TRUE</code> (see <a href="#topic+funC">funC</a>), the times vector is augmented by t = 0. If
<code>nGridpoints</code> (see <a href="#topic+funC">funC</a>) was set &gt;= 0, uniformly distributed time points
between the first and last time point are introduced and the solution is returned
for these time points, too. Any additional time points that are introduced during
integration (e.g. event time points) are returned unless nGridpoints = -1 (the default).</p>
</td></tr>
<tr><td><code id="odeC_+3A_func">func</code></td>
<td>
<p>return value from funC()</p>
</td></tr>
<tr><td><code id="odeC_+3A_parms">parms</code></td>
<td>
<p>named vector of type numeric.</p>
</td></tr>
<tr><td><code id="odeC_+3A_...">...</code></td>
<td>
<p>further arguments going to <code>ode()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See deSolve-package for a full description of possible arguments
</p>


<h3>Value</h3>

<p>matrix with times and states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

######################################################################
## Ozone formation and decay, modified by external forcings
######################################################################

library(deSolve)
data(forcData)
forcData$value &lt;- forcData$value + 1

# O2 + O &lt;-&gt; O3
f &lt;- c(
  O3 = " (build_O3 + u_build) * O2 * O - (decay_O3 + u_degrade) * O3",
  O2 = "-(build_O3 + u_build) * O2 * O + (decay_O3 + u_degrade) * O3",
  O  = "-(build_O3 + u_build) * O2 * O + (decay_O3 + u_degrade) * O3"
)

# Generate ODE function
forcings &lt;- c("u_build", "u_degrade")
func &lt;- funC(f, forcings = forcings, modelname = "test", 
             fcontrol = "nospline", nGridpoints = 10)

# Initialize times, states, parameters and forcings
times &lt;- seq(0, 8, by = .1)
yini &lt;- c(O3 = 0, O2 = 3, O = 2)
pars &lt;- c(build_O3 = 1/6, decay_O3 = 1)

forc &lt;- setForcings(func, forcData)

# Solve ODE
out &lt;- odeC(y = yini, times = times, func = func, parms = pars, 
            forcings = forc)

# Plot solution

par(mfcol=c(1,2))
t1 &lt;- unique(forcData[,2])
M1 &lt;- matrix(forcData[,3], ncol=2)
t2 &lt;- out[,1]
M2 &lt;- out[,2:4]
M3 &lt;- out[,5:6]

matplot(t1, M1, type="l", lty=1, col=1:2, xlab="time", ylab="value", 
	main="forcings", ylim=c(0, 4))
matplot(t2, M3, type="l", lty=2, col=1:2, xlab="time", ylab="value", 
	main="forcings", add=TRUE)

legend("topleft", legend = c("u_build", "u_degrade"), lty=1, col=1:2)
matplot(t2, M2, type="l", lty=1, col=1:3, xlab="time", ylab="value", 
	main="response")
legend("topright", legend = c("O3", "O2", "O"), lty=1, col=1:3)



######################################################################
## Ozone formation and decay, modified by events
######################################################################


f &lt;- c(
  O3 = " (build_O3 + u_build) * O2 * O - 
         (decay_O3 + u_degrade) * O3",
  O2 = "-(build_O3 + u_build) * O2 * O + 
         (decay_O3 + u_degrade) * O3",
  O  = "-(build_O3 + u_build) * O2 * O + 
         (decay_O3 + u_degrade) * O3",
  u_build = "0",    # piecewise constant
  u_degrade = "0"   # piecewise constant
)

# Define parametric events
events.pars &lt;- data.frame(
  var = c("u_degrade", "u_degrade", "u_build"),
  time = c("t_on", "t_off", "2"),
  value = c("plus", "minus", "2"),
  method = "replace"
)

# Declar parameteric events when generating funC object
func &lt;- funC(f, forcings = NULL, events = events.pars, modelname = "test", 
             fcontrol = "nospline", nGridpoints = -1)

# Set Parameters
yini &lt;- c(O3 = 0, O2 = 3, O = 2, u_build = 1, u_degrade = 1)
times &lt;- seq(0, 8, by = .1)
pars &lt;- c(build_O3 = 1/6, decay_O3 = 1, t_on = exp(rnorm(1, 0)), t_off = 6, plus = 3, minus = 1)

# Solve ODE with additional fixed-value events
out &lt;- odeC(y = yini, times = times, func = func, parms = pars)


# Plot solution

par(mfcol=c(1,2))
t2 &lt;- out[,1]
M2 &lt;- out[,2:4]
M3 &lt;- out[,5:6]


matplot(t2, M3, type="l", lty=2, col=1:2, xlab="time", ylab="value", 
        main="events")
legend("topleft", legend = c("u_build", "u_degrade"), lty=1, col=1:2)
matplot(t2, M2, type="l", lty=1, col=1:3, xlab="time", ylab="value", 
        main="response")
legend("topright", legend = c("O3", "O2", "O"), lty=1, col=1:3)


######################################################################
## Ozone formation and decay, modified by events triggered by root
######################################################################


f &lt;- c(
  O3 = " (build_O3 + u_build) * O2 * O - 
         (decay_O3 + u_degrade) * O3",
  O2 = "-(build_O3 + u_build) * O2 * O + 
         (decay_O3 + u_degrade) * O3",
  O  = "-(build_O3 + u_build) * O2 * O + 
         (decay_O3 + u_degrade) * O3",
  u_build = "0",    # piecewise constant
  u_degrade = "0"   # piecewise constant
)

# Define parametric events
events.pars &lt;- data.frame(
  var = c("u_degrade", "u_degrade", "u_build", "O3"),
  time = c("t_on", "t_off", "2", "t_thres_O3"),
  value = c("plus", "minus", "2", "0"),
  root = c(NA, NA, NA, "O3 - thres_O3"),
  method = "replace"
)

# Declar parameteric events when generating funC object
func &lt;- funC(f, forcings = NULL, events = events.pars, modelname = "test", 
             fcontrol = "nospline", nGridpoints = -1)

# Set Parameters
yini &lt;- c(O3 = 0, O2 = 3, O = 2, u_build = 1, u_degrade = 1)
times &lt;- seq(0, 8, by = .01)
pars &lt;- c(build_O3 = 1/6, decay_O3 = 1, 
          t_on = exp(rnorm(1, 0)), t_off = 6, plus = 3, minus = 1, 
          thres_O3 = 0.5, t_thres_O3 = 1)

# Solve ODE with additional fixed-value events
out &lt;- odeC(y = yini, times = times, func = func, parms = pars, method = "lsode")

class(out) &lt;- c("deSolve")
plot(out)
# Plot solution

par(mfcol=c(1,2))
t2 &lt;- out[,1]
M2 &lt;- out[,2:4]
M3 &lt;- out[,5:6]


matplot(t2, M3, type="l", lty=2, col=1:2, xlab="time", ylab="value", 
        main="events")
legend("topleft", legend = c("u_build", "u_degrade"), lty=1, col=1:2)
matplot(t2, M2, type="l", lty=1, col=1:3, xlab="time", ylab="value", 
        main="response")
legend("topright", legend = c("O3", "O2", "O"), lty=1, col=1:3)





## End(Not run)
</code></pre>

<hr>
<h2 id='oxygenData'>Time-course data of O, O2 and O3</h2><span id='topic+oxygenData'></span>

<h3>Description</h3>

<p>Forcings data.frame
</p>

<hr>
<h2 id='prodSymb'>Compute matrix product symbolically</h2><span id='topic+prodSymb'></span>

<h3>Description</h3>

<p>Compute matrix product symbolically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodSymb(M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodSymb_+3A_m">M</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
<tr><td><code id="prodSymb_+3A_n">N</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of type character, the matrix product of M and N
</p>

<hr>
<h2 id='reduceSensitivities'>reduceSensitivities</h2><span id='topic+reduceSensitivities'></span>

<h3>Description</h3>

<p>reduceSensitivities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceSensitivities(sens, vanishing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceSensitivities_+3A_sens">sens</code></td>
<td>
<p>Named character, the sensitivity equations</p>
</td></tr>
<tr><td><code id="reduceSensitivities_+3A_vanishing">vanishing</code></td>
<td>
<p>Character, names of the vanishing sensitivities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the set <code>vanishing</code> of vanishing sensitivities, the algorithm
determins sensitivities that vanish as a consequence of the first set.
</p>


<h3>Value</h3>

<p>Named character, the sensitivity equations with zero entries for vanishing
sensitivities.
</p>

<hr>
<h2 id='replaceNumbers'>Replace integer number in a character vector by other double</h2><span id='topic+replaceNumbers'></span>

<h3>Description</h3>

<p>Replace integer number in a character vector by other double
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceNumbers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceNumbers_+3A_x">x</code></td>
<td>
<p>vector of type character, the object where the replacement should take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of type character, conserves the names of x.
</p>

<hr>
<h2 id='replaceOperation'>Replace a binary operator in a string by a function</h2><span id='topic+replaceOperation'></span>

<h3>Description</h3>

<p>Replace a binary operator in a string by a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceOperation(what, by, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceOperation_+3A_what">what</code></td>
<td>
<p>character, the operator symbol, e.g. &quot;^&quot;</p>
</td></tr>
<tr><td><code id="replaceOperation_+3A_by">by</code></td>
<td>
<p>character, the function string, e.g. &quot;pow&quot;</p>
</td></tr>
<tr><td><code id="replaceOperation_+3A_x">x</code></td>
<td>
<p>vector of type character, the object where the replacement should take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of type character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replaceOperation("^", "pow", "(x^2 + y^2)^.5")
</code></pre>

<hr>
<h2 id='replaceSymbols'>Replace symbols in a character vector by other symbols</h2><span id='topic+replaceSymbols'></span>

<h3>Description</h3>

<p>Replace symbols in a character vector by other symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceSymbols(what, by, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceSymbols_+3A_what">what</code></td>
<td>
<p>vector of type character, the symbols to be replaced, e.g. c(&quot;A&quot;, &quot;B&quot;)</p>
</td></tr>
<tr><td><code id="replaceSymbols_+3A_by">by</code></td>
<td>
<p>vector of type character, the replacement, e.g. c(&quot;x[0]&quot;, &quot;x[1]&quot;)</p>
</td></tr>
<tr><td><code id="replaceSymbols_+3A_x">x</code></td>
<td>
<p>vector of type character, the object where the replacement should take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of type character, conserves the names of x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replaceSymbols(c("A", "B"), c("x[0]", "x[1]"), c("A*B", "A+B+C"))
</code></pre>

<hr>
<h2 id='sensitivitiesSymb'>Compute sensitivity equations of a function symbolically</h2><span id='topic+sensitivitiesSymb'></span>

<h3>Description</h3>

<p>Compute sensitivity equations of a function symbolically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivitiesSymb(
  f,
  states = names(f),
  parameters = NULL,
  inputs = NULL,
  events = NULL,
  reduce = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivitiesSymb_+3A_f">f</code></td>
<td>
<p>named vector of type character, the functions</p>
</td></tr>
<tr><td><code id="sensitivitiesSymb_+3A_states">states</code></td>
<td>
<p>Character vector. Sensitivities are computed with respect to initial
values of these states</p>
</td></tr>
<tr><td><code id="sensitivitiesSymb_+3A_parameters">parameters</code></td>
<td>
<p>Character vector. Sensitivities are computed with respect to initial
values of these parameters</p>
</td></tr>
<tr><td><code id="sensitivitiesSymb_+3A_inputs">inputs</code></td>
<td>
<p>Character vector. Input functions or forcings. They are excluded from
the computation of sensitivities.</p>
</td></tr>
<tr><td><code id="sensitivitiesSymb_+3A_events">events</code></td>
<td>
<p>data.frame of events with columns &quot;var&quot; (character, the name of the state to be
affected), &quot;time&quot; (numeric or character, time point), 
&quot;value&quot; (numeric or character, value), &quot;method&quot; (character, either
&quot;replace&quot; or &quot;add&quot;). See <a href="deSolve.html#topic+events">events</a>.
Within <code>sensitivitiesSymb()</code> a <code>data.frame</code> of additional events is generated to 
reset the sensitivities appropriately, depending on the event method.</p>
</td></tr>
<tr><td><code id="sensitivitiesSymb_+3A_reduce">reduce</code></td>
<td>
<p>Logical. Attempts to determine vanishing sensitivities, removes their
equations and replaces their right-hand side occurences by 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sensitivity equations are ODEs that are derived from the original ODE f.
They describe the sensitivity of the solution curve with respect to parameters like 
initial values and other parameters contained in f. These equtions are also useful
for parameter estimation by the maximum-likelihood method. For consistency with the
time-continuous setting provided by <a href="#topic+adjointSymb">adjointSymb</a>, the returned equations contain
attributes for the chisquare functional and its gradient.
</p>


<h3>Value</h3>

<p>Named vector of type character with the sensitivity equations. Furthermore,
attributes &quot;chi&quot; (the integrand of the chisquare functional), &quot;grad&quot; (the integrand
of the gradient of the chisquare functional), &quot;forcings&quot; (Character vector of the 
additional forcings being necessare to compute <code>chi</code> and <code>grad</code>) and &quot;yini&quot; (
The initial values of the sensitivity equations) are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

######################################################################
## Sensitivity analysis of ozone formation
######################################################################

library(deSolve)

# O2 + O &lt;-&gt; O3
f &lt;- c(
  O3 = " build_O3 * O2 * O - decay_O3 * O3",
  O2 = "-build_O3 * O2 * O + decay_O3 * O3",
  O  = "-build_O3 * O2 * O + decay_O3 * O3"
)

# Compute sensitivity equations
f_s &lt;- sensitivitiesSymb(f)

# Generate ODE function
func &lt;- funC(c(f, f_s))

# Initialize times, states, parameters and forcings
times &lt;- seq(0, 15, by = .1)
yini &lt;- c(O3 = 0, O2 = 3, O = 2, attr(f_s, "yini"))
pars &lt;- c(build_O3 = .1, decay_O3 = .01)

# Solve ODE
out &lt;- odeC(y = yini, times = times, func = func, parms = pars)

# Plot solution
par(mfcol=c(2,3))
t &lt;- out[,1]
M1 &lt;- out[,2:4]
M2 &lt;- out[,5:7]
M3 &lt;- out[,8:10]
M4 &lt;- out[,11:13]
M5 &lt;- out[,14:16]
M6 &lt;- out[,17:19]

matplot(t, M1, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="solution")
legend("topright", legend = c("O3", "O2", "O"), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="d/(d O3)")
matplot(t, M3, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="d/(d O2)")
matplot(t, M4, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="d/(d O)")
matplot(t, M5, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="d/(d build_O3)")
matplot(t, M6, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="d/(d decay_O3)")


## End(Not run)
## Not run: 

######################################################################
## Estimate parameter values from experimental data
######################################################################

library(deSolve)

# O2 + O &lt;-&gt; O3
# diff = O2 - O3
# build_O3 = const.
f &lt;- c(
  O3 = " build_O3 * O2 * O - decay_O3 * O3",
  O2 = "-build_O3 * O2 * O + decay_O3 * O3",
  O  = "-build_O3 * O2 * O + decay_O3 * O3"
)

# Compute sensitivity equations and get attributes
f_s &lt;- sensitivitiesSymb(f)
chi &lt;- attr(f_s, "chi")
grad &lt;- attr(f_s, "grad")
forcings &lt;- attr(f_s, "forcings")

# Generate ODE function
func &lt;- funC(f = c(f, f_s, chi, grad), forcings = forcings, 
             fcontrol = "nospline", modelname = "example3")

# Initialize times, states, parameters
times &lt;- seq(0, 15, by = .1)
yini &lt;- c(O3 = 0, O2 = 2, O = 2.5)
yini_s &lt;- attr(f_s, "yini")
yini_chi &lt;- c(chi = 0)
yini_grad &lt;- rep(0, length(grad)); names(yini_grad) &lt;- names(grad)
pars &lt;- c(build_O3 = .2, decay_O3 = .1)

# Initialize forcings (the data)
data(oxygenData)
forcData &lt;- data.frame(time = oxygenData[,1],
                       name = rep(
                         colnames(oxygenData[,-1]), 
                         each=dim(oxygenData)[1]),
                       value = as.vector(oxygenData[,-1]))
forc &lt;- setForcings(func, forcData)

# Solve ODE
out &lt;- odeC(y = c(yini, yini_s, yini_chi, yini_grad), 
            times = times, func = func, parms = pars, forcings = forc,
            method = "lsodes")

# Plot solution
par(mfcol=c(1,2))
t &lt;- out[,1]
M1 &lt;- out[,2:4]
M2 &lt;- out[,names(grad)]
tD &lt;- oxygenData[,1]
M1D &lt;- oxygenData[,2:4]

matplot(t, M1, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=4, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, 
        xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)

# Define objective function
obj &lt;- function(p) {
  out &lt;- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad), 
              times = times, func = func, parms = p[names(pars)], 
	      forcings = forc, method="lsodes")
  
  value &lt;- as.vector(tail(out, 1)[,"chi"])
  gradient &lt;- as.vector(
    tail(out, 1)[,paste("chi", names(p), sep=".")])
  hessian &lt;- gradient%*%t(gradient)
  
  return(list(value = value, gradient = gradient, hessian = hessian))
}

# Fit the data
myfit &lt;- optim(par = c(yini, pars), 
               fn = function(p) obj(p)$value, 
               gr = function(p) obj(p)$gradient,
               method = "L-BFGS-B", 
               lower=0,
               upper=5)

# Model prediction for fit parameters
prediction &lt;- odeC(y = c(myfit$par[1:3], yini_s, yini_chi, yini_grad), 
                   times = times, func = func, parms = myfit$par[4:5], 
		   forcings = forc, method = "lsodes")

# Plot solution
par(mfcol=c(1,2))
t &lt;- prediction[,1]
M1 &lt;- prediction[,2:4]
M2 &lt;- prediction[,names(grad)]
tD &lt;- oxygenData[,1]
M1D &lt;- oxygenData[,2:4]

matplot(t, M1, type="l", lty=1, col=1:3, 
        xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=4, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, 
        xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)


## End(Not run)
</code></pre>

<hr>
<h2 id='setForcings'>Generate interpolation spline for the forcings and write into list of matrices</h2><span id='topic+setForcings'></span>

<h3>Description</h3>

<p>Generate interpolation spline for the forcings and write into list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setForcings(func, forcings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setForcings_+3A_func">func</code></td>
<td>
<p>result from funC()</p>
</td></tr>
<tr><td><code id="setForcings_+3A_forcings">forcings</code></td>
<td>
<p>data.frame with columns name (factor), time (numeric) and value (numeric)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splines are generated for each name in forcings and both, function value and first
derivative are evaluated at the time points of the data frame.
</p>


<h3>Value</h3>

<p>list of matrices with time points and values assigned to the forcings interface of deSolve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- c(x = "-k*x + a - b")
func &lt;- funC(f, forcings = c("a", "b"))
forcData &lt;- rbind(
  data.frame(name = "a", time = c(0, 1, 10), value = c(0, 5, 2)),
  data.frame(name = "b", time = c(0, 5, 10), value = c(1, 3, 6)))
forc &lt;- setForcings(func, forcData) 

## End(Not run)
</code></pre>

<hr>
<h2 id='sumSymb'>Compute matrix sumSymbolically</h2><span id='topic+sumSymb'></span>

<h3>Description</h3>

<p>Compute matrix sumSymbolically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumSymb(M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumSymb_+3A_m">M</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
<tr><td><code id="sumSymb_+3A_n">N</code></td>
<td>
<p>matrix of type character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of type character, the matrix sum of M and N
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
