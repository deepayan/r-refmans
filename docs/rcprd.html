<!DOCTYPE html><html lang="en"><head><title>Help for package rcprd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rcprd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rcprd-package'><p>rcprd: Extraction and Management of Clinical Practice Research Datalink Data</p></a></li>
<li><a href='#add_to_database'><p>Adds a single .txt file to an SQLite database on the hard disk.</p></a></li>
<li><a href='#combine_query'><p>Combine a database query with a cohort.</p></a></li>
<li><a href='#combine_query_boolean'><p>Combine a database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.</p></a></li>
<li><a href='#combine_query_boolean.aurum'><p>Combine a CPRD aurum database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.</p></a></li>
<li><a href='#combine_query.aurum'><p>Combine a CPRD aurum database query with a cohort.</p></a></li>
<li><a href='#connect_database'><p>Open connection to SQLite database</p></a></li>
<li><a href='#cprd_extract'><p>Adds all the .txt files in a directory, with certain file names, to an SQLite database on the hard disk.</p></a></li>
<li><a href='#create_directory_system'><p>Create the appropriate directory system to be able to run functions without specifying hard filepaths</p></a></li>
<li><a href='#db_query'><p>Query an RSQLite database.</p></a></li>
<li><a href='#delete_directory_system'><p>Deletes directory system created by <code>delete_directory_system</code></p></a></li>
<li><a href='#extract_bmi'><p>Extract most recent BMI score relative to an index date.</p></a></li>
<li><a href='#extract_cholhdl_ratio'><p>Extract most recent total cholesterol/high-density lipoprotein ratio score relative to an index date.</p></a></li>
<li><a href='#extract_cohort'><p>Create cohort from patient files</p></a></li>
<li><a href='#extract_diabetes'><p>Extract diabetes status prior to an index date.</p></a></li>
<li><a href='#extract_ho'><p>Extract a 'history of' type variable</p></a></li>
<li><a href='#extract_smoking'><p>Extract smoking status prior to index date.</p></a></li>
<li><a href='#extract_test_data'><p>Extract test data.</p></a></li>
<li><a href='#extract_test_data_var'><p>Extract standard deviation of all test data values over a specified time period relative to an index date.</p></a></li>
<li><a href='#extract_test_recent'><p>Extract test data.</p></a></li>
<li><a href='#extract_time_until'><p>Extract a 'time until' type variable</p></a></li>
<li><a href='#extract_txt_char'><p>Read in txt file with all colClasses = &quot;character&quot;</p></a></li>
<li><a href='#extract_txt_cons'><p>Read in raw .txt consultation file</p></a></li>
<li><a href='#extract_txt_death'><p>Read in raw ONS death data file</p></a></li>
<li><a href='#extract_txt_drug'><p>Read in raw .txt drugissue file</p></a></li>
<li><a href='#extract_txt_hes_primary'><p>Read in raw HES primary diagnoses file</p></a></li>
<li><a href='#extract_txt_linkage'><p>Read in linkage eligibility file</p></a></li>
<li><a href='#extract_txt_obs'><p>Read in raw .txt observation file</p></a></li>
<li><a href='#extract_txt_pat'><p>Read in raw .txt patient file</p></a></li>
<li><a href='#extract_txt_prob'><p>Read in raw .txt problem file</p></a></li>
<li><a href='#extract_txt_ref'><p>Read in raw .txt referral file</p></a></li>
<li><a href='#implement_output'><p>Internal function to implement saving extracted variable to disk or returning into R workspace.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extraction and Management of Clinical Practice Research Datalink
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Simplify the process of extracting and processing Clinical Practice
  Research Datalink (CPRD) data in order to build datasets ready for statistical
  analysis. This process is difficult in 'R', as the raw data is very large and 
  cannot be read into the R workspace. 'rcprd' utilises 'RSQLite' to create 
  'SQLite' databases which are stored on the hard disk. These are then  queried 
  to extract the required information for a cohort of interest, and create 
  datasets ready for statistical analysis. The  processes follow closely that 
  from the 'rEHR' package, see Springate et al., (2017) 
  &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0171784">doi:10.1371/journal.pone.0171784</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>data.table</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, fastmatch, RSQLite, stringr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alexpate30.github.io/rcprd/">https://alexpate30.github.io/rcprd/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 22:30:47 UTC; mbrxsap3</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Pate <a href="https://orcid.org/0000-0002-0849-3458"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Pate &lt;alexander.pate@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rcprd-package'>rcprd: Extraction and Management of Clinical Practice Research Datalink Data</h2><span id='topic+rcprd'></span><span id='topic+rcprd-package'></span>

<h3>Description</h3>

<p>Simplify the process of extracting and processing Clinical Practice Research Datalink (CPRD) data in order to build datasets ready for statistical analysis. This process is difficult in 'R', as the raw data is very large and cannot be read into the R workspace. 'rcprd' utilises 'RSQLite' to create 'SQLite' databases which are stored on the hard disk. These are then queried to extract the required information for a cohort of interest, and create datasets ready for statistical analysis. The processes follow closely that from the 'rEHR' package, see Springate et al., (2017) <a href="https://doi.org/10.1371/journal.pone.0171784">doi:10.1371/journal.pone.0171784</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander Pate <a href="mailto:alexander.pate@manchester.ac.uk">alexander.pate@manchester.ac.uk</a> (<a href="https://orcid.org/0000-0002-0849-3458">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://alexpate30.github.io/rcprd/">https://alexpate30.github.io/rcprd/</a>
</p>
</li></ul>


<hr>
<h2 id='add_to_database'>Adds a single .txt file to an SQLite database on the hard disk.</h2><span id='topic+add_to_database'></span>

<h3>Description</h3>

<p>Add the raw data from one of the CPRD flatfiles to an SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_to_database(
  filepath,
  filetype = c("observation", "drugissue", "referral", "problem", "consultation",
    "hes_primary", "death"),
  nrows = -1,
  select = NULL,
  subset_patids = NULL,
  use_set = FALSE,
  db,
  extract_txt_func = NULL,
  tablename = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_to_database_+3A_filepath">filepath</code></td>
<td>
<p>Path to .txt file on your system.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_filetype">filetype</code></td>
<td>
<p>Type of CPRD Aurum file (observation, drugissue, referral, problem, consultation, hes_primary, death)</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows to read in from .txt file.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_select">select</code></td>
<td>
<p>Character vector of column names to select before adding to the SQLite database.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_subset_patids">subset_patids</code></td>
<td>
<p>Patient id's to subset the .txt file on before adding to the SQLite database.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_use_set">use_set</code></td>
<td>
<p>Reduce subset_patids to just those with a corresponding set value to the .txt file being read in. Can greatly improve computational efficiency when subset_patids is large. See vignette XXXX for more details.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_db">db</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_extract_txt_func">extract_txt_func</code></td>
<td>
<p>User-defined function to read the .txt file into R.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_tablename">tablename</code></td>
<td>
<p>Name of table in SQLite database that the data will be added to.</p>
</td></tr>
<tr><td><code id="add_to_database_+3A_...">...</code></td>
<td>
<p>Extract arguments passed to read.table (or extract_txt_func) when reading in .txt files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will add the file to a table named <code>filetype</code> in the SQLite database, unless <code>tablename</code> is specified.
</p>
<p>If <code>use_set = FALSE</code>, then <code>subset_patids</code> should be a vector of patid's that the .txt files will be subsetted on before adding to the SQLite database.
If <code>use_set = TRUE</code>, then <code>subset_patids</code> should be a dataframe with two columns, <code>patid</code> and <code>set</code>, where <code>set</code> corresponds to the number in the file name
following the word 'set'. This functionality is provided to increase computational efficiency when subsetting to a cohort of patients which is very large (millions).
This can be a computationally expensive process as each flatfile being read in, must be cross matched with a large vector .
The CPRD flatfiles are split up into groups which can be identified from their naming convention. Patients from set 1, will have their data
in DrugIssue, Observation, etc, all with the same &quot;set&quot; suffix in the flatfile name. We can utilise this to speed up the process of subsetting
the data from the flatfiles to only those with patids in subset.patid. Instead we subset to those with patids in subset_patids, and with the
corresponding value of &quot;set&quot;, which matches the suffix &quot;set&quot; in the CPRD flatfile filename. For example, patients in the Patient file which had
suffix &quot;set1&quot;, will have their medical data in the Observation file with suffix &quot;set1&quot;. When subsetting the Observation file to those in
subset_patids (our cohort), we only need to do so for patients who were also in the patient file with suffix &quot;set1&quot;.
If the cohort of patients for which you want to subset the data to is very small, the computational gains from this argument are minor and it
can be ignored.
</p>
<p>The function for reading in the .txt file will be chosen from a set of functions provided with rcprd, based on  the fletype (<code>filetype</code>).
<code>extract_txt_func</code> does not need to be specified unless wanting to manually define the function for doing this. This may be beneficial if wanting to
change variable formats, or if the variables in the .txt files change in future releases of CPRD AURUM.
</p>


<h3>Value</h3>

<p>Adds .txt file to SQLite database on hard disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data
add_to_database(filepath = system.file("aurum_data",
"aurum_allpatid_set1_extract_observation_001.txt", package = "rcprd"),
filetype = "observation", db = aurum_extract, overwrite = TRUE)

## Query database
RSQLite::dbGetQuery(aurum_extract, 'SELECT * FROM observation', n = 3)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='combine_query'>Combine a database query with a cohort.</h2><span id='topic+combine_query'></span>

<h3>Description</h3>

<p>An S3 generic function that can be used on database queries from Aurum or GOLD extracts.
Combine a database query with a cohort, only retaining observations between <code>time_prev</code> days prior to <code>indexdt</code>, and <code>time_post</code> days after
<code>indexdt</code>, and for test data with values between <code>lower_bound</code> and <code>upper_bound</code>. The most recent <code>numobs</code> observations will be returned.
<code>cohort</code> must contain variables <code>patid</code> and <code>indexdt</code>. The <code>type</code> of query must be specified for appropriate data manipulation. Input <code>type = med</code> if
interested in medical diagnoses from the observation file, and <code>type = test</code> if interseted in test data from the observation file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_query(
  db_query,
  cohort,
  query_type = c("med", "drug", "test", "hes_primary", "death"),
  time_prev = Inf,
  time_post = Inf,
  lower_bound = -Inf,
  upper_bound = Inf,
  numobs = 1,
  value_na_rm = TRUE,
  earliest_values = FALSE,
  reduce_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_query_+3A_db_query">db_query</code></td>
<td>
<p>Output from database query (ideally obtained through <code><a href="#topic+db_query">db_query</a></code>).</p>
</td></tr>
<tr><td><code id="combine_query_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to combine with the database query.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_query_type">query_type</code></td>
<td>
<p>Type of query</p>
</td></tr>
<tr><td><code id="combine_query_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_numobs">numobs</code></td>
<td>
<p>Number of observations to be returned.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_value_na_rm">value_na_rm</code></td>
<td>
<p>If TRUE will remove data with NA in the <code>value</code> column of the queried data and remove values outside of <code>lower_bound</code> and <code>upper_bound</code> when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_earliest_values">earliest_values</code></td>
<td>
<p>If TRUE will return the earliest values as opposed to most recent.</p>
</td></tr>
<tr><td><code id="combine_query_+3A_reduce_output">reduce_output</code></td>
<td>
<p>If TRUE will reduce output to just <code>patid</code>, event date, medical/product code, and test <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>value_na_rm = FALSE</code> may be of use when extracting variables like smoking status, where we want test data for number of cigarettes per day,
but do not want to remove all observations with NA in the <code>value</code> column, because the medcodeid itself may indicate smoking status.
</p>


<h3>Value</h3>

<p>A data.table with observations that meet specified criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data from all observation files in specified directory
cprd_extract(db = aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation")

## Query database for a specific medcode
db_query &lt;- db_query(db_open = aurum_extract,
tab ="observation",
codelist_vector = "187341000000114")

## Define cohort
pat&lt;-extract_cohort(filepath = system.file("aurum_data", package = "rcprd"))

### Add an index date to pat
pat$indexdt &lt;- as.Date("01/01/2020", format = "%d/%m/%Y")

## Combine query with cohort retaining most recent three records
combine_query(cohort = pat,
db_query = db_query,
query_type = "med",
numobs = 3)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='combine_query_boolean'>Combine a database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.</h2><span id='topic+combine_query_boolean'></span>

<h3>Description</h3>

<p>An S3 generic function that can be used on database queries from Aurum or GOLD extracts.
Combine a database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.
<code>cohort</code> must contain variables <code>patid</code> and <code>indexdt</code>. The database query will be merged with the cohort by variable <code>patid</code>.
If an individual has at least <code>numobs</code> observations between <code>time_prev</code> days prior to <code>indexdt</code>, and <code>time_post</code> days after
<code>indexdt</code>, a 1 will be returned, 0 otherwise. The <code>type</code> of query must be specified for appropriate data manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_query_boolean(
  db_query,
  cohort,
  query_type = c("med", "drug"),
  time_prev = Inf,
  time_post = 0,
  numobs = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_query_boolean_+3A_db_query">db_query</code></td>
<td>
<p>Output from database query (ideally obtained through <code><a href="#topic+db_query">db_query</a></code>).</p>
</td></tr>
<tr><td><code id="combine_query_boolean_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to combine with the database query.</p>
</td></tr>
<tr><td><code id="combine_query_boolean_+3A_query_type">query_type</code></td>
<td>
<p>Type of query</p>
</td></tr>
<tr><td><code id="combine_query_boolean_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_boolean_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_boolean_+3A_numobs">numobs</code></td>
<td>
<p>Number of observations required to be observed in specified time window to return a 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 0/1 vector.
</p>

<hr>
<h2 id='combine_query_boolean.aurum'>Combine a CPRD aurum database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.</h2><span id='topic+combine_query_boolean.aurum'></span>

<h3>Description</h3>

<p>An S3 method that can be used on database queries from Aurum extracts. Combine a database query with a cohort returning a 0/1 vector depending on whether each individual has a recorded code of interest.
<code>cohort</code> must contain variables <code>patid</code> and <code>indexdt</code>. The database query will be merged with the cohort by variable <code>patid</code>.
If an individual has at least <code>numobs</code> observations between <code>time_prev</code> days prior to <code>indexdt</code>, and <code>time_post</code> days after
<code>indexdt</code>, a 1 will be returned, 0 otherwise. The <code>type</code> of query must be specified for appropriate data manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aurum'
combine_query_boolean(
  db_query,
  cohort,
  query_type,
  time_prev = Inf,
  time_post = 0,
  numobs = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_query_boolean.aurum_+3A_db_query">db_query</code></td>
<td>
<p>Output from database query (ideally obtained through <code><a href="#topic+db_query">db_query</a></code>).</p>
</td></tr>
<tr><td><code id="combine_query_boolean.aurum_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to combine with the database query.</p>
</td></tr>
<tr><td><code id="combine_query_boolean.aurum_+3A_query_type">query_type</code></td>
<td>
<p>Type of query</p>
</td></tr>
<tr><td><code id="combine_query_boolean.aurum_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_boolean.aurum_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query_boolean.aurum_+3A_numobs">numobs</code></td>
<td>
<p>Number of observations required to be observed in specified time window to return a 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 0/1 vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data from all observation files in specified directory
cprd_extract(db = aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation")

## Query database for a specific medcode
db_query &lt;- db_query(db_open = aurum_extract,
tab ="observation",
codelist_vector = "187341000000114")

## Define cohort
pat&lt;-extract_cohort(filepath = system.file("aurum_data", package = "rcprd"))

### Add an index date to pat
pat$indexdt &lt;- as.Date("01/01/2020", format = "%d/%m/%Y")

## Combine query with cohort retaining most recent three records
combine_query_boolean(cohort = pat,
db_query = db_query,
query_type = "med",
numobs = 3)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='combine_query.aurum'>Combine a CPRD aurum database query with a cohort.</h2><span id='topic+combine_query.aurum'></span>

<h3>Description</h3>

<p>An S3 method that can be used on database queries from Aurum extracts.
Combine a database query with a cohort, only retaining observations between <code>time_prev</code> days prior to <code>indexdt</code>, and <code>time_post</code> days after
<code>indexdt</code>, and for test data with values between <code>lower_bound</code> and <code>upper_bound</code>. The most recent <code>numobs</code> observations will be returned.
<code>cohort</code> must contain variables <code>patid</code> and <code>indexdt</code>. The <code>type</code> of query must be specified for appropriate data manipulation. Input <code>type = med</code> if
interested in medical diagnoses from the observation file, and <code>type = test</code> if interseted in test data from the observation file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aurum'
combine_query(
  db_query,
  cohort,
  query_type,
  time_prev = Inf,
  time_post = Inf,
  lower_bound = -Inf,
  upper_bound = Inf,
  numobs = 1,
  value_na_rm = TRUE,
  earliest_values = FALSE,
  reduce_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_query.aurum_+3A_db_query">db_query</code></td>
<td>
<p>Output from database query (ideally obtained through <code><a href="#topic+db_query">db_query</a></code>).</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to combine with the database query.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_query_type">query_type</code></td>
<td>
<p>Type of query</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_numobs">numobs</code></td>
<td>
<p>Number of observations to be returned.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_value_na_rm">value_na_rm</code></td>
<td>
<p>If TRUE will remove data with NA in the <code>value</code> column of the queried data and remove values outside of <code>lower_bound</code> and <code>upper_bound</code> when <code>query_type = "test"</code>.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_earliest_values">earliest_values</code></td>
<td>
<p>If TRUE will return the earliest values as opposed to most recent.</p>
</td></tr>
<tr><td><code id="combine_query.aurum_+3A_reduce_output">reduce_output</code></td>
<td>
<p>If TRUE will reduce output to just <code>patid</code>, event date, medical/product code, and test <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>value_na_rm = FALSE</code> may be of use when extracting variables like smoking status, where we want test data for number of cigarettes per day,
but do not want to remove all observations with NA in the <code>value</code> column, because the medcodeid itself may indicate smoking status.
</p>


<h3>Value</h3>

<p>A data.table with observations that meet specified criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data from all observation files in specified directory
cprd_extract(db = aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation")

## Query database for a specific medcode
db_query &lt;- db_query(db_open = aurum_extract,
tab ="observation",
codelist_vector = "187341000000114")

## Define cohort
pat&lt;-extract_cohort(filepath = system.file("aurum_data", package = "rcprd"))

### Add an index date to pat
pat$indexdt &lt;- as.Date("01/01/2020", format = "%d/%m/%Y")

## Combine query with cohort retaining most recent three records
combine_query(cohort = pat,
db_query = db_query,
query_type = "med",
numobs = 3)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='connect_database'>Open connection to SQLite database</h2><span id='topic+connect_database'></span>

<h3>Description</h3>

<p>Open connection to SQLite database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect_database(dbname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connect_database_+3A_dbname">dbname</code></td>
<td>
<p>Name of SQLite database on hard disk (including full file path relative to working directory)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to open a database connection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect to a database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Check connection is open
inherits(aurum_extract, "DBIConnection")

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='cprd_extract'>Adds all the .txt files in a directory, with certain file names, to an SQLite database on the hard disk.</h2><span id='topic+cprd_extract'></span>

<h3>Description</h3>

<p>Add the raw data from more than one of the CPRD flatfiles to an SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cprd_extract(
  db,
  filepath,
  filetype = c("observation", "drugissue", "referral", "problem", "consultation",
    "hes_primary", "death"),
  nrows = -1,
  select = NULL,
  subset_patids = NULL,
  use_set = FALSE,
  extract_txt_func = NULL,
  str_match = NULL,
  tablename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cprd_extract_+3A_db">db</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_filepath">filepath</code></td>
<td>
<p>Path to directory containing .txt files.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_filetype">filetype</code></td>
<td>
<p>Type of CPRD Aurum file (observation, drugissue, referral, problem, consultation, hes_primary, death)</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows to read in from .txt file.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_select">select</code></td>
<td>
<p>Vector of column names to select before adding to the SQLite database.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_subset_patids">subset_patids</code></td>
<td>
<p>Patient id's to subset the .txt file on before adding to the SQLite database.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_use_set">use_set</code></td>
<td>
<p>Reduce subset_patids to just those with a corresponding set value to the .txt file being read in. Can greatly improve computational efficiency when subset_patids is large. See vignette XXXX for more details.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_extract_txt_func">extract_txt_func</code></td>
<td>
<p>User-defined function to read the .txt file into R.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_str_match">str_match</code></td>
<td>
<p>Character vector to match on when searching for file names to add to the database.</p>
</td></tr>
<tr><td><code id="cprd_extract_+3A_tablename">tablename</code></td>
<td>
<p>Name of table in SQLite database that the data will be added to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, will add files that contain <code>filetype</code> in the file name to a table named <code>filetype</code> in the SQLite database.
If <code>str_match</code> is specified, will add files that contain <code>str_match</code> in the file name to a table named <code>str_match</code> in the SQLite database.
In this case, <code>filetype</code> will still be used to choose which function reads in and formats the raw data, although this can be overwritten with
<code>extract_txt_func</code>. If argument <code>tablename</code> is specified, data will be added to a table called <code>tablename</code> in the SQLite database.
</p>
<p>Currently, rcprd only deals with <code>filetype = c("observation", "drugissue", "referral", "problem", "consultation", "hes_primary", "death")</code> by default.
However, by using <code>str_match</code> and <code>extract_txt_func</code>, the user can manually search for files with any string in the file name, and read them in
and format using a user-defined function. This means the user is not restricted to only adding the pre-defined file types to the SQLite database.
</p>
<p>If <code>use_set = FALSE</code>, then <code>subset_patids</code> should be a vector of patid's that the .txt files will be subsetted on before adding to the SQLite database.
If <code>use_set = TRUE</code>, then <code>subset_patids</code> should be a dataframe with two columns, <code>patid</code> and <code>set</code>, where <code>set</code> corresponds to the number in the file name
following the word 'set'. This functionality is provided to increase computational efficiency when subsetting to a cohort of patients which is very large (millions).
This can be a computationally expensive process as each flatfile being read in, must be cross matched with a large vector .
The CPRD flatfiles are split up into groups which can be identified from their naming convention. Patients from set 1, will have their data
in DrugIssue, Observation, etc, all with the same &quot;set&quot; suffix in the flatfile name. We can utilise this to speed up the process of subsetting
the data from the flatfiles to only those with patids in subset.patid. Instead we subset to those with patids in subset_patids, and with the
corresponding value of &quot;set&quot;, which matches the suffix &quot;set&quot; in the CPRD flatfile file name. For example, patients in the Patient file which had
suffix &quot;set1&quot;, will have their medical data in the Observation file with suffix &quot;set1&quot;. When subsetting the Observation file to those in
subset_patids (our cohort), we only need to do so for patients who were also in the patient file with suffix &quot;set1&quot;.
If the cohort of patients for which you want to subset the data to is very small, the computational gains from this argument are minor and it
can be ignored.
</p>
<p>The function for reading in the .txt file will be chosen from a set of functions provided with rcprd, based on  the filetype (<code>filetype</code>).
<code>extract_txt_func</code> does not need to be specified unless wanting to manually define the function for doing this. This may be beneficial if wanting to
change variable formats, or if the variables in the .txt files change in future releases of CPRD AURUM and rcprd has not been updated.
</p>


<h3>Value</h3>

<p>Adds .txt file to SQLite database on hard disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data from all observation files in specified directory
cprd_extract(db = aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation")

## Query database
RSQLite::dbGetQuery(aurum_extract, 'SELECT * FROM observation', n = 3)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='create_directory_system'>Create the appropriate directory system to be able to run functions without specifying hard filepaths</h2><span id='topic+create_directory_system'></span>

<h3>Description</h3>

<p>Create the appropriate directory system to be able to run functions without specifying hard filepaths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_directory_system(rootdir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_directory_system_+3A_rootdir">rootdir</code></td>
<td>
<p>Directory within which to create the directory system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, creates directory system in the specified directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create directory system compatible with rcprd's automatic saving of output
create_directory_system(tempdir())
file.exists(file.path(tempdir(),"data"))
file.exists(file.path(tempdir(),"code"))
file.exists(file.path(tempdir(),"codelists"))

## Return filespace to how it was prior to example
delete_directory_system(tempdir())

</code></pre>

<hr>
<h2 id='db_query'>Query an RSQLite database.</h2><span id='topic+db_query'></span>

<h3>Description</h3>

<p>Query an RSQLite database stored on the hard disk for observations with specific codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>db_query(
  codelist,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  db_cprd = c("aurum", "gold"),
  tab = c("observation", "drugissue", "clinical", "immunisation", "test", "therapy",
    "hes_primary", "death"),
  codelist_vector = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="db_query_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist to query the database with.</p>
</td></tr>
<tr><td><code id="db_query_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="db_query_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="db_query_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="db_query_+3A_db_cprd">db_cprd</code></td>
<td>
<p>CPRD Aurum ('aurum') or gold ('gold').</p>
</td></tr>
<tr><td><code id="db_query_+3A_tab">tab</code></td>
<td>
<p>Name of table in SQLite database that is to be queried.</p>
</td></tr>
<tr><td><code id="db_query_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>Specifying <code>codelist</code> requires a specific underlying directory structure. The codelist on the hard disk must be stored in &quot;codelists/analysis/&quot; relative
to the working directory, must be a .csv file, and contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the chosen <code>tab</code>. The codelist can
also be read in manually, and supplied as a character vector to <code>codelist_vector</code>. If <code>codelist_vector</code> is defined, this will take precedence over <code>codelist</code>.
</p>


<h3>Value</h3>

<p>A data.table with observations contained in the specified codelist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create connection to a temporary database
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Add observation data from all observation files in specified directory
cprd_extract(db = aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation")

## Query database for a specific medcode
db_query(db_open = aurum_extract,
tab ="observation",
codelist_vector = "187341000000114")

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='delete_directory_system'>Deletes directory system created by <code>delete_directory_system</code></h2><span id='topic+delete_directory_system'></span>

<h3>Description</h3>

<p>Deletes directory system created by <code>delete_directory_system</code>. Primarily used to restore
filespaces to original in examples/tests/vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_directory_system(rootdir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_directory_system_+3A_rootdir">rootdir</code></td>
<td>
<p>Directory within which to delete the directory system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, deletes directory system in the specified directory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Print current working directory
getwd()

## Create directory system
create_directory_system(tempdir())
file.exists(file.path(tempdir(),"data"))
file.exists(file.path(tempdir(),"code"))
file.exists(file.path(tempdir(),"codelists"))

## Return filespace to how it was prior to example
delete_directory_system(tempdir())
file.exists(file.path(tempdir(),"data"))
file.exists(file.path(tempdir(),"code"))
file.exists(file.path(tempdir(),"codelists"))

</code></pre>

<hr>
<h2 id='extract_bmi'>Extract most recent BMI score relative to an index date.</h2><span id='topic+extract_bmi'></span>

<h3>Description</h3>

<p>Extract most recent BMI score relative to an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_bmi(
  cohort,
  varname = NULL,
  codelist_bmi = NULL,
  codelist_weight = NULL,
  codelist_height = NULL,
  codelist_bmi_vector = NULL,
  codelist_weight_vector = NULL,
  codelist_height_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = 365.25 * 5,
  time_post = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_bmi_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to extract age for.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_varname">varname</code></td>
<td>
<p>Optional name for variable in output dataset.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_bmi">codelist_bmi</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for BMI to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_weight">codelist_weight</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for weight to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_height">codelist_height</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for height to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_bmi_vector">codelist_bmi_vector</code></td>
<td>
<p>Vector of codes for BMI to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_weight_vector">codelist_weight_vector</code></td>
<td>
<p>Vector of codes for weight to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_codelist_height_vector">codelist_height_vector</code></td>
<td>
<p>Vector of codes for height to query the database with.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable which defines index date in <code>cohort</code>.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_t">t</code></td>
<td>
<p>Number of days after index date at which to calculate variable.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to add <code>t</code> to <code>varname</code>.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_bmi_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BMI can either be identified through a directly recorded BMI score, or calculated via height and weight scores.
Full details on the algorithm for extracting BMI are given in the vignette: Details-on-algorithms-for-extracting-specific-variables.
This vignette can be viewed by running <code>vignette("help", package = "rcprd")</code>.
</p>
<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Specifying the non-vector type codelists requires a specific underlying directory structure. The codelist on the hard disk must be stored in &quot;codelists/analysis/&quot; relative
to the working directory, must be a .csv file, and contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the chosen <code>tab</code>. The input
to these variables should just be the name of the files (excluding the suffix .csv). The codelists can also be read in manually, and supplied as a
character vector. This option will take precedence over the codelists stored on the hard disk if both are specified.
</p>


<h3>Value</h3>

<p>A data frame with variable BMI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract most recent BMI prior to index date
extract_bmi(cohort = pat,
codelist_bmi_vector = "498521000006119",
codelist_weight_vector = "401539014",
codelist_height_vector = "13483031000006114",
indexdt = "indexdt",
time_prev = Inf,
db_open = aurum_extract,
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_cholhdl_ratio'>Extract most recent total cholesterol/high-density lipoprotein ratio score relative to an index date.</h2><span id='topic+extract_cholhdl_ratio'></span>

<h3>Description</h3>

<p>Extract most recent total cholesterol/high-density lipoprotein ratio score relative to an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cholhdl_ratio(
  cohort,
  varname = NULL,
  codelist_ratio = NULL,
  codelist_chol = NULL,
  codelist_hdl = NULL,
  codelist_ratio_vector = NULL,
  codelist_chol_vector = NULL,
  codelist_hdl_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = 365.25 * 5,
  time_post = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_cholhdl_ratio_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to extract age for.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_varname">varname</code></td>
<td>
<p>Optional name for variable in output dataset.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_ratio">codelist_ratio</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for ratio to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_chol">codelist_chol</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for total cholesterol to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_hdl">codelist_hdl</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for high-density lipoprotein to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_ratio_vector">codelist_ratio_vector</code></td>
<td>
<p>Vector of codes for ratio to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_chol_vector">codelist_chol_vector</code></td>
<td>
<p>Vector of codes for total cholesterol to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_codelist_hdl_vector">codelist_hdl_vector</code></td>
<td>
<p>Vector of codes for high-density lipoprotein to query the database with.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable which defines index date in <code>cohort</code>.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_t">t</code></td>
<td>
<p>Number of days after index date at which to calculate variable.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to add <code>t</code> to <code>varname</code>.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_cholhdl_ratio_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cholesterol/HDL ratio can either be identified through a directly recorded cholesterol/hdl ratio score, or calculated via total cholesterol and HDL scores.
Full details on the algorithm for extracting cholesterol/hdl ratio are given in the vignette: Details-on-algorithms-for-extracting-specific-variables.
This vignette can be viewed by running <code>vignette("help", package = "rcprd")</code>.
</p>
<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Specifying the non-vector type codelists requires a specific underlying directory structure. The codelist on the hard disk must be stored in &quot;codelists/analysis/&quot; relative
to the working directory, must be a .csv file, and contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the chosen <code>tab</code>. The input
to these variables should just be the name of the files (excluding the suffix .csv). The codelists can also be read in manually, and supplied as a
character vector. This option will take precedence over the codelists stored on the hard disk if both are specified.
</p>


<h3>Value</h3>

<p>A data frame with variable total cholesterol/high-density lipoprotein ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract most recent cholhdl_ratio prior to index date
extract_cholhdl_ratio(cohort = pat,
codelist_ratio_vector = "498521000006119",
codelist_chol_vector = "401539014",
codelist_hdl_vector = "13483031000006114",
indexdt = "indexdt",
time_prev = Inf,
db_open = aurum_extract,
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_cohort'>Create cohort from patient files</h2><span id='topic+extract_cohort'></span>

<h3>Description</h3>

<p>Create cohort from patient files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_cohort(filepath, patids = NULL, select = NULL, set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_cohort_+3A_filepath">filepath</code></td>
<td>
<p>Path to directory containing .txt files.</p>
</td></tr>
<tr><td><code id="extract_cohort_+3A_patids">patids</code></td>
<td>
<p>Patids of patients to retain in the cohort. Character vector. Numeric values should not be used.</p>
</td></tr>
<tr><td><code id="extract_cohort_+3A_select">select</code></td>
<td>
<p>Character vector of column names to select.</p>
</td></tr>
<tr><td><code id="extract_cohort_+3A_set">set</code></td>
<td>
<p>If <code>TRUE</code> will create a variable called <code>set</code> which will contain the number that comes after the word 'set' in the file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with patient information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract cohort data
pat&lt;-extract_cohort(filepath = system.file("aurum_data", package = "rcprd"))
pat

</code></pre>

<hr>
<h2 id='extract_diabetes'>Extract diabetes status prior to an index date.</h2><span id='topic+extract_diabetes'></span>

<h3>Description</h3>

<p>Extract diabetes status prior to an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_diabetes(
  cohort,
  varname = NULL,
  codelist_type1 = NULL,
  codelist_type2 = NULL,
  codelist_type1_vector = NULL,
  codelist_type2_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_diabetes_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to extract age for.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_varname">varname</code></td>
<td>
<p>Optional name for variable in output dataset.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_codelist_type1">codelist_type1</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for type 1 diabetes to query the database with.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_codelist_type2">codelist_type2</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for type 2 diabetes to query the database with.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_codelist_type1_vector">codelist_type1_vector</code></td>
<td>
<p>Vector of codes for type 1 diabetes to query the database with.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_codelist_type2_vector">codelist_type2_vector</code></td>
<td>
<p>Vector of codes for type 2 diabetes to query the database with.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable which defines index date in <code>cohort</code>.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_t">t</code></td>
<td>
<p>Number of days after index date at which to calculate variable.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to add <code>t</code> to <code>varname</code>.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_diabetes_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an individual is found to have medical codes for both type 1 and type 2 diabetes, the returned value of diabetes status will be type 1 diabetes.
Full details on the algorithm for extracting diabetes status are given in the vignette: Details-on-algorithms-for-extracting-specific-variables.
This vignette can be viewed by running <code>vignette("help", package = "rcprd")</code>.
</p>
<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Specifying the non-vector type codelists requires a specific underlying directory structure. The codelist on the hard disk must be stored in &quot;codelists/analysis/&quot; relative
to the working directory, must be a .csv file, and contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the chosen <code>tab</code>. The input
to these variables should just be the name of the files (excluding the suffix .csv). The codelists can also be read in manually, and supplied as a
character vector. This option will take precedence over the codelists stored on the hard disk if both are specified.
</p>


<h3>Value</h3>

<p>A data frame with variable diabetes status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract diabetes prior to index date
extract_diabetes(cohort = pat,
codelist_type1_vector = "498521000006119",
codelist_type2_vector = "401539014",
indexdt = "indexdt",
db_open = aurum_extract)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_ho'>Extract a 'history of' type variable</h2><span id='topic+extract_ho'></span>

<h3>Description</h3>

<p>Query an RSQLite database and return a data frame with a 0/1 vector depending on whether each individual has at least one observation with relevant code between
a specified time period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ho(
  cohort,
  varname = NULL,
  codelist = NULL,
  codelist_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = Inf,
  time_post = 0,
  numobs = 1,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  tab = c("observation", "drugissue", "hes_primary", "death"),
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_ho_+3A_cohort">cohort</code></td>
<td>
<p>Cohort of individuals to extract the 'history of' variable for.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_varname">varname</code></td>
<td>
<p>Name of variable in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist (stored on hard disk) to query the database with.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the index date. The extracted variable will be calculated relative to this.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_t">t</code></td>
<td>
<p>Number of days after <code>indexdt</code> at which to extract the variable.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to alter the variable name in the outputted data frame to reflect <code>t</code>.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_numobs">numobs</code></td>
<td>
<p>Number of obesrvations required to return a value of 1.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_tab">tab</code></td>
<td>
<p>Table name to query in SQLite database.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_ho_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convention. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Codelists can be specified in two ways. The first is to read the codelist into R as a character vector and then specify through the argument
<code>codelist_vector</code>. Codelists stored on the hard disk can also be referred to from the <code>codelist</code> argument, but require a specific underlying directory structure.
The codelist on the hard disk must be stored in a directory called &quot;codelists/analysis/&quot; relative to the working directory. The codelist must be a .csv file, and
contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the input for argument <code>tab</code>. The input to argument <code>codelist</code> should just be a character string of
the name of the files (excluding the suffix '.csv'). The <code>codelist_vector</code> option will take precedence over the <code>codelist</code> argument if both are specified.
</p>


<h3>Value</h3>

<p>A data frame with a 0/1 vector and patid. 1 = presence of code within the specified time period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract a history of type variable prior to index date
extract_ho(pat,
codelist_vector = "187341000000114",
indexdt = "fup_start",
db_open = aurum_extract,
tab = "observation",
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_smoking'>Extract smoking status prior to index date.</h2><span id='topic+extract_smoking'></span>

<h3>Description</h3>

<p>Extract smoking status prior to index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_smoking(
  cohort,
  varname = NULL,
  codelist_non = NULL,
  codelist_ex = NULL,
  codelist_light = NULL,
  codelist_mod = NULL,
  codelist_heavy = NULL,
  codelist_non_vector = NULL,
  codelist_ex_vector = NULL,
  codelist_light_vector = NULL,
  codelist_mod_vector = NULL,
  codelist_heavy_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_smoking_+3A_cohort">cohort</code></td>
<td>
<p>Cohort to extract age for.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_varname">varname</code></td>
<td>
<p>Optional name for variable in output dataset.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_non">codelist_non</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for non-smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_ex">codelist_ex</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for ex-smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_light">codelist_light</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for light smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_mod">codelist_mod</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for moderate smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_heavy">codelist_heavy</code></td>
<td>
<p>Name of codelist (stored on hard disk in &quot;codelists/analysis/&quot;) for heavy smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_non_vector">codelist_non_vector</code></td>
<td>
<p>Vector of codes for non-smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_ex_vector">codelist_ex_vector</code></td>
<td>
<p>Vector of codes for ex-smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_light_vector">codelist_light_vector</code></td>
<td>
<p>Vector of codes for light smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_mod_vector">codelist_mod_vector</code></td>
<td>
<p>Vector of codes for moderate smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_codelist_heavy_vector">codelist_heavy_vector</code></td>
<td>
<p>Vector of codes for heavy smoker to query the database with.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable which defines index date in <code>cohort</code>.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_t">t</code></td>
<td>
<p>Number of days after index date at which to calculate variable.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to add <code>t</code> to <code>varname</code>.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_smoking_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the most recent value of smoking status. If the most recently recorded observation of smoking status is non-smoker, but the individual
has a history of smoking identified through the medical record, the outputted value of smoking status will be ex-smoker.
Full details on the algorithm for extracting smoking status are given in the vignette: Details-on-algorithms-for-extracting-specific-variables.
This vignette can be viewed by running <code>vignette("help", package = "rcprd")</code>.
</p>
<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Specifying the non-vector type codelists requires a specific underlying directory structure. The codelist on the hard disk must be stored in &quot;codelists/analysis/&quot; relative
to the working directory, must be a .csv file, and contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the chosen <code>tab</code>. The input
to these variables should just be the name of the files (excluding the suffix .csv). The codelists can also be read in manually, and supplied as a
character vector. This option will take precedence over the codelists stored on the hard disk if both are specified.
</p>
<p>We take the most recent smoking status record. If an individuals most recent smoking status is a non-smoker,
but they have a history of smoking prior to this, these individuals will be classed as ex-smokers.
</p>


<h3>Value</h3>

<p>A data frame with variable smoking status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract smoking status prior to index date
extract_smoking(cohort = pat,
codelist_non_vector = "498521000006119",
codelist_ex_vector = "401539014",
codelist_light_vector = "128011000000115",
codelist_mod_vector = "380389013",
codelist_heavy_vector = "13483031000006114",
indexdt = "indexdt",
db_open = aurum_extract)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_test_data'>Extract test data.</h2><span id='topic+extract_test_data'></span>

<h3>Description</h3>

<p>Query an RSQLite database and return a data frame containing the most recent test result that meets specified criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_test_data(
  cohort,
  varname = NULL,
  codelist = NULL,
  codelist_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = Inf,
  time_post = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  numobs = 1,
  keep_numunit = FALSE,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_test_data_+3A_cohort">cohort</code></td>
<td>
<p>Cohort of individuals to extract the 'history of' variable for.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_varname">varname</code></td>
<td>
<p>Name of variable in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist (stored on hard disk) to query the database with.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the index date. The extracted variable will be calculated relative to this.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_t">t</code></td>
<td>
<p>Number of days after <code>indexdt</code> at which to extract the variable.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to alter the variable name in the outputted data frame to reflect <code>t</code>.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_numobs">numobs</code></td>
<td>
<p>Number of test results to return. Will return most recent values that are in the valid time and bound ranges.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_keep_numunit">keep_numunit</code></td>
<td>
<p>TRUE/FALSE whether to keep numunitid, medcodeid and obsdate in the outputted dataset</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_data_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Codelists can be specified in two ways. The first is to read the codelist into R as a character vector and then specify through the argument
<code>codelist_vector</code>. Codelists stored on the hard disk can also be referred to from the <code>codelist</code> argument, but require a specific underlying directory structure.
The codelist on the hard disk must be stored in a directory called &quot;codelists/analysis/&quot; relative to the working directory. The codelist must be a .csv file, and
contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the input for argument <code>tab</code>. The input to argument <code>codelist</code> should just be a character string of
the name of the files (excluding the suffix '.csv'). The <code>codelist_vector</code> option will take precedence over the <code>codelist</code> argument if both are specified.
</p>
<p>Currently only returns most recent test result. This will be updated to return more than one most recent test result if specified.
</p>


<h3>Value</h3>

<p>A data frame containing all test results that meets required criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract most recent test value prior to index date
extract_test_data(pat,
codelist_vector = "187341000000114",
indexdt = "fup_start",
db_open = aurum_extract,
time_prev = Inf,
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_test_data_var'>Extract standard deviation of all test data values over a specified time period relative to an index date.</h2><span id='topic+extract_test_data_var'></span>

<h3>Description</h3>

<p>Extract standard deviation of all test data values over a specified time period relative to an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_test_data_var(
  cohort,
  varname = NULL,
  codelist,
  codelist_vector,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = 365.25 * 5,
  time_post = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_test_data_var_+3A_cohort">cohort</code></td>
<td>
<p>Cohort of individuals to extract the 'history of' variable for.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_varname">varname</code></td>
<td>
<p>Name of variable in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist (stored on hard disk) to query the database with.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the index date. The extracted variable will be calculated relative to this.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_t">t</code></td>
<td>
<p>Number of days after <code>indexdt</code> at which to extract the variable.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to alter the variable name in the outputted data frame to reflect <code>t</code>.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_data_var_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Currently only returns most recent test result. This will be updated to return more than one most recent test result if specified.
</p>


<h3>Value</h3>

<p>A data frame containing standard deviation of test results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract standard deviation of previous test scores prior to index date
extract_test_data_var(pat,
codelist_vector = "187341000000114",
indexdt = "fup_start",
db_open = aurum_extract,
time_prev = Inf,
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_test_recent'>Extract test data.</h2><span id='topic+extract_test_recent'></span>

<h3>Description</h3>

<p>Query an RSQLite database and return a data frame containing the most recent test result that meets specified criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_test_recent(
  cohort,
  varname = NULL,
  codelist = NULL,
  codelist_vector = NULL,
  indexdt,
  t = NULL,
  t_varname = TRUE,
  time_prev = 365.25 * 5,
  time_post = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_test_recent_+3A_cohort">cohort</code></td>
<td>
<p>Cohort of individuals to extract the 'history of' variable for.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_varname">varname</code></td>
<td>
<p>Name of variable in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist (stored on hard disk) to query the database with.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the index date. The extracted variable will be calculated relative to this.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_t">t</code></td>
<td>
<p>Number of days after <code>indexdt</code> at which to extract the variable.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to alter the variable name in the outputted data frame to reflect <code>t</code>.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_time_prev">time_prev</code></td>
<td>
<p>Number of days prior to index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_time_post">time_post</code></td>
<td>
<p>Number of days after index date to look for codes.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_lower_bound">lower_bound</code></td>
<td>
<p>Lower bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_upper_bound">upper_bound</code></td>
<td>
<p>Upper bound for returned values.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_test_recent_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Codelists can be specified in two ways. The first is to read the codelist into R as a character vector and then specify through the argument
<code>codelist_vector</code>. Codelists stored on the hard disk can also be referred to from the <code>codelist</code> argument, but require a specific underlying directory structure.
The codelist on the hard disk must be stored in a directory called &quot;codelists/analysis/&quot; relative to the working directory. The codelist must be a .csv file, and
contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the input for argument <code>tab</code>. The input to argument <code>codelist</code> should just be a character string of
the name of the files (excluding the suffix '.csv'). The <code>codelist_vector</code> option will take precedence over the <code>codelist</code> argument if both are specified.
</p>
<p>Currently only returns most recent test result. This will be updated to return more than one most recent test result if specified.
</p>


<h3>Value</h3>

<p>A data frame containing most recent test result that meets required criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")

## Extract most recent test value prior to index date
extract_test_data(pat,
codelist_vector = "187341000000114",
indexdt = "fup_start",
db_open = aurum_extract,
time_prev = Inf,
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_time_until'>Extract a 'time until' type variable</h2><span id='topic+extract_time_until'></span>

<h3>Description</h3>

<p>Query an RSQLite database and a data frame with the time until first code of interest or censoring, and an event/censoring indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_time_until(
  cohort,
  varname_time = NULL,
  varname_indicator = NULL,
  codelist = NULL,
  codelist_vector = NULL,
  indexdt,
  censdt,
  censdt_lag = 0,
  t = NULL,
  t_varname = TRUE,
  db_open = NULL,
  db = NULL,
  db_filepath = NULL,
  tab = c("observation", "drugissue", "hes_primary", "death"),
  out_save_disk = FALSE,
  out_subdir = NULL,
  out_filepath = NULL,
  return_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_time_until_+3A_cohort">cohort</code></td>
<td>
<p>Cohort of individuals to extract the variable for.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_varname_time">varname_time</code></td>
<td>
<p>Name of time variable in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_varname_indicator">varname_indicator</code></td>
<td>
<p>Name of event/censoring indicator in the outputted data frame.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_codelist">codelist</code></td>
<td>
<p>Name of codelist (stored on hard disk) to query the database with.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_codelist_vector">codelist_vector</code></td>
<td>
<p>Vector of codes to query the database with. This takes precedent over <code>codelist</code> if both are specified.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_indexdt">indexdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the index date. The extracted variable will be calculated relative to this.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_censdt">censdt</code></td>
<td>
<p>Name of variable in <code>cohort</code> which specifies the censoring date.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_censdt_lag">censdt_lag</code></td>
<td>
<p>Number of days after censoring where events will still be considered, to account for delays in recording.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_t">t</code></td>
<td>
<p>Number of days after <code>indexdt</code> at which to extract the variable.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_t_varname">t_varname</code></td>
<td>
<p>Whether to alter the variable name in the outputted data frame to reflect <code>t</code>.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_db_open">db_open</code></td>
<td>
<p>An open SQLite database connection created using RSQLite::dbConnect, to be queried.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_db">db</code></td>
<td>
<p>Name of SQLITE database on hard disk (stored in &quot;data/sql/&quot;), to be queried.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_db_filepath">db_filepath</code></td>
<td>
<p>Full filepath to SQLITE database on hard disk, to be queried.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_tab">tab</code></td>
<td>
<p>Table name to query in SQLite database.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If <code>TRUE</code> will attempt to save outputted data frame to directory &quot;data/extraction/&quot;.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of &quot;data/extraction/&quot; to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full filepath and filename to save outputted data frame into.</p>
</td></tr>
<tr><td><code id="extract_time_until_+3A_return_output">return_output</code></td>
<td>
<p>If <code>TRUE</code> will return outputted data frame into R workspace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying <code>db</code> requires a specific underlying directory structure. The SQLite database must be stored in &quot;data/sql/&quot; relative to the working directory.
If the SQLite database is accessed through <code>db</code>, the connection will be opened and then closed after the query is complete. The same is true if
the database is accessed through <code>db_filepath</code>. A connection to the SQLite database can also be opened manually using <code>RSQLite::dbConnect</code>, and then
using the object as input to parameter <code>db_open</code>. After wards, the connection must be closed manually using <code>RSQLite::dbDisconnect</code>. If <code>db_open</code> is specified, this will take precedence over <code>db</code> or <code>db_filepath</code>.
</p>
<p>If <code>out_save_disk = TRUE</code>, the data frame will automatically be written to an .rds file in a subdirectory &quot;data/extraction/&quot; of the working directory.
This directory structure must be created in advance. <code>out_subdir</code> can be used to specify subdirectories within &quot;data/extraction/&quot;. These options will use a default naming convetion. This can be overwritten
using <code>out_filepath</code> to manually specify the location on the hard disk to save. Alternatively, return the data frame into the R workspace using <code>return_output = TRUE</code>
and then save onto the hard disk manually.
</p>
<p>Codelists can be specified in two ways. The first is to read the codelist into R as a character vector and then specify through the argument
<code>codelist_vector</code>. Codelists stored on the hard disk can also be referred to from the <code>codelist</code> argument, but require a specific underlying directory structure.
The codelist on the hard disk must be stored in a directory called &quot;codelists/analysis/&quot; relative to the working directory. The codelist must be a .csv file, and
contain a column &quot;medcodeid&quot;, &quot;prodcodeid&quot; or &quot;ICD10&quot; depending on the input for argument <code>tab</code>. The input to argument <code>codelist</code> should just be a character string of
the name of the files (excluding the suffix '.csv'). The <code>codelist_vector</code> option will take precedence over the <code>codelist</code> argument if both are specified.
</p>
<p>If the time until event is the same as time until censored, this will be considered an event (var_indicator = 1)
</p>
<p>If <code>dtcens.lag &gt; 0</code>, then the time until the event of interest will be the time until the minimum of the event of interest, and date of censoring.
</p>


<h3>Value</h3>

<p>A data frame with variable patid, a variable containing the time until event/censoring, and a variable containing event/censoring indicator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Connect
aurum_extract &lt;- connect_database(file.path(tempdir(), "temp.sqlite"))

## Create SQLite database using cprd_extract
cprd_extract(aurum_extract,
filepath = system.file("aurum_data", package = "rcprd"),
filetype = "observation", use_set = FALSE)

## Define cohort and add index date and censoring date
pat&lt;-extract_cohort(system.file("aurum_data", package = "rcprd"))
pat$indexdt &lt;- as.Date("01/01/1955", format = "%d/%m/%Y")
pat$fup_end &lt;- as.Date("01/01/2000", format = "%d/%m/%Y")

## Extract time until event/censoring
extract_time_until(pat,
codelist_vector = "187341000000114",
indexdt = "fup_start",
censdt = "fup_end",
db_open = aurum_extract,
tab = "observation",
return_output = TRUE)

## clean up
RSQLite::dbDisconnect(aurum_extract)
unlink(file.path(tempdir(), "temp.sqlite"))

</code></pre>

<hr>
<h2 id='extract_txt_char'>Read in txt file with all colClasses = &quot;character&quot;</h2><span id='topic+extract_txt_char'></span>

<h3>Description</h3>

<p>Read in txt file with all colClasses = &quot;character&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_char(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_char_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_char_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_char_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_cons'>Read in raw .txt consultation file</h2><span id='topic+extract_txt_cons'></span>

<h3>Description</h3>

<p>Read in raw .txt consultation file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_cons(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_cons_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_cons_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_cons_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_death'>Read in raw ONS death data file</h2><span id='topic+extract_txt_death'></span>

<h3>Description</h3>

<p>Read in raw ONS death data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_death(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_death_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_death_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_death_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_drug'>Read in raw .txt drugissue file</h2><span id='topic+extract_txt_drug'></span>

<h3>Description</h3>

<p>Read in raw .txt drugissue file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_drug(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_drug_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_drug_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_drug_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_hes_primary'>Read in raw HES primary diagnoses file</h2><span id='topic+extract_txt_hes_primary'></span>

<h3>Description</h3>

<p>Read in raw HES primary diagnoses file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_hes_primary(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_hes_primary_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_hes_primary_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_hes_primary_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_linkage'>Read in linkage eligibility file</h2><span id='topic+extract_txt_linkage'></span>

<h3>Description</h3>

<p>Read in linkage eligibility file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_linkage(filepath, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_linkage_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_linkage_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_obs'>Read in raw .txt observation file</h2><span id='topic+extract_txt_obs'></span>

<h3>Description</h3>

<p>Read in raw .txt observation file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_obs(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_obs_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_obs_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_obs_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_pat'>Read in raw .txt patient file</h2><span id='topic+extract_txt_pat'></span>

<h3>Description</h3>

<p>Read in raw .txt patient file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_pat(filepath, ..., set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_pat_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_pat_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_pat_+3A_set">set</code></td>
<td>
<p>If <code>TRUE</code> will create a variable called <code>set</code> which will contain the number that comes after the word 'set' in the file name.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_prob'>Read in raw .txt problem file</h2><span id='topic+extract_txt_prob'></span>

<h3>Description</h3>

<p>Read in raw .txt problem file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_prob(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_prob_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_prob_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_prob_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='extract_txt_ref'>Read in raw .txt referral file</h2><span id='topic+extract_txt_ref'></span>

<h3>Description</h3>

<p>Read in raw .txt referral file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_txt_ref(filepath, ..., select = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_txt_ref_+3A_filepath">filepath</code></td>
<td>
<p>File path to raw .txt file</p>
</td></tr>
<tr><td><code id="extract_txt_ref_+3A_...">...</code></td>
<td>
<p>Arguments to pass onto utils::read.table</p>
</td></tr>
<tr><td><code id="extract_txt_ref_+3A_select">select</code></td>
<td>
<p>Character vector of variable names to select</p>
</td></tr>
</table>

<hr>
<h2 id='implement_output'>Internal function to implement saving extracted variable to disk or returning into R workspace.</h2><span id='topic+implement_output'></span>

<h3>Description</h3>

<p>Will save extracted variable to disk if <code>out_save_disk = TRUE</code>. Note it relies on correct underlying structure
of directories. Will output extracted variable into R workspace if <code>return_output = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implement_output(
  variable_dat,
  varname,
  out_save_disk,
  out_subdir,
  out_filepath,
  return_output
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="implement_output_+3A_variable_dat">variable_dat</code></td>
<td>
<p>Dataset containing variable</p>
</td></tr>
<tr><td><code id="implement_output_+3A_varname">varname</code></td>
<td>
<p>Name of variable to use in filename</p>
</td></tr>
<tr><td><code id="implement_output_+3A_out_save_disk">out_save_disk</code></td>
<td>
<p>If TRUE will save output to disk</p>
</td></tr>
<tr><td><code id="implement_output_+3A_out_subdir">out_subdir</code></td>
<td>
<p>Sub-directory of data/ to save output into</p>
</td></tr>
<tr><td><code id="implement_output_+3A_out_filepath">out_filepath</code></td>
<td>
<p>Full fiilepath to save dat onto</p>
</td></tr>
<tr><td><code id="implement_output_+3A_return_output">return_output</code></td>
<td>
<p>If TRUE returns output into R workspace</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
