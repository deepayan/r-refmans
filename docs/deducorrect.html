<!DOCTYPE html><html><head><title>Help for package deducorrect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deducorrect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allTotallyUnimodular'><p>Test if a list of matrices are all unimodular</p></a></li>
<li><a href='#applyFix'><p>Apply flips and swaps to a record.</p></a></li>
<li><a href='#correctionRules'><p>Rules for deterministic correction</p></a></li>
<li><a href='#correctRounding'><p>Correct records under linear restrictions for rounding errors</p></a></li>
<li><a href='#correctSigns'><p>Correct sign errors and value interchanges in data records</p></a></li>
<li><a href='#correctTypos'><p>Correct records under linear restrictions using typographical error suggestions</p></a></li>
<li><a href='#correctWithRules'><p>Deterministic correction</p></a></li>
<li><a href='#damerauLevenshteinDistance'><p>Calculate the Damerau Levenshtein Distance between two strings</p></a></li>
<li><a href='#deducorrect-object'><p>deducorrect object</p></a></li>
<li><a href='#deducorrect-package'><p>Deductive correction methods for sign, rounding and typing errors</p></a></li>
<li><a href='#deductiveLevels'><p>Derive imputation values for categorical data</p></a></li>
<li><a href='#deductiveZeros'><p>Find out which variables can deductively be imputed with 0</p></a></li>
<li><a href='#deduImpute'><p>Deductive imputation of numerical or categorical values</p></a></li>
<li><a href='#getSignCorrection'><p>workhorse for correctSigns</p></a></li>
<li><a href='#getTypoCorrection'><p>Check record validity and suggest typo corrections</p></a></li>
<li><a href='#getUsername'><p>Get name of R user.</p></a></li>
<li><a href='#hellerTompkins'><p>Determine if a matrix is totally unimodular using Heller and Tompkins criterium.</p></a></li>
<li><a href='#imputess'><p>Impute values from solution space</p></a></li>
<li><a href='#isTotallyUnimodular'><p>Test for total unimodularity of a matrix.</p></a></li>
<li><a href='#newdeducorrect'><p>Generate an S3 <code>deducorrect</code> object</p></a></li>
<li><a href='#raghavachari'><p>Determine if a matrix is unimodular using recursive Raghavachari criterium</p></a></li>
<li><a href='#reduceMatrix'><p>Apply reduction method from Scholtus (2008)</p></a></li>
<li><a href='#scapegoat'><p>Scapegoat algorithm</p></a></li>
<li><a href='#solSpace'><p>Solution space for missing values under equality constraints</p></a></li>
<li><a href='#status'><p>Create empty status vector</p></a></li>
<li><a href='#tree'><p>Solve an optimization problem using a tree algorithm as described in Scholtus (2009)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Mark van der Loo &lt;mark.vanderloo@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Deductive Correction, Deductive Imputation, and Deterministic
Correction</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark van der Loo, Edwin de Jonge, and Sander
    Scholtus</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods for automated data cleaning where all actions are logged.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/data-cleaning/deducorrect">https://github.com/data-cleaning/deducorrect</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-15</td>
</tr>
<tr>
<td>Depends:</td>
<td>editrules (&ge; 2.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-15 06:34:59 UTC; mark</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-15 13:23:47</td>
</tr>
</table>
<hr>
<h2 id='allTotallyUnimodular'>Test if a list of matrices are all unimodular</h2><span id='topic+allTotallyUnimodular'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+raghavachari">raghavachari</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTotallyUnimodular(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allTotallyUnimodular_+3A_l">L</code></td>
<td>
<p>A list of objects of class matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of length <code>length(L)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>
</p>

<hr>
<h2 id='applyFix'>Apply flips and swaps to a record.</h2><span id='topic+applyFix'></span>

<h3>Description</h3>

<p>Apply flips and swaps to a record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyFix(flips, swaps, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyFix_+3A_flips">flips</code></td>
<td>
<p>Index vector in r. r will be sign-flipped at flips</p>
</td></tr>
<tr><td><code id="applyFix_+3A_swaps">swaps</code></td>
<td>
<p>nx2 matrix denoting value swaps in r.</p>
</td></tr>
<tr><td><code id="applyFix_+3A_r">r</code></td>
<td>
<p>numerical record.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>r, with flips and swaps applied
</p>

<hr>
<h2 id='correctionRules'>Rules for deterministic correction</h2><span id='topic+as.character.correctionRules'></span><span id='topic+correctionRules'></span><span id='topic+correctionRules.character'></span><span id='topic+correctionRules.expression'></span><span id='topic+getVars.correctionRules'></span><span id='topic+print.correctionRules'></span>

<h3>Description</h3>

<p>Rules for deterministic correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionRules(x, strict = TRUE, allowed = getOption("allowedSymbols"),
  ...)

## S3 method for class 'character'
correctionRules(x, strict = TRUE,
  allowed = getOption("allowedSymbols"), file = TRUE, ...)

## S3 method for class 'expression'
correctionRules(x, strict = TRUE,
  allowed = getOption("allowedSymbols"), ...)

## S3 method for class 'correctionRules'
print(x, ...)

## S3 method for class 'correctionRules'
as.character(x, oneliner = FALSE, ...)

## S3 method for class 'correctionRules'
getVars(E, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctionRules_+3A_x">x</code></td>
<td>
<p><code>character</code> or <code>expression</code> vector.</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code> an error is thrown if any forbidden symbol is used (see details).</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_allowed">allowed</code></td>
<td>
<p>A <code>character</code> vector of allowed symbols</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_file">file</code></td>
<td>
<p>If <code>file=TRUE</code>, <code>x</code> is treated as a filename from which the rules are read.</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_oneliner">oneliner</code></td>
<td>
<p>Coerce to oneliner</p>
</td></tr>
<tr><td><code id="correctionRules_+3A_e">E</code></td>
<td>
<p>object of class <code><a href="#topic+correctionRules">correctionRules</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>correctionRules</code> returns an object of class <code>correctionRules</code>
</p>
<p><code>getVars</code> returns a character vector of variable names.
</p>


<h3>Details</h3>

<p>Data editing processes are rarely completely governed by in-record consistency rules.
Many <em>ad-hoc</em> rules are commonly used to impute empty or erroneous values.
Such rules are often applied manually or hidden in source code. This
function, together with <code><a href="#topic+correctWithRules">correctWithRules</a></code> allows for easy definition and execution
of simle deterministic replacement rules.
</p>
<p>These functions are ment to support very simple rules, such as <em>if variable x is missing, then
set it to zero</em>. Such actions usually basically model-free corrections stemming from subject-matter knowledge.
Given the nature of such rules, the type of rules are by default limited to R-statements containing
conditionals (<code>if</code>-<code>else</code>), arithmetic and logical operators, and brackets and assignment operators.
see <code>getOption('allowedSymbols')</code> for a complete list.
</p>
<p>If you cannot execute your 'simple' corrections with just these functions, we strongly recommend to
write a separate imputation or correction routine. However, it's a free world, so you may alter the list of allowed symbols
as you wish.
</p>


<h3>Note</h3>

<p><code>getVars</code> is overloaded from the <code>editrules</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctWithRules">correctWithRules</a></code>
</p>

<hr>
<h2 id='correctRounding'>Correct records under linear restrictions for rounding errors</h2><span id='topic+correctRounding'></span><span id='topic+correctRounding.editmatrix'></span><span id='topic+correctRounding.editset'></span>

<h3>Description</h3>

<p>This algorithm tries to detect and repair records that violate linear (in)equality constraints by correcting possible rounding errors as described by Scholtus(2008).
Typically data is constrainted by <code class="reqn">Rx=a</code> and <code class="reqn">Qx \ge b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctRounding(E, dat, ...)

## S3 method for class 'editset'
correctRounding(E, dat, ...)

## S3 method for class 'editmatrix'
correctRounding(E, dat, fixate = NULL, delta = 2,
  K = 10, round = TRUE, assumeUnimodularity = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctRounding_+3A_e">E</code></td>
<td>
<p><code>editmatrix</code> or <code>editset</code> as generated by the <code>editrules</code> package.</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> with the data to be corrected</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_fixate">fixate</code></td>
<td>
<p><code>character</code> with variable names that should not be changed.</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_delta">delta</code></td>
<td>
<p>tolerance on checking for rounding error</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_k">K</code></td>
<td>
<p>number of trials per record. See details</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_round">round</code></td>
<td>
<p>should the solution be rounded, default TRUE</p>
</td></tr>
<tr><td><code id="correctRounding_+3A_assumeunimodularity">assumeUnimodularity</code></td>
<td>
<p>If <code>FALSE</code>, a test is performed before corrections are computed (expensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm first finds violated constraints
<code class="reqn">|r'_{i}x-a_i| &gt; 0</code> , and selects edits that may be due to a rounding error <code class="reqn">0 &lt; |r'_{i}x-a_i| \leq \delta</code>.
The algorithm then makes a correction suggestion where the errors are attributed to randomly selected variables under the lineair equality constraints.
It checks if the suggested correction
does not violate the inequality matrix <code class="reqn">Q</code>. If it does, it will try to generate a different solution up till <code>K</code> times.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+deducorrect-object">deducorrrect</a></code> object.
</p>


<h3>References</h3>

<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Statistics Netherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deducorrect-object">deducorrect-object</a></code> <code><a href="#topic+status">status</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- editmatrix(expression( 
    x1 + x2 == x3,
    x2 == x4,
    x5 + x6  + x7 == x8,
    x3 + x8 == x9,
    x9 - x10 == x11
    )
)

dat &lt;- data.frame( x1=12
                 , x2=4
                 , x3=15
                 , x4=4
                 , x5=3
                 , x6=1
                 , x7=8
                 , x8=11
                 , x9=27
                 , x10=41
                 , x11=-13
                 )

sol &lt;- correctRounding(E, dat)


# example with editset
for ( d in dir("../pkg/R/",full.names=TRUE) ) dmp &lt;- source(d)
E &lt;- editmatrix(expression(
    x + y == z,
    x &gt;= 0,
    y &gt;= 0,
    z &gt;= 0,
    if ( x &gt; 0 ) y &gt; 0
    ))
dat &lt;- data.frame(
    x = 1,
    y = 0,
    z = 1)
# solutions causing new violations of conditional rules are rejected 
sol &lt;- correctRounding(E,dat)

# An example with editset
E &lt;- editset(expression(
    x + y == z,
    x &gt;= 0,
    y &gt; 0,
    y &lt; 2,
    z &gt; 1,
    z &lt; 3,
    A %in% c('a','b'),
    B %in% c('c','d'),
    if ( A == 'a' ) B == 'b',
    if ( B == 'b' ) x &lt; 1
))
dat &lt;- data.frame(
    x = 0,
    y = 1,
    z = 2,
    A = 'a',
    B = 'b'
)

correctRounding(E,dat)    

</code></pre>

<hr>
<h2 id='correctSigns'>Correct sign errors and value interchanges in data records</h2><span id='topic+correctSigns'></span><span id='topic+correctSigns.editmatrix'></span><span id='topic+correctSigns.editset'></span>

<h3>Description</h3>

<p>Correct sign errors and value interchanges in data records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctSigns(E, dat, ...)

## S3 method for class 'editset'
correctSigns(E, dat, ...)

## S3 method for class 'editmatrix'
correctSigns(E, dat, flip = getVars(E), swap = list(),
  maxActions = length(flip) + length(swap), maxCombinations = 1e+05,
  eps = sqrt(.Machine$double.eps), weight = rep(1, length(flip) +
  length(swap)), fixate = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctSigns_+3A_e">E</code></td>
<td>
<p>An object of class <code><a href="editrules.html#topic+editmatrix">editmatrix</a></code></p>
</td></tr>
<tr><td><code id="correctSigns_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code>, the records to correct.</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_flip">flip</code></td>
<td>
<p>A <code>character</code> vector of variable names who's values may be sign-flipped</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_swap">swap</code></td>
<td>
<p>A <code>list</code> of <code>character</code> 2-vectors of variable combinations who's values may be swapped</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_maxactions">maxActions</code></td>
<td>
<p>The maximum number of flips and swaps that may be performed</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_maxcombinations">maxCombinations</code></td>
<td>
<p>The number of possible flip/swap combinations in each step of the algorithm is <code>choose(n,k)</code>, with <code>n</code>
the number of <code>flips+swaps</code>, and <code>k</code> the number of actions taken in that step. If <code>choose(n,k)</code> exceeds <code>maxCombinations</code>,
the algorithm returns a record uncorrected.</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_eps">eps</code></td>
<td>
<p>Tolerance to check equalities against. Use this to account for sign errors masked by rounding errors.</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_weight">weight</code></td>
<td>
<p>weight vector. Weights can be assigned either to actions (flips and swap) or to variables.
If <code>length(weight)==length(flip)+length(swap)</code>, weights are assiged to actions, if <code>length(weight)==ncol(E)</code>, weights
are assigned to variables. In the first case, the first <code>length{flip}</code> weights correspond to flips, the rest to swaps.
A warning is issued in the second case when the weight vector is not named. See the examples for more details.</p>
</td></tr>
<tr><td><code id="correctSigns_+3A_fixate">fixate</code></td>
<td>
<p>a <code>character</code> vector with names of variables whos values may not be changed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm tries to correct records violating linear equalities by sign flipping and/or value interchanges.
Linear inequalities are taken into account when judging possible solutions. If one or more inequality restriction
is violated, the solution is rejected. It is important to note that the <code><a href="#topic+status">status</a></code> of a record has
the following meaning:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>valid</code> </td><td style="text-align: left;"> The record obeys all equality constraints on entry. No error correction is performed. </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> It may therefore still contain inequality errors.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>corrected</code> </td><td style="text-align: left;"> Equality errors were found, and all of them are solved without violating inequalities.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>partial</code></td><td style="text-align: left;"> Does not occur</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>invalid</code> </td><td style="text-align: left;"> The record contains equality violations which could not be solved with this algorithm</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>NA</code> </td><td style="text-align: left;"> record could not be checked. It contained missings.
</td>
</tr>

</table>

<p>The algorithm applies all combinations of (user-allowed) flip- and swap combinations to find a solution, and minimizes
the number of actions (flips+swaps) that have to be taken to correct a record. When multiple solutions are found, the
solution of minimal weight is chosen. The user may provide a weight vector with weights for every flip and every swap,
or a named weight vector with a weight for every variable. If the weights do not single out a solution, the first one
found is chosen.
</p>
<p>If arguments <code>flip</code> or <code>swap</code> contain a variable not in <code>E</code>, these variables will be ignored by the algorithm.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+deducorrect-object">deducorrect-object</a></code>. The <code>status</code> slot has the following columns for every records in <code>dat</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
     <code>status</code></td><td style="text-align: left;"> a <code><a href="#topic+status">status</a></code> factor, showing the status of the treated record.</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>degeneracy</code></td><td style="text-align: left;"> the number of solutions found, <em>after</em> applying the weight</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>weight</code></td><td style="text-align: left;"> the weight of the chosen solution</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>nflip</code></td><td style="text-align: left;"> the number of applied sign flips</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>nswap</code></td><td style="text-align: left;"> the number of applied value interchanges</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>References</h3>

<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Netherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deducorrect-object">deducorrect-object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# some data 
dat &lt;- data.frame(
    x = c( 3,14,15,  1, 17,12.3),
    y = c(13,-4, 5,  2,  7, -2.1),
    z = c(10,10,-10, NA,10,10 ))
# ... which has to obey
E &lt;- editmatrix(c("z == x-y"))

# All signs may be flipped, no swaps.

correctSigns(E, dat)

# Allow for rounding errors
correctSigns(E, dat, eps=2)

# Limit the number of combinations that may be tested 
correctSigns(E, dat, maxCombinations=2)

# fix z, flip everything else
correctSigns(E, dat,fixate="z")

# the same result is achieved with
correctSigns(E, dat, flip=c("x","y"))

# make x and y swappable, allow no flips
correctSigns(E, dat, flip=c(), swap=list(c("x","y")))

# make x and y swappable, swap a counts as one flip
correctSigns(E, dat, flip="z", swap=list(c("x","y")))

# same, but now, swapping is preferred (has lower weight)
correctSigns(E, dat, flip="z", swap=list(c("x","y")), weight=c(2,1))

# same, but now becayse x any y carry lower weight. Also allow for rounding errors
correctSigns(E, dat, flip="z", swap=list(c("x","y")), eps=2, weight=c(x=1, y=1, z=3))

# demand that solution has y&gt;0
E &lt;- editmatrix(c("z==x-y", "y&gt;0"))
correctSigns(E,dat)

# demand that solution has y&gt;0, taking acount of roundings in equalities
correctSigns(E,dat,eps=2)

# example with editset
E &lt;- editset(expression(
    x + y == z,
    x &gt;= 0,
    y &gt; 0,
    y &lt; 2,
    z &gt; 1,
    z &lt; 3,
    A %in% c('a','b'),
    B %in% c('c','d'),
    if ( A == 'a' ) B == 'b',
    if ( B == 'b' ) x &lt; 1
))

x &lt;- data.frame(
    x = -1,
    y = 1,
    z = 2,
    A = 'a',
    B = 'b'
)

correctSigns(E,x)



   
   
</code></pre>

<hr>
<h2 id='correctTypos'>Correct records under linear restrictions using typographical error suggestions</h2><span id='topic+correctTypos'></span><span id='topic+correctTypos.editmatrix'></span><span id='topic+correctTypos.editset'></span>

<h3>Description</h3>

<p>This algorithm tries to detect and repair records that violate linear equality constraints by correcting simple typo's as described in Scholtus (2009).
The implemention of the detection of typing errors differs in that it uses the restricted Damerau-Levensthein distance. Furthermore it solves a broader class of
problems: the original paper describes the class of equalities: <code class="reqn">Ex=0</code> (balance edits) and this implementation allows for  <code class="reqn">Ex=a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctTypos(E, dat, ...)

## S3 method for class 'editset'
correctTypos(E, dat, ...)

## S3 method for class 'editmatrix'
correctTypos(E, dat, fixate = NULL, cost = c(1, 1, 1,
  1), eps = sqrt(.Machine$double.eps), maxdist = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctTypos_+3A_e">E</code></td>
<td>
<p><code>editmatrix</code> or <code>editset</code></p>
</td></tr>
<tr><td><code id="correctTypos_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code> with data to be corrected.</p>
</td></tr>
<tr><td><code id="correctTypos_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
<tr><td><code id="correctTypos_+3A_fixate">fixate</code></td>
<td>
<p><code>character</code> with variable names that should not be changed.</p>
</td></tr>
<tr><td><code id="correctTypos_+3A_cost">cost</code></td>
<td>
<p>for a deletion, insertion, substition or transposition.</p>
</td></tr>
<tr><td><code id="correctTypos_+3A_eps">eps</code></td>
<td>
<p><code>numeric</code>, tolerance on edit check. Default value is <code>sqrt(.Machine$double.eps)</code>. Set to 2
to allow for rounding errors. Set this parameter to 0 for exact checking.</p>
</td></tr>
<tr><td><code id="correctTypos_+3A_maxdist">maxdist</code></td>
<td>
<p><code>numeric</code>, tolerance used in finding typographical corrections. Default value 1 allows for one error. Used in combination with <code>cost</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each row in <code>dat</code> the correction algorithm first detects if row <code>x</code> violates the equality constraints of <code>E</code> taking possible rounding errors into account.
Mathematically:
<code class="reqn">|\sum_{i=1}^nE_{ji}x_i - a_j| \leq \varepsilon,\quad \forall j </code>
</p>
<p>It then generates correction suggestions by deriving alternative values for variables only involved in the violated edits. The correction suggestions must be within a typographical
edit distance (default = 1) to be selected. If there are more then 1 solutions possible the algorithm tries to derive a partial solution, otherwise the solution is applied to the data.
</p>
<p><code>correctTypos</code> returns an object of class <code><a href="#topic+deducorrect-object">deducorrect</a></code> object describing the status of the record and the corrections that have been applied.
</p>
<p>Inequalities in editmatrix <code>E</code> will be ignored in this algorithm, so if this is the case, the corrected records
are valid according to the equality restrictions, but may be incorrect for the given inequalities.
</p>
<p>Please note that if the returned status of a record is &quot;partial&quot; the corrected record still is not valid.
The partially corrected record will contain less errors and will violate less constraints.
Also note that the status &quot;valid&quot; and &quot;corrected&quot; have to be interpreted in combination with <code>eps</code>.
A common scenario is first to correct for typo's and then correct for rounding errors. This means that in the first
step the algorithm should allow for typo's (e.g. <code>eps==2</code>). The returned &quot;valid&quot;  record therefore may still contain
rounding errors.
</p>


<h3>Value</h3>

<p><code><a href="#topic+deducorrect-object">deducorrect</a></code> object with corrected data.frame, applied corrections and status of the records.
</p>


<h3>References</h3>

<p>Scholtus S (2009). Automatic correction of simple typing errors in numerical data with balance edits.
Discussion paper 09046, Statistics Netherlands, The Hague/Heerlen.
</p>
<p>Damerau F (1964). A technique for computer detection and correction of
spelling errors. Communications of the ACM, 7,issue 3
</p>
<p>Levenshtein VI (1966). Binary codes capable of correcting deletions, insertions,
and reversals. Soviet Physics Doklady 10: 707-10
</p>
<p>A good description of the restricted DL-distance can be found on wikipedia: http://en.wikipedia.org/wiki/Damerau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+damerauLevenshteinDistance">damerauLevenshteinDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(editrules)

# example from section 4 in Scholtus (2009)

E &lt;- editmatrix( c("x1 + x2 == x3"
                  ,"x2 == x4"
                  ,"x5 + x6 + x7 == x8"
                  ,"x3 + x8 == x9"
                  ,"x9 - x10 == x11"
                  )
               )

dat &lt;- read.csv(txt&lt;-textConnection(
"    , x1, x2 , x3  , x4 , x5 , x6, x7, x8 , x9   , x10 , x11
4  , 1452, 116, 1568, 116, 323, 76, 12, 411,  1979, 1842, 137
4.1, 1452, 116, 1568, 161, 323, 76, 12, 411,  1979, 1842, 137
4.2, 1452, 116, 1568, 161, 323, 76, 12, 411, 19979, 1842, 137
4.3, 1452, 116, 1568, 161,   0,  0,  0, 411, 19979, 1842, 137
4.4, 1452, 116, 1568, 161, 323, 76, 12,   0, 19979, 1842, 137"
))
close(txt)
(cor &lt;- correctTypos(E,dat))



# example with editset
E &lt;- editset(expression(
    x + y == z,
    x &gt;= 0,
    y &gt; 0,
    y &lt; 2,
    z &gt; 1,
    z &lt; 3,
    A %in% c('a','b'),
    B %in% c('c','d'),
    if ( A == 'a' ) B == 'b',
    if ( B == 'b' ) x &gt; 3
))

x &lt;- data.frame(
    x = 10,
    y = 1,
    z = 2,
    A = 'a',
    B = 'b'
)

correctTypos(E,x)


</code></pre>

<hr>
<h2 id='correctWithRules'>Deterministic correction</h2><span id='topic+correctWithRules'></span>

<h3>Description</h3>

<p>Apply simple replacement rules to a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctWithRules(rules, dat, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctWithRules_+3A_rules">rules</code></td>
<td>
<p>object of class <code><a href="#topic+correctionRules">correctionRules</a></code></p>
</td></tr>
<tr><td><code id="correctWithRules_+3A_dat">dat</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="correctWithRules_+3A_strict">strict</code></td>
<td>
<p>If <code>TRUE</code>, an error is produced when the rules use variables other than in the <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with altered data (<code>$corrected</code>) and a list of alterations (<code>$corrections</code>).
</p>


<h3>Details</h3>

<p>This function applies the the <code>rules</code> one by one to <code>dat</code> and logs
their actions. Rules are excuted in order of occurrence in the <code><a href="#topic+correctionRules">correctionRules</a></code>
so order may matter for the final result. Rules are applied to one record at the time, so
the use of statistical funtions such as <code>mean</code> is useless, and forbidden by default.
See <code><a href="#topic+correctionRules">correctionRules</a></code> for details on the type of rules that are possible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctionRules">correctionRules</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some example data
dat &lt;- data.frame(
   x = c(NA, 2, 0,-10),
   y = c(1, NA,NA, 6)
)

## a few rules
u &lt;- correctionRules(expression(
   if ( is.na(x) ) x &lt;- 0,
   if ( x == 0 &amp;&amp; is.na(y) ) y &lt;- 0,
   if ( is.na(y) ) y &lt;- 1,
   if ( x &lt; 0 ) y &lt;- 0
))

correctWithRules(u,dat)
</code></pre>

<hr>
<h2 id='damerauLevenshteinDistance'>Calculate the Damerau Levenshtein Distance between two strings</h2><span id='topic+damerauLevenshteinDistance'></span>

<h3>Description</h3>

<p>The restricted Damerau Levenshtein Distance between two strings is commonly used for checking typographical errors in strings.
It takes the deletion and insertion of a character, a wrong character (substition) or the swapping (transposition)
of two characters into account. By default these operations each account for distance 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>damerauLevenshteinDistance(sa, sb, w = c(1, 1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="damerauLevenshteinDistance_+3A_sa">sa</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="damerauLevenshteinDistance_+3A_sb">sb</code></td>
<td>
<p>character vector of equal <code>length(sa)</code></p>
</td></tr>
<tr><td><code id="damerauLevenshteinDistance_+3A_w">w</code></td>
<td>
<p>integer vector for cost of deletion, insertion, substitution
and transposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with pairwise edit distances
</p>


<h3>References</h3>

<p>Damerau F (1964). A technique for computer detection and correction of
spelling errors. Communications of the ACM, 7,issue 3
</p>
<p>Levenshtein VI (1966). Binary codes capable of correcting deletions, insertions,
and reversals. Soviet Physics Doklady 10: 707-10
Damerau Levenshtein Distance calculates the difference between two strings
used for typographical errors (typo's)
</p>

<hr>
<h2 id='deducorrect-object'>deducorrect object</h2><span id='topic+deducorrect-object'></span>

<h3>Description</h3>

<p>deducorrect object
</p>


<h3>Details</h3>

<p>All <code>correct*</code> functions of the deducorrect package return an S3 object of class <code>deducorrect</code>.
The &quot;public slots&quot; are
</p>

<ul>
<li><p><code>corrected</code> A copy of the input <code>data.frame</code>, with records corrected where possible.
</p>
</li>
<li><p><code>corrections</code> A data.frame with the following colums:
</p>

<ul>
<li><p><code>row</code> Row number where correction was applied
</p>
</li>
<li><p><code>variable</code> Variable name where correction was applied
</p>
</li>
<li><p><code>old</code> Old value of adapted variable
</p>
</li>
<li><p><code>new</code> New value of adapted variable
</p>
</li></ul>

</li>
<li><p><code>status</code> A <code>data.frame</code> with the same number of rows as <code>corrected</code>. It has at least
a column called <code><a href="#topic+status">status</a></code>. Further columns might be present, depending on the used correction function.
</p>
</li>
<li><p><code>generatedby</code> The name of the function that called <code><a href="#topic+newdeducorrect">newdeducorrect</a></code> to construct the object.
</p>
</li>
<li><p><code>timestamp</code> The time and date when the object was generated, as returned by <code><a href="base.html#topic+date">date</a></code>.
</p>
</li>
<li><p><code>user</code> The system's username of the user running R. Note that this may yield unexpected results when R accessed on a remote (web)server.
</p>
</li></ul>


<hr>
<h2 id='deducorrect-package'>Deductive correction methods for sign, rounding and typing errors</h2><span id='topic+deducorrect-package'></span>

<h3>Description</h3>

<p>Deductive correction methods for sign, rounding and typing errors
It also contains functionality to check if a matrix of linear restrictions is
totally unimodular. See also
</p>


<h3>Details</h3>


<ul>
<li><p><code><a href="#topic+correctRounding">correctRounding</a></code>
</p>
</li>
<li><p><code><a href="#topic+correctTypos">correctTypos</a></code>
</p>
</li>
<li><p><code><a href="#topic+deducorrect-object">deducorrect-object</a></code> and <code><a href="#topic+status">status</a></code> for output specification
</p>
</li>
<li><p><code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>
</p>
</li>
<li><p><code><a href="#topic+deduImpute">deduImpute</a></code>
</p>
</li>
<li><p><code><a href="#topic+solSpace">solSpace</a></code>, <code><a href="#topic+imputess">imputess</a></code>
</p>
</li>
<li><p><code><a href="#topic+deductiveZeros">deductiveZeros</a></code>
</p>
</li>
<li><p><code><a href="#topic+deductiveLevels">deductiveLevels</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
require(editrules)

# some data 
dat &lt;- data.frame(
    x = c( 3, 14, 15),
    y = c(13, -4,  5),
    z = c(10, 10,-10))

dat
# ... which has to obey
E &lt;- editmatrix("z == x-y")


# All signs may be flipped, no swaps.
 correctSigns(E, dat)

correctTypos(E, dat)

correctRounding(E, dat)
</code></pre>

<hr>
<h2 id='deductiveLevels'>Derive imputation values for categorical data</h2><span id='topic+deductiveLevels'></span>

<h3>Description</h3>

<p>Deduce imputation values for categorical data. By substituting all known
values and interatively eliminating the unknowns from the set of edits,
unique imputation values are derived where possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deductiveLevels(E, x, adapt = rep(FALSE, length(x)),
  checkFeasibility = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deductiveLevels_+3A_e">E</code></td>
<td>
<p>editarray</p>
</td></tr>
<tr><td><code id="deductiveLevels_+3A_x">x</code></td>
<td>
<p>a named <code>character</code> vector</p>
</td></tr>
<tr><td><code id="deductiveLevels_+3A_adapt">adapt</code></td>
<td>
<p>boolean vector indicating which variables may be adapted.</p>
</td></tr>
<tr><td><code id="deductiveLevels_+3A_checkfeasibility">checkFeasibility</code></td>
<td>
<p>Test wether the assumed-correct values (observed and not designated by adapt) can lead to a consistent record.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation values are derived for missing variables (NA) and for variables indicated by 'adapt'.
</p>


<h3>Value</h3>

<p>A named vector with imputation values for <code>x</code>
</p>


<h3>References</h3>

<p>T. De Waal, J. Pannekoek and S. Scholtus (2011) Handbook of statistical data editing
Chpt 9.2.1 - 9.2.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a simple example. We know the subject is pregnant. What is the gender?
E &lt;- editarray(c(
    "gender \%in\% c('male','female')",
    "pregnant \%in\% c(TRUE,FALSE)",
    "if ( gender=='male') !pregnant"))
# a record with unknown gender
x &lt;- c(gender=NA,pregnant=TRUE)

# find imputations
(s &lt;- deductiveLevels(E,x))

# imputation can be done as follows:
x[names(s)] &lt;- s



# Here's an example from De Waal et al (2011) (ex. 9.3)
E &lt;- editarray(c(
    "x1 \%in\% letters[1:4]",
    "x2 \%in\% letters[1:3]",
    "x3 \%in\% letters[1:3]",
    "x4 \%in\% letters[1:2]",
    "if (x2 == 'c'  &amp; x3 != 'c' &amp; x4 == 'a' ) FALSE",
    "if (x2 != 'a'  &amp; x4 == 'b') FALSE",
    "if (x1 != 'c'  &amp; x2 != 'b' &amp; x3 != 'a') FALSE",
    "if (x1 == 'c'  &amp; x3 != 'a' &amp; x4 == 'a' ) FALSE"
))

x &lt;- c(x1='c',x2='b',x3=NA,x4=NA)
(s &lt;- deductiveLevels(E,x))

x[names(s)] &lt;- s


# another example, partial imputation
y &lt;- c(x1=NA,x2=NA,x3=NA,x4='b')
(s &lt;- deductiveLevels(E,y))

y[names(s)] &lt;- s



</code></pre>

<hr>
<h2 id='deductiveZeros'>Find out which variables can deductively be imputed with 0</h2><span id='topic+deductiveZeros'></span><span id='topic+deductiveZeros.editmatrix'></span><span id='topic+deductiveZeros.matrix'></span>

<h3>Description</h3>

<p>Find out which variables can deductively be imputed with 0
</p>
<p>Interface for deductiveZeros for objects of class editmatrix. This interface
is robust for variables in <code>x</code> not occuring in <code>E</code>.
</p>
<p>Suppose <code class="reqn">x</code> is a record under linear constraints <code class="reqn">Ax=b</code> and <code class="reqn">x\geq0</code>.
In certain cases some missing values can be imputed uniquely with zeros. For example,
in the case that <code class="reqn">x_1+x_2=x_3</code>, if <code class="reqn">x_2</code> is missing and <code class="reqn">x_1=x_3\geq 0</code>,
then <code class="reqn">x_2</code> is uniquely determined to be 0. This function returns a boolean
vector indicating which of the missing values are uniquely determined to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deductiveZeros(E, x, ...)

## S3 method for class 'editmatrix'
deductiveZeros(E, x, ...)

## S3 method for class 'matrix'
deductiveZeros(E, x, b, adapt = logical(length(x)),
  nonneg = rep(TRUE, length(x)), roundNearZeros = TRUE,
  tol = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deductiveZeros_+3A_e">E</code></td>
<td>
<p><code>editmatrix</code> or Equality constraint matrix.</p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_x">x</code></td>
<td>
<p>named numeric vector. Naming is optional if <code>E</code> is an equality constraint matrix.</p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to <code>deductiveZeros,matrix</code></p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_b">b</code></td>
<td>
<p>Equality constraint constant vector</p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_adapt">adapt</code></td>
<td>
<p>logical vector. Extra values to adapt, order must be the same as in <code>x</code></p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_nonneg">nonneg</code></td>
<td>
<p>logical vector of length(x). Determines which x-values have to obey nonnegativity constraints.</p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_roundnearzeros">roundNearZeros</code></td>
<td>
<p>Round near zero values of <code>A</code> before determining the sign?</p>
</td></tr>
<tr><td><code id="deductiveZeros_+3A_tol">tol</code></td>
<td>
<p>tolerance used for zero-rounding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is some added flexibility. Users my define 'extra missings' by specifying the <code>adapt</code> vector.
</p>
<p>By default it is assumed that all values must obey the nonnegativity constraint. However this
can be determined by specifying <code>nonneg</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deduImpute">deduImpute</a></code>, <code><a href="#topic+solSpace">solSpace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a simple example"
E &lt;- editmatrix(c(
    "x1 + x2 + x3 == xt",
    "x1 &gt;= 0", "x2&gt;=0","x3&gt;=0", "xt&gt;=0"))
x &lt;- c(x1=10,x2=NA,x3=5,xt=15)

# with deductiveZeros we get:
( I &lt;- deductiveZeros(E,x) )
x[I] &lt;- 0

any(violatedEdits(E,x))

# This example is taken from De Waal et al (2011) (Examples 9.1-9.2)
E &lt;- editmatrix(c(
    "x1 + x2      == x3",
    "x2           == x4",
    "x5 + x6 + x7 == x8",
    "x3 + x8      == x9",
    "x9 - x10     == x11",
    "x6 &gt;= 0",
    "x7 &gt;= 0"
))

x &lt;- c(
  x1 = 145, 
  x2 = NA, 
  x3 = 155, 
  x4 = NA, 
  x5 = 86, 
  x6 = NA, 
  x7 = NA, 
  x8 = 86, 
  x9 = NA, 
  x10 = 217, 
  x11 = NA)

# determine zeros:
I &lt;- deductiveZeros(E,x)
# impute:
x[I] &lt;- 0



</code></pre>

<hr>
<h2 id='deduImpute'>Deductive imputation of numerical or categorical values</h2><span id='topic+deduImpute'></span><span id='topic+deduImpute.editarray'></span><span id='topic+deduImpute.editmatrix'></span><span id='topic+deduImpute.editset'></span>

<h3>Description</h3>

<p>Based on observed values and edit rules, impute as many variables deductively as possible.
</p>
<p>If <code>E</code> is an <code>editset</code>, imputation based on numerical rules (if any) is performed,
and imputations violating extra edits are reverted. Next, this procedure is repeated for
pure categorical rules. The results are combined and returned in a <code>deducorrect</code> object.
</p>
<p><b>For categorical data:</b> The funcion <code><a href="#topic+deductiveLevels">deductiveLevels</a></code> is used to derive
deductive imputations for as many fields as possible
</p>
<p><b>For numerical data:</b> Given (equality) rules and a number of values to impute or adapt, in some cases
unique solutions can be derived. This function uses <code><a href="#topic+solSpace">solSpace</a></code> and
<code><a href="#topic+deductiveZeros">deductiveZeros</a></code> (iteratively) to determine which values can be imputed
deductively. Solutions causing new violations of (in)equality rules are rejected by default by testing
if the observed values can lead to a feasible record. This may be switched off by passing
<code>checkFeasibility=FALSE</code>. This may be desirable for performance reasons. If <code>adapt</code>
was computed with an error localization algorithm, such as <code>editrules::localizeErrors</code>, the
feasibility check is also not nessecary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduImpute(E, dat, adapt = NULL, ...)

## S3 method for class 'editset'
deduImpute(E, dat, adapt = NULL, ...)

## S3 method for class 'editarray'
deduImpute(E, dat, adapt = NULL, ...)

## S3 method for class 'editmatrix'
deduImpute(E, dat, adapt = NULL,
  tol = sqrt(.Machine$double.eps), round = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deduImpute_+3A_e">E</code></td>
<td>
<p>An <code>editmatrix</code> or <code>editarray</code></p>
</td></tr>
<tr><td><code id="deduImpute_+3A_dat">dat</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="deduImpute_+3A_adapt">adapt</code></td>
<td>
<p>(optional) A boolean array of dim(dat), e.g. the result editrules::localizeErrors(E,dat).
Column names must match those of <code>dat</code>.</p>
</td></tr>
<tr><td><code id="deduImpute_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+solSpace">solSpace</a></code> (numerical data) or <code><a href="#topic+deductiveLevels">deductiveLevels</a></code> (categorical data)</p>
</td></tr>
<tr><td><code id="deduImpute_+3A_tol">tol</code></td>
<td>
<p>tolerance to use in <code><a href="#topic+solSpace">solSpace</a></code>
and in <code><a href="#topic+deductiveZeros">deductiveZeros</a></code></p>
</td></tr>
<tr><td><code id="deduImpute_+3A_round">round</code></td>
<td>
<p>should the result be rounded?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+deducorrect-object">deducorrect-object</a></code>
</p>


<h3>Note</h3>

<p>When <code>adapt</code> is not <code>NULL</code>, values in <code>dat</code> where <code>adapt==TRUE</code>
are replaced with <code>NA</code>. The output may therefore contain missings at positions
that were previously filled (with wrong values, according to <code>adapt</code>).
</p>


<h3>References</h3>

<p>T. De Waal, J. Pannekoek and S. Scholtus (2011) Handbook of statistical data editing
Chpt 9.2.1 - 9.2.2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deductiveZeros">deductiveZeros</a></code>, <code><a href="#topic+solSpace">solSpace</a></code>, <code><a href="#topic+deductiveLevels">deductiveLevels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#############################################
# IMPUTATION OF NUMERIC DATA
#############################################

# These examples are taken from De Waal et al (2011) (Examples 9.1-9.2)
E &lt;- editmatrix(c(
    "x1 + x2      == x3",
    "x2           == x4",
    "x5 + x6 + x7 == x8",
    "x3 + x8      == x9",
    "x9 - x10     == x11",
    "x6 &gt;= 0",
    "x7 &gt;= 0"
))


dat &lt;- data.frame(
    x1=c(145,145),
    x2=c(NA,NA),
    x3=c(155,155),
    x4=c(NA,NA),
    x5=c(NA, 86),
    x6=c(NA,NA),
    x7=c(NA,NA),
    x8=c(86,86),
    x9=c(NA,NA),
    x10=c(217,217),
    x11=c(NA,NA)
)

dat

d &lt;- deduImpute(E,dat)
d$corrected
d$status
d$corrections




#############################################
# IMPUTATION OF CATEGORICAL DATA
#############################################


# Here's an example from Katrika (2001) [but see De Waal et al (2011), ex. 9.3)]
E &lt;- editarray(c(
    "x1 \%in\% letters[1:4]",
    "x2 \%in\% letters[1:3]",
    "x3 \%in\% letters[1:3]",
    "x4 \%in\% letters[1:2]",
    "if (x2 == 'c'  &amp; x3 != 'c' &amp; x4 == 'a' ) FALSE",
    "if (x2 != 'a'  &amp; x4 == 'b') FALSE",
    "if (x1 != 'c'  &amp; x2 != 'b' &amp; x3 != 'a') FALSE",
    "if (x1 == 'c'  &amp; x3 != 'a' &amp; x4 == 'a' ) FALSE"
))


dat &lt;- data.frame(
    x1 = c('c', NA ),
    x2 = c('b', NA ),
    x3 = c(NA , NA ),
    x4 = c(NA , 'b'),
    stringsAsFactors=FALSE)


s &lt;- deduImpute(E,dat)
s$corrected
s$status
s$corrections


E &lt;- editset(expression(
    x + y == z,
    x &gt;= 0,
    A %in% c('a','b'),
    B %in% c('c','d'),
    if ( A == 'a' ) B == 'b',
    if ( B == 'b' ) x &gt; 0
))

x &lt;- data.frame(
    x = NA,
    y = 1,
    z = 1,
    A = 'a',
    B = NA
)
# deduImpute will impute x=0 and B='b',which violates the 
# last edit. Hence, imputation will be reverted.
deduImpute(E,x) 


</code></pre>

<hr>
<h2 id='getSignCorrection'>workhorse for correctSigns</h2><span id='topic+getSignCorrection'></span>

<h3>Description</h3>

<p>Workhorse for correctSigns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSignCorrection(r, A1, C1, eps, A2, C2, epsvec, flip, swap, w, swapIsOneFlip,
  maxActions, maxCombinations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSignCorrection_+3A_r">r</code></td>
<td>
<p>The numerical record to correct</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_a1">A1</code></td>
<td>
<p>Equality matrix</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_c1">C1</code></td>
<td>
<p>Constant vector for equalities</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_eps">eps</code></td>
<td>
<p>Tolerance for equality-checking</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_a2">A2</code></td>
<td>
<p>Inequality matrix</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_c2">C2</code></td>
<td>
<p>Constant vector for inequalities</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_epsvec">epsvec</code></td>
<td>
<p>Vector to check against. (<code>.Machine.double.eps</code> for <code>&gt;</code> inequalities, otherwise 0.)</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_flip">flip</code></td>
<td>
<p>indices in <code>r</code>, where r may be sign-flipped</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_swap">swap</code></td>
<td>
<p><code class="reqn">n\times2</code> matrix with indices in <code>r</code>, each row indicating a possible value swap.</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_w">w</code></td>
<td>
<p>weight vector of <code>length(flips)+nrow(swaps)</code> if <code>swapIsOneFlip==TRUE</code>, otherwise of <code>length(r)</code></p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_swapisoneflip">swapIsOneFlip</code></td>
<td>
<p>logical. If <code>TRUE</code>, weights are assigned to each flip or swap action. If <code>FALSE</code> weights are assigned to every changed variable.</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_maxactions">maxActions</code></td>
<td>
<p>Maximum number of <code>flips+swaps</code> to try.</p>
</td></tr>
<tr><td><code id="getSignCorrection_+3A_maxcombinations">maxCombinations</code></td>
<td>
<p>the maximum number of flip/swap combinations to try. See the description in <code><a href="#topic+correctSigns">correctSigns</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<table>
<tr>
 <td style="text-align: left;">
     <code>S</code> </td><td style="text-align: left;"> <code>n x length(r)</code> array with corrected versions of <code>r</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>weight</code> </td><td style="text-align: left;"> vector of length <code>n</code> with total weight for each solution </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>nFlip</code> </td><td style="text-align: left;"> number of sign flips for every solution </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>nSwap</code> </td><td style="text-align: left;"> number of value swaps for every solution</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+correctSigns">correctSigns</a></code>
</p>

<hr>
<h2 id='getTypoCorrection'>Check record validity and suggest typo corrections</h2><span id='topic+getTypoCorrection'></span>

<h3>Description</h3>

<p>This function is the working horse for <code><a href="#topic+correctTypos">correctTypos</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTypoCorrection(E, x, fixate = FALSE, eps = sqrt(.Machine$double.eps),
  maxdist = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTypoCorrection_+3A_e">E</code></td>
<td>
<p>editmatrix</p>
</td></tr>
<tr><td><code id="getTypoCorrection_+3A_x">x</code></td>
<td>
<p>numerical record to be checked</p>
</td></tr>
<tr><td><code id="getTypoCorrection_+3A_eps">eps</code></td>
<td>
<p>tolerance for an edit to be valid</p>
</td></tr>
<tr><td><code id="getTypoCorrection_+3A_maxdist">maxdist</code></td>
<td>
<p>maximum edit distance to be valid as a correction suggestion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with members
</p>

<table>
<tr>
 <td style="text-align: left;">
status </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
cor    </td><td style="text-align: left;"> suggested corrections </td>
</tr>
<tr>
 <td style="text-align: left;">
B      </td><td style="text-align: left;"> reduced binary editmatrix with violated edits, needed for choosing the suggested corrections</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='getUsername'>Get name of R user.</h2><span id='topic+getUsername'></span>

<h3>Description</h3>

<p>Get name of R user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUsername()
</code></pre>


<h3>Details</h3>

<p>This function returns the username.
</p>
<p>This function is not exported.
</p>


<h3>Value</h3>

<p>The username
</p>

<hr>
<h2 id='hellerTompkins'>Determine if a matrix is totally unimodular using Heller and Tompkins criterium.</h2><span id='topic+hellerTompkins'></span>

<h3>Description</h3>

<p>This function is <code>deducorrect</code> internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellerTompkins(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellerTompkins_+3A_a">A</code></td>
<td>
<p>An object of class matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>.
Each column  must have exactly 2 nonzero elements. (This is tested by
<code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if matrix is unimodular, otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>
</p>

<hr>
<h2 id='imputess'>Impute values from solution space</h2><span id='topic+imputess'></span>

<h3>Description</h3>

<p>Given a record <code class="reqn">x</code> with observerd <code class="reqn">x_{obs}</code> and missing values <code class="reqn">x_{miss}</code> under
linear equality constraints <code class="reqn">Ax=b</code>. The function <code><a href="#topic+solSpace">solSpace</a></code> returns
the solution space which can be written as <code class="reqn">x_{miss} = x_0 + Cz</code>, where <code class="reqn">x_0</code> is
are a constant vector (of dimension d=<code>length</code><code class="reqn">(x_{miss})</code>) and <code class="reqn">C</code> a constant
matrix of dimension <code class="reqn">d\times d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputess(x, x0, C, z = NULL, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputess_+3A_x">x</code></td>
<td>
<p>(named) numerical vector to be imputed</p>
</td></tr>
<tr><td><code id="imputess_+3A_x0">x0</code></td>
<td>
<p><code>x0</code> outcome of <code><a href="#topic+solSpace">solSpace</a></code></p>
</td></tr>
<tr><td><code id="imputess_+3A_c">C</code></td>
<td>
<p><code>C</code> outcome of <code><a href="#topic+solSpace">solSpace</a></code></p>
</td></tr>
<tr><td><code id="imputess_+3A_z">z</code></td>
<td>
<p>real vector of dimension <code>ncol(C)</code>.</p>
</td></tr>
<tr><td><code id="imputess_+3A_tol">tol</code></td>
<td>
<p>tolerance used to check which rows of <code>C</code> equal zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">C</code> has rows equal to zero, then those missing values may be imputed deductively.
For the other missing values, some <code class="reqn">z</code> must be chosen or another imputation method
used.
</p>
<p>The function <code>imputess</code> imputes missing values in a vector <code class="reqn">x</code>, based on the
solution space and some chosen vector <code class="reqn">z</code>. If no <code class="reqn">z</code> is passed as argument, only
deductive imputations are performend (i.e. some missings may be left).
</p>
<p>If <code class="reqn">C</code> is a named matrix (as returned by <code><a href="#topic+solSpace">solSpace</a></code>), rows of <code class="reqn">x0</code> and <code class="reqn">C</code>
are matched by name to <code class="reqn">x</code>. Otherwise it is assumed that the missings in <code class="reqn">x</code> occur in the order
of the rows in <code class="reqn">C</code> (which is also the case when x0 and C are computed by <code><a href="#topic+solSpace">solSpace</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#############################################
# IMPUTATION OF NUMERIC DATA
#############################################

# These examples are taken from De Waal et al (2011) (Examples 9.1-9.2)
E &lt;- editmatrix(c(
    "x1 + x2      == x3",
    "x2           == x4",
    "x5 + x6 + x7 == x8",
    "x3 + x8      == x9",
    "x9 - x10     == x11",
    "x6 &gt;= 0",
    "x7 &gt;= 0"
))


dat &lt;- data.frame(
    x1=c(145,145),
    x2=c(NA,NA),
    x3=c(155,155),
    x4=c(NA,NA),
    x5=c(NA, 86),
    x6=c(NA,NA),
    x7=c(NA,NA),
    x8=c(86,86),
    x9=c(NA,NA),
    x10=c(217,217),
    x11=c(NA,NA)
)

dat

d &lt;- deduImpute(E,dat)
d$corrected
d$status
d$corrections




#############################################
# IMPUTATION OF CATEGORICAL DATA
#############################################


# Here's an example from Katrika (2001) [but see De Waal et al (2011), ex. 9.3)]
E &lt;- editarray(c(
    "x1 \%in\% letters[1:4]",
    "x2 \%in\% letters[1:3]",
    "x3 \%in\% letters[1:3]",
    "x4 \%in\% letters[1:2]",
    "if (x2 == 'c'  &amp; x3 != 'c' &amp; x4 == 'a' ) FALSE",
    "if (x2 != 'a'  &amp; x4 == 'b') FALSE",
    "if (x1 != 'c'  &amp; x2 != 'b' &amp; x3 != 'a') FALSE",
    "if (x1 == 'c'  &amp; x3 != 'a' &amp; x4 == 'a' ) FALSE"
))


dat &lt;- data.frame(
    x1 = c('c', NA ),
    x2 = c('b', NA ),
    x3 = c(NA , NA ),
    x4 = c(NA , 'b'),
    stringsAsFactors=FALSE)


s &lt;- deduImpute(E,dat)
s$corrected
s$status
s$corrections


E &lt;- editset(expression(
    x + y == z,
    x &gt;= 0,
    A %in% c('a','b'),
    B %in% c('c','d'),
    if ( A == 'a' ) B == 'b',
    if ( B == 'b' ) x &gt; 0
))

x &lt;- data.frame(
    x = NA,
    y = 1,
    z = 1,
    A = 'a',
    B = NA
)
# deduImpute will impute x=0 and B='b',which violates the 
# last edit. Hence, imputation will be reverted.
deduImpute(E,x) 


</code></pre>

<hr>
<h2 id='isTotallyUnimodular'>Test for total unimodularity of a matrix.</h2><span id='topic+isTotallyUnimodular'></span>

<h3>Description</h3>

<p>Check wether a matrix is totally unimodular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTotallyUnimodular(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isTotallyUnimodular_+3A_a">A</code></td>
<td>
<p>An object of class <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A matrix for which the determinant of every square submatrix equals <code class="reqn">-1</code>, <code class="reqn">0</code> or <code class="reqn">1</code>
is called <em>totally unimodular</em>. This function tests if a matrix with
coefficients in <code class="reqn">\{-1,0,1\}</code> is totally unimodular. It tries to reduce the matrix
using the reduction method described in Scholtus (2008). Next, a test based
on Heller and Tompkins (1956) or Raghavachari is performed.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>References</h3>

<p>Heller I and Tompkins CB (1956). An extension of a theorem of Danttzig's In kuhn HW and Tucker AW (eds.),
pp. 247-254. Princeton University Press.
</p>
<p>Raghavachari M (1976). A constructive method to recognize the total
unimodularity of a matrix. _Zeitschrift fur operations research_,
*20*, pp. 59-61.
</p>
<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Totally unimodular matrix, reduces to nothing
A &lt;- matrix(c(
 1,1,0,0,0,
 -1,0,0,1,0,
 0,0,01,1,0,
 0,0,0,-1,1),nrow=5)
isTotallyUnimodular(A)

# Totally unimodular matrix, by Heller-Tompson criterium
A &lt;- matrix(c(
 1,1,0,0,
 0,0,1,1,
 1,0,1,0,
 0,1,0,1),nrow=4)
isTotallyUnimodular(A)

# Totally unimodular matrix, by Raghavachani recursive criterium
A &lt;- matrix(c(
    1,1,1,
    1,1,0,
    1,0,1))
isTotallyUnimodular(A)




</code></pre>

<hr>
<h2 id='newdeducorrect'>Generate an S3 <code>deducorrect</code> object</h2><span id='topic+newdeducorrect'></span><span id='topic+print.deducorrect'></span>

<h3>Description</h3>

<p>Generate an S3 <code>deducorrect</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newdeducorrect(corrected, corrections, status, Call = sys.call(-1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newdeducorrect_+3A_corrected">corrected</code></td>
<td>
<p>The corrected data.frame</p>
</td></tr>
<tr><td><code id="newdeducorrect_+3A_corrections">corrections</code></td>
<td>
<p>A <code>data.frame</code> listing old and new values for every row and variable where corrections were applied</p>
</td></tr>
<tr><td><code id="newdeducorrect_+3A_status">status</code></td>
<td>
<p>A <code>data.frame</code> with at least one <code><a href="#topic+status">status</a></code> column.</p>
</td></tr>
<tr><td><code id="newdeducorrect_+3A_call">Call</code></td>
<td>
<p>Optionally, a <code>call</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3 object of class <code>deducorrect</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deducorrect-object">deducorrect-object</a></code>
</p>

<hr>
<h2 id='raghavachari'>Determine if a matrix is unimodular using recursive Raghavachari criterium</h2><span id='topic+raghavachari'></span>

<h3>Description</h3>

<p>This function is <code>deducorrect</code> internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raghavachari(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raghavachari_+3A_a">A</code></td>
<td>
<p>An object of class Matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>
</p>

<hr>
<h2 id='reduceMatrix'>Apply reduction method from Scholtus (2008)</h2><span id='topic+reduceMatrix'></span>

<h3>Description</h3>

<p>Apply the reduction method in the appendix of Scholtus (2008) to a matrix.
Let <code class="reqn">A</code> with coefficients in <code class="reqn">\{-1,0,1\}</code>. If, after a possible
permutation of columns it can be written
in the form <code class="reqn">A=[B,C]</code> where each column in <code class="reqn">B</code> has at most 1 nonzero
element, then <code class="reqn">A</code> is totally unimodular if and only if <code class="reqn">C</code> is totally
unimodular. By transposition, a similar theorem holds for the rows of A. This
function iteratively removes rows and columns with only 1 nonzero element
from <code class="reqn">A</code> and returns the reduced result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceMatrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceMatrix_+3A_a">A</code></td>
<td>
<p>An object of class matrix in <code class="reqn">\{-1,0,1\}^{m\times n}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reduction of A.
</p>


<h3>References</h3>

<p>Scholtus S (2008). Algorithms for correcting some obvious
inconsistencies and rounding errors in business survey data. Technical
Report 08015, Netherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isTotallyUnimodular">isTotallyUnimodular</a></code>
</p>

<hr>
<h2 id='scapegoat'>Scapegoat algorithm</h2><span id='topic+scapegoat'></span>

<h3>Description</h3>

<p>Scapegoat algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scapegoat(R0, a0, x, krit = NULL)
</code></pre>

<hr>
<h2 id='solSpace'>Solution space for missing values under equality constraints</h2><span id='topic+solSpace'></span><span id='topic+solSpace.editmatrix'></span><span id='topic+solSpace.matrix'></span>

<h3>Description</h3>

<p>Solution space for missing values under equality constraints
</p>
<p>solSpace method for editmatrix
</p>
<p>This function finds the space of solutions for a numerical record <code class="reqn">x</code> with missing values under
linear constraints <code class="reqn">Ax=b</code>. Write <code class="reqn">x=(x_{obs},x_{miss})</code>.
Then the solution space for <code class="reqn">x_{miss}</code> is given by <code class="reqn">x_0 + Cz</code>, where <code class="reqn">x_0</code> is
a constant vector, <code class="reqn">C</code> a constant matrix and <code class="reqn">z</code> is any real vector of dimension
<code>ncol(C)</code>. This function computes <code class="reqn">x_0</code> and <code class="reqn">C</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solSpace(E, x, ...)

## S3 method for class 'editmatrix'
solSpace(E, x, adapt = logical(length(x)),
  checkFeasibility = TRUE, ...)

## S3 method for class 'matrix'
solSpace(E, x, b, adapt = logical(length(x)),
  tol = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solSpace_+3A_e">E</code></td>
<td>
<p>and <code>editmatrix</code> or equality constraint matrix</p>
</td></tr>
<tr><td><code id="solSpace_+3A_x">x</code></td>
<td>
<p>a named numeric vector.</p>
</td></tr>
<tr><td><code id="solSpace_+3A_...">...</code></td>
<td>
<p>Extra parameters to pass to <code>solSpace.matrix</code></p>
</td></tr>
<tr><td><code id="solSpace_+3A_adapt">adapt</code></td>
<td>
<p>A named logical vector with variables in the same order as in x</p>
</td></tr>
<tr><td><code id="solSpace_+3A_checkfeasibility">checkFeasibility</code></td>
<td>
<p>Check if the observed values can lead to a consistent record</p>
</td></tr>
<tr><td><code id="solSpace_+3A_b">b</code></td>
<td>
<p>Equality constraint constant vector</p>
</td></tr>
<tr><td><code id="solSpace_+3A_tol">tol</code></td>
<td>
<p>tolerance used to determine 0-singular values when determining
generalized inverse and to round coefficients of C to zero. See <code>MASS::ginv</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can specify extra fields to include in <code class="reqn">x_{miss}</code> by specifying <code>adapt</code>.
Also note that the method rests on the assumtion that all nonmissng values of <code class="reqn">x</code> are
correct.
</p>
<p>The most timeconsuming step involves computing the generalized inverse of <code class="reqn">A_{miss}</code>
using <code>MASS::ginv</code> (code copied from MASS to avoid dependency). See the package
vignette and De Waal et al. (2011) for more details.
</p>


<h3>Value</h3>

<p>A <code>list</code> with elements <code class="reqn">x0</code> and <code class="reqn">C</code> or <code>NULL</code> if the solution space is empty
</p>


<h3>References</h3>

<p>T. De Waal, J. Pannekoek and S. Scholtus (2011) Handbook of statistical data editing
Chpt 9.2.1
</p>
<p>Venables, W. N. &amp; Ripley, B. D. (2002) Modern Applied Statistics with
S. Fourth Edition. Springer, New York. ISBN 0-387-95457-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deduImpute">deduImpute</a></code>, <code><a href="#topic+deductiveZeros">deductiveZeros</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example is taken from De Waal et al (2011) (Examples 9.1-9.2)
E &lt;- editmatrix(c(
    "x1 + x2      == x3",
    "x2           == x4",
    "x5 + x6 + x7 == x8",
    "x3 + x8      == x9",
    "x9 - x10     == x11",
    "x6 &gt;= 0",
    "x7 &gt;= 0"
))


dat &lt;- data.frame(
    x1=c(145,145),
    x2=c(NA,NA),
    x3=c(155,155),
    x4=c(NA,NA),
    x5=c(NA, 86),
    x6=c(NA,NA),
    x7=c(NA,NA),
    x8=c(86,86),
    x9=c(NA,NA),
    x10=c(217,217),
    x11=c(NA,NA)
)

# example with solSpace method for editmatrix
# example 9.1 of De Waal et al (2011).
x &lt;-t(dat)[,1]
s &lt;- solSpace(E,x)
s

# some values are uniquely determined and may be imputed directly:
imputess(x,s$x0,s$C)


# To impute everything, we choose z=1 (arbitrary)
z &lt;- rep(1,sum(is.na(x)))
(y &lt;- imputess(x,s$x0,s$C,z))

# did it work? (use a tolerance in checking to account for machine rounding)
# (FALSE means an edit is not violated)
any(violatedEdits(E,y,tol=1e-8))


# here's an example showing that solSpace only looks at missing values unless
# told otherwise.
Ey &lt;- editmatrix(c(
    "yt == y1 + y2 + y3",
    "y4 == 0"))
y &lt;- c(yt=10, y1=NA, y2=3, y3=7,y4=12)
# since solSpace by default checks the feasibility, we get no solution (since
# y4 violates the second edit)"
solSpace(Ey,y)


# If we ask solSpace not to check for feasibility, y4 is left alone (although
# the imputed answer is clearly wrong).
(s &lt;- solSpace(Ey,y,checkFeasibility=FALSE))
imputess(y, s$x0, s$C)

# by setting 'adapt' we can include y4 in the imputation Since we know that
# with this adapt vector, imputation can be done consistently, we save some
# time by switching the feasibility check off.
(s &lt;- solSpace(Ey,y,adapt=c(FALSE,FALSE,FALSE,FALSE,TRUE), 
  checkFeasibility=FALSE))
imputess(y,s$x0,s$C)


</code></pre>

<hr>
<h2 id='status'>Create empty status vector</h2><span id='topic+status'></span>

<h3>Description</h3>

<p>Create empty status vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(n, ini = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_n">n</code></td>
<td>
<p>length of status vector</p>
</td></tr>
<tr><td><code id="status_+3A_ini">ini</code></td>
<td>
<p>initial value, defaults to <code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every function in <code><a href="#topic+deducorrect-package">deducorrect</a></code> returns the status of every row after treatment.
The status vector is an <code>ordered</code> factor with levels
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>invalid</code>      </td><td style="text-align: left;"> record is invalid but could not be corrected</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>partial</code>    </td><td style="text-align: left;"> record violates less edits then before entering the function</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>corrected</code>    </td><td style="text-align: left;"> record satisfies all edit restrictions after correction</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>valid</code>        </td><td style="text-align: left;"> record violates no edit restrictions</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code>invalid &lt; partial &lt; corrected &lt; valid</code>
</p>
<p>This function is <code>deducorrect</code> internal.
</p>


<h3>Value</h3>

<p>an ordered factor with levels mentioned under details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create statusvector

status &lt;- deducorrect:::status(5)
status[1:5] &lt;- c("invalid",NA,"corrected","valid","partial")

# 
which(status &lt; "valid")
</code></pre>

<hr>
<h2 id='tree'>Solve an optimization problem using a tree algorithm as described in Scholtus (2009)</h2><span id='topic+tree'></span>

<h3>Description</h3>

<p>Solve an optimization problem using a tree algorithm as described in Scholtus (2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(B, kappa, delta = as.logical(rep(NA, ncol(B))), sol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_+3A_b">B</code></td>
<td>
<p>binary matrix with suggested corrections per violated edit</p>
</td></tr>
<tr><td><code id="tree_+3A_kappa">kappa</code></td>
<td>
<p>frequency of suggested corrections</p>
</td></tr>
<tr><td><code id="tree_+3A_delta">delta</code></td>
<td>
<p><code>logical</code> vector with partial solution (starts with NA)</p>
</td></tr>
<tr><td><code id="tree_+3A_sol">sol</code></td>
<td>
<p>current best solution. (starts with null)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sol
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
