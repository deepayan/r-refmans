<!DOCTYPE html><html lang="en"><head><title>Help for package forecastLSW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forecastLSW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#forecastLSW-package'><p>Forecasting for locally stationary (wavelet) time series based on the local partial autocorrelation function.</p></a></li>
<li><a href='#abmld2'>
<p>Gross Value Added (GVA, Average) at basis prices: CP SA time series / second differenced series</p></a></li>
<li><a href='#analyze.abmld2'>
<p>Analyzes the abmld2 data, see below for more details.</p></a></li>
<li><a href='#analyze.windanomaly'>
<p>Analyzes the windanomaly data, see below for more details.</p></a></li>
<li><a href='#forecastlpacf'>
<p>Forecasts future values of the time series <code>x</code> <code>h</code>-steps ahead. (for the specified horizon <code>h</code>) using the lpacf to decide the dimension of the generalized Yule-Walker equations.</p></a></li>
<li><a href='#forecastpanel'>
<p>Function to produce a plot of data forecasts.</p></a></li>
<li><a href='#fp.forecast'><p>Do automatic Box-Jenkins ARIMA fit and forecast.</p></a></li>
<li><a href='#plot'><p>Plot the results of forecasting using <code>forecastlpacf</code></p></a></li>
<li><a href='#print'><p>Prints a <code>forecastlpacf</code> object</p></a></li>
<li><a href='#summary'><p>Print out summary information about a <code>forecastlpacf</code> object</p></a></li>
<li><a href='#testforecast'><p>Compare locally stationary forecasting with Box-Jenkins-type</p>
forecasting, by predicting the final values of a time series.</a></li>
<li><a href='#which.wavelet.best'><p>Find out what wavelet is good for forecasting your series.</p></a></li>
<li><a href='#windanomaly'>
<p>Eq. Pacific meridional wind anomaly index, Jan 1900 - June 2005</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forecasting Routines for Locally Stationary Wavelet Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Rebecca Killick [aut, cre],
  Matt Nunes [aut],
  Guy Nason [aut],
  Marina Knight [aut],
  Idris Eckley [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation to perform forecasting of locally stationary wavelet processes by examining the local second order structure of the time series. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), stats, locits, wavethresh, parallel, lpacf,
methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>forecast</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-24 16:10:21 UTC; killick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-25 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='forecastLSW-package'>Forecasting for locally stationary (wavelet) time series based on the local partial autocorrelation function.
</h2><span id='topic+forecastLSW-package'></span>

<h3>Description</h3>

<p>This package computes forecasts for a time series
with prediction errors. The forecasting methodology is designed
with an underlying locally stationary wavelet model in mind. However,
it is possible that the forecasting methodology will work well for
other time series, including those where an underlying model is not
necessarily known. Note: the methodology can work with any
length of time series. The package also contains functions to
display the forecasts and their prediction intervals or a fan chart,
a function to evaluate the performance of the new forecasting methods
and compare it to Box-Jenkins ARMA-based forecasting and a routine
to identify wavelets that enable the forecasting routines to perform
well. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lpacf</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> function computes forecasts of a locally
stationary (wavelet) time series using the localized partial autocorrelation
to help with history identification. The results of such forecasting
can be printed using <code><a href="#topic+print.forecastlpacf">print.forecastlpacf</a></code> or plotted
with <code><a href="#topic+plot.forecastlpacf">plot.forecastlpacf</a></code>.
</p>
<p>Two other useful functions are <code><a href="#topic+testforecast">testforecast</a></code> which 
runs some testing on forecasting some end values of a series using earlier
values and compares the new forecasting with standard Box-Jenkins ARMA
forecasting (visualisation via <code><a href="#topic+forecastpanel">forecastpanel</a></code>) and 
<code><a href="#topic+which.wavelet.best">which.wavelet.best</a></code> which attempts to identify which wavelet is 
well-suited to forecasting a particular series.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick, Marina Knight, Guy Nason, Matt Nunes
</p>
<p>Maintainer: Rebecca Killick &lt;r.killick@lancs.ac.uk&gt;
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code>,
<code><a href="#topic+testforecast">testforecast</a></code>,
<code><a href="#topic+which.wavelet.best">which.wavelet.best</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See examples in each of the functions' help pages linked above.
#
</code></pre>

<hr>
<h2 id='abmld2'>
Gross Value Added (GVA, Average) at basis prices: CP SA time series / second differenced series
</h2><span id='topic+abmld2'></span><span id='topic+abml'></span>

<h3>Description</h3>

<p>Essentially GVA is a component in the estimator for UK Gross Domestic Product (GDP) an important economic time series. The series can be downloaded from the UK Office of National Statistics website, see below for references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("abml")
data("abmld2")
</code></pre>


<h3>Format</h3>

<p>The GVA series that we obtain are the quarterly reports from Q1 1955 until Q4 2020. This is a series of 264 observations. The series has a strong mean trend which we have removed using twice differencing (diff(abml, diff=2)) to obtain the series abmld2. This vector is of length 262.
</p>


<h3>Source</h3>

<p>www.statistics.gov.uk/statbase/TSDtables1.asp and www.statistics.gov.uk/cci/nugget.asp?id=254</p>

<hr>
<h2 id='analyze.abmld2'>
Analyzes the abmld2 data, see below for more details.
</h2><span id='topic+analyze.abmld2'></span>

<h3>Description</h3>

<p>Takes the abmld2 data and analyzes it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.abmld2(h=10,atTime=NULL,atLag=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze.abmld2_+3A_h">h</code></td>
<td>
<p>Numeric value for a 1:h-steps ahead forecast.  In reality we treat the <code>data[1:(length(data)-h)]</code> as known and try to forecast h-steps ahead from <code>data[length(data)-h]</code>
</p>
</td></tr>
<tr><td><code id="analyze.abmld2_+3A_attime">atTime</code></td>
<td>
<p>Vector of the times (rows) of the <code>lpacf</code> to be plotted.  Note that not all times can be plotted, the range of plausible values depends on the bandwidth selected for the data.  At the time of writing binwidth for abmld2 is 147 and thus the plausible values are [74,147].
</p>
</td></tr>
<tr><td><code id="analyze.abmld2_+3A_atlag">atLag</code></td>
<td>
<p>Vector of the lags (columns) of the <code>lpacf</code> to be plotted.  The default maximum lag is <code>floor(10 * log10(n))</code> which is 23 for abmld2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the abmld2 data and analyzes it. Specifically the following is produced:
</p>

<ul>
<li><p> time series plot of the abmld2 data
</p>
</li>
<li><p> the lpacf for the abmld2 data
</p>
</li>
<li><p> plots of the lpacf + CI for the specified times and lags
</p>
</li>
<li><p> the forecast for h to last data point(s) using the lpacf method
</p>
</li>
<li><p> the forecast for h to last data point(s) using the standard ARMA method
</p>
</li>
<li><p> plot of the original data, forecasts and confidence intervals for both methods, red=lpacf, blue=ARMA.
</p>
</li></ul>



<h3>Value</h3>

<p>List containing the lpacf, forecast + accuracy measures using the lpacf method and forecast +accuracy measures using the ARMA method.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="lpacf.html#topic+lpacf.plot">lpacf.plot</a></code>, <code><a href="#topic+forecastlpacf">forecastlpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(abmld2)
	out=analyze.abmld2()

## End(Not run)
</code></pre>

<hr>
<h2 id='analyze.windanomaly'>
Analyzes the windanomaly data, see below for more details.
</h2><span id='topic+analyze.windanomaly'></span>

<h3>Description</h3>

<p>Takes the windanomaly data and analyzes it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.windanomaly(h=10,atTime=NULL,atLag=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze.windanomaly_+3A_h">h</code></td>
<td>
<p>Numeric vector for a h-steps ahead forecast.  In reality we treat the <code>data[1:(length(data)-h)]</code> as known and try to forecast h-steps ahead from <code>data[length(data)-h]</code>
</p>
</td></tr>
<tr><td><code id="analyze.windanomaly_+3A_attime">atTime</code></td>
<td>
<p>Vector of the times (rows) of the <code>lpacf</code> to be plotted. Note that not all times can be plotted, the range of plausible values depends on the bandwidth selected for the data.  At the time of writing binwidth for windanomaly is 1173 and thus the plausible values are [587,680].
</p>
</td></tr>
<tr><td><code id="analyze.windanomaly_+3A_atlag">atLag</code></td>
<td>
<p>Vector of the lags (columns) of the <code>lpacf</code> to be plotted.  The default maximum lag is <code>floor(10 * log10(n))</code> which is 31 for windanomaly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes the windanomaly data and analyzes it. Specifically the following is produced:
</p>

<ul>
<li><p> time series plot of the windanomaly data
</p>
</li>
<li><p> the lpacf for the windanomaly data
</p>
</li>
<li><p> plots of the lpacf + CI for the specified times and lags
</p>
</li>
<li><p> the forecast for h to last data point(s) using the lpacf method
</p>
</li>
<li><p> the forecast for h to last data point(s) using the standard ARMA method
</p>
</li>
<li><p> plot of the original data, forecasts and confidence intervals for both methods, red=lpacf, blue=ARMA.
</p>
</li></ul>



<h3>Value</h3>

<p>List containing the lpacf, forecast + accuracy measures using the lpacf method and forecast +accuracy measures using the ARMA method.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code>lpacf.plot</code>, <code><a href="#topic+forecastlpacf">forecastlpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(windanomaly)
	out=analyze.windanomaly()

## End(Not run)
</code></pre>

<hr>
<h2 id='forecastlpacf'>
Forecasts future values of the time series <code>x</code> <code>h</code>-steps ahead. (for the specified horizon <code>h</code>) using the lpacf to decide the dimension of the generalized Yule-Walker equations.
</h2><span id='topic+forecastlpacf'></span><span id='topic+dforecastlpacf'></span>

<h3>Description</h3>

<p>This function forecasts a <code>x</code> time series <code>h</code>-steps
ahead. The time series is assumed to be locally stationary
(actualy locally stationary wavelet) and uses a local prediction
method. The function makes use of the localized partial autocorrelation
function to decide the order of the local Yule-Walker equations
used in the forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecastlpacf(x,h=1,regularize=TRUE,lag.max=max(10,2*h),forecast.type=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecastlpacf_+3A_x">x</code></td>
<td>
<p>Vector containing time series to generate forecasts for.
</p>
</td></tr>
<tr><td><code id="forecastlpacf_+3A_h">h</code></td>
<td>
<p>Integer. Maximum prediction horizon. Forecasts will be given for 
one to <code>h</code> time steps ahead. Currently, for <code>dforecastlpacf</code>
<code>h</code> is hard-coded to be 1. If you want to forecast further
ahead for differenced data then you will have to difference the time
series manually and supply it to <code>forecastlpacf</code>.
</p>
</td></tr>
<tr><td><code id="forecastlpacf_+3A_regularize">regularize</code></td>
<td>

<p>Logical.  If <code>regularize=TRUE</code> then the Yule-Walker matrix is regularized
before prediction using the method from Xie et al. (2007).
If <code>regularize=FALSE</code> then no regularization takes place.
</p>
</td></tr>
<tr><td><code id="forecastlpacf_+3A_lag.max">lag.max</code></td>
<td>
<p>Maximum lag that the <code>lpacf</code> is calculated to.
If this is set too low, i.e. the automated estimation of the
dimension of the Yule-Walker matrix is equal to <code>max.lag</code>,
then the function will print a warning message.
</p>
</td></tr>
<tr><td><code id="forecastlpacf_+3A_forecast.type">forecast.type</code></td>
<td>

<p>Options are <code>fixed</code>, <code>recursive</code> or <code>extend</code>, see details for further information.
</p>
</td></tr>
<tr><td><code id="forecastlpacf_+3A_...">...</code></td>
<td>

<p>Other parameters to be passed to the periodogram and lacv (local autocovariance) estimation, e.g. <code>filter.number</code> and <code>family</code> detailing the wavelet to be used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the wavelet periodogram followed by the lacv and
<code>lpacf</code>. 
NOTE: Often when local (windowed) estimates are created one assigns the
estimated value to the central point in the window.
This is NOT the approach we take here when calculating the lacv and
<code>lpacf</code>.
Instead we operate a rear facing window where the estimate is assigned to the
final point in the window.
</p>
<p>The lpacf is used to decide the dimension of the local Yule-Walker equations used for forecasting.
The periodogram is then smoothed using a running mean smoother,
and then to get forecast lacv estimates.
The Yule-Walker equations give the forecast mean for <code>h</code> steps ahead.
The standard deviation of the forecasts is also returned.
</p>
<p>When we are trying to forecast <code>h</code> steps ahead we use the lpacf to decide how many values (<code>p</code>) we should use for prediction.  The original method of Fryzlewicz et al. (2003) decides on <code>p</code> and then does a <code>h</code> step ahead forecast only using the <code>p</code> last values.  This is what <code>forecast.type='fixed'</code> does, regardless of the size of <code>p</code> in relation to <code>h</code>.  Note that the left hand side of the Yule-Walker matrix is fixed and only the right hand size (the forecast lacv) is changing.  Thus the size of <code>h</code> is not explicitly taken into account, there is just an inflated variance in the lacv estimate.
One other option is to use the intermediate forecast values as if they were observed and perform a recursive forecast - this is what <code>forecast.type='recursive'</code> does.  Here everything in the Yule-Walker equations is different for each forecast value.
</p>
<p>A third option is to use <code>forecast.type='fixed'</code> when <code>p</code> is greater or equal to <code>h</code> but then when we are trying to forecast beyond this we extend the Yule-Walker equations to be the same dimension as the forecast horizon.  Thus using <code>h</code> previous values instead of <code>p</code>.  This is what <code>forecast.type='extend'</code> does.
</p>
<p>The method closest to the stationary world is <code>forecast.type='recursive'</code>.
</p>
<p>The <code>dforecastlpacf</code> internally differences the time series
and then performs the local forecasting as in <code>forecastlpacf</code>
but only for one-step ahead. The advantage is that subsequent plotting
routines can nicely show the original time series, with the forecasts
on the original (not differenced) scale with the forecast and appropriate
confidence interval.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> which is a list
with the following components.
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>Returns time series forecasts from one to <code>h</code>-steps ahead.
When <code>h</code> is greater than one multiple predictions are returned in this
vector. In this case, item in position <code>n</code> corresponds to <code>n</code> steps ahead. For example, if <code>h=2</code> then this vector will contain two elements.
The first one corresponds to the prediction one-step-head and the second entry
to the two-steps-ahead prediction.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>Returns the prediction error, which can be used for assessing the prediction intervals. Item <code>n</code> corresponds to the prediction <code>n</code>-steps ahead, as for the <code>mean</code> component.</p>
</td></tr>
<tr><td><code>lpacf</code></td>
<td>
<p>Returns the estimated local partial autocovariance function</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>The confidence interval on lpacf which was used used for the automatic calculation of p</p>
</td></tr>
<tr><td><code>binwidth</code></td>
<td>
<p>The automatic bandwidth used for the running mean smoother</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Returns the automatic choice of p - the dimension of the generalized Yule-Walker equations.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The supplied original time series</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Differencing that was applied to the input series before forecasting.
For <code>forecastlpacf</code> this is <code>d=0</code>. For differencing once see
the function <code><a href="#topic+dforecastlpacf">dforecastlpacf</a></code> which returns
<code>d=1</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>R. Killick
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>
<p>Fryzlewicz, P., Van Bellegem, S. and von Sachs, R. (2003) Forecasting
non-stationary time series by wavelet process modelling.
<em>Annals of the Institute of Statistical Mathematics</em>,
<b>55</b>, 737-764.
</p>
<p>Nason, G.P., von Sachs, R., Kroisandt, G. (2000) Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum.
<em>J. Roy. Statist. Soc. B</em>, <b>62</b>, 271-292.
</p>
<p>Xi, Y., Yu, J., Ranneby, B. (2007) Forecasting Using Locally Stationary Wavelet Processes.
</p>


<h3>See Also</h3>

<p><code>lpacf</code>, <code><a href="#topic+forecastpanel">forecastpanel</a></code>,
<code><a href="#topic+plot.forecastlpacf">plot.forecastlpacf</a></code>,
<code><a href="#topic+print.forecastlpacf">print.forecastlpacf</a></code>,
<code><a href="#topic+summary.forecastlpacf">summary.forecastlpacf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some non-stationary data we want to forecast
set.seed(1)
x=tvar2sim()

#predict 1-step ahead using Daubechies wavelets with 2 vanishing moments, although 
#other choices for the wavelet family and filter are possible (including Haar)
pred&lt;-forecastlpacf(x,h=1,filter.number=2,family="DaubExPhase",forecast.type='recursive')

#pred$mean gives the predicted value, while pred$std.err gives the prediction error
</code></pre>

<hr>
<h2 id='forecastpanel'>
Function to produce a plot of data forecasts.
</h2><span id='topic+forecastpanel'></span>

<h3>Description</h3>

<p>This function produces a plot of the data forecast with confidence intervals (if supplied) and, if supplied, against the truth.  Optionally, summaries of the forecast fit are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecastpanel(forecastobj,truth=NULL,add=FALSE,summary=TRUE,test="all",move=0,
conf.level=95,col="red",pch=c(17,19,95),...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecastpanel_+3A_forecastobj">forecastobj</code></td>
<td>
<p>Either an object of class <code>forecast</code>, <code>forecastlpacf</code> or a vector of forecasts.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_truth">truth</code></td>
<td>
<p>The true values of the signal that has been forecast.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_add">add</code></td>
<td>
<p>If FALSE a new plot is created, otherwise points are added to the active graphics device.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_summary">summary</code></td>
<td>
<p>If TRUE a summary of the forecast fit is supplied, see <code><a href="forecast.html#topic+accuracy">accuracy</a></code>.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_test">test</code></td>
<td>
<p>Argument supplied to <code><a href="forecast.html#topic+accuracy">accuracy</a></code> to determine which summary measures are returned.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_move">move</code></td>
<td>
<p>If move does not equal 0 then this is the amount to move the points+confidence intervals for the forecasts to the left (if negative) and to the right (if positive) to offset the plotted location (0) to potentially make the graphic clearer.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level used for the <code>forecastobj</code>. If <code>forecastobj</code> is lpacf it can be calculated for any confidence level.  If <code>forecastobj</code> is of class forecast then the level needs to match the one given when the forecast was calculated. A number between 1 and 100.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_col">col</code></td>
<td>
<p>Specifies the colour of forecasts on the plot, see <code><a href="graphics.html#topic+par">par</a></code> for details.
</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_pch">pch</code></td>
<td>
<p>Length 3 vector specifying the plotting character (pch) of the truth, forecast and CI in that order.</p>
</td></tr>
<tr><td><code id="forecastpanel_+3A_...">...</code></td>
<td>
<p>Additional arguments can be supplied which will be passed to <code>plot</code>, <code>points</code> and <code>segments</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the forecast data, confidence intervals and true signal if supplied.  If <code>summary=TRUE</code> then the output of <code><a href="forecast.html#topic+accuracy">accuracy</a></code> is returned.
</p>


<h3>Value</h3>

<p>If <code>summary=TRUE</code> then the output of <code><a href="forecast.html#topic+accuracy">accuracy</a></code> is returned.
</p>


<h3>Author(s)</h3>

<p>Rebecca Killick
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code>,<code><a href="forecast.html#topic+accuracy">accuracy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate a time-varying process
x=tvar2sim()

# forecast the last 12 data points using the lpacf
ans&lt;-forecastlpacf(x[1:500],h=12,forecast.type='recursive')

# then plot it and get summaries to see how we did
## Not run: plot(ans,truth=x[501:512],move=0.05)
</code></pre>

<hr>
<h2 id='fp.forecast'>Do automatic Box-Jenkins ARIMA fit and forecast.
</h2><span id='topic+fp.forecast'></span>

<h3>Description</h3>

<p>This function merely wraps some excellent functions
from the forecast package up and returns the forecast values
and their lower and upper prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp.forecast(x, h = 1, conf.level = 95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fp.forecast_+3A_x">x</code></td>
<td>
<p>The time series you wish to forecast.
</p>
</td></tr>
<tr><td><code id="fp.forecast_+3A_h">h</code></td>
<td>
<p>The number of steps ahead (forecast horizon)
</p>
</td></tr>
<tr><td><code id="fp.forecast_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the forecast prediction
interval expressed as a value between 0 and 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function entirely relies on existing functions from
the forecast package. It applies <code>auto.arima</code> to <code>x</code>
to fit an ARIMA model to the series with an automatic choice
of parameters. Then the <code>forecast</code> function is applied
to the ARIMA object to obtain forecasts and prediction intervals.
</p>


<h3>Value</h3>

<p>A matrix with <code>h</code> rows and three columns. The first column
contains the forecasted values. The second and third columns
contrain the lower and upper prediction intervals.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>
<p>Hyndman, R.J. and Khandakar, Y. (2008) Automatic Time Series Forecasting:
The forecast package for R. <em>Journal of Statistical Software</em>,
<b>27</b>, Issue 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate random test series
#
x.test &lt;- tvar2sim()
#
# Produce stationary Box-Jenkins forecasts and prediction intervals for
# two-steps ahead
#
fp.forecast(x.test, h=2)
</code></pre>

<hr>
<h2 id='plot'>Plot the results of forecasting using <code><a href="#topic+forecastlpacf">forecastlpacf</a></code>
</h2><span id='topic+plot.forecastlpacf'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> performs forecasting on
a locally stationary (wavelet) time series. This function
provides several options to plot the results in a user-friendly
fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecastlpacf'
plot(x, extra.y = NULL, f.col = 4, show.pi = "standard", 
    pi.col = 2, xlab = "Time", ylab = "Time Series", zoom = FALSE, zoom.no = 30, 
    sw = 0.2, conf.level = 95, pc.fan = (1:9) * 10, fan.seps = FALSE, 
    fan.rgb.col=c(1,0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>The object returned by the <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot_+3A_extra.y">extra.y</code></td>
<td>
<p>Sometimes other routines wish to add to the plot generated
by this function. The y-axis extent of those extra values might be
larger than the values that this plot alone would generate. So,
you can use this argument to provide a set of y-values that you want
to later plot and this plot takes those into account when setting
the scale of the y-axis. So, if you have extra characters or lines
to plot after this plot, and you want to ensure they'll get plotted
and that the y-axis is going to be large enough, supply the y values
as a vector (or just their maximum and minimum) and this function
will use them to help set the y-axis scale.
</p>
</td></tr>
<tr><td><code id="plot_+3A_f.col">f.col</code></td>
<td>
<p>The colour used to drae the forecasted values - both the points
and line joining the forecasts.
</p>
</td></tr>
<tr><td><code id="plot_+3A_show.pi">show.pi</code></td>
<td>
<p>If set to &quot;standard&quot; then 100*conf.level percent prediction
intervals are drawn for each forecasted point in the colour specified
by <code>pi.col</code>. If set to &quot;none&quot; then no prediction intervals are
drawn. If set to &quot;fan&quot; then a Bank-of-England-like fan-plot is
produced with confidence levels set by the <code>pc.fan</code> argument.
</p>
</td></tr>
<tr><td><code id="plot_+3A_pi.col">pi.col</code></td>
<td>
<p>Colour of the prediction intervals or fan plot.
</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>The x-axis label.
</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label.
</p>
</td></tr>
<tr><td><code id="plot_+3A_zoom">zoom</code></td>
<td>
<p>Sometimes for a long time series with a few forecasts the
forecast values can be hard to see and particularly how they relate
to the values of the series near to the end of the series. If
<code>TRUE</code> then this argument causes the function to only
plot the last <code>zoom.no</code> values of the time series and the
associated forecasts. One can then focus on the end of the time
series nearer to the forecast values and those values.
If <code>FALSE</code> then the whole time series and the forecasts are
plotted and <code>zoom.no</code> is ignored.
</p>
</td></tr>
<tr><td><code id="plot_+3A_zoom.no">zoom.no</code></td>
<td>
<p>The number of time series values plotted if <code>zoom=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_sw">sw</code></td>
<td>
<p>The width of the prediction intervals if <code>show.pi="standard"</code>.
</p>
</td></tr>
<tr><td><code id="plot_+3A_conf.level">conf.level</code></td>
<td>
<p>A single confidence value associated with the prediction
interval expressed as a numerical value from 0-100.
</p>
</td></tr>
<tr><td><code id="plot_+3A_pc.fan">pc.fan</code></td>
<td>
<p>A vector of
confidence values associated with the fan plot prediction
intervals expressed as a percentage. 
</p>
</td></tr>
<tr><td><code id="plot_+3A_fan.seps">fan.seps</code></td>
<td>
<p>If <code>TRUE</code> then lines are drawn on the fan part of
the fan plot to more clearly indicated the distinction between
different prediction intervals. If <code>FALSE</code> then no extra
lines are drawn.
</p>
</td></tr>
<tr><td><code id="plot_+3A_fan.rgb.col">fan.rgb.col</code></td>
<td>
<p>A vector of length three containing the red, green
and blue intensities of the fan plot colour</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a plot of a time series and its forecasts
generated by the <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> function.
</p>


<h3>Value</h3>

<p>The function only returns information if <code>show.pi="fan"</code>.
In this case an array is returned that contained the coordinates
of the fan part of the plot. The array is three-dimensional.
Dimension 1 corresponds to the number of steps ahead that we computed
for the forecast in the object <code>x</code>, dimension 2 corresponds to
the number of fan prediction intervals specified by the number of
confidence bands in <code>pc.fan</code>, dimension 3 always has two
dimensions: 1 corresponding to the upper prediction interval and
2 correspond to the lower interval. For example, element[2, 3, 1]
corresponds to the upper prediction interval, for the fan component
associated with the third fan confidence level value in <code>pc.fan</code>
for the <code>h=2</code> step ahead forecast.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simulate an example
#
x.test &lt;- tvar2sim()
#
# Do a two-step ahead forecast
#
x.fl &lt;- forecastlpacf(x.test, h=2, forecast.type="recursive")
#
# Now plot it.
#
# zoom=TRUE: so we only plot the last 30 time series observations, by default
# 	change zoom.no if you want more or less.
# f.col=3: the forecasts and connecting lines are drawn in colour 3 (blue)
# show.pi="fan": do a fan chart for the forecasts
# fan.rgb.col=c(1,0,1):	draw the fan in magenta (default is red)
# ylab="My Time Series": change the y label to something nice
#
plot(x.fl,zoom=TRUE, f.col=3, show.pi="fan", fan.rgb.col=c(1,0,1), ylab="My Time Series")
</code></pre>

<hr>
<h2 id='print'>Prints a <code>forecastlpacf</code> object
</h2><span id='topic+print.forecastlpacf'></span>

<h3>Description</h3>

<p>Prints a <code>forecastlpacf</code> object, basically telling
you what's there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecastlpacf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>The <code>forecastlpacf</code> object</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a <code>forecastlpacf</code> object, basically telling
you what's there.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code>, <code><a href="#topic+summary.forecastlpacf">summary.forecastlpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simulate an example
#
x.test &lt;- tvar2sim()
#
# Do a two-step ahead forecast
#
x.fl &lt;- forecastlpacf(x.test, h=2, forecast.type="recursive")
#
# Print out the object
#
print(x.fl)
#
# This is what gets output
#
#Class 'forecastlpacf' : Forecast from Locally Stationary Time Series:
#       ~~~~  : List with 8 components with names
#              mean std.err lpacf ci binwidth p x d 
#
#
#summary(.):
#----------
#Number of steps ahead predicted:  2 
#Predictions are (3dp):  1.52 -0.365 
#Std err are (3dp):  0.952 0.955 
#Smoothing binwidth was:  293 
#Forecast was based on a p-backlag value selected as:  3 
#There was no explicit differencing.
</code></pre>

<hr>
<h2 id='summary'>Print out summary information about a <code>forecastlpacf</code> object
</h2><span id='topic+summary.forecastlpacf'></span>

<h3>Description</h3>

<p>Print out summary information about a <code>forecastlpacf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forecastlpacf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>The object you want to print out summary info for.
</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints out the maximum number of steps ahead considered in the
object, prints out the first few predictions (up to 6), and
their standard errors. The smoothing binwidth associated with
the localized partial autocorrelation object used to compute the
predictions is printed. The order, p, of the localized partial
autocorrelation is printed. A note of whether differencing was
actioned is printed.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code>, <code><a href="#topic+print.forecastlpacf">print.forecastlpacf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Example for print.forecastlpacf contains a call to summary.forecastlpacf
</code></pre>

<hr>
<h2 id='testforecast'>Compare locally stationary forecasting with Box-Jenkins-type
forecasting, by predicting the final values of a time series.
</h2><span id='topic+testforecast'></span>

<h3>Description</h3>

<p>A good way of evaluating a forecasting method is to
apply the method to most of a series (apart from the last few values)
to forecast those last few values. Then, the forecasts and the true
values can be compared to see how good the forecast is. This function
performs this for the locally stationary forecasting based
on wavelet processes in <code><a href="#topic+forecastlpacf">forecastlpacf</a></code> and
a version of the Box-Jenkins forecasting, and also produces
both plots and returns results of the testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testforecast(x, n.to.test, go.back=0,  plot.it = TRUE, regularize = TRUE, 
    lag.max = max(10, 2 * n.to.test), truth.pch = 23, truth.col = 3, zoom = TRUE, 
    zoom.no = 30, forecast.type = NULL, conf.level = 0.95, stycol = 6, silent = TRUE,
	  lapplyfn=lapply, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testforecast_+3A_x">x</code></td>
<td>
<p>The time series you want to use in testing.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_n.to.test">n.to.test</code></td>
<td>
<p>Suppose the length of <code>x</code> is T. This function
uses the first T-<code>n.to.test</code> observations to predict the
last <code>n.to.test</code> observations.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_go.back">go.back</code></td>
<td>
<p>If <code>go.back=0</code> then a single forecasting operation
forecasting the last n.to.test observations from the previous
data is conducted. If <code>go.back</code> is an integer greater than
zero then the same forecasting as with <code>go.back</code> occurs but
each time the end of the series is moved back one point. This
shifting back occurs from one shift to <code>go.back</code> shifts.
The purpose of this is to repeat the exercise for using previous
data to forecast <code>n.to.test</code> points at the end of the
series, but to then repeat this for the series one step earlier,
then two steps earlier, ..., back to <code>go.back</code> steps earlier.
The results of each forecast are combined into an overall
root-mean-squared error result for each forecast horizon (there
will be <code>n.to.test</code> values) for both of the Box-Jenkins
and the new forecast methodology provided by 
<code><a href="#topic+forecastlpacf">forecastlpacf</a></code>. These additionally forecasts
will be computed in parallel if the <code>parallel</code> package
is loaded and <code>mclapply</code> is used as an argument to
<code>lapplyfn</code>. 
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> a plot is produced showing the original
time series, the stationary and locally stationary forecasts,
and their prediction intervals.  If <code>FALSE</code> then no plot
is produced.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_regularize">regularize</code></td>
<td>
<p>Passed through to <code>forecastlpacf</code></p>
</td></tr>
<tr><td><code id="testforecast_+3A_lag.max">lag.max</code></td>
<td>
<p>Passed through to <code>forecastlpacf</code></p>
</td></tr>
<tr><td><code id="testforecast_+3A_truth.pch">truth.pch</code></td>
<td>
<p>The type of plotting character used for the true
values, see <code>pch</code> argument to <code>points</code> function in R.</p>
</td></tr>
<tr><td><code id="testforecast_+3A_truth.col">truth.col</code></td>
<td>
<p>Colour of plot symbol used for true values.</p>
</td></tr>
<tr><td><code id="testforecast_+3A_zoom">zoom</code></td>
<td>
<p>Typically, we're interested in the later values of a time
series when doing forecasting. If this argument is <code>TRUE</code>
then only the last <code>zoom.no</code> observations are plotted, so one
can focus on the end of the series.</p>
</td></tr>
<tr><td><code id="testforecast_+3A_zoom.no">zoom.no</code></td>
<td>
<p>If <code>zoom=TRUE</code> then this argument controls how much
of the end of the series is plotted.  </p>
</td></tr>
<tr><td><code id="testforecast_+3A_forecast.type">forecast.type</code></td>
<td>
<p>Passed through to <code>forecastlpacf</code> </p>
</td></tr>
<tr><td><code id="testforecast_+3A_conf.level">conf.level</code></td>
<td>
<p>Controls the width of the prediction intervals for
both stationary and nonstationary forecasting.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_stycol">stycol</code></td>
<td>
<p>The colour of both the stationary forecasts and their
confidence intervals. 
</p>
</td></tr> <tr><td><code id="testforecast_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code> then nothing gets printed, otherwise
messages get printed.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>For single-processor use this argument should
be <code>lapply</code> (the default). However, you can set the argument 
to <code>mclapply</code> if you have the <code>parallel</code> package loaded.
Remember to set the number of processors you want to use
with the <code>mc.cores</code> option, e.g. <code>options(mc.cores=4)</code>
if you had four cores available.
</p>
</td></tr>
<tr><td><code id="testforecast_+3A_...">...</code></td>
<td>
<p>Other arguments to the <code>forecastlpacf</code> call</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code>n.to.test=1</code>. Then this function uses all the values of
the time series <code>x</code> apart from the last to generate two forecasts
of the last value. The two methods used to forecast are
the locally stationary method <code>forecastlpacf</code> and a Box-Jenkins
ARIMA alternative for stationary series coded in <code><a href="#topic+fp.forecast">fp.forecast</a></code>.
</p>
<p>Then, if <code>plot.it=TRUE</code> a plot of the time series <code>x</code> is produced,
overlaid with both types of forecast and their related prediction intervals
(the locally stationary ones are hached thin rectangles, the stationary
ones indicated by vertical &lt; &gt; symbols. The true value is also indicated
by a character whose visual characteristics are controlled by
the <code>truth.pch</code> and <code>truth.col</code> arguments, but by default
are a green diamond.
</p>
<p>If <code>n.to.test</code> is bigger than 1 then all of the data, apart from
the last <code>n.to.test</code> values are used in constructing the forecasts
(both stationary and locally stationary) for the last <code>n.to.test</code>
values.
</p>
<p>Values of the empirical root mean squared error of the two forecast
methods are printed out (unless <code>silent=TRUE</code>). The predictions
and their standard errors for the <code>n.to.test</code> values are printed out.
</p>


<h3>Value</h3>

<p>If <code>go.back=0</code> a matrix with <code>n.to.test</code>
values with four columns is returned. The
first column is the actual true value of the time series in the last
<code>n.to.test</code> positions. The second and fourth columns are the forecast
values from the locally stationary and stationary methods. The third column
are the locally stationary prediction error values.
</p>
<p>If <code>go.back</code> is a positive integer then a data frame with two
columns. The first column corresponds to stationary forecasting
using the standard Box-Jenkins type method encapsulated by
<code><a href="#topic+fp.forecast">fp.forecast</a></code>. The second column corresponds to
the locally stationary forecasting encapsulated by
<code>forecastlpacf</code>. Each row of the frame corresponds to
a different forecasting horizon, the horizon is indicated by
the row name of the data frame.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecastlpacf">forecastlpacf</a></code>,
<code><a href="#topic+fp.forecast">fp.forecast</a></code>,
<code><a href="#topic+plot.forecastlpacf">plot.forecastlpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simulated time series from TVAR(2) model.
#
x.test &lt;- tvar2sim()
#
# Now run testforecast on this example time series.
# We've only supplied plot.it=FALSE because its in an R help page, normally
# you would set plot.it=TRUE, which is the default, because you want to see
# the plot.
#
tmp &lt;- testforecast(x.test, n.to.test=3, forecast.type="recursive",
	plot.it=FALSE)
</code></pre>

<hr>
<h2 id='which.wavelet.best'>Find out what wavelet is good for forecasting your series.
</h2><span id='topic+which.wavelet.best'></span>

<h3>Description</h3>

<p>A big question with many wavelet methods is which wavelet
should one use for a particular task. This function tries some
forecasting on your time series with all Daubechies compactly
supported wavelets available to it and returns a list of the
forecasting performance for each choice, and indicates which
wavelet gave the best results. This wavelet can then be used
in future forecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.wavelet.best(x, n.to.test = 10, go.back=5,
	forecast.type = "recursive", lapplyfn = lapply)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.wavelet.best_+3A_x">x</code></td>
<td>
<p>Your times series (not necessarily of dyadic length!)
</p>
</td></tr>
<tr><td><code id="which.wavelet.best_+3A_n.to.test">n.to.test</code></td>
<td>
<p>How many observations at the end to test as part
of the assessment process. The default, 10, means that 10 observations
at the end of the series will all be forecast. This number should
be reasonably big to enable forecasts of more than a few data points,
but not too large.
</p>
</td></tr>
<tr><td><code id="which.wavelet.best_+3A_go.back">go.back</code></td>
<td>
<p>Controls the <code>go.back</code> argument to
<code><a href="#topic+testforecast">testforecast</a></code>. Number of repeats of the
procedure on successively one-unit of time earlier series.</p>
</td></tr>
<tr><td><code id="which.wavelet.best_+3A_forecast.type">forecast.type</code></td>
<td>
<p>The type of forecasting as detailed in
<code><a href="#topic+forecastlpacf">forecastlpacf</a></code>.
</p>
</td></tr>
<tr><td><code id="which.wavelet.best_+3A_lapplyfn">lapplyfn</code></td>
<td>
<p>Type of list processing function. By default it
uses R's <code>lapply</code> function. However, if you use the
<code>parallel</code> library you can replace this with
<code>mclapply</code> which will make this function go faster using
parallel computation. Don't forget to set the
<code>options(mc.cores=4)</code> argument to what you wish (here it is
set to 4 in this example, but you should set it to something that
is appropriate for your machine environment).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses all choices of wavelet to forecast the
last <code>n.to.test</code> observations of your time series. It
works out the forecasting error in doing so for each choice of
wavelet and returns a list telling you which wavelet did best.
</p>


<h3>Value</h3>

<p>A data frame containing information on the root mean squared
forecasting error performance of the locally stationary forecasting
method for different wavelets. The data frame has four columns and
a row for each wavelet tried. The first and second column give
the filter number and family for each wavelet. The third column
gives the root mean squared error for each combination of
wavelet. The fourth column contains an indicator that shows
which wavelet was best (there might be more than one).
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Killick, R., Knight, M.I., Nason, G.P., Nunes M.A., Eckley I.A. (2023) Automatic Locally Stationary Time Series Forecasting with
application to predicting U.K. Gross Value Added Time Series under sudden shocks caused by the COVID pandemic 
<a href="https://arxiv.org/abs/2303.07772">arXiv:2303.07772</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testforecast">testforecast</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate simulated example
#
x &lt;- tvar2sim()
#
# Work out which wavelet is best for forecasting this series
#
# Note: to speed up I also do:
#	library("parallel")
#	options(mc.cores=4)	# You have a four core machine, eg 
#	tmp &lt;- which.wavelet.best(x, lapplyfn=mclapply)
#
# Note2: The following command can take a few minutes to run, even on
#	a fairly recent (2013) machine. You can speed it up by using
#	parallel execution as noted above, or by reducing go.back or
#	by reducing n.to.test, and also shortening the time series x to
#	more recent values. However, you need to be careful if you shorten
#	x too much then you are not basing the best wavelet decision on the
#	right time series. Similarly, by reducing go.back you are not
#	insuring your answer across runs across many internal forecasts. 
#
## Not run: tmp &lt;- which.wavelet.best(x)
#
# Print out what the result was:
#
## Not run: print(tmp)
#   filter.number      family       mse    min.mse
#1              1 DaubExPhase 0.2139173 &lt;- Min MSE
#2              2 DaubExPhase 0.5040532           
#3              3 DaubExPhase 0.4064091           
#4              4 DaubExPhase 0.3077695           
#5              5 DaubExPhase 0.3706422           
#6              6 DaubExPhase 0.6617254           
#7              7 DaubExPhase 0.5477581           
#8              8 DaubExPhase 0.6881407           
#9              9 DaubExPhase 0.5514298           
#10            10 DaubExPhase 0.5551846           
#11             4 DaubLeAsymm 0.3134285           
#12             5 DaubLeAsymm 0.3910101           
#13             6 DaubLeAsymm 0.7480980           
#14             7 DaubLeAsymm 0.5700830           
#15             8 DaubLeAsymm 0.5661297           
#16             9 DaubLeAsymm 0.5689345           
#17            10 DaubLeAsymm 0.5580267           
</code></pre>

<hr>
<h2 id='windanomaly'>
Eq. Pacific meridional wind anomaly index, Jan 1900 - June 2005
</h2><span id='topic+windanomaly'></span>

<h3>Description</h3>

<p>This dataset gives the monthly ENSO meridional wind anomaly index for the region 12-2N, 160E-80W from January 1900 until June 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("windanomaly")
</code></pre>


<h3>Format</h3>

<p>A vector of wind anomalies with length 1266.
</p>


<h3>Source</h3>

<p>http://jisao.washington.edu/data_sets/eqpacmeridwindts/</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
