<!DOCTYPE html><html lang="en"><head><title>Help for package grpsel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grpsel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.cv.grpsel'><p>Coefficient function for cv.grpsel object</p></a></li>
<li><a href='#coef.grpsel'><p>Coefficient function for grpsel object</p></a></li>
<li><a href='#cv.grpsel'><p>Cross-validated group subset selection</p></a></li>
<li><a href='#grpsel'><p>Group subset selection</p></a></li>
<li><a href='#plot.cv.grpsel'><p>Plot function for cv.grpsel object</p></a></li>
<li><a href='#plot.grpsel'><p>Plot function for grpsel object</p></a></li>
<li><a href='#predict.cv.grpsel'><p>Predict function for cv.grpsel object</p></a></li>
<li><a href='#predict.grpsel'><p>Predict function for grpsel object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Group Subset Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for sparse regression modelling with grouped predictors using the group 
    subset selection penalty. Uses coordinate descent and local search algorithms to rapidly deliver 
    near optimal estimates. The group subset penalty can be combined with a group lasso or ridge 
    penalty for added shrinkage. Linear and logistic regression are supported, as are overlapping 
    groups.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ryan-thompson/grpsel">https://github.com/ryan-thompson/grpsel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ryan-thompson/grpsel/issues">https://github.com/ryan-thompson/grpsel/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, parallel, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-28 13:01:02 UTC; ryan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Thompson <a href="https://orcid.org/0000-0002-9002-0448"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-28 14:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.cv.grpsel'>Coefficient function for cv.grpsel object</h2><span id='topic+coef.cv.grpsel'></span>

<h3>Description</h3>

<p>Extracts coefficients for specified values of the tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.grpsel'
coef(object, lambda = "lambda.min", gamma = "gamma.min", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.grpsel_+3A_object">object</code></td>
<td>
<p>an object of class <code>cv.grpsel</code></p>
</td></tr>
<tr><td><code id="coef.cv.grpsel_+3A_lambda">lambda</code></td>
<td>
<p>the value of <code>lambda</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="coef.cv.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="coef.cv.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>

<hr>
<h2 id='coef.grpsel'>Coefficient function for grpsel object</h2><span id='topic+coef.grpsel'></span>

<h3>Description</h3>

<p>Extracts coefficients for specified values of the tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpsel'
coef(object, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.grpsel_+3A_object">object</code></td>
<td>
<p>an object of class <code>grpsel</code></p>
</td></tr>
<tr><td><code id="coef.grpsel_+3A_lambda">lambda</code></td>
<td>
<p>the value of <code>lambda</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="coef.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="coef.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>

<hr>
<h2 id='cv.grpsel'>Cross-validated group subset selection</h2><span id='topic+cv.grpsel'></span>

<h3>Description</h3>

<p>Fits the regularisation surface for a regression model with a group subset selection
penalty and then cross-validates this surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.grpsel(
  x,
  y,
  group = seq_len(ncol(x)),
  penalty = c("grSubset", "grSubset+grLasso", "grSubset+Ridge"),
  loss = c("square", "logistic"),
  lambda = NULL,
  gamma = NULL,
  nfold = 10,
  folds = NULL,
  cv.loss = NULL,
  cluster = NULL,
  interpolate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.grpsel_+3A_x">x</code></td>
<td>
<p>a predictor matrix</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_y">y</code></td>
<td>
<p>a response vector</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_group">group</code></td>
<td>
<p>a vector of length <code>ncol(x)</code> with the jth element identifying the group that
the jth predictor belongs to; alternatively, a list of vectors with the kth vector identifying
the predictors that belong to the kth group (useful for overlapping groups)</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_penalty">penalty</code></td>
<td>
<p>the type of penalty to apply; one of 'grSubset', 'grSubset+grLasso', or
'grSubset+Ridge'</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_loss">loss</code></td>
<td>
<p>the type of loss function to use; 'square' for linear regression or 'logistic' for
logistic regression</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_lambda">lambda</code></td>
<td>
<p>an optional list of decreasing sequences of group subset selection parameters; the
list should contain a vector for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>an optional decreasing sequence of group lasso or ridge parameters</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_nfold">nfold</code></td>
<td>
<p>the number of cross-validation folds</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_folds">folds</code></td>
<td>
<p>an optional vector of length <code>nrow(x)</code> with the ith entry identifying the fold
that the ith observation belongs to</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_cv.loss">cv.loss</code></td>
<td>
<p>an optional cross-validation loss-function to use; should accept a vector of
predicted values and a vector of actual values</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_cluster">cluster</code></td>
<td>
<p>an optional cluster for running cross-validation in parallel; must be set up using
<code>parallel::makeCluster</code>; each fold is evaluated on a different node of the cluster</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_interpolate">interpolate</code></td>
<td>
<p>a logical indicating whether to interpolate the <code>lambda</code> sequence for
the cross-validation fits; see details below</p>
</td></tr>
<tr><td><code id="cv.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments for <code>grpsel()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>loss='logistic'</code> stratified cross-validation is used to balance
the folds. When fitting to the cross-validation folds, <code>interpolate=TRUE</code> cross-validates
the midpoints between consecutive <code>lambda</code> values rather than the original <code>lambda</code>
sequence. This new sequence retains the same set of solutions on the full data, but often leads
to superior cross-validation performance.
</p>


<h3>Value</h3>

<p>An object of class <code>cv.grpsel</code>; a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>cv.mean</code></td>
<td>
<p>a list of vectors containing cross-validation means per value of <code>lambda</code>;
an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>cd.sd</code></td>
<td>
<p>a list of vectors containing cross-validation standard errors per value of
<code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a list of vectors containing the values of <code>lambda</code> used in the fit; an
individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>a vector containing the values of <code>gamma</code> used in the fit</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>the value of <code>lambda</code> minimising <code>cv.mean</code></p>
</td></tr>
<tr><td><code>gamma.min</code></td>
<td>
<p>the value of <code>gamma</code> minimising <code>cv.mean</code></p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the fit from running <code>grpsel()</code> on the full data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grouped data
set.seed(123)
n &lt;- 100
p &lt;- 10
g &lt;- 5
group &lt;- rep(1:g, each = p / g)
beta &lt;- numeric(p)
beta[which(group %in% 1:2)] &lt;- 1
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n, x %*% beta)
newx &lt;- matrix(rnorm(p), ncol = p)

# Group subset selection
fit &lt;- cv.grpsel(x, y, group)
plot(fit)
coef(fit)
predict(fit, newx)

# Parallel cross-validation
cl &lt;- parallel::makeCluster(2)
fit &lt;- cv.grpsel(x, y, group, cluster = cl)
parallel::stopCluster(cl)
</code></pre>

<hr>
<h2 id='grpsel'>Group subset selection</h2><span id='topic+grpsel'></span>

<h3>Description</h3>

<p>Fits the regularisation surface for a regression model with a group subset selection
penalty. The group subset penalty can be combined with either a group lasso or ridge penalty
for shrinkage. The group subset parameter is <code>lambda</code> and the group lasso/ridge parameter is
<code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpsel(
  x,
  y,
  group = seq_len(ncol(x)),
  penalty = c("grSubset", "grSubset+grLasso", "grSubset+Ridge"),
  loss = c("square", "logistic"),
  local.search = FALSE,
  orthogonalise = FALSE,
  nlambda = 100,
  lambda.step = 0.99,
  lambda = NULL,
  lambda.factor = NULL,
  ngamma = 10,
  gamma.max = 100,
  gamma.min = 1e-04,
  gamma = NULL,
  gamma.factor = NULL,
  pmax = ncol(x),
  gmax = length(unique(group)),
  eps = 1e-04,
  max.cd.iter = 10000,
  max.ls.iter = 100,
  active.set = TRUE,
  active.set.count = 3,
  sort = TRUE,
  screen = 500,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grpsel_+3A_x">x</code></td>
<td>
<p>a predictor matrix</p>
</td></tr>
<tr><td><code id="grpsel_+3A_y">y</code></td>
<td>
<p>a response vector</p>
</td></tr>
<tr><td><code id="grpsel_+3A_group">group</code></td>
<td>
<p>a vector of length <code>ncol(x)</code> with the jth element identifying the group that
the jth predictor belongs to; alternatively, a list of vectors with the kth vector identifying
the predictors that belong to the kth group (useful for overlapping groups)</p>
</td></tr>
<tr><td><code id="grpsel_+3A_penalty">penalty</code></td>
<td>
<p>the type of penalty to apply; one of 'grSubset', 'grSubset+grLasso', or
'grSubset+Ridge'</p>
</td></tr>
<tr><td><code id="grpsel_+3A_loss">loss</code></td>
<td>
<p>the type of loss function to use; 'square' for linear regression or 'logistic' for
logistic regression</p>
</td></tr>
<tr><td><code id="grpsel_+3A_local.search">local.search</code></td>
<td>
<p>a logical indicating whether to perform local search after coordinate
descent; typically leads to higher quality solutions</p>
</td></tr>
<tr><td><code id="grpsel_+3A_orthogonalise">orthogonalise</code></td>
<td>
<p>a logical indicating whether to orthogonalise within groups</p>
</td></tr>
<tr><td><code id="grpsel_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of group subset selection parameters to evaluate when  <code>lambda</code> is
computed automatically; may evaluate fewer parameters if <code>pmax</code> or <code>gmax</code> is reached
first</p>
</td></tr>
<tr><td><code id="grpsel_+3A_lambda.step">lambda.step</code></td>
<td>
<p>the step size taken when computing <code>lambda</code> from the data; should be a
value strictly between 0 and 1; larger values typically lead to a finer grid of subset sizes</p>
</td></tr>
<tr><td><code id="grpsel_+3A_lambda">lambda</code></td>
<td>
<p>an optional list of decreasing sequences of group subset selection parameters; the
list should contain a vector for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>a vector of penalty factors applied to the group subset selection penalty;
equal to the group sizes by default</p>
</td></tr>
<tr><td><code id="grpsel_+3A_ngamma">ngamma</code></td>
<td>
<p>the number of group lasso or ridge parameters to evaluate when <code>gamma</code> is
computed automatically</p>
</td></tr>
<tr><td><code id="grpsel_+3A_gamma.max">gamma.max</code></td>
<td>
<p>the maximum value for <code>gamma</code> when <code>penalty='grSubset+Ridge'</code>; when
<code>penalty='grSubset+grLasso'</code> <code>gamma.max</code> is computed automatically from the data</p>
</td></tr>
<tr><td><code id="grpsel_+3A_gamma.min">gamma.min</code></td>
<td>
<p>the minimum value for <code>gamma</code> when <code>penalty='grSubset+Ridge'</code> and the
minimum value for <code>gamma</code> as a fraction of <code>gamma.max</code> when
<code>penalty='grSubset+grLasso'</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_gamma">gamma</code></td>
<td>
<p>an optional decreasing sequence of group lasso or ridge parameters</p>
</td></tr>
<tr><td><code id="grpsel_+3A_gamma.factor">gamma.factor</code></td>
<td>
<p>a vector of penalty factors applied to the shrinkage penalty; by default,
equal to the square root of the group sizes when <code>penalty='grSubset+grLasso'</code> or a vector of
ones when <code>penalty='grSubset+Ridge'</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_pmax">pmax</code></td>
<td>
<p>the maximum number of predictors ever allowed to be active; ignored if <code>lambda</code>
is supplied</p>
</td></tr>
<tr><td><code id="grpsel_+3A_gmax">gmax</code></td>
<td>
<p>the maximum number of groups ever allowed to be active; ignored if <code>lambda</code> is
supplied</p>
</td></tr>
<tr><td><code id="grpsel_+3A_eps">eps</code></td>
<td>
<p>the convergence tolerance; convergence is declared when the relative maximum
difference in consecutive coefficients is less than <code>eps</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_max.cd.iter">max.cd.iter</code></td>
<td>
<p>the maximum number of coordinate descent iterations allowed per value of
<code>lambda</code> and <code>gamma</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_max.ls.iter">max.ls.iter</code></td>
<td>
<p>the maximum number of local search iterations allowed per value of
<code>lambda</code> and <code>gamma</code></p>
</td></tr>
<tr><td><code id="grpsel_+3A_active.set">active.set</code></td>
<td>
<p>a logical indicating whether to use active set updates; typically lowers the
run time</p>
</td></tr>
<tr><td><code id="grpsel_+3A_active.set.count">active.set.count</code></td>
<td>
<p>the number of consecutive coordinate descent iterations in which a
subset should appear before running active set updates</p>
</td></tr>
<tr><td><code id="grpsel_+3A_sort">sort</code></td>
<td>
<p>a logical indicating whether to sort the coordinates before running coordinate
descent; required for gradient screening; typically leads to higher quality solutions</p>
</td></tr>
<tr><td><code id="grpsel_+3A_screen">screen</code></td>
<td>
<p>the number of groups to keep after gradient screening; smaller values typically
lower the run time</p>
</td></tr>
<tr><td><code id="grpsel_+3A_warn">warn</code></td>
<td>
<p>a logical indicating whether to print a warning if the algorithms fail to converge</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For linear regression (<code>loss='square'</code>) the response and predictors are centred
about zero and scaled to unit l2-norm. For logistic regression (<code>loss='logistic'</code>) only the
predictors are centred and scaled and an intercept is fit during the course of the algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code>grpsel</code>; a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>a list of matrices whose columns contain fitted coefficients for a given value of
<code>lambda</code>; an individual matrix in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>a vector containing the values of <code>gamma</code> used in the fit</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a list of vectors containing the values of <code>lambda</code> used in the fit; an
individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>a list of vectors containing the number of active predictors per value of
<code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>ng</code></td>
<td>
<p>a list of vectors containing the the number of active groups per value of
<code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>iter.cd</code></td>
<td>
<p>a list of vectors containing the number of coordinate descent iterations per value
of <code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>iter.ls</code></td>
<td>
<p>a list of vectors containing the number of local search iterations per value
of <code>lambda</code>; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>a list of vectors containing the evaluated loss function per value of <code>lambda</code>
evaluated; an individual vector in the list for each value of <code>gamma</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>


<h3>References</h3>

<p>Thompson, R. and Vahid, F. (2024). 'Group selection and shrinkage: Structured
sparsity for semiparametric additive models'. Journal of Computational and Graphical Statistics
33.4, pp. 1286–1297.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grouped data
set.seed(123)
n &lt;- 100
p &lt;- 10
g &lt;- 5
group &lt;- rep(1:g, each = p / g)
beta &lt;- numeric(p)
beta[which(group %in% 1:2)] &lt;- 1
x &lt;- matrix(rnorm(n * p), n, p)
y &lt;- rnorm(n, x %*% beta)
newx &lt;- matrix(rnorm(p), ncol = p)

# Group subset selection
fit &lt;- grpsel(x, y, group)
plot(fit)
coef(fit, lambda = 0.05)
predict(fit, newx, lambda = 0.05)

# Group subset selection with group lasso shrinkage
fit &lt;- grpsel(x, y, group, penalty = 'grSubset+grLasso')
plot(fit, gamma = 0.05)
coef(fit, lambda = 0.05, gamma = 0.1)
predict(fit, newx, lambda = 0.05, gamma = 0.1)

# Group subset selection with ridge shrinkage
fit &lt;- grpsel(x, y, group, penalty = 'grSubset+Ridge')
plot(fit, gamma = 0.05)
coef(fit, lambda = 0.05, gamma = 0.1)
predict(fit, newx, lambda = 0.05, gamma = 0.1)
</code></pre>

<hr>
<h2 id='plot.cv.grpsel'>Plot function for cv.grpsel object</h2><span id='topic+plot.cv.grpsel'></span>

<h3>Description</h3>

<p>Plot the cross-validation results from group subset selection for a specified value
of <code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.grpsel'
plot(x, gamma = "gamma.min", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv.grpsel_+3A_x">x</code></td>
<td>
<p>an object of class <code>cv.grpsel</code></p>
</td></tr>
<tr><td><code id="plot.cv.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="plot.cv.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the cross-validation results.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>

<hr>
<h2 id='plot.grpsel'>Plot function for grpsel object</h2><span id='topic+plot.grpsel'></span>

<h3>Description</h3>

<p>Plot the coefficient profiles from group subset selection for a specified value of
<code>gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpsel'
plot(x, gamma = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.grpsel_+3A_x">x</code></td>
<td>
<p>an object of class <code>grpsel</code></p>
</td></tr>
<tr><td><code id="plot.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="plot.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the coefficient profiles.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>

<hr>
<h2 id='predict.cv.grpsel'>Predict function for cv.grpsel object</h2><span id='topic+predict.cv.grpsel'></span>

<h3>Description</h3>

<p>Generate predictions for new data using specified values of the tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.grpsel'
predict(object, x.new, lambda = "lambda.min", gamma = "gamma.min", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.grpsel_+3A_object">object</code></td>
<td>
<p>an object of class <code>cv.grpsel</code></p>
</td></tr>
<tr><td><code id="predict.cv.grpsel_+3A_x.new">x.new</code></td>
<td>
<p>a matrix of new values for the predictors</p>
</td></tr>
<tr><td><code id="predict.cv.grpsel_+3A_lambda">lambda</code></td>
<td>
<p>the value of <code>lambda</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="predict.cv.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="predict.cv.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.au&gt;
</p>

<hr>
<h2 id='predict.grpsel'>Predict function for grpsel object</h2><span id='topic+predict.grpsel'></span>

<h3>Description</h3>

<p>Generate predictions for new data using specified values of the tuning parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpsel'
predict(object, x.new, lambda = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.grpsel_+3A_object">object</code></td>
<td>
<p>an object of class <code>grpsel</code></p>
</td></tr>
<tr><td><code id="predict.grpsel_+3A_x.new">x.new</code></td>
<td>
<p>a matrix of new values for the predictors</p>
</td></tr>
<tr><td><code id="predict.grpsel_+3A_lambda">lambda</code></td>
<td>
<p>the value of <code>lambda</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="predict.grpsel_+3A_gamma">gamma</code></td>
<td>
<p>the value of <code>gamma</code> indexing the desired fit</p>
</td></tr>
<tr><td><code id="predict.grpsel_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Ryan Thompson &lt;ryan.thompson-1@uts.edu.auu&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
