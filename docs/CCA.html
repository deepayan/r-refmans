<!DOCTYPE html><html><head><title>Help for package CCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CCA-package'><p>Canonical correlation analysis</p></a></li>
<li><a href='#cc'><p>Canonical Correlation Analysis</p></a></li>
<li><a href='#comput'><p>Additional computations for CCA</p></a></li>
<li><a href='#estim.regul'><p>Estimate the parameters of regularization</p></a></li>
<li><a href='#img.estim.regul'><p>Plot the cross-validation criterion</p></a></li>
<li><a href='#img.matcor'><p>Image of correlation matrices</p></a></li>
<li><a href='#loo'><p>Leave-one-out criterion</p></a></li>
<li><a href='#matcor'><p>Correlations matrices</p></a></li>
<li><a href='#nutrimouse'><p>Nutrimouse dataset</p></a></li>
<li><a href='#plt.cc'><p>Graphical outputs for canonical correlation analysis</p></a></li>
<li><a href='#plt.indiv'><p>Individuals representation for CCA</p></a></li>
<li><a href='#plt.var'><p>Variables representation for CCA</p></a></li>
<li><a href='#rcc'><p>Regularized Canonical Correlation Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Canonical Correlation Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Ignacio González, Sébastien Déjean</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sébastien Déjean &lt;sebastien.dejean@math.univ-toulouse.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions that extend the
        'cancor' function with new numerical and graphical outputs. It
        also include a regularized extension of the canonical
        correlation analysis to deal with datasets with more variables
        than observations.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), fda, fields</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 06:36:46 UTC; sdejean</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 08:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='CCA-package'>Canonical correlation analysis</h2><span id='topic+CCA-package'></span><span id='topic+CCA'></span>

<h3>Description</h3>

<p>The package provides a set of functions that extend the
<code>cancor()</code> function with new numerical and graphical outputs. It
includes a regularized extension of the canonical correlation analysis
to deal with datasets with more variables than observations and enables
to handle with missing values.</p>


<h3>Author(s)</h3>

<p>Ignacio Gonzalez, Sebastien Dejean
Maintainer: Sebastien Dejean &lt;sebastien.dejean@math.univ-toulouse.fr&gt;</p>

<hr>
<h2 id='cc'>Canonical Correlation Analysis</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p>The function performs Canonical Correlation Analysis to highlight correlations between
two data matrices. It complete the <code>cancor()</code> function with supplemental numerical and
graphical outputs and can handle missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="cc_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * q), containing the Y coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The canonical correlation analysis seeks linear combinations of
the 'X' variables which are the most correlated with linear
combinations of the 'Y' variables.
</p>
<p>Let PX and PY be the projector onto the respective column-space of X and Y.
The eigenanalysis of PXPY provide the canonical correlations (square roots
of the eigenvalues) and the coefficients of linear combinations that define
the canonical variates (eigen vectors).
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>cor</code></td>
<td>
<p>canonical correlations</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>a list containing the names to be used for individuals and variables
for graphical outputs</p>
</td></tr>
<tr><td><code>xcoef</code></td>
<td>
<p>estimated coefficients for the 'X' variables as returned by <code>cancor()</code></p>
</td></tr>
<tr><td><code>ycoef</code></td>
<td>
<p>estimated coefficients for the 'Y' variables as returned by <code>cancor()</code></p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>a list returned by the internal function <code>comput()</code> containing individuals
and variables coordinates on the canonical variates basis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>References</h3>

<p>www.lsp.ups-tlse.fr/CCA</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcc">rcc</a></code>, <code><a href="#topic+plt.cc">plt.cc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
X=as.matrix(nutrimouse$gene[,1:10])
Y=as.matrix(nutrimouse$lipid)
res.cc=cc(X,Y)
plot(res.cc$cor,type="b")
plt.cc(res.cc)
</code></pre>

<hr>
<h2 id='comput'>Additional computations for CCA</h2><span id='topic+comput'></span>

<h3>Description</h3>

<p>The <code>comput()</code> function can be viewed as an internal function. It is called by <code>cc()</code>
and <code>rcc</code> to perform additional computations. The user does not have to call it by himself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comput(X, Y, res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comput_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="comput_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * q), containing the Y coordinates.</p>
</td></tr>
<tr><td><code id="comput_+3A_res">res</code></td>
<td>
<p>results provided by the <code>cc()</code> and <code>rcc()</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>xscores</code></td>
<td>
<p>X canonical variates</p>
</td></tr>
<tr><td><code>yscores</code></td>
<td>
<p>Y canonical variates</p>
</td></tr>
<tr><td><code>corr.X.xscores</code></td>
<td>
<p>Correlation bewteen X and X canonical variates</p>
</td></tr>
<tr><td><code>corr.Y.xscores</code></td>
<td>
<p>Correlation bewteen Y and X canonical variates</p>
</td></tr>
<tr><td><code>corr.X.yscores</code></td>
<td>
<p>Correlation bewteen X and Y canonical variates</p>
</td></tr>
<tr><td><code>corr.Y.yscores</code></td>
<td>
<p>Correlation bewteen Y and Y canonical variates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc">cc</a></code>, <code><a href="#topic+rcc">rcc</a></code>
</p>

<hr>
<h2 id='estim.regul'>Estimate the parameters of regularization</h2><span id='topic+estim.regul'></span>

<h3>Description</h3>

<p>Calulate the leave-one-out criterion on a 2D-grid to determine optimal
values for the parameters of regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim.regul(X, Y, grid1 = NULL, grid2 = NULL, plt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estim.regul_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="estim.regul_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="estim.regul_+3A_grid1">grid1</code></td>
<td>
<p>vector defining the values of lambda1 to be tested. If
NULL, the vector is defined as <code>seq(0.001, 1, length = 5)</code></p>
</td></tr>
<tr><td><code id="estim.regul_+3A_grid2">grid2</code></td>
<td>
<p>vector defining the values of lambda2 to be tested. If
NULL, the vector is defined as <code>seq(0.001, 1, length = 5)</code></p>
</td></tr>
<tr><td><code id="estim.regul_+3A_plt">plt</code></td>
<td>
<p>logical argument indicating whether an image should be
plotted by calling the <code>img.estim.regul()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-vector containing the 2 values of the parameters of regularization
on which the leave-one-out criterion reached its maximum; and the
maximal value reached on the grid.</p>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
#data(nutrimouse)
#X=as.matrix(nutrimouse$gene)
#Y=as.matrix(nutrimouse$lipid)
#res.regul = estim.regul(X,Y,c(0.01,0.5),c(0.1,0.2,0.3)) 
</code></pre>

<hr>
<h2 id='img.estim.regul'>Plot the cross-validation criterion</h2><span id='topic+img.estim.regul'></span>

<h3>Description</h3>

<p>This function provide a visualization of the values of the
cross-validation criterion  obtained on a grid defined in the function <code>estim.regul()</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>img.estim.regul(estim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="img.estim.regul_+3A_estim">estim</code></td>
<td>
<p>Object returned by <code>estim.regul()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.regul">estim.regul</a></code></p>

<hr>
<h2 id='img.matcor'>Image of correlation matrices</h2><span id='topic+img.matcor'></span>

<h3>Description</h3>

<p>Display images of the correlation matrices within and between two data matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img.matcor(correl, type = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="img.matcor_+3A_correl">correl</code></td>
<td>
<p>Correlation matrices as returned by the <code>matcor()</code> function</p>
</td></tr>
<tr><td><code id="img.matcor_+3A_type">type</code></td>
<td>
<p>character determining the kind of plots to be produced:
either one ((p+q) * (p+q)) matrix or three matrices (p * p), (q * q) and (p * q)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrices are pre-processed before calling the <code>image()</code> function in order to
get, as in the numerical representation, the diagonal from upper-left corner to
bottom-right one.
</p>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+matcor">matcor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
X=as.matrix(nutrimouse$gene)
Y=as.matrix(nutrimouse$lipid)
correl=matcor(X,Y)
img.matcor(correl)
img.matcor(correl,type=2)
</code></pre>

<hr>
<h2 id='loo'>Leave-one-out criterion</h2><span id='topic+loo'></span>

<h3>Description</h3>

<p> The <code>loo()</code> function can be viewed as an internal
function. It is called by <code>estim.regul()</code> to obtain optimal values
for the two parameters of regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo(X, Y, lambda1, lambda2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="loo_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * q), containing the Y coordinates.</p>
</td></tr>
<tr><td><code id="loo_+3A_lambda1">lambda1</code></td>
<td>
<p>parameter of regularization for X variables</p>
</td></tr>
<tr><td><code id="loo_+3A_lambda2">lambda2</code></td>
<td>
<p>parameter of regularization for Y variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+estim.regul">estim.regul</a></code></p>

<hr>
<h2 id='matcor'>Correlations matrices</h2><span id='topic+matcor'></span>

<h3>Description</h3>

<p>The function computes the correlation matrices within and between two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matcor(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matcor_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="matcor_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * q), containing the Y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>Xcor</code></td>
<td>
<p>Correlation matrix (p * p) for the X variables</p>
</td></tr>
<tr><td><code>Ycor</code></td>
<td>
<p>Correlation matrix (q * q) for the Y variables</p>
</td></tr>
<tr><td><code>XYcor</code></td>
<td>
<p>Correlation matrix ((p+q) * (p+q)) between X and Y variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>See Also</h3>

<p><code><a href="#topic+img.matcor">img.matcor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
X=as.matrix(nutrimouse$gene)
Y=as.matrix(nutrimouse$lipid)
correl=matcor(X,Y)
img.matcor(correl)
img.matcor(correl,type=2)
</code></pre>

<hr>
<h2 id='nutrimouse'>Nutrimouse dataset</h2><span id='topic+nutrimouse'></span>

<h3>Description</h3>

<p>The <code>nutrimouse</code> dataset comes from a nutrition study
in the mouse. It was provided by Pascal Martin from
the Toxicology and Pharmacology Laboratory (French National
Institute for Agronomic Research).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nutrimouse)</code></pre>


<h3>Format</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>gene</code>: data frame (40 * 120) with numerical variables
</p>
</li>
<li> <p><code>lipid</code>: data frame (40 * 21) with numerical variables
</p>
</li>
<li> <p><code>diet</code>: factor vector (40)
</p>
</li>
<li> <p><code>genotype</code>: factor vector (40)
</p>
</li></ul>



<h3>Details</h3>

<p>Two sets of variables were measured on 40 mice:
</p>

<ul>
<li><p> expressions of 120 genes potentially involved in nutritional problems.
</p>
</li>
<li><p> concentrations of 21 hepatic fatty acids.
</p>
<p>The 40 mice were distributed in a 2-factors experimental design (4
replicates):
</p>
</li>
<li><p> Genotype (2-levels factor):  wild-type and PPARalpha -/-
</p>
</li>
<li><p> Diet (5-levels factor): Oils used for experimental diets
preparation were corn and colza oils (50/50) for a reference diet (REF),
hydrogenated coconut oil for a saturated fatty acid diet (COC),
sunflower oil for an Omega6 fatty acid-rich diet (SUN), linseed oil for
an Omega3-rich diet (LIN) and corn/colza/enriched fish oils for the FISH
diet (43/43/14).
</p>
</li></ul>
    


<h3>Source</h3>

<p>P. Martin, H. Guillou, F. Lasserre, S. Déjean, A. Lan, J-M. Pascussi,
M. San Cristobal, P. Legrand, P. Besse, T. Pineau - Novel aspects of
PPARalpha-mediated regulation of lipid and xenobiotic metabolism
revealed through a nutrigenomic study. Hepatology, in press, 2007.
</p>


<h3>References</h3>

<p>www.inra.fr/internet/Centres/toulouse/pharmacologie/pharmaco-moleculaire/acceuil.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
boxplot(nutrimouse$lipid)
</code></pre>

<hr>
<h2 id='plt.cc'>Graphical outputs for canonical correlation analysis</h2><span id='topic+plt.cc'></span>

<h3>Description</h3>

<p>This function calls either <code>plt.var()</code> or <code>plt.indiv()</code> or both functions
to provide individual and/or variable representation on the canonical variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt.cc(res, d1 = 1, d2 = 2, int = 0.5, type = "b", ind.names = NULL,
var.label = FALSE, Xnames = NULL, Ynames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plt.cc_+3A_res">res</code></td>
<td>
<p>Object returned by <code>cc()</code> or <code>rcc()</code></p>
</td></tr>
<tr><td><code id="plt.cc_+3A_d1">d1</code></td>
<td>
<p>The dimension that will be represented on the horizontal axis</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_d2">d2</code></td>
<td>
<p>The dimension that will be represented on the vertical axis</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_int">int</code></td>
<td>
<p>The radius of the inner circle</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_type">type</code></td>
<td>
<p>Character &quot;v&quot; (variables), &quot;i&quot; (individuals) or &quot;b&quot; (both) to specifying
the plot to be done.</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_ind.names">ind.names</code></td>
<td>
<p>vector containing the names of the individuals</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_var.label">var.label</code></td>
<td>
<p>logical indicating whether label should be plotted on
the variables representation</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_xnames">Xnames</code></td>
<td>
<p>vector giving the names of X variables</p>
</td></tr>
<tr><td><code id="plt.cc_+3A_ynames">Ynames</code></td>
<td>
<p>vector giving the names of Y variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>References</h3>

<p>www.lsp.ups-tlse.fr/Biopuces/CCA</p>


<h3>See Also</h3>

<p><code><a href="#topic+plt.indiv">plt.indiv</a></code>, <code><a href="#topic+plt.var">plt.var</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
X=as.matrix(nutrimouse$gene[,1:10])
Y=as.matrix(nutrimouse$lipid)
res.cc=cc(X,Y)
plt.cc(res.cc)
plt.cc(res.cc,d1=1,d2=3,type="v",var.label=TRUE)
</code></pre>

<hr>
<h2 id='plt.indiv'>Individuals representation for CCA</h2><span id='topic+plt.indiv'></span>

<h3>Description</h3>

<p>This function provides individuals representation on the canonical variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt.indiv(res, d1, d2, ind.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plt.indiv_+3A_res">res</code></td>
<td>
<p>Object returned by <code>cc()</code> or <code>rcc()</code></p>
</td></tr>
<tr><td><code id="plt.indiv_+3A_d1">d1</code></td>
<td>
<p>The dimension that will be represented on the horizontal axis</p>
</td></tr>
<tr><td><code id="plt.indiv_+3A_d2">d2</code></td>
<td>
<p>The dimension that will be represented on the vertical axis</p>
</td></tr>
<tr><td><code id="plt.indiv_+3A_ind.names">ind.names</code></td>
<td>
<p>vector containing the names of the individuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>References</h3>

<p>www.lsp.ups-tlse.fr/Biopuces/CCA</p>


<h3>See Also</h3>

<p><code><a href="#topic+plt.var">plt.var</a></code>, <code><a href="#topic+plt.cc">plt.cc</a></code></p>

<hr>
<h2 id='plt.var'>Variables representation for CCA</h2><span id='topic+plt.var'></span>

<h3>Description</h3>

<p>This function provides variables representation on the canonical variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt.var(res, d1, d2, int = 0.5, var.label = FALSE, Xnames = NULL, Ynames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plt.var_+3A_res">res</code></td>
<td>
<p>Object returned by <code>cc</code> or <code>rcc</code></p>
</td></tr>
<tr><td><code id="plt.var_+3A_d1">d1</code></td>
<td>
<p>The dimension that will be represented on the horizontal axis</p>
</td></tr>
<tr><td><code id="plt.var_+3A_d2">d2</code></td>
<td>
<p>The dimension that will be represented on the vertical axis</p>
</td></tr>
<tr><td><code id="plt.var_+3A_int">int</code></td>
<td>
<p>The radius of the inner circle</p>
</td></tr>
<tr><td><code id="plt.var_+3A_var.label">var.label</code></td>
<td>
<p>logical indicating whether label should be plotted on
the variables representation</p>
</td></tr>
<tr><td><code id="plt.var_+3A_xnames">Xnames</code></td>
<td>
<p>vector giving the names of X variables</p>
</td></tr>
<tr><td><code id="plt.var_+3A_ynames">Ynames</code></td>
<td>
<p>vector giving the names of Y variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>References</h3>

<p>www.lsp.ups-tlse.fr/Biopuces/CCA</p>


<h3>See Also</h3>

<p><code><a href="#topic+plt.indiv">plt.indiv</a></code>, <code><a href="#topic+plt.cc">plt.cc</a></code></p>

<hr>
<h2 id='rcc'>Regularized Canonical Correlation Analysis</h2><span id='topic+rcc'></span>

<h3>Description</h3>

<p>The function performs the Regularized extension of the Canonical Correlation Analysis
to seek correlations between two data matrices when the number of columns (variables)
exceeds the number of rows (observations)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcc(X, Y, lambda1, lambda2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcc_+3A_x">X</code></td>
<td>
<p>numeric matrix (n * p), containing the X coordinates.</p>
</td></tr>
<tr><td><code id="rcc_+3A_y">Y</code></td>
<td>
<p>numeric matrix (n * q), containing the Y coordinates.</p>
</td></tr>
<tr><td><code id="rcc_+3A_lambda1">lambda1</code></td>
<td>
<p>Regularization parameter for X</p>
</td></tr>
<tr><td><code id="rcc_+3A_lambda2">lambda2</code></td>
<td>
<p>Regularization parameter for Y</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the number of columns is greater than the number of rows, the matrice 
X'X (and/or Y'Y) may be ill-conditioned. The regularization allows the inversion
by adding a term on the diagonal.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>corr</code></td>
<td>
<p>canonical correlations</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>a list containing the names to be used for individuals and variables
for graphical outputs</p>
</td></tr>
<tr><td><code>xcoef</code></td>
<td>
<p>estimated coefficients for the 'X' variables as returned by <code>cancor()</code></p>
</td></tr>
<tr><td><code>ycoef</code></td>
<td>
<p>estimated coefficients for the 'Y' variables as returned by <code>cancor()</code></p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>a list returned by the internal function comput() containing individuals
and variables coordinates on the canonical variates basis.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Déjean, Ignacio González</p>


<h3>References</h3>

<p>Leurgans, Moyeed and Silverman, (1993). Canonical correlation analysis
when the data are curves. J. Roy. Statist. Soc. Ser. B.  55, 725-740.
</p>
<p>Vinod (1976). Canonical ridge and econometrics of joint production.
J. Econometr. 6, 129-137.</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc">cc</a></code>, <code><a href="#topic+estim.regul">estim.regul</a></code>, <code><a href="#topic+plt.cc">plt.cc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nutrimouse)
X=as.matrix(nutrimouse$gene)
Y=as.matrix(nutrimouse$lipid)
res.cc=rcc(X,Y,0.1,0.2)
plt.cc(res.cc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
