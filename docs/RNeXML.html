<!DOCTYPE html><html><head><title>Help for package RNeXML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RNeXML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.callGeneric'><p>Calls the given generic with the given arguments</p></a></li>
<li><a href='#.methodWithNext'><p>Saves the next method in the method meta data</p></a></li>
<li><a href='#.sigLabel'><p>Create a label for a method signature</p></a></li>
<li><a href='#add_basic_meta'><p>Add basic metadata</p></a></li>
<li><a href='#add_characters'><p>Add character data to a nexml object</p></a></li>
<li><a href='#add_meta'><p>Add metadata to a nexml file</p></a></li>
<li><a href='#add_namespaces'><p>Add namespaces</p></a></li>
<li><a href='#add_trees'><p>add_trees</p></a></li>
<li><a href='#Annotated-class'><p>Class of objects that have metadata as lists of meta elements</p></a></li>
<li><a href='#c,meta-method'><p>Concatenate meta elements into a ListOfmeta</p></a></li>
<li><a href='#c,nexml-method'><p>Concatenate nexml files</p></a></li>
<li><a href='#charzero_as_empty'><p>Treats zero-length character vectors as empty strings</p></a></li>
<li><a href='#coalesce_'><p>Front-end to dplyr::coalesce to deal with NULL vectors</p></a></li>
<li><a href='#expand_prefix'><p>Expand namespace-prefixed string</p></a></li>
<li><a href='#findNextMethod'><p>Finds the method that callNextMethod() should chain to</p></a></li>
<li><a href='#flatten_multiphylo'><p>Flatten a multiphylo object</p></a></li>
<li><a href='#get_all_meta'><p>Get flattened list of meta annotations</p></a></li>
<li><a href='#get_characters'><p>Get character data.frame from nexml</p></a></li>
<li><a href='#get_characters_list'><p>Extract the character matrix</p></a></li>
<li><a href='#get_citation'><p>Get citation from metadata</p></a></li>
<li><a href='#get_flat_trees'><p>get_flat_trees</p></a></li>
<li><a href='#get_level'><p>get_level</p></a></li>
<li><a href='#get_license'><p>Get license from metadata</p></a></li>
<li><a href='#get_meta'><p>Extracts meta objects matching properties</p></a></li>
<li><a href='#get_metadata'><p>get_metadata</p></a></li>
<li><a href='#get_metadata_values'><p>Get the value(s) for metadata</p></a></li>
<li><a href='#get_namespaces'><p>get namespaces</p></a></li>
<li><a href='#get_rdf'><p>Extract rdf-xml from a NeXML file</p></a></li>
<li><a href='#get_taxa'><p>get_taxa</p></a></li>
<li><a href='#get_taxa_list'><p>get_taxa_list</p></a></li>
<li><a href='#get_taxa_meta'><p>get_taxa_meta</p></a></li>
<li><a href='#get_taxa_meta_list'><p>get_taxa_meta_list</p></a></li>
<li><a href='#get_trees'><p>extract a phylogenetic tree from the nexml</p></a></li>
<li><a href='#get_trees_list'><p>extract all phylogenetic trees in ape format</p></a></li>
<li><a href='#lcapply'><p>Compact list then lapply</p></a></li>
<li><a href='#meta'><p>Constructor function for metadata nodes</p></a></li>
<li><a href='#New'><p>new with namespaced class name</p></a></li>
<li><a href='#nexml_add'><p>add elements to a new or existing nexml object</p></a></li>
<li><a href='#nexml_figshare'><p>publish nexml to figshare</p></a></li>
<li><a href='#nexml_get'><p>Get the desired element from the nexml object</p></a></li>
<li><a href='#nexml_publish'><p>publish nexml files to the web and receive a DOI</p></a></li>
<li><a href='#nexml_read'><p>Read NeXML files into various R formats</p></a></li>
<li><a href='#nexml_validate'><p>validate nexml using the online validator tool</p></a></li>
<li><a href='#nexml_write'><p>Write nexml files</p></a></li>
<li><a href='#nexml-class'><p>Class representing a NeXML document</p></a></li>
<li><a href='#nexml.tree'><p>Constructor for the respective class</p></a></li>
<li><a href='#reset_id_counter'><p>reset id counter</p></a></li>
<li><a href='#simmap_to_nexml'><p>Convert phylo with attached simmap to nexml object</p></a></li>
<li><a href='#slot,ResourceMeta-method'><p>Access or set slot of S4 object</p></a></li>
<li><a href='#summary,nexml-method'><p>Summary method for nexml objects</p></a></li>
<li><a href='#taxize_nexml'><p>taxize nexml</p></a></li>
<li><a href='#toPhylo'><p>nexml to phylo</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semantically Rich I/O for the 'NeXML' Format</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides access to phyloinformatic data in 'NeXML' format.  The
    package should add new functionality to R such as the possibility to
    manipulate 'NeXML' objects in more various and refined way and compatibility
    with 'ape' objects.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/RNeXML/">https://docs.ropensci.org/RNeXML/</a>,
<a href="https://github.com/ropensci/RNeXML">https://github.com/ropensci/RNeXML</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/RNeXML/issues">https://github.com/ropensci/RNeXML/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, rdflib, geiger (&ge; 2.0), phytools (&ge; 0.3.93),
knitr (&ge; 1.5), rfigshare (&ge; 0.3.0), knitcitations (&ge; 1.0.1),
testthat (&ge; 0.10.0), rmarkdown (&ge; 0.3.3), xslt, covr,
taxalight, progress</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ape (&ge; 3.1), methods (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML (&ge; 3.95), plyr (&ge; 1.8), reshape2 (&ge; 1.2.2), httr (&ge;
0.3), uuid (&ge; 0.1-1), dplyr (&ge; 0.7.0), tidyr (&ge; 0.3.1),
stringr (&ge; 1.0), stringi, xml2, rlang</td>
</tr>
<tr>
<td>Collate:</td>
<td>'S4-utils.R' 'classes.R' 'add_basic_meta.R' 'add_characters.R'
'add_meta.R' 'add_namespaces.R' 'nexmlTree.R' 'add_trees.R'
'character_classes.R' 'concatenate_nexml.R' 'constructors.R'
'deprecated.R' 'get_basic_metadata.R' 'get_characters.R'
'get_level.R' 'get_metadata.R' 'get_namespaces.R' 'get_rdf.R'
'get_taxa.R' 'get_taxa_meta.R' 'get_trees.R'
'internal_get_node_maps.R' 'internal_isEmpty.R'
'internal_name_by_id.R' 'internal_nexml_id.R' 'meta.R'
'nexml_add.R' 'nexml_get.R' 'nexml_methods.R' 'nexml_publish.R'
'nexml_read.R' 'nexml_validate.R' 'nexml_write.R'
'prefixed-uris.R' 'simmap.R' 'taxize_nexml.R' 'tbl_df.R'
'utils.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Data Publication</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>metadata, nexml, phylogenetics, linked-data</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-01 16:56:11 UTC; cboettig</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Boettiger <a href="https://orcid.org/0000-0002-1642-628X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Hilmar Lapp <a href="https://orcid.org/0000-0001-9107-0714"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kseniia Shumelchyk [aut],
  Rutger Vos <a href="https://orcid.org/0000-0001-9254-7318"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Boettiger &lt;cboettig@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 17:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.callGeneric'>Calls the given generic with the given arguments</h2><span id='topic+.callGeneric'></span>

<h3>Description</h3>

<p>Calls the given generic with the given arguments, using the method
whose signature matches the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.callGeneric(f, ..., .package = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".callGeneric_+3A_f">f</code></td>
<td>
<p>the generic, as a character string or a <code>standardGeneric</code>
object</p>
</td></tr>
<tr><td><code id=".callGeneric_+3A_...">...</code></td>
<td>
<p>the arguments (named and/or unnamed) with which to call the
matching method</p>
</td></tr>
<tr><td><code id=".callGeneric_+3A_.package">.package</code></td>
<td>
<p>the package name for finding the generic (if <code>f</code> is a character
string); by default the package is determined from the calling environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>methods::selectMethod()</code> to find the matching method. In theory,
this is at best wholly redundant with what standard S4 generics already
do by themselves. However, the generics dispatch for S4 seems (at least
currently) broken at least if the first argument in the signature is
a class that name-clashes with a class defined in another package. In
that case, whether the standard dispatch works correctly or not can depend
on <code>search()</code> order, and can change within a session
depending on the order in which packages are loaded.
</p>


<h3>Value</h3>

<p>the value returned by the method
</p>

<hr>
<h2 id='.methodWithNext'>Saves the next method in the method meta data</h2><span id='topic+.methodWithNext'></span>

<h3>Description</h3>

<p>Promotes the given method definition to an instance of
<code>MethodWithNext</code>, thereby recording the next
method in the <code>nextMethod</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.methodWithNext(method, nextMethod, .cache = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".methodWithNext_+3A_method">method</code></td>
<td>
<p>the <code>MethodDefinition</code> object to promote</p>
</td></tr>
<tr><td><code id=".methodWithNext_+3A_nextmethod">nextMethod</code></td>
<td>
<p>the <code>MethodDefinition</code>
object to record as the next method</p>
</td></tr>
<tr><td><code id=".methodWithNext_+3A_.cache">.cache</code></td>
<td>
<p>whether to cache the promoted method definition object
(using <code>methods::cacheMethod()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of <code>MethodWithNext</code>,
which has the next method in the <code>nextMethod</code> slot
</p>


<h3>Note</h3>

<p><code>MethodWithNext</code> objects are normally returned by
<code>methods::addNextMethod()</code>, but a constructor function for the class
seems missing (or is undocumented?). This provides one.
</p>

<hr>
<h2 id='.sigLabel'>Create a label for a method signature</h2><span id='topic+.sigLabel'></span>

<h3>Description</h3>

<p>Creates a label for a signature mirroring the result of <code>.sigLabel()</code>
in the <code>methods</code> package, which unfortunately does not export the function.
This is needed, for example, for the <code>excluded</code> slot in the
<code>MethodWithNext</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sigLabel(signature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sigLabel_+3A_signature">signature</code></td>
<td>
<p>the signature for which to create a label, as a vector
or list of strings, or as an instance of <code>signature</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string
</p>

<hr>
<h2 id='add_basic_meta'>Add basic metadata</h2><span id='topic+add_basic_meta'></span>

<h3>Description</h3>

<p>adds Dublin Core metadata elements to (top-level) nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_basic_meta(
  title = NULL,
  description = NULL,
  creator = Sys.getenv("USER"),
  pubdate = NULL,
  rights = "CC0",
  publisher = NULL,
  citation = NULL,
  nexml = new("nexml")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_basic_meta_+3A_title">title</code></td>
<td>
<p>A title for the dataset</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_description">description</code></td>
<td>
<p>a description of the dataset</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_creator">creator</code></td>
<td>
<p>name of the data creator.  Can be a string or R person object</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_pubdate">pubdate</code></td>
<td>
<p>publication date.  Default is current date.</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_rights">rights</code></td>
<td>
<p>the intellectual property rights associated with the data.
The default is Creative Commons Zero (CC0) public domain declaration,
compatible with all other licenses and appropriate for deposition
into the Dryad or figshare repositories.  CC0 is also recommended by the Panton Principles.
Alternatively, any other plain text string can be added and will be provided as the content
attribute to the dc:rights property.</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_publisher">publisher</code></td>
<td>
<p>the publisher of the dataset. Usually where a user may go to find the canonical
copy of the dataset: could be a repository, journal, or academic institution.</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_citation">citation</code></td>
<td>
<p>a citation associated with the data.  Usually an academic journal
article that indicates how the data should be cited in an academic context.  Multiple citations
can be included here.
citation can be a plain text object, but is preferably an R <code>citation</code> or <code>bibentry</code> object (which
can include multiple citations.  See examples</p>
</td></tr>
<tr><td><code id="add_basic_meta_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object to which metadata should be added.  A new
nexml object will be created if none exists.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_basic_meta()</code> is just a wrapper for <code><a href="#topic+add_meta">add_meta</a></code> to make it easy to
provide generic metadata without explicitly providing the namespace.  For instance,
<code>add_basic_meta(title="My title", description="a description")</code> is identical to:
<code>add_meta(list(meta("dc:title", "My title"), meta("dc:description", "a description")))</code>
Most function arguments are mapped directly to the Dublin Core terms
of the same name, with the exception of <code>rights</code>, which by default maps
to the Creative Commons namespace when using CC0 license.
</p>


<h3>Value</h3>

<p>an updated nexml object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_trees">add_trees</a></code> <code><a href="#topic+add_characters">add_characters</a></code> <code><a href="#topic+add_meta">add_meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nex &lt;- add_basic_meta(title = "My test title",
             description = "A description of my test",
             creator = "Carl Boettiger &lt;cboettig@gmail.com&gt;",
             publisher = "unpublished data",
             pubdate = "2012-04-01")

 ## Adding citation to an R package:
 nexml &lt;- add_basic_meta(citation=citation("ape"))
## Not run: 
 ## Use knitcitations package to add a citation by DOI:
 library(knitcitations)
 nexml &lt;- add_basic_meta(citation = bib_metadata("10.2307/2408428"))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='add_characters'>Add character data to a nexml object</h2><span id='topic+add_characters'></span>

<h3>Description</h3>

<p>Add character data to a nexml object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_characters(x, nexml = new("nexml"), append_to_existing_otus = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_characters_+3A_x">x</code></td>
<td>
<p>character data, in which character traits labels are column names
and taxon labels are row names.  x can be in matrix or data.frame
format.</p>
</td></tr>
<tr><td><code id="add_characters_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object, if appending character table to an existing
nexml object.  If omitted will initiate a new nexml object.</p>
</td></tr>
<tr><td><code id="add_characters_+3A_append_to_existing_otus">append_to_existing_otus</code></td>
<td>
<p>logical. If TRUE, will add any new taxa
(taxa not matching any existing otus block) to the existing (first)
otus block.  Otherwise (default), a new otus block is created, even
though it may contain duplicate taxa to those already present.  While
FALSE is the safe option, TRUE may be appropriate when building nexml
files from scratch with both characters and trees.</p>
</td></tr>
</table>

<hr>
<h2 id='add_meta'>Add metadata to a nexml file</h2><span id='topic+add_meta'></span>

<h3>Description</h3>

<p>Add metadata to a nexml file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_meta(
  meta,
  nexml = new("nexml"),
  level = c("nexml", "otus", "trees", "characters"),
  namespaces = NULL,
  i = 1,
  at_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_meta_+3A_meta">meta</code></td>
<td>
<p>a meta S4 object, e.g. ouput of the function <code><a href="#topic+meta">meta</a></code>, or a list of these meta objects</p>
</td></tr>
<tr><td><code id="add_meta_+3A_nexml">nexml</code></td>
<td>
<p>(S4) object</p>
</td></tr>
<tr><td><code id="add_meta_+3A_level">level</code></td>
<td>
<p>the level at which the metadata annotation should be added.</p>
</td></tr>
<tr><td><code id="add_meta_+3A_namespaces">namespaces</code></td>
<td>
<p>named character string for any additional namespaces that should be defined.</p>
</td></tr>
<tr><td><code id="add_meta_+3A_i">i</code></td>
<td>
<p>for otus, trees, characters: if there are multiple such blocks, which one should be annotated?  Default is first/only block.</p>
</td></tr>
<tr><td><code id="add_meta_+3A_at_id">at_id</code></td>
<td>
<p>the id of the element to be annotated.  Optional, advanced use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the updated nexml object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meta">meta</a></code> <code><a href="#topic+add_trees">add_trees</a></code> <code><a href="#topic+add_characters">add_characters</a></code> <code><a href="#topic+add_basic_meta">add_basic_meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a new nexml object with a single metadata element: 
modified &lt;- meta(property = "prism:modificationDate", content = "2013-10-04")
nex &lt;- add_meta(modified) # Note: 'prism' is defined in nexml_namespaces by default.  

## Write multiple metadata elements, including a new namespace:  
website &lt;- meta(href = "http://carlboettiger.info", 
                rel = "foaf:homepage")              # meta can be link-style metadata
nex &lt;- add_meta(list(modified,  website), 
                namespaces = c(foaf = "http://xmlns.com/foaf/0.1/"))

## Append more metadata, and specify a level: 
history &lt;- meta(property = "skos:historyNote",
                 content = "Mapped from the bird.orders data in the ape package using RNeXML")
data(bird.orders)
nex &lt;- add_trees(bird.orders) # need to have created a trees block first
nex &lt;- add_meta(history, 
                nexml = nex,
                level = "trees",
                namespaces = c(skos = "http://www.w3.org/2004/02/skos/core#"))

</code></pre>

<hr>
<h2 id='add_namespaces'>Add namespaces</h2><span id='topic+add_namespaces'></span>

<h3>Description</h3>

<p>Add namespaces and their prefixes as a named vector of URIs, with the
names being the prefixes. Namespaces have most relevance for meta objects'
<code>rel</code> and <code>property</code>, and for embedded XML literals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_namespaces(namespaces, nexml = new("nexml"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_namespaces_+3A_namespaces">namespaces</code></td>
<td>
<p>a named character vector of namespaces</p>
</td></tr>
<tr><td><code id="add_namespaces_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object. will create a new one if none is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation attempts to avoid duplication, currently using the
prefix. I.e., namespaces with prefixes already defined will not get added.
Namespaces needed by the NeXML format, and for commonly used metadata
terms, are already included by default, see <code><a href="#topic+get_namespaces">get_namespaces()</a></code>.
</p>


<h3>Value</h3>

<p>a nexml object with updated namespaces
</p>


<h3>Note</h3>

<p>Often a user won't call this directly, but instead provide the
namespace(s) through <code><a href="#topic+add_meta">add_meta()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meta">meta()</a></code> <code><a href="#topic+add_meta">add_meta()</a></code> <code><a href="#topic+get_namespaces">get_namespaces()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Write multiple metadata elements, including a new namespace:  
website &lt;- meta(href = "http://carlboettiger.info", 
                rel = "foaf:homepage")     # meta can be link-style metadata
modified &lt;- meta(property = "prism:modificationDate",
                 content = "2013-10-04")
nex &lt;- add_meta(list(modified,  website), 
                namespaces = c(foaf = "http://xmlns.com/foaf/0.1/"))
                # prism prefix already included by default

## Add namespace "by hand" before adding meta:
nex &lt;- add_namespaces(c(skos = "http://www.w3.org/2004/02/skos/core#"),
                      nexml = nex)
history &lt;- meta(property = "skos:historyNote",
                content = "Mapped from the bird.orders data in the ape package using RNeXML")
nex &lt;- add_meta(history, nexml = nex)

</code></pre>

<hr>
<h2 id='add_trees'>add_trees</h2><span id='topic+add_trees'></span>

<h3>Description</h3>

<p>add_trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_trees(phy, nexml = new("nexml"), append_to_existing_otus = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_trees_+3A_phy">phy</code></td>
<td>
<p>a phylo object, multiPhylo object, or list of
multiPhylo to be added to the nexml</p>
</td></tr>
<tr><td><code id="add_trees_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object to which we should append this phylo.
By default, a new nexml object will be created.</p>
</td></tr>
<tr><td><code id="add_trees_+3A_append_to_existing_otus">append_to_existing_otus</code></td>
<td>
<p>logical, indicating if we should
make a new OTU block (default) or append to the existing one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nexml object containing the phy in nexml format.
</p>

<hr>
<h2 id='Annotated-class'>Class of objects that have metadata as lists of meta elements</h2><span id='topic+Annotated-class'></span>

<h3>Description</h3>

<p>Class of objects that have metadata as lists of meta elements
</p>


<h3>Slots</h3>


<dl>
<dt><code>meta</code></dt><dd><p>list of <code>meta</code> objects</p>
</dd>
<dt><code>about</code></dt><dd><p>for RDF extraction, the identifier for the resource that this
object is about</p>
</dd>
</dl>

<hr>
<h2 id='c+2Cmeta-method'>Concatenate meta elements into a ListOfmeta</h2><span id='topic+c+2Cmeta-method'></span><span id='topic+c-meta'></span><span id='topic+c+2CListOfmeta-method'></span><span id='topic+c-ListOfmeta'></span>

<h3>Description</h3>

<p>Concatenate meta elements into a ListOfmeta
</p>
<p>Concatenate ListOfmeta elements into a flat ListOfmeta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'meta'
c(x, ..., recursive = TRUE)

## S4 method for signature 'ListOfmeta'
c(x, ..., recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2Cmeta-method_+3A_x">x</code>, <code id="c+2B2Cmeta-method_+3A_...">...</code></td>
<td>
<p><code>meta</code> and <code>ListOfmeta</code> elements to be concatenated, see <code><a href="#topic+meta">meta</a></code></p>
</td></tr>
<tr><td><code id="c+2B2Cmeta-method_+3A_recursive">recursive</code></td>
<td>
<p>logical, if 'recursive=TRUE', the function recursively
descends through lists and combines their elements into a flat vector.
This method does not support <code>recursive=FALSE</code>, use <a href="base.html#topic+list">list</a>
instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ListOfmeta object containing a flat list of meta elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(meta(content="example", property="dc:title"),
  meta(content="Carl", property="dc:creator"))
metalist &lt;- c(meta(content="example", property="dc:title"),
              meta(content="Carl", property="dc:creator"))
out &lt;- c(metalist, metalist) 
out &lt;- c(metalist, meta(content="a", property="b")) 
</code></pre>

<hr>
<h2 id='c+2Cnexml-method'>Concatenate nexml files</h2><span id='topic+c+2Cnexml-method'></span>

<h3>Description</h3>

<p>Concatenate nexml files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nexml'
c(x, ..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2Cnexml-method_+3A_x">x</code>, <code id="c+2B2Cnexml-method_+3A_...">...</code></td>
<td>
<p>nexml objects to be concatenated, e.g. from
<code><a href="#topic+write.nexml">write.nexml</a></code> or <code><a href="#topic+read.nexml">read.nexml</a></code>.
Must have unique ids on all elements</p>
</td></tr>
<tr><td><code id="c+2B2Cnexml-method_+3A_recursive">recursive</code></td>
<td>
<p>logical.  If 'recursive = TRUE', the function recursively
descends through lists (and pairlists) combining all their
elements into a vector. (Not implemented).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a concatenated nexml file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f1 &lt;- system.file("examples", "trees.xml", package="RNeXML")
f2 &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex1 &lt;- read.nexml(f1)
nex2 &lt;- read.nexml(f2)
nex &lt;- c(nex1, nex2)

## End(Not run)
</code></pre>

<hr>
<h2 id='charzero_as_empty'>Treats zero-length character vectors as empty strings</h2><span id='topic+charzero_as_empty'></span>

<h3>Description</h3>

<p>If the argument is a zero-length character vector (character(0)), returns
an empty string (which is a character vector of length 1). Otherwise passes
through the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charzero_as_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charzero_as_empty_+3A_x">x</code></td>
<td>
<p>the object to be tested for zero-length character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an empty string if <code>x</code> is a character vector of length zero, and <code>x</code>
otherwise
</p>

<hr>
<h2 id='coalesce_'>Front-end to dplyr::coalesce to deal with NULL vectors</h2><span id='topic+coalesce_'></span>

<h3>Description</h3>

<p>Replaces any NULL argument with a vector of <code>NA</code>, and casts every vector
to the same type as the last vector. After that, calls <code><a href="dplyr.html#topic+coalesce">dplyr::coalesce()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce__+3A_...">...</code></td>
<td>
<p>the vectors to coalesce on NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same type and length as the last argument
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+coalesce">dplyr::coalesce()</a></code>
</p>

<hr>
<h2 id='expand_prefix'>Expand namespace-prefixed string</h2><span id='topic+expand_prefix'></span>

<h3>Description</h3>

<p>Substitutes the namespace prefix in the input vector of strings with
the corresponding namespaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_prefix(x, namespaces = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_prefix_+3A_x">x</code></td>
<td>
<p>a character vector of potentially namespace-prefixed strings</p>
</td></tr>
<tr><td><code id="expand_prefix_+3A_namespaces">namespaces</code></td>
<td>
<p>a named vector of namespaces, with namespace prefixes
being the names. A &quot;base&quot; namespace with an empty name can be included.
If not provided, or if empty, the input vector is returned as is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Namespace prefixes are expected to be separated by one or more semicolons.
Prefixes that cannot be matched to the vector of namespaces will be left
as is. For strings that do not have a namespace prefix, the vector of
namespaces can contain a base namespace, identified as not having a name,
with which these strings will be expanded.
</p>


<h3>Value</h3>

<p>a character vector, of the same length as the input vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uris &lt;- c("cc:license", "dc:title")
ns &lt;- c(dc = "http://purl.org/dc/elements/1.1/",
        dcterms = "http://purl.org/dc/terms/",
        dct = "http://purl.org/dc/terms/",
        cc = "http://creativecommons.org/ns#")
# expansion is vectorized
expand_prefix(uris, ns)

# strings with non-matching or no prefix are left as is
uris &lt;- c(uris, "my:title", "title")
expand_prefix(uris, ns)

# NAs in the input list become NA in the output
uris &lt;- c(uris, NA)
expand_prefix(uris, ns)

# can include a "base" (unnamed) namespace for expanding unprefixed strings
ns &lt;- c(ns, "//local/")
xuris &lt;- expand_prefix(uris, ns)
xuris
xuris[uris == "title"] == paste0("//local/", uris[uris == "title"])

# different prefixes may expand to the same result
expand_prefix("dcterms:modified", ns) == expand_prefix("dct:modified", ns)

# or they may result in different expansions
expand_prefix("dc:title", ns) != expand_prefix("dcterms:title", ns)
</code></pre>

<hr>
<h2 id='findNextMethod'>Finds the method that callNextMethod() should chain to</h2><span id='topic+findNextMethod'></span>

<h3>Description</h3>

<p>Attempts to find the &quot;next&quot; method in the inheritance chain. This would
(ideally) be the method that <code>methods::callNextMethod()</code> would chain to,
as a result of the method <code>methods::addNextMethod()</code> would find (and return
in the <code>nextMethod</code> slot of the <code>MethodWithNext</code>
object). Hence, in theory one shouldn't ever need this, but unfortunately
<code>addNextMethod()</code> is broken (and errors out) if one of the classes in the
signature name-clashes with an S4 class defined in another package that is
loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNextMethod(method, f = NULL, envir = topenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNextMethod_+3A_method">method</code></td>
<td>
<p><code>MethodDefinition</code>, the method for which to find
the next method</p>
</td></tr>
<tr><td><code id="findNextMethod_+3A_f">f</code></td>
<td>
<p><code>standardGeneric</code>, the standard generic for which to find
the next method. By default this will be obtained from <code>method</code>.</p>
</td></tr>
<tr><td><code id="findNextMethod_+3A_envir">envir</code></td>
<td>
<p>the environment in which to find the method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The next method will be determined by the S4 inheritance chain. However,
this function will walk only the inheritance chain of those arguments in
the signature that are defined in the package of the generic method from
which this function was invoked (directly or indirectly). If there are
no such parameters in the signature, or if there is more than one,
finding the next method is handed off to <code>methods::addNextMethod()</code>.
</p>


<h3>Value</h3>

<p>a <code>MethodDefinition</code> object that is the next method in the
chain by inheritance
</p>


<h3>Note</h3>

<p>In theory a class name clash between packages shouldn't be a problem
because class names can be namespaced, and the <code>MethodDefinition</code>
object passed to <code>addNextMethod()</code> has all the necessary namespace
information. Hopefully, at some point this gets fixed in R, and then we
don't need this anymore.
</p>

<hr>
<h2 id='flatten_multiphylo'>Flatten a multiphylo object</h2><span id='topic+flatten_multiphylo'></span>

<h3>Description</h3>

<p>Flatten a multiphylo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_multiphylo(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_multiphylo_+3A_object">object</code></td>
<td>
<p>a list of multiphylo objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NeXML has the concept of multiple <code style="white-space: pre;">&#8288;&lt;trees&gt;&#8288;</code> nodes, each with multiple child <code style="white-space: pre;">&#8288;&lt;tree&gt;&#8288;</code> nodes.
This maps naturally to a list of multiphylo  objects.  Sometimes
this hierarchy conveys important structural information, so it is not discarded by default.
Occasionally it is useful to flatten the structure though, hence this function.  Note that this
discards the original structure, and the nexml file must be parsed again to recover it.
</p>

<hr>
<h2 id='get_all_meta'>Get flattened list of meta annotations</h2><span id='topic+get_all_meta'></span>

<h3>Description</h3>

<p>Collects recursively (in the case of nested meta annotations) all meta
object annotations for the given object, and returns the result as a flat
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_meta(annotated)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_meta_+3A_annotated">annotated</code></td>
<td>
<p>the object from which to extract meta object annotations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not check that the input object can actually have meta annotations.
An invalid slot error will be generated if it can't.
</p>


<h3>Value</h3>

<p>a flat list of <code>meta</code> objects
</p>

<hr>
<h2 id='get_characters'>Get character data.frame from nexml</h2><span id='topic+get_characters'></span>

<h3>Description</h3>

<p>Get character data.frame from nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_characters(
  nex,
  rownames_as_col = FALSE,
  otu_id = FALSE,
  otus_id = FALSE,
  include_state_types = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_characters_+3A_nex">nex</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_characters_+3A_rownames_as_col">rownames_as_col</code></td>
<td>
<p>option to return character matrix rownames (with taxon ids) as it's own column in the
data.frame. Default is FALSE for compatibility with geiger and similar packages.</p>
</td></tr>
<tr><td><code id="get_characters_+3A_otu_id">otu_id</code></td>
<td>
<p>logical, default FALSE. return a column with the
otu id (for joining with otu metadata, etc)</p>
</td></tr>
<tr><td><code id="get_characters_+3A_otus_id">otus_id</code></td>
<td>
<p>logical, default FALSE. return a column with the
otus block id (for joining with otu metadata, etc)</p>
</td></tr>
<tr><td><code id="get_characters_+3A_include_state_types">include_state_types</code></td>
<td>
<p>logical, default FALSE. whether to also return a
matrix of state types (with values standard, polymorphic, and uncertain)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RNeXML will attempt to return the matrix using the NeXML taxon (otu) labels to name the rows
and the NeXML char labels to name the traits (columns).  If these are unavailable or not unique, the NeXML
id values for the otus or traits will be used instead.
</p>


<h3>Value</h3>

<p>the character matrix as a data.frame, or if <code>include_state_types</code> is
TRUE a list of two elements, <code>characters</code> as the character matrix, and
<code>state_types</code> as a matrix of state types. Both matrices will be in the same
ordering of rows and columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A simple example with a discrete and a continous trait
f &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- read.nexml(f)
get_characters(nex)

# A more complex example -- currently ignores sequence-type characters
f &lt;- system.file("examples", "characters.xml", package="RNeXML")
nex &lt;- read.nexml(f)
get_characters(nex)

# if polymorphic or uncertain states need special treatment, request state
# types to be returned as well:
f &lt;- system.file("examples", "ontotrace-result.xml", package="RNeXML")
nex &lt;- read.nexml(f)
res &lt;- get_characters(nex, include_state_types = TRUE)
row.has.p &lt;- apply(res$state_types, 1, 
                   function(x) any(x == "polymorphic", na.rm = TRUE))
col.has.p &lt;- apply(res$state_types, 2, 
                   function(x) any(x == "polymorphic", na.rm = TRUE))
res$characters[row.has.p, col.has.p, drop=FALSE] # polymorphic rows and cols
res$characters[!row.has.p, drop=FALSE] # drop taxa with polymorphic states
# replace polymorphic state symbols in matrix with '?'
m1 &lt;- mapply(function(s, s.t) ifelse(s.t == "standard", s, "?"), 
             res$characters, res$state_types)
row.names(m1) &lt;- row.names(res$characters)
m1

## End(Not run)
</code></pre>

<hr>
<h2 id='get_characters_list'>Extract the character matrix</h2><span id='topic+get_characters_list'></span>

<h3>Description</h3>

<p>Extract the character matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_characters_list(nexml, rownames_as_col = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_characters_list_+3A_nexml">nexml</code></td>
<td>
<p>nexml object (e.g. from read.nexml)</p>
</td></tr>
<tr><td><code id="get_characters_list_+3A_rownames_as_col">rownames_as_col</code></td>
<td>
<p>option to return character matrix rownames
(with taxon ids) as it's own column in the data.frame. Default is FALSE
for compatibility with geiger and similar packages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of taxa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_characters_list(nex)
</code></pre>

<hr>
<h2 id='get_citation'>Get citation from metadata</h2><span id='topic+get_citation'></span>

<h3>Description</h3>

<p>Extracts the citation annotation from the metadata annotation of the<code>nexml</code>
object, and returns its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_citation(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_citation_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the implementation looks for <code>dcterms:bibliographicCitation</code>
annotations. (Note that these may be given with any prefix in the metadata
so long as they expand to the same full property URIs.)
</p>


<h3>Value</h3>

<p>the citation if the metadata provides one that is non-empty, and
NA otherwise. If multiple non-empty annotations are found, only the first
one is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_metadata_values">get_metadata_values()</a></code>
</p>

<hr>
<h2 id='get_flat_trees'>get_flat_trees</h2><span id='topic+get_flat_trees'></span>

<h3>Description</h3>

<p>extract a single multiPhylo object containing all trees in the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_flat_trees(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_flat_trees_+3A_nexml">nexml</code></td>
<td>
<p>a representation of the nexml object from  which the data is to be retrieved</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this method collapses any hierarchical structure that may have been present as multiple <code>trees</code> nodes in the original nexml (though such a feature is rarely used).  To preserve that structure, use <code><a href="#topic+get_trees">get_trees</a></code> instead.
</p>


<h3>Value</h3>

<p>a multiPhylo object (list of ape::phylo objects).  See details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trees">get_trees</a></code> <code><a href="#topic+get_trees">get_trees</a></code> <code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_flat_trees(nex)
</code></pre>

<hr>
<h2 id='get_level'>get_level</h2><span id='topic+get_level'></span>

<h3>Description</h3>

<p>get a data.frame of attribute values of a given node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_level(nex, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_level_+3A_nex">nex</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_level_+3A_level">level</code></td>
<td>
<p>a character vector indicating the class of node, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>level should be a character vector giving the path to the specified node
group.  For instance, <code>otus</code>, <code>characters</code>, and <code>trees</code> are top-level blocks (e.g.
child nodes of the root nexml block), and can be specified directly.  To get metadata
for all &quot;char&quot; elements from all characters blocks, you must specify that <code>char</code> nodes
are child nodes to <code>character</code> nodes: e.g. <code>get_level(nex, "characters/char")</code>,
or similarly for states: <code>get_level(nex, characters/states)</code>.
</p>
<p>The return object is a data frame whose columns are the attribute names of the elements
specified. The column names match the attribute names except for &quot;id&quot; attribute, for which the column
is renamed using the node itself. (Thus <code style="white-space: pre;">&#8288;&lt;otus id="os2"&gt;&#8288;</code> would be rendered in a data.frame with column
called &quot;otus&quot; instead of &quot;id&quot;). Additional columns are
added for each parent element in the path; e.g. <code>get_level(nex, "otus/otu")</code> would include a column
named &quot;otus&quot; with the id of each otus block.  Even though the method always returns the data frame
for all matching nodes in all blocks, these ids let you see which otu values came from which
otus block.  This is identical to the function call <code>get_taxa()</code>.
Similarly, <code>get_level(nex, "otus/otu/meta")</code> would return additional columns 'otus' and
also a column, 'otu', with the otu parent ids of each metadata block.  (This is identical to a
function call to <code>get_metadata</code>).  This makes it easier to join data.frames as well, see examples
</p>


<h3>Value</h3>

<p>Returns the attributes of specified class of nodes as a data.frame
</p>

<hr>
<h2 id='get_license'>Get license from metadata</h2><span id='topic+get_license'></span>

<h3>Description</h3>

<p>Extracts the license annotation from the metadata annotation of the<code>nexml</code>
object, and returns its value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_license(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_license_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the implementation looks for <code>cc:license</code> and <code>dc:rights</code>
annotations. (Note that these may be given with any prefix in the metadata
so long as they expand to the same full property URIs.)
</p>


<h3>Value</h3>

<p>the license if the metadata asserts one that is non-empty, and
NA otherwise.If multiple non-empty annotations are found, only the first
one is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_metadata_values">get_metadata_values()</a></code>
</p>

<hr>
<h2 id='get_meta'>Extracts meta objects matching properties</h2><span id='topic+get_meta'></span>

<h3>Description</h3>

<p>Extracts the metadata annotations for the given property or properties,
and returns the result as a list of <code>meta</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_meta(nexml, annotated = NULL, props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_meta_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_meta_+3A_annotated">annotated</code></td>
<td>
<p>the nexml component object from which to obtain metadata
annotations, or a list of such objects. Defaults to the nexml object itself.</p>
</td></tr>
<tr><td><code id="get_meta_+3A_props">props</code></td>
<td>
<p>a character vector of property names for which to extract
metadata annotations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For matching property identifiers (i.e., URIs), prefixes in the input list
as well as in the <code>annotated</code> object will be expanded using the namespaces
of the <code>nexml</code> object. Names in the returned list are mapped to the
(possibly prefixed) form in the input list. The resulting list is flat,
and hence does not retain the nesting hierarchy in the object's annotation.
</p>


<h3>Value</h3>

<p>a named list of the matching meta objects
</p>

<hr>
<h2 id='get_metadata'>get_metadata</h2><span id='topic+get_metadata'></span>

<h3>Description</h3>

<p>get_metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata(nexml, level = "nexml", simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metadata_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_metadata_+3A_level">level</code></td>
<td>
<p>the name of the level of element desired, see details</p>
</td></tr>
<tr><td><code id="get_metadata_+3A_simplify">simplify</code></td>
<td>
<p>logical, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'level' should be either the name of a child element of a NeXML document
(e.g. &quot;otu&quot;, &quot;characters&quot;), or a path to the desired element, e.g. 'trees/tree'
will return the metadata for all phylogenies in all trees blocks.
</p>
<p>If a metadata element has other metadata elements nested within it, the
nested metadata are returned as well. A column &quot;Meta&quot; will contain the
IDs consolidated from the type-specific LiteralMeta and ResourceMeta
columns, and IDs are generated for meta elements that have nested elements
but do not have an ID (&quot;blank nodes&quot;). A column &quot;meta&quot; contains the
IDs of the parent meta elements for nested ones. This means that the
resulting table can be self-joined on those columns.
</p>
<p>If <code>simplify</code> is <code>FALSE</code>, the type-specific &quot;LiteralMeta&quot; and &quot;ResourceMeta&quot;
columns will be retained even if a consolidated &quot;Meta&quot; column is present.
Otherwise, only the consolidated column will be included in the result.
Also, if <code>simplify</code> is <code>TRUE</code> the values for &quot;property&quot; (LiteralMeta) and
&quot;rel&quot; (ResourceMeta) will be consolidated to &quot;property&quot;, and &quot;rel&quot; will be
removed from the result.
</p>


<h3>Value</h3>

<p>the requested metadata as a data.frame. Additional columns
indicate the parent element of the return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
comp_analysis &lt;- system.file("examples", "primates.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_metadata(nex)
get_metadata(nex, "otus/otu")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_metadata_values'>Get the value(s) for metadata</h2><span id='topic+get_metadata_values'></span>

<h3>Description</h3>

<p>Extracts the values from the metadata annotations for the given property
or properties, and returns the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metadata_values(nexml, annotated = NULL, props)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metadata_values_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_metadata_values_+3A_annotated">annotated</code></td>
<td>
<p>the nexml component object from which to obtain metadata
annotations, defaults to the nexml object itself</p>
</td></tr>
<tr><td><code id="get_metadata_values_+3A_props">props</code></td>
<td>
<p>a character vector of property names for which to extract
metadata annotations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For matching property identifiers (i.e., URIs), prefixes in the input list
as well as in the <code>annotated</code> object will be expanded using the namespaces
of the <code>nexml</code> object. Names in the returned vector are mapped to the
(possibly prefixed) form in the input list.
</p>


<h3>Value</h3>

<p>a named character vector, giving the values and names being the
property names
</p>

<hr>
<h2 id='get_namespaces'>get namespaces</h2><span id='topic+get_namespaces'></span>

<h3>Description</h3>

<p>get namespaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_namespaces(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_namespaces_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named character vector providing the URLs defining each
of the namespaces used in the nexml file.  Names correspond to
the prefix abbreviations of the namespaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_namespaces(nex)
</code></pre>

<hr>
<h2 id='get_rdf'>Extract rdf-xml from a NeXML file</h2><span id='topic+get_rdf'></span>

<h3>Description</h3>

<p>Extract rdf-xml from a NeXML file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rdf(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rdf_+3A_file">file</code></td>
<td>
<p>the name of a nexml file, or otherwise a nexml object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an RDF-XML object (XMLInternalDocument).  This can be manipulated with
tools from the XML R package, or converted into a triplestore for use with
SPARQL queries from the rdflib R package.
</p>

<hr>
<h2 id='get_taxa'>get_taxa</h2><span id='topic+get_taxa'></span><span id='topic+get_otu'></span>

<h3>Description</h3>

<p>Retrieve names of all species/otus otus (operational taxonomic units) included in the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxa(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxa_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of taxa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_taxa(nex)
</code></pre>

<hr>
<h2 id='get_taxa_list'>get_taxa_list</h2><span id='topic+get_taxa_list'></span><span id='topic+get_otus_list'></span>

<h3>Description</h3>

<p>Retrieve names of all species/otus otus (operational taxonomic units) included in the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxa_list(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxa_list_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of taxa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_item">get_item</a></code>
</p>

<hr>
<h2 id='get_taxa_meta'>get_taxa_meta</h2><span id='topic+get_taxa_meta'></span>

<h3>Description</h3>

<p>Retrieve metadata of all species/otus otus (operational taxonomic units) included in the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxa_meta(nexml, what = "href")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxa_meta_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_taxa_meta_+3A_what">what</code></td>
<td>
<p>One of href, rel, id, or xsi:type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of metadata for each taxon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- add_trees(bird.orders)
birds &lt;- taxize_nexml(birds, "NCBI")
RNeXML:::get_taxa_meta(birds)
RNeXML:::get_taxa_meta(birds, 'rel')
RNeXML:::get_taxa_meta(birds, 'id')
RNeXML:::get_taxa_meta(birds, 'xsi:type')
 
## End(Not run)
</code></pre>

<hr>
<h2 id='get_taxa_meta_list'>get_taxa_meta_list</h2><span id='topic+get_taxa_meta_list'></span>

<h3>Description</h3>

<p>Retrieve metadata of all species/otus otus (operational taxonomic units) included in the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxa_meta_list(nexml, what = "href")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_taxa_meta_list_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="get_taxa_meta_list_+3A_what">what</code></td>
<td>
<p>One of href, rel, id, or xsi:type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of metadata for each taxon
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- add_trees(bird.orders)
birds &lt;- taxize_nexml(birds, "NCBI")
RNeXML:::get_taxa_meta_list(birds)
RNeXML:::get_taxa_meta_list(birds, 'rel')
RNeXML:::get_taxa_meta_list(birds, 'id')
RNeXML:::get_taxa_meta_list(birds, 'xsi:type')

## End(Not run)
</code></pre>

<hr>
<h2 id='get_trees'>extract a phylogenetic tree from the nexml</h2><span id='topic+get_trees'></span>

<h3>Description</h3>

<p>extract a phylogenetic tree from the nexml
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trees(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trees_+3A_nexml">nexml</code></td>
<td>
<p>a representation of the nexml object from
which the data is to be retrieved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ape::phylo tree, if only one tree is represented.
Otherwise returns a list of lists of multiphylo trees.
To consistently receive the list of lists format (preserving
the hierarchical nature of the nexml), use <code><a href="#topic+get_trees_list">get_trees_list</a></code> instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trees">get_trees</a></code> <code><a href="#topic+get_flat_trees">get_flat_trees</a></code> <code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_trees(nex)
</code></pre>

<hr>
<h2 id='get_trees_list'>extract all phylogenetic trees in ape format</h2><span id='topic+get_trees_list'></span>

<h3>Description</h3>

<p>extract all phylogenetic trees in ape format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trees_list(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_trees_list_+3A_nexml">nexml</code></td>
<td>
<p>a representation of the nexml object from
which the data is to be retrieved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of lists of multiphylo trees, even if all trees
are in the same <code>trees</code> node (and hence the outer list will be of length
</p>

<ol>
<li><p> or if there is only a single tree (and hence the inner list will also
be of length 1.  This ensures a consistent return type regardless of
the number of trees present in the nexml file, and also preserves any
grouping of trees.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+get_trees">get_trees</a></code> <code><a href="#topic+get_flat_trees">get_flat_trees</a></code> <code><a href="#topic+get_item">get_item</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
get_trees_list(nex)
</code></pre>

<hr>
<h2 id='lcapply'>Compact list then lapply</h2><span id='topic+lcapply'></span>

<h3>Description</h3>

<p>Compacts the list (i.e., removes NULL objects), then calls <code><a href="base.html#topic+lapply">lapply()</a></code>
on the result with the remaining parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcapply(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcapply_+3A_x">X</code></td>
<td>
<p>the list object</p>
</td></tr>
<tr><td><code id="lcapply_+3A_...">...</code></td>
<td>
<p>remaining arguments to <code>lapply()</code></p>
</td></tr>
</table>

<hr>
<h2 id='meta'>Constructor function for metadata nodes</h2><span id='topic+meta'></span><span id='topic+nexml.meta'></span>

<h3>Description</h3>

<p>Constructor function for metadata nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta(
  property = NULL,
  content = NULL,
  rel = NULL,
  href = NULL,
  datatype = NULL,
  id = NULL,
  type = NULL,
  children = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta_+3A_property">property</code></td>
<td>
<p>specify the ontological definition together with it's namespace, e.g. dc:title</p>
</td></tr>
<tr><td><code id="meta_+3A_content">content</code></td>
<td>
<p>content of the metadata field</p>
</td></tr>
<tr><td><code id="meta_+3A_rel">rel</code></td>
<td>
<p>Ontological definition of the reference provided in href</p>
</td></tr>
<tr><td><code id="meta_+3A_href">href</code></td>
<td>
<p>A link to some reference</p>
</td></tr>
<tr><td><code id="meta_+3A_datatype">datatype</code></td>
<td>
<p>optional RDFa field</p>
</td></tr>
<tr><td><code id="meta_+3A_id">id</code></td>
<td>
<p>optional id element (otherwise id will be automatically generated).</p>
</td></tr>
<tr><td><code id="meta_+3A_type">type</code></td>
<td>
<p>optional xsi:type.  If not given, will use either &quot;LiteralMeta&quot; or &quot;ResourceMeta&quot; as
determined by the presence of either a property or a href value.</p>
</td></tr>
<tr><td><code id="meta_+3A_children">children</code></td>
<td>
<p>Optional element containing any valid XML block (XMLInternalElementNode class, see the XML package for details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User must either provide property+content or rel+href.  Mixing these will result in potential garbage.
The datatype attribute will be detected automatically from the class of the content argument.  Maps from R class
to schema datatypes are as follows:
character - xs:string,
Date - xs:date,
integer - xs:integer,
numeric - xs:decimal,
logical - xs:boolean
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nexml_write">nexml_write</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meta(content="example", property="dc:title")
</code></pre>

<hr>
<h2 id='New'>new with namespaced class name</h2><span id='topic+New'></span>

<h3>Description</h3>

<p>Convenience function for <code><a href="methods.html#topic+new">methods::new()</a></code> that ensures that the provided
class name is namespaced with a package name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>New(Class, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="New_+3A_class">Class</code></td>
<td>
<p>the name of the S4 class to be instantiated</p>
</td></tr>
<tr><td><code id="New_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>methods::new()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the provided class name is not already namespaced (see
<code>methods::packageSlot()</code>), it will be namespaced with this package. This
mechanism is used by <code>new()</code> to disambiguate if the class name clashes
with a class defined in another package.
</p>


<h3>Note</h3>

<p>This may not completely eliminate messages on standard error about
classes with the same name having been found in different packages. If
they appear, they will most likely have come from the call to the
<code>methods::initialize()</code> generic that <code>new()</code> issues at the end.
</p>

<hr>
<h2 id='nexml_add'>add elements to a new or existing nexml object</h2><span id='topic+nexml_add'></span>

<h3>Description</h3>

<p>add elements to a new or existing nexml object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_add(
  x,
  nexml = new("nexml"),
  type = c("trees", "characters", "meta", "namespaces"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_add_+3A_x">x</code></td>
<td>
<p>the object to be added</p>
</td></tr>
<tr><td><code id="nexml_add_+3A_nexml">nexml</code></td>
<td>
<p>an existing nexml object onto which the object should be appended</p>
</td></tr>
<tr><td><code id="nexml_add_+3A_type">type</code></td>
<td>
<p>the type of object being provided.</p>
</td></tr>
<tr><td><code id="nexml_add_+3A_...">...</code></td>
<td>
<p>additional optional arguments to the add functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nexml object with the additional data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_trees">add_trees</a></code> <code><a href="#topic+add_characters">add_characters</a></code> <code><a href="#topic+add_meta">add_meta</a></code> <code><a href="#topic+add_namespaces">add_namespaces</a></code>
</p>

<hr>
<h2 id='nexml_figshare'>publish nexml to figshare</h2><span id='topic+nexml_figshare'></span>

<h3>Description</h3>

<p>publish nexml to figshare
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_figshare(
  nexml,
  file = "nexml.xml",
  categories = "Evolutionary Biology",
  tags = list("phylogeny", "NeXML"),
  visibility = c("public", "private", "draft"),
  id = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_figshare_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object (or file path to a nexml file)</p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_file">file</code></td>
<td>
<p>The filename desired for the object, if nexml is not already a file.
if the first argument is already a path, this value is ignored.</p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_categories">categories</code></td>
<td>
<p>The figshare categories, must match available set. see <code>fs_add_categories</code></p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_tags">tags</code></td>
<td>
<p>Any keyword tags you want to add to the data.</p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_visibility">visibility</code></td>
<td>
<p>whether the results should be published (public), or kept private,
or kept as a draft for further editing before publication.  (New versions can be updated,
but any former versions that was once made public will always be archived and cannot be removed).</p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_id">id</code></td>
<td>
<p>an existing figshare id (e.g. from fs_create), to which this file can be appended.</p>
</td></tr>
<tr><td><code id="nexml_figshare_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the figshare id of the object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- add_trees(bird.orders)
doi &lt;- nexml_figshare(birds, visibility = "public", repository="figshare")

## End(Not run)
</code></pre>

<hr>
<h2 id='nexml_get'>Get the desired element from the nexml object</h2><span id='topic+nexml_get'></span><span id='topic+get_item'></span>

<h3>Description</h3>

<p>Get the desired element from the nexml object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_get(
  nexml,
  element = c("trees", "trees_list", "flat_trees", "metadata", "otu", "taxa",
    "characters", "characters_list", "namespaces"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_get_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object (from read_nexml)</p>
</td></tr>
<tr><td><code id="nexml_get_+3A_element">element</code></td>
<td>
<p>the kind of object desired, see details.</p>
</td></tr>
<tr><td><code id="nexml_get_+3A_...">...</code></td>
<td>
<p>additional arguments, if applicable to certain elements</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>&quot;tree&quot; an ape::phylo tree, if only one tree is represented.  Otherwise returns a list of lists of multiphylo trees.  To consistently receive the list of lists format (preserving the hierarchical nature of the nexml), use <code>trees</code> instead.
</p>
</li>
<li><p>&quot;trees&quot; returns a list of lists of multiphylo trees, even if all trees are in the same <code>trees</code> node (and hence the outer list will be of length 1) or if there is only a single tree (and hence the inner list will also be of length 1.  This ensures a consistent return type regardless of the number of trees present in the nexml file, and also preserves any hierarchy/grouping of trees.  
</p>
</li>
<li><p>&quot;flat_trees&quot; a multiPhylo object (list of ape::phylo objects) Note that this method collapses any hierarchical structure that may have been present as multiple <code>trees</code> nodes in the original nexml (though such a feature is rarely used).  To preserve that structure, use <code>trees</code> instead.
</p>
</li>
<li><p>&quot;metadata&quot;Get metadata from the specified level (default is top/nexml level) 
</p>
</li>
<li><p>&quot;otu&quot; returns a named character vector containing all available metadata.  names indicate <code>property</code> (or <code>rel</code> in the case of links/resourceMeta), while values indicate the <code>content</code> (or <code>href</code> for links). 
</p>
</li>
<li><p>&quot;taxa&quot; alias for otu 
</p>
</li></ul>

<p>For a slightly cleaner interface, each of these elements is also defined as an S4 method
for a nexml object.  So in place of <code>get_item(nexml, "tree")</code>, one could use <code>get_tree(nexml)</code>,
and so forth for each element type.
</p>


<h3>Value</h3>

<p>return type depends on the element requested.  See details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_trees">get_trees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp_analysis &lt;- system.file("examples", "comp_analysis.xml", package="RNeXML")
nex &lt;- nexml_read(comp_analysis)
nexml_get(nex, "trees")
nexml_get(nex, "characters_list")
</code></pre>

<hr>
<h2 id='nexml_publish'>publish nexml files to the web and receive a DOI</h2><span id='topic+nexml_publish'></span>

<h3>Description</h3>

<p>publish nexml files to the web and receive a DOI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_publish(nexml, ..., repository = "figshare")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_publish_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object (or file path)</p>
</td></tr>
<tr><td><code id="nexml_publish_+3A_...">...</code></td>
<td>
<p>additional arguments, depending on repository. See examples.</p>
</td></tr>
<tr><td><code id="nexml_publish_+3A_repository">repository</code></td>
<td>
<p>destination repository</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a digital object identifier to the published data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- add_trees(bird.orders)
doi &lt;- nexml_publish(birds, visibility = "public", repository="figshare")

## End(Not run)
</code></pre>

<hr>
<h2 id='nexml_read'>Read NeXML files into various R formats</h2><span id='topic+nexml_read'></span><span id='topic+read.nexml'></span><span id='topic+nexml_read.character'></span><span id='topic+nexml_read.XMLInternalDocument'></span><span id='topic+nexml_read.XMLInternalNode'></span>

<h3>Description</h3>

<p>Read NeXML files into various R formats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_read(x, ...)

## S3 method for class 'character'
nexml_read(x, ...)

## S3 method for class 'XMLInternalDocument'
nexml_read(x, ...)

## S3 method for class 'XMLInternalNode'
nexml_read(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_read_+3A_x">x</code></td>
<td>
<p>Path to the file to be read in. An <code>XML::XMLDocument-class</code>
or <code><a href="XML.html#topic+XMLNode-class">XMLNode-class</a></code></p>
</td></tr>
<tr><td><code id="nexml_read_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="XML.html#topic+xmlTreeParse">xmlTreeParse</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># file
f &lt;- system.file("examples", "trees.xml", package="RNeXML")
nexml_read(f)
## Not run:  # may take &gt; 5 s
# url
url &lt;- "https://raw.githubusercontent.com/ropensci/RNeXML/master/inst/examples/trees.xml"
nexml_read(url)
# character string of XML
str &lt;- paste0(readLines(f), collapse = "")
nexml_read(str)
# XMLInternalDocument
library("httr")
library("XML")
x &lt;- xmlParse(content(GET(url)))
nexml_read(x)
# XMLInternalNode
nexml_read(xmlRoot(x))

## End(Not run)
</code></pre>

<hr>
<h2 id='nexml_validate'>validate nexml using the online validator tool</h2><span id='topic+nexml_validate'></span>

<h3>Description</h3>

<p>validate nexml using the online validator tool
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_validate(
  file,
  schema = system.file("xsd/nexml.xsd", package = "RNeXML"),
  local = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_validate_+3A_file">file</code></td>
<td>
<p>path to the nexml file to validate</p>
</td></tr>
<tr><td><code id="nexml_validate_+3A_schema">schema</code></td>
<td>
<p>URL of schema (for fallback method only, set by default).</p>
</td></tr>
<tr><td><code id="nexml_validate_+3A_local">local</code></td>
<td>
<p>logical, if TRUE we skip the online validator and rely only on pure XML-schema validation.  This may fail to detect invalid use of some semantic elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires an internet connection if local=FALSE.  see http://www.nexml.org/nexml/phylows/validator for more information in debugging invalid files
</p>


<h3>Value</h3>

<p>TRUE if the file is valid, FALSE or error message otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- nexml_write(bird.orders, "birds_orders.xml")
nexml_validate("birds_orders.xml")
unlink("birds_orders.xml") # delete file to clean up

## End(Not run)
</code></pre>

<hr>
<h2 id='nexml_write'>Write nexml files</h2><span id='topic+nexml_write'></span><span id='topic+write.nexml'></span>

<h3>Description</h3>

<p>Write nexml files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml_write(
  x = nexml(),
  file = NULL,
  trees = NULL,
  characters = NULL,
  meta = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml_write_+3A_x">x</code></td>
<td>
<p>a nexml object, or any phylogeny object (e.g. phylo, phylo4)
that can be coerced into one. Can also be omitted, in which case a new
nexml object will be constructed with the additional parameters specified.</p>
</td></tr>
<tr><td><code id="nexml_write_+3A_file">file</code></td>
<td>
<p>the name of the file to write out</p>
</td></tr>
<tr><td><code id="nexml_write_+3A_trees">trees</code></td>
<td>
<p>phylogenetic trees to add to the nexml file (if not already given in x)
see <code><a href="#topic+add_trees">add_trees</a></code> for details.</p>
</td></tr>
<tr><td><code id="nexml_write_+3A_characters">characters</code></td>
<td>
<p>additional characters</p>
</td></tr>
<tr><td><code id="nexml_write_+3A_meta">meta</code></td>
<td>
<p>A meta element or list of meta elements, see <code><a href="#topic+add_meta">add_meta</a></code></p>
</td></tr>
<tr><td><code id="nexml_write_+3A_...">...</code></td>
<td>
<p>additional arguments to add__basic_meta, such as the title.  See <code><a href="#topic+add_basic_meta">add_basic_meta</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes out a nexml file
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_trees">add_trees</a></code> <code><a href="#topic+add_characters">add_characters</a></code> <code><a href="#topic+add_meta">add_meta</a></code> <code><a href="#topic+nexml_read">nexml_read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Write an ape tree to nexml, analgous to write.nexus:
 library(ape); data(bird.orders)
 ex &lt;- tempfile(fileext=".xml")
 write.nexml(bird.orders, file=ex)
</code></pre>

<hr>
<h2 id='nexml-class'>Class representing a NeXML document</h2><span id='topic+nexml-class'></span><span id='topic+nexml'></span>

<h3>Description</h3>

<p>The <code>nexml</code> class represents a NeXML document, and is the top of the
class hierarchy defined in this package, corresponding to the root node
of the corresponding XML document.
</p>


<h3>Details</h3>

<p>Normally objects of this type are created by the package as a result of
reading a NeXML file, or of converting from another type, such as
<code>ape::phylo</code>. Also, interacting directly with the slots of the class is
normally not necessary. Instead, use the <code>get_XXX()</code> and <code>add_XXX()</code>
functions in the API.
</p>


<h3>Slots</h3>


<dl>
<dt><code>trees</code></dt><dd><p>list, corresponding to the list of <code style="white-space: pre;">&#8288;&lt;trees/&gt;&#8288;</code> elements in
NeXML. Elements will be of class <code>trees</code>.</p>
</dd>
<dt><code>characters</code></dt><dd><p>list, corresponding to the list of <code style="white-space: pre;">&#8288;&lt;characters/&gt;&#8288;</code>
elements in NeXML. Elements will be of class <code>characters</code>.</p>
</dd>
<dt><code>otus</code></dt><dd><p>list, corresponding to the list of <code style="white-space: pre;">&#8288;&lt;otus/&gt;&#8288;</code> elements in NeXML.
Elements will be of class <code>otus</code>.</p>
</dd>
<dt><code>about</code></dt><dd><p>inherited, see <a href="#topic+Annotated-class">Annotated</a></p>
</dd>
<dt><code>meta</code></dt><dd><p>inherited, see <a href="#topic+Annotated-class">Annotated</a></p>
</dd>
<dt><code>xsi:type</code></dt><dd><p>for internal use</p>
</dd>
<dt><code>version</code></dt><dd><p>NeXML schema version, do not change</p>
</dd>
<dt><code>generator</code></dt><dd><p>name of software generating the XML</p>
</dd>
<dt><code>xsi:schemaLocation</code></dt><dd><p>for internal use, do not change</p>
</dd>
<dt><code>namespaces</code></dt><dd><p>named character vector giving the XML namespaces</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+read.nexml">read.nexml()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nex &lt;- nexml() # a nexml object with no further content
nex &lt;- new("nexml") # accomplishes the same thing
nex@generator
length(nex@trees)

data(bird.orders)
nex &lt;- as(bird.orders, "nexml")
summary(nex)
length(nex@trees)
</code></pre>

<hr>
<h2 id='nexml.tree'>Constructor for the respective class</h2><span id='topic+nexml.tree'></span><span id='topic+nexml.trees'></span><span id='topic+nexml.node'></span><span id='topic+nexml.edge'></span><span id='topic+nexml.otu'></span><span id='topic+nexml.otus'></span><span id='topic+nexml.char'></span><span id='topic+nexml.characters'></span><span id='topic+nexml.format'></span><span id='topic+nexml.state'></span><span id='topic+nexml.uncertain_state'></span><span id='topic+nexml.states'></span><span id='topic+nexml.uncertain_states'></span><span id='topic+nexml.polymorphic_states'></span><span id='topic+nexml.member'></span><span id='topic+nexml.matrix'></span><span id='topic+nexml.row'></span><span id='topic+nexml.seq'></span><span id='topic+nexml.cell'></span><span id='topic+nexml.meta_'></span>

<h3>Description</h3>

<p>Creates an instance of the class corresponding to the respective NeXML
element, and initializes its slots with the provided parameters, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexml.tree(...)

nexml.trees(...)

nexml.node(...)

nexml.edge(...)

nexml.otu(...)

nexml.otus(...)

nexml.char(...)

nexml.characters(...)

nexml.format(...)

nexml.state(...)

nexml.uncertain_state(...)

nexml.states(...)

nexml.uncertain_states(...)

nexml.polymorphic_states(...)

nexml.member(...)

nexml.matrix(...)

nexml.row(...)

nexml.seq(...)

nexml.cell(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexml.tree_+3A_...">...</code></td>
<td>
<p>optionally, parameters passed on to <code><a href="methods.html#topic+new">new()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually, users won't need to invoke this directly.
</p>


<h3>See Also</h3>

<p><a href="#topic+meta">nexml.meta()</a> for documentation of <code>nexml.meta()</code>
</p>

<hr>
<h2 id='reset_id_counter'>reset id counter</h2><span id='topic+reset_id_counter'></span>

<h3>Description</h3>

<p>reset the id counter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_id_counter()
</code></pre>

<hr>
<h2 id='simmap_to_nexml'>Convert phylo with attached simmap to nexml object</h2><span id='topic+simmap_to_nexml'></span><span id='topic+nexml_to_simmap'></span>

<h3>Description</h3>

<p>Convert phylo with attached simmap to nexml object
</p>
<p>Convert nexml object with simmap to phylo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simmap_to_nexml(phy, state_ids = NULL)

nexml_to_simmap(nexml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simmap_to_nexml_+3A_phy">phy</code></td>
<td>
<p>a phylo object containing simmap <code>phy$maps</code> element,
from the phytools package</p>
</td></tr>
<tr><td><code id="simmap_to_nexml_+3A_state_ids">state_ids</code></td>
<td>
<p>a named character vector giving the state
names corresponding to the ids used to refer to each state
in nexml.  If null ids will be generated and states taken from
the phy$states names.</p>
</td></tr>
<tr><td><code id="simmap_to_nexml_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nexml representation of the simmap
</p>
<p>a simmap object (phylo object with a <code style="white-space: pre;">&#8288;$maps&#8288;</code> element
for use in phytools functions).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>nexml_to_simmap()</code>: Convert nexml object with simmap to phylo
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>simmap_ex &lt;- read.nexml(system.file("examples","simmap_ex.xml", package="RNeXML"))
phy &lt;- nexml_to_simmap(simmap_ex)
nex &lt;- simmap_to_nexml(phy) 
</code></pre>

<hr>
<h2 id='slot+2CResourceMeta-method'>Access or set slot of S4 object</h2><span id='topic+slot+2CResourceMeta-method'></span><span id='topic+slot-ResourceMeta'></span><span id='topic+slot+3C-+2CResourceMeta-method'></span>

<h3>Description</h3>

<p>See <code><a href="methods.html#topic+slot">methods::slot()</a></code>. This version allows using &quot;property&quot; consistently
for both LiteralMeta and ResourceMeta (which internally uses &quot;rel&quot; because
RDFa does), which is easier to program. It also allows using &quot;meta&quot;
as an alias for &quot;children&quot; for ResourceMeta, to be consistent with the
corresponding slot for instances of <code>Annotated</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ResourceMeta'
slot(object, name)

## S4 replacement method for signature 'ResourceMeta'
slot(object, name) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slot+2B2CResourceMeta-method_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="slot+2B2CResourceMeta-method_+3A_name">name</code></td>
<td>
<p>name of the slot</p>
</td></tr>
<tr><td><code id="slot+2B2CResourceMeta-method_+3A_value">value</code></td>
<td>
<p>the new value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+slot">methods::slot()</a></code>
</p>

<hr>
<h2 id='summary+2Cnexml-method'>Summary method for nexml objects</h2><span id='topic+summary+2Cnexml-method'></span><span id='topic+summary.nexml'></span>

<h3>Description</h3>

<p>Generates a list of various counts of the major elements that comprise a
<a href="#topic+nexml-class">nexml</a> object, such as number of different kinds of blocks,
characters, states, OTUs (taxa), etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'nexml'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Cnexml-method_+3A_object">object</code></td>
<td>
<p>the <a href="#topic+nexml-class">nexml</a> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="methods.html#topic+show">show</a> method uses this summary for pretty-printing a
summary of the NeXML object, but it can be used on its own as well, in
particular for quick inspection of key properties of a NeXML file.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>nblocks</code> the number of trees, otus, and characters blocks
</p>
</li>
<li> <p><code>ncharacters</code> the number of characters in each characters block
</p>
</li>
<li> <p><code>nstates</code> summary statistics of the number of character states per state set
defined for each characters block
</p>
</li>
<li> <p><code>nnonstdstatedefs</code> the number of polymorphic and uncertain states defined
for each character block
</p>
</li>
<li> <p><code>nmatrixrows</code> the number of rows in the matrix for each character block
</p>
</li>
<li> <p><code>ntrees</code> the number of trees contained in each trees block
</p>
</li>
<li> <p><code>notus</code> the number of OTUs defined in each OTUs block
</p>
</li>
<li> <p><code>nmeta</code> a list of the number of the number of metadata annotations at
several levels, specifically:
</p>

<ul>
<li> <p><code>nexml</code> at the top (nexml) level
</p>
</li>
<li> <p><code>otu</code> at the OTU level, for each OTUs block
</p>
</li>
<li> <p><code>char</code> at the character level, for each characters block
</p>
</li>
<li> <p><code>state</code> at the character state level, for each characters block
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>nex &lt;- nexml_read(system.file("examples", "comp_analysis.xml", package = "RNeXML"))
s &lt;- summary(nex)
# number of major blocks:
s$nblocks

# each characters block defines 1 character:
s$ncharacters

# summary stats of states per character (for morphological matrices there is
# typically one state set per character)
s$nstates # note that first block is of continuous type, so no stats there

# pretty-printed summary:
nex # this is the same as show(nex)
</code></pre>

<hr>
<h2 id='taxize_nexml'>taxize nexml</h2><span id='topic+taxize_nexml'></span>

<h3>Description</h3>

<p>Check taxonomic names against the specified service and
add appropriate semantic metadata to the nexml OTU unit
containing the corresponding identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxize_nexml(
  nexml,
  type = c("ncbi", "itis", "col", "tpl", "gbif", "wd"),
  warnings = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxize_nexml_+3A_nexml">nexml</code></td>
<td>
<p>a nexml object</p>
</td></tr>
<tr><td><code id="taxize_nexml_+3A_type">type</code></td>
<td>
<p>the name of the identifier to use</p>
</td></tr>
<tr><td><code id="taxize_nexml_+3A_warnings">warnings</code></td>
<td>
<p>should we show warning messages if no match can be found?</p>
</td></tr>
<tr><td><code id="taxize_nexml_+3A_...">...</code></td>
<td>
<p>additional arguments to <code style="white-space: pre;">&#8288;[taxadb::get_ids()]&#8288;</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(bird.orders)
birds &lt;- add_trees(bird.orders)
birds &lt;- taxize_nexml(birds, "NCBI")

## End(Not run)
</code></pre>

<hr>
<h2 id='toPhylo'>nexml to phylo</h2><span id='topic+toPhylo'></span>

<h3>Description</h3>

<p>nexml to phylo coercion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toPhylo(tree, otus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toPhylo_+3A_tree">tree</code></td>
<td>
<p>an nexml tree element</p>
</td></tr>
<tr><td><code id="toPhylo_+3A_otus">otus</code></td>
<td>
<p>a character string of taxonomic labels, named by the otu ids.
e.g. (from get_otu_maps for the otus set matching the relevant trees node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phylo object.  If a &quot;reconstructions&quot; annotation is found on the
edges, return simmap maps slot as well.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
