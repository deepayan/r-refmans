<!DOCTYPE html><html lang="en"><head><title>Help for package metaheuristicOpt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metaheuristicOpt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABC'><p>Optimization using Artificial Bee Colony Algorithm</p></a></li>
<li><a href='#ALO'><p>Optimization using Ant Lion Optimizer</p></a></li>
<li><a href='#BA'><p>Optimization using Bat Algorithm</p></a></li>
<li><a href='#BHO'><p>Optimization using Black Hole Optimization Algorithm</p></a></li>
<li><a href='#CLONALG'><p>Optimization using Clonal Selection Algorithm</p></a></li>
<li><a href='#CS'><p>Optimization using Cuckoo Search algorithm</p></a></li>
<li><a href='#CSO'><p>Optimization using Cat Swarm Optimization Algorithm</p></a></li>
<li><a href='#DA'><p>Optimization using Dragonfly Algorithm</p></a></li>
<li><a href='#DE'><p>Optimization using Differential Evolution Algorithm</p></a></li>
<li><a href='#FFA'><p>Optimization using Firefly Algorithm</p></a></li>
<li><a href='#GA'><p>Optimization using Genetic Algorithm</p></a></li>
<li><a href='#GBS'><p>Optimization using Gravitational Based Search Algorithm.</p></a></li>
<li><a href='#GOA'><p>Optimization using Grasshopper Optimisation Algorithm</p></a></li>
<li><a href='#GWO'><p>Optimization using Grey Wolf Optimizer</p></a></li>
<li><a href='#HS'><p>Optimization using Harmony Search Algorithm</p></a></li>
<li><a href='#KH'><p>Optimization using Krill-Herd Algorithm</p></a></li>
<li><a href='#metaOpt'><p>metaOpt The main function to execute algorithms for getting optimal solutions</p></a></li>
<li><a href='#MFO'><p>Optimization using Moth Flame Optimizer</p></a></li>
<li><a href='#PSO'><p>Optimization using Prticle Swarm Optimization</p></a></li>
<li><a href='#SCA'><p>Optimization using Sine Cosine Algorithm</p></a></li>
<li><a href='#SFL'><p>Optimization using Shuffled Frog Leaping Algorithm</p></a></li>
<li><a href='#WOA'><p>Optimization using Whale Optimization Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Metaheuristic for Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Lala Septem Riza [aut, cre],
  Iip [aut],
  Eddy Prasetyo Nugroho [aut],
  Muhammad Bima Adi Prabowo [aut],
  Enjun Junaeti [aut],
  Ade Gafar Abdullah [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lala Septem Riza &lt;lala.s.riza@upi.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of metaheuristic algorithms for continuous optimization. Currently, the package contains the implementations of 21 algorithms, as follows: particle swarm optimization (Kennedy and Eberhart, 1995), ant lion optimizer (Mirjalili, 2015 &lt;<a href="https://doi.org/10.1016%2Fj.advengsoft.2015.01.010">doi:10.1016/j.advengsoft.2015.01.010</a>&gt;), grey wolf optimizer (Mirjalili et al., 2014 &lt;<a href="https://doi.org/10.1016%2Fj.advengsoft.2013.12.007">doi:10.1016/j.advengsoft.2013.12.007</a>&gt;), dragonfly algorithm (Mirjalili, 2015 &lt;<a href="https://doi.org/10.1007%2Fs00521-015-1920-1">doi:10.1007/s00521-015-1920-1</a>&gt;), firefly algorithm (Yang, 2009 &lt;<a href="https://doi.org/10.1007%2F978-3-642-04944-6_14">doi:10.1007/978-3-642-04944-6_14</a>&gt;), genetic algorithm (Holland, 1992, ISBN:978-0262581110), grasshopper optimisation algorithm (Saremi et al., 2017 &lt;<a href="https://doi.org/10.1016%2Fj.advengsoft.2017.01.004">doi:10.1016/j.advengsoft.2017.01.004</a>&gt;), harmony search algorithm (Mahdavi et al., 2007 &lt;<a href="https://doi.org/10.1016%2Fj.amc.2006.11.033">doi:10.1016/j.amc.2006.11.033</a>&gt;), moth flame optimizer (Mirjalili, 2015 &lt;<a href="https://doi.org/10.1016%2Fj.knosys.2015.07.006">doi:10.1016/j.knosys.2015.07.006</a>&gt;, sine cosine algorithm (Mirjalili, 2016 &lt;<a href="https://doi.org/10.1016%2Fj.knosys.2015.12.022">doi:10.1016/j.knosys.2015.12.022</a>&gt;),  whale optimization algorithm (Mirjalili and Lewis, 2016 &lt;<a href="https://doi.org/10.1016%2Fj.advengsoft.2016.01.008">doi:10.1016/j.advengsoft.2016.01.008</a>&gt;), clonal selection algorithm (Castro, 2002 &lt;<a href="https://doi.org/10.1109%2FTEVC.2002.1011539">doi:10.1109/TEVC.2002.1011539</a>&gt;), differential evolution (Das &amp; Suganthan, 2011), shuffled frog leaping (Eusuff, Landsey &amp; Pasha, 2006), cat swarm optimization (Chu et al., 2006), artificial bee colony algorithm (Karaboga &amp; Akay, 2009), krill-herd algorithm (Gandomi &amp; Alavi, 2012), cuckoo search (Yang &amp; Deb, 2009), bat algorithm (Yang, 2012), gravitational based search (Rashedi et al., 2009) and black hole optimization (Hatamlou, 2013).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-19 10:05:01 UTC; HP</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-19 12:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABC'>Optimization using Artificial Bee Colony Algorithm</h2><span id='topic+ABC'></span>

<h3>Description</h3>

<p>This is the internal function that implements Artificial Bee Colony
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABC(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, cycleLimit = as.integer(numVar *
  numPopulation))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ABC_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="ABC_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="ABC_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="ABC_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="ABC_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="ABC_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="ABC_+3A_cyclelimit">cycleLimit</code></td>
<td>
<p>a positive integer to determine number of times allowed for
candidate solution to not move.  The default value is <code>as.integer(numVar * numPopulation)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Karaboga &amp; Akay, 2009).
It inspired by type of bee. They are three types of bee employeed,
onlooker and scout. Employed bee work by finding food source.
Onlooker bee work by finding better food source other than foods
that Employed bee found. Scout bee work by removing abandoned food
source. Each candidate solution in ABC algorithm represent as bee
and they will move in 3 phases employed, onlooker and scout.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> Employed bee phase (Perform local search and greedy algorithm for each candidate solution).
</p>
</li>
<li><p> Onlooker bee phase (Perform local search and greedy algorithm for some candidate solutions).
</p>
</li>
<li><p> Scout bee phase (Remove abandoned candidate solutions).
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to employed bee phase.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Karaboga, D., &amp; Akay, B. (2009). A comparative study of artificial bee colony algorithm.
Applied mathematics and computation, 214(1), 108-132.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

# define sphere function as objective function
sphere &lt;- function(x){
    return(sum(x^2))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using artificial bee colony algorithm
resultABC &lt;- ABC(sphere, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using sphere function
optimum.value &lt;- sphere(resultABC)

</code></pre>

<hr>
<h2 id='ALO'>Optimization using Ant Lion Optimizer</h2><span id='topic+ALO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Ant Lion Optimizer
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ALO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="ALO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="ALO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="ALO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="ALO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="ALO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Mirjalili, 2015). The Ant Lion Optimizer (ALO)
algorithm mimics the hunting mechanism of antlions in nature. Five main steps
of hunting prey such as the random walk of ants, building traps, entrapment of
ants in traps, catching preys, and re-building traps are implemented.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of ants and antlions randomly,
calculate the fitness of ants and antlions and find the best antlions as the
elite (determined optimum).
</p>
</li>
<li><p> Update Ants Position: Select an antlion using Roulette Whell then update ants
position based on random walk around selected antlion and elite.
Furthermore, calculate the fitness of all ants.
</p>
</li>
<li><p> Replace an antlion with its corresponding ant, if it becomes fitter
</p>
</li>
<li><p> Update elite if an antlion becomes fitter than the elite
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
elite as the optimal solution for given problem. Otherwise, back to Update Ants Position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili, The Ant Lion Optimizer, Advances in Engineering Software,
Volume 83, 2015, Pages 80-98, ISSN 0965-9978,
https://doi.org/10.1016/j.advengsoft.2015.01.010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 2.22 function

# define schewefel's problem 2.22 function as objective function
schewefels2.22 &lt;- function(x){
   return(sum(abs(x)+prod(abs(x))))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Ant Lion Optimizer
resultALO &lt;- ALO(schewefels2.22, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 2.22 function
optimum.value &lt;- schewefels2.22(resultALO)

</code></pre>

<hr>
<h2 id='BA'>Optimization using Bat Algorithm</h2><span id='topic+BA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Bat
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BA(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, maxFrequency = 0.1, minFrequency = -0.1, gama = 1,
  alphaBA = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="BA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="BA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="BA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="BA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="BA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="BA_+3A_maxfrequency">maxFrequency</code></td>
<td>
<p>a numeric to determine maximum frequency. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="BA_+3A_minfrequency">minFrequency</code></td>
<td>
<p>a numeric to determine minimum frequency. The default value is -0.1.</p>
</td></tr>
<tr><td><code id="BA_+3A_gama">gama</code></td>
<td>
<p>a numeric greater than equal to 1. It use to increase pulse rate. The default value is 1.</p>
</td></tr>
<tr><td><code id="BA_+3A_alphaba">alphaBA</code></td>
<td>
<p>a numeric between 0 and 1. It use to decrease loudness. The default value is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Yang, 2011). It was inspired
by echolocation of bats. Candidate solutions in bat algorithm
are represented by bat. They have flying speed, pulse rate,
loudness and pulse frequency and they move based on them.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> move every candidate solutions based on velocity and pulse frequnecy.
</p>
</li>
<li><p> move some candidate solutions near globak best randomly.
</p>
</li>
<li><p> If a candidate solution have better fitness than global best replace it with new
random candidate solution then increase its pulse rate and decrease its loudness.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to move every candidate solutions.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Yang, X. S., (2011), Bat Algorithm for Multiobjective Optimization,
Int. J. Bio-Inspired Computation, Vol. 3, No. 5, pp.267-274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 1.2 function

# define schewefel's problem 1.2 function as objective function
schewefels1.2 &lt;- function(x){
  dim &lt;- length(x)
  result &lt;- 0
    for(i in 1:dim){
       result &lt;- result + sum(x[1:i])^2
   }
  return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using bat algorithm
resultBA &lt;- BA(schewefels1.2, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 1.2 function
optimum.value &lt;- schewefels1.2(resultBA)

</code></pre>

<hr>
<h2 id='BHO'>Optimization using Black Hole Optimization Algorithm</h2><span id='topic+BHO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Black-Hole based Optimization
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BHO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BHO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="BHO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="BHO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="BHO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="BHO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="BHO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Hatamlou, 2013).
The main inspiration for BHO algorithm originates from black hole
that swallow all nearest star. Black hole represent candidate solution
with best fitness and other candidate solutions as star, so all star
search new best candidate solution while moving towards black-hole.
if star reaches better fitness than black hole, exchange its position.
star that too close to black hole (pass event horizon) wiil be replace
by new random candidate solution.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> select best candidate solution as black hole other as stars.
</p>
</li>
<li><p> change each star location to moving toward black hole.
</p>
</li>
<li><p> If a star reaches a location with lower cost than the black hole, exchange their locations.
</p>
</li>
<li><p> If a star crosses the event horizon of the black hole, replace it
with a new star in a random location in the search space.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Hatamlou, A. (2013). Black hole: A new heuristic optimization approach for data clustering.
Information Sciences, 222(December), 175–184. https://doi.org/10.1016/j.ins.2012.08.023
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the step function

# define step function as objective function
step &lt;- function(x){
    result &lt;- sum(abs((x+0.5))^2)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-100,100), nrow=2)

## calculate the optimum solution using black hole optimization
resultBHO &lt;- BHO(step, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using step function
optimum.value &lt;- step(resultBHO)

</code></pre>

<hr>
<h2 id='CLONALG'>Optimization using Clonal Selection Algorithm</h2><span id='topic+CLONALG'></span>

<h3>Description</h3>

<p>This is the internal function that implements Clonal Selection
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CLONALG(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, selectionSize = as.integer(numPopulation/4),
  multipicationFactor = 0.5, hypermutationRate = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CLONALG_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_selectionsize">selectionSize</code></td>
<td>
<p>a positive integer between 0 and numVar
to determine selection size (see details). The default value is <code>as.integer(numPopulation/4)</code>.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_multipicationfactor">multipicationFactor</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine number of clones. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="CLONALG_+3A_hypermutationrate">hypermutationRate</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine probabilty of variable in
clone candidate solutions to be mutated, close to 1 probability is high and vice versa.
The default value is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Castro &amp; Zuben, 2002). The Clonal Selection Algorithm (CLONALG)
mimics maturation proses of imumune system. CLONALG consist 5 step initialize, selection, clonal,
hypermutation and maturation.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> select top selectionSize candidate solutions from population with best fitness.
</p>
</li>
<li><p> clone each selected candidate solutions.
</p>
</li>
<li><p> hypermutation each variable in cloned candidate solutions.
</p>
</li>
<li><p> maturation combine each hypermutated candidate solution with population.
Select top n candidate solution from population as new population.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Castro, L. &amp; Zuben, F. J. V. (2002).
Learning and optimization using the clonal selection principle.
IEEE Transactions on Evolutionary Computation, Special Issue on
Artificial. Immune Systems, 6(3), 239–251. https://doi.org/10.1109/TEVC.2002.1011539
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the quartic with noise function

# define Quartic with noise function as objective function
quartic &lt;- function(x){
    dim &lt;- length(x)
    result &lt;- sum(c(1:dim)*(x^4))+runif(1)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-1.28, 1.28), nrow=2)

## calculate the optimum solution clonal selection algorithm
resultCLONALG &lt;- CLONALG(quartic, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using quartic with noise function
optimum.value &lt;- quartic(resultCLONALG)

</code></pre>

<hr>
<h2 id='CS'>Optimization using Cuckoo Search algorithm</h2><span id='topic+CS'></span>

<h3>Description</h3>

<p>This is the internal function that implements cuckoo search
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CS(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, abandonedFraction = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CS_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="CS_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="CS_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="CS_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="CS_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="CS_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="CS_+3A_abandonedfraction">abandonedFraction</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine fraction
of population to be replaced. The default value is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Yang &amp; Deb, 2009). This
algorithhm was inspired by behaviour of cuckoo birds which
place its egg on other bird nest. While cuckoo birds putting
the eggs in the nests of other birds they are two possible
outcome. First the owner of the nest will stay on the nest.
Second the owner of the nest will abandon the nest.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> create a mutant vector.
</p>
</li>
<li><p> select a candidate solution in population randomly then compare it with mutant vector.
if mutant vector have better fitness than candidate solution replace candidate solution with
mutant vector.
</p>
</li>
<li><p> replace fraction of population with worst fitness with new random candidate solutions.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to create a mutant vector.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Yang, X. S., &amp; Deb, S. (2009, December). Cuckoo search via Lévy flights. In 2009 World Congress on
Nature &amp; Biologically Inspired Computing (NaBIC) (pp. 210-214). IEEE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

# define sphere function as objective function
sphere &lt;- function(x){
    return(sum(x^2))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution cuckoo search
resultCS &lt;- CS(sphere, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using sphere function
optimum.value &lt;- sphere(resultCS)

</code></pre>

<hr>
<h2 id='CSO'>Optimization using Cat Swarm Optimization Algorithm</h2><span id='topic+CSO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Cat Swarm Optimization
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, mixtureRatio = 0.5, tracingConstant = 0.1,
  maximumVelocity = 1, smp = as.integer(20), srd = 20,
  cdc = as.integer(numVar), spc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CSO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="CSO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="CSO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="CSO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="CSO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="CSO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="CSO_+3A_mixtureratio">mixtureRatio</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine flaging proportion.
higher mixtureRatio increase number of candidate solutions in seeking mode
and vice versa. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="CSO_+3A_tracingconstant">tracingConstant</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine tracingConstant. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="CSO_+3A_maximumvelocity">maximumVelocity</code></td>
<td>
<p>a positive numeric to determine maximumVelocity while candidate solutions
in tracing mode performing local search. The default value is 1.</p>
</td></tr>
<tr><td><code id="CSO_+3A_smp">smp</code></td>
<td>
<p>a positive integer to determine number of duplication in genetic operator. The default value is <code>as.integer(20)</code>.</p>
</td></tr>
<tr><td><code id="CSO_+3A_srd">srd</code></td>
<td>
<p>a positive numeric between 0 and 100 to determine mutation length in genetic operator. The default value is 20.</p>
</td></tr>
<tr><td><code id="CSO_+3A_cdc">cdc</code></td>
<td>
<p>a positive integer between 0 and numVar to determine number of variabel in
candidate solutions in seeking mode to be mutated during mutation step in
genetic operator. The default value is <code>as.integer(numVar)</code>.</p>
</td></tr>
<tr><td><code id="CSO_+3A_spc">spc</code></td>
<td>
<p>a logical. if spc is TRUE smp = smp else smp = smp - 1.  The default value is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Chu, Tsai &amp; Pan, 2006).
This algorithm was inspired by behaviours of felyne. Behaviours of
felyne can be devided into two seeking mode (when flyne rest)
and tracing mode (when felyne chase its prey). candidate solutions divided
into seeking and tracing mode. candidate solution in seeking mode move using
local search while candidate solution in tracing mode move using genetic operator.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> flaging (tracing or seeking) every candidate solution in population based on mixtureRatio randomly.
</p>
</li>
<li><p> candidate solutions in seeking mode move using local search
</p>
</li>
<li><p> candidate solutions in tracing mode move using genetic operator
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to flaging candidate solutions.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Chu, S. C., Tsai, P. W., &amp; Pan, J. S. (2006, August). Cat swarm optimization.
In Pacific Rim international conference on artificial intelligence (pp. 854-858).
Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 2.22 function

# define schewefel's problem 2.22 function as objective function
schewefels2.22 &lt;- function(x){
   return(sum(abs(x)+prod(abs(x))))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Ant Lion Optimizer
resultCSO &lt;- CSO(schewefels2.22, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 2.22 function
optimum.value &lt;- schewefels2.22(resultCSO)

</code></pre>

<hr>
<h2 id='DA'>Optimization using Dragonfly Algorithm</h2><span id='topic+DA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Dragonfly
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DA(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="DA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="DA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="DA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="DA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="DA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Mirjalili, 2015). The main inspiration of the
DA algorithm originates from the static and dynamic swarming behaviours of
dragonflies in nature. Two essential phases of optimization, exploration and
exploitation, are designed by modelling the social interaction of dragonflies
in navigating, searching for foods, and avoiding enemies when swarming
dynamically or statistically.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of dragonflies randomly,
calculate the fitness of dragonflies and find the best dragonfly as
food source and the worst dragonfly as enemy position.
</p>
</li>
<li><p> Calculating Behaviour Weight that affecting fly direction and distance.
First, find the neighbouring dragonflies for each dragonfly then calculate the behaviour weight.
The behaviour weight consist of separation, alignment, cohesion, attracted toward food sources
and distraction from enemy. The neighbouring dragonfly determined by the neighbouring radius
that increasing linearly for each iteration.
</p>
</li>
<li><p> Update the position each dragonfly using behaviour weight and the delta (same as velocity in PSO).
</p>
</li>
<li><p> Calculate the fitness and update food and enemy position
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
food position as the optimal solution for given problem. Otherwise, back to Calculating Behaviour Weight steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili. 2015. Dragonfly algorithm: a new meta-heuristic optimization
technique for solving single-objective, discrete, and multi-objective problems.
Neural Comput. Appl. 27, 4 (May 2015), 1053-1073.
DOI=https://doi.org/10.1007/s00521-015-1920-1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 1.2 function

# define schewefel's problem 1.2 function as objective function
schewefels1.2 &lt;- function(x){
  dim &lt;- length(x)
  result &lt;- 0
    for(i in 1:dim){
       result &lt;- result + sum(x[1:i])^2
   }
  return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using dragonfly algorithm
resultDA &lt;- DA(schewefels1.2, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 1.2 function
optimum.value &lt;- schewefels1.2(resultDA)

</code></pre>

<hr>
<h2 id='DE'>Optimization using Differential Evolution Algorithm</h2><span id='topic+DE'></span>

<h3>Description</h3>

<p>This is the internal function that implements Differential Evolution
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, scalingVector = 0.8, crossOverRate = 0.5,
  strategy = "best 1")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function</p>
</td></tr>
<tr><td><code id="DE_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="DE_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="DE_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="DE_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="DE_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="DE_+3A_scalingvector">scalingVector</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine scalingVector
for mutation operator. The default value is 0.8.</p>
</td></tr>
<tr><td><code id="DE_+3A_crossoverrate">crossOverRate</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine crossOver probability.
The default value is 0.5.</p>
</td></tr>
<tr><td><code id="DE_+3A_strategy">strategy</code></td>
<td>
<p>characters to determine mutation method. They are six methods to choose:
</p>

<ul>
<li><p> &quot;classical&quot;.
</p>
</li>
<li><p> &quot;best 1&quot;
</p>
</li>
<li><p> &quot;target to best&quot;
</p>
</li>
<li><p> &quot;best 2&quot;
</p>
</li>
<li><p> &quot;rand 2&quot;
</p>
</li>
<li><p> &quot;rand 2 dir&quot;
</p>
</li></ul>

<p>details of the mutation methods are on the references. The default value is &quot;best 1&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This Differential Evolution algorithm based on jurnal by (Das &amp; Suganthan, 2011).
Differential Evolution algorithm use genetic operator for optimization such as
mutation, crossover and selection.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> create some mutation vectors as new candidate solutions (mutation operator).
</p>
</li>
<li><p> perform crossover operator.
</p>
</li>
<li><p> perform selection operator.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to create some mutation vector.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Das, S., &amp; Suganthan, P. N. (2011). Differential evolution: A survey of the state-of-the-art.
IEEE transactions on evolutionary computation, 15(1), 4-31.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the step function

# define step function as objective function
step &lt;- function(x){
    result &lt;- sum(abs((x+0.5))^2)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-100,100), nrow=2)

## calculate the optimum solution using differential evolution
resultDE &lt;- DE(step, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using step function
optimum.value &lt;- step(resultDE)

</code></pre>

<hr>
<h2 id='FFA'>Optimization using Firefly Algorithm</h2><span id='topic+FFA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Firefly
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFA(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, B0 = 1, gamma = 1, alphaFFA = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FFA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="FFA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="FFA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="FFA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="FFA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="FFA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="FFA_+3A_b0">B0</code></td>
<td>
<p>a positive integer to determine the attractiveness firefly at r=0. The default value is 1.</p>
</td></tr>
<tr><td><code id="FFA_+3A_gamma">gamma</code></td>
<td>
<p>a positive integer to determine light absorption coefficient. The default value is 1.</p>
</td></tr>
<tr><td><code id="FFA_+3A_alphaffa">alphaFFA</code></td>
<td>
<p>a positive integer to determine randomization parameter. The default value is 0.2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Yang, 2009).
The firefly algorithm (FFA) mimics the behavior of fireflies, which use
a kind of flashing light to communicate with other members of their species.
Since the intensity of the light of a single firefly diminishes with
increasing distance, the FFA is implicitly able to detect local solutions
on its way to the best solution for a given objective function.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of fireflies randomly,
calculate the fitness of fireflies and assumes fitness values as
Light Intensity.
</p>
</li>
<li><p> Update the firefly position based on the attractiveness. The firefly that have higher light
intensity will tend to attract other fireflies. The attracted firefly will move based on
the parameter that given by user.
</p>
</li>
<li><p> Calculate the fitness and update the best firefly position.
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
best position as the optimal solution for given problem. Otherwise, back to Update firefly position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>X.-S. Yang, Firefly algorithms for multimodal optimization, in:
Stochastic Algorithms: Foundations and Applications, SAGA 2009,
Lecture Notes in Computer Sciences, Vol. 5792, pp. 169-178 (2009).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the quartic with noise function
# define Quartic with noise function as objective function
quartic &lt;- function(x){
    dim &lt;- length(x)
    result &lt;- sum(c(1:dim)*(x^4))+runif(1)
    return(result)
}

## Define parameter
B0 &lt;- 1
gamma &lt;- 1
alphaFFA &lt;- 0.2
numVar &lt;- 5
rangeVar &lt;- matrix(c(-1.28,1.28), nrow=2)

## calculate the optimum solution using Firefly Algorithm
resultFFA &lt;- FFA(quartic, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar, B0, gamma, alphaFFA)

## calculate the optimum value using sphere function
optimum.value &lt;- quartic(resultFFA)

</code></pre>

<hr>
<h2 id='GA'>Optimization using Genetic Algorithm</h2><span id='topic+GA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Genetic
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GA(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, Pm = 0.1, Pc = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="GA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="GA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="GA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="GA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="GA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="GA_+3A_pm">Pm</code></td>
<td>
<p>a positive integer to determine mutation probability. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="GA_+3A_pc">Pc</code></td>
<td>
<p>a positive integer to determine crossover probability. The default value is 0.8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic algorithms (GA) were invented by John Holland in the 1960 and
were developed by Holland and his students and colleagues at the
University of Michigan in the 1960 and the 1970. GA are commonly used
to generate high-quality solutions to optimization and search problems
by relying on bio-inspired operators such as mutation, crossover and
selection.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population randomly,
calculate the fitness and save the best fitness as bestPopulation.
</p>
</li>
<li><p> Selection: Select set of individual parent for doing crossover. Number of parent
determined by the crossover probability which defined by user.
In this work, we use method called Roulette Whell Selection.
</p>
</li>
<li><p> Crossover: Doing crossover between two parent from Selection step.
This step done by selecting two point randomly and switching the values between them.
</p>
</li>
<li><p> Mutation : All individu in population have a chance to mutate. When mutation occurs, we
generate the random values to replace the old one.
</p>
</li>
<li><p> Calculate the fitness of each individual and update bestPopulation.
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
bestPopulation as the optimal solution for given problem. Otherwise, back to Selection steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Holland, J. H. 1975. Adaptation in Natural and Artificial Systems.
University of Michigan Press. (Second edition: MIT Press, 1992.)
</p>
<p>Melanie Mitchell. 1998. An Introduction to Genetic Algorithms.
MIT Press, Cambridge, MA, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

# define sphere function as objective function
sphere &lt;- function(x){
    return(sum(x^2))
}

## Define parameter
Pm &lt;- 0.1
Pc &lt;- 0.8
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Genetic Algorithm
resultGA &lt;- GA(sphere, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar, Pm, Pc)

## calculate the optimum value using sphere function
optimum.value &lt;- sphere(resultGA)

</code></pre>

<hr>
<h2 id='GBS'>Optimization using Gravitational Based Search Algorithm.</h2><span id='topic+GBS'></span>

<h3>Description</h3>

<p>This is the internal function that implements Gravitational Based Search
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBS(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, gravitationalConst = max(rangeVar),
  kbest = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GBS_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="GBS_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="GBS_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="GBS_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="GBS_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="GBS_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="GBS_+3A_gravitationalconst">gravitationalConst</code></td>
<td>
<p>a numeric to determine gravitational constant while
calculating total force. The default value is <code>max(rangeVar)</code>.</p>
</td></tr>
<tr><td><code id="GBS_+3A_kbest">kbest</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine fraction of population
with best fitness which will affect every candidate solution in population.
The default value is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Rashedi, 2009).
GBS use newton law of universal gravitation and second law of motion
to optimize. Every candidate solution in population consider having mass and it move
using newton law of universal gravitation and second law of motion.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> calculate gravitational mass of every candidate solution in population.
</p>
</li>
<li><p> calculate total force of every candidate solution in population using
newton law of universal gravitation.
</p>
</li>
<li><p> calculate acceleration of every candidate solution in population using
newton second law of motion.
</p>
</li>
<li><p> update velocity of every candidate solution in population based on its acceleration.
</p>
</li>
<li><p> move every candidate solution in population based on its velocity.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to calculate gravitational mass.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Rashedi, E., Nezamabadi-Pour, H., &amp; Saryazdi, S. (2009).
GSA: a gravitational search algorithm. Information sciences, 179(13), 2232-2248.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 2.22 function

# define schewefel's problem 2.22 function as objective function
schewefels2.22 &lt;- function(x){
   return(sum(abs(x)+prod(abs(x))))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Gravitational Based Search
resultGBS &lt;- GBS(schewefels2.22, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 2.22 function
optimum.value &lt;- schewefels2.22(resultGBS)

</code></pre>

<hr>
<h2 id='GOA'>Optimization using Grasshopper Optimisation Algorithm</h2><span id='topic+GOA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Grasshopper
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOA(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GOA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="GOA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="GOA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="GOA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="GOA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="GOA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grasshopper Optimisation Algorithm (GOA) was proposed by (Mirjalili et al., 2017).
The algorithm mathematically models and mimics the
behaviour of grasshopper swarms in nature for solving optimisation
problems.
</p>


<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Shahrzad Saremi, Seyedali Mirjalili, Andrew Lewis, Grasshopper Optimisation
Algorithm: Theory and application, Advances in Engineering Software,
Volume 105, March 2017, Pages 30-47, ISSN 0965-9978,
https://doi.org/10.1016/j.advengsoft.2017.01.004
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 1.2 function

# define schewefel's problem 1.2 function as objective function
schewefels1.2 &lt;- function(x){
  dim &lt;- length(x)
  result &lt;- 0
    for(i in 1:dim){
       result &lt;- result + sum(x[1:i])^2
   }
  return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using grasshoper algorithm
resultGOA &lt;- GOA(schewefels1.2, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 1.2 function
optimum.value &lt;- schewefels1.2(resultGOA)

</code></pre>

<hr>
<h2 id='GWO'>Optimization using Grey Wolf Optimizer</h2><span id='topic+GWO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Grey Wolf Optimizer
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GWO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GWO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="GWO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="GWO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="GWO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="GWO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="GWO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Mirjalili, 2014), inspired by the behaviour of grey
wolf (Canis lupus). The GWO algorithm mimics the leadership hierarchy and hunting
mechanism of grey wolves in nature. Four types of grey wolves such as alpha, beta,
delta, and omega are employed for simulating the leadership hierarchy.
In addition, the three main steps of hunting, searching for prey, encircling prey,
and attacking prey, are implemented.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of grey wolf randomly,
calculate their fitness and find the best wolf as alpha, second best as
beta and third best as delta. The rest of wolf assumed as omega.
</p>
</li>
<li><p> Update Wolf Position: The position of the wolf is updated depending on the position
of three wolfes (alpha, betha and delta).
</p>
</li>
<li><p> Replace the alpha, betha or delta if new position of wolf have better fitness.
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
alpha as the optimal solution for given problem. Otherwise, back to Update Wolf Position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili, Seyed Mohammad Mirjalili, Andrew Lewis, Grey Wolf Optimizer,
Advances in Engineering Software, Volume 69, 2014, Pages 46-61, ISSN 0965-9978,
https://doi.org/10.1016/j.advengsoft.2013.12.007
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the step function

# define step function as objective function
step &lt;- function(x){
    result &lt;- sum(abs((x+0.5))^2)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-100,100), nrow=2)

## calculate the optimum solution using grey wolf optimizer
resultGWO &lt;- GWO(step, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using step function
optimum.value &lt;- step(resultGWO)

</code></pre>

<hr>
<h2 id='HS'>Optimization using Harmony Search Algorithm</h2><span id='topic+HS'></span>

<h3>Description</h3>

<p>This is the internal function that implements Improved Harmony Search
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HS(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, PAR = 0.3, HMCR = 0.95, bandwith = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HS_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="HS_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="HS_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="HS_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="HS_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="HS_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="HS_+3A_par">PAR</code></td>
<td>
<p>a positive integer to determine the value of Pinch Adjusting Ratio. The default value is 0.3.</p>
</td></tr>
<tr><td><code id="HS_+3A_hmcr">HMCR</code></td>
<td>
<p>a positive integer to determine the Harmony Memory Consideration Rate. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="HS_+3A_bandwith">bandwith</code></td>
<td>
<p>a positive integer to determine the bandwith. The default value is 0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Harmony Search (HS)  was proposed by (Geem et al., 2001)
mimicking the improvisation of music players. Furthermore,
Improved Harmny Search (HS), proposed by Mahdavi, employs a method for
generating new solution vectors that enhances accuracy and convergence
rate of harmony search algorithm.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Step 1. Initialized the problem and algorithm parameters
</p>
</li>
<li><p> Step 2. Initialize the Harmony Memory, creating the Harmony memory and give
random rumber for each memory.
</p>
</li>
<li><p> Step 3. Improvise new Harmony, Generating new Harmony based on parameter defined by user
</p>
</li>
<li><p> Step 4. Update the Harmony Memory, If new harmony have better fitness than the worst harmony in
Harmony Memory, then replace the worst harmony with new Harmony.
</p>
</li>
<li><p> Step 5. Check termination criteria, if termination criterion is satisfied, return the
best Harmony as the optimal solution for given problem. Otherwise, back to Step 3.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Geem, Zong Woo, Joong Hoon Kim, and G. V. Loganathan (2001). &quot;A new
heuristic optimization algorithm: harmony search.&quot; Simulation 76.2: pp. 60-68.
</p>
<p>M. Mahdavi, M. Fesanghary, E. Damangir, An improved harmony search algorithm
for solving optimization problems, Applied Mathematics and Computation,
Volume 188, Issue 2, 2007, Pages 1567-1579, ISSN 0096-3003,
https://doi.org/10.1016/j.amc.2006.11.033
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the quartic with noise function

# define Quartic with noise function as objective function
quartic &lt;- function(x){
    dim &lt;- length(x)
    result &lt;- sum(c(1:dim)*(x^4))+runif(1)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)
PAR &lt;- 0.3
HMCR &lt;- 0.95
bandwith &lt;- 0.05

## calculate the optimum solution using Harmony Search algorithm
resultHS &lt;- HS(quartic, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar, PAR, HMCR, bandwith)

## calculate the optimum value using quartic with noise function
optimum.value &lt;- quartic(resultHS)

</code></pre>

<hr>
<h2 id='KH'>Optimization using Krill-Herd Algorithm</h2><span id='topic+KH'></span>

<h3>Description</h3>

<p>This is the internal function that implements Krill-Herd
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KH(FUN, optimType = "MIN", numVar, numPopulation = 40, maxIter = 500,
  rangeVar, maxMotionInduced = 0.01,
  inertiaWeightOfMotionInduced = 0.01, epsilon = 1e-05,
  foragingSpeed = 0.02, inertiaWeightOfForagingSpeed = 0.01,
  maxDifussionSpeed = 0.01, constantSpace = 1, mu = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KH_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="KH_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="KH_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="KH_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="KH_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="KH_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="KH_+3A_maxmotioninduced">maxMotionInduced</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine
maximum motion induced. The default value is 0.01.</p>
</td></tr>
<tr><td><code id="KH_+3A_inertiaweightofmotioninduced">inertiaWeightOfMotionInduced</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine
how much motion induced affect krill (candidate solution) movement. the
greater the value the greater the affect of motion induced on krill movement.
The default value is 0.01.</p>
</td></tr>
<tr><td><code id="KH_+3A_epsilon">epsilon</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine epsilon constant. The default value is 1e-05.</p>
</td></tr>
<tr><td><code id="KH_+3A_foragingspeed">foragingSpeed</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine foraging speed. The default value is 0.02</p>
</td></tr>
<tr><td><code id="KH_+3A_inertiaweightofforagingspeed">inertiaWeightOfForagingSpeed</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine
how much foraging speed affect krill (candidate solution) movement. the
greater the value the greater the affect of foraging speed on krill movement.
The default value is 0.01.</p>
</td></tr>
<tr><td><code id="KH_+3A_maxdifussionspeed">maxDifussionSpeed</code></td>
<td>
<p>a positive numeric between 0 and 1 to determine maximum
difussion speed. The default value is 0.01.</p>
</td></tr>
<tr><td><code id="KH_+3A_constantspace">constantSpace</code></td>
<td>
<p>a numeric between 0 and 1 to determine how much range affect
krill movement. The default value is 1.</p>
</td></tr>
<tr><td><code id="KH_+3A_mu">mu</code></td>
<td>
<p>a numeric between 0 and 1 to determine constant number for mutation operator.
The default value is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Gandomi &amp; Alavi, 2012).
It was inspired by behaviours of swarm of krill. Every
krill move based on motion induced (such as obstacle, predators),
foraging speed (food source) and physical difussion (swarm density).
In KH algorithm candidate solution represented by krill. KH algorithm
also use genetic operator mutation and crossover.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> calculate total motion based on motion induced, foraging speed and physical
difussion for each candidate solutions and move it based on total motion.
</p>
</li>
<li><p> perform genetic operator crossover and mutation
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to calculate total motion.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Gandomi, A. H., &amp; Alavi, A. H. (2012). Krill herd: a new bio-inspired optimization algorithm.
Communications in nonlinear science and numerical simulation, 17(12), 4831-4845.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

# define sphere function as objective function
sphere &lt;- function(x){
    return(sum(x^2))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution
resultKH &lt;- KH(sphere, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using sphere function
optimum.value &lt;- sphere(resultKH)

</code></pre>

<hr>
<h2 id='metaOpt'>metaOpt The main function to execute algorithms for getting optimal solutions</h2><span id='topic+metaOpt'></span>

<h3>Description</h3>

<p>A main funtion to compute the optimal solution using a selected algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaOpt(FUN, optimType = "MIN", algorithm = "PSO", numVar, rangeVar,
  control = list(), seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaOpt_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="metaOpt_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represents the type of optimization.
There are two options for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, referring the minimization problem.
Otherwise, you can use <code>"MAX"</code> for maximization problem.</p>
</td></tr>
<tr><td><code id="metaOpt_+3A_algorithm">algorithm</code></td>
<td>
<p>a vector or single string value that represent the algorithm used to
do optimization. There are currently twenty one implemented algorithm:
</p>

<ul>
<li> <p><code>"PSO"</code>: Particle Swarm Optimization. See <code><a href="#topic+PSO">PSO</a></code>;
</p>
</li>
<li> <p><code>"ALO"</code>: Ant Lion Optimizer. See <code><a href="#topic+ALO">ALO</a></code>;
</p>
</li>
<li> <p><code>"GWO"</code>: Grey Wolf Optimizer. See <code><a href="#topic+GWO">GWO</a></code>
</p>
</li>
<li> <p><code>"DA"</code> : Dragonfly Algorithm. See <code><a href="#topic+DA">DA</a></code>
</p>
</li>
<li> <p><code>"FFA"</code>: Firefly Algorithm. See <code><a href="#topic+FFA">FFA</a></code>
</p>
</li>
<li> <p><code>"GA"</code> : Genetic Algorithm. See <code><a href="#topic+GA">GA</a></code>
</p>
</li>
<li> <p><code>"GOA"</code>: Grasshopper Optimisation Algorithm. See <code><a href="#topic+GOA">GOA</a></code>
</p>
</li>
<li> <p><code>"HS"</code>: Harmony Search Algorithm. See <code><a href="#topic+HS">HS</a></code>
</p>
</li>
<li> <p><code>"MFO"</code>: Moth Flame Optimizer. See <code><a href="#topic+MFO">MFO</a></code>
</p>
</li>
<li> <p><code>"SCA"</code>: Sine Cosine Algorithm. See <code><a href="#topic+SCA">SCA</a></code>
</p>
</li>
<li> <p><code>"WOA"</code>: Whale Optimization Algorithm. See <code><a href="#topic+WOA">WOA</a></code>
</p>
</li>
<li> <p><code>"CLONALG"</code>: Clonal Selection Algorithm. See <code><a href="#topic+CLONALG">CLONALG</a></code>
</p>
</li>
<li> <p><code>"DE"</code>: Differential Evolution Algorithm. See <code><a href="#topic+DE">DE</a></code>
</p>
</li>
<li> <p><code>"SFL"</code>: Shuffled Frog Leaping Algorithm. See <code><a href="#topic+SFL">SFL</a></code>
</p>
</li>
<li> <p><code>"CSO"</code>: Cat Swarm Optimization Algorithm. See <code><a href="#topic+CSO">CSO</a></code>
</p>
</li>
<li> <p><code>"ABC"</code>: Artificial Bee Colony Algorithm. See <code><a href="#topic+ABC">ABC</a></code>
</p>
</li>
<li> <p><code>"KH"</code>: Krill-Herd Algorithm. See <code><a href="#topic+KH">KH</a></code>
</p>
</li>
<li> <p><code>"CS"</code>: Cuckoo Search Algorithm. See <code><a href="#topic+CS">CS</a></code>
</p>
</li>
<li> <p><code>"BA"</code>: Bat Algorithm. See <code><a href="#topic+BA">BA</a></code>
</p>
</li>
<li> <p><code>"GBS"</code>: Gravitation Based Search Algorithm. See <code><a href="#topic+GBS">GBS</a></code>
</p>
</li>
<li> <p><code>"BHO"</code>: Black Hole Based Optimization Algorithm. See <code><a href="#topic+BHO">BHO</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="metaOpt_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="metaOpt_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="metaOpt_+3A_control">control</code></td>
<td>
<p>a list containing all arguments, depending on the algorithm to use. The following list are
parameters required for each algorithm.
</p>

<ul>
<li> <p><code>PSO</code>:
</p>
<p><code>list(numPopulation, maxIter, Vmax, ci, cg, w)</code>
</p>
</li>
<li> <p><code>ALO</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>GWO</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>DA</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>FFA</code>:
</p>
<p><code>list(numPopulation, maxIter, B0, gamma, alphaFFA)</code>
</p>
</li>
<li> <p><code>GA</code>:
</p>
<p><code>list(numPopulation, maxIter, Pm, Pc)</code>
</p>
</li>
<li> <p><code>GOA</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>HS</code>:
</p>
<p><code>list(numPopulation, maxIter, PAR, HMCR, bandwith)</code>
</p>
</li>
<li> <p><code>MFO</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>SCA</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>WOA</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
</li>
<li> <p><code>CLONALG</code>:
</p>
<p><code>list(numPopulation, maxIter, selectionSize, multipicationFactor, hypermutationRate)</code>
</p>
</li>
<li> <p><code>DE</code>:
</p>
<p><code>list(numPopulation, maxIter, scalingVector, crossOverRate, strategy)</code>
</p>
</li>
<li> <p><code>SFL</code>:
</p>
<p><code>list(numPopulation, maxIter, numMemeplex, frogLeapingIteration)</code>
</p>
</li>
<li> <p><code>CSO</code>:
</p>
<p><code>list(numPopulation, maxIter, mixtureRatio, tracingConstant, maximumVelocity, smp, srd, cdc, spc)</code>
</p>
</li>
<li> <p><code>ABC</code>:
</p>
<p><code>list(numPopulation, maxIter, cycleLimit)</code>
</p>
</li>
<li> <p><code>KH</code>:
</p>
<p><code>list(numPopulation, maxIter, maxMotionInduced, inertiaWeightOfMotionInduced, epsilon, foragingSpeed, inertiaWeightOfForagingSpeed, maxDifussionSpeed, constantSpace, mu)</code>
</p>
</li>
<li> <p><code>CS</code>:
</p>
<p><code>list(numPopulation, maxIter, abandonedFraction)</code>
</p>
</li>
<li> <p><code>BA</code>:
</p>
<p><code>list(numPopulation, maxIter, maxFrequency, minFrequency, gama, alphaBA)</code>
</p>
</li>
<li> <p><code>GBS</code>:
</p>
<p><code>list(numPopulation, maxIter, gravitationalConst, kbest)</code>
</p>
</li>
<li> <p><code>BHO</code>:
</p>
<p><code>list(numPopulation, maxIter)</code>
</p>
<p><b>Description of the <code>control</code> Parameters</b>
</p>

<ul>
<li> <p><code>numPopulation</code>: a positive integer to determine the number populations.
The default value is 40.
</p>
</li>
<li> <p><code>maxIter</code>: a positive integer to determine the maximum number of iterations.
The default value is 500.
</p>
</li>
<li> <p><code>Vmax</code>: a positive integer to determine the maximum velocity of particle.
The default value is 2.
</p>
</li>
<li> <p><code>ci</code>: a positive integer to determine the individual cognitive.
The default value is 1.49445.
</p>
</li>
<li> <p><code>cg</code>: a positive integer to determine the group cognitive.
The default value is 1.49445.
</p>
</li>
<li> <p><code>w</code>: a positive integer to determine the inertia weight.
The default value is 0.729.
</p>
</li>
<li> <p><code>B0</code>: a positive integer to determine the attractiveness firefly at r=0.
The default value is 1.
</p>
</li>
<li> <p><code>gamma</code>: a positive integer to determine light absorption coefficient.
The default value is 1.
</p>
</li>
<li> <p><code>alphaFFA</code>: a positive integer to determine randomization parameter.
The default value is 0.2.
</p>
</li>
<li> <p><code>Pm</code>: a positive integer to determine mutation probability.
The default value is 0.1.
</p>
</li>
<li> <p><code>Pc</code>: a positive integer to determine crossover probability.
The default value is 0.8.
</p>
</li>
<li> <p><code>PAR</code>: a positive integer to determine Pinch Adjusting Rate.
The default value is 0.3.
</p>
</li>
<li> <p><code>HMCR</code>: a positive integer to determine Harmony Memory Considering Rate.
The default value is 0.95.
</p>
</li>
<li> <p><code>bandwith</code>: a positive integer to determine distance bandwith.
The default value is 0.05.
</p>
</li>
<li> <p><code>selectionSize</code>: a positive integer between 0 and numVar to determine selection size.
The default value is <code>as.integer(numPopulation/4)</code>.
</p>
</li>
<li> <p><code>multipicationFactor</code>: a positive numeric between 0 and 1 to determine number of clones.
The default value is 0.5.
</p>
</li>
<li> <p><code>hypermutationRate</code>: a positive numeric between 0 and 1 to determine probabilty of variable in
clone candidate solutions to be mutated, close to 1 probability is high and vice versa.
The default value is 0.1.
</p>
</li>
<li> <p><code>scalingVector</code>: a positive numeric between 0 and 1 to determine scalingVector for mutation operator.
The default value is 0.8.
</p>
</li>
<li> <p><code>crossOverRate</code>: a positive numeric between 0 and 1 to determine crossOver probability.
The default value is 0.5.
</p>
</li>
<li> <p><code>strategy</code>: characters to determine mutation method. They are six methods to choose:
</p>

<ul>
<li><p> &quot;classical&quot;.
</p>
</li>
<li><p> &quot;best 1&quot;
</p>
</li>
<li><p> &quot;target to best&quot;
</p>
</li>
<li><p> &quot;best 2&quot;
</p>
</li>
<li><p> &quot;rand 2&quot;
</p>
</li>
<li><p> &quot;rand 2 dir&quot;
</p>
</li></ul>

<p>The default value is &quot;best 1&quot;.
</p>
</li>
<li> <p><code>numMemeplex</code>: a positive integer (as.integer()) between 0 and numVar to
determine number of memeplex (see details).The default value is <code>as.integer(numPopulation/3)</code>.
</p>
</li>
<li> <p><code>frogLeapingIteration</code>: a positive integer (as.integer()) to determine number
of iteration for each memeplex. The default value is <code>as.integer(10)</code>.
</p>
</li>
<li> <p><code>mixtureRatio</code>: a positive numeric between 0 and 1 to determine flaging proportion.
higher mixtureRatio increase number of candidate solutions in seeking mode
and vice versa. The default value is 0.5.
</p>
</li>
<li> <p><code>tracingConstant</code>: a positive numeric between 0 and 1 to determine tracingConstant.
The default value is 0.1.
</p>
</li>
<li> <p><code>maximumVelocity</code>: a positive numeric to determine maximumVelocity while candidate solutions
in tracing mode performing local search. The default value is 1.
</p>
</li>
<li> <p><code>smp</code>: a positive integer to determine number of duplication in genetic operator.
The default value is <code>as.integer(20)</code>.
</p>
</li>
<li> <p><code>srd</code>: a positive numeric between 0 and 100 to determine mutation length in genetic operator.
The default value is 20.
</p>
</li>
<li> <p><code>cdc</code>: a positive integer between 0 and numVar to determine number of variabel in
candidate solutions in seeking mode to be mutated during mutation step in
genetic operator. The default value is <code>as.integer(numVar)</code>.
</p>
</li>
<li> <p><code>spc</code>: a logical. if spc is TRUE smp = smp else smp = smp - 1. The default value is TRUE.
</p>
</li>
<li> <p><code>cycleLimit</code>: a positive integer to determine number of times allowed for
candidate solution to not move. The default value is <code>as.integer(numVar * numPopulation)</code>.
</p>
</li>
<li> <p><code>maxMotionInduced</code>: a positive numeric between 0 and 1 to determine
maximum motion induced. The default value is 0.01.
</p>
</li>
<li> <p><code>inertiaWeightOfMotionInduced</code>: a positive numeric between 0 and 1 to determine
how much motion induced affect krill (candidate solution) movement. the
greater the value the greater the affect of motion induced on krill movement.
The default value is 0.01.
</p>
</li>
<li> <p><code>epsilon</code>: a positive numeric between 0 and 1 to determine epsilon constant.
The default value is 1e-05.
</p>
</li>
<li> <p><code>foragingSpeed</code>: a positive numeric between 0 and 1 to determine foraging speed.
The default value is 0.02
</p>
</li>
<li> <p><code>inertiaWeightOfForagingSpeed</code>: a positive numeric between 0 and 1 to determine
how much foraging speed affect krill (candidate solution) movement. the
greater the value the greater the affect of foraging speed on krill movement.
The default value is 0.01.
</p>
</li>
<li> <p><code>maxDifussionSpeed</code>: a positive numeric between 0 and 1 to determine maximum
difussion speed. The default value is 0.01.
</p>
</li>
<li> <p><code>constantSpace</code>: a numeric between 0 and 1 to determine how much range affect
krill movement. The default value is 1.
</p>
</li>
<li> <p><code>mu</code>: a numeric between 0 and 1 to determine constant number for mutation operator.
The default value is 0.1.
</p>
</li>
<li> <p><code>abandonedFraction</code>: a positive numeric between 0 and 1 to determine fraction
of population to be replaced. The default value is 0.5.
</p>
</li>
<li> <p><code>maxFrequency</code>: a numeric to determine maximum frequency. The default value is 0.1.
</p>
</li>
<li> <p><code>minFrequency</code>: a numeric to determine minimum frequency. The default value is -0.1.
</p>
</li>
<li> <p><code>gama</code>: a numeric greater than equal to 1. It use to increase pulse rate. The default value is 1.
</p>
</li>
<li> <p><code>alphaBA</code>: a numeric between 0 and 1. It use to decrease loudness. The default value is 0.1.
</p>
</li>
<li> <p><code>gravitationalConst</code>: a numeric to determine gravitational constant while
calculating total force. The default value is <code>max(rangeVar)</code>.
</p>
</li>
<li> <p><code>kbest</code>: a positive numeric between 0 and 1 to determine fraction of population
with best fitness which will affect every candidate solution in population.
The default value is 0.1.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="metaOpt_+3A_seed">seed</code></td>
<td>
<p>a number to determine the seed for RNG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes accessible all algorithm that are implemented
in this package. All of the algorithm use this function as interface to find
the optimal solution, so users do not need to call other functions.
In order to obtain good results, users need to adjust some parameters such as the
objective function, optimum type, number variable or dimension, number populations,
the maximal number of iterations, lower bound, upper bound, or other algorithm-dependent parameters
which are collected in the control parameter.
</p>


<h3>Value</h3>

<p><code>List</code> that contain list of variable, optimum value and execution time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

## Define sphere function as an objective function
sphere &lt;- function(X){
    return(sum(X^2))
}

## Define control variable
control &lt;- list(numPopulation=40, maxIter=100, Vmax=2, ci=1.49445, cg=1.49445, w=0.729)

numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## Define control variable
best.variable &lt;- metaOpt(sphere, optimType="MIN", algorithm="PSO", numVar,
                         rangeVar, control)

</code></pre>

<hr>
<h2 id='MFO'>Optimization using Moth Flame Optimizer</h2><span id='topic+MFO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Moth Flame Optimization
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="MFO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="MFO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="MFO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="MFO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="MFO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed (Mirjalili, 2015). The main inspiration of
this optimizer is the navigation method of moths in nature called transverse
orientation. Moths fly in night by maintaining a fixed angle with respect to
the moon, a very effective mechanism for travelling in a straight line
for long distances. However, these fancy insects are trapped in a useless/deadly
spiral path around artificial lights.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of moth randomly,
calculate the fitness of moth and find the best moth as the best flame obtained so far
The flame indicate the best position obtained by motion of moth. So in this step, position of
flame will same with the position of moth.
</p>
</li>
<li><p> Update Moth Position: All moth move around the corresponding flame.
In every iteration, the number flame is decreasing over the iteration.
So at the end of iteration all moth will move around the best solution obtained so far.
</p>
</li>
<li><p> Replace a flame with the position of moth if a moth becomes fitter than flame
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
best flame as the optimal solution for given problem. Otherwise, back to Update Moth Position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili, Moth-flame optimization algorithm: A novel nature-inspired
heuristic paradigm, Knowledge-Based Systems, Volume 89, 2015, Pages 228-249,
ISSN 0950-7051, https://doi.org/10.1016/j.knosys.2015.07.006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 2.22 function

# define schewefel's problem 2.22 function as objective function
schewefels2.22 &lt;- function(x){
   return(sum(abs(x)+prod(abs(x))))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Moth Flame Optimizer
resultMFO &lt;- MFO(schewefels2.22, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using schewefel's problem 2.22 function
optimum.value &lt;- schewefels2.22(resultMFO)

</code></pre>

<hr>
<h2 id='PSO'>Optimization using Prticle Swarm Optimization</h2><span id='topic+PSO'></span>

<h3>Description</h3>

<p>This is the internal function that implements Particle Swarm Optimization
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PSO(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, Vmax = 2, ci = 1.49445, cg = 1.49445,
  w = 0.729)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PSO_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="PSO_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="PSO_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="PSO_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="PSO_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="PSO_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="PSO_+3A_vmax">Vmax</code></td>
<td>
<p>a positive integer to determine the maximum particle's velocity. The default value is 2.</p>
</td></tr>
<tr><td><code id="PSO_+3A_ci">ci</code></td>
<td>
<p>a positive integer to determine individual cognitive. The default value is 1.49445.</p>
</td></tr>
<tr><td><code id="PSO_+3A_cg">cg</code></td>
<td>
<p>a positive integer to determine group cognitive. The default value is 1.49445.</p>
</td></tr>
<tr><td><code id="PSO_+3A_w">w</code></td>
<td>
<p>a positive integer to determine inertia weight. The default value is 0.729.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Kennedy &amp; Eberhart, 1995), inspired by
the behaviour of the social animals/particles, like a flock of birds in
a swarm. The inertia weight that proposed by Shi and Eberhart is used to
increasing the performance of PSO.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of particles and its corresponding
velocity. Then, calculate the fitness of particles and find the best position as
Global Best and Local Best.
</p>
</li>
<li><p> Update Velocity: Every particle move around search space with specific velocity.
In every iteration, the velocity is depend on two things, Global best and Local best.
Global best is the best position of particle obtained so far, and Local best is the best solution
in current iteration.
</p>
</li>
<li><p> Update particle position. After calculating the new velocity, then the particle move around search
with the new velocity.
</p>
</li>
<li><p> Update Global best and local best if the new particle become fitter.
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
Global best as the optimal solution for given problem. Otherwise, back to Update Velocity steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Kennedy, J. and Eberhart, R. C. Particle swarm optimization.
Proceedings of IEEE International Conference on Neural Networks, Piscataway, NJ. pp. 1942-1948, 1995
</p>
<p>Shi, Y. and Eberhart, R. C. A modified particle swarm optimizer.
Proceedings of the IEEE Congress on Evolutionary Computation (CEC 1998), Piscataway, NJ. pp. 69-73, 1998
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the schewefel's problem 1.2 function

# define schewefel's problem 1.2 function as objective function
schewefels1.2 &lt;- function(x){
  dim &lt;- length(x)
  result &lt;- 0
    for(i in 1:dim){
       result &lt;- result + sum(x[1:i])^2
   }
  return(result)
}

## Define parameter
Vmax &lt;- 2
ci &lt;- 1.5
cg &lt;- 1.5
w &lt;- 0.7
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Particle Swarm Optimization Algorithm
resultPSO &lt;- PSO(schewefels1.2, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar, Vmax, ci, cg, w)

## calculate the optimum value using schewefel's problem 1.2 function
optimum.value &lt;- schewefels1.2(resultPSO)

</code></pre>

<hr>
<h2 id='SCA'>Optimization using Sine Cosine Algorithm</h2><span id='topic+SCA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Sine Cosine
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="SCA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="SCA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="SCA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="SCA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Mirjalili, 2016). The SCA creates multiple initial
random candidate solutions and requires them to fluctuate outwards or towards the
best solution using a mathematical model based on sine and cosine functions. Several
random and adaptive variables also are integrated to this algorithm to emphasize
exploration and exploitation of the search space in different milestones of optimization.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of candidate solution randomly,
calculate the fitness of candidate solution and find the best candidate.
</p>
</li>
<li><p> Update Candidate Position: Update the position with the equation that represent the
behaviour of sine and cosine function.
</p>
</li>
<li><p> Update the best candidate if there are candidate solution with better fitness.
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
best candidate as the optimal solution for given problem. Otherwise, back to Update Candidate Position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili, SCA: A Sine Cosine Algorithm for solving optimization problems,
Knowledge-Based Systems, Volume 96, 2016, Pages 120-133, ISSN 0950-7051,
https://doi.org/10.1016/j.knosys.2015.12.022
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the step function

# define step function as objective function
step &lt;- function(x){
    result &lt;- sum(abs((x+0.5))^2)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-100,100), nrow=2)

## calculate the optimum solution using Sine Cosine Algorithm
resultSCA &lt;- SCA(step, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using step function
optimum.value &lt;- step(resultSCA)

</code></pre>

<hr>
<h2 id='SFL'>Optimization using Shuffled Frog Leaping Algorithm</h2><span id='topic+SFL'></span>

<h3>Description</h3>

<p>This is the internal function that implements Shuffled Frog Leaping
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SFL(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar, numMemeplex = as.integer(numPopulation/3),
  frogLeapingIteration = as.integer(10))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SFL_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="SFL_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="SFL_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="SFL_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="SFL_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="SFL_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
<tr><td><code id="SFL_+3A_nummemeplex">numMemeplex</code></td>
<td>
<p>a positive integer (as.integer()) between 0 and numVar to
determine number of memeplexes (see details). The default value is <code>as.integer(numPopulation/3)</code>.</p>
</td></tr>
<tr><td><code id="SFL_+3A_frogleapingiteration">frogLeapingIteration</code></td>
<td>
<p>a positive integer (as.integer()) to determine number
of iterations for each memeplex. The default value is <code>as.integer(10)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Eusuff, Lansey &amp; Pasha, 2006).
The main inspiration for SFL algorithm originates from how swarm of frogs
finding foods.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> initialize population randomly.
</p>
</li>
<li><p> separate population into &quot;numMemeplex&quot; memeplexes.
</p>
</li>
<li><p> update worst candidate solution using best candidate solution on
each memeplex as much as &quot;frogLeaping Iteration&quot;.
</p>
</li>
<li><p> Shuffled back each memeplexes into population.
</p>
</li>
<li><p> Sort population based on fitness.
</p>
</li>
<li><p> If a termination criterion (a maximum number of iterations or a sufficiently good fitness) is met,
exit the loop, else back to separate population into memeplexes.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Eusuff, M., Lansey, K., &amp; Pasha, F. (2006). Shuffled frog-leaping algorithm:
a memetic meta-heuristic for discrete optimization. Engineering Optimization,
38(2), 129–154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the quartic with noise function

# define Quartic with noise function as objective function
quartic &lt;- function(x){
    dim &lt;- length(x)
    result &lt;- sum(c(1:dim)*(x^4))+runif(1)
    return(result)
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-1.28, 1.28), nrow=2)

## calculate the optimum solution shuffled frog leaping algorithm
resultSFL &lt;- SFL(quartic, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using quartic with noise function
optimum.value &lt;- quartic(resultSFL)

</code></pre>

<hr>
<h2 id='WOA'>Optimization using Whale Optimization Algorithm</h2><span id='topic+WOA'></span>

<h3>Description</h3>

<p>This is the internal function that implements Whale Optimization
Algorithm. It is used to solve continuous optimization tasks.
Users do not need to call it directly,
but just use <code><a href="#topic+metaOpt">metaOpt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WOA(FUN, optimType = "MIN", numVar, numPopulation = 40,
  maxIter = 500, rangeVar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WOA_+3A_fun">FUN</code></td>
<td>
<p>an objective function or cost function,</p>
</td></tr>
<tr><td><code id="WOA_+3A_optimtype">optimType</code></td>
<td>
<p>a string value that represent the type of optimization.
There are two option for this arguments: <code>"MIN"</code> and <code>"MAX"</code>.
The default value is <code>"MIN"</code>, which the function will do minimization.
Otherwise, you can use <code>"MAX"</code> for maximization problem.
The default value is <code>"MIN"</code>.</p>
</td></tr>
<tr><td><code id="WOA_+3A_numvar">numVar</code></td>
<td>
<p>a positive integer to determine the number variables.</p>
</td></tr>
<tr><td><code id="WOA_+3A_numpopulation">numPopulation</code></td>
<td>
<p>a positive integer to determine the number populations. The default value is 40.</p>
</td></tr>
<tr><td><code id="WOA_+3A_maxiter">maxIter</code></td>
<td>
<p>a positive integer to determine the maximum number of iterations. The default value is 500.</p>
</td></tr>
<tr><td><code id="WOA_+3A_rangevar">rangeVar</code></td>
<td>
<p>a matrix (<code class="reqn">2 \times n</code>) containing the range of variables,
where <code class="reqn">n</code> is the number of variables, and first and second rows
are the lower bound (minimum) and upper bound (maximum) values, respectively.
If all variable have equal upper bound, you can define <code>rangeVar</code> as
matrix (<code class="reqn">2 \times 1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm was proposed by (Mirjalili, 2016), which mimics the
social behavior of humpback whales. The algorithm is inspired by the
bubble-net hunting strategy.
</p>
<p>In order to find the optimal solution, the algorithm follow the following steps.
</p>

<ul>
<li><p> Initialization: Initialize the first population of whale randomly,
calculate the fitness of whale and find the best whale position as the
best position obtained so far.
</p>
</li>
<li><p> Update Whale Position: Update the whale position using bubble-net hunting
strategy. The whale position will depend on the best whale position obtained so far.
Otherwise random whale choosen if the specific condition meet.
</p>
</li>
<li><p> Update the best position if there are new whale that have better fitness
</p>
</li>
<li><p> Check termination criteria, if termination criterion is satisfied, return the
best position as the optimal solution for given problem. Otherwise, back to Update Whale Position steps.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Vector [v1, v2, ..., vn]</code> where <code>n</code> is number variable
and <code>vn</code> is value of <code>n-th</code> variable.
</p>


<h3>References</h3>

<p>Seyedali Mirjalili, Andrew Lewis, The Whale Optimization Algorithm,
Advances in Engineering Software, Volume 95, 2016, Pages 51-67,
ISSN 0965-9978, https://doi.org/10.1016/j.advengsoft.2016.01.008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metaOpt">metaOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################
## Optimizing the sphere function

# define sphere function as objective function
sphere &lt;- function(x){
    return(sum(x^2))
}

## Define parameter
numVar &lt;- 5
rangeVar &lt;- matrix(c(-10,10), nrow=2)

## calculate the optimum solution using Ant Lion Optimizer
resultWOA &lt;- WOA(sphere, optimType="MIN", numVar, numPopulation=20,
                 maxIter=100, rangeVar)

## calculate the optimum value using sphere function
optimum.value &lt;- sphere(resultWOA)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
