<!DOCTYPE html><html><head><title>Help for package fedmatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fedmatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#articles'><p>articles</p></a></li>
<li><a href='#build_clean_settings'><p>Building settings for string cleaning</p></a></li>
<li><a href='#build_corpus'><p>Calculate word corpus for weighted jaccard matching</p></a></li>
<li><a href='#build_fuzzy_settings'><p>Build settings for fuzzy matching</p></a></li>
<li><a href='#build_multivar_settings'><p>Build settings for multivar matching</p></a></li>
<li><a href='#build_score_settings'><p>Build settings for scoring</p></a></li>
<li><a href='#build_tier'><p>Build settings for a tier</p></a></li>
<li><a href='#calculate_weights'><p>Calculate weights for computing matchscore</p></a></li>
<li><a href='#clean_strings'><p>String cleaning for easier matching</p></a></li>
<li><a href='#corp_data1'><p>corp_data1</p></a></li>
<li><a href='#corp_data2'><p>corp_data2</p></a></li>
<li><a href='#corporate_words'><p>corporate_words</p></a></li>
<li><a href='#fund_words'><p>fund_words</p></a></li>
<li><a href='#fuzzy_match'><p>Use string distances to match on names</p></a></li>
<li><a href='#match_evaluate'><p>evaluate a matched dataset</p></a></li>
<li><a href='#merge_plus'><p>Merge two datasets either by exact, fuzzy, or multivar-based matching</p></a></li>
<li><a href='#multivar_match'><p>Matching by computing multivar_scores based on several variables</p></a></li>
<li><a href='#sp_char_words'><p>sp_char_words</p></a></li>
<li><a href='#State_FIPS'><p>State_FIPS</p></a></li>
<li><a href='#tier_match'><p>Perform an iterative match by tier</p></a></li>
<li><a href='#wgt_jaccard_distance'><p>Computing Weighted Jaccard Distance</p></a></li>
<li><a href='#word_frequency'><p>Compute frequency of words in a corpus</p></a></li>
<li><a href='#World_Bank_Codes'><p>World_Bank_Codes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast, Flexible, and User-Friendly Record Linkage Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a flexible set of tools for matching two un-linked data sets. 
    'fedmatch' allows for three ways to match data: exact matches, fuzzy matches, and multi-variable matches. 
    It also allows an easy combination of these three matches via the tier matching function.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringdist, SnowballC, stringr, purrr, Rcpp, parallel,
forcats, data.table, magrittr, scales</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-22 21:53:45 UTC; cwebster</td>
</tr>
<tr>
<td>Author:</td>
<td>Melanie Friedrichs [aut],
  Chris Webster [aut, cre],
  Blake Marsh [aut],
  Jacob Dice [aut],
  Seung Lee [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Webster &lt;chris0webster@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-22 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='articles'>articles</h2><span id='topic+articles'></span>

<h3>Description</h3>

<p>Data.frame with common articles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>articles
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 23 rows and 2 columns.
</p>


<h3>See Also</h3>

<p>clean_strings
</p>

<hr>
<h2 id='build_clean_settings'>Building settings for string cleaning</h2><span id='topic+build_clean_settings'></span>

<h3>Description</h3>

<p><code>build_clean_settings</code> is a convenient way to make the proper list for the
<code>clean_settings</code> argument of <code>tier_match</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_clean_settings(
  sp_char_words = fedmatch::sp_char_words,
  common_words = NULL,
  remove_char = NULL,
  remove_words = FALSE,
  stem = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_clean_settings_+3A_sp_char_words">sp_char_words</code></td>
<td>
<p>character vector. Data.frame where first column is special characters and second column is full words. The default is</p>
</td></tr>
<tr><td><code id="build_clean_settings_+3A_common_words">common_words</code></td>
<td>
<p>data.frame. Data.frame where first column is abbreviations and second column is full words.</p>
</td></tr>
<tr><td><code id="build_clean_settings_+3A_remove_char">remove_char</code></td>
<td>
<p>character vector. string of specific characters (for example, &quot;letters&quot;) to be removed</p>
</td></tr>
<tr><td><code id="build_clean_settings_+3A_remove_words">remove_words</code></td>
<td>
<p>logical. If TRUE, removes all abbreviations and replacement words in common_words</p>
</td></tr>
<tr><td><code id="build_clean_settings_+3A_stem">stem</code></td>
<td>
<p>logical. If TRUE, words are stemmed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with settings to pass to <code>clean_strings</code>
</p>

<hr>
<h2 id='build_corpus'>Calculate word corpus for weighted jaccard matching</h2><span id='topic+build_corpus'></span>

<h3>Description</h3>

<p>Calculate word corpus for weighted jaccard matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_corpus(namelist1, namelist2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_corpus_+3A_namelist1">namelist1</code></td>
<td>
<p>character vector of names from dataset 1</p>
</td></tr>
<tr><td><code id="build_corpus_+3A_namelist2">namelist2</code></td>
<td>
<p>character vector of names from dataset 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns for frequency, inverse frequency, and log inverse frequency for each word in the two strings.
</p>

<hr>
<h2 id='build_fuzzy_settings'>Build settings for fuzzy matching</h2><span id='topic+build_fuzzy_settings'></span>

<h3>Description</h3>

<p><code>build_fuzzy_settings</code> is a convenient way to build the list for the fuzzy settings argument in merge_plus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_fuzzy_settings(
  method = "jw",
  p = 0.1,
  maxDist = 0.05,
  matchNA = FALSE,
  nthread = getOption("sd_num_thread")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_fuzzy_settings_+3A_method">method</code></td>
<td>
<p>character vector of length 1. Either one of the methods listed in stringdist::amatch, or our custom method 'wgt_jaccard.' See the vignettes for more details.</p>
</td></tr>
<tr><td><code id="build_fuzzy_settings_+3A_p">p</code></td>
<td>
<p>numeric vector of length 1. See stringdist::amatch()</p>
</td></tr>
<tr><td><code id="build_fuzzy_settings_+3A_maxdist">maxDist</code></td>
<td>
<p>numeric vector of length 1. See stringdist::amatch()</p>
</td></tr>
<tr><td><code id="build_fuzzy_settings_+3A_matchna">matchNA</code></td>
<td>
<p>whether or not to match on NAs, see <code>stringdist::amatch()</code></p>
</td></tr>
<tr><td><code id="build_fuzzy_settings_+3A_nthread">nthread</code></td>
<td>
<p>number of threads to use in the underlying C code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing options for the 'fuzzy_settings' argument of <code>merge_plus</code>.
</p>

<hr>
<h2 id='build_multivar_settings'>Build settings for multivar matching</h2><span id='topic+build_multivar_settings'></span>

<h3>Description</h3>

<p><code>build_multivar_settings</code> is a convenient way to build the list for the multivar settings argument in merge_plus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_multivar_settings(
  logit = NULL,
  missing = FALSE,
  wgts = NULL,
  compare_type = "diff",
  blocks = NULL,
  blocks.x = NULL,
  blocks.y = NULL,
  top = 1,
  threshold = NULL,
  nthread = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_multivar_settings_+3A_logit">logit</code></td>
<td>
<p>a glm or lm model as a result from a logit regression on a verified dataset. See details.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_missing">missing</code></td>
<td>
<p>boolean T/F, whether or not to treat missing (NA) observations as its own binary column for each column in by. See details.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_wgts">wgts</code></td>
<td>
<p>rather than a lm model, you can supply weights to calculate matchscore. Can be weights from <code>calculate_weights</code>.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_compare_type">compare_type</code></td>
<td>
<p>a vector with the same length as &quot;by&quot; that describes how to compare the variables. Options are &quot;in&quot;, &quot;indicator&quot;, &quot;substr&quot;, &quot;difference&quot;, &quot;ratio&quot;, and &quot;stringdist&quot;. See X for details.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_blocks">blocks</code></td>
<td>
<p>variable present in both data sets to &quot;block&quot; on before computing scores. Matchscores will only be computed for observations that share a block. See details.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_blocks.x">blocks.x</code></td>
<td>
<p>name of blocking variables in x. cannot supply both blocks and blocks.x</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_blocks.y">blocks.y</code></td>
<td>
<p>name of blocking variables in y. cannot supply both blocks and blocks.y</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_top">top</code></td>
<td>
<p>integer. Number of matches to return for each observation.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_threshold">threshold</code></td>
<td>
<p>numeric. Minimum score for a match to be included in the result.</p>
</td></tr>
<tr><td><code id="build_multivar_settings_+3A_nthread">nthread</code></td>
<td>
<p>integer. Number of cores to use when computing all combinations. See <code>parallel::makecluster()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing options for the 'multivar_settings' argument of <code>merge_plus</code>.
</p>

<hr>
<h2 id='build_score_settings'>Build settings for scoring</h2><span id='topic+build_score_settings'></span>

<h3>Description</h3>

<p><code>build_score_settings</code> is a convenient way to make the proper list for the
<code>score_settings</code> argument of <code>merge_plus</code> Each vector in build_score_settings
should be the same length, and each position (first, second, third, etc.)
corresponds to one variable to score on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_score_settings(
  score_var_x = NULL,
  score_var_y = NULL,
  score_var_both = NULL,
  wgts = NULL,
  score_type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_score_settings_+3A_score_var_x">score_var_x</code></td>
<td>
<p>character vector. the variables from the 'x' dataset to score on</p>
</td></tr>
<tr><td><code id="build_score_settings_+3A_score_var_y">score_var_y</code></td>
<td>
<p>character vector. the variables from the 'y' dataset to score on</p>
</td></tr>
<tr><td><code id="build_score_settings_+3A_score_var_both">score_var_both</code></td>
<td>
<p>the variables from both datasets (shared names) to score on, before any prefixes are applied.</p>
</td></tr>
<tr><td><code id="build_score_settings_+3A_wgts">wgts</code></td>
<td>
<p>numeric vector. The weights for the linear sum of scores</p>
</td></tr>
<tr><td><code id="build_score_settings_+3A_score_type">score_type</code></td>
<td>
<p>character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing options for the 'score_settings' argument of <code>merge_plus</code>.
</p>

<hr>
<h2 id='build_tier'>Build settings for a tier</h2><span id='topic+build_tier'></span>

<h3>Description</h3>

<p><code>build_tier_settings</code> is a convenient way to make the proper list for the
<code>tier_list</code> argument of <code>tier_match</code> Each vector in build_score_settings
should be the same length, and each position (first, second, third, etc.)
corresponds to one variable to score on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tier(
  by.x = NULL,
  by.y = NULL,
  check_merge = NULL,
  match_type = NULL,
  fuzzy_settings = build_fuzzy_settings(),
  score_settings = NULL,
  filter = NULL,
  filter.args = NULL,
  evaluate = NULL,
  evaluate.args = NULL,
  clean_settings = build_clean_settings(),
  clean = NULL,
  sequential_words = NULL,
  allow.cartesian = FALSE,
  multivar_settings = build_multivar_settings()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tier_+3A_by.x">by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td></tr>
<tr><td><code id="build_tier_+3A_by.y">by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td></tr>
<tr><td><code id="build_tier_+3A_check_merge">check_merge</code></td>
<td>
<p>logical. Checks that your unique_keys are indeed unique.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_match_type">match_type</code></td>
<td>
<p>string. If 'exact', match is exact, if 'fuzzy', match is
fuzzy. If 'multivar,' match is multivar-based. See <code>multivar_match</code>,</p>
</td></tr>
<tr><td><code id="build_tier_+3A_fuzzy_settings">fuzzy_settings</code></td>
<td>
<p>additional arguments for amatch, to be used if match_type
= 'fuzzy'. Suggested defaults provided. (see amatch, method='jw')</p>
</td></tr>
<tr><td><code id="build_tier_+3A_score_settings">score_settings</code></td>
<td>
<p>list. Score settings for post-hoc matchscores.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_filter">filter</code></td>
<td>
<p>function or numeric. Filters a merged data1-data2 dataset. If a
function, should take in a data.frame (data1 and data2 merged by name1 and
name2) and spit out a trimmed verion of the data.frame (fewer rows). Think
of this function as applying other conditions to matches, other than a
match by name. The first argument of filter should be the data.frame. If
numeric, will drop all observations with a matchscore lower than or equal
to filter.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_filter.args">filter.args</code></td>
<td>
<p>list. Arguments passed to filter, if a function</p>
</td></tr>
<tr><td><code id="build_tier_+3A_evaluate">evaluate</code></td>
<td>
<p>Function to evalute merge_plus output.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_evaluate.args">evaluate.args</code></td>
<td>
<p>list. Arguments passed to evaluate</p>
</td></tr>
<tr><td><code id="build_tier_+3A_clean_settings">clean_settings</code></td>
<td>
<p>list. Settings for string cleaning. See <code>clean_strings</code> and <code>build_clean_settings</code>.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_clean">clean</code></td>
<td>
<p>Boolean, T/F, whether or not to clean strings prior to the match.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_sequential_words">sequential_words</code></td>
<td>
<p>data.table of words in the same format of the common_words argument in <code>clean_strings</code>. Each of these will be replaced from the by columns.</p>
</td></tr>
<tr><td><code id="build_tier_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>whether or not to allow many-many matches, see data.table::merge()</p>
</td></tr>
<tr><td><code id="build_tier_+3A_multivar_settings">multivar_settings</code></td>
<td>
<p>list of settings to go to the multivar match if match_type
== 'multivar'. See <code>multivar-match</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing 1 tier for the 'tier_list' argument of <code>tier_match</code>.
</p>

<hr>
<h2 id='calculate_weights'>Calculate weights for computing matchscore</h2><span id='topic+calculate_weights'></span>

<h3>Description</h3>

<p>Calculate weights for comparison variables based on <code class="reqn">m</code> and <code class="reqn">u</code>
probabilities estimated from a verified dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_weights(
  data,
  variables,
  compare_type = "stringdist",
  suffixes = c("_1", "_2"),
  non_negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_weights_+3A_data">data</code></td>
<td>
<p>data.frame. Verified data. Should have all of the variables you want to calculate weights for from both datasets, named the same with data-specific suffixes.</p>
</td></tr>
<tr><td><code id="calculate_weights_+3A_variables">variables</code></td>
<td>
<p>character vector of the variable names of the variables you want to calculate weights for.</p>
</td></tr>
<tr><td><code id="calculate_weights_+3A_compare_type">compare_type</code></td>
<td>
<p>character vector. One of 'stringdist' (for string variables) 'ratio','difference' (for numerics) 'indicator' (0-1 dummy indicating if the two are the same),'in' (0-1 dummy indicating if data1 is IN data2), and 'substr' (numeric indicating how many digits are the same.)</p>
</td></tr>
<tr><td><code id="calculate_weights_+3A_suffixes">suffixes</code></td>
<td>
<p>character vector. Suffixes of of the variables that indicate what data they are from. Default is same as the default for base R merge, c('.x','.y')</p>
</td></tr>
<tr><td><code id="calculate_weights_+3A_non_negative">non_negative</code></td>
<td>
<p>logical. Do you want to allow negative weights?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the classic Record Linkage methodology first developed by Felligi and Sunter.
See <a href="https://en.wikipedia.org/wiki/Record_linkage">Record Linkage</a>. <code class="reqn">m</code> is the
probability of a given link between observations is a true match, while <code class="reqn">u</code> is the probability
of an unlinked pair of observations being a true match. <code>calculate_weights</code>
computes a preliminary weight for each variable by computing
</p>
<p style="text-align: center;"><code class="reqn">w = \log_2 (\frac{m}{u}),</code>
</p>

<p>then making these weights sum to 1. Thus, the weights that have higher <code class="reqn">m</code>
and lower <code class="reqn">u</code> probabilities will get higher weights, which makes sense given
the definitions. These weights can then be easily passed into the <code>score_settings</code>
argument of <code>merge_plus</code> or <code>tier_match</code>, or into the <code>wgts</code> argument of
<code>multivar_match</code>.
</p>


<h3>Value</h3>

<p>list with m probabilities, u probabilites, w weights, and settings, the list argument requried as an input for score_settings in merge_plus using the calculate weights.
</p>

<hr>
<h2 id='clean_strings'>String cleaning for easier matching</h2><span id='topic+clean_strings'></span>

<h3>Description</h3>

<p><code>clean_strings</code> takes a string vector and cleans it according to user-given options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_strings(
  string,
  sp_char_words = fedmatch::sp_char_words,
  common_words = NULL,
  remove_char = NULL,
  remove_words = FALSE,
  stem = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_strings_+3A_string">string</code></td>
<td>
<p>character or character vector of strings</p>
</td></tr>
<tr><td><code id="clean_strings_+3A_sp_char_words">sp_char_words</code></td>
<td>
<p>character vector. Data.frame where first column is special characters and second column is full words. The default is</p>
</td></tr>
<tr><td><code id="clean_strings_+3A_common_words">common_words</code></td>
<td>
<p>data.frame. Data.frame where first column is abbreviations and second column is full words.</p>
</td></tr>
<tr><td><code id="clean_strings_+3A_remove_char">remove_char</code></td>
<td>
<p>character vector. string of specific characters (for example, &quot;letters&quot;) to be removed</p>
</td></tr>
<tr><td><code id="clean_strings_+3A_remove_words">remove_words</code></td>
<td>
<p>logical. If TRUE, removes all abbreviations and replacement words in common_words</p>
</td></tr>
<tr><td><code id="clean_strings_+3A_stem">stem</code></td>
<td>
<p>logical. If TRUE, words are stemmed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a variety of options, each of which changes the behavior.
Without the default settings, <code>clean_strings</code> will do the following:
make the string lowercase; replace special characters &amp;, $, \
names (&quot;and&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;at&quot;); convert tabs to spaces and removes extra spaces.
This default cleaning puts the strings in a standard format to allow for easier matching.
</p>
<p>The other options allow for the removal or replacement of other words or characters.
</p>


<h3>Value</h3>

<p>cleaned strings
</p>

<hr>
<h2 id='corp_data1'>corp_data1</h2><span id='topic+corp_data1'></span>

<h3>Description</h3>

<p>Some made up data on the top 10 US companies in the Fortune 500. Mock-matched to corp_data2 in examples/match_template.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corp_data1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 10 rows and 6 columns.
</p>

<hr>
<h2 id='corp_data2'>corp_data2</h2><span id='topic+corp_data2'></span>

<h3>Description</h3>

<p>Some made up data on the top 10 US companies in the Fortune 500. Mock-matched to corp_data1 in examples/match_template.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corp_data2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 10 rows and 6 columns.
</p>

<hr>
<h2 id='corporate_words'>corporate_words</h2><span id='topic+corporate_words'></span>

<h3>Description</h3>

<p>Data.frame with common corporate abbreviations in column 1 and corresponding long names in column 2. Useful for cleaning company names for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corporate_words
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 54 rows and 2 columns.
</p>


<h3>See Also</h3>

<p>clean_strings
</p>

<hr>
<h2 id='fund_words'>fund_words</h2><span id='topic+fund_words'></span>

<h3>Description</h3>

<p>Data.frame with abbreviations common in the names of financial (i.e. mutual) funds in column 1 and corresponding long names in column 2.  Useful for cleaning fund names for matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fund_words
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 63 rows and 2 columns.
</p>


<h3>See Also</h3>

<p>clean_strings
</p>

<hr>
<h2 id='fuzzy_match'>Use string distances to match on names</h2><span id='topic+fuzzy_match'></span>

<h3>Description</h3>

<p>Use the <code>stringdist</code> package to perform a fuzzy match on two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_match(
  data1,
  data2,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  suffixes,
  unique_key_1,
  unique_key_2,
  fuzzy_settings = list(method = "jw", p = 0.1, maxDist = 0.05, matchNA = FALSE,
    nthread = getOption("sd_num_thread"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fuzzy_match_+3A_data1">data1</code></td>
<td>
<p>data.frame. First to-merge dataset.</p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_data2">data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_by">by</code></td>
<td>
<p>character string. Variables to merge on (common across data 1 and data 2). See <code>merge</code></p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_by.x">by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_by.y">by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_suffixes">suffixes</code></td>
<td>
<p>character vector with length==2. Suffix to add to like named variables after the merge. See <code>merge</code></p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_unique_key_1">unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_unique_key_2">unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="fuzzy_match_+3A_fuzzy_settings">fuzzy_settings</code></td>
<td>
<p>list of arguments to pass to to the fuzzy matching function. See <code>amatch</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stringdist</code> <code>amatch</code> computes string distances between every
pair of strings in two vectors, then picks the closest string pair for each
observation in the dataset. This is used by <code>fuzzy_match</code> to perform
a string distance-based match between two datasets. This process can take quite a long time,
for quicker matches try adjusting the <code>nthread</code> argument in <code>fuzzy_settings</code>.
The default fuzzy_settings are sensible starting points for company name matching,
but adjusting these can greatly change how the match performs.
</p>


<h3>Value</h3>

<p>a data.table, the resultant merged data set, including all columns from both data sets.
</p>

<hr>
<h2 id='match_evaluate'>evaluate a matched dataset</h2><span id='topic+match_evaluate'></span>

<h3>Description</h3>

<p><code>match_evaluate</code> takes in matches and outputs summary statistics for those matches, including
the number of matches in each tier and the percent matched from each dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_evaluate(
  matches,
  data1,
  data2,
  unique_key_1,
  unique_key_2,
  suffixes = c("_1", "_1"),
  tier = "tier",
  tier_order = NULL,
  quality_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_evaluate_+3A_matches">matches</code></td>
<td>
<p>data.frame. Merged dataset.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_data1">data1</code></td>
<td>
<p>data.frame. First to-merge dataset.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_data2">data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_unique_key_1">unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_unique_key_2">unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_suffixes">suffixes</code></td>
<td>
<p>character vector. Mnemonics associated data1 and data2.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_tier">tier</code></td>
<td>
<p>character vector. Default=NULL. The variable that defines a tier.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_tier_order">tier_order</code></td>
<td>
<p>character vector. Default= &quot;tier&quot;. Variable that defines the order of tiers, if needed.</p>
</td></tr>
<tr><td><code id="match_evaluate_+3A_quality_vars">quality_vars</code></td>
<td>
<p>character vector. Variables you want to use to calculate the quality of each tier. Calculates mean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most straightforward way to use <code>match_evaluate</code> is to pass it to the <code>evaluate</code>
argument of <code>tier_match</code> or <code>merge_plus</code>. This will have <code>merge_plus</code>
return a data.table with the evaluation information, alongside the matches themselves.
</p>
<p>I
</p>
<p><code>match_evaluate</code> returns the number of matches in each tier, the number of
unique matches in each tier, and the percent matched for each dataset. If no tiers are supplied,
the entire dataset will be used as one &quot;tier.&quot;
The argument <code>quality_vars</code> allows for the calculation of averages of any columns in the dataset, by tier.
The most straightforward case would be a matchscore, which can again all be done
in <code>merge_plus</code> with the scoring argument. This lets you see the average matchscore by tier.
</p>


<h3>Value</h3>

<p>data.table. Table describing each tier according to aggregate_by variables and quality_vars variables.
</p>


<h3>See Also</h3>

<p>merge_plus
</p>

<hr>
<h2 id='merge_plus'>Merge two datasets either by exact, fuzzy, or multivar-based matching</h2><span id='topic+merge_plus'></span>

<h3>Description</h3>

<p><code>merge_plus</code> is a wrapper for a standard merge, a fuzzy string match,
and a a &ldquo;multivar&rdquo; match based on several columns of the data. Parameters allow
for control for fine-tuning of the match. This is primarily used as the
workhorse for the <code>tier_match</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_plus(
  data1,
  data2,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  suffixes = c("_1", "_2"),
  check_merge = TRUE,
  unique_key_1,
  unique_key_2,
  match_type = "exact",
  fuzzy_settings = build_fuzzy_settings(),
  score_settings = NULL,
  filter = NULL,
  filter.args = list(),
  evaluate = match_evaluate,
  evaluate.args = list(),
  allow.cartesian = FALSE,
  multivar_settings = build_multivar_settings()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_plus_+3A_data1">data1</code></td>
<td>
<p>data.frame. First to-merge dataset (ordering matters - see Fuzzy Matching vignette.)</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_data2">data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_by">by</code></td>
<td>
<p>character string. Variables to merge on (common across data 1 and
data 2). See <code>merge</code></p>
</td></tr>
<tr><td><code id="merge_plus_+3A_by.x">by.x</code></td>
<td>
<p>length-1 character vector. Variable to merge on in data1. See <code>merge</code></p>
</td></tr>
<tr><td><code id="merge_plus_+3A_by.y">by.y</code></td>
<td>
<p>length-1 character vector. Variable to merge on in data2. See <code>merge</code></p>
</td></tr>
<tr><td><code id="merge_plus_+3A_suffixes">suffixes</code></td>
<td>
<p>character vector with length==2. Suffix to add to like named
variables after the merge. See <code>merge</code></p>
</td></tr>
<tr><td><code id="merge_plus_+3A_check_merge">check_merge</code></td>
<td>
<p>logical. Checks that your unique_keys are indeed unique.</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_unique_key_1">unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely
identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_unique_key_2">unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely
identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_match_type">match_type</code></td>
<td>
<p>string. If 'exact', match is exact, if 'fuzzy', match is
fuzzy. If 'multivar,' match is multivar-based. See <code>multivar_match</code>,</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_fuzzy_settings">fuzzy_settings</code></td>
<td>
<p>additional arguments for amatch, to be used if match_type
= 'fuzzy'. Suggested defaults provided. See <code>build_fuzzy_settings</code>.</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_score_settings">score_settings</code></td>
<td>
<p>list. Score settings for post-hoc matchscores. See <code>build_score_settings</code></p>
</td></tr>
<tr><td><code id="merge_plus_+3A_filter">filter</code></td>
<td>
<p>function or numeric. Filters a merged data1-data2 dataset. If a
function, should take in a data.frame (data1 and data2 merged by name1 and
name2) and spit out a trimmed verion of the data.frame (fewer rows). Think
of this function as applying other conditions to matches, other than a
match by name. The first argument of filter should be the data.frame. If
numeric, will drop all observations with a matchscore lower than or equal
to filter.</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_filter.args">filter.args</code></td>
<td>
<p>list. Arguments passed to filter, if a function</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_evaluate">evaluate</code></td>
<td>
<p>Function to evalute merge_plus output.</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_evaluate.args">evaluate.args</code></td>
<td>
<p>list. Arguments passed to evaluate</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>whether or not to allow many-many matches, see data.table::merge()</p>
</td></tr>
<tr><td><code id="merge_plus_+3A_multivar_settings">multivar_settings</code></td>
<td>
<p>list of settings to go to the multivar match if match_type
== 'multivar'. See <code>multivar-match</code> and <code>build_multivar_settings</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with matches, filtered matches (if applicable), data1 and data2
minus matches, and match evaluation
</p>


<h3>See Also</h3>

<p>match_evaluate
</p>

<hr>
<h2 id='multivar_match'>Matching by computing multivar_scores based on several variables</h2><span id='topic+multivar_match'></span>

<h3>Description</h3>

<p><code>multivar_match</code> computes a multivar_score between each pair of observations between
datasets x and y using several variables, then executes a merge by picking the
highest multivar_score pair for each observation in x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivar_match(
  data1,
  data2,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  unique_key_1,
  unique_key_2,
  logit = NULL,
  missing = FALSE,
  wgts = NULL,
  compare_type = "diff",
  blocks = NULL,
  blocks.x = NULL,
  blocks.y = NULL,
  nthread = 1,
  top = 1,
  threshold = NULL,
  suffixes = c("_1", "_2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivar_match_+3A_data1">data1</code></td>
<td>
<p>data.frame. First to-merge dataset.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_data2">data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_by">by</code></td>
<td>
<p>character string. Variables to merge on (common across data 1 and data 2). See <code>merge</code></p>
</td></tr>
<tr><td><code id="multivar_match_+3A_by.x">by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td></tr>
<tr><td><code id="multivar_match_+3A_by.y">by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td></tr>
<tr><td><code id="multivar_match_+3A_unique_key_1">unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_unique_key_2">unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_logit">logit</code></td>
<td>
<p>a glm or lm model as a result from a logit regression on a verified dataset. See details.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_missing">missing</code></td>
<td>
<p>boolean T/F, whether or not to treat missing (NA) observations as its own binary column for each column in by. See details.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_wgts">wgts</code></td>
<td>
<p>rather than a lm model, you can supply weights to calculate multivar_score. Can be weights from <code>calculate_weights</code>.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_compare_type">compare_type</code></td>
<td>
<p>a vector with the same length as &quot;by&quot; that describes how to compare the variables. Options are &quot;in&quot;, &quot;indicator&quot;, &quot;substr&quot;, &quot;difference&quot;, &quot;ratio&quot;, and &quot;stringdist&quot;. See X for details.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_blocks">blocks</code></td>
<td>
<p>variable present in both data sets to &quot;block&quot; on before computing scores. multivar_scores will only be computed for observations that share a block. See details.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_blocks.x">blocks.x</code></td>
<td>
<p>name of blocking variables in x. cannot supply both blocks and blocks.x</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_blocks.y">blocks.y</code></td>
<td>
<p>name of blocking variables in y. cannot supply both blocks and blocks.y</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_nthread">nthread</code></td>
<td>
<p>integer. Number of cores to use when computing all combinations. See <code>parallel::makecluster()</code></p>
</td></tr>
<tr><td><code id="multivar_match_+3A_top">top</code></td>
<td>
<p>integer. Number of matches to return for each observation.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_threshold">threshold</code></td>
<td>
<p>numeric. Minimum score for a match to be included in the result.</p>
</td></tr>
<tr><td><code id="multivar_match_+3A_suffixes">suffixes</code></td>
<td>
<p>see <code>merge</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best way to understand this function is to see the vignette 'Multivar_matching'.
</p>
<p>There are two ways of performing this match: either with or without a pre-trained logit.
To use a logit, you must have a verified set of matches. The names of the variables
in this set must match the names of the variables in the data you pass into <code>multivar_match</code>.
Without a pre-trained logit, you must have a set of weights for each variable that you
want in the comparison. These can either be made up ahead of time, or you can
use a verified set of matches and <code>calculate_weights</code>.
</p>


<h3>Value</h3>

<p>a data.table, the resultant match, including columns from both data sets.
</p>

<hr>
<h2 id='sp_char_words'>sp_char_words</h2><span id='topic+sp_char_words'></span>

<h3>Description</h3>

<p>Common special characters and their replacements for string cleaning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_char_words
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 4 rows and 2 columns.
</p>

<hr>
<h2 id='State_FIPS'>State_FIPS</h2><span id='topic+State_FIPS'></span>

<h3>Description</h3>

<p>Data.table with state FIPS codes and abbreviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>State_FIPS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 55 rows and 3 columns.
</p>

<hr>
<h2 id='tier_match'>Perform an iterative match by tier</h2><span id='topic+tier_match'></span>

<h3>Description</h3>

<p>Constructs a tier_match by running <code>merge_plus</code> with different parameters sequentially
on the same data. Allows for sequential removal of observations after each tier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tier_match(
  data1,
  data2,
  by = NULL,
  by.x = NULL,
  by.y = NULL,
  suffixes = c("_1", "_2"),
  check_merge = TRUE,
  unique_key_1,
  unique_key_2,
  tiers = list(),
  takeout = "both",
  match_type = "exact",
  clean = FALSE,
  clean_settings = build_clean_settings(),
  score_settings = NULL,
  filter = NULL,
  filter.args = list(),
  evaluate = match_evaluate,
  evaluate.args = list(),
  allow.cartesian = TRUE,
  fuzzy_settings = build_fuzzy_settings(),
  multivar_settings = build_multivar_settings(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tier_match_+3A_data1">data1</code></td>
<td>
<p>data.frame. First to-merge dataset.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_data2">data2</code></td>
<td>
<p>data.frame. Second to-merge dataset.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_by">by</code></td>
<td>
<p>character string. Variables to merge on (common across data 1 and data 2). See <code>merge</code></p>
</td></tr>
<tr><td><code id="tier_match_+3A_by.x">by.x</code></td>
<td>
<p>character string. Variable to merge on in data1. See <code>merge</code></p>
</td></tr>
<tr><td><code id="tier_match_+3A_by.y">by.y</code></td>
<td>
<p>character string. Variable to merge on in data2. See <code>merge</code></p>
</td></tr>
<tr><td><code id="tier_match_+3A_suffixes">suffixes</code></td>
<td>
<p>see <code>merge</code></p>
</td></tr>
<tr><td><code id="tier_match_+3A_check_merge">check_merge</code></td>
<td>
<p>logical. Checks that your unique_keys are indeed unique, and prevents merge from running if merge would result in data.frames larger than 5 million rows</p>
</td></tr>
<tr><td><code id="tier_match_+3A_unique_key_1">unique_key_1</code></td>
<td>
<p>character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="tier_match_+3A_unique_key_2">unique_key_2</code></td>
<td>
<p>character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)</p>
</td></tr>
<tr><td><code id="tier_match_+3A_tiers">tiers</code></td>
<td>
<p>list(). tier is a list of lists, where each list holds the parameters for creating that tier. All arguments to tier_match listed after this argument can either be supplied directly to tier_match, or indirectly via tiers.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_takeout">takeout</code></td>
<td>
<p>character vector, either 'data1', 'data2', 'both', or 'neither'. Removes observations after each tier from the selected dataset.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_match_type">match_type</code></td>
<td>
<p>string. If 'exact', match is exact, if 'fuzzy', match is fuzzy.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_clean">clean</code></td>
<td>
<p>Boolean, T/F, whether or not to clean strings prior to the match.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_clean_settings">clean_settings</code></td>
<td>
<p>list. Settings for string cleaning. See <code>clean_strings</code> and <code>build_clean_settings</code>.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_score_settings">score_settings</code></td>
<td>
<p>list. Settings for post-hoc matchscoring. See <code>build_score_settings</code>.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_filter">filter</code></td>
<td>
<p>function or numeric. Filters a merged data1-data2 dataset. If a function, should take in
a data.frame (data1 and data2 merged by name1 and name2) and spit out a trimmed verion
of the data.frame (fewer rows). Think of this function as applying other conditions
to matches, other than a match by name. The first argument of filter should be the data.frame.
If numeric, will drop all observations with a matchscore lower than or equal to filter.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_filter.args">filter.args</code></td>
<td>
<p>list. Arguments passed to filter, if a function</p>
</td></tr>
<tr><td><code id="tier_match_+3A_evaluate">evaluate</code></td>
<td>
<p>Function to evalute merge_plus output. see <code>evaluate_match</code>.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_evaluate.args">evaluate.args</code></td>
<td>
<p>list. Arguments passed to function specified by evaluate</p>
</td></tr>
<tr><td><code id="tier_match_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>whether or not to allow many-many matches, see data.table::merge()</p>
</td></tr>
<tr><td><code id="tier_match_+3A_fuzzy_settings">fuzzy_settings</code></td>
<td>
<p>additional arguments for amatch, to be used if match_type = 'fuzzy'. Suggested defaults provided. (see amatch, method='jw')</p>
</td></tr>
<tr><td><code id="tier_match_+3A_multivar_settings">multivar_settings</code></td>
<td>
<p>list of settings to go to the multivar match if match_type
== 'multivar'. See <code>multivar-match</code>.</p>
</td></tr>
<tr><td><code id="tier_match_+3A_verbose">verbose</code></td>
<td>
<p>boolean, whether or not to print tier names and time to match each tier as the matching happens.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the tier match vignette to get a clear understanding of the tier_match syntax.
</p>


<h3>Value</h3>

<p>list with matches, data1 and data2 minus matches, and match evaluation
</p>


<h3>See Also</h3>

<p>merge_plus clean_strings
</p>

<hr>
<h2 id='wgt_jaccard_distance'>Computing Weighted Jaccard Distance</h2><span id='topic+wgt_jaccard_distance'></span>

<h3>Description</h3>

<p>#' <code>wgt_jaccard_distance</code> computes the Weighted Jaccard Distance between
two strings. It is vectorized, and accepts only two equal-length string
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgt_jaccard_distance(string_1, string_2, corpus, nthreads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wgt_jaccard_distance_+3A_string_1">string_1</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="wgt_jaccard_distance_+3A_string_2">string_2</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="wgt_jaccard_distance_+3A_corpus">corpus</code></td>
<td>
<p>corpus data.table, constructed with
<code>fedmatch::build_corpus</code></p>
</td></tr>
<tr><td><code id="wgt_jaccard_distance_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads to use in the underlying C++ code</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette <code>fuzzy_matching</code> for details on how the Weighted Jaccard similarity is computed.
</p>


<h3>Value</h3>

<p>numeric vector with the Weighted Jaccard distances for each element
of string_1 and string_2.
</p>

<hr>
<h2 id='word_frequency'>Compute frequency of words in a corpus</h2><span id='topic+word_frequency'></span>

<h3>Description</h3>

<p><code>word_frequency</code> counts the frequency of words in a set of strings.
Also does minimal cleaning (removes punctuation and extra spaces). Useful for
determining what words are common and may need to be replaced or removed with
<code>clean_strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>word_frequency(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="word_frequency_+3A_string">string</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with word frequency
</p>

<hr>
<h2 id='World_Bank_Codes'>World_Bank_Codes</h2><span id='topic+World_Bank_Codes'></span>

<h3>Description</h3>

<p>World Bank 3-Character Country Codes for 213 countries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>World_Bank_Codes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 213 rows and 2 columns.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
