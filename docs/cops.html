<!DOCTYPE html><html><head><title>Help for package cops</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cops}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BankingCrisesDistances'><p>Banking Crises Distances</p></a></li>
<li><a href='#cmdscale'><p>Wrapper to <code>cmdscale</code> for S3 class</p></a></li>
<li><a href='#conf_adjust'><p>conf_adjust: a function to procrustes adjust two matrices</p></a></li>
<li><a href='#cop_apstress'><p>PCOPS version of approximated power stress model.</p></a></li>
<li><a href='#cop_cmdscale'><p>PCOPS version of strain</p></a></li>
<li><a href='#cop_elastic'><p>PCOPS versions of elastic scaling models (via smacofSym)</p></a></li>
<li><a href='#cop_powerelastic'><p>PCOPS version of elastic scaling with powers</p></a></li>
<li><a href='#cop_powermds'><p>PCOPS version of powermds</p></a></li>
<li><a href='#cop_powersammon'><p>PCOPS version of sammon with powers</p></a></li>
<li><a href='#cop_powerstress'><p>COPS version of powerstress</p></a></li>
<li><a href='#cop_rpowerstress'><p>PCOPS version of restricted powerstress.</p></a></li>
<li><a href='#cop_rstress'><p>PCOPS version of rstress</p></a></li>
<li><a href='#cop_sammon'><p>PCOPS version of Sammon mapping</p></a></li>
<li><a href='#cop_sammon2'><p>Another COPS versions of Sammon mapping models (via smacofSym)</p></a></li>
<li><a href='#cop_smacofSphere'><p>PCOPS versions of smacofSphere models</p></a></li>
<li><a href='#cop_smacofSym'><p>PCOPS versions of smacofSym models</p></a></li>
<li><a href='#cop_sstress'><p>PCOPS version of sstress</p></a></li>
<li><a href='#cops'><p>cops: cluster optimized proximity scaling</p></a></li>
<li><a href='#copstress'><p>Calculates copstress for given MDS object</p></a></li>
<li><a href='#copstressMin'><p>Fitting a COPS-C Model (COPS Variant 1).</p></a></li>
<li><a href='#doubleCenter'><p>Double centering of a matrix</p></a></li>
<li><a href='#enorm'><p>Explicit Normalization</p>
Normalizes distances</a></li>
<li><a href='#ljoptim'><p>(Adaptive) Version of Luus-Jakola Optimization</p></a></li>
<li><a href='#mkBmat'><p>Auxfunction1</p></a></li>
<li><a href='#mkPower'><p>Take matrix to a power</p></a></li>
<li><a href='#pcops'><p>Profile COPS Function (aka COPS Variant 2)</p></a></li>
<li><a href='#pdist'><p>Squared p-distances</p></a></li>
<li><a href='#plot.cops'><p>S3 plot method for cops objects</p></a></li>
<li><a href='#plot.pcops'><p>S3 plot method for p-cops objects</p></a></li>
<li><a href='#plot.smacofP'><p>S3 plot method for smacofP objects</p></a></li>
<li><a href='#plot3dstatic'><p>plot3dstatic: static 3D plots</p></a></li>
<li><a href='#plot3dstatic.cmdscaleE'><p>3D plots: plot3dstatic method for class cmdscale</p></a></li>
<li><a href='#powerStressFast'><p>Power stress minimization by NEWUOA</p></a></li>
<li><a href='#powerStressMin'><p>Power Stress SMACOF</p></a></li>
<li><a href='#procruster'><p>procruster: a procrustes function</p></a></li>
<li><a href='#sammon'><p>Wrapper to <code>sammon</code> for S3 class</p></a></li>
<li><a href='#scale_adjust'><p>Adjusts a configuration</p></a></li>
<li><a href='#secularEq'><p>Secular Equation</p></a></li>
<li><a href='#sqdist'><p>Squared distances</p></a></li>
<li><a href='#torgerson'><p>Torgerson scaling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Cluster Optimized Proximity Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Rusch &lt;thomas.rusch@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multidimensional scaling (MDS) methods that aim at pronouncing the clustered appearance of the configuration (Rusch, Mair &amp; Hornik, 2021, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;). They achieve this by transforming proximities/distances with power functions and augment the fitting criterion with a clusteredness index, the OPTICS Cordillera (Rusch, Hornik &amp; Mair, 2018, &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1349664">doi:10.1080/10618600.2017.1349664</a>&gt;). There are two variants: One for finding the configuration directly (COPS-C) for ratio, power, interval and non-metric MDS (Borg &amp; Groenen, 2005, ISBN:978-0-387-28981-6), and one for using the augmented fitting criterion to find optimal parameters (P-COPS). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a COPS framework like ratio, interval and non-metric MDS for COPS-C and P-COPS with Torgerson scaling (Torgerson, 1958, ISBN:978-0471879459), scaling by majorizing a complex function (SMACOF; de Leeuw, 1977, <a href="https://escholarship.org/uc/item/4ps3b5mj">https://escholarship.org/uc/item/4ps3b5mj</a>), Sammon mapping (Sammon, 1969, &lt;<a href="https://doi.org/10.1109%2FT-C.1969.222678">doi:10.1109/T-C.1969.222678</a>&gt;), elastic scaling (McGee, 1966, &lt;<a href="https://doi.org/10.1111%2Fj.2044-8317.1966.tb00367.x">doi:10.1111/j.2044-8317.1966.tb00367.x</a>&gt;), s-stress (Takane, Young &amp; de Leeuw, 1977, &lt;<a href="https://doi.org/10.1007%2FBF02293745">doi:10.1007/BF02293745</a>&gt;), r-stress (de Leeuw, Groenen &amp; Mair, 2016, <a href="https://rpubs.com/deleeuw/142619">https://rpubs.com/deleeuw/142619</a>), power stress (Buja &amp; Swayne, 2002 &lt;<a href="https://doi.org/10.1007%2Fs00357-001-0031-0">doi:10.1007/s00357-001-0031-0</a>&gt;), restricted power stress, approximate power stress, power elastic scaling, power Sammon mapping (for all Rusch, Mair &amp; Hornik, 2021, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;). All of these models can also solely be fit as MDS with power transformations. The package further contains a function for pattern search optimization, the &ldquo;Adaptive Luus-Jaakola Algorithm&rdquo; (Rusch, Mair &amp; Hornik, 2021,&lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), cordillera (&ge; 0.7-2), smacof (&ge; 1.10-4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, minqa, pso, scatterplot3d, NlcOptim, Rsolnp, dfoptim,
subplex, cmaes, crs, nloptr, rgenoud, GenSA</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-19 14:16:42 UTC; trusch</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Rusch <a href="https://orcid.org/0000-0002-7773-2096"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jan de Leeuw [aut],
  Patrick Mair [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-19 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BankingCrisesDistances'>Banking Crises Distances</h2><span id='topic+BankingCrisesDistances'></span>

<h3>Description</h3>

<p>Matrix of Jaccard distances between 70 countries (Hungary and Greece were combined to be the same observation) based on their binary time series of having had a banking crises in a year from 1800 to 2010 or not. See data(bankingCrises) in package Ecdat for more info. The last column is Reinhart &amp; Rogoffs classification as a low (3), middle- (2) or high-income country (1).
</p>


<h3>Format</h3>

<p>A 69 x 70 matrix.
</p>


<h3>Source</h3>

<p>data(bankingCrises) in library(Ecdat)
</p>

<hr>
<h2 id='cmdscale'>Wrapper to <code>cmdscale</code> for S3 class</h2><span id='topic+cmdscale'></span>

<h3>Description</h3>

<p>Wrapper to <code>cmdscale</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmdscale(d, k = 2, eig = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmdscale_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix containing the dissimilarities</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_k">k</code></td>
<td>
<p>the maximum dimension of the space which the data are to be represented in</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_eig">eig</code></td>
<td>
<p>indicates whether eigenvalues should be returned.</p>
</td></tr>
<tr><td><code id="cmdscale_+3A_...">...</code></td>
<td>
<p>additional parameters passed to cmdscale. See <code><a href="#topic+cmdscale">cmdscale</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>overloads base::cmdscale and adds class attributes for which there are methods. The functionality is duplicated in the stops package.
</p>


<h3>Value</h3>

<p>Object of class &quot;cmdscaleE' and 'cmdscale' extending <code><a href="#topic+cmdscale">cmdscale</a></code>. This wrapper only adds an extra slot to the list with the call, adds column labels to the $points and assigns S3 class 'cmdscaleE' and 'cmdscale'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-cmdscale(dis)
</code></pre>

<hr>
<h2 id='conf_adjust'>conf_adjust: a function to procrustes adjust two matrices</h2><span id='topic+conf_adjust'></span>

<h3>Description</h3>

<p>conf_adjust: a function to procrustes adjust two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_adjust(conf1, conf2, verbose = FALSE, eps = 1e-12, itmax = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_adjust_+3A_conf1">conf1</code></td>
<td>
<p>reference configuration, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_conf2">conf2</code></td>
<td>
<p>another configuration, a numeric matrix</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_verbose">verbose</code></td>
<td>
<p>should adjustment be output; default to FALSE</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_eps">eps</code></td>
<td>
<p>numerical accuracy</p>
</td></tr>
<tr><td><code id="conf_adjust_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ref.conf being the reference configuration, other.conf the adjusted coniguration and comparison.conf the comparison configuration
</p>

<hr>
<h2 id='cop_apstress'>PCOPS version of approximated power stress model.</h2><span id='topic+cop_apstress'></span>

<h3>Description</h3>

<p>This uses an approximation to power stress that can make use of smacof as workhorse. Free parameters are tau and upsilon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_apstress(
  dis,
  theta = c(1, 1, 1),
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_apstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of parameters to optimize over. Must be of length two, with the first the tau argument and the second the upsilon argument. It can also be a scalar of the tau and upsilon transformation for the observed proximities and gets recycled for both ups and tau (so they are equal). Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a binary matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure (which has all smacofB elements and some more
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_cmdscale'>PCOPS version of strain</h2><span id='topic+cop_cmdscale'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_cmdscale(
  dis,
  theta = c(1, 1, 1),
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_cmdscale_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. No effect here.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes cmdscales default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_elastic'>PCOPS versions of elastic scaling models (via smacofSym)</h2><span id='topic+cop_elastic'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -2. Allows for a weight matrix because of smacof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_elastic(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = 1,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_elastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the elscal weights)</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powerelastic'>PCOPS version of elastic scaling with powers</h2><span id='topic+cop_powerelastic'></span>

<h3>Description</h3>

<p>PCOPS version of elastic scaling with powers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powerelastic(
  dis,
  theta = c(1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_powerelastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers;  a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar for the free parameters is given it is recycled.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powermds'>PCOPS version of powermds</h2><span id='topic+cop_powermds'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but nu is fixed to 1, so no weight transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powermds(
  dis,
  theta = c(1, 1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = itmaxi,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_powermds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length 2 where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to whatever whim is my default (currently explicitly normed stress)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powersammon'>PCOPS version of sammon with powers</h2><span id='topic+cop_powersammon'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but nu is fixed to -1 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powersammon(
  dis,
  theta = c(1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_powersammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled for the free parameters.  Defaults to 1 1..</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powerstress'>COPS version of powerstress</h2><span id='topic+cop_powerstress'></span>

<h3>Description</h3>

<p>Power stress with free kappa and lambda and rho (the theta argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powerstress(
  dis,
  theta = c(1, 1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_powerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_rpowerstress'>PCOPS version of restricted powerstress.</h2><span id='topic+cop_rpowerstress'></span>

<h3>Description</h3>

<p>This is a power stress where kappa and lambda are free to vary but restricted to be equal, so the same exponent will be used for distances and dissimilarities. nu (for the weights) is also free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_rpowerstress(
  dis,
  theta = c(1, 1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_rpowerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first two arguments are for kappa and lambda and should be equal (for the fitted distances and observed proximities), the third nu (for the weights). Internally the kappa and lambda are equated. If a scalar is given it is recycled (so all elements of theta are equal); if a vector of length 2 is given, it gets expanded to c(theta[1],theta[1],theta[2]). Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress1 value (sqrt(stress.m))
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_rstress'>PCOPS version of rstress</h2><span id='topic+cop_rstress'></span>

<h3>Description</h3>

<p>Free parameter is kappa for the fitted distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_rstress(
  dis,
  theta = c(1, 1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_rstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the kappa transformation for the fitted distances proximities. Defaults to 1. Note the kappa here differs from Jan's version where the parameter was called r and the relationship is r=kappa/2 or kappa=2r.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sammon'>PCOPS version of Sammon mapping</h2><span id='topic+cop_sammon'></span>

<h3>Description</h3>

<p>Uses MASS::sammon. The free parameter is lambda for power transformations of the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sammon(
  dis,
  theta = 1,
  ndim = 2,
  init = NULL,
  weightmat = NULL,
  itmaxi = 100,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_sammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be  a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sammon2'>Another COPS versions of Sammon mapping models (via smacofSym)</h2><span id='topic+cop_sammon2'></span>

<h3>Description</h3>

<p>Uses Smacof, so it can deal with a weight matrix too.  The free parameter is lambda for power transformations of the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sammon2(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_sammon2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_theta">theta</code></td>
<td>
<p>theta the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the sammon weights)</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_smacofSphere'>PCOPS versions of smacofSphere models</h2><span id='topic+cop_smacofSphere'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_smacofSphere(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_smacofSphere_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_smacofSym'>PCOPS versions of smacofSym models</h2><span id='topic+cop_smacofSym'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_smacofSym(
  dis,
  theta = 1,
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_smacofSym_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_theta">theta</code></td>
<td>
<p>the theta vector; must be a scalar for the lambda (proximity) transformation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure (which has all smacofB elements and some more)
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sstress'>PCOPS version of sstress</h2><span id='topic+cop_sstress'></span>

<h3>Description</h3>

<p>Free parameter is lambda for the observed proximities. Fitted distances are transformed with power 2, weights have exponent of 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sstress(
  dis,
  theta = c(2, 1, 1),
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE,
  stresstype = c("default", "stress1", "rawstress", "normstress", "enormstress",
    "enormstress1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cop_sstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report? Defaults to explicitly normed stress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cops'>cops: cluster optimized proximity scaling</h2><span id='topic+cops'></span>

<h3>Description</h3>

<p>About the package cops: Cluster optimized proximity scaling (COPS) refers to multidimensional scaling methods that aim at pronouncing the clustered appearance of the configuration. They achieve this by transforming proximities/distances with power functions and augment the fitting criterion with a clusteredness index, the OPTICS Cordillera (Rusch, Hornik &amp; Mair 2018). There are two variants: One for finding the configuration directly for given parameters (COPS-C), and one for using the augmented fitting criterion to find optimal parameters for the power transformations (P-COPS). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a COPS framework like Torgerson scaling, SMACOF, Sammon mapping, elastic scaling, symmetric SMACOF, spherical SMACOF, sstress, rstress, powermds, power elastic scaling, power sammon mapping, powerstress. All of these models can also solely be fit as MDS with power transformations. The package further contains functions for optimization (Adaptive LJ Algorithmus).
</p>
<p>About the function cops: The high level function allows for minimizing copstress for a clustered MDS configuration. Allows to choose COPS-C (finding a configuration from copstress with cordillera penalty) and profile COPS (finding hyperparameters for MDS models with power transformations). It is a wrapper for copstressMin and pcops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cops(
  dis,
  variant = c("1", "2", "Variant1", "Variant2", "v1", "v2", "COPS-C", "P-COPS",
    "configuration-c", "profile", "copstress-c", "p-copstress", "COPS-P", "copstress-p",
    "cops-c", "p-cops", "copsc", "pcops"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cops_+3A_dis">dis</code></td>
<td>
<p>a dissimilarity matrix or a dist object</p>
</td></tr>
<tr><td><code id="cops_+3A_variant">variant</code></td>
<td>
<p>a character string specifying which variant of COPS to fit. Allowed is any of the following &quot;1&quot;,&quot;2&quot;,&quot;Variant1&quot;,&quot;Variant2&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;COPS-C&quot;,&quot;P-COPS&quot;,&quot;configuration-c&quot;,&quot;profile&quot;,&quot;copstress-c&quot;,&quot;p-copstress&quot;. Defaults to &quot;COPS-C&quot;.</p>
</td></tr>
<tr><td><code id="cops_+3A_...">...</code></td>
<td>
<p>arguments to be passed to  <code><a href="#topic+copstressMin">copstressMin</a></code> (for Variant 1) or <code><a href="#topic+pcops">pcops</a></code> (for Variant 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cops package provides five categories of important functions:
</p>
<p>Models &amp; Algorithms:
</p>

<ul>
<li><p> cops() ... high level interface to fit COPS models as described in Rusch et al. (2021). By setting cordweight to zero they can also be used to fit metric MDS for many different models, see below.
</p>
</li>
<li><p> copstressMin()... The workhorse for fitting a COPS-C model. Can also be called directly.
</p>
</li>
<li><p> pcops()... The workhorse for fitting a P-COPS model. Can also be called directly.
</p>
</li>
<li><p> powerStressMin()... a workhorse for fitting s-stress, r-stress (de Leeuw, 2014), p-stress (e.g., Rusch et al., 2021), Sammon mapping with power transformations (powersammon) and elastic scaling with power transformation (powerelastic). They can conveniently also be fitted via the cops functions and setting stressweight=1 and cordweight or by the dedicated functions starting with cops_XXX where XXX is the method and setting stressweight=1 and cordweight=0. It uses the nested majorization algorithm for r-stress of De Leeuw (2014).
</p>
</li></ul>

<p>Optimization functions:
</p>

<ul>
<li><p> ljoptim() ... An (adaptive) version of the Luus-Jakola random search
</p>
</li></ul>

<p>Wrappers and convenience functions:
</p>

<ul>
<li><p> conf_adjust(): procrustes adjustment of configurations 
</p>
</li>
<li><p> cmdscale(), sammon(): wrappers that return S3 objects to be used with cops
</p>
</li>
<li><p> copstress() ... a function to calculate copstress (Rusch et al., 2021)
</p>
</li>
<li><p> cop_smacofSym(), cop_sammon(), cop_cmdscale(), cop_rstress(), cop_powerstress(), cop_smacofSphere(), cop_sammon2(), cop_elastic(), cop_sstress(), cop_powerelastic(), cop_powersammon(): cop versions of these MDS models.
</p>
</li></ul>

<p>Methods: 
For most of the objects returned by the high-level functions S3 classes and methods for standard generics were implemented, including print, summary, plot, plot3dstatic.   
</p>
<p>References:
</p>

<ul>
<li><p> Rusch, T., Hornik, K. &amp; Mair, P. (2018) Assessing and quantifying clusteredness: The OPTICS Cordillera. Journal of Computational and Graphical Statistics, 27 (1), 220-233. <a href="https://doi.org/10.1080/10618600.2017.1349664">doi:10.1080/10618600.2017.1349664</a>
</p>
</li>
<li><p> Rusch, T., Mair, P. &amp; Hornik, K. (2021) Cluster optimized proximity scaling. Journal of Computational and Graphical Statistics. <a href="https://doi.org/10.1080/10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>
</p>
</li></ul>

<p>Authors: Thomas Rusch, Jan de Leeuw, Patrick Mair
</p>
<p>Maintainer: Thomas Rusch
</p>


<h3>Value</h3>

<p>For COPS-C Variant 1 see <code><a href="#topic+copstressMin">copstressMin</a></code>, for P-COPS Variant 2 see <code><a href="#topic+pcops">pcops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BankingCrisesDistances)


# shorthand function for COPS-C (finding configuration with copstress)
res&lt;-cops(BankingCrisesDistances[,1:69],variant="COPS-C",
          stressweight=0.98,cordweight=0.02,itmax=1000)
# Note: itmax is very small here for illustration; will give a non-convergence
# warning of the optimizer which disappears at itmax=275000  

res
summary(res)
plot(res)
plot(res,"reachplot")
plot(res,"transplot")
plot(res,"Shepard")
#shorthand function for P-COPS (hyperparameter search for powerstress)
res&lt;-cops(BankingCrisesDistances[,1:69],variant="P-COPS")
res
summary(res)
plot(res)
plot(res,"reachplot")
plot(res,"transplot")
plot(res,"Shepard")

dis&lt;-as.matrix(smacof::kinshipdelta)

#COPS-C with equal weight to stress and cordillera 
res1&lt;-cops(dis,variant="COPS-C",stressweight=0.5,cordweight=0.5,
          minpts=2,itmax=500) #use higher itmax in real
res1
summary(res1)
plot(res1)
plot(res1,"reachplot")



#s-stress type copstress (i.e. kappa=2, lambda=2)
res3&lt;-cops(dis,variant="COPS-C",kappa=2,lambda=2,stressweight=0.5,cordweight=0.5) 
res3
summary(res3)
plot(res3)


# power-stress type profile copstress
# search for optimal kappa and lambda between
# kappa=0.5,lambda=0.5 and kappa=2,lambda=5
# nu is fixed on -1
ws&lt;-1/dis
diag(ws)&lt;-1 
res5&lt;-cops(dis,variant="P-COPS",loss="powerstress",
          theta=c(1.4,3,-1), lower=c(1,0.5,-1),upper=c(3,5,-1),
          weightmat=ws, stressweight=0.9,cordweight=0.1) 
res5
summary(res5)
plot(res5)


</code></pre>

<hr>
<h2 id='copstress'>Calculates copstress for given MDS object</h2><span id='topic+copstress'></span>

<h3>Description</h3>

<p>Calculates copstress for given MDS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copstress(
  obj,
  stressweight = 1,
  cordweight = 5,
  q = 1,
  minpts = 2,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = c("std", "sd", "proc", "none"),
  init,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copstress_+3A_obj">obj</code></td>
<td>
<p>MDS object (supported are sammon, cmdscale, smacof, rstress, powermds)</p>
</td></tr>
<tr><td><code id="copstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="copstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="copstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="copstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to 2</p>
</td></tr>
<tr><td><code id="copstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="copstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="copstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose (copstress level), &gt;3 is extremely (up to MDS optimization level)</p>
</td></tr>
<tr><td><code id="copstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="copstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted.</p>
</td></tr>
<tr><td><code id="copstress_+3A_init">init</code></td>
<td>
<p>a reference configuration when doing procrustes adjustment</p>
</td></tr>
<tr><td><code id="copstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the cordillera function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='copstressMin'>Fitting a COPS-C Model (COPS Variant 1).</h2><span id='topic+copstressMin'></span>

<h3>Description</h3>

<p>Minimizing Copstress to obtain a clustered MDS configuration with given hyperparameters theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  theta = c(kappa, lambda, nu),
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  ndim = 2,
  init = NULL,
  stressweight = 0.975,
  cordweight = 0.025,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  dmax = NULL,
  rang,
  optimmethod = c("NelderMead", "Newuoa", "BFGS", "SANN", "hjk", "solnl", "solnp",
    "subplex", "snomadr", "hjk-Newuoa", "hjk-BFGS", "BFGS-hjk", "Newuoa-hjk", "cmaes",
    "direct", "direct-Newuoa", "direct-BFGS", "genoud", "gensa"),
  verbose = 0,
  scale = c("sd", "rmsq", "std", "proc", "none"),
  normed = TRUE,
  accuracy = 1e-07,
  itmax = 5000,
  stresstype = c("stress-1", "stress"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copstressMin_+3A_delta">delta</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_kappa">kappa</code></td>
<td>
<p>power transformation for fitted distances</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_lambda">lambda</code></td>
<td>
<p>power transformation for proximities</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_nu">nu</code></td>
<td>
<p>power transformation for weights</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances if it exists), the second lambda (for the observed proximities if it exist), the third is nu (for the weights if it exists) . If less than three elements are is given as argument, it will be recycled. Defaults to 1 1 1. Will override any kappa, lmabda, nu parameters if they are given and do not match</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_ties">ties</code></td>
<td>
<p>the handling of ties for ordinal (nonmetric) MDS. Possible are &quot;primary&quot; (default), &quot;secondary&quot; or &quot;tertiary&quot;.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 0.975</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.025</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization limit of reachability distances in the OPTICS Cordillera. If supplied, it should be either a numeric value that matches max(rang) or NULL; if NULL it is found as 1.5 times (for kappa &gt;1) or 1 times (for kappa &lt;=1) the maximum reachbility value of the power torgerson model with the same lambda. If dmax and rang are supplied and dmax is not max(rang), a warning is given and rang takes precedence.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_rang">rang</code></td>
<td>
<p>range of the reachabilities to be considered. If missing it is found from the initial configuration by taking 0 as the lower boundary and dmax (see above) as upper boundary. See also <code><a href="cordillera.html#topic+cordillera">cordillera</a></code></p>
</td></tr>
<tr><td><code id="copstressMin_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What optimizer to use? Choose one string of 'Newuoa' (from package minqa), 'NelderMead', 'hjk' (Hooke-Jeeves algorithm from dfoptim), 'solnl' (from nlcOptim), 'solnp' (from Rsolnp), 'subplex' (from subplex), 'SANN' (simulated annealing), 'BFGS', 'snomadr' (from crs), 'genoud' (from rgenoud), 'gensa' (from GenSA), 'cmaes' (from cmaes) and 'direct' (from nloptr). See the according R packages for details on these solvers. There are also combinations that proved to work well good, like 'hjk-Newuoa', 'hjk-BFGS', 'BFGS-hjk', 'Newuoa-hjk', 'direct-Newuoa' and 'direct-BFGS' . Usually hjk, BFGS, newuoa, subplex and solnl work rather well in an acceptable time frame (depending on the smoothness of copstress). Default is 'hjk-Newuoa'.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_scale">scale</code></td>
<td>
<p>Allows to scale the configuration for the OC (the scaled configuration is also returned as $conf). One of &quot;none&quot; (so no scaling), &quot;sd&quot; (configuration divided by the highest standard deviation of the columns), &quot;std&quot; (standardize all columns !NOTE: This does not preserve the relative distances of the optimal config), &quot;proc&quot; (procrustes adjustment to the initial fit) and &quot;rmsq&quot; (configuration divided by the maximum root mean square of the columns). Default is &quot;sd&quot;.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_accuracy">accuracy</code></td>
<td>
<p>numerical accuracy, defaults to 1e-7</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Defaults to 5000. If itmax is (too) small, some optimizers will print warnings. For example, for optimizers using NEWUOA, an iteration number of 10*length(par)^2 is recommended. The number of parameters to optimize over for the COPS problem is number of objects * target space dimensions and can grow large very quickly, so being able to live with these warnings is probably a good idea.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to use in the copstress. Defaults to stress-1. If anything else is set, explicitly normed stress which is (stress-1)^2. Using stress-1 puts more weight on MDS fit.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> delta: the original transformed dissimilarities
</p>
</li>
<li><p> obsdiss: the explicitly normed transformed dissimilarities (which are approximated by the fit)
</p>
</li>
<li><p> confdist: the fitted distances
</p>
</li>
<li><p> conf: the configuration to which the scaling of argument scale was applied
</p>
</li>
<li><p> confo: the unscaled but explicitly normed configuration returned from the fitting procedure. Scaling applied to confo gives conf.
</p>
</li>
<li><p> par, pars : the theta vector of powers tranformations (kappa,lambda,nu)
</p>
</li>
<li><p> niter: number of iterations of the optimizer. 
</p>
</li>
<li><p> stress: the square root of explicitly normalized stress (calculated for confo).
</p>
</li>
<li><p> spp: stress per point
</p>
</li>
<li><p> ndim: number of dimensions
</p>
</li>
<li><p> model: Fitted model name with optimizer
</p>
</li>
<li><p> call: the call
</p>
</li>
<li><p> nobj: the number of objects
</p>
</li>
<li><p> type, loss, losstype: stresstype
</p>
</li>
<li><p> stress.m: The stress used for copstress. If stresstype=&quot;stress-1&quot; this is like $stress else it is stress^2
</p>
</li>
<li><p> stress.en: another ways to calculate the stress
</p>
</li>
<li><p> deltaorig: the original untransformed dissimilarities  
</p>
</li>
<li><p> copstress: the copstress loss value
</p>
</li>
<li><p> resmat: the matrix of residuals
</p>
</li>
<li><p> weightmat: the matrix of untransformed weights 
</p>
</li>
<li><p> OC: the (normed) OPTICS Cordillera object (calculated for scaled conf)
</p>
</li>
<li><p> OCv: the (normed) OPTICS Cordillera value alone (calculated for scaled conf)
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stressweight, cordweight: the weights of the stress and OC respectively (v_1 and v_2)
</p>
</li>
<li><p> optimmethod: The solver used 
</p>
</li>
<li><p> type: the type of MDS fitted
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)

#Copstress with equal weight to stress and cordillera 
res1&lt;-copstressMin(dis,stressweight=0.5,cordweight=0.5,
                  itmax=1000) #use higher itmax about 10000 
res1
summary(res1)
plot(res1)  #super clustered

</code></pre>

<hr>
<h2 id='doubleCenter'>Double centering of a matrix</h2><span id='topic+doubleCenter'></span>

<h3>Description</h3>

<p>Double centering of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleCenter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doubleCenter_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the double centered matrix
</p>

<hr>
<h2 id='enorm'>Explicit Normalization
Normalizes distances</h2><span id='topic+enorm'></span>

<h3>Description</h3>

<p>Explicit Normalization
Normalizes distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enorm(x, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enorm_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="enorm_+3A_w">w</code></td>
<td>
<p>weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constant
</p>

<hr>
<h2 id='ljoptim'>(Adaptive) Version of Luus-Jakola Optimization</h2><span id='topic+ljoptim'></span>

<h3>Description</h3>

<p>Adaptive means that the search space reduction factors in the number of iterations; makes convergence faster at about 100 iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljoptim(
  x,
  fun,
  ...,
  red = ifelse(adaptive, 0.99, 0.95),
  lower,
  upper,
  acc = 1e-06,
  accd = 1e-04,
  itmax = 1000,
  verbose = 0,
  adaptive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ljoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_red">red</code></td>
<td>
<p>value of the reduction of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-6</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_accd">accd</code></td>
<td>
<p>if the width of the search space is below this, stop the optimization; defaults to 1e-4</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_adaptive">adaptive</code></td>
<td>
<p>should the adaptive version be used? defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (see also <code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimimum in the search space (parameters that minimize the function; argmin fun)
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun)
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-ljoptim(c(-1.2,1),fbana,lower=-5,upper=5,accd=1e-16,acc=1e-16)
res1

set.seed(210485)
fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "ljoptim() minimising 'wild function'")
res2&lt;-ljoptim(50, fwild,lower=-50,upper=50,adaptive=FALSE,accd=1e-16,acc=1e-16)
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

<hr>
<h2 id='mkBmat'>Auxfunction1</h2><span id='topic+mkBmat'></span>

<h3>Description</h3>

<p>only used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkBmat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkBmat_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='mkPower'>Take matrix to a power</h2><span id='topic+mkPower'></span>

<h3>Description</h3>

<p>Take matrix to a power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkPower(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkPower_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mkPower_+3A_r">r</code></td>
<td>
<p>numeric (power)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='pcops'>Profile COPS Function (aka COPS Variant 2)</h2><span id='topic+pcops'></span>

<h3>Description</h3>

<p>Metaparameter selection for MDS models baseed on the Profile COPS approach (COPS Variant 2). It uses copstress for hyperparameter selection. It is a special case of a STOPS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcops(
  dis,
  loss = c("stress", "smacofSym", "smacofSphere", "strain", "sammon", "rstress",
    "powermds", "sstress", "elastic", "powersammon", "powerelastic", "powerstress",
    "sammon2", "powerstrain", "apstress", "rpowerstress"),
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  theta = 1,
  stressweight = 1,
  cordweight,
  q = 2,
  minpts = ndim + 1,
  epsilon = 100,
  rang,
  optimmethod = c("ALJ", "pso", "SANN", "DIRECT", "DIRECTL", "stogo", "MADS", "hjk"),
  lower = 0.5,
  upper = 5,
  verbose = 0,
  scale = c("proc", "sd", "none", "std"),
  normed = TRUE,
  s = 4,
  stresstype = "default",
  acc = 1e-07,
  itmaxo = 200,
  itmaxi = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcops_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="pcops_+3A_loss">loss</code></td>
<td>
<p>which loss function to be used for fitting, defaults to strain. Currently allows for the following models:
</p>

<ul>
<li><p> Power transformations of observed proximities only (theta must be scalar): Strain loss or classical scaling (<code>strain</code>, workhorse is cmdscale), Kruskall's stress for symmetric matrices (<code>smacofSym</code> or <code>stress</code> and <code>smacofSphere</code> for scaling onto a sphere; workhorse is smacof), Sammon mapping (<code>sammon</code> or <code>sammon2</code>; for the earlier the workhorse is sammon from MASS for the latter it is smacof), elastic scaling (<code>elastic</code>, the workhorse is smacof), Takane et al's s-Stress <code>sstress</code> (workhorse is powerstressMin)
</p>
</li>
<li><p> Power transformations of fitted distances only (theta must be scalar): De Leeuw's r-stress <code>rstress</code> (workhorse is powerstressMin)
</p>
</li>
<li><p> Power transformations of fitted distances and observed proximities (theta must be scalar or of length 2): Power MDS (<code>powermds</code>), Sammon mapping/elastic scaling with powers (<code>powersammon</code>, <code>powerelastic</code>)
</p>
</li>
<li><p> Power transfomations of fitted distances, observed proximities and weights (theta must be of length 3 at most): powerstress (POST-MDS, <code>powerstress</code>), restricted powerstress with equal transformations for distances and proximities (<code>rpowerstress</code>); workhorse is powerstressMin)
</p>
</li>
<li><p> Approximation to power stress (theta must be of length 2): Approximated power stress (<code>apstress</code>; workhorse is smacof)
</p>
</li></ul>
</td></tr>
<tr><td><code id="pcops_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="pcops_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="pcops_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration. If not supplied, the Torgerson scaling result of the dissimilarity matrix dis^theta[2]/enorm(dis^theta[2],weightmat) is used.</p>
</td></tr>
<tr><td><code id="pcops_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; see the corresponding cop_XXX function for which theta are allowed. If a scalar is given as argument, it will be recycled. Defaults to 1.</p>
</td></tr>
<tr><td><code id="pcops_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="pcops_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; if missing gets estimated from the initial configuration so that copstress = 0 for theta=c(1,1)</p>
</td></tr>
<tr><td><code id="pcops_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="pcops_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="pcops_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="pcops_+3A_rang">rang</code></td>
<td>
<p>range of the minimum reachabilities to be considered. If missing it is found from the initial configuration by taking 1.5 times the maximal minimum reachability of the model with theta=c(1,1). If NULL it will be normed to each configuration's minimum and maximum distance, so an absolute value of goodness-of-clusteredness. Note that the latter is not necessarily desirable when comparing configurations for their relative clusteredness. See also <code><a href="cordillera.html#topic+cordillera">cordillera</a></code>.</p>
</td></tr>
<tr><td><code id="pcops_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What general purpose optimizer to use? Defaults to our adaptive LJ version (ALJ). Also allows particle swarm optimization with s particles (&quot;pso&quot;) and simulated annealing (&quot;SANN&quot;), &quot;DIRECT&quot; and &quot;DIRECTL&quot;, Hooke-Jeeves (&quot;hjk&quot;), StoGo (&quot;stogo&quot;), and &quot;MADS&quot;. We recommend not using SANN and pso with the rstress, sstress and the power stress models. We made good experiences with ALJ, stogo, DIRECT and DIRECTL and also MADS.</p>
</td></tr>
<tr><td><code id="pcops_+3A_lower">lower</code></td>
<td>
<p>A vector of the lower box contraints of the search region. Its length must match the length of theta.</p>
</td></tr>
<tr><td><code id="pcops_+3A_upper">upper</code></td>
<td>
<p>A vector of the upper box contraints of the search region. Its length must match the length of theta.</p>
</td></tr>
<tr><td><code id="pcops_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose. Note that for models with some parameters fixed, the iteration progress of the optimizer shows different values also for the fixed parameters because due to the modular setup we always optimize over a three parameter vector. These values are inconsequential however as internally they will be fixed.</p>
</td></tr>
<tr><td><code id="pcops_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scaled and/or centered for calculating the cordillera? &quot;std&quot; standardizes each column of the configurations to mean=0 and sd=1 (typically not a good idea), &quot;sd&quot; scales the configuration by the maximum standard devation of any column (default), &quot;proc&quot; adjusts the fitted configuration to the init configuration (or the Togerson scaling solution if init=NULL). This parameter only has an effect for calculating the cordillera, the fitted and returned configuration is NOT scaled.</p>
</td></tr>
<tr><td><code id="pcops_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="pcops_+3A_s">s</code></td>
<td>
<p>number of particles if pso is used</p>
</td></tr>
<tr><td><code id="pcops_+3A_stresstype">stresstype</code></td>
<td>
<p>what stress to be used for comparisons between solutions. Currently not implemented and pcops uses explicitly normalized stress for copstress (not stress-1). Stress-1 is reported by the print function though.</p>
</td></tr>
<tr><td><code id="pcops_+3A_acc">acc</code></td>
<td>
<p>termination threshold difference of two successive outer minimization steps.</p>
</td></tr>
<tr><td><code id="pcops_+3A_itmaxo">itmaxo</code></td>
<td>
<p>iterations of the outer step (optimization over the hyperparmeters; if solver allows it). Defaults to 200.</p>
</td></tr>
<tr><td><code id="pcops_+3A_itmaxi">itmaxi</code></td>
<td>
<p>iterations of the inner step (optimization of the MDS). Defaults to 10000 (whichis huge).</p>
</td></tr>
<tr><td><code id="pcops_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the OPTICS cordillera for the scaled configuration (as defined by scale) 
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stress: the stress (square root of stress.m)
</p>
</li>
<li><p> stress.m: default normalized stress 
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
set.seed(210485)
#configuration is scaled with highest column sd for calculating cordilera 
res1&lt;-pcops(dis,loss="strain",lower=0.1,upper=5,minpts=2) 
res1
summary(res1)
plot(res1)


</code></pre>

<hr>
<h2 id='pdist'>Squared p-distances</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Squared p-distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="pdist_+3A_p">p</code></td>
<td>
<p>p&gt;0 the Minkoswki distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared Minkowski distance matrix
</p>

<hr>
<h2 id='plot.cops'>S3 plot method for cops objects</h2><span id='topic+plot.cops'></span>

<h3>Description</h3>

<p>S3 plot method for cops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cops'
plot(x, plot.type = c("confplot"), main, asp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cops_+3A_x">x</code></td>
<td>
<p>an object of class cops</p>
</td></tr>
<tr><td><code id="plot.cops_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;reachplot&quot;, &quot;resplot&quot;,&quot;transplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.cops_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.cops_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to NA; setting to 1 will lead to an accurate represenation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.cops_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.
</p>
<p>Details:
</p>

<ul>
<li><p> Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Reachability plot (plot.type = &quot;confplot&quot;): Plots the OPTICS reachability plot and the OPTICS cordillera 
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances.
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess smooth and a least squares line.
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with the observed dissimilarities (lighter) and the transformed observed dissimilarities (darker) against the fitted distances together with loess smoothing lines 
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;, only for SMACOF objects in $fit): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;, only available for SMACOF objects $fit): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
resl&lt;-copstressMin(dis,itmax=20)
plot(resl)
</code></pre>

<hr>
<h2 id='plot.pcops'>S3 plot method for p-cops objects</h2><span id='topic+plot.pcops'></span>

<h3>Description</h3>

<p>S3 plot method for p-cops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcops'
plot(x, plot.type = c("confplot"), main, asp = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pcops_+3A_x">x</code></td>
<td>
<p>an object of class cops</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;reachplot&quot;, &quot;resplot&quot;,&quot;transplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to NA; setting to 1 will lead to an accurate represenation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.
</p>
<p>Details:
</p>

<ul>
<li><p> Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Reachability plot (plot.type = &quot;confplot&quot;): Plots the OPTICS reachability plot and the OPTICS cordillera 
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances.
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess smooth and a least squares line.
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with the observed dissimilarities (lighter) and the transformed observed dissimilarities (darker) against the fitted distances together with loess smoothing lines 
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;, only for SMACOF objects in $fit): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;, only available for SMACOF objects $fit): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
resl&lt;-pcops(dis,loss="strain",lower=0.1,upper=5,minpts=2)
plot(resl)
plot(resl,plot.type="Shepard")
</code></pre>

<hr>
<h2 id='plot.smacofP'>S3 plot method for smacofP objects</h2><span id='topic+plot.smacofP'></span>

<h3>Description</h3>

<p>S3 plot method for smacofP objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smacofP'
plot(
  x,
  plot.type = "confplot",
  plot.dim = c(1, 2),
  bubscale = 5,
  col,
  label.conf = list(label = TRUE, pos = 3, col = 1, cex = 0.8),
  identify = FALSE,
  type = "p",
  pch = 20,
  asp = 1,
  main,
  xlab,
  ylab,
  xlim,
  ylim,
  legend = TRUE,
  legpos,
  loess = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smacofP_+3A_x">x</code></td>
<td>
<p>an object of class smacofP</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;resplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;,&quot;transplot&quot;, &quot;bubbleplot&quot; (see details)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions to be plotted in confplot; defaults to c(1, 2)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_bubscale">bubscale</code></td>
<td>
<p>Scaling factor (size) for the bubble plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_col">col</code></td>
<td>
<p>vector of colors for the points</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_label.conf">label.conf</code></td>
<td>
<p>List with arguments for plotting the labels of the configurations in a configuration plot (logical value whether to plot labels or not, label position, label color)</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_identify">identify</code></td>
<td>
<p>If 'TRUE', the 'identify()' function is called internally that allows to add configuration labels by mouse click</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn (see also 'plot')</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_pch">pch</code></td>
<td>
<p>Plot symbol</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio; defaults to 1 so distances between x and y are represented accurately; can lead to slighlty weird looking plots if the variance on one axis is much smaller than on the other axis; use NA if the standard type of R plot is wanted where the ylim and xlim arguments define the aspect ratio - but then the distances seen are no longer accurate</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_xlim">xlim</code></td>
<td>
<p>scale of x axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_ylim">ylim</code></td>
<td>
<p>scale of y axis</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legend">legend</code></td>
<td>
<p>Flag whether legends should be drawn for plots that have legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_legpos">legpos</code></td>
<td>
<p>Position of legend in plots with legends</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_loess">loess</code></td>
<td>
<p>should loess fit be added to Shepard plot</p>
</td></tr>
<tr><td><code id="plot.smacofP_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacof' and 'plot' for detailed information.
</p>
<p>Details:
</p>

<ul>
<li><p>  Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances.
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess curve and a least squares line.
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with the observed dissimilarities (lighter) and the transformed observed dissimilarities (darker) against the fitted distances together with the nonlinear regression curve 
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-powerStressMin(dis)
plot(res)
plot(res,"reachplot")
plot(res,"Shepard")
plot(res,"resplot")
plot(res,"transplot")
plot(res,"stressplot")
plot(res,"bubbleplot")
</code></pre>

<hr>
<h2 id='plot3dstatic'>plot3dstatic: static 3D plots</h2><span id='topic+plot3dstatic'></span>

<h3>Description</h3>

<p>A static 3d plot S3 generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3dstatic(x, plot.dim = c(1, 2, 3), main, xlab, ylab, zlab, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dstatic_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_plot.dim">plot.dim</code></td>
<td>
<p>dimensions to plot</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_zlab">zlab</code></td>
<td>
<p>label for z axis</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="plot3dstatic_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A static 3d plot
</p>

<hr>
<h2 id='plot3dstatic.cmdscaleE'>3D plots: plot3dstatic method for class cmdscale</h2><span id='topic+plot3dstatic.cmdscaleE'></span>

<h3>Description</h3>

<p>This methods produces a static 3D configuration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmdscaleE'
plot3dstatic(x, plot.dim = c(1, 2, 3), main, xlab, ylab, zlab, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_x">x</code></td>
<td>
<p>object of class cmdscale</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_plot.dim">plot.dim</code></td>
<td>
<p>vector of length 3 with dimensions to be plotted</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_xlab">xlab</code></td>
<td>
<p>label of x axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_ylab">ylab</code></td>
<td>
<p>label of y axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_zlab">zlab</code></td>
<td>
<p>label of z axis</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_col">col</code></td>
<td>
<p>color of the text labels</p>
</td></tr>
<tr><td><code id="plot3dstatic.cmdscaleE_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'scatterplot3d' in package 'scatterplot3d' for detailed information.</p>
</td></tr>
</table>

<hr>
<h2 id='powerStressFast'>Power stress minimization by NEWUOA</h2><span id='topic+powerStressFast'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by a derivative-free trust region optimization algorithm (NEWUOA). Much faster than majorizing as used in powerStressMin but perhaps less accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerStressFast(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-12,
  itmax = 50000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerStressFast_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_acc">acc</code></td>
<td>
<p>The smallest value of the trust region radius that is allowed. If not defined, then 1e-10 will be used.</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 50000.</p>
</td></tr>
<tr><td><code id="powerStressFast_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a smacofP object (inheriting form smacofB, see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed dissimilarities, normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress (stress 1, square root of the explicitly normalized stress on the normalized, transformed dissimilarities)  
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> gamma: Empty
</p>
</li>
<li><p> stress.m: default stress for the COPS and STOP. Defaults to the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> stress.en: explicitly stress on the normalized, transformed dissimilarities and normalized transformed distances
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> weightmat: weighting matrix 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-powerStressFast(as.matrix(dis),kappa=2,lambda=1.5)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='powerStressMin'>Power Stress SMACOF</h2><span id='topic+powerStressMin'></span>

<h3>Description</h3>

<p>An implementation to minimize power stress by minimization-majorization. Usually more accurate but slower than powerStressFast. Uses a repeat loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  weightmat = 1 - diag(nrow(delta)),
  init = NULL,
  ndim = 2,
  acc = 1e-10,
  itmax = 50000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerStressMin_+3A_delta">delta</code></td>
<td>
<p>dist object or a symmetric, numeric data.frame or matrix of distances</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_kappa">kappa</code></td>
<td>
<p>power of the transformation of the fitted distances; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_lambda">lambda</code></td>
<td>
<p>the power of the transformation of the proximities; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_nu">nu</code></td>
<td>
<p>the power of the transformation for weightmat; defaults to 1</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>a matrix of finite weights</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_init">init</code></td>
<td>
<p>starting configuration</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_ndim">ndim</code></td>
<td>
<p>dimension of the configuration; defaults to 2</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_acc">acc</code></td>
<td>
<p>numeric accuracy of the iteration</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Default is 50000.</p>
</td></tr>
<tr><td><code id="powerStressMin_+3A_verbose">verbose</code></td>
<td>
<p>should iteration output be printed; if &gt; 1 then yes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a smacofP object (inheriting form smacofB, see <code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>). It is a list with the components
</p>

<ul>
<li><p> delta: Observed dissimilarities, not normalized
</p>
</li>
<li><p> obsdiss: Observed dissimilarities, normalized 
</p>
</li>
<li><p> confdist: Configuration dissimilarities, NOT normalized 
</p>
</li>
<li><p> conf: Matrix of fitted configuration, NOT normalized
</p>
</li>
<li><p> stress: Default stress  (stress 1; sqrt of explicitly normalized stress)
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> model: Name of smacof model
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li>
<li><p> type: Type of MDS model
</p>
</li></ul>

<p>and some additional components
</p>

<ul>
<li><p> stress.m: default stress for the COPS and STOP defaults to the explicitly normalized stress on the normalized, transformed dissimilarities
</p>
</li>
<li><p> stress.en: a manually calculated stress on the normalized, transformed dissimilarities and normalized transformed distances which is not correct
</p>
</li>
<li><p> deltaorig: observed, untransformed dissimilarities
</p>
</li>
<li><p> weightmat: weighting matrix 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="smacof.html#topic+smacofSym">smacofSym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-smacof::kinshipdelta
res&lt;-powerStressMin(as.matrix(dis),kappa=2,lambda=1.5,itmax=1000)
res
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='procruster'>procruster: a procrustes function</h2><span id='topic+procruster'></span>

<h3>Description</h3>

<p>procruster: a procrustes function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procruster(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="procruster_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='sammon'>Wrapper to <code>sammon</code> for S3 class</h2><span id='topic+sammon'></span>

<h3>Description</h3>

<p>Wrapper to <code>sammon</code> for S3 class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammon(d, y = NULL, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammon_+3A_d">d</code></td>
<td>
<p>a distance structure such as that returned by 'dist' or a full symmetric matrix.  Data are assumed to be dissimilarities or relative distances, but must be positive except for self-distance.  This can contain missing values.</p>
</td></tr>
<tr><td><code id="sammon_+3A_y">y</code></td>
<td>
<p>An initial configuration. If NULL, 'cmdscale' is used to provide the classical solution.  (If there are missing values in 'd', an initial configuration must be provided.)  This must not have duplicates.</p>
</td></tr>
<tr><td><code id="sammon_+3A_k">k</code></td>
<td>
<p>The dimension of the configuration</p>
</td></tr>
<tr><td><code id="sammon_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>sammon</code>, see <code><a href="#topic+sammon">sammon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>overloads MASS::sammon and adds class attributes for which there are methods. The functionality is duplicated in the stops package.
</p>


<h3>Value</h3>

<p>Object of class sammonE' inheriting from <code><a href="#topic+sammon">sammon</a></code>. This wrapper only adds an extra slot to the list with the call, adds column labels to the $points and assigns S3 classes 'sammonE', 'sammon' and 'cmdscale'. It also adds a slot obsdiss with normalized dissimilarities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-sammon(dis)
</code></pre>

<hr>
<h2 id='scale_adjust'>Adjusts a configuration</h2><span id='topic+scale_adjust'></span>

<h3>Description</h3>

<p>Adjusts a configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_adjust(conf, ref, scale = c("sd", "std", "proc", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_adjust_+3A_conf">conf</code></td>
<td>
<p>a configuration</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_ref">ref</code></td>
<td>
<p>a reference configuration (only for scale=&quot;proc&quot;)</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_scale">scale</code></td>
<td>
<p>Scale adjustment. &quot;std&quot; standardizes each column of the configurations to mean=0 and sd=1, &quot;sd&quot; scales the configuration by the maximum standard devation of any column, &quot;proc&quot; adjusts the fitted configuration to the reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scale adjusted configuration.
</p>

<hr>
<h2 id='secularEq'>Secular Equation</h2><span id='topic+secularEq'></span>

<h3>Description</h3>

<p>Secular Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secularEq(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secularEq_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="secularEq_+3A_b">b</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='sqdist'>Squared distances</h2><span id='topic+sqdist'></span>

<h3>Description</h3>

<p>Squared distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared distance matrix
</p>

<hr>
<h2 id='torgerson'>Torgerson scaling</h2><span id='topic+torgerson'></span>

<h3>Description</h3>

<p>Torgerson scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torgerson(delta, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torgerson_+3A_delta">delta</code></td>
<td>
<p>symmetric, numeric matrix of distances</p>
</td></tr>
<tr><td><code id="torgerson_+3A_p">p</code></td>
<td>
<p>target space dimensions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a n x p matrix (the configuration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
res&lt;-torgerson(dis)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
