<!DOCTYPE html><html lang="en"><head><title>Help for package cops</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cops}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cops-package'><p>cops: cluster optimized proximity scaling</p></a></li>
<li><a href='#BankingCrisesDistances'><p>Banking Crises Distances</p></a></li>
<li><a href='#biplotmds.pcops'><p>S3 method for pcops objects</p></a></li>
<li><a href='#biplotmds.stops'><p>S3 method for stops objects</p></a></li>
<li><a href='#bootmds.pcops'><p>MDS Bootstrap for pcops objects</p></a></li>
<li><a href='#cop_apstress'><p>PCOPS version of approximated power stress model.</p></a></li>
<li><a href='#cop_cmdscale'><p>PCOPS version of strain</p></a></li>
<li><a href='#cop_elastic'><p>PCOPS versions of elastic scaling models (via smacofSym)</p></a></li>
<li><a href='#cop_powerelastic'><p>PCOPS version of elastic scaling with powers</p></a></li>
<li><a href='#cop_powermds'><p>PCOPS version of powermds</p></a></li>
<li><a href='#cop_powersammon'><p>PCOPS version of sammon with powers</p></a></li>
<li><a href='#cop_powerstress'><p>COPS version of powerstress</p></a></li>
<li><a href='#cop_rpowerstress'><p>PCOPS version of restricted powerstress.</p></a></li>
<li><a href='#cop_rstress'><p>PCOPS version of rstress</p></a></li>
<li><a href='#cop_sammon'><p>PCOPS version of Sammon mapping from MASS</p></a></li>
<li><a href='#cop_sammon2'><p>Another COPS versions of Sammon mapping models (via smacofSym)</p></a></li>
<li><a href='#cop_smacofSphere'><p>PCOPS versions of smacofSphere models</p></a></li>
<li><a href='#cop_smacofSym'><p>PCOPS versions of smacofSym models</p></a></li>
<li><a href='#cop_sstress'><p>PCOPS version of sstress</p></a></li>
<li><a href='#cops'><p>High Level COPS Function</p></a></li>
<li><a href='#copstress'><p>Calculates copstress for given MDS object</p></a></li>
<li><a href='#copstressMin'><p>Fitting a COPS-C Model (COPS Variant 1).</p></a></li>
<li><a href='#doubleCenter'><p>Double centering of a matrix</p></a></li>
<li><a href='#enorm'><p>Explicit Normalization</p>
Normalizes distances</a></li>
<li><a href='#jackmds.pcops'><p>MDS Jackknife for pcops objects</p></a></li>
<li><a href='#ljoptim'><p>(Adaptive) Version of Luus-Jakola Optimization</p></a></li>
<li><a href='#matchphi'><p>Distances of MATCH-ADTC modules</p></a></li>
<li><a href='#mkBmat'><p>Auxfunction1</p></a></li>
<li><a href='#mkPower'><p>Take matrix to a power</p></a></li>
<li><a href='#pcops'><p>Profile COPS Function (aka COPS Variant 2)</p></a></li>
<li><a href='#pdist'><p>Squared p-distances</p></a></li>
<li><a href='#phidistance'><p>Calculating the pairwise phi distance matrix between n vectors</p></a></li>
<li><a href='#plot.copsc'><p>S3 plot method for cops objects</p></a></li>
<li><a href='#plot.pcops'><p>S3 plot method for p-cops objects</p></a></li>
<li><a href='#procruster'><p>procruster: a procrustes function</p></a></li>
<li><a href='#scale_adjust'><p>Adjusts a configuration</p></a></li>
<li><a href='#secularEq'><p>Secular Equation</p></a></li>
<li><a href='#spp'><p>Calculating stress per point</p></a></li>
<li><a href='#sqdist'><p>Squared distances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Cluster Optimized Proximity Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.12-1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Rusch &lt;thomas.rusch@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multidimensional scaling (MDS) methods that aim at pronouncing the clustered appearance of the configuration (Rusch, Mair &amp; Hornik, 2021, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;). They achieve this by transforming proximities/distances with explicit power functions and penalizing the fitting criterion with a clusteredness index, the OPTICS Cordillera (Rusch, Hornik &amp; Mair, 2018, &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1349664">doi:10.1080/10618600.2017.1349664</a>&gt;). There are two variants: One for finding the configuration directly (COPS-C) with given explicit power transformations and implicit ratio, interval and non-metric optimal scaling transformations (Borg &amp; Groenen, 2005, ISBN:978-0-387-28981-6), and one for using the augmented fitting criterion to find optimal hyperparameters for the explicit transformations (P-COPS). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying a large number of different MDS models (most of the functionality in smacofx) in the COPS framework. The package further contains a function for pattern search optimization, the &ldquo;Adaptive Luus-Jaakola Algorithm&rdquo; (Rusch, Mair &amp; Hornik, 2021,&lt;<a href="https://doi.org/10.1080%2F10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>&gt;) and a functions to calculate the phi-distances for count data or histograms.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), cordillera (&ge; 0.7-2), smacofx</td>
</tr>
<tr>
<td>Imports:</td>
<td>smacof, analogue, cmaes, crs, dfoptim, GenSA, minqa, NlcOptim,
nloptr, pso, rgenoud, Rsolnp, subplex</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-22 13:53:03 UTC; trusch</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Rusch <a href="https://orcid.org/0000-0002-7773-2096"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Patrick Mair <a href="https://orcid.org/0000-0003-0100-6511"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-22 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cops-package'>cops: cluster optimized proximity scaling</h2><span id='topic+cops-package'></span>

<h3>Description</h3>

<p>About the package cops: Cluster optimized proximity scaling (COPS) refers to multidimensional scaling methods that aim at pronouncing the clustered appearance of the configuration. They achieve this by transforming proximities/distances with power functions and augment the fitting criterion with a clusteredness index, the OPTICS Cordillera (Rusch, Hornik &amp; Mair 2018). There are two variants: One for finding the configuration directly for given parameters (COPS-C), and one for using the augmented fitting criterion to find optimal parameters for the power transformations (P-COPS). The package contains various functions, wrappers, methods and classes for fitting, plotting and displaying different MDS models in a COPS framework like Torgerson scaling, SMACOF, Sammon mapping, elastic scaling, symmetric SMACOF, spherical SMACOF, sstress, rstress, powermds, power elastic scaling, power sammon mapping, powerstress. All of these models can also solely be fit as MDS with power transformations. The package further contains functions for optimization (Adaptive LJ Algorithmus).
</p>


<h3>Details</h3>

<p>The cops package provides five categories of important functions:
</p>
<p>Models &amp; Algorithms:
</p>

<ul>
<li><p> cops() ... high level interface to fit COPS models as described in Rusch et al. (2021). By setting cordweight to zero they can also be used to fit metric MDS for many different models, see below.
</p>
</li>
<li><p> copstressMin()... The workhorse for fitting a COPS-C model. Can also be called directly.
</p>
</li>
<li><p> pcops()... The workhorse for fitting a P-COPS model. Can also be called directly.
</p>
</li>
<li><p> powerStressMin()... a workhorse for fitting s-stress, r-stress (de Leeuw, 2014), p-stress (e.g., Rusch et al., 2021), Sammon mapping with power transformations (powersammon) and elastic scaling with power transformation (powerelastic). They can conveniently also be fitted via the cops functions and setting stressweight=1 and cordweight or by the dedicated functions starting with cops_XXX where XXX is the method and setting stressweight=1 and cordweight=0. It uses the nested majorization algorithm for r-stress of De Leeuw (2014).
</p>
</li></ul>

<p>Optimization functions:
</p>

<ul>
<li><p> ljoptim() ... An (adaptive) version of the Luus-Jakola random search
</p>
</li></ul>

<p>Wrappers and convenience functions:
</p>

<ul>
<li><p> conf_adjust(): procrustes adjustment of configurations 
</p>
</li>
<li><p> cmdscale(), sammon(): wrappers that return S3 objects to be used with cops
</p>
</li>
<li><p> copstress() ... a function to calculate copstress (Rusch et al., 2021)
</p>
</li>
<li><p> cop_smacofSym(), cop_sammon(), cop_cmdscale(), cop_rstress(), cop_powerstress(), cop_smacofSphere(), cop_sammon2(), cop_elastic(), cop_sstress(), cop_powerelastic(), cop_powersammon(): cop versions of these MDS models.
</p>
</li></ul>

<p>Methods: 
For most of the objects returned by the high-level functions S3 classes and methods for standard generics were implemented, including print, summary, plot, plot3dstatic.   
</p>
<p>References:
</p>

<ul>
<li><p> Rusch, T., Hornik, K. &amp; Mair, P. (2018) Assessing and quantifying clusteredness: The OPTICS Cordillera. Journal of Computational and Graphical Statistics, 27 (1), 220-233. <a href="https://doi.org/10.1080/10618600.2017.1349664">doi:10.1080/10618600.2017.1349664</a>
</p>
</li>
<li><p> Rusch, T., Mair, P. &amp; Hornik, K. (2021) Cluster optimized proximity scaling. Journal of Computational and Graphical Statistics. <a href="https://doi.org/10.1080/10618600.2020.1869027">doi:10.1080/10618600.2020.1869027</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Rusch <a href="mailto:thomas.rusch@wu.ac.at">thomas.rusch@wu.ac.at</a> (<a href="https://orcid.org/0000-0002-7773-2096">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrick Mair <a href="mailto:mair@fas.harvard.edu">mair@fas.harvard.edu</a> (<a href="https://orcid.org/0000-0003-0100-6511">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kurt Hornik <a href="mailto:Kurt.Hornik@R-project.org">Kurt.Hornik@R-project.org</a> (<a href="https://orcid.org/0000-0003-4198-9911">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-forge.r-project.org/projects/stops/">https://r-forge.r-project.org/projects/stops/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(BankingCrisesDistances)


# shorthand function for COPS-C (finding configuration with copstress)
res&lt;-cops(BankingCrisesDistances[,1:69],variant="COPS-C",
          stressweight=0.98,cordweight=0.02,itmax=1000)
# Note: itmax is very small here for illustration; will give a non-convergence
# warning of the optimizer which disappears at itmax=275000  

res
summary(res)
plot(res)
plot(res,"reachplot")
plot(res,"transplot")
plot(res,"Shepard")
#shorthand function for P-COPS (hyperparameter search for powerstress)
res&lt;-cops(BankingCrisesDistances[,1:69],variant="P-COPS")
res
summary(res)
plot(res)
plot(res,"reachplot")
plot(res,"transplot")
plot(res,"Shepard")

</code></pre>

<hr>
<h2 id='BankingCrisesDistances'>Banking Crises Distances</h2><span id='topic+BankingCrisesDistances'></span>

<h3>Description</h3>

<p>Matrix of Jaccard distances between 70 countries (Hungary and Greece were combined to be the same observation) based on their binary time series of having had a banking crises in a year from 1800 to 2010 or not. See data(bankingCrises) in package Ecdat for more info. The last column is Reinhart &amp; Rogoffs classification as a low (3), middle- (2) or high-income country (1).
</p>


<h3>Format</h3>

<p>A 69 x 70 matrix.
</p>


<h3>Source</h3>

<p>data(bankingCrises) in library(Ecdat)
</p>

<hr>
<h2 id='biplotmds.pcops'>S3 method for pcops objects</h2><span id='topic+biplotmds.pcops'></span>

<h3>Description</h3>

<p>S3 method for pcops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcops'
biplotmds(object, extvar, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplotmds.pcops_+3A_object">object</code></td>
<td>
<p>An object of class stops</p>
</td></tr>
<tr><td><code id="biplotmds.pcops_+3A_extvar">extvar</code></td>
<td>
<p>Data frame with external variables.</p>
</td></tr>
<tr><td><code id="biplotmds.pcops_+3A_scale">scale</code></td>
<td>
<p>if 'TRUE' external variables are standardized internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model for individual differences is provided, the external
variables are regressed on the group stimulus space
configurations. For objects returned from 'biplotmds' we use the plot method in
<code><a href="smacof.html#topic+biplotmds">biplotmds</a></code>. In the biplot called with plot() only the relative length of the
vectors and their direction matters. Using the vecscale argument in plot() the
user can control for the relative length of the vectors. If
'vecscale = NULL', the 'vecscale()' function from the 'candisc'
package is used which tries to automatically calculate the scale
factor so that the vectors approximately fill the same space as
the configuration. In this method vecscale should usually be smaller than the one used in smacof
by a factor of 0.1.
</p>


<h3>Value</h3>

<p>Returns an object belonging to classes 'mlm' and 'mdsbi'. See 'lm' for details.
R2vec: Vector containing the R2 values.
See also <code><a href="smacof.html#topic+biplotmds">biplotmds</a></code> for the plot method.
</p>

<hr>
<h2 id='biplotmds.stops'>S3 method for stops objects</h2><span id='topic+biplotmds.stops'></span>

<h3>Description</h3>

<p>S3 method for stops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stops'
biplotmds(object, extvar, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplotmds.stops_+3A_object">object</code></td>
<td>
<p>An object of class stops</p>
</td></tr>
<tr><td><code id="biplotmds.stops_+3A_extvar">extvar</code></td>
<td>
<p>Data frame with external variables.</p>
</td></tr>
<tr><td><code id="biplotmds.stops_+3A_scale">scale</code></td>
<td>
<p>if 'TRUE' external variables are standardized internally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a model for individual differences is provided, the external
variables are regressed on the group stimulus space
configurations. For objects returned from 'biplotmds' we use the plot method in
<code><a href="smacof.html#topic+biplotmds">biplotmds</a></code>. In the biplot called with plot() only the relative length of the
vectors and their direction matters. Using the vecscale argument in plot() the
user can control for the relative length of the vectors. If
'vecscale = NULL', the 'vecscale()' function from the 'candisc'
package is used which tries to automatically calculate the scale
factor so that the vectors approximately fill the same space as
the configuration. In this method vecscale should usually be smaller than the one used in smacof
by a factor of 0.1.
</p>


<h3>Value</h3>

<p>Returns an object belonging to classes 'mlm' and 'mdsbi'. See 'lm' for details.
R2vec: Vector containing the R2 values.
See also <code><a href="smacof.html#topic+biplotmds">biplotmds</a></code> for the plot method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see smacof::biplotmds for more
res &lt;- powerStressMin(morse,kappa=0.5,lambda=2)
fitbi &lt;- biplotmds(res, morsescales[,2:3])
plot(fitbi, main = "MDS Biplot", vecscale = 0.03)

</code></pre>

<hr>
<h2 id='bootmds.pcops'>MDS Bootstrap for pcops objects</h2><span id='topic+bootmds.pcops'></span>

<h3>Description</h3>

<p>Performs a bootstrap on an MDS solution. It works for derived dissimilarities only, i.e. generated by the call dist(data). The original data matrix needs to be provided, as well as the type of dissimilarity measure used to compute the input dissimilarities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcops'
bootmds(
  object,
  data,
  method.dat = "pearson",
  nrep = 100,
  alpha = 0.05,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootmds.pcops_+3A_object">object</code></td>
<td>
<p>Object of class smacofP if used as method or another object inheriting from smacofB (needs to be called directly as bootmds.smacofP then).</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_data">data</code></td>
<td>
<p>Initial data (before dissimilarity computation).</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_method.dat">method.dat</code></td>
<td>
<p>Dissimilarity computation used as MDS input. This must be one of &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;.</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_nrep">nrep</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for condfidence ellipsoids.</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', bootstrap index is printed out.</p>
</td></tr>
<tr><td><code id="bootmds.pcops_+3A_...">...</code></td>
<td>
<p>Additional arguments needed for dissimilarity computation as specified in <code><a href="smacof.html#topic+sim2diss">sim2diss</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a bootstrap on the raw data can be performed. This results in confidence ellipses in the configuration plot. The ellipses are returned as list which allows users to produce (and further customize) the plot by hand. See <code><a href="smacof.html#topic+bootmds">bootmds</a></code> for more.
</p>


<h3>Value</h3>

<p>An object of class 'smacofboot', see <code><a href="smacof.html#topic+bootmds">bootmds</a></code>. With values 
</p>

<ul>
<li><p> cov: Covariances for ellipse computation
</p>
</li>
<li><p> bootconf: Configurations bootstrap samples
</p>
</li>
<li><p> stressvec: Bootstrap stress values
</p>
</li>
<li><p> bootci: Stress bootstrap percentile confidence interval
</p>
</li>
<li><p> spp: Stress per point (based on stress.en) 
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dats &lt;- na.omit(PVQ40[,1:5])
diss &lt;- dist(t(dats))   ## Euclidean distances 
fit &lt;- pcops(diss,loss="rstress",itmaxi=50) #this is just for illustration: increase itmaxi    
set.seed(123)
resboot &lt;- bootmds(fit, dats, method.dat = "euclidean", nrep = 2)
</code></pre>

<hr>
<h2 id='cop_apstress'>PCOPS version of approximated power stress model.</h2><span id='topic+cop_apstress'></span>

<h3>Description</h3>

<p>This uses an approximation to power stress that makes use of smacofx as workhorse. Free parameters are kappa, lambda and nu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_apstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_apstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of parameters to optimize over. Must be of length three, with the first the kappa argument, the second the lambda argument and the third the nu argument. One cannot supply upsilon and tau as of yet. Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a binary matrix of nonnegative weights.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_apstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 of the configuration
</p>
</li>
<li><p>stress.m: default normalized stress (sqrt(stress-1)) 
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the OPTICS cordillera value
</p>
</li>
<li><p>parameters: the theta parameters used for fitting (kappa, lambda, nu)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure (typically of class smacofB or smacofP)
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_cmdscale'>PCOPS version of strain</h2><span id='topic+cop_cmdscale'></span>

<h3>Description</h3>

<p>The free parameter that pcops optimizes over is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_cmdscale(
  dis,
  theta = 1,
  type = "ratio",
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  itmaxi = 1000,
  add,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_cmdscale_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_type">type</code></td>
<td>
<p>MDS type. Ignored here.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. No effect here.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_add">add</code></td>
<td>
<p>should the dissimilarities be made Euclidean? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure smacofx::cmdscale. Note we always use eig=TRUE and that can't be changed (we need the GOF). Also default if nothing is supplied is to use add=TRUE which in my opinion one always should to avoid negative eigenvalues.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_cmdscale_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the badness-of-fit value (this isn't stress here but 1-(sum_ndim(max(eigenvalues,0))/sum_n(max(eigenvalues,0)), 1-GOF[2])
</p>
</li>
<li><p> stress.m: default normalized stress (manually calculated)
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure, which is cmdscalex object with some extra slots for the parameters and stresses 
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_elastic'>PCOPS versions of elastic scaling models (via smacofSym)</h2><span id='topic+cop_elastic'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights=delta is -2. Allows for a weight matrix because of smacof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_elastic(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_elastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the elscal weights)</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_elastic_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure (plus a slot for the orginal data $deltaorig)
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powerelastic'>PCOPS version of elastic scaling with powers</h2><span id='topic+cop_powerelastic'></span>

<h3>Description</h3>

<p>PCOPS version of elastic scaling with powers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powerelastic(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_powerelastic_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers;  a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar for the free parameters is given it is recycled.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powerelastic_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value (sqrt(stress.m))
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the OPTICScordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powermds'>PCOPS version of powermds</h2><span id='topic+cop_powermds'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but nu is internally fixed to 1, so no weight transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powermds(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_powermds_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length 2 where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled.  Defaults to 1,1.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to ratio.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powermds_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powersammon'>PCOPS version of sammon with powers</h2><span id='topic+cop_powersammon'></span>

<h3>Description</h3>

<p>This is power stress with free kappa and lambda but nu is fixed to -1 and the weights are delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powersammon(
  dis,
  theta = c(1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_powersammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; a vector of length two where the first element is kappa (for the fitted distances), the second lambda (for the observed proximities). If a scalar is given it is recycled for the free parameters.  Defaults to 1 1.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_type">type</code></td>
<td>
<p>MDS type. defaults to ratio.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations (of powerstress). default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powersammon_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress1 value  (sqrt(stress.m))
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the explicit parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_powerstress'>COPS version of powerstress</h2><span id='topic+cop_powerstress'></span>

<h3>Description</h3>

<p>Power stress with free kappa and lambda and rho (the theta argument) and ratio and interval optimal scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_powerstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_powerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances), the second lambda (for the observed proximities), the third nu (for the weights). If a scalar is given it is recycled.  Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_type">type</code></td>
<td>
<p>MDS type. Default is ratio.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_powerstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure plus a slot for the original data $deltaorig
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_rpowerstress'>PCOPS version of restricted powerstress.</h2><span id='topic+cop_rpowerstress'></span>

<h3>Description</h3>

<p>This is a power stress where kappa and lambda are free to vary but restricted to be equal, so the same exponent will be used for distances and dissimilarities. nu (for the weights) is also free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_rpowerstress(
  dis,
  theta = c(1, 1, 1),
  type = "ratio",
  weightmat = NULL,
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_rpowerstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first two arguments are for kappa and lambda and should be equal (for the fitted distances and observed proximities), the third nu (for the weights). Internally the kappa and lambda are equated based on theta[1]. If a scalar is given it is recycled (so all elements of theta are equal); if a vector of length 2 is given, it gets expanded to c(theta[1],theta[1],theta[2]). Defaults to 1 1 1.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_rpowerstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress1 value (sqrt(stress.m))
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the  explicit  parameters used for fitting (kappa=lambda, nu)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_rstress'>PCOPS version of rstress</h2><span id='topic+cop_rstress'></span>

<h3>Description</h3>

<p>Free parameter is kappa=2r for the fitted distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_rstress(
  dis,
  theta = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_rstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the kappa=2*r transformation for the fitted distances proximities. Defaults to 1. Note that what is returned is r, not kappa.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_type">type</code></td>
<td>
<p>MDS type. Defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_rstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (r)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sammon'>PCOPS version of Sammon mapping from MASS</h2><span id='topic+cop_sammon'></span>

<h3>Description</h3>

<p>Uses smacofx::sammon wrapper for MASS::sammon. The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sammon(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  init = NULL,
  weightmat = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_sammon_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be  a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_type">type</code></td>
<td>
<p>MDS type. Only &quot;ratio&quot; here.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. Default is 1000.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_scale">scale</code></td>
<td>
<p>if TRUE the configuration is scale adjusted</p>
</td></tr>
<tr><td><code id="cop_sammon_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1
</p>
</li>
<li><p> stress.m: default normalized stress (stress-1^2)
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure smacofx::sammon 
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sammon2'>Another COPS versions of Sammon mapping models (via smacofSym)</h2><span id='topic+cop_sammon2'></span>

<h3>Description</h3>

<p>Uses smacofSym, so it can deal with a weightmatrix and different types. The free parameter is lambda for power transformations of the observed proximities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sammon2(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_sammon2_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_theta">theta</code></td>
<td>
<p>theta the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_type">type</code></td>
<td>
<p>MDS type. Default is ratio.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights (NOT the sammon weights)</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_sammon2_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_smacofSphere'>PCOPS versions of smacofSphere models</h2><span id='topic+cop_smacofSphere'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_smacofSphere(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = NULL,
  init = NULL,
  itmaxi = 5000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_smacofSphere_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_type">type</code></td>
<td>
<p>MDS type</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_q">q</code></td>
<td>
<p>the norm of the corrdillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_smacofSphere_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress-1 value
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure  
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_smacofSym'>PCOPS versions of smacofSym models</h2><span id='topic+cop_smacofSym'></span>

<h3>Description</h3>

<p>The free parameter is lambda for power transformations the observed proximities. The fitted distances power is internally fixed to 1 and the power for the weights is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_smacofSym(
  dis,
  theta = 1,
  type = "ratio",
  ndim = 2,
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  itmaxi = 1000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = "sd",
  stresstype = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_smacofSym_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_theta">theta</code></td>
<td>
<p>the theta vector; should be a scalar for the lambda (proximity) transformation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_type">type</code></td>
<td>
<p>MDS type.</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 1000</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_smacofSym_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to report. Only takes smacofs default stress currrently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p>stress: the stress
</p>
</li>
<li><p>stress.m: default normalized stress
</p>
</li>
<li><p>copstress: the weighted loss value
</p>
</li>
<li><p>OC: the Optics cordillera value
</p>
</li>
<li><p>parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p>fit: the returned object of the fitting procedure 
</p>
</li>
<li><p>cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cop_sstress'>PCOPS version of sstress</h2><span id='topic+cop_sstress'></span>

<h3>Description</h3>

<p>Free parameter is lambda for the observed proximities. Fitted distances are transformed with power 2, weights have exponent of 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cop_sstress(
  dis,
  theta = 1,
  type = "ratio",
  weightmat = 1 - diag(nrow(dis)),
  init = NULL,
  ndim = 2,
  itmaxi = 10000,
  ...,
  stressweight = 1,
  cordweight = 0.5,
  q = 1,
  minpts = ndim + 1,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  scale = "sd",
  normed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cop_sstress_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; this must be a scalar of the lambda transformation for the observed proximities. Defaults to 1. Note that the lambda here works as a multiplicator of 2 (as sstress has f(delta^2)).</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_type">type</code></td>
<td>
<p>MDS type, defaults to &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_itmaxi">itmaxi</code></td>
<td>
<p>number of iterations. default is 10000.</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitting procedure</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted</p>
</td></tr>
<tr><td><code id="cop_sstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> stress: the stress-1 value
</p>
</li>
<li><p> stress.m: default normalized stress
</p>
</li>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='cops'>High Level COPS Function</h2><span id='topic+cops'></span>

<h3>Description</h3>

<p>About the function cops: The high level function allows for minimizing copstress for a clustered MDS configuration. Allows to choose COPS-C (finding a configuration from copstress with cordillera penalty) and profile COPS (finding hyperparameters for MDS models with power transformations). It is a wrapper for copstressMin and pcops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cops(
  dis,
  variant = c("1", "2", "Variant1", "Variant2", "v1", "v2", "COPS-C", "P-COPS",
    "configuration-c", "profile", "copstress-c", "p-copstress", "COPS-P", "copstress-p",
    "cops-c", "p-cops", "copsc", "pcops"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cops_+3A_dis">dis</code></td>
<td>
<p>a dissimilarity matrix or a dist object</p>
</td></tr>
<tr><td><code id="cops_+3A_variant">variant</code></td>
<td>
<p>a character string specifying which variant of COPS to fit. Allowed is any of the following &quot;1&quot;,&quot;2&quot;,&quot;Variant1&quot;,&quot;Variant2&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;COPS-C&quot;,&quot;P-COPS&quot;,&quot;configuration-c&quot;,&quot;profile&quot;,&quot;copstress-c&quot;,&quot;p-copstress&quot;. Defaults to &quot;COPS-C&quot;.</p>
</td></tr>
<tr><td><code id="cops_+3A_...">...</code></td>
<td>
<p>arguments to be passed to  <code><a href="#topic+copstressMin">copstressMin</a></code> (for Variant 1) or <code><a href="#topic+pcops">pcops</a></code> (for Variant 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For COPS-C Variant 1 see <code><a href="#topic+copstressMin">copstressMin</a></code>, for P-COPS Variant 2 see <code><a href="#topic+pcops">pcops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)

#COPS-C with equal weight to stress and cordillera 
res1&lt;-cops(dis,variant="COPS-C",stressweight=0.75,cordweight=0.25,
          minpts=2,itmax=1000) #use higher itmax in real
res1
summary(res1)
plot(res1)
plot(res1,"reachplot")



#s-stress type copstress (i.e. kappa=2, lambda=2)
res3&lt;-cops(dis,variant="COPS-C",kappa=2,lambda=2,stressweight=0.5,cordweight=0.5) 
res3
summary(res3)
plot(res3)


# power-stress type profile copstress
# search for optimal kappa and lambda between
# kappa=0.5,lambda=0.5 and kappa=2,lambda=5
# nu is fixed on -1
ws&lt;-1/dis
diag(ws)&lt;-1 
res5&lt;-cops(dis,variant="P-COPS",loss="powerstress",
          theta=c(1.4,3,-1), lower=c(1,0.5,-1),upper=c(3,5,-1),
          weightmat=ws, stressweight=0.9,cordweight=0.1) 
res5
summary(res5)
plot(res5)




</code></pre>

<hr>
<h2 id='copstress'>Calculates copstress for given MDS object</h2><span id='topic+copstress'></span>

<h3>Description</h3>

<p>Calculates copstress for given MDS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copstress(
  obj,
  stressweight = 1,
  cordweight = 5,
  q = 1,
  minpts = 2,
  epsilon = 10,
  rang = NULL,
  verbose = 0,
  normed = TRUE,
  scale = c("std", "sd", "proc", "none"),
  init,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copstress_+3A_obj">obj</code></td>
<td>
<p>MDS object (supported are sammon, cmdscale, smacof, rstress, powermds)</p>
</td></tr>
<tr><td><code id="copstress_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="copstress_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.5</p>
</td></tr>
<tr><td><code id="copstress_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="copstress_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to 2</p>
</td></tr>
<tr><td><code id="copstress_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="copstress_+3A_rang">rang</code></td>
<td>
<p>range of the distances (min distance minus max distance). If NULL (default) the cordillera will be normed to each configuration's maximum distance, so an absolute value of goodness-of-clusteredness.</p>
</td></tr>
<tr><td><code id="copstress_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose (copstress level), &gt;3 is extremely (up to MDS optimization level)</p>
</td></tr>
<tr><td><code id="copstress_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="copstress_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scale adjusted.</p>
</td></tr>
<tr><td><code id="copstress_+3A_init">init</code></td>
<td>
<p>a reference configuration when doing procrustes adjustment</p>
</td></tr>
<tr><td><code id="copstress_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the cordillera function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the Optics cordillera value
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>


<hr>
<h2 id='copstressMin'>Fitting a COPS-C Model (COPS Variant 1).</h2><span id='topic+copstressMin'></span><span id='topic+copsc'></span><span id='topic+copStressMin'></span>

<h3>Description</h3>

<p>Minimizing Copstress to obtain a clustered ratio, interval or ordinal PS configuration with given explicit power transformations theta. The function allows mix-and-match of explicit (via theta) and implicit (via type) transformations by setting the kappa, lambda, nu (or theta) and type arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copstressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  theta = c(kappa, lambda, nu),
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  ndim = 2,
  init = NULL,
  stressweight = 0.975,
  cordweight = 0.025,
  q = 1,
  minpts = ndim + 1,
  epsilon = max(10, max(delta)),
  dmax = NULL,
  rang,
  optimmethod = c("NelderMead", "Newuoa", "BFGS", "SANN", "hjk", "solnl", "solnp",
    "subplex", "snomadr", "hjk-Newuoa", "hjk-BFGS", "BFGS-hjk", "Newuoa-hjk", "cmaes",
    "direct", "direct-Newuoa", "direct-BFGS", "genoud", "gensa"),
  verbose = 0,
  scale = c("sd", "rmsq", "proc", "none"),
  normed = TRUE,
  accuracy = 1e-07,
  itmax = 10000,
  stresstype = c("stress-1", "stress"),
  principal = FALSE,
  ...
)

copsc(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  theta = c(kappa, lambda, nu),
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  ndim = 2,
  init = NULL,
  stressweight = 0.975,
  cordweight = 0.025,
  q = 1,
  minpts = ndim + 1,
  epsilon = max(10, max(delta)),
  dmax = NULL,
  rang,
  optimmethod = c("NelderMead", "Newuoa", "BFGS", "SANN", "hjk", "solnl", "solnp",
    "subplex", "snomadr", "hjk-Newuoa", "hjk-BFGS", "BFGS-hjk", "Newuoa-hjk", "cmaes",
    "direct", "direct-Newuoa", "direct-BFGS", "genoud", "gensa"),
  verbose = 0,
  scale = c("sd", "rmsq", "proc", "none"),
  normed = TRUE,
  accuracy = 1e-07,
  itmax = 10000,
  stresstype = c("stress-1", "stress"),
  principal = FALSE,
  ...
)

copStressMin(
  delta,
  kappa = 1,
  lambda = 1,
  nu = 1,
  theta = c(kappa, lambda, nu),
  type = c("ratio", "interval", "ordinal"),
  ties = "primary",
  weightmat = 1 - diag(nrow(delta)),
  ndim = 2,
  init = NULL,
  stressweight = 0.975,
  cordweight = 0.025,
  q = 1,
  minpts = ndim + 1,
  epsilon = max(10, max(delta)),
  dmax = NULL,
  rang,
  optimmethod = c("NelderMead", "Newuoa", "BFGS", "SANN", "hjk", "solnl", "solnp",
    "subplex", "snomadr", "hjk-Newuoa", "hjk-BFGS", "BFGS-hjk", "Newuoa-hjk", "cmaes",
    "direct", "direct-Newuoa", "direct-BFGS", "genoud", "gensa"),
  verbose = 0,
  scale = c("sd", "rmsq", "proc", "none"),
  normed = TRUE,
  accuracy = 1e-07,
  itmax = 10000,
  stresstype = c("stress-1", "stress"),
  principal = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copstressMin_+3A_delta">delta</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_kappa">kappa</code></td>
<td>
<p>power transformation for fitted distances</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_lambda">lambda</code></td>
<td>
<p>power transformation for proximities (only used if type=&quot;ratio&quot; or &quot;interval&quot;)</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_nu">nu</code></td>
<td>
<p>power transformation for weights</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_theta">theta</code></td>
<td>
<p>the theta vector of powers; the first is kappa (for the fitted distances if it exists), the second lambda (for the observed proximities if it exist and type=&quot;ratio&quot; or &quot;interval&quot;), the third is nu (for the weights if it exists). If less than three elements are is given as argument, it will be recycled. Defaults to 1 1 1. Will override any kappa, lambda, nu parameters if they are given and do not match.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_type">type</code></td>
<td>
<p>what type of MDS to fit. Currently one of &quot;ratio&quot;, &quot;interval&quot; or &quot;ordinal&quot;. Default is &quot;ratio&quot;.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_ties">ties</code></td>
<td>
<p>the handling of ties for ordinal (nonmetric) MDS. Possible are &quot;primary&quot; (default), &quot;secondary&quot; or &quot;tertiary&quot;.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 0.975</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; defaults to 0.025</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS, see <code><a href="dbscan.html#topic+optics">optics</a></code> where it is called <code>minPts</code>; defaults to ndim+1.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked, see <code><a href="dbscan.html#topic+optics">optics</a></code>; defaults to 10 (which is plenty for the explicit normalization we use). Note this means we do not expect any noise objects per default. This number will rarely be exceeded if we standardize the configuration as is the default in cops. However if no standardization is applied or there is a procrustes adjustment to a configuration with variance of 10 or more on any of the axes, it can have the effect of being too small. In that case just set a much higher epsilon.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_dmax">dmax</code></td>
<td>
<p>The winsorization limit of reachability distances in the OPTICS Cordillera. If supplied, it should be either a numeric value that matches 'max(rang)' or 'NULL'; if 'NULL' it is found as 1.5 times (for kappa &gt;1) or 1 times (for kappa &lt;=1) the maximum reachbility value of the power torgerson model with the same lambda. If 'dmax' and 'rang' are supplied and 'dmax' is not 'max(rang)', a warning is given and 'rang' takes precedence.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_rang">rang</code></td>
<td>
<p>range of the reachabilities to be considered. If missing it is found from the initial configuration by taking 0 as the lower boundary and dmax (see above) as upper boundary. See also <code><a href="cordillera.html#topic+cordillera">cordillera</a></code></p>
</td></tr>
<tr><td><code id="copstressMin_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What optimizer to use? Choose one string of 'Newuoa' (<code><a href="minqa.html#topic+newuoa">newuoa</a></code>), 'NelderMead' (see <code><a href="stats.html#topic+optim">optim</a></code>), 'hjk' (Hooke-Jeeves algorithm from <code><a href="dfoptim.html#topic+hjk">hjk</a></code>), 'solnl' (from <code><a href="NlcOptim.html#topic+solnl">solnl</a></code>), 'solnp' (from <code><a href="Rsolnp.html#topic+solnp">solnp</a></code>), 'subplex' (from <code><a href="subplex.html#topic+subplex">subplex</a></code>), 'SANN' (simulated annealing, <code><a href="stats.html#topic+optim">optim</a></code>), 'BFGS' (see <code><a href="stats.html#topic+optim">optim</a></code>), 'snomadr' (from <code><a href="crs.html#topic+snomadr">snomadr</a></code>), 'genoud' (from <code><a href="rgenoud.html#topic+genoud">genoud</a></code>), 'gensa' (from <code><a href="GenSA.html#topic+GenSA">GenSA</a></code>), 'cmaes' (from <code><a href="cmaes.html#topic+cma_es">cma_es</a></code>) and 'direct' (from <code><a href="nloptr.html#topic+direct">direct</a></code>). See the linked functions for details on these solvers. There are also combinations that proved to work well good, like 'hjk-Newuoa', 'hjk-BFGS', 'BFGS-hjk', 'Newuoa-hjk', 'direct-Newuoa' and 'direct-BFGS'. Usually everything with 'hjk', 'BFGS', 'Newuoa', 'subplex' and 'solnl' in it work rather well in an acceptable time frame (depending on the smoothness of copstress). Default is 'hjk-Newuoa'.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is very verbose</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_scale">scale</code></td>
<td>
<p>Scale the configuration (in MDS stress is invariant up to a scaling factor). One of &quot;none&quot; (so no extra scaling of the configuration but normalized to sum delta^2=1), &quot;sd&quot; (configuration divided by the highest standard deviation of any the columns), &quot;proc&quot; (procrustes adjustment to the initial fit) and &quot;rmsq&quot; (configuration divided by the maximum root mean square of the columns). Default is &quot;sd&quot; which often gives a nicer spread on the axes. Note that the scaled configuration is returned as $conf and the unscaled as $usconf, so manual calculation of the OC should be done with $conf.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_normed">normed</code></td>
<td>
<p>should the Cordillera be normed; defaults to TRUE.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_accuracy">accuracy</code></td>
<td>
<p>numerical accuracy, defaults to 1e-7.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations. Defaults to 10000. For the two-step algorithms if itmax is exceeded by the first solver, the second algorithm is run for at least 0.1*itmax (so overall itmax may be exceeded by a factor of 1.1).</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_stresstype">stresstype</code></td>
<td>
<p>which stress to use in the copstress. Defaults to stress-1. If anything else is set, explicitly normed stress which is (stress-1)^2 is used. Using stress-1 puts more weight on MDS fit.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_principal">principal</code></td>
<td>
<p>If ‘TRUE’, principal axis transformation is applied to the final configuration.</p>
</td></tr>
<tr><td><code id="copstressMin_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the optimization procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an extremely flexible approach to least squares proximity scaling: It supports ratio power stress; ratio, interval and ordinal r stress and ratio, interval and ordinal MDS with or without a COPS penalty. Famous special cases of these models that can be fitted are multiscale MDS if kappa-&gt;0 and delta=log(delta), Alscal MDS (sstress) with lambda=kappa=2, sammon type mapping with weightmat=delta and nu=-1, elastic scaling with weightmat=delta and nu=-2. Due to mix-and-match this function also allows to fit models that have not yet been published, such as for example an &quot;elastic scaling ordinal s-stress with cops penalty&quot;.
</p>
<p>If one wants to fit these models without the cops penalty, we recommend to use <code><a href="smacofx.html#topic+powerStressMin">powerStressMin</a></code> (for ratio and interval MDS with any power transformation for weights, dissimilarities and distances) or <code><a href="smacofx.html#topic+rStressMin">rStressMin</a></code> (for ratio, interval and ordinal MDS with power transformations for distances and weights) as these use majorization.
</p>
<p>Some optimizers (including the default hjk-Newuoa) will print a warning if itmax is (too) small or if there was no convergence. Consider increasing itmax then.
</p>
<p>For some solvers theresometimes may be an error [NA/NaN/Inf in foreign function call (arg 3)] stemming from smacof::transform(). This happens when the algorithm places two object at exactly the same place so their fitted distance is 0. This is good from an OPTICS Cordillera point of view (as it is more clustered) which is why some solvers like to pick that up, but it can lead to an issue in the optimal scaling in smacof. This can usually be mitigated when specifying the model by either using less cordweight, less itmax, less accuracy or combining the two offending objects into one (so include them as a combined row in the distance matrix).
</p>
<p>We might eventually switch to newuoa in nloptr.
</p>


<h3>Value</h3>

<p>A copsc object (inheriting from smacofP). A list with the components
</p>

<ul>
<li><p> delta: the original untransformed dissimilarities
</p>
</li>
<li><p> tdelta: the explicitly transformed dissimilarities 
</p>
</li>
<li><p> dhat: the explicitly transformed dissimilarities (dhats), optimally scaled and normalized (which are approximated by the fit)
</p>
</li>
<li><p> confdist: Configuration distances, the transformed fitted distances
</p>
</li>
<li><p> conf: the configuration (normed) and scaled as specified in scale. 
</p>
</li>
<li><p> usconf: the unscaled configuration (normed to sum delta^2=1). Scaling applied to usconf gives conf.
</p>
</li>
<li><p> parameters, par, pars : the theta vector of powers tranformations (kappa, lambda, nu)
</p>
</li>
<li><p> niter: number of iterations of the optimizer. 
</p>
</li>
<li><p> stress: the square root of explicitly normalized stress (calculated for confo).
</p>
</li>
<li><p> spp: stress per point
</p>
</li>
<li><p> ndim: number of dimensions
</p>
</li>
<li><p> model: Fitted model name
</p>
</li>
<li><p> call: the call
</p>
</li>
<li><p> nobj: the number of objects
</p>
</li>
<li><p> type, loss, losstype: stresstype
</p>
</li>
<li><p> stress.m: The stress used for copstress. If stresstype=&quot;stress-1&quot; this is like $stress else it is stress^2
</p>
</li>
<li><p> copstress: the copstress loss value
</p>
</li>
<li><p> resmat: the matrix of residuals
</p>
</li>
<li><p> weightmat: the matrix of untransformed weights
</p>
</li>
<li><p> tweightmat: the transformed weighting matrix (here weightmat^nu) 
</p>
</li>
<li><p> OC: the (normed) OPTICS Cordillera object (calculated for scaled conf)
</p>
</li>
<li><p> OCv: the (normed) OPTICS Cordillera value alone (calculated for scaled conf)
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stressweight, cordweight: the weights of the stress and OC respectively (v_1 and v_2)
</p>
</li>
<li><p> optimmethod: The solver used 
</p>
</li>
<li><p> type: the type of MDS fitted
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)

set.seed(1)
## Copstress with equal weight to stress and cordillera 
res1&lt;-copstressMin(dis,stressweight=0.5,cordweight=0.5,
                  itmax=100) #use higher itmax about 10000 
res1
summary(res1)
plot(res1)  #super clustered 

##Alias name 
res1&lt;-copsc(dis,stressweight=0.5,
                  cordweight=0.5,itmax=100) 


## Elastic scaling ordinal s-stress with cops penalty
res1&lt;-copsc(dis,type="ordinal",kappa=2,nu=-2,weightmat=dis,
            stressweight=0.5, cordweight=0.5,itmax=100)


</code></pre>

<hr>
<h2 id='doubleCenter'>Double centering of a matrix</h2><span id='topic+doubleCenter'></span>

<h3>Description</h3>

<p>Double centering of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubleCenter(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doubleCenter_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the double centered matrix
</p>

<hr>
<h2 id='enorm'>Explicit Normalization
Normalizes distances</h2><span id='topic+enorm'></span>

<h3>Description</h3>

<p>Explicit Normalization
Normalizes distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enorm(x, w = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enorm_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="enorm_+3A_w">w</code></td>
<td>
<p>weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constant
</p>

<hr>
<h2 id='jackmds.pcops'>MDS Jackknife for pcops objects</h2><span id='topic+jackmds.pcops'></span>

<h3>Description</h3>

<p>These methods perform an MDS Jackknife and plot the corresponding solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcops'
jackmds(object, eps = 1e-06, itmax = 100, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jackmds.pcops_+3A_object">object</code></td>
<td>
<p>Object of class pcops.</p>
</td></tr>
<tr><td><code id="jackmds.pcops_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="jackmds.pcops_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="jackmds.pcops_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE', intermediate stress is printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to examine the stability solution of an MDS, a Jackknife on the configurations can be performed (see de Leeuw &amp; Meulman, 1986) and plotted. The plot shows the jackknife configurations which are connected to their centroid. In addition, the original configuration (transformed through Procrustes) is plotted. The Jackknife function itself returns also a stability measure (as ratio of between and total variance), a measure for cross validity, and the dispersion around the original smacof solution.
</p>
<p>Note that this jackknife only resamples the configuration given the selected hyperparameters, so uncertainty with respect to the hyperparameetr selection is not incorporated.
</p>


<h3>Value</h3>

<p>An object of class 'smacofJK', see <code><a href="smacof.html#topic+jackmds">jackmds</a></code>. With values 
</p>

<ul>
<li><p> smacof.conf: Original configuration
</p>
</li>
<li><p> jackknife.confboot: An array of n-1 configuration matrices for each Jackknife MDS solution
</p>
</li>
<li><p> comparison.conf: Centroid Jackknife configurations (comparison matrix)
</p>
</li>
<li><p> cross: Cross validity
</p>
</li>
<li><p> stab: Stability coefficient
</p>
</li>
<li><p> disp: Dispersion
</p>
</li>
<li><p> loss: Value of the loss function (just used internally)
</p>
</li>
<li><p> ndim: Number of dimensions
</p>
</li>
<li><p> call: Model call
</p>
</li>
<li><p> niter: Number of iterations
</p>
</li>
<li><p> nobj: Number of objects
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>diso&lt;-kinshipdelta
fit &lt;- pcops(diso,loss="stress") 
res.jk &lt;- jackmds(fit)
plot(res.jk)
</code></pre>

<hr>
<h2 id='ljoptim'>(Adaptive) Version of Luus-Jakola Optimization</h2><span id='topic+ljoptim'></span>

<h3>Description</h3>

<p>Adaptive means that the search space reduction factors in the number of iterations; makes convergence faster at about 100 iterations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljoptim(
  x,
  fun,
  ...,
  red = ifelse(adaptive, 0.99, 0.95),
  lower,
  upper,
  acc = 1e-06,
  accd = 1e-04,
  itmax = 1000,
  verbose = 0,
  adaptive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ljoptim_+3A_x">x</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_fun">fun</code></td>
<td>
<p>function to minimize</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function to be optimized</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_red">red</code></td>
<td>
<p>value of the reduction of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_lower">lower</code></td>
<td>
<p>The lower contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_upper">upper</code></td>
<td>
<p>The upper contraints of the search region</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_acc">acc</code></td>
<td>
<p>if the numerical accuracy of two successive target function values is below this, stop the optimization; defaults to 1e-6</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_accd">accd</code></td>
<td>
<p>if the width of the search space is below this, stop the optimization; defaults to 1e-4</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_itmax">itmax</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose</p>
</td></tr>
<tr><td><code id="ljoptim_+3A_adaptive">adaptive</code></td>
<td>
<p>should the adaptive version be used? defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the components (see also <code><a href="stats.html#topic+optim">optim</a></code>)
</p>

<ul>
<li><p> par The position of the optimimum in the search space (parameters that minimize the function; argmin fun)
</p>
</li>
<li><p> value The value of the objective function at the optimum (min fun)
</p>
</li>
<li><p> counts The number of iterations performed at convergence with entries fnction for the number of iterations and gradient which is always NA at the moment
</p>
</li>
<li><p> convergence 0 successful completion by the accd or acc criterion, 1 indicate iteration limit was reached, 99 is a problem 
</p>
</li>
<li><p> message is NULL (only for compatibility or future use)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fbana &lt;- function(x) {
x1 &lt;- x[1]
x2 &lt;- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
res1&lt;-ljoptim(c(-1.2,1),fbana,lower=-5,upper=5,accd=1e-16,acc=1e-16)
res1

set.seed(210485)
fwild &lt;- function (x) 10*sin(0.3*x)*sin(1.3*x^2) + 0.00001*x^4 + 0.2*x+80
plot(fwild, -50, 50, n = 1000, main = "ljoptim() minimising 'wild function'")
res2&lt;-ljoptim(50, fwild,lower=-50,upper=50,adaptive=FALSE,accd=1e-16,acc=1e-16)
points(res2$par,res2$value,col="red",pch=19)
res2

</code></pre>

<hr>
<h2 id='matchphi'>Distances of MATCH-ADTC modules</h2><span id='topic+matchphi'></span>

<h3>Description</h3>

<p>A symmetric distance matrix of 32 MATCH-ADT modules based on their usage by clinicians. The raw data were counts of how often each module has been used with each of 449 youths, resulting in a count profile of each module. Based on that the phi-distance between the modules has been calculated.
</p>


<h3>Format</h3>

<p>A 32 x 32 distance matrix.
</p>


<h3>Details</h3>

<p>This is an object that inherits from class distance (see package analogue) and matrix.
</p>

<hr>
<h2 id='mkBmat'>Auxfunction1</h2><span id='topic+mkBmat'></span>

<h3>Description</h3>

<p>only used internally
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkBmat(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkBmat_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='mkPower'>Take matrix to a power</h2><span id='topic+mkPower'></span>

<h3>Description</h3>

<p>Take matrix to a power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkPower(x, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkPower_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="mkPower_+3A_r">r</code></td>
<td>
<p>numeric (power)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='pcops'>Profile COPS Function (aka COPS Variant 2)</h2><span id='topic+pcops'></span>

<h3>Description</h3>

<p>Metaparameter selection for MDS models baseed on the Profile COPS approach (COPS Variant 2). It uses copstress for hyperparameter selection of explicit transformations (currently power transformations). It is a special case of a STOPS model and predated it; <code><a href="stops.html#topic+stops">stops</a></code> has more functionality and can be seen as the successor. pcops uses explicitly normalized stress for copstress (not stress-1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcops(
  dis,
  loss = c("stress", "smacofSym", "smacofSphere", "strain", "sammon", "rstress",
    "powermds", "sstress", "elastic", "powersammon", "powerelastic", "powerstress",
    "sammon2", "powerstrain", "apstress", "rpowerstress"),
  type = "ratio",
  weightmat = NULL,
  ndim = 2,
  init = NULL,
  theta = c(1, 1, 1),
  stressweight = 1,
  cordweight,
  q = 2,
  minpts = ndim + 1,
  epsilon = 100,
  rang,
  optimmethod = c("ALJ", "pso", "SANN", "direct", "directL", "stogo", "MADS", "hjk"),
  lower = 0.5,
  upper = 5,
  verbose = 0,
  scale = c("proc", "sd", "none", "std"),
  normed = TRUE,
  s = 4,
  acc = 1e-05,
  itmaxo = 200,
  itmaxi = 5000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcops_+3A_dis">dis</code></td>
<td>
<p>numeric matrix or dist object of a matrix of proximities</p>
</td></tr>
<tr><td><code id="pcops_+3A_loss">loss</code></td>
<td>
<p>which loss function to be used for fitting, defaults to strain. See Details.</p>
</td></tr>
<tr><td><code id="pcops_+3A_type">type</code></td>
<td>
<p>MDS type which may be one of &quot;ratio&quot;, interval&quot;, &quot;ordinal&quot;. Defaults to &quot;ratio&quot;. Note not all loss arguments support all types; if not there will be an error and infor which types are supported. In that case choose another type.</p>
</td></tr>
<tr><td><code id="pcops_+3A_weightmat">weightmat</code></td>
<td>
<p>(optional) a matrix of nonnegative weights; defaults to 1 for all off diagonals</p>
</td></tr>
<tr><td><code id="pcops_+3A_ndim">ndim</code></td>
<td>
<p>number of dimensions of the target space</p>
</td></tr>
<tr><td><code id="pcops_+3A_init">init</code></td>
<td>
<p>(optional) initial configuration. If not supplied, the Torgerson scaling result of the dissimilarity matrix dis^theta[2]/enorm(dis^theta[2],weightmat) is used.</p>
</td></tr>
<tr><td><code id="pcops_+3A_theta">theta</code></td>
<td>
<p>the theta vector of free parameters; see details for the number of free parameters for each loss function. Defaults to 1 for all free parameters. Make sure to supply a theta of the correct length as the mechanisms in place to automatically choose theta/upper/lower are dependent on the optimizer and ad hoc: If this is a vector with more elements than necessary, it is either cut (so for a vector of length 3 and a function with 2 free parameters, the first two elements of the vector are used) or there will be an error. If a scalar is given as argument and the number of free parameters is larger than 1, the scalar will be recycled and this may also make the optimizers equate all free parameters.</p>
</td></tr>
<tr><td><code id="pcops_+3A_stressweight">stressweight</code></td>
<td>
<p>weight to be used for the fit measure; defaults to 1</p>
</td></tr>
<tr><td><code id="pcops_+3A_cordweight">cordweight</code></td>
<td>
<p>weight to be used for the cordillera; if missing gets estimated from the initial configuration so that copstress = 0 for theta=1</p>
</td></tr>
<tr><td><code id="pcops_+3A_q">q</code></td>
<td>
<p>the norm of the cordillera; defaults to 1</p>
</td></tr>
<tr><td><code id="pcops_+3A_minpts">minpts</code></td>
<td>
<p>the minimum points to make up a cluster in OPTICS; defaults to ndim+1</p>
</td></tr>
<tr><td><code id="pcops_+3A_epsilon">epsilon</code></td>
<td>
<p>the epsilon parameter of OPTICS, the neighbourhood that is checked; defaults to 10</p>
</td></tr>
<tr><td><code id="pcops_+3A_rang">rang</code></td>
<td>
<p>range of the minimum reachabilities to be considered. If missing it is found from the initial configuration by taking 1.5 times the maximal minimum reachability of the model with theta=1. If NULL it will be normed to each configuration's minimum and maximum distance, so an absolute value of goodness-of-clusteredness. Note that the latter is not necessarily desirable when comparing configurations for their relative clusteredness. See also <code><a href="cordillera.html#topic+cordillera">cordillera</a></code>.</p>
</td></tr>
<tr><td><code id="pcops_+3A_optimmethod">optimmethod</code></td>
<td>
<p>What general purpose optimizer to use? Defaults to our adaptive LJ version (ALJ). Also allows particle swarm optimization with s particles (&quot;pso&quot;, <code><a href="pso.html#topic+psoptim">psoptim</a></code>) and simulated annealing (&quot;SANN&quot;, <code><a href="stats.html#topic+optim">optim</a></code>), &quot;directT&quot; or &quot;directL&quot; (see <code><a href="nloptr.html#topic+direct">direct</a></code>), Hooke-Jeeves (&quot;hjk&quot;, <code><a href="dfoptim.html#topic+hjk">hjk</a></code>), StoGo (&quot;stogo&quot;, <code><a href="nloptr.html#topic+stogo">stogo</a></code>), and &quot;snomadr&quot; (<code><a href="crs.html#topic+snomadr">snomadr</a></code>). We recommend not using SANN and pso with the rstress, sstress and the power stress models. We made good experiences with ALJ, stogo, direct and directL and also snomadr.</p>
</td></tr>
<tr><td><code id="pcops_+3A_lower">lower</code></td>
<td>
<p>A vector of the lower box contraints of the search region. Its length must match the length of theta.</p>
</td></tr>
<tr><td><code id="pcops_+3A_upper">upper</code></td>
<td>
<p>A vector of the upper box contraints of the search region. Its length must match the length of theta.</p>
</td></tr>
<tr><td><code id="pcops_+3A_verbose">verbose</code></td>
<td>
<p>numeric value hat prints information on the fitting process; &gt;2 is extremely verbose. Note that for models with some parameters fixed, the iteration progress of the optimizer shows different values also for the fixed parameters because due to the modular setup we always optimize over a three parameter vector. These values are inconsequential however as internally they will be fixed.</p>
</td></tr>
<tr><td><code id="pcops_+3A_scale">scale</code></td>
<td>
<p>should the configuration be scaled and/or centered for calculating the cordillera? &quot;std&quot; standardizes each column of the configurations to mean=0 and sd=1 (typically not a good idea), &quot;sd&quot; scales the configuration by the maximum standard devation of any column (default), &quot;proc&quot; adjusts the fitted configuration to the init configuration (or the Togerson scaling solution if init=NULL). This parameter only has an effect for calculating the cordillera, the fitted and returned configuration is NOT scaled.</p>
</td></tr>
<tr><td><code id="pcops_+3A_normed">normed</code></td>
<td>
<p>should the cordillera be normed; defaults to TRUE</p>
</td></tr>
<tr><td><code id="pcops_+3A_s">s</code></td>
<td>
<p>number of particles if pso is used</p>
</td></tr>
<tr><td><code id="pcops_+3A_acc">acc</code></td>
<td>
<p>termination threshold difference of two successive outer minimization steps.</p>
</td></tr>
<tr><td><code id="pcops_+3A_itmaxo">itmaxo</code></td>
<td>
<p>iterations of the outer step (optimization over the hyperparmeters; if solver allows it). Defaults to 200.</p>
</td></tr>
<tr><td><code id="pcops_+3A_itmaxi">itmaxi</code></td>
<td>
<p>iterations of the inner step (optimization of the MDS). Defaults to 5000.</p>
</td></tr>
<tr><td><code id="pcops_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the optimization procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently allows for the following models:
</p>

<ul>
<li><p> Power transformations applied to observed proximities only (theta, upper, lower should be numeric scalar): Strain loss/Torgerson scaling (<code>strain</code>, workhorse: smacofx::cmdscale), Stress for symmetric matrices (<code>smacofSym</code>, <code>stress</code>,<code>smacofSphere</code> for scaling onto a sphere; workhorse: smacof::smacofSym), Sammon mapping (<code>sammon</code>, workhorse is smacofx::sammon or <code>sammon2</code>, workhorse: smacof::smacofSym), elastic scaling (<code>elastic</code>, workhorse smacof::smacofSym), Alscal or S-Stress <code>sstress</code> (workhorse: smacofx::powerStressMin)
</p>
</li>
<li><p> Power transformations of fitted distances only (theta, upper, lower should be numeric scalar): r-stress <code>rstress</code> (workhorse: smacofx:rStressMin)
</p>
</li>
<li><p> Power transformations applied to fitted distances and observed proximities (theta, upper, lower should be numeric of length 2): Power MDS (<code>powermds</code>, workhorse: smacofx::powerStressMin), Sammon Mapping/elastic scaling with powers (<code>powersammon</code>, <code>powerelastic</code>, workhorse: smacofx::powerStressMin)
</p>
</li>
<li><p> Power transformations applied to fitted distances, observed proximities and weights (theta, upper, lower should be numeric of length 3): power stress (POST-MDS, <code>powerstress</code>, workhorse: smacofx::powerStressMin), restricted power stress with equal transformations for distances and proximities (<code>rpowerstress</code>); workhorse: smacofx::powerStressMin), approximated power stress (<code>apstress</code>; workhorse: smacof::smacofSym)
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the components
</p>

<ul>
<li><p> copstress: the weighted loss value
</p>
</li>
<li><p> OC: the OPTICS cordillera for the scaled configuration (as defined by scale) 
</p>
</li>
<li><p> optim: the object returned from the optimization procedure
</p>
</li>
<li><p> stress: the stress (square root of stress.m)
</p>
</li>
<li><p> stress.m: default normalized stress 
</p>
</li>
<li><p> parameters: the parameters used for fitting (kappa, lambda)
</p>
</li>
<li><p> fit: the returned object of the fitting procedure
</p>
</li>
<li><p> cordillera: the cordillera object
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
set.seed(210485)
#configuration is scaled with highest column sd for calculating cordilera 
res1&lt;-pcops(dis,loss="strain",lower=0.1,upper=5,minpts=2) 
res1
summary(res1)
plot(res1)


</code></pre>

<hr>
<h2 id='pdist'>Squared p-distances</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Squared p-distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(x, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="pdist_+3A_p">p</code></td>
<td>
<p>p&gt;0 the Minkoswki distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared Minkowski distance matrix
</p>

<hr>
<h2 id='phidistance'>Calculating the pairwise phi distance matrix between n vectors</h2><span id='topic+phidistance'></span>

<h3>Description</h3>

<p>The pairwise phi-distance of two vectors x and y is sqrt(sum(((x[i]-y[i])^2)/((x[i]+y[i])*(sum(x)+sum(y))))). The function calculates this for all pairs of rows of a matrix or data frame X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phidistance(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phidistance_+3A_x">X</code></td>
<td>
<p>an n times p numeric matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric n times n matrix of pairwise phi distance (between rows of X) with 0 in the main diagonal. Is an object of class distance and matrix.
</p>

<hr>
<h2 id='plot.copsc'>S3 plot method for cops objects</h2><span id='topic+plot.copsc'></span>

<h3>Description</h3>

<p>S3 plot method for cops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'copsc'
plot(x, plot.type, main, asp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.copsc_+3A_x">x</code></td>
<td>
<p>an object of class cops</p>
</td></tr>
<tr><td><code id="plot.copsc_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: &quot;confplot&quot;, &quot;reachplot&quot;, &quot;resplot&quot;,&quot;transplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;, &quot;bubblepot&quot;, &quot;histogram&quot;  (see details)</p>
</td></tr>
<tr><td><code id="plot.copsc_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.copsc_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to 1; setting to 1 will lead to an accurate representation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.copsc_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacofP' and 'plot' for detailed information.
</p>
<p>Details:
</p>

<ul>
<li><p> Configuration plot (plot.type = &quot;confplot&quot;): Plots the MDS configurations.
</p>
</li>
<li><p> Reachability plot (plot.type = &quot;confplot&quot;): Plots the OPTICS reachability plot and the OPTICS cordillera 
</p>
</li>
<li><p> Residual plot (plot.type = &quot;resplot&quot;): Plots the dissimilarities against the fitted distances.
</p>
</li>
<li><p> Linearized Shepard diagram (plot.type = &quot;Shepard&quot;): Diagram with the transformed observed dissimilarities against the transformed fitted distance as well as loess smooth and a least squares line.
</p>
</li>
<li><p> Transformation Plot (plot.type = &quot;transplot&quot;): Diagram with the observed dissimilarities (lighter) and the transformed observed dissimilarities (darker) against the fitted distances together with loess smoothing lines 
</p>
</li>
<li><p> Stress decomposition plot (plot.type = &quot;stressplot&quot;, only for SMACOF objects in $fit): Plots the stress contribution in of each observation. Note that it rescales the stress-per-point (SPP) from the corresponding smacof function to percentages (sum is 100). The higher the contribution, the worse the fit.
</p>
</li>
<li><p> Bubble plot (plot.type = &quot;bubbleplot&quot;, only available for SMACOF objects $fit): Combines the configuration plot with the point stress contribution. The larger the bubbles, the better the fit.
</p>
</li></ul>

<p>#@importFrom smacofx plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
set.seed(1)
resl&lt;-copstressMin(dis,itmax=500)
plot(resl)
</code></pre>

<hr>
<h2 id='plot.pcops'>S3 plot method for p-cops objects</h2><span id='topic+plot.pcops'></span>

<h3>Description</h3>

<p>S3 plot method for p-cops objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcops'
plot(x, plot.type, main, asp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pcops_+3A_x">x</code></td>
<td>
<p>an object of class cops</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_plot.type">plot.type</code></td>
<td>
<p>String indicating which type of plot to be produced: can be one of &quot;confplot&quot;, &quot;reachplot&quot;, &quot;resplot&quot;, &quot;transplot&quot;, &quot;Shepard&quot;, &quot;stressplot&quot;, &quot;bubbleplot&quot;, &quot;histogram&quot; *see plot.smacofP, plot.smacofB and plot.copsc). Note that not all plots might be available for all losses.</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of x/y axis; defaults to 1; setting to 1 will lead to an accurate represenation of the fitted distances.</p>
</td></tr>
<tr><td><code id="plot.pcops_+3A_...">...</code></td>
<td>
<p>Further plot arguments passed: see 'plot.smacofP', 'plot.smacofB' and 'plot' for detailed information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See plot.smacofP
</p>
<p>#@importFrom smacofx plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dis&lt;-as.matrix(smacof::kinshipdelta)
resl&lt;-pcops(dis,loss="stress",lower=0.1,upper=5,minpts=2)
plot(resl,plot.type="confplot")
plot(resl,plot.type="reachplot")
plot(resl,plot.type="Shepard")
plot(resl,plot.type="transplot")
plot(resl,plot.type="stressplot")
plot(resl,plot.type="bubbleplot")
plot(resl,plot.type="histogram")
</code></pre>

<hr>
<h2 id='procruster'>procruster: a procrustes function</h2><span id='topic+procruster'></span>

<h3>Description</h3>

<p>procruster: a procrustes function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procruster(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procruster_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='scale_adjust'>Adjusts a configuration</h2><span id='topic+scale_adjust'></span>

<h3>Description</h3>

<p>Adjusts a configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_adjust(conf, ref, scale = c("sd", "std", "proc", "none"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_adjust_+3A_conf">conf</code></td>
<td>
<p>a configuration</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_ref">ref</code></td>
<td>
<p>a reference configuration (only for scale=&quot;proc&quot;)</p>
</td></tr>
<tr><td><code id="scale_adjust_+3A_scale">scale</code></td>
<td>
<p>Scale adjustment. &quot;std&quot; standardizes each column of the configurations to mean=0 and sd=1, &quot;sd&quot; scales the configuration by the maximum standard devation of any column, &quot;proc&quot; adjusts the fitted configuration to the reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scale adjusted configuration.
</p>

<hr>
<h2 id='secularEq'>Secular Equation</h2><span id='topic+secularEq'></span>

<h3>Description</h3>

<p>Secular Equation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secularEq(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="secularEq_+3A_a">a</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="secularEq_+3A_b">b</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='spp'>Calculating stress per point</h2><span id='topic+spp'></span>

<h3>Description</h3>

<p>Calculating stress per point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp(dhat, confdist, weightmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spp_+3A_dhat">dhat</code></td>
<td>
<p>a dist object or symmetric matrix of dissimilarities</p>
</td></tr>
<tr><td><code id="spp_+3A_confdist">confdist</code></td>
<td>
<p>a dist object or symmetric matrix of fitted distances</p>
</td></tr>
<tr><td><code id="spp_+3A_weightmat">weightmat</code></td>
<td>
<p>dist objetc or symmetric matrix of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='sqdist'>Squared distances</h2><span id='topic+sqdist'></span>

<h3>Description</h3>

<p>Squared distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdist(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqdist_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared distance matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
