<!DOCTYPE html><html lang="en-US"><head><title>Help for package iGraphMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iGraphMatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#iGraphMatch-package'><p>iGraphMatch: Tools for Graph Matching</p></a></li>
<li><a href='#+25+2A+25+2CgraphMatch+2CANY-method'><p>Operator methods for graphMatch objects</p></a></li>
<li><a href='#as.character.splrMatrix'><p>splr &quot;Matrix&quot; as character</p></a></li>
<li><a href='#as.data.frame+2CgraphMatch-method'><p>Methods for the graphMatch class</p></a></li>
<li><a href='#best_matches'><p>Rank best matches</p></a></li>
<li><a href='#C.Elegans'><p>Chemical synapses and electrical synapses networks of roundworm</p></a></li>
<li><a href='#center_graph'><p>Center adjacency matrix</p></a></li>
<li><a href='#check_graph'><p>Parameter checking for a graph-pair</p></a></li>
<li><a href='#check_seeds'><p>Standardize seeds input data type</p></a></li>
<li><a href='#check_sim'><p>Check the similarity matrix passed to a matching function</p></a></li>
<li><a href='#do_lap'><p>Linear (sum) assignment problem</p></a></li>
<li><a href='#Enron'><p>Email communication networks of Enron Corporation</p></a></li>
<li><a href='#get_perm_mat'><p>Get Permutation</p></a></li>
<li><a href='#gm'><p>Graph Matching Methods</p></a></li>
<li><a href='#graph_match_convex'><p>Frank-Wolfe Graph Matching Methods</p></a></li>
<li><a href='#graph_match_IsoRank'><p>Spectral Graph Matching Methods: IsoRank Algorithm</p></a></li>
<li><a href='#graph_match_percolation'><p>Percolation Graph Matching Methods</p></a></li>
<li><a href='#graph_match_Umeyama'><p>Spectral Graph Matching Methods: Umeyama Algorithm</p></a></li>
<li><a href='#graphMatch-class'><p>Graph matching results class</p></a></li>
<li><a href='#init_start'><p>Initialization of the start matrix</p></a></li>
<li><a href='#innerproduct'><p>Matrix inner products</p></a></li>
<li><a href='#lapjv'><p>Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant</p></a></li>
<li><a href='#largest_common_cc'><p>Find the largest common connected subgraph (LCCS) of two graphs</p></a></li>
<li><a href='#matrix_list-class'><p>Lists of Matrices</p></a></li>
<li><a href='#pad'><p>Pad a matrix object with extra rows/columns of 0s.</p></a></li>
<li><a href='#plot+2Cigraph+2Cigraph-method'><p>Plotting methods for visualizing matches</p></a></li>
<li><a href='#sample_correlated_gnp_pair'><p>Sample correlated G(n,p) random graphs</p></a></li>
<li><a href='#sample_correlated_ieg_pair'><p>Sample graphs from edge probability matrix and correlation matrix</p></a></li>
<li><a href='#sample_correlated_sbm_pair'><p>Sample graphs pair from stochastic block model</p></a></li>
<li><a href='#show+2CsplrMatrix-method'><p>&quot;SPLR&quot; Methods</p></a></li>
<li><a href='#split_igraph'><p>Split an igraph object into aligned graphs by attribute</p></a></li>
<li><a href='#splr_sparse_plus_constant'><p>Add a constant to a splrMatrix object</p></a></li>
<li><a href='#splr_to_sparse'><p>Convert splr &quot;Matrix&quot; to Sparse</p></a></li>
<li><a href='#splrMatrix-class'><p>Sparse Plus Low-Rank Matrices</p></a></li>
<li><a href='#summary+2CgraphMatch-method'><p>Summary methods for graphMatch objects</p></a></li>
<li><a href='#Transportation'><p>Britain Transportation Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Graph Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Versatile tools and data for graph matching analysis with various forms of prior information
    that supports working with 'igraph' objects, matrix objects, or lists of either.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dpmcsuss/iGraphMatch">https://github.com/dpmcsuss/iGraphMatch</a>,
<a href="https://dpmcsuss.github.io/iGraphMatch/">https://dpmcsuss.github.io/iGraphMatch/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clue (&ge; 0.3-54), Matrix (&ge; 1.6-2), igraph (&ge; 2.0.0), irlba,
methods, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, dplyr (&ge; 0.5.0), testthat (&ge; 2.0.0), knitr,
rmarkdown, ggplot2, purrr, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dpmcsuss/iGraphMatch/issues">https://github.com/dpmcsuss/iGraphMatch/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 18:58:56 UTC; dsussman</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Sussman [aut, cre],
  Zihuan Qiao [aut],
  Joshua Agterberg [ctb],
  Lujia Wang [ctb],
  Vince Lyzinski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Sussman &lt;sussman@bu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 19:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='iGraphMatch-package'>iGraphMatch: Tools for Graph Matching</h2><span id='topic+iGraphMatch'></span><span id='topic+iGraphMatch-package'></span>

<h3>Description</h3>

<p>Versatile tools and data for graph matching analysis with various forms of prior information that supports working with 'igraph' objects, matrix objects, or lists of either.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel Sussman <a href="mailto:sussman@bu.edu">sussman@bu.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Zihuan Qiao <a href="mailto:zhqiao@bu.edu">zhqiao@bu.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Joshua Agterberg [contributor]
</p>
</li>
<li><p> Lujia Wang [contributor]
</p>
</li>
<li><p> Vince Lyzinski [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dpmcsuss/iGraphMatch">https://github.com/dpmcsuss/iGraphMatch</a>
</p>
</li>
<li> <p><a href="https://dpmcsuss.github.io/iGraphMatch/">https://dpmcsuss.github.io/iGraphMatch/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dpmcsuss/iGraphMatch/issues">https://github.com/dpmcsuss/iGraphMatch/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+2A+25+2CgraphMatch+2CANY-method'>Operator methods for graphMatch objects</h2><span id='topic++25+2A+25+2CgraphMatch+2CANY-method'></span><span id='topic++25+2A+25+2CANY+2CgraphMatch-method'></span><span id='topic++25+2A+25+2CgraphMatch+2CMatrix-method'></span><span id='topic++25+2A+25+2CMatrix+2CgraphMatch-method'></span><span id='topic++25+2A+25+2CgraphMatch+2Cigraph-method'></span><span id='topic++25+2A+25+2Cigraph+2CgraphMatch-method'></span>

<h3>Description</h3>

<p>Methods to use <a href="#topic+graphMatch">graphMatch</a> objects as operators on
igraph and matrix-like objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'graphMatch,ANY'
x %*% y

## S4 method for signature 'ANY,graphMatch'
x %*% y

## S4 method for signature 'graphMatch,Matrix'
x %*% y

## S4 method for signature 'Matrix,graphMatch'
x %*% y

## S4 method for signature 'graphMatch,igraph'
x %*% y

## S4 method for signature 'igraph,graphMatch'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B2A+2B25+2B2CgraphMatch+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>Either graphMatch object or a matrix-like object</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B25+2B2CgraphMatch+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>Either graphMatch object or a matrix-like object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These methods return an object of the same type
as the non-graphMatch object. If m is the match of g1
to g2 (both igraph objects), then m 
permuted so as to match with g1. Conversely, g1 
returns g1 permuted so as to match with g2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2

# match g1 &amp; g2 using FW methodology with indefinite relaxation
match &lt;- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')

# permute the second graph according to the match result: P %*% g2 %*% P^T
match %*% g2 # return an igraph object
# equivalent to the matrix operation
match[] %*% g2[] %*% t(match[])

match %*% g2[] # return a matrix
# equivalent to:
P &lt;- match[]
P %*% g2[] %*% Matrix::t(P)

# the inverse operations are performed via right multiplication
all(g1[] %*% match == t(P) %*% g1[] %*% P)


</code></pre>

<hr>
<h2 id='as.character.splrMatrix'>splr &quot;Matrix&quot; as character</h2><span id='topic+as.character.splrMatrix'></span>

<h3>Description</h3>

<p>splr &quot;Matrix&quot; as character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splrMatrix'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.splrMatrix_+3A_x">x</code></td>
<td>
<p>splrMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character output of splr matrix
</p>

<hr>
<h2 id='as.data.frame+2CgraphMatch-method'>Methods for the graphMatch class</h2><span id='topic+as.data.frame+2CgraphMatch-method'></span><span id='topic+show+2CgraphMatch-method'></span><span id='topic+print+2CgraphMatch-method'></span><span id='topic++5B+2CgraphMatch+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+dim+2CgraphMatch-method'></span><span id='topic+length+2CgraphMatch-method'></span><span id='topic+t+2CgraphMatch-method'></span><span id='topic+rev+2CgraphMatch-method'></span><span id='topic++5B+2CgraphMatch+2CANY+2CANY+2CANY-method'></span><span id='topic+str+2CgraphMatch-method'></span><span id='topic++24+2CgraphMatch-method'></span>

<h3>Description</h3>

<p>These methods provide functionality to view, inspect, and
convert <a href="#topic+graphMatch">graphMatch</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'graphMatch'
as.data.frame(x)

## S4 method for signature 'graphMatch'
show(object)

## S4 method for signature 'graphMatch'
print(x)

## S4 method for signature 'graphMatch,missing,missing,missing'
x[i = NULL, j = NULL, drop = NULL]

## S4 method for signature 'graphMatch'
dim(x)

## S4 method for signature 'graphMatch'
length(x)

## S4 method for signature 'graphMatch'
t(x)

## S4 method for signature 'graphMatch'
rev(x)

## S4 method for signature 'graphMatch,ANY,ANY,ANY'
x[i = NULL, j = NULL, drop = NULL]

## S4 method for signature 'graphMatch'
str(object)

## S4 method for signature 'graphMatch'
x$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_x">x</code></td>
<td>
<p>graphMatch object</p>
</td></tr>
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_object">object</code></td>
<td>
<p>graphMatch object</p>
</td></tr>
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_i">i</code></td>
<td>
<p>row index for the correspondence data.frame</p>
</td></tr>
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_j">j</code></td>
<td>
<p>col index for the correspondence data.frame</p>
</td></tr>
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_drop">drop</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame+2B2CgraphMatch-method_+3A_name">name</code></td>
<td>
<p>name of element in the list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for the graphMatch class
</p>


<h3>Value</h3>

<p><code>dim</code> returns a vector of length two indicating the number of
vertices in each original graph. <code>length</code> returns the number of found
vertex-pair matches. <code>m[i,j]</code> will index the 2 x length data.frame of
vertex-pair matches. This is true for any i,j unless both are missing. In
that case, <code>m[]</code> returns a sparse matrix of dimension dim(m) where
<code>m[][i,j]</code> is 0 unless m matches node i with node j. (Note this is not
guaranteed to be a permutation matrix unless <code>dim(m)[1] = dim(m)[2] =
  length(m)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot+2Cigraph+2Cigraph-method">graphMatch_plot</a>, <a href="#topic++25+2A+25+2CgraphMatch+2CANY-method">graphMatch_operators</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample a pair of correlated random graphs from G(n,p)
set.seed(123)
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2

# match g1 &amp; g2 using FW methodology with indefinite relaxation
match &lt;- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')

# print graphMatch object
match
print(match)
show(match)

# print matching correspondence
match$corr_A # matching correspondence in the first graph
match$corr_B # matching correspondence in the second graph

# get nonseed matching correspondence
match[!match$seeds]

# create graphMatch object from a vector
as.graphMatch(sample(10))
# or data.frame
as.graphMatch(data.frame(a = 1:10, b = sample(1000, 10)))

# get corresponding permutation matrix for the match result
match[] # preferred approach
# or equivalently
get_perm_mat(match)


# sizes of two graphs
dim(match)

# number of matched node pairs
length(match)


# reverse the matching correspondence between two graphs
t(match)
rev(match)
</code></pre>

<hr>
<h2 id='best_matches'>Rank best matches</h2><span id='topic+best_matches'></span>

<h3>Description</h3>

<p>Rank vertex-pairs in  order of a goodness of matching metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_matches(A, B, match, measure, num = NULL, true_label = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_matches_+3A_a">A</code></td>
<td>
<p>A matrix, an <code>igraph</code> object, or a list of either.
See <a href="#topic+check_graph">check_graph</a></p>
</td></tr>
<tr><td><code id="best_matches_+3A_b">B</code></td>
<td>
<p>A matrix, an <code>igraph</code> object, or a list of either.
See <a href="#topic+check_graph">check_graph</a></p>
</td></tr>
<tr><td><code id="best_matches_+3A_match">match</code></td>
<td>
<p><a href="#topic+graphMatch">graphMatch</a>, eg result of call to <a href="#topic+gm">gm</a></p>
</td></tr>
<tr><td><code id="best_matches_+3A_measure">measure</code></td>
<td>
<p>One of &quot;row_cor&quot;, &quot;row_diff&quot;, or &quot;row_perm_stat&quot; or
a function (see details). Measure for computing goodness of matching.</p>
</td></tr>
<tr><td><code id="best_matches_+3A_num">num</code></td>
<td>
<p>A positive integer or NULL. Number of pairs of best matched
vertices needed. NULL indicates all matches.</p>
</td></tr>
<tr><td><code id="best_matches_+3A_true_label">true_label</code></td>
<td>
<p>the true correspondence (if available).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If measure is a function, it should take exactly two matrices or igraph
objects as arguments and return a vector of length equal to the number of nonseed nodes
in the first object. Smaller values will be taken to indicate better matches.
</p>


<h3>Value</h3>

<p><code>best_matches</code> returns a data frame with the indices of best
matched vertices in <code class="reqn">G_1</code> named <code>A_best</code>, the indices of best
matched vertices in <code class="reqn">G_2</code> named <code>B_best</code> and the values of measure
for best matches, where smaller values indicate better matches for all
measures. If the true correspondence is available, also returns the
precision of top n best matches, for each n &lt;= <code>num</code>.
</p>
<p><code>row_cor</code> takes 1 minus the row correlation value for the corresponding vertex.
<code>row_diff</code> takes the row difference value for each corresponding vertex.
<code>row_perm_stat</code> uses the row permutation statistics value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cgnp_pair &lt;- sample_correlated_gnp_pair(n = 50, corr =  0.5, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
seeds &lt;- 1:50 &lt;= 10
match &lt;- gm(g1, g2, seeds, method = "indefinite")

# Application: select best matched seeds from non seeds as new seeds, and do the
# graph matching iteratively to get higher matching accuracy
best_matches(A = g1, B = g2, match = match, measure = "row_perm_stat", num = 5, true_label = 1:50)


</code></pre>

<hr>
<h2 id='C.Elegans'>Chemical synapses and electrical synapses networks of roundworm</h2><span id='topic+C.Elegans'></span>

<h3>Description</h3>

<p>C.Elegans networks consist of the chemical synapses network and the
electrical synapses network of the roundworm, where each of 279 nodes
represents a neuron and each edge represents the intensity of synapses
connections between two neurons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C.Elegans)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Details</h3>

<p>Two networks are weighted and directed graphs with self-loops.
There are 2194 and 1031 edges in two graphs respectively and the empirical
Pearson's correlation between two graphs is 0.17.
Two networks are stored in a list in the form of igraph objects, where
the first network in the list is the chemical synapses network and the
other one is the electrical synapses network.
</p>


<h3>References</h3>

<p>Chen, L., Vogelstein, J. T., Lyzinski, V., &amp; Priebe, C. E.
(2016). <em>A joint graph inference case study: the C. elegans chemical
and electrical connectomes.</em> Worm, 5(2), e1142041.
</p>
<p>Sulston, J. E., Schierenberg, E., White, J. G., &amp; Thomson, J.N. (1983).
<em>The embryonic cell lineage of the nematode caenorhabditis
elegans.</em> Developmental biology, 100(1):64â€“119.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(C.Elegans)
g1 &lt;- C.Elegans[[1]]
g2 &lt;- C.Elegans[[2]]
plot(g1, g2)

</code></pre>

<hr>
<h2 id='center_graph'>Center adjacency matrix</h2><span id='topic+center_graph'></span>

<h3>Description</h3>

<p>Center the adjacency matrix by re-weighting edges according to a specified scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_graph(A, scheme = c(-1, 1), use_splr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_graph_+3A_a">A</code></td>
<td>
<p>A matrix, an igraph object. Adjacency matrix.</p>
</td></tr>
<tr><td><code id="center_graph_+3A_scheme">scheme</code></td>
<td>
<p>A character vector, number or pair of numbers. Default <code>c(-1, 1)</code>. See Details.</p>
</td></tr>
<tr><td><code id="center_graph_+3A_use_splr">use_splr</code></td>
<td>
<p>A boolean indicating whether to use the <a href="#topic+splr">splrMatrix</a> object when storing the
centered graph.  Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options for scheme are
</p>

<ul>
<li><p> &quot;naive&quot; Returns original A
</p>
</li>
<li><p> Integer: Returns <code class="reqn">A - A_{scheme}</code> where
<code class="reqn">A_{scheme}</code> is the best rank-scheme approximation
of A.
</p>
</li>
<li><p> A pair of scalars: Returns s * A + a such that the
minimum of the returned matrix is min(scheme) and the
maximum is max(scheme).
</p>
</li>
<li><p> &quot;center&quot;: Same as <code>scheme=c(-1,1)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>centered adjacency matrix as a <a href="#topic+splr">splrMatrix</a> if
useSplr = TRUE, otherwise as a Matrix object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- sample_correlated_gnp_pair(n = 10, corr = .5, p = .5)$graph1
center_graph(A, scheme = "naive")
center_graph(A, scheme = "center")
center_graph(A, scheme = 2)
center_graph(A, scheme = c(-4, 2))

</code></pre>

<hr>
<h2 id='check_graph'>Parameter checking for a graph-pair</h2><span id='topic+check_graph'></span><span id='topic+check_single_graph'></span>

<h3>Description</h3>

<p>Function that checks that the pair of graphs passed
to a matching-related functions satisfies necessary conditions and modifies
them according to specified parameters. check_single_graph
does similar checks and modifications but just for one graph or list of graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_graph(
  A,
  B,
  same_order = TRUE,
  square = TRUE,
  as_list = TRUE,
  as_igraph = FALSE
)

check_single_graph(A, square = TRUE, as_list = TRUE, as_igraph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_graph_+3A_a">A</code></td>
<td>
<p>A matrix, an igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_b">B</code></td>
<td>
<p>A matrix, an igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_same_order">same_order</code></td>
<td>
<p>Whether the returned objects should have the same number of nodes.
If the graphs start with different numbers of nodes the smaller graph is padded with
isolated vertices. (default = TRUE)</p>
</td></tr>
<tr><td><code id="check_graph_+3A_square">square</code></td>
<td>
<p>Whether the matrices need to be square. (default = TRUE)
Currently non-square matrices are not supported.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_as_list">as_list</code></td>
<td>
<p>Whether to return the results as a matrix_list. (default = TRUE)
If FALSE and A and B have length &gt; 1</p>
</td></tr>
<tr><td><code id="check_graph_+3A_as_igraph">as_igraph</code></td>
<td>
<p>Whether to return an igraph object. (default=FALSE)
Only allowed if the original parameters are igraph objects.
If FALSE, then this converts the objects to sparse matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If A and B are lists of matrices or igraph objects, then the lists
must be the same length. Additionally, within each list the graphs need to have the
same number of vertices but this does not need to be true across lists.
</p>


<h3>Value</h3>

<p>List containing A and B modified according to the parameters and the number of 
vertices in each graph in totv1 and totv2.
</p>

<hr>
<h2 id='check_seeds'>Standardize seeds input data type</h2><span id='topic+check_seeds'></span>

<h3>Description</h3>

<p>Convert the input seeds data into data frame type with the first column being the
indices of <code class="reqn">G_1</code> and the second column being the corresponding indices of <code class="reqn">G_2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_seeds(seeds, nv, logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_seeds_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. Input in the form of a
vector of integers denotes the indices of seeds which are identical in both graphs. Input in the
form of a vector of logicals indicate the location of seeds with TRUE and the indices of seeds
are identical in both graphs. Input in the form of a matrix or a data frame, with the first
column being the indices of <code class="reqn">G_1</code> and the second
column being the corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="check_seeds_+3A_nv">nv</code></td>
<td>
<p>An integer. Number of total vertices.</p>
</td></tr>
<tr><td><code id="check_seeds_+3A_logical">logical</code></td>
<td>
<p>A logical. TRUE indicates to return seeds in a vector of logicals where TRUE
indicates the corresponding vertex is a seed. FALSE indicates to return a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with the first column being the corresponding indices of
<code class="reqn">G_1</code> and the second column being the corresponding indices of <code class="reqn">G_2</code> or a vector of
logicals where TRUE indicates the corresponding vertex is a seed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#input is a vector of logicals
check_seeds(1:10 &lt;= 3, nv = 10)

#input is a vector of integers
check_seeds(c(1,4,2,7,3), nv = 10)

#input is a matrix
check_seeds(matrix(1:4,2), nv = 10)

#input is a data frame
check_seeds(as.data.frame(matrix(1:4,2)), nv = 10)

</code></pre>

<hr>
<h2 id='check_sim'>Check the similarity matrix passed to a matching function</h2><span id='topic+check_sim'></span>

<h3>Description</h3>

<p>Internal function that checks that a similarity matrix satisfies
necessary conditions and modifies it for use in graph matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sim(sim, seeds, nonseeds, totv1, totv2, for_nonseeds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_sim_+3A_sim">sim</code></td>
<td>
<p>Similarity matrix</p>
</td></tr>
<tr><td><code id="check_sim_+3A_seeds">seeds</code></td>
<td>
<p>dataframe of seed matches from running <a href="#topic+check_seeds">check_seeds</a></p>
</td></tr>
<tr><td><code id="check_sim_+3A_nonseeds">nonseeds</code></td>
<td>
<p>dataframe of nonseed nodes from running <a href="#topic+check_seeds">check_seeds</a></p>
</td></tr>
<tr><td><code id="check_sim_+3A_totv1">totv1</code></td>
<td>
<p>total number of vertices in the first graph</p>
</td></tr>
<tr><td><code id="check_sim_+3A_totv2">totv2</code></td>
<td>
<p>total number of vertices in the second graph</p>
</td></tr>
<tr><td><code id="check_sim_+3A_for_nonseeds">for_nonseeds</code></td>
<td>
<p>Whether the similarities are between non-seed nodes only (default = TRUE), or 
if similarities among seed nodes are included (FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal here is to be flexible in terms of the dimensions of the similarity matrix
passed to <a href="#topic+gm">gm</a>. This is useful when the graphs have different orders in which case
the function accepts matrices with dimensions equal to that of orders of the original graphs
or the number of nonseeds.
</p>


<h3>Value</h3>

<p>Standardized similarity matrix for similarities only between nonseeds across
the two graphs, if for_nonseeds = TRUE, or between all nodes, if for_nonseeds = FALSE
</p>

<hr>
<h2 id='do_lap'>Linear (sum) assignment problem</h2><span id='topic+do_lap'></span>

<h3>Description</h3>

<p>Compute the best bipartite matching
using one of three methods. For an n x n score matrix it find
<code class="reqn">\max_{v\in \Pi_n} \sum_{i=1}^n score_{i, v(i)}</code>
where <code class="reqn">\Pi_n</code> denotes all permutations on n objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_lap(score, method = "clue")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_lap_+3A_score">score</code></td>
<td>
<p>matrix of pairwise scores</p>
</td></tr>
<tr><td><code id="do_lap_+3A_method">method</code></td>
<td>
<p>One of &quot;lapjv&quot;, &quot;lapmod&quot;, or &quot;clue&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves a linear assignment using one of three methods.
&quot;clue&quot; uses <code>solve_lsap</code> from the clue package.
&quot;lapjv&quot; uses the Jonker-Volgenaut approach implemented in this package.
&quot;lapmod&quot; use a modification of JV that exploits sparsity in the score matrix.
</p>
<p>Scores do not need to be non-negative. For &quot;clue&quot; the scores are pre-translated to be
non-negative which preserves the LAP solution.
</p>


<h3>Value</h3>

<p><code>do_lap</code> returns a vector which indicates the
best matching column for each row.
</p>


<h3>References</h3>

<p>R. Jonker, A. Volgenant (1987). <em>A shortest augmenting path algorithm
for dense and sparse linear assignment problems</em>. Computing, pages 325-340.
</p>
<p>A. Volgenant (1996). <em>Linear and Semi-Assignment Problems: A
Core Oriented Approach</em>. Computer Ops Res., pages 917-932.
</p>
<p>C. H. Papadimitriou and K. Steiglitz (1998). <em>Combinatorial Optimization:
Algorithms and Complexity</em>. Courier Corporation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
cost &lt;- Matrix::rsparsematrix(10, 10, .5)
cbind(
 do_lap(cost, "lapjv"),
 do_lap(cost, "lapmod"),
 do_lap(cost, "clue")
)

</code></pre>

<hr>
<h2 id='Enron'>Email communication networks of Enron Corporation</h2><span id='topic+Enron'></span>

<h3>Description</h3>

<p>The Enron network data consists of email messages between 184 employees
of the Enron Corporation where each graph represents one week of emails
and each edge indicates whether there is email sent from one employee to
the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Enron)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Details</h3>

<p>Two networks are unweighted and directed with self-loops.
There are 488 and 482 edges in two networks respectively and the empirical
Pearson's correlation between two graphs is 0.85.
Two email communication networks for two different weeks are stored in a
list in the form of igraph objects.
</p>


<h3>References</h3>

<p>Originally released by William Cohen at CMU. <a href="http://www.cs.cmu.edu/~enron/">More details</a>
on the origins and research uses of the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Enron)
g1 &lt;- Enron[[1]]
g2 &lt;- Enron[[2]]
plot(g1, g2)

</code></pre>

<hr>
<h2 id='get_perm_mat'>Get Permutation</h2><span id='topic+get_perm_mat'></span>

<h3>Description</h3>

<p>Get an <code>m-by-n</code> permutation matrix according to the mapping
correspondence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_perm_mat(match, dim = NULL, padded = FALSE, seeds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_perm_mat_+3A_match">match</code></td>
<td>
<p>Either a graphMatch object or 2-column matrix or data frame.
The first and second columns correspond to indices in <code class="reqn">G_1</code> and 
<code class="reqn">G_2</code> respectively.</p>
</td></tr>
<tr><td><code id="get_perm_mat_+3A_dim">dim</code></td>
<td>
<p>desired dimensions of the matrix. Note, this does not
have to be square. If NULL and match is a graphMatch object then
dim is set to dim(match)</p>
</td></tr>
<tr><td><code id="get_perm_mat_+3A_padded">padded</code></td>
<td>
<p>If FALSE then this returns a square matrix the size of
the larger of the two graph otherwise dim = dim(match). This is 
ignored if match is not a graphMatch object.</p>
</td></tr>
<tr><td><code id="get_perm_mat_+3A_seeds">seeds</code></td>
<td>
<p>Whether to keep the seed vertices (TRUE) from the match
or to remove them (FALSE). Ignored if match is not a graphMatch object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_perm_mat</code> returns an <code>m-by-n</code> sparse permutation matrix or whose
submatrix is a permutation matrix if only parts of nodes from both graphs get
matched or in the case of matching graphs of different order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns a permutation matrix: m=n, all the nodes get matched
corr &lt;- data.frame(corr_A = c(1,2,3,4), corr_B = c(1,4,2,3))
get_perm_mat(corr, c(4, 4))

# submatrix is a permutation matrix: parts of graphs get matched
get_perm_mat(corr, c(5, 6))

</code></pre>

<hr>
<h2 id='gm'>Graph Matching Methods</h2><span id='topic+gm'></span>

<h3>Description</h3>

<p><code>gm</code> is used to match a pair of given graphs, with
specifications of the adjacency matrices of for a pair of graphs, possible
prior knowledge, and a graph matching method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm(A, B, seeds = NULL, similarity = NULL, method = "indefinite", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gm_+3A_a">A</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="gm_+3A_b">B</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="gm_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be a matrix or a data frame, with the first
column being the indices of <code class="reqn">G_1</code> and the second column being the
corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="gm_+3A_similarity">similarity</code></td>
<td>
<p>A matrix. An <code>n-by-n</code> matrix containing vertex
similarities. Mandatory for the &quot;IsoRank&quot; method.</p>
</td></tr>
<tr><td><code id="gm_+3A_method">method</code></td>
<td>
<p>Choice for graph matching methods. One of &quot;indefinite&quot;,
&quot;convex&quot;, &quot;PATH&quot;, &quot;percolation&quot;, &quot;IsoRank&quot;, &quot;Umeyama&quot;, or a user-defined
graph matching function. Please check Details and Examples sections for
instructions on how to define your own function.</p>
</td></tr>
<tr><td><code id="gm_+3A_...">...</code></td>
<td>
<p>Arguments passed to graph matching methods. Please refer to
Details section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is a function, it should take two matrices or
igraph objects, seeds and similarity scores as arguments for minimum.
Additionally, it can also take other arguments if needed. The self-defined
function should return a graphMatch class object with matching
correspondence, sizes of two input graphs, matching formula, and other
algorithm hyperparameter details.
</p>
<p>The <code>method</code> argument can also take one of the implemented algorithms,
including <a href="#topic+graph_match_indefinite">&quot;indefinite&quot;</a>,
<a href="#topic+graph_match_convex">&quot;convex&quot;</a>, <a href="#topic+graph_match_PATH">&quot;PATH&quot;</a>,
<a href="#topic+graph_match_percolation">&quot;percolation&quot;</a>, <a href="#topic+graph_match_IsoRank">&quot;IsoRank&quot;</a>,
and <a href="#topic+graph_match_Umeyama">&quot;Umeyama&quot;</a>.
In this case, one can pass additional arguments to the <code>gm</code> function
according to the specified method.
For a detailed list of additional arguments for each one of the implemented method,
please click on the corresponding method name for its help page.
</p>
<p>Most graph matching functions include as list elements additional details
about the match. Call <code>names()</code> on a <code>graphMatch</code> object to see
the available details. As an example, PATH, IsoRank, Umeyama, Indefinite,
and Convex each include <code>soft</code>, which is the matrix found by the
algorithm prior to projection onto the set of permutation matrices.
Similarly, PATH, Indefinite, and Convex return <code>iter</code>, the number of
iterations, and IsoRank (with greedy LAP) and Percolation return
<code>match_order</code>, the order that the node-pairs were added to the match.
</p>


<h3>Value</h3>

<p><code>gm</code> returns an object of class &quot;<code><a href="#topic+graphMatch">graphMatch</a></code>&quot;.
See <a href="#topic+graphMatch-class">graphMatch-class</a> and links therein for details
on the <code>graphMatch</code> class.
</p>
<p>Please also refer to the help page for each implemented method, i.e.
<a href="#topic+graph_match_indefinite">&quot;indefinite&quot;</a>,
<a href="#topic+graph_match_convex">&quot;convex&quot;</a>,
<a href="#topic+graph_match_PATH">&quot;PATH&quot;</a>,
<a href="#topic+graph_match_percolation">&quot;percolation&quot;</a>,
<a href="#topic+graph_match_IsoRank">&quot;IsoRank&quot;</a>,
and <a href="#topic+graph_match_Umeyama">&quot;Umeyama&quot;</a>
for details on the corresponding returned list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># match G_1 &amp; G_2 with some known node pairs as seeds
set.seed(123)
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.5, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
seeds &lt;- 1:10 &lt;= 4

m_rds &lt;- gm(g1, g2, seeds, method = "indefinite", start = "rds", max_iter = 20)
summary(m_rds, g1, g2, true_label = 1:10)


# match two multi-layer graphs
set.seed(123)
gp_list &lt;- replicate(3, sample_correlated_gnp_pair(20, .3, .5), simplify = FALSE)
A &lt;- lapply(gp_list, function(gp)gp[[1]])
B &lt;- lapply(gp_list, function(gp)gp[[2]])

m_perco &lt;- gm(A, B, seeds, method = "percolation", ExpandWhenStuck = FALSE)
summary(m_perco, A, B)

sim &lt;- as.matrix(init_start(start = "bari", nns = 20, soft_seeds = 1:5))
m_Iso &lt;- gm(A, B, similarity = sim, method = "IsoRank", lap_method = "greedy")
summary(m_Iso, A, B)

# customized graph matching algorithm
graph_match_rand &lt;- function(A, B, seeds = NULL, similarity = NULL, rand_seed){
  nm &lt;- min(nrow(A), nrow(B))
  set.seed(rand_seed)
  m &lt;- data.frame(sample(nrow(A), nm), corr_B = sample(nrow(B), nm))
  m &lt;- as.graphMatch(m)
  m$rand_seed &lt;- rand_seed
  m
}

m_self &lt;- gm(g1, g2, method = graph_match_rand, rand_seed = 123)
summary(m_self, g1, g2)

</code></pre>

<hr>
<h2 id='graph_match_convex'>Frank-Wolfe Graph Matching Methods</h2><span id='topic+graph_match_convex'></span><span id='topic+graph_match_indefinite'></span><span id='topic+graph_match_PATH'></span>

<h3>Description</h3>

<p>Match two given graphs, returns a list of graph matching
results, including matching correspondence vector of <code class="reqn">G_2</code> with respect
to <code class="reqn">G_1</code>, doubly stochastic matrix and permutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_match_convex(
  A,
  B,
  seeds = NULL,
  similarity = NULL,
  start = "bari",
  max_iter = 100,
  tol = 1e-05,
  lap_method = NULL
)

graph_match_indefinite(
  A,
  B,
  seeds = NULL,
  similarity = NULL,
  start = "bari",
  max_iter = 20,
  lap_method = NULL
)

graph_match_PATH(
  A,
  B,
  seeds = NULL,
  similarity = NULL,
  epsilon = 1,
  tol = 1e-05,
  max_iter = 20,
  lap_method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_match_convex_+3A_a">A</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_b">B</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be  a matrix or a data frame, with the first
column being the indices of <code class="reqn">G_1</code> and the second column being the
corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_similarity">similarity</code></td>
<td>
<p>A matrix. An <code>n-by-n</code> matrix containing vertex similarities.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_start">start</code></td>
<td>
<p>A matrix or a character. Any <code>nns-by-nns</code> matrix or
character value like &quot;bari&quot;, &quot;rds&quot; or &quot;convex&quot; to initialize the starting matrix.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_max_iter">max_iter</code></td>
<td>
<p>A number. Maximum number of replacing matches.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_tol">tol</code></td>
<td>
<p>A number. Tolerance of edge disagreements.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_lap_method">lap_method</code></td>
<td>
<p>Choice for lap method. One of &quot;lapjv&quot;, &quot;lapmod&quot;, or &quot;clue&quot;.</p>
</td></tr>
<tr><td><code id="graph_match_convex_+3A_epsilon">epsilon</code></td>
<td>
<p>A small number</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>graph_match_indefinite</code>, <code>graph_match_convex</code> and <code>graph_match_PATH</code>
return an object of class &quot;<code><a href="#topic+graphMatch">graphMatch</a></code>&quot; which is a list containing the following
components:
</p>

<dl>
<dt>corr_A</dt><dd><p>matching correspondence in <code class="reqn">G_1</code></p>
</dd>
<dt>corr_B</dt><dd><p>matching correspondence in <code class="reqn">G_2</code></p>
</dd>
<dt>soft</dt><dd><p>the doubly stochastic matrix from the last iteration with which one can
extract more than one matching candidates</p>
</dd>
<dt>iter</dt><dd><p>number of iterations until convergence or reaches the <code>max_iter</code></p>
</dd>
<dt>max_iter</dt><dd><p>Maximum number of replacing matches</p>
</dd>
<dt>lap_method</dt><dd><p>Choice for solving the LAP</p>
</dd>
<dt>seeds</dt><dd><p>a vector of logicals indicating if the corresponding vertex is a seed</p>
</dd>
</dl>



<h3>References</h3>

<p>Y. Aflalo and A. Bronstein and R. Kimmel (2014), <em>On convex
relaxation of graph isomorphism</em>. Proceedings of the National Academy of Sciences,
pages 2942-2947.
</p>
<p>V. Lyzinski and D. E. Fishkind and M. Fiori and J. T. Vogelstein and C. E. Priebe
and G. Sapiro (2016), <em>Graph Matching: Relax at Your Own Risk</em>. IEEE TPAMI, pages 60-73.
</p>
<p>V. Lyzinski and D. E. Fishkind and C. E. Priebe (2014), <em>Seeded Graph Matching
for Correlated Erdos-Renyi Graphs</em>.J. Mach. Learn. Res., pages 3513-3540.
</p>
<p>M. Zaslavskiy, F. Bach and J. Vert (2009), <em>A Path following
algorithm for the graph matching problem</em>. IEEE Trans Pattern Anal Mach Intell,
pages 2227-2242.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.9, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
# match G_1 &amp; G_2 with no seeds
gm(g1, g2, method = "convex", max_iter = 10)
seeds &lt;- 1:10 &lt;= 3
gm(g1, g2, seeds, method = "convex", max_iter = 10)




# match G_1 &amp; G_2 with some known node pairs as seeds
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
seeds &lt;- 1:10 &lt;= 3
GM_bari &lt;- gm(g1, g2, seeds, method = "indefinite", start = "bari")
GM_bari
GM_bari[!GM_bari$seeds] # matching correspondence for non-seeds

summary(GM_bari, g1, g2, true_label = 1:10)

# match G_1 &amp; G_2 with some incorrect seeds
hard_seeds &lt;- matrix(c(4,6,5,4),2)
seeds &lt;- rbind(as.matrix(check_seeds(seeds, nv = 10)$seeds),hard_seeds)
GM_badseed &lt;- gm(g1, g2, seeds, method = "indefinite")

GM_badseed[] # get the corresponding permutation matrix
GM_badseed %*% g2 # permute the second graph according to match result: PBP^T
GM_badseed$soft # doubly stochastic matrix from the last step of Frank-Wolfe iterations
GM_badseed$iter # number of iterations
GM_badseed$max_iter # preset maximum number of iterations: 20

# match two multi-layer graphs
gp_list &lt;- replicate(3, sample_correlated_gnp_pair(20, .3, .5), simplify = FALSE)
A &lt;- lapply(gp_list, function(gp)gp[[1]])
B &lt;- lapply(gp_list, function(gp)gp[[2]])

match_multi_layer &lt;- gm(A, B, seeds = 1:10, method = "indefinite", start = "bari", max_iter = 20)
summary(match_multi_layer, A, B)

# match G_1 &amp; G_2 using PATH algorithm
gm(g1, g2, method = "PATH")


</code></pre>

<hr>
<h2 id='graph_match_IsoRank'>Spectral Graph Matching Methods: IsoRank Algorithm</h2><span id='topic+graph_match_IsoRank'></span>

<h3>Description</h3>

<p>Spectral Graph Matching Methods: IsoRank Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_match_IsoRank(
  A,
  B,
  seeds = NULL,
  similarity,
  max_iter = 50,
  lap_method = "greedy"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_match_IsoRank_+3A_a">A</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_IsoRank_+3A_b">B</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_IsoRank_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be  a matrix
or a data frame, with the first column being the indices of <code class="reqn">G_1</code> and
the second column being the corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="graph_match_IsoRank_+3A_similarity">similarity</code></td>
<td>
<p>A matrix. An <code>n-by-n</code> matrix containing vertex similarities.</p>
</td></tr>
<tr><td><code id="graph_match_IsoRank_+3A_max_iter">max_iter</code></td>
<td>
<p>A number. Maximum number of replacing matches.</p>
</td></tr>
<tr><td><code id="graph_match_IsoRank_+3A_lap_method">lap_method</code></td>
<td>
<p>Choice of method to extract mapping from score matrix.
One of &quot;greedy&quot; or &quot;LAP&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>graph_match_IsoRank</code> returns an object of class &quot;<code><a href="#topic+graphMatch">graphMatch</a></code>&quot; which is a list
containing the following components:
</p>

<dl>
<dt>corr_A</dt><dd><p>matching correspondence in <code class="reqn">G_1</code></p>
</dd>
<dt>corr_B</dt><dd><p>matching correspondence in <code class="reqn">G_2</code></p>
</dd>
<dt>seeds</dt><dd><p>a vector of logicals indicating if the corresponding vertex is a seed</p>
</dd>
<dt>soft</dt><dd><p>the functional similarity score matrix obtained from the power method
with which one can extract more than one matching candidates</p>
</dd>
<dt>match_order</dt><dd><p>the order of vertices getting matched</p>
</dd>
<dt>lap_method</dt><dd><p>Method for extracting node mapping</p>
</dd>
</dl>



<h3>References</h3>

<p>R. Singh, J. Xu, B. Berger (2008), <em>Global alignment of
multiple protein interaction networks with application to functional
orthology detection</em>. Proceedings of the National Academy of Science. USA, pages 12763-12768.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
# match G_1 &amp; G_2 using IsoRank algorithm
startm &lt;- as.matrix(init_start(start = "bari", nns = 10, soft_seeds = 1:4))

GM_IsoRank &lt;- gm(g1, g2, similarity = startm, method = "IsoRank", lap_method = "greedy")
GM_IsoRank
summary(GM_IsoRank, g1, g2, true_label = 1:10)

GM_IsoRank[] # get the corresponding permutation matrix
GM_IsoRank %*% g2 # permute the second graph according to match result: PBP^T
GM_IsoRank %*% g2[] # output permuted matrix

# Visualize the edge-wise matching performance
plot(g1, g2, GM_IsoRank)
plot(g1[], g2[], GM_IsoRank)


</code></pre>

<hr>
<h2 id='graph_match_percolation'>Percolation Graph Matching Methods</h2><span id='topic+graph_match_percolation'></span>

<h3>Description</h3>

<p>Percolation Graph Matching Methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_match_percolation(
  A,
  B,
  seeds,
  similarity = NULL,
  r = 2,
  ExpandWhenStuck = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_match_percolation_+3A_a">A</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_percolation_+3A_b">B</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_percolation_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be  a matrix
or a data frame, with the first column being the indices of <code class="reqn">G_1</code> and
the second column being the corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="graph_match_percolation_+3A_similarity">similarity</code></td>
<td>
<p>A matrix. An <code>n-by-n</code> matrix containing vertex similarities.</p>
</td></tr>
<tr><td><code id="graph_match_percolation_+3A_r">r</code></td>
<td>
<p>A number. Threshold of neighboring pair scores.</p>
</td></tr>
<tr><td><code id="graph_match_percolation_+3A_expandwhenstuck">ExpandWhenStuck</code></td>
<td>
<p>A logical. TRUE if expand the seed set when Percolation algorithm
stops before matching all the vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>graph_match_percolation</code> returns an object of class &quot;<code><a href="#topic+graphMatch">graphMatch</a></code>&quot; which is a
list containing the following components:
</p>

<dl>
<dt>corr_A</dt><dd><p>matching correspondence in <code class="reqn">G_1</code></p>
</dd>
<dt>corr_B</dt><dd><p>matching correspondence in <code class="reqn">G_2</code></p>
</dd>
<dt>match_order</dt><dd><p>the order of vertices getting matched</p>
</dd>
<dt>seeds</dt><dd><p>a vector of logicals indicating if the corresponding vertex is a seed</p>
</dd>
</dl>



<h3>References</h3>

<p>L. Yartseva and M. Grossglauser (2013), <em>On the performance
of percolation graph matching</em>. COSN, Boston, MA, USA, pages 119â€“130.
</p>
<p>E. Kazemi, S. H. Hassani, and M. Grossglauser (2015),
<em>Growing a graph matching from a handful of seeds</em>. Proc. of the VLDB
Endowment, 8(10):1010â€“1021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># match G_1 &amp; G_2 using percolation graph matching method
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 20, corr =  0.5, p =  0.8)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
seeds &lt;- 1:10 &lt;= 3
GM_perco &lt;- gm(g1, g2, seeds, method = "percolation", r = 2, ExpandWhenStuck = FALSE)
GM_perco

# matching accuracy with the true alignment being the identity
mean(GM_perco$corr_A == GM_perco$corr_B)
GM_perco$match_order

summary(GM_perco, g1, g2, true_label = 1:20)
plot(g1[], g2[], GM_perco)

# expand when stuck
GM_exp &lt;- gm(g1, g2, seeds, method = "percolation", r = 4, ExpandWhenStuck = TRUE)
GM_exp


</code></pre>

<hr>
<h2 id='graph_match_Umeyama'>Spectral Graph Matching Methods: Umeyama Algorithm</h2><span id='topic+graph_match_Umeyama'></span>

<h3>Description</h3>

<p>Spectral Graph Matching Methods: Umeyama Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_match_Umeyama(A, B, seeds = NULL, similarity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_match_Umeyama_+3A_a">A</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_Umeyama_+3A_b">B</code></td>
<td>
<p>A matrix, igraph object, or list of either.</p>
</td></tr>
<tr><td><code id="graph_match_Umeyama_+3A_seeds">seeds</code></td>
<td>
<p>A vector of integers or logicals, a matrix or a data frame. If
the seed pairs have the same indices in both graphs then seeds can be a
vector. If not, seeds must be  a matrix
or a data frame, with the first column being the indices of <code class="reqn">G_1</code> and
the second column being the corresponding indices of <code class="reqn">G_2</code>.</p>
</td></tr>
<tr><td><code id="graph_match_Umeyama_+3A_similarity">similarity</code></td>
<td>
<p>A matrix. An <code>n-by-n</code> matrix containing vertex similarities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>graph_match_Umeyama</code> returns an object of class &quot;<code><a href="#topic+graphMatch">graphMatch</a></code>&quot; which is a list
containing the following components:
</p>

<dl>
<dt>corr_A</dt><dd><p>matching correspondence in <code class="reqn">G_1</code></p>
</dd>
<dt>corr_B</dt><dd><p>matching correspondence in <code class="reqn">G_2</code></p>
</dd>
<dt>soft</dt><dd><p>the functional similarity score matrix with which one can extract
more than one matching candidates</p>
</dd>
<dt>lap_method</dt><dd><p>Choice for solving the LAP</p>
</dd>
<dt>seeds</dt><dd><p>a vector of logicals indicating if the corresponding vertex is a seed</p>
</dd>
</dl>



<h3>References</h3>

<p>S. Umeyama (1988), <em>An eigendecomposition approach to weighted
graph matching problems</em>. IEEE TPAMI. USA, pages 695-703.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># match G_1 &amp; G_2 using Umeyama algorithm
G &lt;- sample_correlated_gnp_pair(10, .9, .5)
g1 &lt;- G$graph1
g2 &lt;- G$graph2
startm &lt;- matrix(0, 10, 10)
diag(startm)[1:4] &lt;- 1

GM_Umeyama &lt;- gm(g1, g2, similarity = startm, method = "Umeyama")
GM_Umeyama
# generate the corresponding permutation matrix
GM_Umeyama[]

summary(GM_Umeyama, g1, g2)
# visualize the edge-wise matching performance
plot(g1, g2, GM_Umeyama)
plot(g1[], g2[], GM_Umeyama)


</code></pre>

<hr>
<h2 id='graphMatch-class'>Graph matching results class</h2><span id='topic+graphMatch-class'></span><span id='topic+graphMatch'></span><span id='topic+as.graphMatch'></span>

<h3>Description</h3>

<p>An S4 class for the results of a graph matching function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphMatch(corr, nnodes, call = NULL, detail = list())

as.graphMatch(from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphMatch-class_+3A_corr">corr</code></td>
<td>
<p>data.frame indicating the correspondence between two graphs</p>
</td></tr>
<tr><td><code id="graphMatch-class_+3A_nnodes">nnodes</code></td>
<td>
<p>dimensions of the original two graphs</p>
</td></tr>
<tr><td><code id="graphMatch-class_+3A_call">call</code></td>
<td>
<p>The call to the graph matching function</p>
</td></tr>
<tr><td><code id="graphMatch-class_+3A_detail">detail</code></td>
<td>
<p>List with other more detailed information</p>
</td></tr>
<tr><td><code id="graphMatch-class_+3A_from">from</code></td>
<td>
<p>object to convert to graphMatch object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>graphMatch objects are returned by any of the graph matching methods
implemented in the iGraphMatch package. These objects are primarily to
represent the found correspondence between the two vertex sets. This is
represented by a data.frame with two columns indicating the aligned
vertex-pairs across the two graphs.
</p>


<h3>Value</h3>

<p>graphMatch object
</p>


<h3>Slots</h3>


<dl>
<dt><code>corr</code></dt><dd><p>data.frame indicating the correspondence between two graphs</p>
</dd>
<dt><code>nnodes</code></dt><dd><p>of the original two graphs</p>
</dd>
<dt><code>call</code></dt><dd><p>The call to the graph matching function</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+as.data.frame+2CgraphMatch-method">graphMatch_methods</a>,
<a href="#topic+summary+2CgraphMatch-method">graphMatch_summary</a>,
<a href="#topic++25+2A+25+2CgraphMatch+2CANY-method">graphMatch_operators</a>,
<a href="#topic+plot+2Cigraph+2Cigraph-method">graphMatch_plot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample a pair of correlated random graphs from G(n,p)
set.seed(123)
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2

# match g1 &amp; g2 using percolation algorithm with some known node pairs as seeds
match &lt;- gm(A = g1, B = g2, seeds = 1:3, method = 'indefinite')

# graphMatch object
match

match$corr_A # matching correspondence in the first graph
match$corr_B # matching correspondence in the second graph
match$seeds # vector of logicals indicating seeded nodes

as.data.frame(match)
match[]
dim(match)
length(match)

# matching details unique to the FW methodology with indefinite relaxation
match$iter # number of iterations
match$soft # doubly stochastic matrix from the last iteration, can be used to extract soft matching
match$lap_method # method for solving lap

# create a graphMatch object from a data.frame or matrix
as.graphMatch(data.frame(1:5, 1:5))
as.graphMatch(1:5)

</code></pre>

<hr>
<h2 id='init_start'>Initialization of the start matrix</h2><span id='topic+init_start'></span>

<h3>Description</h3>

<p>Initialize the start matrix for graph matching iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_start(start, nns, ns = 0, soft_seeds = NULL, seeds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_start_+3A_start">start</code></td>
<td>
<p>A matrix, character, or function. A <code>nns-by-nns</code> matrix, start
method like &quot;bari&quot;, &quot;convex&quot; or &quot;rds&quot;, or a function  to initialize the start matrix.
If a function, it must have at least the arguments nns, ns, and softs_seeds.</p>
</td></tr>
<tr><td><code id="init_start_+3A_nns">nns</code></td>
<td>
<p>An integer. Number of non-seeds.</p>
</td></tr>
<tr><td><code id="init_start_+3A_ns">ns</code></td>
<td>
<p>An integer. Number of seeds.</p>
</td></tr>
<tr><td><code id="init_start_+3A_soft_seeds">soft_seeds</code></td>
<td>
<p>A vector, a matrix or a data frame indicating entries of the start matrix
that will be initialized at 1 to indicate . See <a href="#topic+check_seeds">check_seeds</a>.</p>
</td></tr>
<tr><td><code id="init_start_+3A_seeds">seeds</code></td>
<td>
<p>A vector, a matrix or a data frame. Indicating hard seeds.
These are used for &quot;convex&quot; start but otherwise are ignored.</p>
</td></tr>
<tr><td><code id="init_start_+3A_...">...</code></td>
<td>
<p>Arguments passed to other start functions. See details in Values section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>start</code> is a character, there are five options.
</p>

<ul>
<li> <p><code>"bari"</code> initializes at the barycenter.
</p>
</li>
<li> <p><code>"rds_perm_bari"</code> gives a random linear combination of barycenter and
a random permutation matrix, (1-a) B + a P. The argument <code>g</code> controls a
with a being sampled as <code>g * runif()</code>.
</p>
</li>
<li> <p><code>"rds"</code> gives a random doubly stochastic matrix. Users can specify a
random deviates generator to the <code>distribution</code> argument, and the default is <code>runif</code>. 
A random matrix with iid entries from <code>distribution</code> and the the Sinkhorn algorithm is applied
to produce the output.
</p>
</li>
<li> <p><code>"rds_from_sim"</code> gives a random doubly stochastic matrix derived from
similarity scores. One needs to input a similarity score matrix to the <code>sim</code>
argument for this method. The procedure is the same as <code>"rds"</code> but before 
the Sinkhorn algorithm is applied, the entries of the random matrix are scaled by 
<code>sim</code>.
</p>
</li>
<li> <p><code>"convex"</code> returns the doubly stochastic matrix from the last iteration of running the Frank-
Wolfe algorithm with convex relaxation initialized at the barycenter. For this method, one needs to
input two graphs <code>A</code> and <code>B</code>, as well as <code>seeds</code> if applicable.
</p>
</li></ul>



<h3>Value</h3>

<p><code>init_start</code> returns a <code>nns-by-nns</code> doubly stochastic matrix as the start
matrix in the graph matching iteration. If conduct a soft seeding graph matching, returns a
<code>nns-by-nns</code> doubly stochastic matrix with 1's corresponding to the soft seeds and values
at the other places are derived by different start method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss &lt;- matrix(c(5, 4, 4, 3), nrow = 2)
# initialize start matrix without soft seeds
init_start(start = "bari", nns = 5)
init_start(start = "rds", nns = 3)
init_start(start = "rds_perm_bari", nns = 5)
init_start(start = "rds_from_sim", nns = 3, sim = matrix(runif(9), 3))

# initialize start matrix with soft seeds
init_start(start = "bari", nns = 5, ns = 1, soft_seeds = ss)
init_start(start = "rds", nns = 5, soft_seeds = ss)
init_start(start = "rds_perm_bari", nns = 5, soft_seeds = ss)


# initialize start matrix for convex graph matching
cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.3, p =  0.5)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
seeds &lt;- 1:10 &lt;= 2
init_start(start = "convex", nns = 8, A = g1, B = g2, seeds = seeds)

# FW graph matching with incorrect seeds to start at convex start
init_start(start = "convex", nns = 8, ns = 2, soft_seeds = ss, A = g1, B = g2, seeds = seeds)


</code></pre>

<hr>
<h2 id='innerproduct'>Matrix inner products</h2><span id='topic+innerproduct'></span><span id='topic+innerproduct+2CsplrMatrix+2CsplrMatrix-method'></span><span id='topic+innerproduct+2CsplrMatrix+2CMatrix-method'></span><span id='topic+innerproduct+2CMatrix+2CsplrMatrix-method'></span><span id='topic+innerproduct+2Cmatrix_list+2Cmatrix_list-method'></span>

<h3>Description</h3>

<p>Matrix inner products
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerproduct(x, y)

## S4 method for signature 'splrMatrix,splrMatrix'
innerproduct(x, y)

## S4 method for signature 'splrMatrix,Matrix'
innerproduct(x, y)

## S4 method for signature 'Matrix,splrMatrix'
innerproduct(x, y)

## S4 method for signature 'matrix_list,matrix_list'
innerproduct(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="innerproduct_+3A_x">x</code></td>
<td>
<p>matrix like object</p>
</td></tr>
<tr><td><code id="innerproduct_+3A_y">y</code></td>
<td>
<p>matrix like object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a matrix_list object, sums over all layers/list-elements as well.
</p>


<h3>Value</h3>

<p>inner product &lt;x, y&gt; = sum over all elements i,j of x_ij * y_ij.
</p>

<hr>
<h2 id='lapjv'>Solves a linear assignment problem using the Jonker-Vogenant algorithm or LAPMOD variant</h2><span id='topic+lapjv'></span><span id='topic+lapmod'></span>

<h3>Description</h3>

<p>Find the matching of rows to columns that minimizes or maximizes
the cost. See <a href="#topic+do_lap">do_lap</a> for usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapjv(cost, maximize = FALSE)

lapmod(cost, maximize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lapjv_+3A_cost">cost</code></td>
<td>
<p>For lapjv, an object that can be coerced to a matrix. For lapmod, a sparseMatrix.</p>
</td></tr>
<tr><td><code id="lapjv_+3A_maximize">maximize</code></td>
<td>
<p>If FALSE (default) then costs are minimized and if TRUE the
costs are maximized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The C++ code for these method is modified from code in the
<a href="https://github.com/Bram94/lapjv">python lapjv</a> package.
</p>
<p>The cost matrix is padded with a single row and column of very large entries that
helps to avoid stability issues with the algorithms.
</p>


<h3>Value</h3>

<p>The assignment of rows to columns as a vector.
</p>


<h3>References</h3>

<p>R. Jonker, A. Volgenant (1987). <em>A shortest augmenting path algorithm
for dense and sparse linear assignment problems</em>. Computing, pages 325-340.
</p>
<p>A. Volgenant (1996). <em>Linear and Semi-Assignment Problems: A
Core Oriented Approach</em>. Computer Ops Res., pages 917-932.
</p>

<hr>
<h2 id='largest_common_cc'>Find the largest common connected subgraph (LCCS) of two graphs</h2><span id='topic+largest_common_cc'></span><span id='topic+largest_cc'></span>

<h3>Description</h3>

<p>Find the largest common connected subgraphs of
two matched graphs, which is an induced connected subgraph of both graphs
that has as many vertices as possible.
The <code>largest_cc</code> function returns the largest connected subgraph of a single graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>largest_common_cc(A, B, min_degree = 1)

largest_cc(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="largest_common_cc_+3A_a">A</code></td>
<td>
<p>A matrix or an igraph object. See <a href="#topic+check_graph">check_graph</a>. Must be single-layer.</p>
</td></tr>
<tr><td><code id="largest_common_cc_+3A_b">B</code></td>
<td>
<p>A matrix or an igraph object. See <a href="#topic+check_graph">check_graph</a>. Must be single-layer.</p>
</td></tr>
<tr><td><code id="largest_common_cc_+3A_min_degree">min_degree</code></td>
<td>
<p>A number. Defines the level of connectedness of the
obtained largest common connected subgraph. The induced subgraph is
a graph with a minimum vertex-degree of at least min_degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>largest_common_cc</code> returns the common largest connected subgraphs of
two aligned graphs in the igraph object form and a logical vector indicating which vertices in
the original graphs remain in the induced subgraph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cgnp_pair &lt;- sample_correlated_gnp_pair(n = 10, corr =  0.7, p =  0.2)
g1 &lt;- cgnp_pair$graph1
g2 &lt;- cgnp_pair$graph2
# put no constraint on the minimum degree of the common largest conncect subgraph
lccs1 &lt;- largest_common_cc(g1, g2, min_degree = 1)
# induced subgraph
lccs1$g1
lccs1$g2
# label of vertices of the induced subgraph in the original graph
igraph::V(g1)[lccs1$keep]

# obtain a common largest connect subgraph with each vertex having a minimum degree of 3
lccs3 &lt;- largest_common_cc(g1, g2, min_degree = 3)

g &lt;- igraph::sample_gnp(100, .01)
lcc &lt;- largest_cc(g)
# induced subgraph
lcc$g
# label of vertices of the induced subgraph in the original graph
igraph::V(g)[lcc$keep]

</code></pre>

<hr>
<h2 id='matrix_list-class'>Lists of Matrices</h2><span id='topic+matrix_list-class'></span><span id='topic+matrix_list'></span><span id='topic++25+2A+25+2Cmatrix_list+2Cmatrix_list-method'></span><span id='topic+t+2Cmatrix_list-method'></span><span id='topic+dim+2Cmatrix_list-method'></span><span id='topic++5B+2Cmatrix_list+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cmatrix_list+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cmatrix_list+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2Cmatrix_list+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++25+2A+25+2Cmatrix_list+2CANY-method'></span><span id='topic++25+2A+25+2CANY+2Cmatrix_list-method'></span><span id='topic++25+2A+25+2Cmatrix_list+2CMatrix-method'></span><span id='topic++25+2A+25+2CMatrix+2Cmatrix_list-method'></span><span id='topic+sum+2Cmatrix_list+2Clogical-method'></span><span id='topic++5E+2Cmatrix_list+2CANY-method'></span><span id='topic+-+2Cmatrix_list+2Cmatrix_list-method'></span><span id='topic++2B+2Cmatrix_list+2Cmatrix_list-method'></span><span id='topic++2A+2Cmatrix_list+2Cmatrix_list-method'></span><span id='topic++2F+2Cmatrix_list+2Cmatrix_list-method'></span><span id='topic+-+2Cmatrix_list+2CANY-method'></span><span id='topic++2B+2Cmatrix_list+2CANY-method'></span><span id='topic++2A+2Cmatrix_list+2CANY-method'></span><span id='topic++2F+2Cmatrix_list+2CANY-method'></span><span id='topic+-+2CANY+2Cmatrix_list-method'></span><span id='topic++2B+2CANY+2Cmatrix_list-method'></span><span id='topic++2A+2CANY+2Cmatrix_list-method'></span><span id='topic++2F+2CANY+2Cmatrix_list-method'></span><span id='topic+-+2Cmatrix_list+2Cmissing-method'></span><span id='topic+names+3C-+2Cmatrix_list-method'></span>

<h3>Description</h3>

<p>Basically a list with matrix components that are all 
the same dimension. Mostly for internal igraphmatch use.
It can do various things like arithmetic and
indexing, all of which are done component-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_list(ml)

## S4 method for signature 'matrix_list,matrix_list'
x %*% y

## S4 method for signature 'matrix_list'
t(x)

## S4 method for signature 'matrix_list'
dim(x)

## S4 method for signature 'matrix_list,ANY,ANY,ANY'
x[i = 1:nrow(x[[1]]), j = 1:ncol(x[[1]]), drop = FALSE]

## S4 method for signature 'matrix_list,ANY,missing,ANY'
x[i, drop = FALSE]

## S4 method for signature 'matrix_list,missing,ANY,ANY'
x[j, drop = FALSE]

## S4 method for signature 'matrix_list,missing,missing,ANY'
x[drop = FALSE]

## S4 method for signature 'matrix_list,ANY'
x %*% y

## S4 method for signature 'ANY,matrix_list'
x %*% y

## S4 method for signature 'matrix_list,Matrix'
x %*% y

## S4 method for signature 'Matrix,matrix_list'
x %*% y

## S4 method for signature 'matrix_list,logical'
sum(x, na.rm = FALSE)

## S4 method for signature 'matrix_list,ANY'
e1 ^ e2

## S4 method for signature 'matrix_list,matrix_list'
e1 - e2

## S4 method for signature 'matrix_list,matrix_list'
e1 + e2

## S4 method for signature 'matrix_list,matrix_list'
e1 * e2

## S4 method for signature 'matrix_list,matrix_list'
e1 / e2

## S4 method for signature 'matrix_list,ANY'
e1 - e2

## S4 method for signature 'matrix_list,ANY'
e1 + e2

## S4 method for signature 'matrix_list,ANY'
e1 * e2

## S4 method for signature 'matrix_list,ANY'
e1 / e2

## S4 method for signature 'ANY,matrix_list'
e1 - e2

## S4 method for signature 'ANY,matrix_list'
e1 + e2

## S4 method for signature 'ANY,matrix_list'
e1 * e2

## S4 method for signature 'ANY,matrix_list'
e1 / e2

## S4 method for signature 'matrix_list,missing'
e1 - e2

## S4 replacement method for signature 'matrix_list'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_list-class_+3A_ml">ml</code></td>
<td>
<p>A list of matrices</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_x">x</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_y">y</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_i">i</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_j">j</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_drop">drop</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_na.rm">na.rm</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_e1">e1</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
<tr><td><code id="matrix_list-class_+3A_e2">e2</code></td>
<td>
<p>As in Matrix</p>
</td></tr>
</table>

<hr>
<h2 id='pad'>Pad a matrix object with extra rows/columns of 0s.</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p>Attempts are made to make this padding efficient
by employing sparse graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(m, nr, nc = nr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pad_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="pad_+3A_nr">nr</code></td>
<td>
<p>number of rows to add</p>
</td></tr>
<tr><td><code id="pad_+3A_nc">nc</code></td>
<td>
<p>number of columns to add. (default = nr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m padded with nr rows and nc columns of zeros.
</p>

<hr>
<h2 id='plot+2Cigraph+2Cigraph-method'>Plotting methods for visualizing matches</h2><span id='topic+plot+2Cigraph+2Cigraph-method'></span><span id='topic+plot+2CMatrix+2CMatrix-method'></span>

<h3>Description</h3>

<p>Two functions are provided, <code>match_plot_igraph</code>
which makes a ball and stick plot from igraph objects
and <code>match_plot_matrix</code> which shows an adjacency
matrix plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'igraph,igraph'
plot(x, y, match = NULL, color = TRUE, linetype = TRUE, ...)

## S4 method for signature 'Matrix,Matrix'
plot(x, y, match = NULL, col.regions = NULL, at = NULL, colorkey = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_x">x</code></td>
<td>
<p>First graph, either an igraph object or a Matrix</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_y">y</code></td>
<td>
<p>second graph, either an igraph object or a Matrix</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_match">match</code></td>
<td>
<p>result from a match call. Requires element
<code>corr</code> as a data.frame with names corr_A, corr_B.</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_color">color</code></td>
<td>
<p>Whether to color edges according to which
graph(s) they are in.</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_linetype">linetype</code></td>
<td>
<p>Whether to set edge line types according
to which graph(s) they are in.</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_...">...</code></td>
<td>
<p>additional parameters passed to either the
igraph plot function or the Matrix image function.</p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_col.regions">col.regions</code></td>
<td>
<p>NULL for default colors, otherwise see <a href="Matrix.html#topic+image-methods">image-methods</a></p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_at">at</code></td>
<td>
<p>NULL for default at values for at (ensures zero is grey), otherwise see <a href="Matrix.html#topic+image-methods">image-methods</a></p>
</td></tr>
<tr><td><code id="plot+2B2Cigraph+2B2Cigraph-method_+3A_colorkey">colorkey</code></td>
<td>
<p>NULL for default colorkey, otherwise see <a href="Matrix.html#topic+image-methods">image-methods</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grey edges/pixels indicate common edges, blue
indicates edges only in graph A and red
represents edges only graph B. The corresponding
linetypes are solid, long dash, and short dash.
</p>
<p>The plots can be recreated from the output with the code <br />
<code>plot(g)</code> <br />
for <code>g &lt;- match_plot_igraph(...)</code> and  <br />
<code>col &lt;- colorRampPalette(c("#AA4444", "#888888", "#44AA44"))</code> <br />
<code>image(m, col.regions = col(256))</code> <br />
for <code>m &lt;- match_plot_match(...)</code>.
</p>
<p>This only plots and returns the matched vertices.
</p>


<h3>Value</h3>

<p>Both functions return values invisibly.
<code>match_plot_igraph</code> returns the union of the
matched graphs as an igraph object with additional
edge attributes <code>edge_match, color, lty</code>.
<code>match_plot_matrix</code> returns the difference between
the matched graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
graphs &lt;- sample_correlated_gnp_pair(20, .9, .3)
A &lt;- graphs$graph1
B &lt;- graphs$graph2
res &lt;- gm(A, B, 1:4, method = "percolation")

plot(A, B, res)
plot(A[], B[], res)
</code></pre>

<hr>
<h2 id='sample_correlated_gnp_pair'>Sample correlated G(n,p) random graphs</h2><span id='topic+sample_correlated_gnp_pair'></span>

<h3>Description</h3>

<p>Sample a pair of correlated G(n,p) random graphs with correlation between
two graphs being <code>corr</code> and edge probability being <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_correlated_gnp_pair(n, corr, p, ncore = n, permutation = 1:n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_correlated_gnp_pair_+3A_n">n</code></td>
<td>
<p>An integer. Number of total vertices for the sampled graphs.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_corr">corr</code></td>
<td>
<p>A number. The target Pearson correlation between the adjacency matrices
of the generated graphs. It must be in  [0,1] interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_p">p</code></td>
<td>
<p>A number. Edge probability between two vertices. It must be in open
[0,1] interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_ncore">ncore</code></td>
<td>
<p>An integer. Number of core vertices.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector to permute second graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_gnp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sample_correlated_gnp_pair</code> returns a list of two igraph object, named
<code>graph1</code> and <code>graph2</code>, whose adjacency matrix entries
are correlated with <code>corr</code>. If sample two graphs with junk vertices, the first
<code>ncore</code> vertices are core vertices and the rest are junk vertices.
</p>


<h3>References</h3>

<p>V. Lyzinski and D. E. Fishkind and C. E. Priebe (2014), <em>Seeded Graph Matching
for Correlated Erdos-Renyi Graphs</em>.J. Mach. Learn. Res., pages 3513-3540.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_correlated_sbm_pair">sample_correlated_sbm_pair</a></code>, <code><a href="#topic+sample_correlated_rdpg_pair">sample_correlated_rdpg_pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_correlated_gnp_pair(n=50, corr=0.3, p=0.5, ncore=40)
sample_correlated_gnp_pair(n=5, corr=0.3, p=0.5, permutation=c(1,3,2,4,5))

</code></pre>

<hr>
<h2 id='sample_correlated_ieg_pair'>Sample graphs from edge probability matrix and correlation matrix</h2><span id='topic+sample_correlated_ieg_pair'></span><span id='topic+sample_correlated_rdpg_pair'></span>

<h3>Description</h3>

<p>Sample a pair of graphs with specified edge probability and
correlation between each pair of vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_correlated_ieg_pair(
  n,
  p_mat,
  c_mat,
  ncore = n,
  directed = FALSE,
  loops = FALSE,
  permutation = 1:n
)

sample_correlated_rdpg_pair(X, corr, ncore = nrow(X), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_correlated_ieg_pair_+3A_n">n</code></td>
<td>
<p>An integer. Number of total vertices for the sampled graphs.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_p_mat">p_mat</code></td>
<td>
<p>An <code>n-by-n</code> matrix. Edge probability matrix, each entry
should be in the open (0,1) interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_c_mat">c_mat</code></td>
<td>
<p>An <code>n-by-n</code> matrix. The target Pearson correlation matrix,
each entry should be in the open (0,1) interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_ncore">ncore</code></td>
<td>
<p>An integer. Number of core vertices.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed graphs.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether self-loops are allowed in the graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector,permute second graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_x">X</code></td>
<td>
<p>A matrix. Dot products matrix, each entry must be in open (0,1)
interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_corr">corr</code></td>
<td>
<p>A number. The target Pearson correlation between the adjacency
matrices of the generated graphs. It must be in open (0,1) interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_ieg_pair_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_correlated_ieg_pair</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sample_correlated_ieg_pair</code> returns two igraph objects named
<code>graph1</code> and <code>graph2</code>. If sample two graphs with junk vertices,
the first <code>ncore</code> vertices are core vertices and the rest are junk
vertices.
</p>
<p><code>sample_correlated_rdpg_pair</code> returns two igraph objects named
<code>graph1</code> and <code>graph2</code> that are sampled from random dot product
graphs model. If sample two graphs with junk vertices, the first
<code>ncore</code> vertices are core vertices and the rest are junk vertices.
</p>


<h3>References</h3>

<p>S. Young and E. Scheinerman (2007), <em>Random Dot Product
Graph Models for Social Networks</em>. Proceedings of the 5th International
Conference on Algorithms and Models for the Web-graph, pages 138-149.
</p>
<p>F. Fang and D. Sussman and V. Lyzinski (2018), <em>Tractable
Graph Matching via Soft Seeding</em>. <a href="https://arxiv.org/abs/1807.09299">https://arxiv.org/abs/1807.09299</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a></code>,
<code><a href="#topic+sample_correlated_sbm_pair">sample_correlated_sbm_pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
p_mat &lt;- matrix(runif(n^2),n)
c_mat &lt;- matrix(runif(n^2),n)
sample_correlated_ieg_pair(n,p_mat,c_mat,ncore=40)

## sample a pair of igraph objects from random dot
## product graphs model with dimension 3 and scale 8
n &lt;- 50
xdim &lt;- 3
scale &lt;- 8
X &lt;- matrix(rgamma(n*(xdim+1),scale,1),n,xdim+1)
X &lt;- X/rowSums(X)
X &lt;- X[,1:xdim]
sample_correlated_rdpg_pair(X,corr=0.5,ncore=40)

</code></pre>

<hr>
<h2 id='sample_correlated_sbm_pair'>Sample graphs pair from stochastic block model</h2><span id='topic+sample_correlated_sbm_pair'></span>

<h3>Description</h3>

<p>Sample a pair of random graphs from stochastic block model with
correlation between two graphs being <code>corr</code> and edge probability being
<code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_correlated_sbm_pair(
  n,
  pref.matrix,
  block.sizes,
  corr,
  core.block.sizes = NULL,
  permutation = 1:n,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_correlated_sbm_pair_+3A_n">n</code></td>
<td>
<p>An integer. Number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>The matrix giving the Bernoulli rates. This is a
<code>K-by-K</code> matrix, where <code>k</code> is the number of groups. The
probability of creating an edge between vertices from groups <code>i</code> and
<code>j</code> is given by element <code>i,j</code>. For undirected graphs, this matrix
must be symmetric.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_block.sizes">block.sizes</code></td>
<td>
<p>A numeric vector. Give the number of vertices in each
group. The sum of the vector must match the number of vertices.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_corr">corr</code></td>
<td>
<p>A number. The target Pearson correlation between the adjacency
matrices of the generated graphs. It must be in open (0,1) interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_core.block.sizes">core.block.sizes</code></td>
<td>
<p>A numeric vector. Give the number of core vertices in
each group. Entries should be smaller than <code>block.sizes</code> and the
vector length should be the same as <code>block.sizes</code>.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector, permute second graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_sbm_pair_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_sbm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of two igraph object, named <code>graph1</code> and
<code>graph2</code>. If sample two graphs with junk vertices, in each
corresponding block the first <code>core.block.sizes</code> vertices are core
vertices and the rest are junk vertices.
</p>


<h3>References</h3>

<p>P. Holland and K. Laskey and S. Leinhardt (1983),
<em>Stochastic Blockmodels: First Steps</em>. Social Networks, pages 109-137.
</p>
<p>F. Fang and D. Sussman and V. Lyzinski (2018), <em>Tractable
Graph Matching via Soft Seeding</em>. <a href="https://arxiv.org/abs/1807.09299">https://arxiv.org/abs/1807.09299</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a></code>,
<code><a href="#topic+sample_correlated_rdpg_pair">sample_correlated_rdpg_pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm &lt;- cbind( c(.1, .001), c(.001, .05) )
sample_correlated_sbm_pair(n=1000, pref.matrix=pm, block.sizes=c(300,700), corr=0.5)
sample_correlated_sbm_pair(n=1000, pref.matrix=pm, block.sizes=c(300,700), corr=0.5,
core.block.sizes=c(200,500))

</code></pre>

<hr>
<h2 id='show+2CsplrMatrix-method'>&quot;SPLR&quot; Methods</h2><span id='topic+show+2CsplrMatrix-method'></span><span id='topic+splrMatrix_method'></span><span id='topic+print+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2Cmatrix_list-method'></span><span id='topic++25+2A+25+2Cmatrix_list+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CMatrix+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2Cnumeric+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CnumLike+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CANY+2CsplrMatrix-method'></span><span id='topic+dim+2CsplrMatrix-method'></span><span id='topic+length+2CsplrMatrix-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2CMatrix-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2Cnumeric-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2CnumLike-method'></span><span id='topic++25+2A+25+2CsplrMatrix+2CANY-method'></span><span id='topic++2A+2CsplrMatrix+2CsplrMatrix-method'></span><span id='topic++2A+2CMatrix+2CsplrMatrix-method'></span><span id='topic++2A+2CsplrMatrix+2CddiMatrix-method'></span><span id='topic++2A+2CddiMatrix+2CsplrMatrix-method'></span><span id='topic++2A+2Cmatrix+2CsplrMatrix-method'></span><span id='topic++2A+2Cnumeric+2CsplrMatrix-method'></span><span id='topic++2A+2CANY+2CsplrMatrix-method'></span><span id='topic++2A+2CsplrMatrix+2Cmatrix-method'></span><span id='topic++2A+2CsplrMatrix+2CMatrix-method'></span><span id='topic++2A+2CsplrMatrix+2Cnumeric-method'></span><span id='topic++2A+2CsplrMatrix+2CANY-method'></span><span id='topic++2F+2CsplrMatrix+2Cmatrix-method'></span><span id='topic++2F+2CsplrMatrix+2CMatrix-method'></span><span id='topic++2F+2CsplrMatrix+2CANY-method'></span><span id='topic++2B+2CsplrMatrix+2CsplrMatrix-method'></span><span id='topic+-+2CsplrMatrix+2CsplrMatrix-method'></span><span id='topic++2B+2CsplrMatrix+2CMatrix-method'></span><span id='topic++2B+2CsplrMatrix+2Cnumeric-method'></span><span id='topic++2B+2CsplrMatrix+2CANY-method'></span><span id='topic+-+2CsplrMatrix+2Cmissing-method'></span><span id='topic+-+2CsplrMatrix+2CMatrix-method'></span><span id='topic+-+2CsplrMatrix+2CddiMatrix-method'></span><span id='topic+-+2CsplrMatrix+2Cnumeric-method'></span><span id='topic+-+2CsplrMatrix+2CANY-method'></span><span id='topic++2B+2CMatrix+2CsplrMatrix-method'></span><span id='topic++2B+2Cnumeric+2CsplrMatrix-method'></span><span id='topic++2B+2CANY+2CsplrMatrix-method'></span><span id='topic+-+2CMatrix+2CsplrMatrix-method'></span><span id='topic+-+2Cnumeric+2CsplrMatrix-method'></span><span id='topic+-+2CANY+2CsplrMatrix-method'></span><span id='topic+norm+2CsplrMatrix+2Ccharacter-method'></span><span id='topic+rowSums+2CsplrMatrix-method'></span><span id='topic+colSums+2CsplrMatrix-method'></span><span id='topic+rowMeans+2CsplrMatrix-method'></span><span id='topic+colMeans+2CsplrMatrix-method'></span><span id='topic+sum+2CsplrMatrix+2CANY-method'></span><span id='topic+mean+2CsplrMatrix-method'></span><span id='topic++5B+2CsplrMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cmissing+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Cmissing+2Clogical+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cmissing+2Clogical+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2CANY+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2Clogical+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cnumeric+2CANY+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2CANY+2CANY-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2CANY+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CsplrMatrix+2Clogical+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2CsplrMatrix+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2CsplrMatrix+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+3C-+2CsplrMatrix+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CsplrMatrix+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+3C-+2CMatrix+2CANY+2CANY+2CsplrMatrix-method'></span><span id='topic+str+2CsplrMatrix-method'></span><span id='topic+t+2CsplrMatrix-method'></span><span id='topic+diag+2CsplrMatrix-method'></span>

<h3>Description</h3>

<p>Methods for the splrMatrix class. Most behave like
Matrix methods though things like output show the
decomposition. Use as.matrix to see the computed
dense matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'splrMatrix'
show(object)

## S4 method for signature 'splrMatrix'
print(x)

## S4 method for signature 'splrMatrix,splrMatrix'
x %*% y

## S4 method for signature 'splrMatrix,matrix_list'
x %*% y

## S4 method for signature 'matrix_list,splrMatrix'
x %*% y

## S4 method for signature 'Matrix,splrMatrix'
x %*% y

## S4 method for signature 'matrix,splrMatrix'
x %*% y

## S4 method for signature 'numeric,splrMatrix'
x %*% y

## S4 method for signature 'numLike,splrMatrix'
x %*% y

## S4 method for signature 'ANY,splrMatrix'
x %*% y

## S4 method for signature 'splrMatrix'
dim(x)

## S4 method for signature 'splrMatrix'
length(x)

## S4 method for signature 'splrMatrix,Matrix'
x %*% y

## S4 method for signature 'splrMatrix,matrix'
x %*% y

## S4 method for signature 'splrMatrix,numeric'
x %*% y

## S4 method for signature 'splrMatrix,numLike'
x %*% y

## S4 method for signature 'splrMatrix,ANY'
x %*% y

## S4 method for signature 'splrMatrix,splrMatrix'
e1 * e2

## S4 method for signature 'Matrix,splrMatrix'
e1 * e2

## S4 method for signature 'splrMatrix,ddiMatrix'
e1 * e2

## S4 method for signature 'ddiMatrix,splrMatrix'
e1 * e2

## S4 method for signature 'matrix,splrMatrix'
e1 * e2

## S4 method for signature 'numeric,splrMatrix'
e1 * e2

## S4 method for signature 'ANY,splrMatrix'
e1 * e2

## S4 method for signature 'splrMatrix,matrix'
e1 * e2

## S4 method for signature 'splrMatrix,Matrix'
e1 * e2

## S4 method for signature 'splrMatrix,numeric'
e1 * e2

## S4 method for signature 'splrMatrix,ANY'
e1 * e2

## S4 method for signature 'splrMatrix,matrix'
e1 / e2

## S4 method for signature 'splrMatrix,Matrix'
e1 / e2

## S4 method for signature 'splrMatrix,ANY'
e1 / e2

## S4 method for signature 'splrMatrix,splrMatrix'
e1 + e2

## S4 method for signature 'splrMatrix,splrMatrix'
e1 - e2

## S4 method for signature 'splrMatrix,Matrix'
e1 + e2

## S4 method for signature 'splrMatrix,numeric'
e1 + e2

## S4 method for signature 'splrMatrix,ANY'
e1 + e2

## S4 method for signature 'splrMatrix,missing'
e1 - e2 = NULL

## S4 method for signature 'splrMatrix,Matrix'
e1 - e2

## S4 method for signature 'splrMatrix,ddiMatrix'
e1 - e2

## S4 method for signature 'splrMatrix,numeric'
e1 - e2

## S4 method for signature 'splrMatrix,ANY'
e1 - e2

## S4 method for signature 'Matrix,splrMatrix'
e1 + e2

## S4 method for signature 'numeric,splrMatrix'
e1 + e2

## S4 method for signature 'ANY,splrMatrix'
e1 + e2

## S4 method for signature 'Matrix,splrMatrix'
e1 - e2

## S4 method for signature 'numeric,splrMatrix'
e1 - e2

## S4 method for signature 'ANY,splrMatrix'
e1 - e2

## S4 method for signature 'splrMatrix,character'
norm(x, type, ...)

## S4 method for signature 'splrMatrix'
rowSums(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'splrMatrix'
colSums(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'splrMatrix'
rowMeans(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'splrMatrix'
colMeans(x, na.rm = FALSE, dims = 1, ...)

## S4 method for signature 'splrMatrix,ANY'
sum(x, ..., na.rm = FALSE)

## S4 method for signature 'splrMatrix'
mean(x, ...)

## S4 method for signature 'splrMatrix,missing,missing,missing'
x[i = NULL, j = NULL, drop = NULL]

## S4 method for signature 'splrMatrix,numeric,numeric,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,missing,numeric,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,missing,numeric,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,missing,logical,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,missing,logical,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,numeric,missing,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,numeric,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,logical,missing,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,logical,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,numeric,ANY,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,numeric,logical,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,numeric,ANY,missing'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'splrMatrix,logical,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,logical,ANY,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,logical,numeric,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,logical,numeric,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'splrMatrix,missing,missing,missing'
x[i = NULL, j = NULL, drop = NULL]

## S4 method for signature 'splrMatrix,matrix,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 replacement method for signature 'splrMatrix,numeric,numeric,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'splrMatrix,numeric,missing,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'splrMatrix,missing,numeric,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'Matrix,ANY,ANY,splrMatrix'
x[i, j, ...] &lt;- value

## S4 method for signature 'splrMatrix'
dim(x)

## S4 method for signature 'splrMatrix'
str(object)

## S4 method for signature 'splrMatrix'
t(x)

## S4 method for signature 'splrMatrix'
diag(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_object">object</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_x">x</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_y">y</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_e1">e1</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_e2">e2</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_type">type</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_...">...</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_na.rm">na.rm</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_dims">dims</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_i">i</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_j">j</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_drop">drop</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="show+2B2CsplrMatrix-method_+3A_value">value</code></td>
<td>
<p>As in &quot;Matrix&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of matrix operations for splrMatrix objects.
Attempts are made such that the returned object is stored efficiently,
either as a splrMatrix or sparse Matrix.
</p>

<hr>
<h2 id='split_igraph'>Split an igraph object into aligned graphs by attribute</h2><span id='topic+split_igraph'></span>

<h3>Description</h3>

<p>Given an igraph object and an edge attribute, this function
finds all unique values of the edge attribute in the graph
and returns a list of igraph objects on the same vertex set
where each element of the list has a graph containing only
those edges with specified attributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_igraph(g, e_attr, strip_vertex_attr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_igraph_+3A_g">g</code></td>
<td>
<p>An igraph object</p>
</td></tr>
<tr><td><code id="split_igraph_+3A_e_attr">e_attr</code></td>
<td>
<p>the name of an edge attribute in g</p>
</td></tr>
<tr><td><code id="split_igraph_+3A_strip_vertex_attr">strip_vertex_attr</code></td>
<td>
<p>Whether to remove all vertex
attribute from the new graphs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of igraph objects with names corresponding to the values of
the edge attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- igraph::sample_gnm(20, 60)
igraph::E(g)$color &lt;-
  sample(c("red", "green"), 60, replace = TRUE)
split_igraph(g, "color")

</code></pre>

<hr>
<h2 id='splr_sparse_plus_constant'>Add a constant to a splrMatrix object</h2><span id='topic+splr_sparse_plus_constant'></span>

<h3>Description</h3>

<p>Add a constant to a splrMatrix object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splr_sparse_plus_constant(x, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splr_sparse_plus_constant_+3A_x">x</code></td>
<td>
<p>sparse Matrix object</p>
</td></tr>
<tr><td><code id="splr_sparse_plus_constant_+3A_a">a</code></td>
<td>
<p>scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new splrMatrix object x + a
</p>

<hr>
<h2 id='splr_to_sparse'>Convert splr &quot;Matrix&quot; to Sparse</h2><span id='topic+splr_to_sparse'></span>

<h3>Description</h3>

<p>Convert splr &quot;Matrix&quot; to Sparse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splr_to_sparse(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splr_to_sparse_+3A_data">data</code></td>
<td>
<p>splrMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse Matrix equal to x + a 
</p>
<p>See <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>.
</p>

<hr>
<h2 id='splrMatrix-class'>Sparse Plus Low-Rank Matrices</h2><span id='topic+splrMatrix-class'></span><span id='topic+splr'></span><span id='topic+splr+2CMatrix+2CMatrix+2CMatrix-method'></span>

<h3>Description</h3>

<p>An &quot;S4&quot; class for efficient computation with sparse plus
low-rank matrices. Stores sparse plus low-rank matrices
(e.g. from matrix factorization or centering graphs)
of the form <code>x + a %*% t(b)</code> for faster
computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splr(x, a = NULL, b = NULL, rank = NULL, dimnames = list(NULL, NULL), ...)

## S4 method for signature 'Matrix,Matrix,Matrix'
splr(x, a = NULL, b = NULL, rank = NULL, dimnames = list(NULL, NULL), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splrMatrix-class_+3A_x">x</code></td>
<td>
<p>as in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="splrMatrix-class_+3A_a">a</code></td>
<td>
<p>as in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="splrMatrix-class_+3A_b">b</code></td>
<td>
<p>as in &quot;Matrix&quot;</p>
</td></tr>
<tr><td><code id="splrMatrix-class_+3A_rank">rank</code></td>
<td>
<p>rank of the matrix to be factorized.</p>
</td></tr>
<tr><td><code id="splrMatrix-class_+3A_dimnames">dimnames</code></td>
<td>
<p>optional - the list of names for the matrix</p>
</td></tr>
<tr><td><code id="splrMatrix-class_+3A_...">...</code></td>
<td>
<p>as in &quot;Matrix&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splrMatrix object
</p>
<p>splrMatrix object
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>a sparse matrix</p>
</dd>
<dt><code>a</code></dt><dd><p>a low-rank factor or a matrix</p>
</dd>
<dt><code>b</code></dt><dd><p>optional. a low-rank factor for <code>a %*% t(b)</code>. if <code>b</code> is not provided, a will be factorized using
<code><a href="irlba.html#topic+irlba">irlba</a></code> provided <code>factorize = TRUE</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>Methods are documented in <a href="#topic+splrMatrix_method">splrMatrix_method</a>.
Other relevant methods are <a href="#topic+splr_sparse_plus_constant">splr_sparse_plus_constant</a> and
</p>

<hr>
<h2 id='summary+2CgraphMatch-method'>Summary methods for graphMatch objects</h2><span id='topic+summary+2CgraphMatch-method'></span>

<h3>Description</h3>

<p>Summary methods for graphMatch objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'graphMatch'
summary(object, A = NULL, B = NULL, true_label = NULL, directed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary+2B2CgraphMatch-method_+3A_object">object</code></td>
<td>
<p>graphMatch object</p>
</td></tr>
<tr><td><code id="summary+2B2CgraphMatch-method_+3A_a">A</code></td>
<td>
<p>igraph or matrix-like object</p>
</td></tr>
<tr><td><code id="summary+2B2CgraphMatch-method_+3A_b">B</code></td>
<td>
<p>igraph or matrix-like object</p>
</td></tr>
<tr><td><code id="summary+2B2CgraphMatch-method_+3A_true_label">true_label</code></td>
<td>
<p>the true correspondence (if available)</p>
</td></tr>
<tr><td><code id="summary+2B2CgraphMatch-method_+3A_directed">directed</code></td>
<td>
<p>whether to treat the graphs as directed (TRUE) or not
directed (FALSE) default is NULL which will treat the graphs as directed if
either adjacency matrix is not symmetric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary</code> returns the graph matching formula, and a summary of
graph matching results including the number of matches, the number of
correct matches (if the true correspondence is available), and common
edges, missing edges, extra edges, common non-edges and the objective
function value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
graphs &lt;- sample_correlated_gnp_pair(20, .9, .3)
A &lt;- graphs$graph1
B &lt;- graphs$graph2
match &lt;- gm(A, B, 1:4, method = "percolation")

summary(match, A, B)
summary(match, A, B, true_label = 1:20) # also output the number of correct matches

</code></pre>

<hr>
<h2 id='Transportation'>Britain Transportation Network</h2><span id='topic+Transportation'></span>

<h3>Description</h3>

<p>The Britain Transportation Network reflects the transportation connections in
the UK, with five layers representing ferry, rail, metro, coach, and bus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Transportation)
</code></pre>


<h3>Format</h3>

<p>A list of length 3, corresponding to the template graph, world graph, and
candidate data frame with first column indicating template node ID's and second column
indicating world node ID's.
The template graph and world graph are stored as lists of five adjacency matrices,
representing ferry, rail, metro, coach, and bus transportation connections respectively.
</p>


<h3>Details</h3>

<p>The data consists of a smaller template graph with 53 nodes and 56 connections
across five layers, a larger world graph with candidates of the template graph
with 2075 nodes and 8368 connections, and a list of candidate matches for each
template node, where the true correspondence is guaranteed to be among the candidates.
</p>
<p>The template graph was constructed based on a random walk starting from a randomly
chosen hub node, a node that has connections in all the layers.
All edges in the template are common edges shared by two graphs, where 40%, 24.1%,
37.5%, 31.7% and 25.6% of edges in the world graph are in template for each layer.
All graphs are unweighted, directed, and do not have self-loops.
</p>


<h3>References</h3>

<p>Gallotti, R., Barthelemy, M. (2015). <em>The multilayer temporal
network of public transport in Great Britain.</em> Sci Data 2, 140056 .
https://doi.org/10.1038/sdata.2014.56.
</p>
<p>J. D. Moorman, Q. Chen, T. K. Tu, Z. M. Boyd and A. L. Bertozzi, (2018).
<em>Filtering Methods for Subgraph Matching on Multiplex Networks.</em> 2018 IEEE
International Conference on Big Data (Big Data), pp. 3980-3985,
doi: 10.1109/BigData.2018.8622566.
</p>


<h3>See Also</h3>

<p>The original Britain Transportation Network data is found here
math.bu.edu/people/sussman/data/Transportation.rda.
The template graph and world graph in the 'Transportation' data are
induced subgraphs of the original graphs , keeping only the candidate nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tm &lt;- Transportation[[1]]
cm &lt;- Transportation[[2]]
candidate &lt;- Transportation[[3]]
tn &lt;- nrow(tm[[1]])
wn &lt;- nrow(cm[[1]])
similarity &lt;- with(candidate, Matrix::sparseMatrix(i = tem, j = wor, x = 1,
                            dims = c(tn,wn)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
