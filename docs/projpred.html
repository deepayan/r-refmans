<!DOCTYPE html><html lang="en"><head><title>Help for package projpred</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {projpred}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#projpred-package'><p>Projection predictive feature selection</p></a></li>
<li><a href='#as_draws_matrix.projection'><p>Extract projected parameter draws and coerce to <code>draws_matrix</code> (see package</p>
<span class="pkg">posterior</span>)</a></li>
<li><a href='#as.matrix.projection'><p>Extract projected parameter draws and coerce to matrix</p></a></li>
<li><a href='#augdat_ilink_binom'><p>Inverse-link function for augmented-data projection with binomial family</p></a></li>
<li><a href='#augdat_link_binom'><p>Link function for augmented-data projection with binomial family</p></a></li>
<li><a href='#augdat-internals'><p>Augmented-data projection: Internals</p></a></li>
<li><a href='#break_up_matrix_term'><p>Break up matrix terms</p></a></li>
<li><a href='#cl_agg'><p>Weighted averaging within clusters of parameter draws</p></a></li>
<li><a href='#cv_proportions'><p>Ranking proportions from fold-wise predictor rankings</p></a></li>
<li><a href='#cv_varsel'><p>Run search and performance evaluation with cross-validation</p></a></li>
<li><a href='#cv-indices'><p>Create cross-validation folds</p></a></li>
<li><a href='#df_binom'><p>Binomial toy example</p></a></li>
<li><a href='#df_gaussian'><p>Gaussian toy example</p></a></li>
<li><a href='#do_call'><p>Execute a function call</p></a></li>
<li><a href='#extend_family'><p>Extend a family</p></a></li>
<li><a href='#extra-families'><p>Extra family objects</p></a></li>
<li><a href='#force_search_terms'><p>Force search terms</p></a></li>
<li><a href='#mesquite'><p>Mesquite data set</p></a></li>
<li><a href='#performances'><p>Predictive performance results</p></a></li>
<li><a href='#plot.cv_proportions'><p>Plot ranking proportions from fold-wise predictor rankings</p></a></li>
<li><a href='#plot.vsel'><p>Plot predictive performance</p></a></li>
<li><a href='#pred-projection'><p>Predictions from a submodel (after projection)</p></a></li>
<li><a href='#predict.refmodel'><p>Predictions or log posterior predictive densities from a reference model</p></a></li>
<li><a href='#predictor_terms'><p>Predictor terms used in a <code>project()</code> run</p></a></li>
<li><a href='#print.projection'><p>Print information about <code>project()</code> output</p></a></li>
<li><a href='#print.refmodel'><p>Print information about a reference model object</p></a></li>
<li><a href='#print.vsel'><p>Print results (summary) of a <code>varsel()</code> or <code>cv_varsel()</code> run</p></a></li>
<li><a href='#print.vselsummary'><p>Print summary of a <code>varsel()</code> or <code>cv_varsel()</code> run</p></a></li>
<li><a href='#project'><p>Projection onto submodel(s)</p></a></li>
<li><a href='#ranking'><p>Predictor ranking(s)</p></a></li>
<li><a href='#refmodel-init-get'><p>Reference model and more general information</p></a></li>
<li><a href='#run_cvfun'><p>Create <code>cvfits</code> from <code>cvfun</code></p></a></li>
<li><a href='#solution_terms'><p>Retrieve the full-data solution path from a <code>varsel()</code> or <code>cv_varsel()</code> run</p>
or the predictor combination from a <code>project()</code> run</a></li>
<li><a href='#suggest_size'><p>Suggest submodel size</p></a></li>
<li><a href='#summary.vsel'><p>Summary of a <code>varsel()</code> or <code>cv_varsel()</code> run</p></a></li>
<li><a href='#varsel'><p>Run search and performance evaluation without cross-validation</p></a></li>
<li><a href='#y_wobs_offs'><p>Extract response values, observation weights, and offsets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Projection Predictive Feature Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>2.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-14</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Performs projection predictive feature selection for generalized linear
    models (Piironen, Paasiniemi, and Vehtari, 2020, &lt;<a href="https://doi.org/10.1214%2F20-EJS1711">doi:10.1214/20-EJS1711</a>&gt;)
    with or without multilevel or additive terms (Catalina, Bürkner, and
    Vehtari, 2022, <a href="https://proceedings.mlr.press/v151/catalina22a.html">https://proceedings.mlr.press/v151/catalina22a.html</a>), for
    some ordinal and nominal regression models (Weber, Glass, and Vehtari, 2023,
    &lt;<a href="https://doi.org/10.48550/arXiv.2301.01660">doi:10.48550/arXiv.2301.01660</a>&gt;), and for many other regression models (using the latent
    projection by Catalina, Bürkner, and Vehtari, 2021, &lt;<a href="https://doi.org/10.48550/arXiv.2109.04702">doi:10.48550/arXiv.2109.04702</a>&gt;,
    which can also be applied to most of the former models). The package is
    compatible with the 'rstanarm' and 'brms' packages, but other reference
    models can also be used. See the vignettes and the documentation for more
    information and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/projpred/">https://mc-stan.org/projpred/</a>, <a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stan-dev/projpred/issues/">https://github.com/stan-dev/projpred/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, Rcpp, gtools, ggplot2, scales, rstantools (&ge;
2.0.0), loo (&ge; 2.0.0), lme4 (&ge; 1.1-28), mvtnorm, mgcv, gamm4,
abind, MASS, ordinal, nnet, mclogit</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggrepel, rstanarm, brms, nlme, optimx, ucminf, parallel,
foreach, iterators, doRNG, unix, testthat, vdiffr, knitr,
rmarkdown, glmnet, cmdstanr, rlang, bayesplot (&ge; 1.5.0),
posterior, doParallel, future, future.callr, doFuture</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 16:47:45 UTC; frank</td>
</tr>
<tr>
<td>Author:</td>
<td>Juho Piironen [aut],
  Markus Paasiniemi [aut],
  Alejandro Catalina [aut],
  Frank Weber [cre, aut],
  Aki Vehtari [aut],
  Jonah Gabry [ctb],
  Marco Colombo [ctb],
  Paul-Christian Bürkner [ctb],
  Hamada S. Badr [ctb],
  Brian Sullivan [ctb],
  Sölvi Rögnvaldsson [ctb],
  The LME4 Authors [cph] (see file 'LICENSE' for details),
  Yann McLatchie [ctb],
  Juho Timonen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frank Weber &lt;fweber144@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='projpred-package'>Projection predictive feature selection</h2><span id='topic+projpred'></span><span id='topic+projpred-package'></span>

<h3>Description</h3>

<p>The <span class="rlang"><b>R</b></span> package <span class="pkg">projpred</span> performs the projection predictive variable (or
&quot;feature&quot;) selection for various regression models. We recommend to read the
<code>README</code> file (available with enhanced formatting
<a href="https://mc-stan.org/projpred/">online</a>) and the main vignette (<code>topic = "projpred"</code>, but also available
<a href="https://mc-stan.org/projpred/articles/projpred.html">online</a>) before
continuing here.
</p>


<h3>Terminology</h3>

<p>Throughout the whole package documentation, we use the term &quot;submodel&quot; for
all kinds of candidate models onto which the reference model is projected.
For custom reference models, the candidate models don't need to be actual
<em>sub</em>models of the reference model, but in any case (even for custom
reference models), the candidate models are always actual <em>sub</em>models of the
full <code><a href="stats.html#topic+formula">formula</a></code> used by the search procedure. In this regard, it is correct
to speak of <em>sub</em>models, even in case of a custom reference model.
</p>
<p>The following model type abbreviations will be used at multiple places
throughout the documentation: GLM (generalized linear model), GLMM
(generalized linear multilevel&mdash;or &quot;mixed&quot;&mdash;model), GAM (generalized
additive model), and GAMM (generalized additive multilevel&mdash;or
&quot;mixed&quot;&mdash;model). Note that the term &quot;generalized&quot; includes the Gaussian
family as well.
</p>


<h3>Draw-wise divergence minimizers</h3>

<p>For the projection of the reference model onto a submodel, <span class="pkg">projpred</span>
currently relies on the following functions as draw-wise divergence
minimizers (in other words, these are the workhorse functions employed by
<span class="pkg">projpred</span>'s internal default <code>div_minimizer</code> functions, see
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>):
</p>

<ul>
<li><p> Submodel without multilevel or additive terms:
</p>

<ul>
<li><p> For the traditional (or latent) projection (or the augmented-data
projection in case of the <code><a href="stats.html#topic+binomial">binomial()</a></code> or <code><a href="brms.html#topic+brmsfamily">brms::bernoulli()</a></code> family): An
internal C++ function which basically serves the same purpose as <code><a href="stats.html#topic+lm">lm()</a></code>
for the <code><a href="stats.html#topic+gaussian">gaussian()</a></code> family and <code><a href="stats.html#topic+glm">glm()</a></code> for all other families. The
returned object inherits from class <code>subfit</code>. Possible tuning parameters
for this internal C++ function are: <code>regul</code> (amount of ridge
regularization; default: <code>1e-4</code>), <code>thresh_conv</code> (convergence threshold;
default: <code>1e-7</code>), <code>qa_updates_max</code> (maximum number of quadratic
approximation updates; default: <code>100</code>, but fixed to <code>1</code> in case of the
Gaussian family with identity link), <code>ls_iter_max</code> (maximum number of
line search iterations; default: <code>30</code>, but fixed to <code>1</code> in case of the
Gaussian family with identity link), <code>normalize</code> (single logical value
indicating whether to scale the predictors internally with the returned
regression coefficient estimates being back-adjusted appropriately;
default: <code>TRUE</code>), <code>beta0_init</code> (single numeric value giving the starting
value for the intercept at centered predictors; default: <code>0</code>), and
<code>beta_init</code> (numeric vector giving the starting values for the regression
coefficients; default: vector of <code>0</code>s).
</p>
</li>
<li><p> For the augmented-data projection: <code><a href="MASS.html#topic+polr">MASS::polr()</a></code> (the returned object
inherits from class <code>polr</code>) for the <code><a href="brms.html#topic+brmsfamily">brms::cumulative()</a></code> family or
<code><a href="rstanarm.html#topic+stan_polr">rstanarm::stan_polr()</a></code> fits, <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code> (the returned object
inherits from class <code>multinom</code>) for the <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> family.
</p>
</li></ul>

</li>
<li><p> Submodel with multilevel but no additive terms:
</p>

<ul>
<li><p> For the traditional (or latent) projection (or the augmented-data
projection in case of the <code><a href="stats.html#topic+binomial">binomial()</a></code> or <code><a href="brms.html#topic+brmsfamily">brms::bernoulli()</a></code> family):
<code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code> (the returned object inherits from class <code>lmerMod</code>) for
the <code><a href="stats.html#topic+gaussian">gaussian()</a></code> family, <code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code> (the returned object inherits
from class <code>glmerMod</code>) for all other families.
</p>
</li>
<li><p> For the augmented-data projection: <code><a href="ordinal.html#topic+clmm">ordinal::clmm()</a></code> (the returned
object inherits from class <code>clmm</code>) for the <code><a href="brms.html#topic+brmsfamily">brms::cumulative()</a></code> family,
<code><a href="mclogit.html#topic+mblogit">mclogit::mblogit()</a></code> (the returned object inherits from class <code>mmblogit</code>)
for the <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> family.
</p>
</li></ul>

</li>
<li><p> Submodel without multilevel but additive terms: <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> (the returned
object inherits from class <code>gam</code>).
</p>
</li>
<li><p> Submodel with multilevel and additive terms: <code><a href="gamm4.html#topic+gamm4">gamm4::gamm4()</a></code> (within
<span class="pkg">projpred</span>, the returned object inherits from class <code>gamm4</code>).
</p>
</li></ul>



<h3>Verbosity, messages, warnings, errors</h3>

<p>Setting global option <code>projpred.extra_verbose</code> to <code>TRUE</code> will print out which
submodel <span class="pkg">projpred</span> is currently projecting onto as well as (if <code>method = "forward"</code> and <code>verbose = TRUE</code> in <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>) which
submodel has been selected at those steps of the forward search for which a
percentage (of the maximum submodel size that the search is run up to) is
printed. In general, however, we cannot recommend setting this global option
to <code>TRUE</code> for <code><a href="#topic+cv_varsel">cv_varsel()</a></code> with <code>validate_search = TRUE</code> (simply due to the
amount of information that will be printed, but also due to the progress bar
which will not work as intended anymore).
</p>
<p>By default, <span class="pkg">projpred</span> catches messages and warnings from the draw-wise
divergence minimizers and throws their unique collection after performing all
draw-wise divergence minimizations (i.e., draw-wise projections). This can be
deactivated by setting global option <code>projpred.warn_prj_drawwise</code> to <code>FALSE</code>.
</p>
<p>Furthermore, by default, <span class="pkg">projpred</span> checks the convergence of the
draw-wise divergence minimizers and throws a warning if any seem to have not
converged. This warning is thrown after the warning message from global
option <code>projpred.warn_prj_drawwise</code> (see above) and can be deactivated by
setting global option <code>projpred.check_conv</code> to <code>FALSE</code>.
</p>


<h3>Parallelization</h3>

<p>The projection of the reference model onto a submodel can be run in parallel
(across the projected draws). This is powered by the <span class="pkg">foreach</span> package.
Thus, any parallel (or sequential) backend compatible with <span class="pkg">foreach</span> can
be used, e.g., the backends from packages <span class="pkg">doParallel</span>, <span class="pkg">doMPI</span>, or
<span class="pkg">doFuture</span>. Using the global option <code>projpred.prll_prj_trigger</code>, the
number of projected draws below which no parallelization is applied (even if
a parallel backend is registered) can be modified. Such a &quot;trigger&quot; threshold
exists because of the computational overhead of a parallelization which makes
the projection parallelization only useful for a sufficiently large number of
projected draws. By default, the projection parallelization is turned off,
which can also be achieved by supplying <code>Inf</code> (or <code>NULL</code>) to option
<code>projpred.prll_prj_trigger</code>. Note that we cannot recommend the projection
parallelization on Windows because in our experience, the parallelization
overhead is larger there, causing a parallel run to take longer than a
sequential run. Also note that the projection parallelization works well for
submodels which are GLMs (and hence also for the latent projection if the
submodel has no multilevel or additive predictor terms), but for all other
types of submodels, the fitted submodel objects are quite big, which&mdash;when
running in parallel&mdash;may lead to excessive memory usage which in turn may
crash the R session (on Unix systems, setting an appropriate memory limit via
<code><a href="unix.html#topic+rlimit">unix::rlimit_as()</a></code> may avoid crashing the whole machine). Thus, we currently
cannot recommend parallelizing projections onto submodels which are GLMs (in
this context, the latent projection onto a submodel without multilevel and
without additive terms may be regarded as a projection onto a submodel which
is a GLM). However, for <code><a href="#topic+cv_varsel">cv_varsel()</a></code>, there is also a <em>CV</em> parallelization
(i.e., a parallelization of <span class="pkg">projpred</span>'s cross-validation) which can be
activated via argument <code>parallel</code>.
</p>


<h3>Multilevel models: &quot;Integrating out&quot; group-level effects</h3>

<p>In case of multilevel models, <span class="pkg">projpred</span> offers two global options for
&quot;integrating out&quot; group-level effects: <code>projpred.mlvl_pred_new</code> and
<code>projpred.mlvl_proj_ref_new</code>. When setting <code>projpred.mlvl_pred_new</code> to <code>TRUE</code>
(default is <code>FALSE</code>), then at
<em>prediction</em> time, <span class="pkg">projpred</span> will treat group levels existing in the
training data as <em>new</em> group levels, implying that their group-level effects
are drawn randomly from a (multivariate) Gaussian distribution. This concerns
both, the reference model and the (i.e., any) submodel. Furthermore, setting
<code>projpred.mlvl_pred_new</code> to <code>TRUE</code> causes <code><a href="#topic+as.matrix.projection">as.matrix.projection()</a></code> and
<code><a href="#topic+as_draws_matrix.projection">as_draws_matrix.projection()</a></code> to omit the projected group-level effects (for
the group levels from the original dataset). When setting
<code>projpred.mlvl_proj_ref_new</code> to <code>TRUE</code> (default is <code>FALSE</code>), then at
<em>projection</em> time, the reference model's fitted values (that the submodels
fit to) will be computed by treating the group levels from the original
dataset as <em>new</em> group levels, implying that their group-level effects will
be drawn randomly from a (multivariate) Gaussian distribution (as long as the
reference model is a multilevel model, which&mdash;for custom reference
models&mdash;does not need to be the case). This also affects the latent response
values for a latent projection correspondingly. Setting
<code>projpred.mlvl_pred_new</code> to <code>TRUE</code> makes sense, e.g., when the prediction
task is such that any group level will be treated as a new one. Typically,
setting <code>projpred.mlvl_proj_ref_new</code> to <code>TRUE</code> only makes sense when
<code>projpred.mlvl_pred_new</code> is already set to <code>TRUE</code>. In that case, the default
of <code>FALSE</code> for <code>projpred.mlvl_proj_ref_new</code> ensures that at projection time,
the submodels fit to the best possible fitted values from the reference
model, and setting <code>projpred.mlvl_proj_ref_new</code> to <code>TRUE</code> would make sense if
the group-level effects should be integrated out completely.
</p>


<h3>Memory usage</h3>

<p>By setting the global option <code>projpred.run_gc</code> to <code>TRUE</code>, <span class="pkg">projpred</span> will
call <code><a href="base.html#topic+gc">gc()</a></code> at some places (e.g., after each size that the forward search
passes through) to free up some memory. These <code><a href="base.html#topic+gc">gc()</a></code> calls are not always
necessary to reduce the peak memory usage, but they add runtime (hence the
default of <code>FALSE</code> for that global option).
</p>


<h3>Other notes</h3>

<p>Most examples are not executed when called via <code><a href="utils.html#topic+example">example()</a></code>. To execute them,
their code has to be copied and pasted manually to the console.
</p>


<h3>Functions</h3>


<dl>
<dt><code><a href="#topic+init_refmodel">init_refmodel()</a></code>, <code><a href="#topic+get_refmodel">get_refmodel()</a></code></dt><dd><p>For setting up an object
containing information about the reference model, the submodels, and how
the projection should be carried out. Explicit calls to <code><a href="#topic+init_refmodel">init_refmodel()</a></code>
and <code><a href="#topic+get_refmodel">get_refmodel()</a></code> are only rarely needed.</p>
</dd>
<dt><code><a href="#topic+varsel">varsel()</a></code>, <code><a href="#topic+cv_varsel">cv_varsel()</a></code></dt><dd><p>For running the <em>search</em> part and the
<em>evaluation</em> part for a projection predictive variable selection, possibly
with cross-validation (CV).</p>
</dd>
<dt><code><a href="#topic+summary.vsel">summary.vsel()</a></code>, <code><a href="#topic+print.vsel">print.vsel()</a></code>, <code><a href="#topic+plot.vsel">plot.vsel()</a></code>,
<code><a href="#topic+suggest_size.vsel">suggest_size.vsel()</a></code>, <code><a href="#topic+ranking">ranking()</a></code>, <code><a href="#topic+cv_proportions">cv_proportions()</a></code>,
<code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>, <code><a href="#topic+performances">performances()</a></code></dt><dd><p>For post-processing the results
from <code><a href="#topic+varsel">varsel()</a></code> and <code><a href="#topic+cv_varsel">cv_varsel()</a></code>.</p>
</dd>
<dt><code><a href="#topic+project">project()</a></code></dt><dd><p>For projecting the reference model onto submodel(s).
Typically, this follows the variable selection, but it can also be applied
directly (without a variable selection).</p>
</dd>
<dt><code><a href="#topic+as.matrix.projection">as.matrix.projection()</a></code> and <code><a href="#topic+as_draws_matrix.projection">as_draws_matrix.projection()</a></code></dt><dd><p>For
extracting projected parameter draws.</p>
</dd>
<dt><code><a href="#topic+proj_linpred">proj_linpred()</a></code>, <code><a href="#topic+proj_predict">proj_predict()</a></code></dt><dd><p>For making predictions from a
submodel (after projecting the reference model onto it).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Frank Weber <a href="mailto:fweber144@protonmail.com">fweber144@protonmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Juho Piironen <a href="mailto:juho.t.piironen@gmail.com">juho.t.piironen@gmail.com</a>
</p>
</li>
<li><p> Markus Paasiniemi
</p>
</li>
<li><p> Alejandro Catalina <a href="mailto:alecatfel@gmail.com">alecatfel@gmail.com</a>
</p>
</li>
<li><p> Aki Vehtari
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jonah Gabry [contributor]
</p>
</li>
<li><p> Marco Colombo [contributor]
</p>
</li>
<li><p> Paul-Christian Bürkner [contributor]
</p>
</li>
<li><p> Hamada S. Badr [contributor]
</p>
</li>
<li><p> Brian Sullivan [contributor]
</p>
</li>
<li><p> Sölvi Rögnvaldsson [contributor]
</p>
</li>
<li><p>  The LME4 Authors (see file 'LICENSE' for details) [copyright holder]
</p>
</li>
<li><p> Yann McLatchie [contributor]
</p>
</li>
<li><p> Juho Timonen [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mc-stan.org/projpred/">https://mc-stan.org/projpred/</a>
</p>
</li>
<li> <p><a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stan-dev/projpred/issues/">https://github.com/stan-dev/projpred/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='as_draws_matrix.projection'>Extract projected parameter draws and coerce to <code>draws_matrix</code> (see package
<span class="pkg">posterior</span>)</h2><span id='topic+as_draws_matrix.projection'></span><span id='topic+as_draws.projection'></span>

<h3>Description</h3>

<p>These are the <code><a href="posterior.html#topic+draws">posterior::as_draws()</a></code> and <code><a href="posterior.html#topic+draws_matrix">posterior::as_draws_matrix()</a></code>
methods for <code>projection</code> objects (returned by <code><a href="#topic+project">project()</a></code>, possibly as
elements of a <code>list</code>). They extract the projected parameter draws and return
them as a <code>draws_matrix</code>. In case of different (i.e., nonconstant) weights
for the projected draws, a <code>draws_matrix</code> allows for a safer handling of
these weights (safer in contrast to the matrix returned by
<code><a href="#topic+as.matrix.projection">as.matrix.projection()</a></code>), in particular by providing the natural input for
<code><a href="posterior.html#topic+resample_draws">posterior::resample_draws()</a></code> (see section &quot;Examples&quot; below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projection'
as_draws_matrix(x, ...)

## S3 method for class 'projection'
as_draws(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_draws_matrix.projection_+3A_x">x</code></td>
<td>
<p>An object of class <code>projection</code> (returned by <code><a href="#topic+project">project()</a></code>, possibly
as elements of a <code>list</code>).</p>
</td></tr>
<tr><td><code id="as_draws_matrix.projection_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.matrix.projection">as.matrix.projection()</a></code>, except for
<code>allow_nonconst_wdraws_prj</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of the augmented-data projection for a multilevel submodel
of a <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> reference model, the multilevel parameters (and
therefore also their names) slightly differ from those in the <span class="pkg">brms</span>
reference model fit (see section &quot;Augmented-data projection&quot; in
<code><a href="#topic+extend_family">extend_family()</a></code>'s documentation).
</p>


<h3>Value</h3>

<p>An <code class="reqn">S_{\mathrm{prj}} \times Q</code> <code>draws_matrix</code> (see
<code><a href="posterior.html#topic+draws_matrix">posterior::draws_matrix()</a></code>) of projected draws, with
<code class="reqn">S_{\mathrm{prj}}</code> denoting the number of projected draws and
<code class="reqn">Q</code> the number of parameters. If the projected draws have nonconstant
weights, <code><a href="posterior.html#topic+weight_draws">posterior::weight_draws()</a></code> is applied internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Projection onto an arbitrary combination of predictor terms (with a small
# value for `nclusters`, but only for illustrative purposes; this is not
# recommended in general):
prj &lt;- project(fit, predictor_terms = c("X1", "X3", "X5"), nclusters = 5,
               seed = 9182)

# Applying the posterior::as_draws_matrix() generic to the output of
# project() dispatches to the projpred::as_draws_matrix.projection()
# method:
prj_draws &lt;- posterior::as_draws_matrix(prj)

# Resample the projected draws according to their weights:
set.seed(3456)
prj_draws_resampled &lt;- posterior::resample_draws(prj_draws, ndraws = 1000)

# The values from the following two objects should be the same (in general,
# this only holds approximately):
print(proportions(table(rownames(prj_draws_resampled))))
print(weights(prj_draws))

# Treat the resampled draws like ordinary draws, e.g., summarize them:
print(posterior::summarize_draws(
  prj_draws_resampled,
  "median", "mad", function(x) quantile(x, probs = c(0.025, 0.975))
))
# Or visualize them using the `bayesplot` package:
if (requireNamespace("bayesplot", quietly = TRUE)) {
  print(bayesplot::mcmc_intervals(prj_draws_resampled))
}

</code></pre>

<hr>
<h2 id='as.matrix.projection'>Extract projected parameter draws and coerce to matrix</h2><span id='topic+as.matrix.projection'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+as.matrix">as.matrix()</a></code> method for <code>projection</code> objects (returned by
<code><a href="#topic+project">project()</a></code>, possibly as elements of a <code>list</code>). It extracts the projected
parameter draws and returns them as a matrix. In case of different (i.e.,
nonconstant) weights for the projected draws, see
<code><a href="#topic+as_draws_matrix.projection">as_draws_matrix.projection()</a></code> for a better solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projection'
as.matrix(x, nm_scheme = NULL, allow_nonconst_wdraws_prj = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.projection_+3A_x">x</code></td>
<td>
<p>An object of class <code>projection</code> (returned by <code><a href="#topic+project">project()</a></code>, possibly
as elements of a <code>list</code>).</p>
</td></tr>
<tr><td><code id="as.matrix.projection_+3A_nm_scheme">nm_scheme</code></td>
<td>
<p>The naming scheme for the columns of the output matrix.
Either <code>NULL</code>, <code>"rstanarm"</code>, or <code>"brms"</code>, where <code>NULL</code> chooses <code>"rstanarm"</code>
or <code>"brms"</code> based on the class of the reference model fit (and uses
<code>"rstanarm"</code> if the reference model fit is of an unknown class).</p>
</td></tr>
<tr><td><code id="as.matrix.projection_+3A_allow_nonconst_wdraws_prj">allow_nonconst_wdraws_prj</code></td>
<td>
<p>A single logical value indicating whether to
allow projected draws with different (i.e., nonconstant) weights (<code>TRUE</code>)
or not (<code>FALSE</code>). <strong>CAUTION</strong>: Expert use only because if set to <code>TRUE</code>,
the weights of the projected draws are stored in an attribute <code>wdraws_prj</code>
and handling this attribute requires special care (e.g., when subsetting
the returned matrix).</p>
</td></tr>
<tr><td><code id="as.matrix.projection_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of the augmented-data projection for a multilevel submodel
of a <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> reference model, the multilevel parameters (and
therefore also their names) slightly differ from those in the <span class="pkg">brms</span>
reference model fit (see section &quot;Augmented-data projection&quot; in
<code><a href="#topic+extend_family">extend_family()</a></code>'s documentation).
</p>


<h3>Value</h3>

<p>An <code class="reqn">S_{\mathrm{prj}} \times Q</code> matrix of projected
draws, with <code class="reqn">S_{\mathrm{prj}}</code> denoting the number of projected
draws and <code class="reqn">Q</code> the number of parameters. If <code>allow_nonconst_wdraws_prj</code>
is set to <code>TRUE</code>, the weights of the projected draws are stored in an
attribute <code>wdraws_prj</code>. (If <code>allow_nonconst_wdraws_prj</code> is <code>FALSE</code>,
projected draws with nonconstant weights cause an error.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Projection onto an arbitrary combination of predictor terms (with a small
# value for `ndraws`, but only for the sake of speed in this example; this
# is not recommended in general):
prj &lt;- project(fit, predictor_terms = c("X1", "X3", "X5"), ndraws = 21,
               seed = 9182)

# Applying the as.matrix() generic to the output of project() dispatches to
# the projpred::as.matrix.projection() method:
prj_mat &lt;- as.matrix(prj)

# Since the draws have all the same weight here, we can treat them like
# ordinary MCMC draws, e.g., we can summarize them using the `posterior`
# package:
if (requireNamespace("posterior", quietly = TRUE)) {
  print(posterior::summarize_draws(
    posterior::as_draws_matrix(prj_mat),
    "median", "mad", function(x) quantile(x, probs = c(0.025, 0.975))
  ))
}
# Or visualize them using the `bayesplot` package:
if (requireNamespace("bayesplot", quietly = TRUE)) {
  print(bayesplot::mcmc_intervals(prj_mat))
}

</code></pre>

<hr>
<h2 id='augdat_ilink_binom'>Inverse-link function for augmented-data projection with binomial family</h2><span id='topic+augdat_ilink_binom'></span>

<h3>Description</h3>

<p>This is the function which has to be supplied to <code><a href="#topic+extend_family">extend_family()</a></code>'s argument
<code>augdat_ilink</code> in case of the augmented-data projection for the <code><a href="stats.html#topic+binomial">binomial()</a></code>
family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augdat_ilink_binom(eta_arr, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augdat_ilink_binom_+3A_eta_arr">eta_arr</code></td>
<td>
<p>An array as described in section &quot;Augmented-data projection&quot;
of <code><a href="#topic+extend_family">extend_family()</a></code>'s documentation.</p>
</td></tr>
<tr><td><code id="augdat_ilink_binom_+3A_link">link</code></td>
<td>
<p>The same as argument <code>link</code> of <code><a href="stats.html#topic+binomial">binomial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array as described in section &quot;Augmented-data projection&quot; of
<code><a href="#topic+extend_family">extend_family()</a></code>'s documentation.
</p>

<hr>
<h2 id='augdat_link_binom'>Link function for augmented-data projection with binomial family</h2><span id='topic+augdat_link_binom'></span>

<h3>Description</h3>

<p>This is the function which has to be supplied to <code><a href="#topic+extend_family">extend_family()</a></code>'s argument
<code>augdat_link</code> in case of the augmented-data projection for the <code><a href="stats.html#topic+binomial">binomial()</a></code>
family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augdat_link_binom(prb_arr, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augdat_link_binom_+3A_prb_arr">prb_arr</code></td>
<td>
<p>An array as described in section &quot;Augmented-data projection&quot;
of <code><a href="#topic+extend_family">extend_family()</a></code>'s documentation.</p>
</td></tr>
<tr><td><code id="augdat_link_binom_+3A_link">link</code></td>
<td>
<p>The same as argument <code>link</code> of <code><a href="stats.html#topic+binomial">binomial()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array as described in section &quot;Augmented-data projection&quot; of
<code><a href="#topic+extend_family">extend_family()</a></code>'s documentation.
</p>

<hr>
<h2 id='augdat-internals'>Augmented-data projection: Internals</h2><span id='topic+augdat-internals'></span>

<h3>Description</h3>

<p>The augmented-data projection makes extensive use of <em>augmented-rows
matrices</em> and <em>augmented-length vectors</em>. In the following, <code class="reqn">N</code>,
<code class="reqn">C_{\mathrm{cat}}</code>, <code class="reqn">C_{\mathrm{lat}}</code>,
<code class="reqn">S_{\mathrm{ref}}</code>, and <code class="reqn">S_{\mathrm{prj}}</code> from help
topic <a href="#topic+refmodel-init-get">refmodel-init-get</a> are used. Furthermore, let <code class="reqn">C</code> denote either
<code class="reqn">C_{\mathrm{cat}}</code> or <code class="reqn">C_{\mathrm{lat}}</code>, whichever is
appropriate in the context where it is used (e.g., for <code>ref_predfun</code>'s
output, <code class="reqn">C = C_{\mathrm{lat}}</code>). Similarly, let <code class="reqn">S</code> denote
either <code class="reqn">S_{\mathrm{ref}}</code> or <code class="reqn">S_{\mathrm{prj}}</code>,
whichever is appropriate in the context where it is used. Then an
augmented-rows matrix is a matrix with <code class="reqn">N \cdot C</code> rows in <code class="reqn">C</code>
blocks of <code class="reqn">N</code> rows, i.e., with the <code class="reqn">N</code> observations nested in the
<code class="reqn">C</code> (possibly latent) response categories. For ordered response
categories, the <code class="reqn">C</code> (possibly latent) response categories (i.e., the row
blocks) have to be sorted increasingly. The columns of an augmented-rows
matrix have to correspond to the <code class="reqn">S</code> parameter draws, just like for the
traditional projection. An augmented-rows matrix is of class <code>augmat</code>
(inheriting from classes <code>matrix</code> and <code>array</code>) and needs to have the value of
<code class="reqn">C</code> stored in an attribute called <code>ndiscrete</code>. An augmented-length vector
(class <code>augvec</code>) is the vector resulting from subsetting an augmented-rows
matrix to extract a single column and thereby dropping dimensions.
</p>

<hr>
<h2 id='break_up_matrix_term'>Break up matrix terms</h2><span id='topic+break_up_matrix_term'></span>

<h3>Description</h3>

<p>Sometimes there can be terms in a formula that refer to a matrix instead of a
single predictor. This function breaks up the matrix term into individual
predictors to handle separately, as that is probably the intention of the
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>break_up_matrix_term(formula, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="break_up_matrix_term_+3A_formula">formula</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> for a valid model.</p>
</td></tr>
<tr><td><code id="break_up_matrix_term_+3A_data">data</code></td>
<td>
<p>The original <code>data.frame</code> with a matrix as predictor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the expanded <code><a href="stats.html#topic+formula">formula</a></code> and the expanded
<code>data.frame</code>.
</p>

<hr>
<h2 id='cl_agg'>Weighted averaging within clusters of parameter draws</h2><span id='topic+cl_agg'></span>

<h3>Description</h3>

<p>This function aggregates <code class="reqn">S</code> parameter draws that have been clustered
into <code class="reqn">S_{\mathrm{cl}}</code> clusters by averaging across the draws that
belong to the same cluster. This averaging can be done in a weighted fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl_agg(
  draws,
  cl = seq_len(nrow(draws)),
  wdraws = rep(1, nrow(draws)),
  eps_wdraws = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl_agg_+3A_draws">draws</code></td>
<td>
<p>An <code class="reqn">S \times P</code> matrix of parameter draws, with
<code class="reqn">P</code> denoting the number of parameters.</p>
</td></tr>
<tr><td><code id="cl_agg_+3A_cl">cl</code></td>
<td>
<p>A numeric vector of length <code class="reqn">S</code>, giving the cluster indices for
the draws. The cluster indices need to be values from the set <code class="reqn">\{1,
  ..., S_{\mathrm{cl}}\}</code>, except for draws that should be
dropped (e.g., by thinning), in which case <code>NA</code> needs to be provided at the
positions of <code>cl</code> corresponding to these draws.</p>
</td></tr>
<tr><td><code id="cl_agg_+3A_wdraws">wdraws</code></td>
<td>
<p>A numeric vector of length <code class="reqn">S</code>, giving the weights of the
draws. It doesn't matter whether these are normalized (i.e., sum to <code>1</code>) or
not because internally, these weights are normalized to sum to <code>1</code> within
each cluster. Draws that should be dropped (e.g., by thinning) can (but
must not necessarily) have an <code>NA</code> in <code>wdraws</code>.</p>
</td></tr>
<tr><td><code id="cl_agg_+3A_eps_wdraws">eps_wdraws</code></td>
<td>
<p>A positive numeric value (typically small) which will be
used to improve numerical stability: The weights of the draws within each
cluster are multiplied by <code>1 - eps_wdraws</code>. The default of <code>0</code> should be
fine for most cases; this argument only exists to help in those cases where
numerical instabilities occur (which must be detected by the user; this
function will not detect numerical instabilities itself).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">S_{\mathrm{cl}} \times P</code> matrix of aggregated
parameter draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(323)
S &lt;- 100L
P &lt;- 3L
draws &lt;- matrix(rnorm(S * P), nrow = S, ncol = P)
# Clustering example:
S_cl &lt;- 10L
cl_draws &lt;- sample.int(S_cl, size = S, replace = TRUE)
draws_cl &lt;- cl_agg(draws, cl = cl_draws)
# Clustering example with nonconstant `wdraws`:
w_draws &lt;- rgamma(S, shape = 4)
draws_cl &lt;- cl_agg(draws, cl = cl_draws, wdraws = w_draws)
# Thinning example (implying constant `wdraws`):
S_th &lt;- 50L
idxs_thin &lt;- round(seq(1, S, length.out = S_th))
th_draws &lt;- rep(NA, S)
th_draws[idxs_thin] &lt;- seq_len(S_th)
draws_th &lt;- cl_agg(draws, cl = th_draws)

</code></pre>

<hr>
<h2 id='cv_proportions'>Ranking proportions from fold-wise predictor rankings</h2><span id='topic+cv_proportions'></span><span id='topic+cv_proportions.ranking'></span><span id='topic+cv_proportions.vsel'></span>

<h3>Description</h3>

<p>Calculates the <em>ranking proportions</em> from the fold-wise predictor rankings in
a cross-validation (CV) with fold-wise searches. For a given predictor
<code class="reqn">x</code> and a given submodel size <code class="reqn">j</code>, the ranking proportion is the
proportion of CV folds which have predictor <code class="reqn">x</code> at position <code class="reqn">j</code> of
their predictor ranking. While these ranking proportions are helpful for
investigating variability in the predictor ranking, they can also be
<em>cumulated</em> across submodel sizes. The cumulated ranking proportions are more
helpful when it comes to model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_proportions(object, ...)

## S3 method for class 'ranking'
cv_proportions(object, cumulate = FALSE, ...)

## S3 method for class 'vsel'
cv_proportions(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_proportions_+3A_object">object</code></td>
<td>
<p>For <code><a href="#topic+cv_proportions.ranking">cv_proportions.ranking()</a></code>: an object of class <code>ranking</code>
(returned by <code><a href="#topic+ranking">ranking()</a></code>). For <code><a href="#topic+cv_proportions.vsel">cv_proportions.vsel()</a></code>: an object of class
<code>vsel</code> (returned by <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>) that <code><a href="#topic+ranking">ranking()</a></code> will be
applied to internally before then calling <code><a href="#topic+cv_proportions.ranking">cv_proportions.ranking()</a></code>.</p>
</td></tr>
<tr><td><code id="cv_proportions_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+cv_proportions.vsel">cv_proportions.vsel()</a></code>: arguments passed to <code><a href="#topic+ranking.vsel">ranking.vsel()</a></code>
and <code><a href="#topic+cv_proportions.ranking">cv_proportions.ranking()</a></code>. For <code><a href="#topic+cv_proportions.ranking">cv_proportions.ranking()</a></code>: currently
ignored.</p>
</td></tr>
<tr><td><code id="cv_proportions_+3A_cumulate">cumulate</code></td>
<td>
<p>A single logical value indicating whether the ranking
proportions should be cumulated across increasing submodel sizes (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the ranking proportions. This matrix has
<code>nterms_max</code> rows and <code>nterms_max</code> columns, with <code>nterms_max</code> as specified
in the (possibly implicit) <code><a href="#topic+ranking">ranking()</a></code> call. The rows correspond to the
submodel sizes and the columns to the predictor terms (sorted according to
the full-data predictor ranking). If <code>cumulate</code> is <code>FALSE</code>, then the
returned matrix is of class <code>cv_proportions</code>. If <code>cumulate</code> is <code>TRUE</code>, then
the returned matrix is of classes <code>cv_proportions_cumul</code> and
<code>cv_proportions</code> (in this order).
</p>
<p>Note that if <code>cumulate</code> is <code>FALSE</code>, then the values in the returned matrix
only need to sum to 1 (column-wise and row-wise) if <code>nterms_max</code> (see
above) is equal to the full model size. Likewise, if <code>cumulate</code> is <code>TRUE</code>,
then the value <code>1</code> only needs to occur in each column of the returned
matrix if <code>nterms_max</code> is equal to the full model size.
</p>
<p>The <code><a href="#topic+cv_proportions">cv_proportions()</a></code> function is only applicable if the <code>ranking</code> object
includes fold-wise predictor rankings (i.e., if it is based on a <code>vsel</code>
object created by <code><a href="#topic+cv_varsel">cv_varsel()</a></code> with <code>validate_search = TRUE</code>). If the
<code>ranking</code> object contains only a full-data predictor ranking (i.e., if it
is based on a <code>vsel</code> object created by <code><a href="#topic+varsel">varsel()</a></code> or by <code><a href="#topic+cv_varsel">cv_varsel()</a></code>, but
the latter with <code>validate_search = FALSE</code>), then an error is thrown because
in that case, there are no fold-wise predictor rankings from which to
calculate ranking proportions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an example, see `?plot.cv_proportions`.

</code></pre>

<hr>
<h2 id='cv_varsel'>Run search and performance evaluation with cross-validation</h2><span id='topic+cv_varsel'></span><span id='topic+cv_varsel.default'></span><span id='topic+cv_varsel.vsel'></span><span id='topic+cv_varsel.refmodel'></span>

<h3>Description</h3>

<p>Run the <em>search</em> part and the <em>evaluation</em> part for a projection predictive
variable selection. The search part determines the predictor ranking (also
known as solution path), i.e., the best submodel for each submodel size
(number of predictor terms). The evaluation part determines the predictive
performance of the submodels along the predictor ranking. In contrast to
<code><a href="#topic+varsel">varsel()</a></code>, <code><a href="#topic+cv_varsel">cv_varsel()</a></code> performs a cross-validation (CV) by running the
search part with the training data of each CV fold separately (an exception
is explained in section &quot;Note&quot; below) and by running the evaluation part on
the corresponding test set of each CV fold. A special method is
<code><a href="#topic+cv_varsel.vsel">cv_varsel.vsel()</a></code> because it re-uses the search results from an earlier
<code><a href="#topic+cv_varsel">cv_varsel()</a></code> (or <code><a href="#topic+varsel">varsel()</a></code>) run, as illustrated in the main vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_varsel(object, ...)

## Default S3 method:
cv_varsel(object, ...)

## S3 method for class 'vsel'
cv_varsel(
  object,
  cv_method = object$cv_method %||% "LOO",
  nloo = object$nloo,
  K = object$K %||% if (!inherits(object, "datafit")) 5 else 10,
  cvfits = object$cvfits,
  validate_search = object$validate_search %||% TRUE,
  ...
)

## S3 method for class 'refmodel'
cv_varsel(
  object,
  method = "forward",
  cv_method = if (!inherits(object, "datafit")) "LOO" else "kfold",
  ndraws = NULL,
  nclusters = 20,
  ndraws_pred = 400,
  nclusters_pred = NULL,
  refit_prj = !inherits(object, "datafit"),
  nterms_max = NULL,
  penalty = NULL,
  verbose = TRUE,
  nloo = object$nobs,
  K = if (!inherits(object, "datafit")) 5 else 10,
  cvfits = object$cvfits,
  search_control = NULL,
  lambda_min_ratio = 1e-05,
  nlambda = 150,
  thresh = 1e-06,
  validate_search = TRUE,
  seed = NA,
  search_terms = NULL,
  search_out = NULL,
  parallel = getOption("projpred.prll_cv", FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_varsel_+3A_object">object</code></td>
<td>
<p>An object of class <code>refmodel</code> (returned by <code><a href="#topic+get_refmodel">get_refmodel()</a></code> or
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>) or an object that can be passed to argument <code>object</code> of
<code><a href="#topic+get_refmodel">get_refmodel()</a></code>.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+cv_varsel.default">cv_varsel.default()</a></code>: Arguments passed to <code><a href="#topic+get_refmodel">get_refmodel()</a></code> as
well as to <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>. For <code><a href="#topic+cv_varsel.vsel">cv_varsel.vsel()</a></code>: Arguments passed
to <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>. For <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>: Arguments passed to
the divergence minimizer (see argument <code>div_minimizer</code> of <code><a href="#topic+init_refmodel">init_refmodel()</a></code>
as well as section &quot;Draw-wise divergence minimizers&quot; of <a href="#topic+projpred-package">projpred-package</a>)
when refitting the submodels for the performance evaluation (if <code>refit_prj</code>
is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_cv_method">cv_method</code></td>
<td>
<p>The CV method, either <code>"LOO"</code> or <code>"kfold"</code>. In the <code>"LOO"</code>
case, a Pareto-smoothed importance sampling leave-one-out CV (PSIS-LOO CV)
is performed, which avoids refitting the reference model <code>nloo</code> times (in
contrast to a standard LOO CV). In the <code>"kfold"</code> case, a <code class="reqn">K</code>-fold CV is
performed. See also section &quot;Note&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_nloo">nloo</code></td>
<td>
<p><strong>Caution:</strong> Still experimental. Only relevant if <code>cv_method = "LOO"</code>. If <code>nloo</code> is smaller than the number of all observations,
approximate full LOO CV using probability-proportional-to-size-sampling
(PPS) to make accurate computation only for <code>nloo</code> (anything from 1 to the
number of all observations) leave-one-out folds (Magnusson et al., 2019).
Smaller values lead to faster computation but higher uncertainty in the
evaluation part. If <code>NULL</code>, all observations are used (as by default).</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_k">K</code></td>
<td>
<p>Only relevant if <code>cv_method = "kfold"</code> and if <code>cvfits</code> is <code>NULL</code>
(which is the case for reference model objects created by
<code><a href="#topic+get_refmodel.stanreg">get_refmodel.stanreg()</a></code> or <code><a href="brms.html#topic+get_refmodel.brmsfit">brms::get_refmodel.brmsfit()</a></code>). Number of
folds in <code class="reqn">K</code>-fold CV.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_cvfits">cvfits</code></td>
<td>
<p>Only relevant if <code>cv_method = "kfold"</code>. The same as argument
<code>cvfits</code> of <code><a href="#topic+init_refmodel">init_refmodel()</a></code>, but repeated here so that output from
<code><a href="#topic+run_cvfun">run_cvfun()</a></code> can be inserted here straightforwardly.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_validate_search">validate_search</code></td>
<td>
<p>A single logical value indicating whether to
cross-validate also the search part, i.e., whether to run the search
separately for each CV fold (<code>TRUE</code>) or not (<code>FALSE</code>). We strongly do not
recommend setting this to <code>FALSE</code>, because this is known to bias the
predictive performance estimates of the selected submodels. However,
setting this to <code>FALSE</code> can sometimes be useful because comparing the
results to the case where this argument is <code>TRUE</code> gives an idea of how
strongly the search is (over-)fitted to the data (the difference
corresponds to the search degrees of freedom or the effective number of
parameters introduced by the search).</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_method">method</code></td>
<td>
<p>The method for the search part. Possible options are
<code>"forward"</code> for forward search and <code>"L1"</code> for L1 search. See also section
&quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_ndraws">ndraws</code></td>
<td>
<p>Number of posterior draws used in the search part. Ignored if
<code>nclusters</code> is not <code>NULL</code> or in case of L1 search (because L1 search always
uses a single cluster). If both (<code>nclusters</code> and <code>ndraws</code>) are <code>NULL</code>, the
number of posterior draws from the reference model is used for <code>ndraws</code>.
See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters of posterior draws used in the search
part. Ignored in case of L1 search (because L1 search always uses a single
cluster). For the meaning of <code>NULL</code>, see argument <code>ndraws</code>. See also
section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_ndraws_pred">ndraws_pred</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of
posterior draws used in the evaluation part. Ignored if <code>nclusters_pred</code> is
not <code>NULL</code>. If both (<code>nclusters_pred</code> and <code>ndraws_pred</code>) are <code>NULL</code>, the
number of posterior draws from the reference model is used for
<code>ndraws_pred</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_nclusters_pred">nclusters_pred</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of
clusters of posterior draws used in the evaluation part. For the meaning of
<code>NULL</code>, see argument <code>ndraws_pred</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_refit_prj">refit_prj</code></td>
<td>
<p>For the evaluation part, should the submodels along the
predictor ranking be fitted again (<code>TRUE</code>) or should their fits from the
search part be re-used (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_nterms_max">nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms) up to
which the search is continued. If <code>NULL</code>, then <code>min(19, D)</code> is used where
<code>D</code> is the number of terms in the reference model (or in <code>search_terms</code>, if
supplied). Note that <code>nterms_max</code> does not count the intercept, so use
<code>nterms_max = 0</code> for the intercept-only model. (Correspondingly, <code>D</code> above
does not count the intercept.)</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_penalty">penalty</code></td>
<td>
<p>Only relevant for L1 search. A numeric vector determining the
relative penalties or costs for the predictors. A value of <code>0</code> means that
those predictors have no cost and will therefore be selected first, whereas
<code>Inf</code> means those predictors will never be selected. If <code>NULL</code>, then <code>1</code> is
used for each predictor.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_verbose">verbose</code></td>
<td>
<p>A single logical value indicating whether to print out
additional information during the computations.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_search_control">search_control</code></td>
<td>
<p>A <code>list</code> of &quot;control&quot; arguments (i.e., tuning
parameters) for the search. In case of forward search, these arguments are
passed to the divergence minimizer (see argument <code>div_minimizer</code> of
<code><a href="#topic+init_refmodel">init_refmodel()</a></code> as well as section &quot;Draw-wise divergence minimizers&quot; of
<a href="#topic+projpred-package">projpred-package</a>). In case of forward search, <code>NULL</code> causes <code>...</code> to be
used not only for the performance evaluation, but also for the search. In
case of L1 search, possible arguments are:
</p>

<ul>
<li> <p><code>lambda_min_ratio</code>: Ratio between the smallest and largest lambda in the
L1-penalized search (default: <code>1e-5</code>). This parameter essentially
determines how long the search is carried out, i.e., how large submodels
are explored. No need to change this unless the program gives a warning
about this.
</p>
</li>
<li> <p><code>nlambda</code>: Number of values in the lambda grid for L1-penalized search
(default: <code>150</code>). No need to change this unless the program gives a warning
about this.
</p>
</li>
<li> <p><code>thresh</code>: Convergence threshold when computing the L1 path (default:
<code>1e-6</code>). Usually, there is no need to change this.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cv_varsel_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead).
Only relevant for L1 search. Ratio between the smallest and largest lambda
in the L1-penalized search. This parameter essentially determines how long
the search is carried out, i.e., how large submodels are explored. No need
to change this unless the program gives a warning about this.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_nlambda">nlambda</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead). Only
relevant for L1 search. Number of values in the lambda grid for
L1-penalized search. No need to change this unless the program gives a
warning about this.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_thresh">thresh</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead). Only relevant
for L1 search. Convergence threshold when computing the L1 path. Usually,
there is no need to change this.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>) upon exiting <code><a href="#topic+cv_varsel">cv_varsel()</a></code>. Here, <code>seed</code> is used for
clustering the reference model's posterior draws (if <code>!is.null(nclusters)</code>
or <code>!is.null(nclusters_pred)</code>), for subsampling PSIS-LOO CV folds (if
<code>nloo</code> is smaller than the number of observations), for sampling the folds
in <code class="reqn">K</code>-fold CV, and for drawing new group-level effects when predicting
from a multilevel submodel (however, not yet in case of a GAMM).</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_search_terms">search_terms</code></td>
<td>
<p>Only relevant for forward search. A custom character
vector of predictor term blocks to consider for the search. Section
&quot;Details&quot; below describes more precisely what &quot;predictor term block&quot; means.
The intercept (<code>"1"</code>) is always included internally via <code>union()</code>, so
there's no difference between including it explicitly or omitting it. The
default <code>search_terms</code> considers all the terms in the reference model's
formula.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_search_out">search_out</code></td>
<td>
<p>Intended for internal use.</p>
</td></tr>
<tr><td><code id="cv_varsel_+3A_parallel">parallel</code></td>
<td>
<p>A single logical value indicating whether to run costly parts
of the CV in parallel (<code>TRUE</code>) or not (<code>FALSE</code>). See also section &quot;Note&quot;
below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>ndraws</code>, <code>nclusters</code>, <code>nclusters_pred</code>, and <code>ndraws_pred</code>
are automatically truncated at the number of posterior draws in the
reference model (which is <code>1</code> for <code>datafit</code>s). Using less draws or clusters
in <code>ndraws</code>, <code>nclusters</code>, <code>nclusters_pred</code>, or <code>ndraws_pred</code> than posterior
draws in the reference model may result in slightly inaccurate projection
performance. Increasing these arguments affects the computation time
linearly.
</p>
<p>For argument <code>method</code>, there are some restrictions: For a reference model
with multilevel or additive formula terms or a reference model set up for
the augmented-data projection, only the forward search is available.
Furthermore, argument <code>search_terms</code> requires a forward search to take
effect.
</p>
<p>L1 search is faster than forward search, but forward search may be more
accurate. Furthermore, forward search may find a sparser model with
comparable performance to that found by L1 search, but it may also start
overfitting when more predictors are added.
</p>
<p>An L1 search may select an interaction term before all involved lower-order
interaction terms (including main-effect terms) have been selected. In
<span class="pkg">projpred</span> versions &gt; 2.6.0, the resulting predictor ranking is
automatically modified so that the lower-order interaction terms come
before this interaction term, but if this is conceptually undesired, choose
the forward search instead.
</p>
<p>The elements of the <code>search_terms</code> character vector don't need to be
individual predictor terms. Instead, they can be building blocks consisting
of several predictor terms connected by the <code>+</code> symbol. To understand how
these building blocks work, it is important to know how <span class="pkg">projpred</span>'s
forward search works: It starts with an empty vector <code>chosen</code> which will
later contain already selected predictor terms. Then, the search iterates
over model sizes <code class="reqn">j \in \{0, ..., J\}</code> (with <code class="reqn">J</code>
denoting the maximum submodel size, not counting the intercept). The
candidate models at model size <code class="reqn">j</code> are constructed from those elements
from <code>search_terms</code> which yield model size <code class="reqn">j</code> when combined with the
<code>chosen</code> predictor terms. Note that sometimes, there may be no candidate
models for model size <code class="reqn">j</code>. Also note that internally, <code>search_terms</code> is
expanded to include the intercept (<code>"1"</code>), so the first step of the search
(model size 0) always consists of the intercept-only model as the only
candidate.
</p>
<p>As a <code>search_terms</code> example, consider a reference model with formula <code>y ~ x1 + x2 + x3</code>. Then, to ensure that <code>x1</code> is always included in the
candidate models, specify <code>search_terms = c("x1", "x1 + x2", "x1 + x3", "x1 + x2 + x3")</code> (or, in a simpler way that leads to the same results,
<code>search_terms = c("x1", "x1 + x2", "x1 + x3")</code>, for which helper function
<code><a href="#topic+force_search_terms">force_search_terms()</a></code> exists). This search would start with <code>y ~ 1</code> as the
only candidate at model size 0. At model size 1, <code>y ~ x1</code> would be the only
candidate. At model size 2, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code> would be the
two candidates. At the last model size of 3, <code>y ~ x1 + x2 + x3</code> would be
the only candidate. As another example, to exclude <code>x1</code> from the search,
specify <code>search_terms = c("x2", "x3", "x2 + x3")</code> (or, in a simpler way
that leads to the same results, <code>search_terms = c("x2", "x3")</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>vsel</code>. The elements of this object are not meant
to be accessed directly but instead via helper functions (see the main
vignette and <a href="#topic+projpred-package">projpred-package</a>).
</p>


<h3>Note</h3>

<p>If <code>validate_search</code> is <code>FALSE</code>, the search is not included in the CV
so that only a single full-data search is run.
</p>
<p>For PSIS-LOO CV, <span class="pkg">projpred</span> calls <code><a href="loo.html#topic+psis">loo::psis()</a></code> (or, exceptionally,
<code><a href="loo.html#topic+sis">loo::sis()</a></code>, see below) with <code>r_eff = NA</code>. This is only a problem if there
was extreme autocorrelation between the MCMC iterations when the reference
model was built. In those cases however, the reference model should not
have been used anyway, so we don't expect <span class="pkg">projpred</span>'s <code>r_eff = NA</code> to
be a problem.
</p>
<p>PSIS cannot be used if the draws have different (i.e., nonconstant) weights
or if the number of draws is too small. In such cases, <span class="pkg">projpred</span>
resorts to standard importance sampling (SIS) and throws a warning about
this. Throughout the documentation, the term &quot;PSIS&quot; is used even though in
fact, <span class="pkg">projpred</span> resorts to SIS in these special cases.
</p>
<p>With <code>parallel = TRUE</code>, costly parts of <span class="pkg">projpred</span>'s CV are run in
parallel. Costly parts are the fold-wise searches and performance
evaluations in case of <code>validate_search = TRUE</code>. (Note that in case of
<code class="reqn">K</code>-fold CV, the <code class="reqn">K</code> reference model refits are not affected by
argument <code>parallel</code>; only <span class="pkg">projpred</span>'s CV is affected.) The
parallelization is powered by the <span class="pkg">foreach</span> package. Thus, any parallel
(or sequential) backend compatible with <span class="pkg">foreach</span> can be used, e.g.,
the backends from packages <span class="pkg">doParallel</span>, <span class="pkg">doMPI</span>, or
<span class="pkg">doFuture</span>. For GLMs, this CV parallelization should work reliably, but
for other models (such as GLMMs), it may lead to excessive memory usage
which in turn may crash the R session (on Unix systems, setting an
appropriate memory limit via <code><a href="unix.html#topic+rlimit">unix::rlimit_as()</a></code> may avoid crashing the
whole machine). However, the problem of excessive memory usage is less
pronounced for the CV parallelization than for the projection
parallelization described in <a href="#topic+projpred-package">projpred-package</a>. In that regard, the CV
parallelization is recommended over the projection parallelization.
</p>


<h3>References</h3>

<p>Magnusson, Måns, Michael Andersen, Johan Jonasson, and Aki Vehtari. 2019.
&quot;Bayesian Leave-One-Out Cross-Validation for Large Data.&quot; In <em>Proceedings of
the 36th International Conference on Machine Learning</em>, edited by Kamalika
Chaudhuri and Ruslan Salakhutdinov, 97:4244&ndash;53. Proceedings of Machine
Learning Research. PMLR.
<a href="https://proceedings.mlr.press/v97/magnusson19a.html">https://proceedings.mlr.press/v97/magnusson19a.html</a>.
</p>
<p>Vehtari, Aki, Andrew Gelman, and Jonah Gabry. 2017. &quot;Practical Bayesian Model
Evaluation Using Leave-One-Out Cross-Validation and WAIC.&quot; <em>Statistics and
Computing</em> 27 (5): 1413&ndash;32. <a href="https://doi.org/10.1007/s11222-016-9696-4">doi:10.1007/s11222-016-9696-4</a>.
</p>
<p>Vehtari, Aki, Daniel Simpson, Andrew Gelman, Yuling Yao, and Jonah Gabry.
2022. &quot;Pareto Smoothed Importance Sampling.&quot; arXiv.
<a href="https://doi.org/10.48550/arXiv.1507.02646">doi:10.48550/arXiv.1507.02646</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varsel">varsel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 1000, refresh = 0, seed = 9876
)

# Run cv_varsel() (with L1 search and small values for `K`, `nterms_max`, and
# `nclusters_pred`, but only for the sake of speed in this example; this is
# not recommended in general):
cvvs &lt;- cv_varsel(fit, method = "L1", cv_method = "kfold", K = 2,
                  nterms_max = 3, nclusters_pred = 10, seed = 5555)
# Now see, for example, `?print.vsel`, `?plot.vsel`, `?suggest_size.vsel`,
# and `?ranking` for possible post-processing functions.

</code></pre>

<hr>
<h2 id='cv-indices'>Create cross-validation folds</h2><span id='topic+cv-indices'></span><span id='topic+cv_folds'></span><span id='topic+cvfolds'></span><span id='topic+cv_ids'></span>

<h3>Description</h3>

<p>These are helper functions to create cross-validation (CV) folds, i.e., to
split up the indices from 1 to <code>n</code> into <code>K</code> subsets (&quot;folds&quot;) for
<code class="reqn">K</code>-fold CV. These functions are potentially useful when creating the
input for arguments <code>cvfits</code> and <code>cvfun</code> of <code><a href="#topic+init_refmodel">init_refmodel()</a></code> (or argument
<code>cvfits</code> of <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>). Function <code><a href="#topic+cvfolds">cvfolds()</a></code> is deprecated;
please use <code><a href="#topic+cv_folds">cv_folds()</a></code> instead (apart from the name, they are the same). The
return value of <code><a href="#topic+cv_folds">cv_folds()</a></code> and <code><a href="#topic+cv_ids">cv_ids()</a></code> is different, see below for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_folds(n, K, seed = NA)

cvfolds(n, K, seed = NA)

cv_ids(n, K, out = c("foldwise", "indices"), seed = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv-indices_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="cv-indices_+3A_k">K</code></td>
<td>
<p>Number of folds. Must be at least 2 and not exceed <code>n</code>.</p>
</td></tr>
<tr><td><code id="cv-indices_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling
<code><a href="#topic+cv_folds">cv_folds()</a></code> or <code><a href="#topic+cv_ids">cv_ids()</a></code>) upon exiting <code><a href="#topic+cv_folds">cv_folds()</a></code> or <code><a href="#topic+cv_ids">cv_ids()</a></code>.</p>
</td></tr>
<tr><td><code id="cv-indices_+3A_out">out</code></td>
<td>
<p>Format of the output, either <code>"foldwise"</code> or <code>"indices"</code>. See
below for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+cv_folds">cv_folds()</a></code> returns a vector of length <code>n</code> such that each element is
an integer between 1 and <code>K</code> denoting which fold the corresponding data
point belongs to. The return value of <code><a href="#topic+cv_ids">cv_ids()</a></code> depends on the <code>out</code>
argument. If <code>out = "foldwise"</code>, the return value is a <code>list</code> with <code>K</code>
elements, each being a <code>list</code> with elements <code>tr</code> and <code>ts</code> giving the
training and test indices, respectively, for the corresponding fold. If
<code>out = "indices"</code>, the return value is a <code>list</code> with elements <code>tr</code> and <code>ts</code>
each being a <code>list</code> with <code>K</code> elements giving the training and test indices,
respectively, for each fold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
set.seed(1234)
y &lt;- rnorm(n)
cv &lt;- cv_ids(n, K = 5)
# Mean within the test set of each fold:
cvmeans &lt;- sapply(cv, function(fold) mean(y[fold$ts]))

</code></pre>

<hr>
<h2 id='df_binom'>Binomial toy example</h2><span id='topic+df_binom'></span>

<h3>Description</h3>

<p>Binomial toy example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_binom
</code></pre>


<h3>Format</h3>

<p>A simulated classification dataset containing 100 observations.
</p>

<dl>
<dt>y</dt><dd><p>response, 0 or 1.</p>
</dd>
<dt>x</dt><dd><p>predictors, 30 in total.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://web.stanford.edu/~hastie/glmnet/glmnetData/BNExample.RData">https://web.stanford.edu/~hastie/glmnet/glmnetData/BNExample.RData</a>
</p>

<hr>
<h2 id='df_gaussian'>Gaussian toy example</h2><span id='topic+df_gaussian'></span>

<h3>Description</h3>

<p>Gaussian toy example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_gaussian
</code></pre>


<h3>Format</h3>

<p>A simulated regression dataset containing 100 observations.
</p>

<dl>
<dt>y</dt><dd><p>response, real-valued.</p>
</dd>
<dt>x</dt><dd><p>predictors, 20 in total. Mean and SD are approximately 0 and 1,
respectively.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://web.stanford.edu/~hastie/glmnet/glmnetData/QSExample.RData">https://web.stanford.edu/~hastie/glmnet/glmnetData/QSExample.RData</a>
</p>

<hr>
<h2 id='do_call'>Execute a function call</h2><span id='topic+do_call'></span>

<h3>Description</h3>

<p>Execute a function call similar to <code><a href="base.html#topic+do.call">do.call()</a></code>, but without deparsing
function arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_call(what, args, pkg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_call_+3A_what">what</code></td>
<td>
<p>Either a function or a non-empty character string naming the
function to be called.</p>
</td></tr>
<tr><td><code id="do_call_+3A_args">args</code></td>
<td>
<p>A <code>list</code> of arguments to the function call. The <code><a href="base.html#topic+names">names</a></code>
attribute of <code>args</code> gives the argument names.</p>
</td></tr>
<tr><td><code id="do_call_+3A_pkg">pkg</code></td>
<td>
<p>Optional name of the package in which to search for the function
if <code>what</code> is a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the (evaluated) function call.
</p>

<hr>
<h2 id='extend_family'>Extend a family</h2><span id='topic+extend_family'></span>

<h3>Description</h3>

<p>This function adds some internally required elements to an object of class
<code>family</code> (see, e.g., <code><a href="stats.html#topic+family">family()</a></code>). It is called internally by
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>, so you will rarely need to call it yourself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_family(
  family,
  latent = FALSE,
  latent_y_unqs = NULL,
  latent_ilink = NULL,
  latent_ll_oscale = NULL,
  latent_ppd_oscale = NULL,
  augdat_y_unqs = NULL,
  augdat_link = NULL,
  augdat_ilink = NULL,
  augdat_args_link = list(),
  augdat_args_ilink = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_family_+3A_family">family</code></td>
<td>
<p>An object of class <code>family</code>.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_latent">latent</code></td>
<td>
<p>A single logical value indicating whether to use the latent
projection (<code>TRUE</code>) or not (<code>FALSE</code>). Note that setting <code>latent = TRUE</code>
causes all arguments starting with <code>augdat_</code> to be ignored.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_latent_y_unqs">latent_y_unqs</code></td>
<td>
<p>Only relevant for a latent projection where the original
response space has finite support (i.e., the original response values may
be regarded as categories), in which case this needs to be the character
vector of unique response values (which will be assigned to <code>family$cats</code>
internally) or may be left at <code>NULL</code> (so that <span class="pkg">projpred</span> will try to
infer it from <code>family$cats</code>). See also section &quot;Latent projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_latent_ilink">latent_ilink</code></td>
<td>
<p>Only relevant for the latent projection, in which case
this needs to be the inverse-link function. If the original response family
was the <code><a href="stats.html#topic+binomial">binomial()</a></code> or the <code><a href="stats.html#topic+poisson">poisson()</a></code> family, then <code>latent_ilink</code> can be
<code>NULL</code>, in which case an internal default will be used. Can also be <code>NULL</code>
in all other cases, but then an internal default based on <code>family$linkinv</code>
will be used which might not work for all families. See also section
&quot;Latent projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_latent_ll_oscale">latent_ll_oscale</code></td>
<td>
<p>Only relevant for the latent projection, in which
case this needs to be the function computing response-scale (not
latent-scale) log-likelihood values. If <code>!is.null(family$cats)</code> (after
taking <code>latent_y_unqs</code> into account) or if the original response family was
the <code><a href="stats.html#topic+binomial">binomial()</a></code> or the <code><a href="stats.html#topic+poisson">poisson()</a></code> family, then <code>latent_ll_oscale</code> can be
<code>NULL</code>, in which case an internal default will be used. Can also be <code>NULL</code>
in all other cases, but then downstream functions will have limited
functionality (a message thrown by <code><a href="#topic+extend_family">extend_family()</a></code> will state what
exactly won't be available). See also section &quot;Latent projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_latent_ppd_oscale">latent_ppd_oscale</code></td>
<td>
<p>Only relevant for the latent projection, in which
case this needs to be the function sampling response values given latent
predictors that have been transformed to response scale using
<code>latent_ilink</code>. If <code>!is.null(family$cats)</code> (after taking <code>latent_y_unqs</code>
into account) or if the original response family was the <code><a href="stats.html#topic+binomial">binomial()</a></code> or
the <code><a href="stats.html#topic+poisson">poisson()</a></code> family, then <code>latent_ppd_oscale</code> can be <code>NULL</code>, in which
case an internal default will be used. Can also be <code>NULL</code> in all other
cases, but then downstream functions will have limited functionality (a
message thrown by <code><a href="#topic+extend_family">extend_family()</a></code> will state what exactly won't be
available). See also section &quot;Latent projection&quot; below. Note that although
this function has the abbreviation &quot;PPD&quot; in its name (which stands for
&quot;posterior predictive distribution&quot;), <span class="pkg">projpred</span> currently only uses it
in <code><a href="#topic+proj_predict">proj_predict()</a></code>, i.e., for sampling from what would better be termed
posterior-projection predictive distribution (PPPD).</p>
</td></tr>
<tr><td><code id="extend_family_+3A_augdat_y_unqs">augdat_y_unqs</code></td>
<td>
<p>Only relevant for augmented-data projection, in which
case this needs to be the character vector of unique response values (which
will be assigned to <code>family$cats</code> internally) or may be left at <code>NULL</code> if
<code>family$cats</code> is already non-<code>NULL</code>. See also section &quot;Augmented-data
projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_augdat_link">augdat_link</code></td>
<td>
<p>Only relevant for augmented-data projection, in which case
this needs to be the link function. Use <code>NULL</code> for the traditional
projection. See also section &quot;Augmented-data projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_augdat_ilink">augdat_ilink</code></td>
<td>
<p>Only relevant for augmented-data projection, in which
case this needs to be the inverse-link function. Use <code>NULL</code> for the
traditional projection. See also section &quot;Augmented-data projection&quot; below.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_augdat_args_link">augdat_args_link</code></td>
<td>
<p>Only relevant for augmented-data projection, in which
case this may be a named <code>list</code> of arguments to pass to the function
supplied to <code>augdat_link</code>.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_augdat_args_ilink">augdat_args_ilink</code></td>
<td>
<p>Only relevant for augmented-data projection, in
which case this may be a named <code>list</code> of arguments to pass to the function
supplied to <code>augdat_ilink</code>.</p>
</td></tr>
<tr><td><code id="extend_family_+3A_...">...</code></td>
<td>
<p>Ignored (exists only to swallow up further arguments which might
be passed to this function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, <code class="reqn">N</code>, <code class="reqn">C_{\mathrm{cat}}</code>,
<code class="reqn">C_{\mathrm{lat}}</code>, <code class="reqn">S_{\mathrm{ref}}</code>, and
<code class="reqn">S_{\mathrm{prj}}</code> from help topic <a href="#topic+refmodel-init-get">refmodel-init-get</a> are used.
Note that <code class="reqn">N</code> does not necessarily denote the number of original
observations; it can also refer to new observations. Furthermore, let <code class="reqn">S</code>
denote either <code class="reqn">S_{\mathrm{ref}}</code> or <code class="reqn">S_{\mathrm{prj}}</code>,
whichever is appropriate in the context where it is used.
</p>


<h3>Value</h3>

<p>The <code>family</code> object extended in the way needed by <span class="pkg">projpred</span>.
</p>


<h3>Augmented-data projection</h3>

<p>As their first input, the functions supplied to arguments <code>augdat_link</code> and
<code>augdat_ilink</code> have to accept:
</p>

<ul>
<li><p> For <code>augdat_link</code>: an <code class="reqn">S \times N \times C_{\mathrm{cat}}</code> array containing the probabilities for the response categories. The
order of the response categories is the same as in <code>family$cats</code> (see
argument <code>augdat_y_unqs</code>).
</p>
</li>
<li><p> For <code>augdat_ilink</code>: an <code class="reqn">S \times N \times C_{\mathrm{lat}}</code> array containing the linear predictors.
</p>
</li></ul>

<p>The return value of these functions needs to be:
</p>

<ul>
<li><p> For <code>augdat_link</code>: an <code class="reqn">S \times N \times C_{\mathrm{lat}}</code> array containing the linear predictors.
</p>
</li>
<li><p> For <code>augdat_ilink</code>: an <code class="reqn">S \times N \times C_{\mathrm{cat}}</code> array containing the probabilities for the response categories. The
order of the response categories has to be the same as in <code>family$cats</code> (see
argument <code>augdat_y_unqs</code>).
</p>
</li></ul>

<p>For the augmented-data projection, the response vector resulting from
<code>extract_model_data</code> (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>) is coerced to a <code>factor</code> (using
<code><a href="base.html#topic+as.factor">as.factor()</a></code>) at multiple places throughout this package. Inside of
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>, the levels of this <code>factor</code> have to be identical to
<code>family$cats</code> (<em>after</em> applying <code><a href="#topic+extend_family">extend_family()</a></code> inside of
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Everywhere else, these levels have to be a subset of
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> (where <code style="white-space: pre;">&#8288;&lt;refmodel&gt;&#8288;</code> is an object resulting from
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>). See argument <code>augdat_y_unqs</code> for how to control
<code>family$cats</code>.
</p>
<p>For ordinal <span class="pkg">brms</span> families, be aware that the submodels (onto which the
reference model is projected) currently have the following restrictions:
</p>

<ul>
<li><p> The discrimination parameter <code>disc</code> is not supported (i.e., it is a
constant with value 1).
</p>
</li>
<li><p> The thresholds are <code>"flexible"</code> (see <code><a href="brms.html#topic+brmsfamily">brms::brmsfamily()</a></code>).
</p>
</li>
<li><p> The thresholds do not vary across the levels of a <code>factor</code>-like variable
(see argument <code>gr</code> of <code><a href="brms.html#topic+addition-terms">brms::resp_thres()</a></code>).
</p>
</li>
<li><p> The <code>"probit_approx"</code> link is replaced by <code>"probit"</code>.
</p>
</li></ul>

<p>For the <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> family, be aware that:
</p>

<ul>
<li><p> For multilevel submodels, the group-level effects are allowed to be
correlated between different response categories.
</p>
</li>
<li><p> For multilevel submodels, <span class="pkg">mclogit</span> versions &lt; 0.9.4 may throw the
error <code>'a' (&lt;number&gt; x 1) must be square</code>. Updating <span class="pkg">mclogit</span> to a
version &gt;= 0.9.4 should fix this.
</p>
</li></ul>



<h3>Latent projection</h3>

<p>The function supplied to argument <code>latent_ilink</code> needs to have the prototype
</p>
<div class="sourceCode r"><pre>latent_ilink(lpreds, cl_ref, wdraws_ref = rep(1, length(cl_ref)))
</pre></div>
<p>where:
</p>

<ul>
<li> <p><code>lpreds</code> accepts an <code class="reqn">S \times N</code> matrix containing the linear
predictors.
</p>
</li>
<li> <p><code>cl_ref</code> accepts a numeric vector of length <code class="reqn">S_{\mathrm{ref}}</code>,
containing <span class="pkg">projpred</span>'s internal cluster indices for these draws.
</p>
</li>
<li> <p><code>wdraws_ref</code> accepts a numeric vector of length
<code class="reqn">S_{\mathrm{ref}}</code>, containing weights for these draws. These
weights should be treated as not being normalized (i.e., they don't
necessarily sum to <code>1</code>).
</p>
</li></ul>

<p>The return value of <code>latent_ilink</code> needs to contain the linear predictors
transformed to the original response space, with the following structure:
</p>

<ul>
<li><p> If <code>is.null(family$cats)</code> (after taking <code>latent_y_unqs</code> into account): an
<code class="reqn">S \times N</code> matrix.
</p>
</li>
<li><p> If <code>!is.null(family$cats)</code> (after taking <code>latent_y_unqs</code> into account): an
<code class="reqn">S \times N \times C_{\mathrm{cat}}</code> array. In that case,
<code>latent_ilink</code> needs to return <em>probabilities</em> (for the response categories
given in <code>family$cats</code>, after taking <code>latent_y_unqs</code> into account).
</p>
</li></ul>

<p>The function supplied to argument <code>latent_ll_oscale</code> needs to have the
prototype
</p>
<div class="sourceCode r"><pre>latent_ll_oscale(ilpreds, y_oscale, wobs = rep(1, length(y_oscale)), cl_ref,
                 wdraws_ref = rep(1, length(cl_ref)))
</pre></div>
<p>where:
</p>

<ul>
<li> <p><code>ilpreds</code> accepts the return value from <code>latent_ilink</code>.
</p>
</li>
<li> <p><code>y_oscale</code> accepts a vector of length <code class="reqn">N</code> containing response values on
the original response scale.
</p>
</li>
<li> <p><code>wobs</code> accepts a numeric vector of length <code class="reqn">N</code> containing observation
weights.
</p>
</li>
<li> <p><code>cl_ref</code> accepts the same input as argument <code>cl_ref</code> of <code>latent_ilink</code>.
</p>
</li>
<li> <p><code>wdraws_ref</code> accepts the same input as argument <code>wdraws_ref</code> of
<code>latent_ilink</code>.
</p>
</li></ul>

<p>The return value of <code>latent_ll_oscale</code> needs to be an <code class="reqn">S \times N</code>
matrix containing the response-scale (not latent-scale) log-likelihood values
for the <code class="reqn">N</code> observations from its inputs.
</p>
<p>The function supplied to argument <code>latent_ppd_oscale</code> needs to have the
prototype
</p>
<div class="sourceCode r"><pre>latent_ppd_oscale(ilpreds_resamp, wobs, cl_ref,
                  wdraws_ref = rep(1, length(cl_ref)), idxs_prjdraws)
</pre></div>
<p>where:
</p>

<ul>
<li> <p><code>ilpreds_resamp</code> accepts the return value from <code>latent_ilink</code>, but possibly
with resampled (clustered) draws (see argument <code>nresample_clusters</code> of
<code><a href="#topic+proj_predict">proj_predict()</a></code>).
</p>
</li>
<li> <p><code>wobs</code> accepts a numeric vector of length <code class="reqn">N</code> containing observation
weights.
</p>
</li>
<li> <p><code>cl_ref</code> accepts the same input as argument <code>cl_ref</code> of <code>latent_ilink</code>.
</p>
</li>
<li> <p><code>wdraws_ref</code> accepts the same input as argument <code>wdraws_ref</code> of
<code>latent_ilink</code>.
</p>
</li>
<li> <p><code>idxs_prjdraws</code> accepts a numeric vector of length <code>dim(ilpreds_resamp)[1]</code>
containing the resampled indices of the projected draws (i.e., these indices
are values from the set <code class="reqn">\{1, ..., \texttt{dim(ilpreds)[1]}\}</code> where <code>ilpreds</code> denotes the return value of
<code>latent_ilink</code>).
</p>
</li></ul>

<p>The return value of <code>latent_ppd_oscale</code> needs to be a
<code class="reqn">\texttt{dim(ilpreds\_resamp)[1]} \times N</code>
matrix containing the response-scale (not latent-scale) draws from the
posterior(-projection) predictive distributions for the <code class="reqn">N</code> observations
from its inputs.
</p>
<p>If the bodies of these three functions involve parameter draws from the
reference model which have not been projected (e.g., for <code>latent_ilink</code>, the
thresholds in an ordinal model), <code><a href="#topic+cl_agg">cl_agg()</a></code> is provided as a helper function
for aggregating these reference model draws in the same way as the draws have
been aggregated for the first argument of these functions (e.g., <code>lpreds</code> in
case of <code>latent_ilink</code>).
</p>
<p>In fact, the weights passed to argument <code>wdraws_ref</code> are nonconstant only in
case of <code><a href="#topic+cv_varsel">cv_varsel()</a></code> with <code>cv_method = "LOO"</code> and <code>validate_search = TRUE</code>.
In that case, the weights passed to this argument are the PSIS-LOO CV weights
for one observation. Note that although argument <code>wdraws_ref</code> has the suffix
<code style="white-space: pre;">&#8288;_ref&#8288;</code>, <code>wdraws_ref</code> does not necessarily obtain weights for the <em>initial</em>
reference model's posterior draws: In case of <code><a href="#topic+cv_varsel">cv_varsel()</a></code> with <code>cv_method = "kfold"</code>, these weights may refer to one of the <code class="reqn">K</code> reference model
refits (but in that case, they are constant anyway).
</p>
<p>If <code>family$cats</code> is not <code>NULL</code> (after taking <code>latent_y_unqs</code> into account),
then the response vector resulting from <code>extract_model_data</code> (see
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>) is coerced to a <code>factor</code> (using <code><a href="base.html#topic+as.factor">as.factor()</a></code>) at multiple
places throughout this package. Inside of <code><a href="#topic+init_refmodel">init_refmodel()</a></code>, the levels of
this <code>factor</code> have to be identical to <code>family$cats</code> (<em>after</em> applying
<code><a href="#topic+extend_family">extend_family()</a></code> inside of <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Everywhere else, these levels
have to be a subset of <code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> (where <code style="white-space: pre;">&#8288;&lt;refmodel&gt;&#8288;</code> is an
object resulting from <code><a href="#topic+init_refmodel">init_refmodel()</a></code>).
</p>

<hr>
<h2 id='extra-families'>Extra family objects</h2><span id='topic+extra-families'></span><span id='topic+Student_t'></span>

<h3>Description</h3>

<p>Family objects not in the set of default <code><a href="stats.html#topic+family">family</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Student_t(link = "identity", nu = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extra-families_+3A_link">link</code></td>
<td>
<p>Name of the link function. In contrast to the default <code><a href="stats.html#topic+family">family</a></code>
objects, this has to be a character string here.</p>
</td></tr>
<tr><td><code id="extra-families_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom for the Student-<code class="reqn">t</code> distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A family object analogous to those described in <code><a href="stats.html#topic+family">family</a></code>.
</p>


<h3>Note</h3>

<p>Support for the <code><a href="#topic+Student_t">Student_t()</a></code> family is still experimental.
</p>

<hr>
<h2 id='force_search_terms'>Force search terms</h2><span id='topic+force_search_terms'></span>

<h3>Description</h3>

<p>A helper function to construct the input for argument <code>search_terms</code> of
<code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> if certain predictor terms should be forced to be
selected first whereas other predictor terms are optional (i.e., they are
subject to the variable selection, but only after the inclusion of the
&quot;forced&quot; terms).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_search_terms(forced_terms, optional_terms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="force_search_terms_+3A_forced_terms">forced_terms</code></td>
<td>
<p>A character vector of predictor terms that should be
selected first.</p>
</td></tr>
<tr><td><code id="force_search_terms_+3A_optional_terms">optional_terms</code></td>
<td>
<p>A character vector of predictor terms that should be
subject to the variable selection after the inclusion of the &quot;forced&quot;
terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector that may be used as input for argument
<code>search_terms</code> of <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varsel">varsel()</a></code>, <code><a href="#topic+cv_varsel">cv_varsel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# We will force X1 and X2 to be selected first:
search_terms_forced &lt;- force_search_terms(
  forced_terms = paste0("X", 1:2),
  optional_terms = paste0("X", 3:5)
)

# Run varsel() (here without cross-validation and with small values for
# `nterms_max`, `nclusters`, and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, nclusters = 5, nclusters_pred = 10,
             search_terms = search_terms_forced, seed = 5555)
# Now see, for example, `?print.vsel`, `?plot.vsel`, `?suggest_size.vsel`,
# and `?ranking` for possible post-processing functions.

</code></pre>

<hr>
<h2 id='mesquite'>Mesquite data set</h2><span id='topic+mesquite'></span>

<h3>Description</h3>

<p>The mesquite bushes yields dataset from Gelman and Hill (2006)
(<a href="http://www.stat.columbia.edu/~gelman/arm/">http://www.stat.columbia.edu/~gelman/arm/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesquite
</code></pre>


<h3>Format</h3>

<p>The response variable is the total weight (in grams) of
photosynthetic material as derived from actual harvesting of the bush. The
predictor variables are:
</p>

<dl>
<dt>diam1</dt><dd><p>diameter of the canopy (the leafy area of the bush) in meters,
measured along the longer axis of the bush.</p>
</dd>
<dt>diam2</dt><dd><p>canopy diameter measured along the shorter axis.</p>
</dd>
<dt>canopy height</dt><dd><p>height of the canopy.</p>
</dd>
<dt>total height</dt><dd><p>total height of the bush.</p>
</dd>
<dt>density</dt><dd><p>plant unit density (# of primary stems per plant unit).</p>
</dd>
<dt>group</dt><dd><p>group of measurements (0 for the first group, 1 for the second
group).</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.stat.columbia.edu/~gelman/arm/examples/mesquite/mesquite.dat">http://www.stat.columbia.edu/~gelman/arm/examples/mesquite/mesquite.dat</a>
</p>


<h3>References</h3>

<p>Gelman, Andrew, and Jennifer Hill. 2006. <em>Data Analysis Using
Regression and Multilevel/Hierarchical Models</em>. Cambridge, UK: Cambridge
University Press. <a href="https://doi.org/10.1017/CBO9780511790942">doi:10.1017/CBO9780511790942</a>.
</p>

<hr>
<h2 id='performances'>Predictive performance results</h2><span id='topic+performances'></span><span id='topic+performances.vselsummary'></span><span id='topic+performances.vsel'></span>

<h3>Description</h3>

<p>Retrieves the predictive performance summaries after running <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>. These summaries are computed by <code><a href="#topic+summary.vsel">summary.vsel()</a></code>, so the main
method of <code><a href="#topic+performances">performances()</a></code> is <code><a href="#topic+performances.vselsummary">performances.vselsummary()</a></code> (objects of class
<code>vselsummary</code> are returned by <code><a href="#topic+summary.vsel">summary.vsel()</a></code>). As a shortcut method,
<code><a href="#topic+performances.vsel">performances.vsel()</a></code> is provided as well (objects of class <code>vsel</code> are
returned by <code><a href="#topic+varsel">varsel()</a></code> and <code><a href="#topic+cv_varsel">cv_varsel()</a></code>). For a graphical representation,
see <code><a href="#topic+plot.vsel">plot.vsel()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performances(object, ...)

## S3 method for class 'vselsummary'
performances(object, ...)

## S3 method for class 'vsel'
performances(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performances_+3A_object">object</code></td>
<td>
<p>The object from which to retrieve the predictive performance
results. Possible classes may be inferred from the names of the
corresponding methods (see also the description).</p>
</td></tr>
<tr><td><code id="performances_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+performances.vsel">performances.vsel()</a></code>: arguments passed to <code><a href="#topic+summary.vsel">summary.vsel()</a></code>.
For <code><a href="#topic+performances.vselsummary">performances.vselsummary()</a></code>: currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>performances</code> which is a <code>list</code> with the
following elements:
</p>

<ul>
<li> <p><code>submodels</code>: The predictive performance results for the submodels, as a
<code>data.frame</code>.
</p>
</li>
<li> <p><code>reference_model</code>: The predictive performance results for the reference
model, as a named vector.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)
print(performances(vs))

</code></pre>

<hr>
<h2 id='plot.cv_proportions'>Plot ranking proportions from fold-wise predictor rankings</h2><span id='topic+plot.cv_proportions'></span><span id='topic+plot.ranking'></span>

<h3>Description</h3>

<p>Plots the ranking proportions (see <code><a href="#topic+cv_proportions">cv_proportions()</a></code>) from the fold-wise
predictor rankings in a cross-validation with fold-wise searches. This is a
visualization of the <em>transposed</em> matrix returned by <code><a href="#topic+cv_proportions">cv_proportions()</a></code>. The
proportions printed as text inside of the colored tiles are rounded to whole
percentage points (the plotted proportions themselves are not rounded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_proportions'
plot(x, text_angle = NULL, ...)

## S3 method for class 'ranking'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv_proportions_+3A_x">x</code></td>
<td>
<p>For <code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>: an object of class <code>cv_proportions</code>
(returned by <code><a href="#topic+cv_proportions">cv_proportions()</a></code>, possibly with <code>cumulate = TRUE</code>). For
<code><a href="#topic+plot.ranking">plot.ranking()</a></code>: an object of class <code>ranking</code> (returned by <code><a href="#topic+ranking">ranking()</a></code>)
that <code><a href="#topic+cv_proportions">cv_proportions()</a></code> will be applied to internally before then calling
<code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cv_proportions_+3A_text_angle">text_angle</code></td>
<td>
<p>Passed to argument <code>angle</code> of <code><a href="ggplot2.html#topic+element">ggplot2::element_text()</a></code> for
the y-axis tick labels. In case of long predictor names, <code>text_angle = 45</code>
might be helpful (for example).</p>
</td></tr>
<tr><td><code id="plot.cv_proportions_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+plot.ranking">plot.ranking()</a></code>: arguments passed to
<code><a href="#topic+cv_proportions.ranking">cv_proportions.ranking()</a></code> and <code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>. For
<code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>: currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> plotting object (of class <code>gg</code> and <code>ggplot</code>).
</p>


<h3>Author(s)</h3>

<p>Idea and original code by Aki Vehtari. Slight modifications of the
original code by Frank Weber, Yann McLatchie, and Sölvi Rögnvaldsson. Final
implementation in <span class="pkg">projpred</span> by Frank Weber.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 1000, refresh = 0, seed = 9876
)

# Run cv_varsel() (with L1 search and small values for `K`, `nterms_max`, and
# `nclusters_pred`, but only for the sake of speed in this example; this is
# not recommended in general):
cvvs &lt;- cv_varsel(fit, method = "L1", cv_method = "kfold", K = 2,
                  nterms_max = 3, nclusters_pred = 10, seed = 5555)

# Extract predictor rankings:
rk &lt;- ranking(cvvs)

# Compute ranking proportions:
pr_rk &lt;- cv_proportions(rk)

# Visualize the ranking proportions:
gg_pr_rk &lt;- plot(pr_rk)
print(gg_pr_rk)

# Since the object returned by plot.cv_proportions() is a standard ggplot2
# plotting object, you can modify the plot easily, e.g., to remove the
# legend:
print(gg_pr_rk + ggplot2::theme(legend.position = "none"))

</code></pre>

<hr>
<h2 id='plot.vsel'>Plot predictive performance</h2><span id='topic+plot.vsel'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+plot">plot()</a></code> method for <code>vsel</code> objects (returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>). It visualizes the predictive performance of the reference
model (possibly also that of some other &quot;baseline&quot; model) and that of the
submodels along the full-data predictor ranking. Basic information about the
(CV) variability in the ranking of the predictors is included as well (if
available; inferred from <code><a href="#topic+cv_proportions">cv_proportions()</a></code>). For a tabular representation,
see <code><a href="#topic+summary.vsel">summary.vsel()</a></code> and <code><a href="#topic+performances">performances()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vsel'
plot(
  x,
  nterms_max = NULL,
  stats = "elpd",
  deltas = FALSE,
  alpha = 2 * pnorm(-1),
  baseline = if (!inherits(x$refmodel, "datafit")) "ref" else "best",
  thres_elpd = NA,
  resp_oscale = TRUE,
  point_size = 3,
  bar_thickness = 1,
  ranking_nterms_max = NULL,
  ranking_abbreviate = FALSE,
  ranking_abbreviate_args = list(),
  ranking_repel = NULL,
  ranking_repel_args = list(),
  ranking_colored = FALSE,
  show_cv_proportions = TRUE,
  cumulate = FALSE,
  text_angle = NULL,
  size_position = "primary_x_bottom",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.vsel_+3A_x">x</code></td>
<td>
<p>An object of class <code>vsel</code> (returned by <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_nterms_max">nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms) for which
the performance statistics are calculated. Using <code>NULL</code> is effectively the
same as <code>length(ranking(object)$fulldata)</code>. Note that <code>nterms_max</code> does not
count the intercept, so use <code>nterms_max = 0</code> for the intercept-only model.
For <code><a href="#topic+plot.vsel">plot.vsel()</a></code>, <code>nterms_max</code> must be at least <code>1</code>.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_stats">stats</code></td>
<td>
<p>One or more character strings determining which performance
statistics (i.e., utilities or losses) to estimate based on the
observations in the evaluation (or &quot;test&quot;) set (in case of
cross-validation, these are all observations because they are partitioned
into multiple test sets; in case of <code><a href="#topic+varsel">varsel()</a></code> with <code>d_test = NULL</code>, these
are again all observations because the test set is the same as the training
set). Available statistics are:
</p>

<ul>
<li> <p><code>"elpd"</code>: expected log (pointwise) predictive density (for a new
dataset). Estimated by the sum of the observation-specific log predictive
density values (with each of these predictive density values being
a&mdash;possibly weighted&mdash;average across the parameter draws).
</p>
</li>
<li> <p><code>"mlpd"</code>: mean log predictive density, that is, <code>"elpd"</code> divided by the
number of observations.
</p>
</li>
<li> <p><code>"gmpd"</code>: geometric mean predictive density (GMPD), that is, <code><a href="base.html#topic+exp">exp()</a></code> of
<code>"mlpd"</code>. The GMPD is especially helpful for discrete response families
(because there, the GMPD is bounded by zero and one). For the corresponding
standard error, the delta method is used. The corresponding confidence
interval type is &quot;exponentiated normal approximation&quot; because the
confidence interval bounds are the exponentiated confidence interval bounds
of the <code>"mlpd"</code>.
</p>
</li>
<li> <p><code>"mse"</code>: mean squared error (only available in the situations mentioned
in section &quot;Details&quot; below).
</p>
</li>
<li> <p><code>"rmse"</code>: root mean squared error (only available in the situations
mentioned in section &quot;Details&quot; below). For the corresponding standard error
and lower and upper confidence interval bounds, bootstrapping is used.
</p>
</li>
<li> <p><code>"acc"</code> (or its alias, <code>"pctcorr"</code>): classification accuracy (only
available in the situations mentioned in section &quot;Details&quot; below). By
&quot;classification accuracy&quot;, we mean the proportion of correctly classified
observations. For this, the response category (&quot;class&quot;) with highest
probability (the probabilities are model-based) is taken as the prediction
(&quot;classification&quot;) for an observation.
</p>
</li>
<li> <p><code>"auc"</code>: area under the ROC curve (only available in the situations
mentioned in section &quot;Details&quot; below). For the corresponding standard error
and lower and upper confidence interval bounds, bootstrapping is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.vsel_+3A_deltas">deltas</code></td>
<td>
<p>If <code>TRUE</code>, the submodel statistics are estimated relatively to
the baseline model (see argument <code>baseline</code>). For the GMPD, the term
&quot;relatively&quot; refers to the ratio vs. the baseline model (i.e., the submodel
statistic divided by the baseline model statistic). For all other <code>stats</code>,
&quot;relatively&quot; refers to the difference from the baseline model (i.e., the
submodel statistic minus the baseline model statistic).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_alpha">alpha</code></td>
<td>
<p>A number determining the (nominal) coverage <code>1 - alpha</code> of the
normal-approximation (or bootstrap or exponentiated normal-approximation;
see argument <code>stats</code>) confidence intervals. For example, in case of the
normal approximation, <code>alpha = 2 * pnorm(-1)</code> corresponds to a confidence
interval stretching by one standard error on either side of the point
estimate.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_baseline">baseline</code></td>
<td>
<p>For <code><a href="#topic+summary.vsel">summary.vsel()</a></code>: Only relevant if <code>deltas</code> is <code>TRUE</code>.
For <code><a href="#topic+plot.vsel">plot.vsel()</a></code>: Always relevant. Either <code>"ref"</code> or <code>"best"</code>, indicating
whether the baseline is the reference model or the best submodel found (in
terms of <code>stats[1]</code>), respectively.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_thres_elpd">thres_elpd</code></td>
<td>
<p>Only relevant if <code>any(stats %in% c("elpd", "mlpd", "gmpd"))</code>. The threshold for the ELPD difference (taking the submodel's
ELPD minus the baseline model's ELPD) above which the submodel's ELPD is
considered to be close enough to the baseline model's ELPD. An equivalent
rule is applied in case of the MLPD and the GMPD. See <code><a href="#topic+suggest_size">suggest_size()</a></code> for
a formalization. Supplying <code>NA</code> deactivates this.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_resp_oscale">resp_oscale</code></td>
<td>
<p>Only relevant for the latent projection. A single logical
value indicating whether to calculate the performance statistics on the
original response scale (<code>TRUE</code>) or on latent scale (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_point_size">point_size</code></td>
<td>
<p>Passed to argument <code>size</code> of <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> and
controls the size of the points.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_bar_thickness">bar_thickness</code></td>
<td>
<p>Passed to argument <code>linewidth</code> of
<code><a href="ggplot2.html#topic+geom_linerange">ggplot2::geom_linerange()</a></code> and controls the thickness of the uncertainty
bars.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_nterms_max">ranking_nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms)
for which the predictor names and the corresponding ranking proportions are
added on the x-axis. Using <code>NULL</code> is effectively the same as using
<code>nterms_max</code>. Using <code>NA</code> causes the predictor names and the corresponding
ranking proportions to be omitted. Note that <code>ranking_nterms_max</code> does not
count the intercept, so <code>ranking_nterms_max = 1</code> corresponds to the
submodel consisting of the first (non-intercept) predictor term.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_abbreviate">ranking_abbreviate</code></td>
<td>
<p>A single logical value indicating whether the
predictor names in the full-data predictor ranking should be abbreviated by
<code><a href="base.html#topic+abbreviate">abbreviate()</a></code> (<code>TRUE</code>) or not (<code>FALSE</code>). See also argument
<code>ranking_abbreviate_args</code> and section &quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_abbreviate_args">ranking_abbreviate_args</code></td>
<td>
<p>A <code>list</code> of arguments (except for <code>names.arg</code>)
to be passed to <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> in case of <code>ranking_abbreviate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_repel">ranking_repel</code></td>
<td>
<p>Either <code>NULL</code>, <code>"text"</code>, or <code>"label"</code>. By <code>NULL</code>, the
full-data predictor ranking and the corresponding ranking proportions are
placed below the x-axis. By <code>"text"</code> or <code>"label"</code>, they are placed within
the plotting area, using <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_text_repel()</a></code> or
<code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code>, respectively. See also argument
<code>ranking_repel_args</code>.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_repel_args">ranking_repel_args</code></td>
<td>
<p>A <code>list</code> of arguments (except for <code>mapping</code>) to be
passed to <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_text_repel()</a></code> or <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code> in
case of <code>ranking_repel = "text"</code> or <code>ranking_repel = "label"</code>,
respectively.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_ranking_colored">ranking_colored</code></td>
<td>
<p>A single logical value indicating whether the points
and the uncertainty bars should be gradient-colored according to the CV
ranking proportions (<code>TRUE</code>, currently only works if <code>show_cv_proportions</code>
is <code>TRUE</code> as well) or not (<code>FALSE</code>). The CV ranking proportions may be
cumulated (see argument <code>cumulate</code>). Note that the point and the
uncertainty bar at submodel size 0 (i.e., at the intercept-only model) are
always colored in gray because the intercept is forced to be selected
before any predictors are selected (in other words, the reason is that for
submodel size 0, the question of variability across CV folds is not
appropriate in the first place).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_show_cv_proportions">show_cv_proportions</code></td>
<td>
<p>A single logical value indicating whether the CV
ranking proportions (see <code><a href="#topic+cv_proportions">cv_proportions()</a></code>) should be displayed (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_cumulate">cumulate</code></td>
<td>
<p>Passed to argument <code>cumulate</code> of <code><a href="#topic+cv_proportions">cv_proportions()</a></code>. Affects
the ranking proportions given on the x-axis (below the full-data predictor
ranking).</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_text_angle">text_angle</code></td>
<td>
<p>Passed to argument <code>angle</code> of <code><a href="ggplot2.html#topic+element">ggplot2::element_text()</a></code> for
the x-axis tick labels. In case of long predictor names (and/or large
<code>nterms_max</code>), <code>text_angle = 45</code> might be helpful (for example). If
<code>text_angle &gt; 0</code> (<code style="white-space: pre;">&#8288;&lt; 0&#8288;</code>), the x-axis text is automatically right-aligned
(left-aligned). If <code>-90 &lt; text_angle &amp;&amp; text_angle &lt; 90 &amp;&amp; text_angle != 0</code>, the x-axis text is also top-aligned.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_size_position">size_position</code></td>
<td>
<p>A single character string specifying the position of the
submodel sizes. Either <code>"primary_x_bottom"</code> for including them in the
x-axis tick labels, <code>"primary_x_top"</code> for putting them above the x-axis, or
<code>"secondary_x"</code> for putting them into a secondary x-axis. Currently, both
of the non-default options may not be combined with <code>ranking_nterms_max = NA</code>.</p>
</td></tr>
<tr><td><code id="plot.vsel_+3A_...">...</code></td>
<td>
<p>Arguments passed to the internal function which is used for
bootstrapping (if applicable; see argument <code>stats</code>). Currently, relevant
arguments are <code>B</code> (the number of bootstrap samples, defaulting to <code>2000</code>)
and <code>seed</code> (see <code><a href="base.html#topic+set.seed">set.seed()</a></code>, but defaulting to <code>NA</code> so that <code><a href="base.html#topic+set.seed">set.seed()</a></code>
is not called within that function at all).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stats</code> options <code>"mse"</code> and <code>"rmse"</code> are only available for:
</p>

<ul>
<li><p> the traditional projection,
</p>
</li>
<li><p> the latent projection with <code>resp_oscale = FALSE</code>,
</p>
</li>
<li><p> the latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>.
</p>
</li></ul>

<p>The <code>stats</code> option <code>"acc"</code> (= <code>"pctcorr"</code>) is only available for:
</p>

<ul>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family in case of the traditional projection,
</p>
</li>
<li><p> all families in case of the augmented-data projection,
</p>
</li>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family (on the original response scale) in case of the
latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>,
</p>
</li>
<li><p> all families (on the original response scale) in case of the latent
projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being not <code>NULL</code>.
</p>
</li></ul>

<p>The <code>stats</code> option <code>"auc"</code> is only available for:
</p>

<ul>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family in case of the traditional projection,
</p>
</li>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family (on the original response scale) in case of the
latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> plotting object (of class <code>gg</code> and <code>ggplot</code>). If
<code>ranking_abbreviate</code> is <code>TRUE</code>, the output of <code><a href="base.html#topic+abbreviate">abbreviate()</a></code> is stored in
an attribute called <code>projpred_ranking_abbreviated</code> (to allow the
abbreviations to be easily mapped back to the original predictor names).
</p>


<h3>Horizontal lines</h3>

<p>As long as the reference model's performance is computable, it is always
shown in the plot as a dashed red horizontal line. If <code>baseline = "best"</code>,
the baseline model's performance is shown as a dotted black horizontal line.
If <code>!is.na(thres_elpd)</code> and <code>any(stats %in% c("elpd", "mlpd", "gmpd"))</code>, the
value supplied to <code>thres_elpd</code> (which is automatically adapted internally in
case of the MLPD or the GMPD or <code>deltas = FALSE</code>) is shown as a dot-dashed
gray horizontal line for the reference model and, if <code>baseline = "best"</code>, as
a long-dashed green horizontal line for the baseline model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)
print(plot(vs))

</code></pre>

<hr>
<h2 id='pred-projection'>Predictions from a submodel (after projection)</h2><span id='topic+pred-projection'></span><span id='topic+proj_linpred'></span><span id='topic+proj_predict'></span>

<h3>Description</h3>

<p>After the projection of the reference model onto a submodel, the linear
predictors (for the original or a new dataset) based on that submodel can be
calculated by <code><a href="#topic+proj_linpred">proj_linpred()</a></code>. These linear predictors can also be
transformed to response scale and averaged across the projected parameter
draws. Furthermore, <code><a href="#topic+proj_linpred">proj_linpred()</a></code> returns the corresponding log predictive
density values if the (original or new) dataset contains response values. The
<code><a href="#topic+proj_predict">proj_predict()</a></code> function draws from the predictive distributions (there is
one such distribution for each observation from the original or new dataset)
of the submodel that the reference model has been projected onto. If the
projection has not been performed yet, both functions call <code><a href="#topic+project">project()</a></code>
internally to perform the projection. Both functions can also handle multiple
submodels at once (for <code>object</code>s of class <code>vsel</code> or <code>object</code>s returned by a
<code><a href="#topic+project">project()</a></code> call to an object of class <code>vsel</code>; see <code><a href="#topic+project">project()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_linpred(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  transform = FALSE,
  integrated = FALSE,
  allow_nonconst_wdraws_prj = return_draws_matrix,
  return_draws_matrix = FALSE,
  .seed = NA,
  ...
)

proj_predict(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  nresample_clusters = 1000,
  return_draws_matrix = FALSE,
  .seed = NA,
  resp_oscale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred-projection_+3A_object">object</code></td>
<td>
<p>An object returned by <code><a href="#topic+project">project()</a></code> or an object that can be
passed to argument <code>object</code> of <code><a href="#topic+project">project()</a></code>.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_newdata">newdata</code></td>
<td>
<p>Passed to argument <code>newdata</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Provides the
predictor (and possibly also the response) data for the new (or old)
observations. May also be <code>NULL</code> for using the original dataset. If not
<code>NULL</code>, any <code>NA</code>s will trigger an error.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_offsetnew">offsetnew</code></td>
<td>
<p>Passed to argument <code>orhs</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Used to get the
offsets for the new (or old) observations.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_weightsnew">weightsnew</code></td>
<td>
<p>Passed to argument <code>wrhs</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Used to get the
weights for the new (or old) observations.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_filter_nterms">filter_nterms</code></td>
<td>
<p>Only applies if <code>object</code> is an object returned by
<code><a href="#topic+project">project()</a></code>. In that case, <code>filter_nterms</code> can be used to filter <code>object</code>
for only those elements (submodels) with a number of predictor terms in
<code>filter_nterms</code>. Therefore, needs to be a numeric vector or <code>NULL</code>. If
<code>NULL</code>, use all submodels.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_transform">transform</code></td>
<td>
<p>For <code><a href="#topic+proj_linpred">proj_linpred()</a></code> only. A single logical value indicating
whether the linear predictor should be transformed to response scale using
the inverse-link function (<code>TRUE</code>) or not (<code>FALSE</code>). In case of the latent
projection, argument <code>transform</code> is similar in spirit to argument
<code>resp_oscale</code> from other functions and affects the scale of both output
elements <code>pred</code> and <code>lpd</code> (see sections &quot;Details&quot; and &quot;Value&quot; below).</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_integrated">integrated</code></td>
<td>
<p>For <code><a href="#topic+proj_linpred">proj_linpred()</a></code> only. A single logical value
indicating whether the output should be averaged across the projected
posterior draws (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_allow_nonconst_wdraws_prj">allow_nonconst_wdraws_prj</code></td>
<td>
<p>Only relevant for <code><a href="#topic+proj_linpred">proj_linpred()</a></code> and only
if <code>integrated</code> is <code>FALSE</code>. A single logical value indicating whether to
allow projected draws with different (i.e., nonconstant) weights (<code>TRUE</code>)
or not (<code>FALSE</code>). If <code>return_draws_matrix</code> is <code>TRUE</code>,
<code>allow_nonconst_wdraws_prj</code> is internally set to <code>TRUE</code> as well.
<strong>CAUTION</strong>: Expert use only because if set to <code>TRUE</code>, the weights of the
projected draws are stored in attributes <code>wdraws_prj</code> and handling these
attributes requires special care (e.g., when subsetting the returned
matrices).</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_return_draws_matrix">return_draws_matrix</code></td>
<td>
<p>A single logical value indicating whether to
return an object (in case of <code><a href="#topic+proj_predict">proj_predict()</a></code>) or objects (in case of
<code><a href="#topic+proj_linpred">proj_linpred()</a></code>) of class <code>draws_matrix</code> (see
<code><a href="posterior.html#topic+draws_matrix">posterior::draws_matrix()</a></code>). In case of <code><a href="#topic+proj_linpred">proj_linpred()</a></code> and projected
draws with nonconstant weights (as well as <code>integrated</code> being <code>FALSE</code>),
<code><a href="posterior.html#topic+weight_draws">posterior::weight_draws()</a></code> is applied internally.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_.seed">.seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling
<code><a href="#topic+proj_linpred">proj_linpred()</a></code> or <code><a href="#topic+proj_predict">proj_predict()</a></code>) upon exiting <code><a href="#topic+proj_linpred">proj_linpred()</a></code> or
<code><a href="#topic+proj_predict">proj_predict()</a></code>. Here, <code>.seed</code> is used for drawing new group-level effects
in case of a multilevel submodel (however, not yet in case of a GAMM) and
for drawing from the predictive distributions of the submodel(s) in case of
<code><a href="#topic+proj_predict">proj_predict()</a></code>. If a clustered projection was performed, then in
<code><a href="#topic+proj_predict">proj_predict()</a></code>, <code>.seed</code> is also used for drawing from the set of
projected clusters of posterior draws (see argument <code>nresample_clusters</code>).
If <code><a href="#topic+project">project()</a></code> is called internally with <code>seed = NA</code> (or with <code>seed</code> being
a lazily evaluated expression that uses the PRNG), then <code>.seed</code> also
affects the PRNG usage there.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+project">project()</a></code> if <code>object</code> is not already an
object returned by <code><a href="#topic+project">project()</a></code>.</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_nresample_clusters">nresample_clusters</code></td>
<td>
<p>For <code><a href="#topic+proj_predict">proj_predict()</a></code> with clustered projection (and
nonconstant weights for the projected draws) only. Number of draws to
return from the predictive distributions of the submodel(s). Not to be
confused with argument <code>nclusters</code> of <code><a href="#topic+project">project()</a></code>: <code>nresample_clusters</code>
gives the number of draws (<em>with</em> replacement) from the set of clustered
posterior draws after projection (with this set being determined by
argument <code>nclusters</code> of <code><a href="#topic+project">project()</a></code>).</p>
</td></tr>
<tr><td><code id="pred-projection_+3A_resp_oscale">resp_oscale</code></td>
<td>
<p>Only relevant for the latent projection. A single logical
value indicating whether to draw from the posterior-projection predictive
distributions on the original response scale (<code>TRUE</code>) or on latent scale
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code><a href="#topic+proj_predict">proj_predict()</a></code> ignores observation weights that are not
equal to <code>1</code>. A corresponding warning is thrown if this is the case.
</p>
<p>In case of the latent projection and <code>transform = FALSE</code>:
</p>

<ul>
<li><p> Output element <code>pred</code> contains the linear predictors without any
modifications that may be due to the original response distribution (e.g.,
for a <code><a href="brms.html#topic+brmsfamily">brms::cumulative()</a></code> model, the ordered thresholds are not taken into
account).
</p>
</li>
<li><p> Output element <code>lpd</code> contains the <em>latent</em> log predictive density values,
i.e., those corresponding to the latent Gaussian distribution. If <code>newdata</code>
is not <code>NULL</code>, this requires the latent response values to be supplied in a
column called <code style="white-space: pre;">&#8288;.&lt;response_name&gt;&#8288;</code> of <code>newdata</code> where <code style="white-space: pre;">&#8288;&lt;response_name&gt;&#8288;</code> needs
to be replaced by the name of the original response variable (if
<code style="white-space: pre;">&#8288;&lt;response_name&gt;&#8288;</code> contained parentheses, these have been stripped off by
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>; see the left-hand side of <code style="white-space: pre;">&#8288;formula(&lt;refmodel&gt;)&#8288;</code>). For
technical reasons, the existence of column <code style="white-space: pre;">&#8288;&lt;response_name&gt;&#8288;</code> in <code>newdata</code>
is another requirement (even though <code style="white-space: pre;">&#8288;.&lt;response_name&gt;&#8288;</code> is actually used).
</p>
</li></ul>



<h3>Value</h3>

<p>In the following, <code class="reqn">S_{\mathrm{prj}}</code>, <code class="reqn">N</code>,
<code class="reqn">C_{\mathrm{cat}}</code>, and <code class="reqn">C_{\mathrm{lat}}</code> from help
topic <a href="#topic+refmodel-init-get">refmodel-init-get</a> are used. (For <code><a href="#topic+proj_linpred">proj_linpred()</a></code> with <code>integrated = TRUE</code>, we have <code class="reqn">S_{\mathrm{prj}} = 1</code>.) Furthermore, let
<code class="reqn">C</code> denote either <code class="reqn">C_{\mathrm{cat}}</code> (if <code>transform = TRUE</code>)
or <code class="reqn">C_{\mathrm{lat}}</code> (if <code>transform = FALSE</code>). Then, if the
prediction is done for one submodel only (i.e., <code>length(nterms) == 1 || !is.null(predictor_terms)</code> in the explicit or implicit call to <code><a href="#topic+project">project()</a></code>,
see argument <code>object</code>):
</p>

<ul>
<li> <p><code><a href="#topic+proj_linpred">proj_linpred()</a></code> returns a <code>list</code> with the following elements:
</p>

<ul>
<li><p> Element <code>pred</code> contains the actual predictions, i.e., the linear
predictors, possibly transformed to response scale (depending on
argument <code>transform</code>).
</p>
</li>
<li><p> Element <code>lpd</code> is non-<code>NULL</code> only if <code>newdata</code> is <code>NULL</code> or if
<code>newdata</code> contains response values in the corresponding column. In that
case, it contains the log predictive density values (conditional on
each of the projected parameter draws if <code>integrated = FALSE</code> and
averaged across the projected parameter draws if <code>integrated = TRUE</code>).
</p>
</li></ul>

<p>In case of (i) the traditional projection, (ii) the latent projection
with <code>transform = FALSE</code>, or (iii) the latent projection with
<code>transform = TRUE</code> and <code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> (where <code style="white-space: pre;">&#8288;&lt;refmodel&gt;&#8288;</code> is
an object resulting from <code><a href="#topic+init_refmodel">init_refmodel()</a></code>; see also
<code><a href="#topic+extend_family">extend_family()</a></code>'s argument <code>latent_y_unqs</code>) being <code>NULL</code>, both
elements are <code class="reqn">S_{\mathrm{prj}} \times N</code> matrices
(converted to a&mdash;possibly weighted&mdash;<code>draws_matrix</code> if argument
<code>return_draws_matrix</code> is <code>TRUE</code>, see the description of this argument).
In case of (i) the augmented-data projection or (ii) the latent
projection with <code>transform = TRUE</code> and <code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being
not <code>NULL</code>, <code>pred</code> is an <code class="reqn">S_{\mathrm{prj}} \times N \times C</code> array (if argument <code>return_draws_matrix</code> is <code>TRUE</code>, this array
is &quot;compressed&quot; to an <code class="reqn">S_{\mathrm{prj}} \times (N \cdot C)</code> matrix&mdash;with the columns consisting of <code class="reqn">C</code> blocks of
<code class="reqn">N</code> rows&mdash;and then converted to a&mdash;possibly
weighted&mdash;<code>draws_matrix</code>) and <code>lpd</code> is an <code class="reqn">S_{\mathrm{prj}} \times
      N</code> matrix (converted to a&mdash;possibly
weighted&mdash;<code>draws_matrix</code> if argument <code>return_draws_matrix</code> is <code>TRUE</code>).
If <code>return_draws_matrix</code> is <code>FALSE</code> and <code>allow_nonconst_wdraws_prj</code> is
<code>TRUE</code> and <code>integrated</code> is <code>FALSE</code> and the projected draws have
nonconstant weights, then both <code>list</code> elements have the weights of
these draws stored in an attribute <code>wdraws_prj</code>. (If
<code>return_draws_matrix</code>, <code>allow_nonconst_wdraws_prj</code>, and <code>integrated</code>
are all <code>FALSE</code>, then projected draws with nonconstant weights cause an
error.)
</p>
</li>
<li> <p><code><a href="#topic+proj_predict">proj_predict()</a></code> returns an <code class="reqn">S_{\mathrm{prj}} \times N</code>
matrix of predictions where <code class="reqn">S_{\mathrm{prj}}</code> denotes
<code>nresample_clusters</code> in case of clustered projection (or, more generally,
in case of projected draws with nonconstant weights). If argument
<code>return_draws_matrix</code> is <code>TRUE</code>, the returned matrix is converted to a
<code>draws_matrix</code> (see <code><a href="posterior.html#topic+draws_matrix">posterior::draws_matrix()</a></code>). In case of (i) the
augmented-data projection or (ii) the latent projection with <code>resp_oscale =   TRUE</code> and <code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being not <code>NULL</code>, the returned matrix
(or <code>draws_matrix</code>) has an attribute called <code>cats</code> (the character vector of
response categories) and the values of the matrix (or <code>draws_matrix</code>) are
the predicted indices of the response categories (these indices refer to
the order of the response categories from attribute <code>cats</code>).
</p>
</li></ul>

<p>If the prediction is done for more than one submodel, the output from above
is returned for each submodel, giving a named <code>list</code> with one element for
each submodel (the names of this <code>list</code> being the numbers of predictor
terms of the submodels when counting the intercept, too).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Projection onto an arbitrary combination of predictor terms (with a small
# value for `ndraws`, but only for the sake of speed in this example; this
# is not recommended in general):
prj &lt;- project(fit, predictor_terms = c("X1", "X3", "X5"), ndraws = 21,
               seed = 9182)

# Predictions (at the training points) from the submodel onto which the
# reference model was projected:
prjl &lt;- proj_linpred(prj)
prjp &lt;- proj_predict(prj, .seed = 7364)

</code></pre>

<hr>
<h2 id='predict.refmodel'>Predictions or log posterior predictive densities from a reference model</h2><span id='topic+predict.refmodel'></span>

<h3>Description</h3>

<p>This is the <code><a href="stats.html#topic+predict">predict()</a></code> method for <code>refmodel</code> objects (returned by
<code><a href="#topic+get_refmodel">get_refmodel()</a></code> or <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). It offers three types of output which
are all based on the reference model and new (or old) observations: Either
the linear predictor on link scale, the linear predictor transformed to
response scale, or the log posterior predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'refmodel'
predict(
  object,
  newdata = NULL,
  ynew = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  type = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.refmodel_+3A_object">object</code></td>
<td>
<p>An object of class <code>refmodel</code> (returned by <code><a href="#topic+get_refmodel">get_refmodel()</a></code> or
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>).</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_newdata">newdata</code></td>
<td>
<p>Passed to argument <code>newdata</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Provides the
predictor (and possibly also the response) data for the new (or old)
observations. May also be <code>NULL</code> for using the original dataset. If not
<code>NULL</code>, any <code>NA</code>s will trigger an error.</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_ynew">ynew</code></td>
<td>
<p>If not <code>NULL</code>, then this needs to be a vector of new (or old)
response values. See also section &quot;Value&quot; below. In case of (i) the
augmented-data projection or (ii) the latent projection with <code>type = "response"</code> and <code>object$family$cats</code> being not <code>NULL</code>, <code>ynew</code> is internally
coerced to a <code>factor</code> (using <code><a href="base.html#topic+as.factor">as.factor()</a></code>). The levels of this <code>factor</code>
have to be a subset of <code>object$family$cats</code> (see <code><a href="#topic+extend_family">extend_family()</a></code>'s
arguments <code>augdat_y_unqs</code> and <code>latent_y_unqs</code>, respectively).</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_offsetnew">offsetnew</code></td>
<td>
<p>Passed to argument <code>orhs</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Used to get the
offsets for the new (or old) observations.</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_weightsnew">weightsnew</code></td>
<td>
<p>Passed to argument <code>wrhs</code> of the reference model's
<code>extract_model_data</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). Used to get the
weights for the new (or old) observations.</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_type">type</code></td>
<td>
<p>Usually only relevant if <code>is.null(ynew)</code>, but for the latent
projection, this also affects the <code>!is.null(ynew)</code> case (see below). The
scale on which the predictions are returned, either <code>"link"</code> or
<code>"response"</code> (see <code><a href="stats.html#topic+predict.glm">predict.glm()</a></code> but note that <code><a href="#topic+predict.refmodel">predict.refmodel()</a></code> does
not adhere to the typical <span class="rlang"><b>R</b></span> convention of a default prediction on link
scale). For both scales, the predictions are averaged across the posterior
draws. In case of the latent projection, argument <code>type</code> is similar in
spirit to argument <code>resp_oscale</code> from other functions: If (i)
<code>is.null(ynew)</code>, then argument <code>type</code> affects the predictions as described
above. In that case, note that <code>type = "link"</code> yields the linear predictors
without any modifications that may be due to the original response
distribution (e.g., for a <code><a href="brms.html#topic+brmsfamily">brms::cumulative()</a></code> model, the ordered
thresholds are not taken into account). If (ii) <code>!is.null(ynew)</code>, then
argument <code>type</code> also affects the scale of the log posterior predictive
densities (<code>type = "response"</code> for the original response scale, <code>type = "link"</code> for the latent Gaussian scale).</p>
</td></tr>
<tr><td><code id="predict.refmodel_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>weightsnew</code> is only relevant if <code>!is.null(ynew)</code>.
</p>
<p>In case of a multilevel reference model, group-level effects for new group
levels are drawn randomly from a (multivariate) Gaussian distribution. When
setting <code>projpred.mlvl_pred_new</code> to <code>TRUE</code>, all group levels from <code>newdata</code>
(even those that already exist in the original dataset) are treated as new
group levels (if <code>is.null(newdata)</code>, all group levels from the original
dataset are considered as new group levels in that case).
</p>


<h3>Value</h3>

<p>In the following, <code class="reqn">N</code>, <code class="reqn">C_{\mathrm{cat}}</code>, and
<code class="reqn">C_{\mathrm{lat}}</code> from help topic <a href="#topic+refmodel-init-get">refmodel-init-get</a> are used.
Furthermore, let <code class="reqn">C</code> denote either <code class="reqn">C_{\mathrm{cat}}</code> (if
<code>type = "response"</code>) or <code class="reqn">C_{\mathrm{lat}}</code> (if <code>type = "link"</code>).
Then, if <code>is.null(ynew)</code>, the returned object contains the reference
model's predictions (with the scale depending on argument <code>type</code>) as:
</p>

<ul>
<li><p> a length-<code class="reqn">N</code> vector in case of (i) the traditional projection, (ii)
the latent projection with <code>type = "link"</code>, or (iii) the latent projection
with <code>type = "response"</code> and <code>object$family$cats</code> being <code>NULL</code>;
</p>
</li>
<li><p> an <code class="reqn">N \times C</code> matrix in case of (i) the augmented-data
projection or (ii) the latent projection with <code>type = "response"</code> and
<code>object$family$cats</code> being not <code>NULL</code>.
</p>
</li></ul>

<p>If <code>!is.null(ynew)</code>, the returned object is a length-<code class="reqn">N</code> vector of log
posterior predictive densities evaluated at <code>ynew</code>.
</p>

<hr>
<h2 id='predictor_terms'>Predictor terms used in a <code><a href="#topic+project">project()</a></code> run</h2><span id='topic+predictor_terms'></span><span id='topic+predictor_terms.projection'></span>

<h3>Description</h3>

<p>For a <code>projection</code> object (returned by <code><a href="#topic+project">project()</a></code>, possibly as elements of a
<code>list</code>), this function extracts the combination of predictor terms onto which
the projection was performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictor_terms(object, ...)

## S3 method for class 'projection'
predictor_terms(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictor_terms_+3A_object">object</code></td>
<td>
<p>An object of class <code>projection</code> (returned by <code><a href="#topic+project">project()</a></code>,
possibly as elements of a <code>list</code>) from which to retrieve the predictor
terms.</p>
</td></tr>
<tr><td><code id="predictor_terms_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of predictor terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Projection onto an arbitrary combination of predictor terms (with a small
# value for `nclusters`, but only for the sake of speed in this example;
# this is not recommended in general):
prj &lt;- project(fit, predictor_terms = c("X1", "X3", "X5"), nclusters = 10,
               seed = 9182)
print(predictor_terms(prj)) # gives `c("X1", "X3", "X5")`

</code></pre>

<hr>
<h2 id='print.projection'>Print information about <code><a href="#topic+project">project()</a></code> output</h2><span id='topic+print.projection'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+print">print()</a></code> method for objects of class <code>projection</code>. This method
mainly exists to avoid cluttering the console when printing such objects
accidentally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'projection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.projection_+3A_x">x</code></td>
<td>
<p>An object of class <code>projection</code> (returned by <code><a href="#topic+project">project()</a></code>, possibly
as elements of a <code>list</code>).</p>
</td></tr>
<tr><td><code id="print.projection_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code> (invisible).
</p>

<hr>
<h2 id='print.refmodel'>Print information about a reference model object</h2><span id='topic+print.refmodel'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+print">print()</a></code> method for reference model objects (objects of class
<code>refmodel</code>). This method mainly exists to avoid cluttering the console when
printing such objects accidentally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'refmodel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.refmodel_+3A_x">x</code></td>
<td>
<p>An object of class <code>refmodel</code> (returned by <code><a href="#topic+get_refmodel">get_refmodel()</a></code> or
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>).</p>
</td></tr>
<tr><td><code id="print.refmodel_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code> (invisible).
</p>

<hr>
<h2 id='print.vsel'>Print results (summary) of a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run</h2><span id='topic+print.vsel'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+print">print()</a></code> method for <code>vsel</code> objects (returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>). It displays a summary of a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run by
first calling <code><a href="#topic+summary.vsel">summary.vsel()</a></code> and then <code><a href="#topic+print.vselsummary">print.vselsummary()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vsel'
print(x, digits = getOption("projpred.digits", 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vsel_+3A_x">x</code></td>
<td>
<p>An object of class <code>vsel</code> (returned by <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>).</p>
</td></tr>
<tr><td><code id="print.vsel_+3A_digits">digits</code></td>
<td>
<p>Passed to argument <code>digits</code> of <code><a href="#topic+print.vselsummary">print.vselsummary()</a></code>.</p>
</td></tr>
<tr><td><code id="print.vsel_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+summary.vsel">summary.vsel()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of <code><a href="#topic+summary.vsel">summary.vsel()</a></code> (invisible).
</p>

<hr>
<h2 id='print.vselsummary'>Print summary of a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run</h2><span id='topic+print.vselsummary'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+print">print()</a></code> method for summary objects created by <code><a href="#topic+summary.vsel">summary.vsel()</a></code>.
It displays a summary of the results from a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vselsummary'
print(x, digits = getOption("projpred.digits", 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vselsummary_+3A_x">x</code></td>
<td>
<p>An object of class <code>vselsummary</code>.</p>
</td></tr>
<tr><td><code id="print.vselsummary_+3A_digits">digits</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code> (for the table containing the
submodel performance evaluation results) and <code><a href="base.html#topic+print.default">print.default()</a></code> (for the
vector containing the reference model performance evaluation results).</p>
</td></tr>
<tr><td><code id="print.vselsummary_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+print.data.frame">print.data.frame()</a></code> (for the table containing
the submodel performance evaluation results) and <code><a href="base.html#topic+print.default">print.default()</a></code> (for the
vector containing the reference model performance evaluation results).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the submodel predictive performance table printed at (or towards)
the bottom, column <code>ranking_fulldata</code> contains the full-data predictor
ranking and column <code>cv_proportions_diag</code> contains the main diagonal of the
matrix returned by <code><a href="#topic+cv_proportions">cv_proportions()</a></code> (with <code>cumulate</code> as set in the
<code><a href="#topic+summary.vsel">summary.vsel()</a></code> call that created <code>x</code>). To retrieve the fold-wise
predictor rankings, use the <code><a href="#topic+ranking">ranking()</a></code> function, possibly followed by
<code><a href="#topic+cv_proportions">cv_proportions()</a></code> for computing the ranking proportions (which can be
visualized by <code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>).
</p>


<h3>Value</h3>

<p>The output of <code><a href="#topic+summary.vsel">summary.vsel()</a></code> (invisible).
</p>

<hr>
<h2 id='project'>Projection onto submodel(s)</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Project the posterior of the reference model onto the parameter space of a
single submodel consisting of a specific combination of predictor terms or
(after variable selection) onto the parameter space of a single or multiple
submodels of specific sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  object,
  nterms = NULL,
  solution_terms = predictor_terms,
  predictor_terms = NULL,
  refit_prj = TRUE,
  ndraws = 400,
  nclusters = NULL,
  seed = NA,
  verbose = getOption("projpred.verbose_project", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_+3A_object">object</code></td>
<td>
<p>An object which can be used as input to <code><a href="#topic+get_refmodel">get_refmodel()</a></code> (in
particular, objects of class <code>refmodel</code>).</p>
</td></tr>
<tr><td><code id="project_+3A_nterms">nterms</code></td>
<td>
<p>Only relevant if <code>object</code> is of class <code>vsel</code> (returned by
<code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>). Ignored if <code>!is.null(predictor_terms)</code>.
Number of terms for the submodel (the corresponding combination of
predictor terms is taken from <code>object</code>). If a numeric vector, then the
projection is performed for each element of this vector. If <code>NULL</code> (and
<code>is.null(predictor_terms)</code>), then the value suggested by <code><a href="#topic+suggest_size">suggest_size()</a></code>
is taken (with default arguments for <code><a href="#topic+suggest_size">suggest_size()</a></code>, implying that this
suggested size is based on the ELPD). Note that <code>nterms</code> does not count the
intercept, so use <code>nterms = 0</code> for the intercept-only model.</p>
</td></tr>
<tr><td><code id="project_+3A_solution_terms">solution_terms</code></td>
<td>
<p>Deprecated. Please use argument <code>predictor_terms</code>
instead.</p>
</td></tr>
<tr><td><code id="project_+3A_predictor_terms">predictor_terms</code></td>
<td>
<p>If not <code>NULL</code>, then this needs to be a character
vector of predictor terms for the submodel onto which the projection will
be performed. Argument <code>nterms</code> is ignored in that case. For an <code>object</code>
which is not of class <code>vsel</code>, <code>predictor_terms</code> must not be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_refit_prj">refit_prj</code></td>
<td>
<p>A single logical value indicating whether to fit the
submodels (again) (<code>TRUE</code>) or&mdash;if <code>object</code> is of class <code>vsel</code>&mdash;to re-use
the submodel fits from the full-data search that was run when creating
<code>object</code> (<code>FALSE</code>). For an <code>object</code> which is not of class <code>vsel</code>,
<code>refit_prj</code> must be <code>TRUE</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="project_+3A_ndraws">ndraws</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of posterior
draws to be projected. Ignored if <code>nclusters</code> is not <code>NULL</code> or if the
reference model is of class <code>datafit</code> (in which case one cluster is used).
If both (<code>nclusters</code> and <code>ndraws</code>) are <code>NULL</code>, the number of posterior
draws from the reference model is used for <code>ndraws</code>. See also section
&quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="project_+3A_nclusters">nclusters</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of clusters
of posterior draws to be projected. Ignored if the reference model is of
class <code>datafit</code> (in which case one cluster is used). For the meaning of
<code>NULL</code>, see argument <code>ndraws</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="project_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling
<code><a href="#topic+project">project()</a></code>) upon exiting <code><a href="#topic+project">project()</a></code>. Here, <code>seed</code> is used for clustering
the reference model's posterior draws (if <code>!is.null(nclusters)</code>) and for
drawing new group-level effects when predicting from a multilevel submodel
(however, not yet in case of a GAMM) and having global option
<code>projpred.mlvl_pred_new</code> set to <code>TRUE</code>. (Such a prediction takes place when
calculating output elements <code>dis</code> and <code>ce</code>.)</p>
</td></tr>
<tr><td><code id="project_+3A_verbose">verbose</code></td>
<td>
<p>A single logical value indicating whether to print out
additional information during the computations. More precisely, this gets
passed as <code>verbose_divmin</code> to the divergence minimizer function of the
<code>refmodel</code> object. For the built-in divergence minimizers, this only has an
effect in case of sequential computations (not in case of parallel
projection, which is described in <a href="#topic+projpred-package">projpred-package</a>).</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+get_refmodel">get_refmodel()</a></code> (if <code><a href="#topic+get_refmodel">get_refmodel()</a></code> is
actually used; see argument <code>object</code>) as well as to the divergence
minimizer (if <code>refit_prj</code> is <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>ndraws</code> and <code>nclusters</code> are automatically truncated at
the number of posterior draws in the reference model (which is <code>1</code> for
<code>datafit</code>s). Using less draws or clusters in <code>ndraws</code> or <code>nclusters</code> than
posterior draws in the reference model may result in slightly inaccurate
projection performance. Increasing these arguments affects the computation
time linearly.
</p>
<p>If <code>refit_prj = FALSE</code> (which is only possible if <code>object</code> is of class
<code>vsel</code>), <code><a href="#topic+project">project()</a></code> retrieves the submodel fits from the full-data search
that was run when creating <code>object</code>. Usually, the search relies on a rather
coarse clustering or thinning of the reference model's posterior draws (by
default, <code><a href="#topic+varsel">varsel()</a></code> and <code><a href="#topic+cv_varsel">cv_varsel()</a></code> use <code>nclusters = 20</code>). Consequently,
<code><a href="#topic+project">project()</a></code> with <code>refit_prj = FALSE</code> then inherits this coarse clustering
or thinning.
</p>


<h3>Value</h3>

<p>If the projection is performed onto a single submodel (i.e.,
<code>length(nterms) == 1 || !is.null(predictor_terms)</code>), an object of class
<code>projection</code> which is a <code>list</code> containing the following elements:
</p>

<dl>
<dt><code>dis</code></dt><dd><p>Projected draws for the dispersion parameter.</p>
</dd>
<dt><code>ce</code></dt><dd><p>The cross-entropy part of the Kullback-Leibler (KL)
divergence from the reference model to the submodel. For some families,
this is not the actual cross-entropy, but a reduced one where terms which
would cancel out when calculating the KL divergence have been dropped. In
case of the Gaussian family, that reduced cross-entropy is further
modified, yielding merely a proxy.</p>
</dd>
<dt><code>wdraws_prj</code></dt><dd><p>Weights for the projected draws.</p>
</dd>
<dt><code>predictor_terms</code></dt><dd><p>A character vector of the submodel's predictor
terms.</p>
</dd>
<dt><code>outdmin</code></dt><dd><p>A <code>list</code> containing the submodel fits (one fit per
projected draw). This is the same as the return value of the
<code>div_minimizer</code> function (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>), except if <code><a href="#topic+project">project()</a></code>
was used with an <code>object</code> of class <code>vsel</code> based on an L1 search as well
as with <code>refit_prj = FALSE</code>, in which case this is the output from an
internal <em>L1-penalized</em> divergence minimizer.</p>
</dd>
<dt><code>cl_ref</code></dt><dd><p>A numeric vector of length equal to the number of
posterior draws in the reference model, containing the cluster indices of
these draws.</p>
</dd>
<dt><code>wdraws_ref</code></dt><dd><p>A numeric vector of length equal to the number of
posterior draws in the reference model, giving the weights of these
draws. These weights should be treated as not being normalized (i.e.,
they don't necessarily sum to <code>1</code>).</p>
</dd>
<dt><code>const_wdraws_prj</code></dt><dd><p>A single logical value indicating whether the
projected draws have constant weights (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</dd>
<dt><code>refmodel</code></dt><dd><p>The reference model object.</p>
</dd>
</dl>

<p>If the projection is performed onto more than one submodel, the output from
above is returned for each submodel, giving a <code>list</code> with one element for
each submodel.
</p>
<p>The elements of an object of class <code>projection</code> are not meant to be
accessed directly but instead via helper functions (see the main vignette
and <a href="#topic+projpred-package">projpred-package</a>; see also <code><a href="#topic+as_draws_matrix.projection">as_draws_matrix.projection()</a></code>, argument
<code>return_draws_matrix</code> of <code><a href="#topic+proj_linpred">proj_linpred()</a></code>, and argument
<code>nresample_clusters</code> of <code><a href="#topic+proj_predict">proj_predict()</a></code> for the intended use of the
weights stored in element <code>wdraws_prj</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)

# Projection onto the best submodel with 2 predictor terms (with a small
# value for `nclusters`, but only for the sake of speed in this example;
# this is not recommended in general):
prj_from_vs &lt;- project(vs, nterms = 2, nclusters = 10, seed = 9182)

# Projection onto an arbitrary combination of predictor terms (with a small
# value for `nclusters`, but only for the sake of speed in this example;
# this is not recommended in general):
prj &lt;- project(fit, predictor_terms = c("X1", "X3", "X5"), nclusters = 10,
               seed = 9182)

</code></pre>

<hr>
<h2 id='ranking'>Predictor ranking(s)</h2><span id='topic+ranking'></span><span id='topic+ranking.vsel'></span>

<h3>Description</h3>

<p>Extracts the <em>predictor ranking(s)</em> from an object of class <code>vsel</code> (returned
by <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>). A predictor ranking is simply a character
vector of predictor terms ranked by predictive relevance (with the most
relevant term first). In any case, objects of class <code>vsel</code> contain the
predictor ranking based on the <em>full-data</em> search. If an object of class
<code>vsel</code> is based on a cross-validation (CV) with fold-wise searches (i.e., if
it was created by <code><a href="#topic+cv_varsel">cv_varsel()</a></code> with <code>validate_search = TRUE</code>), then it also
contains <em>fold-wise</em> predictor rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranking(object, ...)

## S3 method for class 'vsel'
ranking(object, nterms_max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranking_+3A_object">object</code></td>
<td>
<p>The object from which to retrieve the predictor ranking(s).
Possible classes may be inferred from the names of the corresponding
methods (see also the description).</p>
</td></tr>
<tr><td><code id="ranking_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="ranking_+3A_nterms_max">nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms) for the
predictor ranking(s), i.e., the submodel size at which to cut off the
predictor ranking(s). Using <code>NULL</code> is effectively the same as setting
<code>nterms_max</code> to the full model size, i.e., this means to not cut off the
predictor ranking(s) at all. Note that <code>nterms_max</code> does not count the
intercept, so <code>nterms_max = 1</code> corresponds to the submodel consisting of
the first (non-intercept) predictor term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ranking</code> which is a <code>list</code> with the following
elements:
</p>

<ul>
<li> <p><code>fulldata</code>: The predictor ranking from the full-data search.
</p>
</li>
<li> <p><code>foldwise</code>: The predictor rankings from the fold-wise
searches in the form of a character matrix (only available if <code>object</code> is
based on a CV with fold-wise searches, otherwise element <code>foldwise</code> is
<code>NULL</code>). The rows of this matrix correspond to the CV folds and the columns
to the submodel sizes. Each row contains the predictor ranking from the
search of that CV fold.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cv_proportions">cv_proportions()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an example, see `?plot.cv_proportions`.

</code></pre>

<hr>
<h2 id='refmodel-init-get'>Reference model and more general information</h2><span id='topic+refmodel-init-get'></span><span id='topic+get_refmodel'></span><span id='topic+get_refmodel.refmodel'></span><span id='topic+get_refmodel.vsel'></span><span id='topic+get_refmodel.projection'></span><span id='topic+get_refmodel.default'></span><span id='topic+get_refmodel.stanreg'></span><span id='topic+init_refmodel'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+get_refmodel">get_refmodel()</a></code> is a generic function whose methods usually call
<code><a href="#topic+init_refmodel">init_refmodel()</a></code> which is the underlying workhorse (and may also be used
directly without a call to <code><a href="#topic+get_refmodel">get_refmodel()</a></code>).
</p>
<p>Both, <code><a href="#topic+get_refmodel">get_refmodel()</a></code> and <code><a href="#topic+init_refmodel">init_refmodel()</a></code>, create an object containing
information needed for the projection predictive variable selection, namely
about the reference model, the submodels, and how the projection should be
carried out. For the sake of simplicity, the documentation may refer to the
resulting object also as &quot;reference model&quot; or &quot;reference model object&quot;, even
though it also contains information about the submodels and the projection.
</p>
<p>A &quot;typical&quot; reference model object is created by <code><a href="#topic+get_refmodel.stanreg">get_refmodel.stanreg()</a></code> and
<code><a href="brms.html#topic+get_refmodel.brmsfit">brms::get_refmodel.brmsfit()</a></code>, either implicitly by a call to a top-level
function such as <code><a href="#topic+project">project()</a></code>, <code><a href="#topic+varsel">varsel()</a></code>, and <code><a href="#topic+cv_varsel">cv_varsel()</a></code> or explicitly by
a call to <code><a href="#topic+get_refmodel">get_refmodel()</a></code>. All non-&quot;typical&quot; reference model objects will be
called &quot;custom&quot; reference model objects.
</p>
<p>Some arguments are for <code class="reqn">K</code>-fold cross-validation (<code class="reqn">K</code>-fold CV) only;
see <code><a href="#topic+cv_varsel">cv_varsel()</a></code> for the use of <code class="reqn">K</code>-fold CV in <span class="pkg">projpred</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_refmodel(object, ...)

## S3 method for class 'refmodel'
get_refmodel(object, ...)

## S3 method for class 'vsel'
get_refmodel(object, ...)

## S3 method for class 'projection'
get_refmodel(object, ...)

## Default S3 method:
get_refmodel(object, family = NULL, ...)

## S3 method for class 'stanreg'
get_refmodel(object, latent = FALSE, dis = NULL, ...)

init_refmodel(
  object,
  data,
  formula,
  family,
  ref_predfun = NULL,
  div_minimizer = NULL,
  proj_predfun = NULL,
  extract_model_data = NULL,
  cvfun = NULL,
  cvfits = NULL,
  dis = NULL,
  cvrefbuilder = NULL,
  called_from_cvrefbuilder = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refmodel-init-get_+3A_object">object</code></td>
<td>
<p>For <code><a href="#topic+init_refmodel">init_refmodel()</a></code>, an object that the functions from
arguments <code>extract_model_data</code> and <code>ref_predfun</code> can be applied to, with a
<code>NULL</code> object being treated specially (see section &quot;Value&quot; below). For
<code><a href="#topic+get_refmodel.default">get_refmodel.default()</a></code>, an object that function <code><a href="stats.html#topic+family">family()</a></code> can be applied
to in order to retrieve the family (if argument <code>family</code> is <code>NULL</code>),
additionally to the properties required for <code><a href="#topic+init_refmodel">init_refmodel()</a></code>. For
non-default methods of <code><a href="#topic+get_refmodel">get_refmodel()</a></code>, an object of the corresponding
class.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+get_refmodel.default">get_refmodel.default()</a></code> and <code><a href="#topic+get_refmodel.stanreg">get_refmodel.stanreg()</a></code>:
arguments passed to <code><a href="#topic+init_refmodel">init_refmodel()</a></code>. For the <code><a href="#topic+get_refmodel">get_refmodel()</a></code> generic:
arguments passed to the appropriate method. For <code><a href="#topic+init_refmodel">init_refmodel()</a></code>:
arguments passed to <code><a href="#topic+extend_family">extend_family()</a></code> (apart from <code>family</code>).</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_family">family</code></td>
<td>
<p>An object of class <code>family</code> representing the observation model
(i.e., the distributional family for the response) of the <em>submodels</em>.
(However, the link and the inverse-link function of this <code>family</code> are also
used for quantities like predictions and fitted values related to the
<em>reference model</em>.) May be <code>NULL</code> for <code><a href="#topic+get_refmodel.default">get_refmodel.default()</a></code> in which
case the family is retrieved from <code>object</code>. For custom reference models,
<code>family</code> does not have to coincide with the family of the reference model
(if the reference model possesses a formal <code>family</code> at all). In typical
reference models, however, these families do coincide. Furthermore, the
latent projection is an exception where <code>family</code> is not the family of the
submodels (in that case, the family of the submodels is the <code><a href="stats.html#topic+gaussian">gaussian()</a></code>
family).</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_latent">latent</code></td>
<td>
<p>A single logical value indicating whether to use the latent
projection (<code>TRUE</code>) or not (<code>FALSE</code>). Note that setting <code>latent = TRUE</code>
causes all arguments starting with <code>augdat_</code> to be ignored.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_dis">dis</code></td>
<td>
<p>A vector of posterior draws for the reference model's dispersion
parameter or&mdash;more precisely&mdash;the posterior values for the reference
model's parameter-conditional predictive variance (assuming that this
variance is the same for all observations). May be <code>NULL</code> if the submodels
have no dispersion parameter or if the submodels do have a dispersion
parameter, but <code>object</code> is <code>NULL</code> (in which case <code>0</code> is used for <code>dis</code>).
Note that for the <code><a href="stats.html#topic+gaussian">gaussian()</a></code> <code>family</code>, <code>dis</code> is the standard deviation,
not the variance.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data to use for the projection
predictive variable selection. Any <code>contrasts</code> attributes of the dataset's
columns are silently removed. For custom reference models, the columns of
<code>data</code> do not necessarily have to coincide with those of the dataset used
for fitting the reference model, but keep in mind that a row-subset of
<code>data</code> is used for argument <code>newdata</code> of <code>ref_predfun</code> during <code class="reqn">K</code>-fold
CV.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_formula">formula</code></td>
<td>
<p>The full formula to use for the search procedure. For custom
reference models, this does not necessarily coincide with the reference
model's formula. For general information about formulas in <span class="rlang"><b>R</b></span>, see
<code><a href="stats.html#topic+formula">formula</a></code>. For information about possible right-hand side (i.e.,
predictor) terms in <code>formula</code> here, see the main vignette and section
&quot;Formula terms&quot; below. For multilevel formulas, see also package <span class="pkg">lme4</span>
(in particular, functions <code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code> and <code><a href="lme4.html#topic+glmer">lme4::glmer()</a></code>). For additive
formulas, see also packages <span class="pkg">mgcv</span> (in particular, function
<code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>) and <span class="pkg">gamm4</span> (in particular, function <code><a href="gamm4.html#topic+gamm4">gamm4::gamm4()</a></code>).</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_ref_predfun">ref_predfun</code></td>
<td>
<p>Prediction function for the linear predictor of the
reference model, including offsets (if existing). See also section
&quot;Arguments <code>ref_predfun</code>, <code>proj_predfun</code>, and <code>div_minimizer</code>&quot; below. If
<code>object</code> is <code>NULL</code>, <code>ref_predfun</code> is ignored and an internal default is
used instead.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_div_minimizer">div_minimizer</code></td>
<td>
<p>A function for minimizing the Kullback-Leibler (KL)
divergence from the reference model to a submodel (i.e., for performing the
projection of the reference model onto a submodel). The output of
<code>div_minimizer</code> is used, e.g., by <code>proj_predfun</code>'s argument <code>fits</code>. See
also section &quot;Arguments <code>ref_predfun</code>, <code>proj_predfun</code>, and <code>div_minimizer</code>&quot;
below.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_proj_predfun">proj_predfun</code></td>
<td>
<p>Prediction function for the linear predictor of a
submodel onto which the reference model is projected. See also section
&quot;Arguments <code>ref_predfun</code>, <code>proj_predfun</code>, and <code>div_minimizer</code>&quot; below.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_extract_model_data">extract_model_data</code></td>
<td>
<p>A function for fetching some variables (response,
observation weights, offsets) from the original dataset (supplied to
argument <code>data</code>) or from a new dataset. May be <code>NULL</code> for using an internal
default that essentially corresponds to <code><a href="#topic+y_wobs_offs">y_wobs_offs()</a></code>. See also section
&quot;Argument <code>extract_model_data</code>&quot; below.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_cvfun">cvfun</code></td>
<td>
<p>For <code class="reqn">K</code>-fold CV only. A function that, given a fold indices
vector, fits the reference model separately for each fold and returns the
<code class="reqn">K</code> model fits as a <code>list</code>. If <code>object</code> is <code>NULL</code>, <code>cvfun</code> may be
<code>NULL</code> for using an internal default. Only one of <code>cvfits</code> and <code>cvfun</code>
needs to be provided (for <code class="reqn">K</code>-fold CV). Note that <code>cvfits</code> takes
precedence over <code>cvfun</code>, i.e., if both are provided, <code>cvfits</code> is used.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_cvfits">cvfits</code></td>
<td>
<p>For <code class="reqn">K</code>-fold CV only. A <code>list</code> containing the <code class="reqn">K</code>
reference model refits from which reference model objects are created. This
<code>list</code> needs to have an attribute called <code>folds</code>, consisting of an integer
vector giving the fold indices (one fold index per observation). Only one
of <code>cvfits</code> and <code>cvfun</code> needs to be provided (for <code class="reqn">K</code>-fold CV). Note
that <code>cvfits</code> takes precedence over <code>cvfun</code>, i.e., if both are provided,
<code>cvfits</code> is used.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_cvrefbuilder">cvrefbuilder</code></td>
<td>
<p>For <code class="reqn">K</code>-fold CV only. A function that, given a
reference model fit for fold <code class="reqn">k \in \{1, ..., K\}</code>,
returns an object of the same type as <code><a href="#topic+init_refmodel">init_refmodel()</a></code> does. The reference
model fit for fold <code class="reqn">k</code> is the <code class="reqn">k</code>-th element of the return value of
<code>cvfun</code> or the <code class="reqn">k</code>-th element of the <code>list</code> supplied to <code>cvfits</code>
(either here in <code><a href="#topic+init_refmodel">init_refmodel()</a></code> or in <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>), extended
by elements <code>omitted</code> (containing the indices of the left-out observations
in that fold) and <code>projpred_k</code> (containing the integer <code class="reqn">k</code>) if that
<code class="reqn">k</code>-th element is a <code>list</code> itself (otherwise, <code>omitted</code> and
<code>projpred_k</code> are appended as attributes). Argument <code>cvrefbuilder</code> may be
<code>NULL</code> for using an internal default: <code><a href="#topic+get_refmodel">get_refmodel()</a></code> if <code>object</code> is not
<code>NULL</code> and a function calling <code><a href="#topic+init_refmodel">init_refmodel()</a></code> appropriately (with the
assumption <code>dis = 0</code>) if <code>object</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="refmodel-init-get_+3A_called_from_cvrefbuilder">called_from_cvrefbuilder</code></td>
<td>
<p>A single logical value indicating whether
<code><a href="#topic+init_refmodel">init_refmodel()</a></code> is called from a <code>cvrefbuilder</code> function (<code>TRUE</code>) or not
(<code>FALSE</code>). Currently, <code>TRUE</code> only causes some warnings to be suppressed
(warnings which don't need to be thrown for each of the <code class="reqn">K</code> reference
model objects because it is sufficient to throw them for the original
reference model object only). This argument is mainly for internal use, but
may also be helpful for users with a custom <code>cvrefbuilder</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that can be passed to all the functions that take the
reference model fit as the first argument, such as <code><a href="#topic+varsel">varsel()</a></code>,
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>, <code><a href="#topic+project">project()</a></code>, <code><a href="#topic+proj_linpred">proj_linpred()</a></code>, and <code><a href="#topic+proj_predict">proj_predict()</a></code>.
Usually, the returned object is of class <code>refmodel</code>. However, if <code>object</code>
is <code>NULL</code>, the returned object is of class <code>datafit</code> as well as of class
<code>refmodel</code> (with <code>datafit</code> being first). Objects of class <code>datafit</code> are
handled differently at several places throughout this package.
</p>
<p>The elements of the returned object are not meant to be accessed directly
but instead via downstream functions (see the functions mentioned above as
well as <code><a href="#topic+predict.refmodel">predict.refmodel()</a></code>).
</p>


<h3>Formula terms</h3>

<p>Although bad practice (in general), a reference model lacking an intercept
can be used within <span class="pkg">projpred</span>. However, it will always be projected onto
submodels which <em>include</em> an intercept. The reason is that even if the true
intercept in the reference model is zero, this does not need to hold for the
submodels.
</p>
<p>In multilevel (group-level) terms, function calls on the right-hand side of
the <code>|</code> character (e.g., <code>(1 | gr(group_variable))</code>, which is possible in
<span class="pkg">brms</span>) are currently not allowed in <span class="pkg">projpred</span>.
</p>
<p>For additive models (still an experimental feature), only <code><a href="mgcv.html#topic+s">mgcv::s()</a></code> and
<code><a href="mgcv.html#topic+t2">mgcv::t2()</a></code> are currently supported as smooth terms. Furthermore, these need
to be called without any arguments apart from the predictor names (symbols).
For example, for smoothing the effect of a predictor <code>x</code>, only <code>s(x)</code> or
<code>t2(x)</code> are allowed. As another example, for smoothing the joint effect of
two predictors <code>x</code> and <code>z</code>, only <code>s(x, z)</code> or <code>t2(x, z)</code> are allowed (and
analogously for higher-order joint effects, e.g., of three predictors). Note
that all smooth terms need to be included in <code>formula</code> (there is no <code>random</code>
argument as in <code><a href="rstanarm.html#topic+stan_gamm4">rstanarm::stan_gamm4()</a></code>, for example).
</p>


<h3>Arguments <code>ref_predfun</code>, <code>proj_predfun</code>, and <code>div_minimizer</code></h3>

<p>Arguments <code>ref_predfun</code>, <code>proj_predfun</code>, and <code>div_minimizer</code> may be <code>NULL</code>
for using an internal default (see <a href="#topic+projpred-package">projpred-package</a> for the functions used
by the default divergence minimizers). Otherwise, let <code class="reqn">N</code> denote the
number of observations (in case of CV, these may be reduced to each fold),
<code class="reqn">S_{\mathrm{ref}}</code> the number of posterior draws for the reference
model's parameters, and <code class="reqn">S_{\mathrm{prj}}</code> the number of draws for
the parameters of a submodel that the reference model has been projected onto
(short: the number of projected draws). For the augmented-data projection,
let <code class="reqn">C_{\mathrm{cat}}</code> denote the number of response categories,
<code class="reqn">C_{\mathrm{lat}}</code> the number of latent response categories (which
typically equals <code class="reqn">C_{\mathrm{cat}} - 1</code>), and define
<code class="reqn">N_{\mathrm{augcat}} := N \cdot C_{\mathrm{cat}}</code>
as well as <code class="reqn">N_{\mathrm{auglat}} := N \cdot C_{\mathrm{lat}}</code>. Then the functions supplied to these arguments need to have the
following prototypes:
</p>

<ul>
<li> <p><code>ref_predfun</code>: <code>ref_predfun(fit, newdata = NULL)</code> where:
</p>

<ul>
<li> <p><code>fit</code> accepts the reference model fit as given in argument <code>object</code>
(but possibly refitted to a subset of the observations, as done in
<code class="reqn">K</code>-fold CV).
</p>
</li>
<li> <p><code>newdata</code> accepts either <code>NULL</code> (for using the original dataset,
typically stored in <code>fit</code>) or data for new observations (at least in the
form of a <code>data.frame</code>).
</p>
</li></ul>

</li>
<li> <p><code>proj_predfun</code>: <code>proj_predfun(fits, newdata)</code> where:
</p>

<ul>
<li> <p><code>fits</code> accepts a <code>list</code> of length <code class="reqn">S_{\mathrm{prj}}</code>
containing this number of submodel fits. This <code>list</code> is the same as that
returned by <code><a href="#topic+project">project()</a></code> in its output element <code>outdmin</code> (which in turn is
the same as the return value of <code>div_minimizer</code>, except if <code><a href="#topic+project">project()</a></code>
was used with an <code>object</code> of class <code>vsel</code> based on an L1 search as well
as with <code>refit_prj = FALSE</code>).
</p>
</li>
<li> <p><code>newdata</code> accepts data for new observations (at least in the form of a
<code>data.frame</code>).
</p>
</li></ul>

</li>
<li> <p><code>div_minimizer</code> does not need to have a specific prototype, but it needs to
be able to be called with the following arguments:
</p>

<ul>
<li> <p><code>formula</code> accepts either a standard <code><a href="stats.html#topic+formula">formula</a></code> with a single response
(if <code class="reqn">S_{\mathrm{prj}} = 1</code> or in case of the
augmented-data projection) or a <code><a href="stats.html#topic+formula">formula</a></code> with <code class="reqn">S_{\mathrm{prj}} &gt;
    1</code> response variables <code><a href="base.html#topic+cbind">cbind()</a></code>-ed on the left-hand side in
which case the projection has to be performed for each of the response
variables separately.
</p>
</li>
<li> <p><code>data</code> accepts a <code>data.frame</code> to be used for the projection. In case of
the traditional or the latent projection, this dataset has <code class="reqn">N</code> rows.
In case of the augmented-data projection, this dataset has
<code class="reqn">N_{\mathrm{augcat}}</code> rows.
</p>
</li>
<li> <p><code>family</code> accepts an object of class <code>family</code>.
</p>
</li>
<li> <p><code>weights</code> accepts either observation weights (at least in the form of a
numeric vector) or <code>NULL</code> (for using a vector of ones as weights).
</p>
</li>
<li> <p><code>projpred_var</code> accepts an <code class="reqn">N \times S_{\mathrm{prj}}</code>
matrix of predictive variances (necessary for <span class="pkg">projpred</span>'s internal
GLM fitter) in case of the traditional or the latent projection and an
<code class="reqn">N_{\mathrm{augcat}} \times S_{\mathrm{prj}}</code>
matrix (containing only <code>NA</code>s) in case of the augmented-data projection.
</p>
</li>
<li> <p><code>projpred_ws_aug</code> accepts an <code class="reqn">N \times S_{\mathrm{prj}}</code>
matrix of expected values for the response in case of the traditional or
the latent projection and an <code class="reqn">N_{\mathrm{augcat}} \times
    S_{\mathrm{prj}}</code> matrix of probabilities for the
response categories in case of the augmented-data projection.
</p>
</li>
<li> <p><code>...</code> accepts further arguments specified by the user (or by
<span class="pkg">projpred</span>).
</p>
</li></ul>

</li></ul>

<p>The return value of these functions needs to be:
</p>

<ul>
<li> <p><code>ref_predfun</code>: for the traditional or the latent projection, an <code class="reqn">N
\times S_{\mathrm{ref}}</code> matrix; for the augmented-data
projection, an <code class="reqn">S_{\mathrm{ref}} \times N \times C_{\mathrm{lat}}</code> array (the only exception is the augmented-data projection for
the <code><a href="stats.html#topic+binomial">binomial()</a></code> family in which case <code>ref_predfun</code> needs to return an <code class="reqn">N
\times S_{\mathrm{ref}}</code> matrix just like for the traditional
projection because the array is constructed by an internal wrapper function).
</p>
</li>
<li> <p><code>proj_predfun</code>: for the traditional or the latent projection, an <code class="reqn">N
\times S_{\mathrm{prj}}</code> matrix; for the augmented-data
projection, an <code class="reqn">N \times C_{\mathrm{lat}} \times S_{\mathrm{prj}}</code> array.
</p>
</li>
<li> <p><code>div_minimizer</code>: a <code>list</code> of length <code class="reqn">S_{\mathrm{prj}}</code>
containing this number of submodel fits.
</p>
</li></ul>



<h3>Argument <code>extract_model_data</code></h3>

<p>The function supplied to argument <code>extract_model_data</code> needs to have the
prototype
</p>
<div class="sourceCode r"><pre>extract_model_data(object, newdata, wrhs = NULL, orhs = NULL,
                   extract_y = TRUE)
</pre></div>
<p>where:
</p>

<ul>
<li> <p><code>object</code> accepts the reference model fit as given in argument <code>object</code> (but
possibly refitted to a subset of the observations, as done in <code class="reqn">K</code>-fold
CV).
</p>
</li>
<li> <p><code>newdata</code> accepts data for new observations (at least in the form of a
<code>data.frame</code>).
</p>
</li>
<li> <p><code>wrhs</code> accepts at least (i) a right-hand side formula consisting only of
the variable in <code>newdata</code> containing the observation weights or (ii) <code>NULL</code>
for using the observation weights corresponding to <code>newdata</code> (typically, the
observation weights are stored in a column of <code>newdata</code>; if the model was
fitted without observation weights, a vector of ones should be used).
</p>
</li>
<li> <p><code>orhs</code> accepts at least (i) a right-hand side formula consisting only of
the variable in <code>newdata</code> containing the offsets or (ii) <code>NULL</code> for using the
offsets corresponding to <code>newdata</code> (typically, the offsets are stored in a
column of <code>newdata</code>; if the model was fitted without offsets, a vector of
zeros should be used).
</p>
</li>
<li> <p><code>extract_y</code> accepts a single logical value indicating whether output
element <code>y</code> (see below) shall be <code>NULL</code> (<code>TRUE</code>) or not (<code>FALSE</code>).
</p>
</li></ul>

<p>The return value of <code>extract_model_data</code> needs to be a <code>list</code> with elements
<code>y</code>, <code>weights</code>, and <code>offset</code>, each being a numeric vector containing the data
for the response, the observation weights, and the offsets, respectively. An
exception is that <code>y</code> may also be <code>NULL</code> (depending on argument <code>extract_y</code>),
a non-numeric vector, or a <code>factor</code>.
</p>
<p>The weights and offsets returned by <code>extract_model_data</code> will be assumed to
hold for the reference model as well as for the submodels.
</p>
<p>Above, arguments <code>wrhs</code> and <code>orhs</code> were assumed to have defaults of <code>NULL</code>.
It should be possible to use defaults other than <code>NULL</code>, but we strongly
recommend to use <code>NULL</code>. If defaults other than <code>NULL</code> are used, they need to
imply the behaviors described at items &quot;(ii)&quot; (see the descriptions of <code>wrhs</code>
and <code>orhs</code>).
</p>


<h3>Augmented-data projection</h3>

<p>If a custom reference model for an augmented-data projection is needed, see
also <code><a href="#topic+extend_family">extend_family()</a></code>.
</p>
<p>For the augmented-data projection, the response vector resulting from
<code>extract_model_data</code> is internally coerced to a <code>factor</code> (using
<code><a href="base.html#topic+as.factor">as.factor()</a></code>). The levels of this <code>factor</code> have to be identical to
<code>family$cats</code> (<em>after</em> applying <code><a href="#topic+extend_family">extend_family()</a></code> internally; see
<code><a href="#topic+extend_family">extend_family()</a></code>'s argument <code>augdat_y_unqs</code>).
</p>
<p>Note that response-specific offsets (i.e., one length-<code class="reqn">N</code> offset vector
per response category) are not supported by <span class="pkg">projpred</span> yet. So far, only
offsets which are the same across all response categories are supported. This
is why in case of the <code><a href="brms.html#topic+brmsfamily">brms::categorical()</a></code> family, offsets are currently not
supported at all.
</p>
<p>Currently, <code>object = NULL</code> (i.e., a <code>datafit</code>; see section &quot;Value&quot;) is not
supported in case of the augmented-data projection.
</p>


<h3>Latent projection</h3>

<p>If a custom reference model for a latent projection is needed, see also
<code><a href="#topic+extend_family">extend_family()</a></code>.
</p>
<p>For the latent projection, <code>family$cats</code> (<em>after</em> applying <code><a href="#topic+extend_family">extend_family()</a></code>
internally; see <code><a href="#topic+extend_family">extend_family()</a></code>'s argument <code>latent_y_unqs</code>) currently must
not be <code>NULL</code> if the original (i.e., non-latent) response is a <code>factor</code>.
Conversely, if <code>family$cats</code> (<em>after</em> applying <code><a href="#topic+extend_family">extend_family()</a></code>) is
non-<code>NULL</code>, the response vector resulting from <code>extract_model_data</code> is
internally coerced to a <code>factor</code> (using <code><a href="base.html#topic+as.factor">as.factor()</a></code>). The levels of this
<code>factor</code> have to be identical to that non-<code>NULL</code> element <code>family$cats</code>.
</p>
<p>Currently, <code>object = NULL</code> (i.e., a <code>datafit</code>; see section &quot;Value&quot;) is not
supported in case of the latent projection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Define the reference model object explicitly:
ref &lt;- get_refmodel(fit)
print(class(ref)) # gives `"refmodel"`
# Now see, for example, `?varsel`, `?cv_varsel`, and `?project` for
# possible post-processing functions. Most of the post-processing functions
# call get_refmodel() internally at the beginning, so you will rarely need
# to call get_refmodel() yourself.

# A custom reference model object which may be used in a variable selection
# where the candidate predictors are not a subset of those used for the
# reference model's predictions:
ref_cust &lt;- init_refmodel(
  fit,
  data = dat_gauss,
  formula = y ~ X6 + X7,
  family = gaussian(),
  cvfun = function(folds) {
    kfold(
      fit, K = max(folds), save_fits = TRUE, folds = folds, cores = 1
    )$fits[, "fit"]
  },
  dis = as.matrix(fit)[, "sigma"],
  cvrefbuilder = function(cvfit) {
    init_refmodel(cvfit,
                  data = dat_gauss[-cvfit$omitted, , drop = FALSE],
                  formula = y ~ X6 + X7,
                  family = gaussian(),
                  dis = as.matrix(cvfit)[, "sigma"],
                  called_from_cvrefbuilder = TRUE)
  }
)
# Now, the post-processing functions mentioned above (for example,
# varsel(), cv_varsel(), and project()) may be applied to `ref_cust`.

</code></pre>

<hr>
<h2 id='run_cvfun'>Create <code>cvfits</code> from <code>cvfun</code></h2><span id='topic+run_cvfun'></span><span id='topic+run_cvfun.default'></span><span id='topic+run_cvfun.refmodel'></span>

<h3>Description</h3>

<p>A helper function that can be used to create input for
<code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>'s argument <code>cvfits</code> by running first <code><a href="#topic+cv_folds">cv_folds()</a></code> and
then the reference model object's <code>cvfun</code> (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>). This is
helpful if <code class="reqn">K</code>-fold CV is run multiple times based on the same <code class="reqn">K</code>
reference model refits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_cvfun(object, ...)

## Default S3 method:
run_cvfun(object, ...)

## S3 method for class 'refmodel'
run_cvfun(
  object,
  K = if (!inherits(object, "datafit")) 5 else 10,
  folds = NULL,
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_cvfun_+3A_object">object</code></td>
<td>
<p>An object of class <code>refmodel</code> (returned by <code><a href="#topic+get_refmodel">get_refmodel()</a></code> or
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>) or an object that can be passed to argument <code>object</code> of
<code><a href="#topic+get_refmodel">get_refmodel()</a></code>.</p>
</td></tr>
<tr><td><code id="run_cvfun_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+run_cvfun.default">run_cvfun.default()</a></code>: Arguments passed to <code><a href="#topic+get_refmodel">get_refmodel()</a></code>.
For <code><a href="#topic+run_cvfun.refmodel">run_cvfun.refmodel()</a></code>: Currently ignored.</p>
</td></tr>
<tr><td><code id="run_cvfun_+3A_k">K</code></td>
<td>
<p>Number of folds. Must be at least 2 and not exceed the number of
observations. Ignored if <code>folds</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="run_cvfun_+3A_folds">folds</code></td>
<td>
<p>Either <code>NULL</code> for determining the CV folds automatically via
<code><a href="#topic+cv_folds">cv_folds()</a></code> (using argument <code>K</code>) or a numeric (in fact, integer) vector
giving the fold index for each observation. In the latter case, argument
<code>K</code> is ignored.</p>
</td></tr>
<tr><td><code id="run_cvfun_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling
<code><a href="#topic+run_cvfun">run_cvfun()</a></code>) upon exiting <code><a href="#topic+run_cvfun">run_cvfun()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that can be used as input for <code><a href="#topic+cv_varsel.refmodel">cv_varsel.refmodel()</a></code>'s
argument <code>cvfits</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Define the reference model object explicitly (not really necessary here
# because the get_refmodel() call is quite fast in this example, but in
# general, this approach is faster than defining the reference model object
# multiple times implicitly):
ref &lt;- get_refmodel(fit)

# Run the reference model object's `cvfun` (with a small value for `K`, but
# only for the sake of speed in this example; this is not recommended in
# general):
cv_fits &lt;- run_cvfun(ref, K = 2, seed = 184)

# Run cv_varsel() (with L1 search and small values for `nterms_max` and
# `nclusters_pred`, but only for the sake of speed in this example; this is
# not recommended in general) and use `cv_fits` there:
cvvs_L1 &lt;- cv_varsel(ref, method = "L1", cv_method = "kfold",
                     cvfits = cv_fits, nterms_max = 3, nclusters_pred = 10,
                     seed = 5555)
# Now see, for example, `?print.vsel`, `?plot.vsel`, `?suggest_size.vsel`,
# and `?ranking` for possible post-processing functions.

# The purpose of run_cvfun() is to create an object that can be used in
# multiple cv_varsel() calls, e.g., to check the sensitivity to the search
# method (L1 or forward):
cvvs_fw &lt;- cv_varsel(ref, method = "forward", cv_method = "kfold",
                     cvfits = cv_fits, nterms_max = 3, nclusters = 5,
                     nclusters_pred = 10, seed = 5555)

# Stratified K-fold CV is straightforward:
n_strat &lt;- 3L
set.seed(692)
# Some example strata:
strat_fac &lt;- sample(paste0("lvl", seq_len(n_strat)), size = nrow(dat_gauss),
                    replace = TRUE,
                    prob = diff(c(0, pnorm(seq_len(n_strat - 1L) - 0.5), 1)))
table(strat_fac)
# Use loo::kfold_split_stratified() to create the folds vector:
folds_strat &lt;- loo::kfold_split_stratified(K = 2, x = strat_fac)
table(folds_strat, strat_fac)
# Call run_cvfun(), but this time with argument `folds` instead of `K` (here,
# specifying argument `seed` would not be necessary because of the set.seed()
# call above, but we specify it nonetheless for the sake of generality):
cv_fits_strat &lt;- run_cvfun(ref, folds = folds_strat, seed = 391)
# Now use `cv_fits_strat` analogously to `cv_fits` from above.

</code></pre>

<hr>
<h2 id='solution_terms'>Retrieve the full-data solution path from a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run
or the predictor combination from a <code><a href="#topic+project">project()</a></code> run</h2><span id='topic+solution_terms'></span><span id='topic+solution_terms.vsel'></span><span id='topic+solution_terms.projection'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+solution_terms.vsel">solution_terms.vsel()</a></code> method retrieves the solution path from a
full-data search (<code>vsel</code> objects are returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>). The <code><a href="#topic+solution_terms.projection">solution_terms.projection()</a></code> method retrieves the
predictor combination onto which a projection was performed (<code>projection</code>
objects are returned by <code><a href="#topic+project">project()</a></code>, possibly as elements of a <code>list</code>). Both
methods (and hence also the <code><a href="#topic+solution_terms">solution_terms()</a></code> generic) are deprecated and
will be removed in a future release. Please use <code><a href="#topic+ranking">ranking()</a></code> instead of
<code><a href="#topic+solution_terms.vsel">solution_terms.vsel()</a></code> (<code><a href="#topic+ranking">ranking()</a></code>'s output element <code>fulldata</code> contains the
full-data predictor ranking that is extracted by <code><a href="#topic+solution_terms.vsel">solution_terms.vsel()</a></code>;
<code><a href="#topic+ranking">ranking()</a></code>'s output element <code>foldwise</code> contains the fold-wise predictor
rankings&mdash;if available&mdash;which were previously not accessible via a built-in
function) and <code><a href="#topic+predictor_terms">predictor_terms()</a></code> instead of <code><a href="#topic+solution_terms.projection">solution_terms.projection()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solution_terms(object, ...)

## S3 method for class 'vsel'
solution_terms(object, ...)

## S3 method for class 'projection'
solution_terms(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solution_terms_+3A_object">object</code></td>
<td>
<p>The object from which to retrieve the predictor terms. Possible
classes may be inferred from the names of the corresponding methods (see
also the description).</p>
</td></tr>
<tr><td><code id="solution_terms_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of predictor terms.
</p>

<hr>
<h2 id='suggest_size'>Suggest submodel size</h2><span id='topic+suggest_size'></span><span id='topic+suggest_size.vsel'></span>

<h3>Description</h3>

<p>This function can suggest an appropriate submodel size based on a decision
rule described in section &quot;Details&quot; below. Note that this decision is quite
heuristic and should be interpreted with caution. It is recommended to
examine the results via <code><a href="#topic+plot.vsel">plot.vsel()</a></code>, <code><a href="#topic+cv_proportions">cv_proportions()</a></code>,
<code><a href="#topic+plot.cv_proportions">plot.cv_proportions()</a></code>, and/or <code><a href="#topic+summary.vsel">summary.vsel()</a></code> and to make the final
decision based on what is most appropriate for the problem at hand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggest_size(object, ...)

## S3 method for class 'vsel'
suggest_size(
  object,
  stat = "elpd",
  pct = 0,
  type = "upper",
  thres_elpd = NA,
  warnings = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="suggest_size_+3A_object">object</code></td>
<td>
<p>An object of class <code>vsel</code> (returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>).</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+summary.vsel">summary.vsel()</a></code>, except for <code>object</code>, <code>stats</code>
(which is set to <code>stat</code>), <code>type</code>, and <code>deltas</code> (which is set to <code>TRUE</code>).
See section &quot;Details&quot; below for some important arguments which may be
passed here.</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_stat">stat</code></td>
<td>
<p>Performance statistic (i.e., utility or loss) used for the
decision. See argument <code>stats</code> of <code><a href="#topic+summary.vsel">summary.vsel()</a></code> for possible choices.</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_pct">pct</code></td>
<td>
<p>A number giving the proportion (<em>not</em> percents) of the <em>relative</em>
null model utility one is willing to sacrifice. See section &quot;Details&quot; below
for more information.</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_type">type</code></td>
<td>
<p>Either <code>"upper"</code> or <code>"lower"</code> determining whether the decision is
based on the upper or lower confidence interval bound, respectively. See
section &quot;Details&quot; below for more information.</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_thres_elpd">thres_elpd</code></td>
<td>
<p>Only relevant if <code style="white-space: pre;">&#8288;stat %in% c("elpd", "mlpd", "gmpd"))&#8288;</code>.
The threshold for the ELPD difference (taking the submodel's ELPD minus the
baseline model's ELPD) above which the submodel's ELPD is considered to be
close enough to the baseline model's ELPD. An equivalent rule is applied in
case of the MLPD and the GMPD. See section &quot;Details&quot; for a formalization.
Supplying <code>NA</code> deactivates this.</p>
</td></tr>
<tr><td><code id="suggest_size_+3A_warnings">warnings</code></td>
<td>
<p>Mainly for internal use. A single logical value indicating
whether to throw warnings if automatic suggestion fails. Usually there is
no reason to set this to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general (beware of special cases below), the suggested model
size is the smallest model size <code class="reqn">j \in \{0, 1, ...,
  \texttt{nterms\_max}\}</code> for which either the
lower or upper bound (depending on argument <code>type</code>) of the
normal-approximation (or bootstrap or exponentiated normal-approximation;
see argument <code>stat</code>) confidence interval (with nominal coverage <code>1 - alpha</code>; see argument <code>alpha</code> of <code><a href="#topic+summary.vsel">summary.vsel()</a></code>) for <code class="reqn">U_j -
  U_{\mathrm{base}}</code> (with <code class="reqn">U_j</code> denoting the <code class="reqn">j</code>-th
submodel's true utility and <code class="reqn">U_{\mathrm{base}}</code> denoting the
baseline model's true utility)
falls above (or is equal to) </p>
<p style="text-align: center;"><code class="reqn">\texttt{pct} \cdot (u_0 -
  u_{\mathrm{base}})</code>
</p>
<p> where <code class="reqn">u_0</code> denotes the null
model's estimated utility and <code class="reqn">u_{\mathrm{base}}</code> the baseline
model's estimated utility. The baseline model is either the reference model
or the best submodel found (see argument <code>baseline</code> of <code><a href="#topic+summary.vsel">summary.vsel()</a></code>).
</p>
<p>In doing so, loss statistics like the root mean squared error (RMSE) and
the mean squared error (MSE) are converted to utilities by multiplying them
by <code>-1</code>, so a call such as <code>suggest_size(object, stat = "rmse", type = "upper")</code> finds the smallest model size whose upper confidence interval
bound for the <em>negative</em> RMSE or MSE exceeds (or is equal to) the cutoff
(or, equivalently, has the lower confidence interval bound for the RMSE or
MSE below&mdash;or equal to&mdash;the cutoff). This is done to make the
interpretation of argument <code>type</code> the same regardless of argument <code>stat</code>.
</p>
<p>For the geometric mean predictive density (GMPD), the decision rule above
is applied on <code><a href="base.html#topic+log">log()</a></code> scale. In other words, if the true GMPD is denoted by
<code class="reqn">U^\ast_j</code> for the <code class="reqn">j</code>-th submodel and
<code class="reqn">U^\ast_{\mathrm{base}}</code> for the baseline model (so that
<code class="reqn">U_j</code> and <code class="reqn">U_{\mathrm{base}}</code> from above are given by
<code class="reqn">U_j = \log(U^\ast_j)</code> and
<code class="reqn">U_{\mathrm{base}} = \log(U^\ast_{\mathrm{base}})</code>), then <code><a href="#topic+suggest_size">suggest_size()</a></code> yields the smallest model size whose
lower or upper (depending on argument <code>type</code>) confidence interval bound for
<code class="reqn">\frac{U^\ast_j}{U^\ast_{\mathrm{base}}}</code> exceeds (or
is equal to)
</p>
<p style="text-align: center;"><code class="reqn">(\frac{u^\ast_0}{u^\ast_{\mathrm{base}}})^{\texttt{pct}}</code>
</p>
<p> where <code class="reqn">u^\ast_0</code> denotes the null
model's estimated GMPD and <code class="reqn">u^\ast_{\mathrm{base}}</code> the
baseline model's estimated GMPD.
</p>
<p>If <code>!is.na(thres_elpd)</code> and <code>stat = "elpd"</code>, the decision rule above is
extended: The suggested model size is then the smallest model size <code class="reqn">j</code>
fulfilling the rule above <em>or</em> <code class="reqn">u_j - u_{\mathrm{base}} &gt;
  \texttt{thres\_elpd}</code>. Correspondingly, in case
of <code>stat = "mlpd"</code> (and <code>!is.na(thres_elpd)</code>), the suggested model size is
the smallest model size <code class="reqn">j</code> fulfilling the rule above <em>or</em> <code class="reqn">u_j -
  u_{\mathrm{base}} &gt; \frac{\texttt{thres\_elpd}}{N}</code> with <code class="reqn">N</code> denoting the number of observations.
Correspondingly, in case of <code>stat = "gmpd"</code> (and <code>!is.na(thres_elpd)</code>), the
suggested model size is the smallest model size <code class="reqn">j</code> fulfilling the rule
above <em>or</em> <code class="reqn">\frac{u^\ast_j}{u^\ast_{\mathrm{base}}} &gt;
  \exp(\frac{\texttt{thres\_elpd}}{N})</code>.
</p>
<p>For example (disregarding the special extensions in case of
<code>!is.na(thres_elpd)</code> with <code>stat %in% c("elpd", "mlpd", "gmpd")</code>), <code>alpha = 2 * pnorm(-1)</code>, <code>pct = 0</code>, and <code>type = "upper"</code> means that we select the
smallest model size for which the upper bound of the <code>1 - 2 * pnorm(-1)</code>
(approximately 68.3%) confidence interval for <code class="reqn">U_j -
  U_{\mathrm{base}}</code>
(<code class="reqn">\frac{U^\ast_j}{U^\ast_{\mathrm{base}}}</code> in case of
the GMPD) exceeds (or is equal to) zero (one in case of the GMPD), that is
(if <code>stat</code> is a performance statistic for which the normal approximation is
used, not the bootstrap and not the exponentiated normal approximation),
for which the submodel's utility estimate is at most one standard error
smaller than the baseline model's utility estimate (with that standard
error referring to the utility <em>difference</em>).
</p>
<p>Apart from the two <code><a href="#topic+summary.vsel">summary.vsel()</a></code> arguments mentioned above (<code>alpha</code> and
<code>baseline</code>), <code>resp_oscale</code> is another important <code><a href="#topic+summary.vsel">summary.vsel()</a></code> argument
that may be passed via <code>...</code>.
</p>


<h3>Value</h3>

<p>A single numeric value, giving the suggested submodel size (or <code>NA</code>
if the suggestion failed).
</p>
<p>The intercept is not counted by <code><a href="#topic+suggest_size">suggest_size()</a></code>, so a suggested size of
zero stands for the intercept-only model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)
print(suggest_size(vs))

</code></pre>

<hr>
<h2 id='summary.vsel'>Summary of a <code><a href="#topic+varsel">varsel()</a></code> or <code><a href="#topic+cv_varsel">cv_varsel()</a></code> run</h2><span id='topic+summary.vsel'></span>

<h3>Description</h3>

<p>This is the <code><a href="base.html#topic+summary">summary()</a></code> method for <code>vsel</code> objects (returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>). Apart from some general information about the <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code> run, it shows the full-data predictor ranking, basic
information about the (CV) variability in the ranking of the predictors (if
available; inferred from <code><a href="#topic+cv_proportions">cv_proportions()</a></code>), and estimates for
user-specified predictive performance statistics. For a graphical
representation, see <code><a href="#topic+plot.vsel">plot.vsel()</a></code>. For extracting the predictive performance
results printed at the bottom of the output created by this <code><a href="base.html#topic+summary">summary()</a></code>
method, see <code><a href="#topic+performances">performances()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vsel'
summary(
  object,
  nterms_max = NULL,
  stats = "elpd",
  type = c("mean", "se", "diff", "diff.se"),
  deltas = FALSE,
  alpha = 2 * pnorm(-1),
  baseline = if (!inherits(object$refmodel, "datafit")) "ref" else "best",
  resp_oscale = TRUE,
  cumulate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.vsel_+3A_object">object</code></td>
<td>
<p>An object of class <code>vsel</code> (returned by <code><a href="#topic+varsel">varsel()</a></code> or
<code><a href="#topic+cv_varsel">cv_varsel()</a></code>).</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_nterms_max">nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms) for which
the performance statistics are calculated. Using <code>NULL</code> is effectively the
same as <code>length(ranking(object)$fulldata)</code>. Note that <code>nterms_max</code> does not
count the intercept, so use <code>nterms_max = 0</code> for the intercept-only model.
For <code><a href="#topic+plot.vsel">plot.vsel()</a></code>, <code>nterms_max</code> must be at least <code>1</code>.</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_stats">stats</code></td>
<td>
<p>One or more character strings determining which performance
statistics (i.e., utilities or losses) to estimate based on the
observations in the evaluation (or &quot;test&quot;) set (in case of
cross-validation, these are all observations because they are partitioned
into multiple test sets; in case of <code><a href="#topic+varsel">varsel()</a></code> with <code>d_test = NULL</code>, these
are again all observations because the test set is the same as the training
set). Available statistics are:
</p>

<ul>
<li> <p><code>"elpd"</code>: expected log (pointwise) predictive density (for a new
dataset). Estimated by the sum of the observation-specific log predictive
density values (with each of these predictive density values being
a&mdash;possibly weighted&mdash;average across the parameter draws).
</p>
</li>
<li> <p><code>"mlpd"</code>: mean log predictive density, that is, <code>"elpd"</code> divided by the
number of observations.
</p>
</li>
<li> <p><code>"gmpd"</code>: geometric mean predictive density (GMPD), that is, <code><a href="base.html#topic+exp">exp()</a></code> of
<code>"mlpd"</code>. The GMPD is especially helpful for discrete response families
(because there, the GMPD is bounded by zero and one). For the corresponding
standard error, the delta method is used. The corresponding confidence
interval type is &quot;exponentiated normal approximation&quot; because the
confidence interval bounds are the exponentiated confidence interval bounds
of the <code>"mlpd"</code>.
</p>
</li>
<li> <p><code>"mse"</code>: mean squared error (only available in the situations mentioned
in section &quot;Details&quot; below).
</p>
</li>
<li> <p><code>"rmse"</code>: root mean squared error (only available in the situations
mentioned in section &quot;Details&quot; below). For the corresponding standard error
and lower and upper confidence interval bounds, bootstrapping is used.
</p>
</li>
<li> <p><code>"acc"</code> (or its alias, <code>"pctcorr"</code>): classification accuracy (only
available in the situations mentioned in section &quot;Details&quot; below). By
&quot;classification accuracy&quot;, we mean the proportion of correctly classified
observations. For this, the response category (&quot;class&quot;) with highest
probability (the probabilities are model-based) is taken as the prediction
(&quot;classification&quot;) for an observation.
</p>
</li>
<li> <p><code>"auc"</code>: area under the ROC curve (only available in the situations
mentioned in section &quot;Details&quot; below). For the corresponding standard error
and lower and upper confidence interval bounds, bootstrapping is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary.vsel_+3A_type">type</code></td>
<td>
<p>One or more items from <code>"mean"</code>, <code>"se"</code>, <code>"lower"</code>, <code>"upper"</code>,
<code>"diff"</code>, and <code>"diff.se"</code> indicating which of these to compute for each
item from <code>stats</code> (mean, standard error, lower and upper confidence
interval bounds, mean difference to the corresponding statistic of the
reference model, and standard error of this difference, respectively; note
that for the GMPD, <code>"diff"</code>, and <code>"diff.se"</code> actually refer to the ratio
vs. the reference model, not the difference). The confidence interval
bounds belong to normal-approximation (or bootstrap or exponentiated
normal-approximation; see argument <code>stats</code>) confidence intervals with
(nominal) coverage <code>1 - alpha</code>. Items <code>"diff"</code> and <code>"diff.se"</code> are only
supported if <code>deltas</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_deltas">deltas</code></td>
<td>
<p>If <code>TRUE</code>, the submodel statistics are estimated relatively to
the baseline model (see argument <code>baseline</code>). For the GMPD, the term
&quot;relatively&quot; refers to the ratio vs. the baseline model (i.e., the submodel
statistic divided by the baseline model statistic). For all other <code>stats</code>,
&quot;relatively&quot; refers to the difference from the baseline model (i.e., the
submodel statistic minus the baseline model statistic).</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_alpha">alpha</code></td>
<td>
<p>A number determining the (nominal) coverage <code>1 - alpha</code> of the
normal-approximation (or bootstrap or exponentiated normal-approximation;
see argument <code>stats</code>) confidence intervals. For example, in case of the
normal approximation, <code>alpha = 2 * pnorm(-1)</code> corresponds to a confidence
interval stretching by one standard error on either side of the point
estimate.</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_baseline">baseline</code></td>
<td>
<p>For <code><a href="#topic+summary.vsel">summary.vsel()</a></code>: Only relevant if <code>deltas</code> is <code>TRUE</code>.
For <code><a href="#topic+plot.vsel">plot.vsel()</a></code>: Always relevant. Either <code>"ref"</code> or <code>"best"</code>, indicating
whether the baseline is the reference model or the best submodel found (in
terms of <code>stats[1]</code>), respectively.</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_resp_oscale">resp_oscale</code></td>
<td>
<p>Only relevant for the latent projection. A single logical
value indicating whether to calculate the performance statistics on the
original response scale (<code>TRUE</code>) or on latent scale (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_cumulate">cumulate</code></td>
<td>
<p>Passed to argument <code>cumulate</code> of <code><a href="#topic+cv_proportions">cv_proportions()</a></code>. Affects
column <code>cv_proportions_diag</code> of the summary table.</p>
</td></tr>
<tr><td><code id="summary.vsel_+3A_...">...</code></td>
<td>
<p>Arguments passed to the internal function which is used for
bootstrapping (if applicable; see argument <code>stats</code>). Currently, relevant
arguments are <code>B</code> (the number of bootstrap samples, defaulting to <code>2000</code>)
and <code>seed</code> (see <code><a href="base.html#topic+set.seed">set.seed()</a></code>, but defaulting to <code>NA</code> so that <code><a href="base.html#topic+set.seed">set.seed()</a></code>
is not called within that function at all).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stats</code> options <code>"mse"</code> and <code>"rmse"</code> are only available for:
</p>

<ul>
<li><p> the traditional projection,
</p>
</li>
<li><p> the latent projection with <code>resp_oscale = FALSE</code>,
</p>
</li>
<li><p> the latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>.
</p>
</li></ul>

<p>The <code>stats</code> option <code>"acc"</code> (= <code>"pctcorr"</code>) is only available for:
</p>

<ul>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family in case of the traditional projection,
</p>
</li>
<li><p> all families in case of the augmented-data projection,
</p>
</li>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family (on the original response scale) in case of the
latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>,
</p>
</li>
<li><p> all families (on the original response scale) in case of the latent
projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being not <code>NULL</code>.
</p>
</li></ul>

<p>The <code>stats</code> option <code>"auc"</code> is only available for:
</p>

<ul>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family in case of the traditional projection,
</p>
</li>
<li><p> the <code><a href="stats.html#topic+binomial">binomial()</a></code> family (on the original response scale) in case of the
latent projection with <code>resp_oscale = TRUE</code> in combination with
<code style="white-space: pre;">&#8288;&lt;refmodel&gt;$family$cats&#8288;</code> being <code>NULL</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>vselsummary</code>. The elements of this object are not
meant to be accessed directly but instead via helper functions
(<code><a href="#topic+print.vselsummary">print.vselsummary()</a></code> and <code><a href="#topic+performances.vselsummary">performances.vselsummary()</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.vselsummary">print.vselsummary()</a></code>, <code><a href="#topic+performances.vselsummary">performances.vselsummary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)
print(summary(vs), digits = 1)

</code></pre>

<hr>
<h2 id='varsel'>Run search and performance evaluation without cross-validation</h2><span id='topic+varsel'></span><span id='topic+varsel.default'></span><span id='topic+varsel.vsel'></span><span id='topic+varsel.refmodel'></span>

<h3>Description</h3>

<p>Run the <em>search</em> part and the <em>evaluation</em> part for a projection predictive
variable selection. The search part determines the predictor ranking (also
known as solution path), i.e., the best submodel for each submodel size
(number of predictor terms). The evaluation part determines the predictive
performance of the submodels along the predictor ranking. A special method is
<code><a href="#topic+varsel.vsel">varsel.vsel()</a></code> because it re-uses the search results from an earlier
<code><a href="#topic+varsel">varsel()</a></code> (or <code><a href="#topic+cv_varsel">cv_varsel()</a></code>) run, as illustrated in the main vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varsel(object, ...)

## Default S3 method:
varsel(object, ...)

## S3 method for class 'vsel'
varsel(object, ...)

## S3 method for class 'refmodel'
varsel(
  object,
  d_test = NULL,
  method = "forward",
  ndraws = NULL,
  nclusters = 20,
  ndraws_pred = 400,
  nclusters_pred = NULL,
  refit_prj = !inherits(object, "datafit"),
  nterms_max = NULL,
  verbose = TRUE,
  search_control = NULL,
  lambda_min_ratio = 1e-05,
  nlambda = 150,
  thresh = 1e-06,
  penalty = NULL,
  search_terms = NULL,
  search_out = NULL,
  seed = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varsel_+3A_object">object</code></td>
<td>
<p>An object of class <code>refmodel</code> (returned by <code><a href="#topic+get_refmodel">get_refmodel()</a></code> or
<code><a href="#topic+init_refmodel">init_refmodel()</a></code>) or an object that can be passed to argument <code>object</code> of
<code><a href="#topic+get_refmodel">get_refmodel()</a></code>.</p>
</td></tr>
<tr><td><code id="varsel_+3A_...">...</code></td>
<td>
<p>For <code><a href="#topic+varsel.default">varsel.default()</a></code>: Arguments passed to <code><a href="#topic+get_refmodel">get_refmodel()</a></code> as
well as to <code><a href="#topic+varsel.refmodel">varsel.refmodel()</a></code>. For <code><a href="#topic+varsel.vsel">varsel.vsel()</a></code>: Arguments passed to
<code><a href="#topic+varsel.refmodel">varsel.refmodel()</a></code>. For <code><a href="#topic+varsel.refmodel">varsel.refmodel()</a></code>: Arguments passed to the
divergence minimizer (see argument <code>div_minimizer</code> of <code><a href="#topic+init_refmodel">init_refmodel()</a></code> as
well as section &quot;Draw-wise divergence minimizers&quot; of <a href="#topic+projpred-package">projpred-package</a>)
when refitting the submodels for the performance evaluation (if <code>refit_prj</code>
is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="varsel_+3A_d_test">d_test</code></td>
<td>
<p>A <code>list</code> of the structure outlined in section &quot;Argument
<code>d_test</code>&quot; below, providing test data for evaluating the predictive
performance of the submodels as well as of the reference model. If <code>NULL</code>,
the training data is used.</p>
</td></tr>
<tr><td><code id="varsel_+3A_method">method</code></td>
<td>
<p>The method for the search part. Possible options are
<code>"forward"</code> for forward search and <code>"L1"</code> for L1 search. See also section
&quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="varsel_+3A_ndraws">ndraws</code></td>
<td>
<p>Number of posterior draws used in the search part. Ignored if
<code>nclusters</code> is not <code>NULL</code> or in case of L1 search (because L1 search always
uses a single cluster). If both (<code>nclusters</code> and <code>ndraws</code>) are <code>NULL</code>, the
number of posterior draws from the reference model is used for <code>ndraws</code>.
See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="varsel_+3A_nclusters">nclusters</code></td>
<td>
<p>Number of clusters of posterior draws used in the search
part. Ignored in case of L1 search (because L1 search always uses a single
cluster). For the meaning of <code>NULL</code>, see argument <code>ndraws</code>. See also
section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="varsel_+3A_ndraws_pred">ndraws_pred</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of
posterior draws used in the evaluation part. Ignored if <code>nclusters_pred</code> is
not <code>NULL</code>. If both (<code>nclusters_pred</code> and <code>ndraws_pred</code>) are <code>NULL</code>, the
number of posterior draws from the reference model is used for
<code>ndraws_pred</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="varsel_+3A_nclusters_pred">nclusters_pred</code></td>
<td>
<p>Only relevant if <code>refit_prj</code> is <code>TRUE</code>. Number of
clusters of posterior draws used in the evaluation part. For the meaning of
<code>NULL</code>, see argument <code>ndraws_pred</code>. See also section &quot;Details&quot; below.</p>
</td></tr>
<tr><td><code id="varsel_+3A_refit_prj">refit_prj</code></td>
<td>
<p>For the evaluation part, should the submodels along the
predictor ranking be fitted again (<code>TRUE</code>) or should their fits from the
search part be re-used (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="varsel_+3A_nterms_max">nterms_max</code></td>
<td>
<p>Maximum submodel size (number of predictor terms) up to
which the search is continued. If <code>NULL</code>, then <code>min(19, D)</code> is used where
<code>D</code> is the number of terms in the reference model (or in <code>search_terms</code>, if
supplied). Note that <code>nterms_max</code> does not count the intercept, so use
<code>nterms_max = 0</code> for the intercept-only model. (Correspondingly, <code>D</code> above
does not count the intercept.)</p>
</td></tr>
<tr><td><code id="varsel_+3A_verbose">verbose</code></td>
<td>
<p>A single logical value indicating whether to print out
additional information during the computations.</p>
</td></tr>
<tr><td><code id="varsel_+3A_search_control">search_control</code></td>
<td>
<p>A <code>list</code> of &quot;control&quot; arguments (i.e., tuning
parameters) for the search. In case of forward search, these arguments are
passed to the divergence minimizer (see argument <code>div_minimizer</code> of
<code><a href="#topic+init_refmodel">init_refmodel()</a></code> as well as section &quot;Draw-wise divergence minimizers&quot; of
<a href="#topic+projpred-package">projpred-package</a>). In case of forward search, <code>NULL</code> causes <code>...</code> to be
used not only for the performance evaluation, but also for the search. In
case of L1 search, possible arguments are:
</p>

<ul>
<li> <p><code>lambda_min_ratio</code>: Ratio between the smallest and largest lambda in the
L1-penalized search (default: <code>1e-5</code>). This parameter essentially
determines how long the search is carried out, i.e., how large submodels
are explored. No need to change this unless the program gives a warning
about this.
</p>
</li>
<li> <p><code>nlambda</code>: Number of values in the lambda grid for L1-penalized search
(default: <code>150</code>). No need to change this unless the program gives a warning
about this.
</p>
</li>
<li> <p><code>thresh</code>: Convergence threshold when computing the L1 path (default:
<code>1e-6</code>). Usually, there is no need to change this.
</p>
</li></ul>
</td></tr>
<tr><td><code id="varsel_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead).
Only relevant for L1 search. Ratio between the smallest and largest lambda
in the L1-penalized search. This parameter essentially determines how long
the search is carried out, i.e., how large submodels are explored. No need
to change this unless the program gives a warning about this.</p>
</td></tr>
<tr><td><code id="varsel_+3A_nlambda">nlambda</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead). Only
relevant for L1 search. Number of values in the lambda grid for
L1-penalized search. No need to change this unless the program gives a
warning about this.</p>
</td></tr>
<tr><td><code id="varsel_+3A_thresh">thresh</code></td>
<td>
<p>Deprecated (please use <code>search_control</code> instead). Only relevant
for L1 search. Convergence threshold when computing the L1 path. Usually,
there is no need to change this.</p>
</td></tr>
<tr><td><code id="varsel_+3A_penalty">penalty</code></td>
<td>
<p>Only relevant for L1 search. A numeric vector determining the
relative penalties or costs for the predictors. A value of <code>0</code> means that
those predictors have no cost and will therefore be selected first, whereas
<code>Inf</code> means those predictors will never be selected. If <code>NULL</code>, then <code>1</code> is
used for each predictor.</p>
</td></tr>
<tr><td><code id="varsel_+3A_search_terms">search_terms</code></td>
<td>
<p>Only relevant for forward search. A custom character
vector of predictor term blocks to consider for the search. Section
&quot;Details&quot; below describes more precisely what &quot;predictor term block&quot; means.
The intercept (<code>"1"</code>) is always included internally via <code>union()</code>, so
there's no difference between including it explicitly or omitting it. The
default <code>search_terms</code> considers all the terms in the reference model's
formula.</p>
</td></tr>
<tr><td><code id="varsel_+3A_search_out">search_out</code></td>
<td>
<p>Intended for internal use.</p>
</td></tr>
<tr><td><code id="varsel_+3A_seed">seed</code></td>
<td>
<p>Pseudorandom number generation (PRNG) seed by which the same
results can be obtained again if needed. Passed to argument <code>seed</code> of
<code><a href="base.html#topic+set.seed">set.seed()</a></code>, but can also be <code>NA</code> to not call <code><a href="base.html#topic+set.seed">set.seed()</a></code> at all. If not
<code>NA</code>, then the PRNG state is reset (to the state before calling <code><a href="#topic+varsel">varsel()</a></code>)
upon exiting <code><a href="#topic+varsel">varsel()</a></code>. Here, <code>seed</code> is used for clustering the reference
model's posterior draws (if <code>!is.null(nclusters)</code> or
<code>!is.null(nclusters_pred)</code>) and for drawing new group-level effects when
predicting from a multilevel submodel (however, not yet in case of a GAMM).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>ndraws</code>, <code>nclusters</code>, <code>nclusters_pred</code>, and <code>ndraws_pred</code>
are automatically truncated at the number of posterior draws in the
reference model (which is <code>1</code> for <code>datafit</code>s). Using less draws or clusters
in <code>ndraws</code>, <code>nclusters</code>, <code>nclusters_pred</code>, or <code>ndraws_pred</code> than posterior
draws in the reference model may result in slightly inaccurate projection
performance. Increasing these arguments affects the computation time
linearly.
</p>
<p>For argument <code>method</code>, there are some restrictions: For a reference model
with multilevel or additive formula terms or a reference model set up for
the augmented-data projection, only the forward search is available.
Furthermore, argument <code>search_terms</code> requires a forward search to take
effect.
</p>
<p>L1 search is faster than forward search, but forward search may be more
accurate. Furthermore, forward search may find a sparser model with
comparable performance to that found by L1 search, but it may also start
overfitting when more predictors are added.
</p>
<p>An L1 search may select an interaction term before all involved lower-order
interaction terms (including main-effect terms) have been selected. In
<span class="pkg">projpred</span> versions &gt; 2.6.0, the resulting predictor ranking is
automatically modified so that the lower-order interaction terms come
before this interaction term, but if this is conceptually undesired, choose
the forward search instead.
</p>
<p>The elements of the <code>search_terms</code> character vector don't need to be
individual predictor terms. Instead, they can be building blocks consisting
of several predictor terms connected by the <code>+</code> symbol. To understand how
these building blocks work, it is important to know how <span class="pkg">projpred</span>'s
forward search works: It starts with an empty vector <code>chosen</code> which will
later contain already selected predictor terms. Then, the search iterates
over model sizes <code class="reqn">j \in \{0, ..., J\}</code> (with <code class="reqn">J</code>
denoting the maximum submodel size, not counting the intercept). The
candidate models at model size <code class="reqn">j</code> are constructed from those elements
from <code>search_terms</code> which yield model size <code class="reqn">j</code> when combined with the
<code>chosen</code> predictor terms. Note that sometimes, there may be no candidate
models for model size <code class="reqn">j</code>. Also note that internally, <code>search_terms</code> is
expanded to include the intercept (<code>"1"</code>), so the first step of the search
(model size 0) always consists of the intercept-only model as the only
candidate.
</p>
<p>As a <code>search_terms</code> example, consider a reference model with formula <code>y ~ x1 + x2 + x3</code>. Then, to ensure that <code>x1</code> is always included in the
candidate models, specify <code>search_terms = c("x1", "x1 + x2", "x1 + x3", "x1 + x2 + x3")</code> (or, in a simpler way that leads to the same results,
<code>search_terms = c("x1", "x1 + x2", "x1 + x3")</code>, for which helper function
<code><a href="#topic+force_search_terms">force_search_terms()</a></code> exists). This search would start with <code>y ~ 1</code> as the
only candidate at model size 0. At model size 1, <code>y ~ x1</code> would be the only
candidate. At model size 2, <code>y ~ x1 + x2</code> and <code>y ~ x1 + x3</code> would be the
two candidates. At the last model size of 3, <code>y ~ x1 + x2 + x3</code> would be
the only candidate. As another example, to exclude <code>x1</code> from the search,
specify <code>search_terms = c("x2", "x3", "x2 + x3")</code> (or, in a simpler way
that leads to the same results, <code>search_terms = c("x2", "x3")</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>vsel</code>. The elements of this object are not meant
to be accessed directly but instead via helper functions (see the main
vignette and <a href="#topic+projpred-package">projpred-package</a>).
</p>


<h3>Argument <code>d_test</code></h3>

<p>If not <code>NULL</code>, then <code>d_test</code> needs to be a <code>list</code> with the following
elements:
</p>

<ul>
<li> <p><code>data</code>: a <code>data.frame</code> containing the predictor variables for the test set.
</p>
</li>
<li> <p><code>offset</code>: a numeric vector containing the offset values for the test set
(if there is no offset, use a vector of zeros).
</p>
</li>
<li> <p><code>weights</code>: a numeric vector containing the observation weights for the test
set (if there are no observation weights, use a vector of ones).
</p>
</li>
<li> <p><code>y</code>: a vector or a <code>factor</code> containing the response values for the test
set. In case of the latent projection, this has to be a vector containing the
<em>latent</em> response values, but it can also be a vector full of <code>NA</code>s if
latent-scale post-processing is not needed.
</p>
</li>
<li> <p><code>y_oscale</code>: Only needs to be provided in case of the latent projection
where this needs to be a vector or a <code>factor</code> containing the <em>original</em>
(i.e., non-latent) response values for the test set.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cv_varsel">cv_varsel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data:
dat_gauss &lt;- data.frame(y = df_gaussian$y, df_gaussian$x)

# The `stanreg` fit which will be used as the reference model (with small
# values for `chains` and `iter`, but only for technical reasons in this
# example; this is not recommended in general):
fit &lt;- rstanarm::stan_glm(
  y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
  QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
)

# Run varsel() (here without cross-validation, with L1 search, and with small
# values for `nterms_max` and `nclusters_pred`, but only for the sake of
# speed in this example; this is not recommended in general):
vs &lt;- varsel(fit, method = "L1", nterms_max = 3, nclusters_pred = 10,
             seed = 5555)
# Now see, for example, `?print.vsel`, `?plot.vsel`, `?suggest_size.vsel`,
# and `?ranking` for possible post-processing functions.

</code></pre>

<hr>
<h2 id='y_wobs_offs'>Extract response values, observation weights, and offsets</h2><span id='topic+y_wobs_offs'></span>

<h3>Description</h3>

<p>A helper function for extracting response values, observation weights, and
offsets from a dataset. It is designed for use in the <code>extract_model_data</code>
function of custom reference model objects (see <code><a href="#topic+init_refmodel">init_refmodel()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_wobs_offs(newdata, wrhs = NULL, orhs = NULL, resp_form)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="y_wobs_offs_+3A_newdata">newdata</code></td>
<td>
<p>The <code>data.frame</code> from which at least the response values
should be extracted.</p>
</td></tr>
<tr><td><code id="y_wobs_offs_+3A_wrhs">wrhs</code></td>
<td>
<p>Either a right-hand side formula consisting only of the variable
in <code>newdata</code> containing the weights, <code>NULL</code> (for using a vector of ones),
or directly the numeric vector of observation weights.</p>
</td></tr>
<tr><td><code id="y_wobs_offs_+3A_orhs">orhs</code></td>
<td>
<p>Either a right-hand side formula consisting only of the variable
in <code>newdata</code> containing the offsets, <code>NULL</code> (for using a vector of zeros),
or directly the numeric vector of offsets.</p>
</td></tr>
<tr><td><code id="y_wobs_offs_+3A_resp_form">resp_form</code></td>
<td>
<p>If this is a formula, then the second element of this
formula (if the formula is a standard formula with both left-hand and
right-hand side, then its second element is the left-hand side; if the
formula is a right-hand side formula, then its second element is the
right-hand side) will be extracted from <code>newdata</code> (so <code>resp_form</code> may be
either a standard formula or a right-hand side formula, but in the latter
case, the right-hand side should consist only of the response variable). In
all other cases, <code>NULL</code> will be returned for element <code>y</code> of the output
<code>list</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with elements <code>y</code>, <code>weights</code>, and <code>offset</code>, each being a
numeric vector containing the data for the response, the observation
weights, and the offsets, respectively. An exception is that <code>y</code> may also
be <code>NULL</code> (depending on argument <code>resp_form</code>), a non-numeric vector, or a
<code>factor</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_refmodel">init_refmodel()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an example, see `?init_refmodel`.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
