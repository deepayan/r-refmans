<!DOCTYPE html><html><head><title>Help for package tigger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tigger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tigger-package'><p>tigger: Infers Novel Immunoglobulin Alleles from Sequencing Data</p></a></li>
<li><a href='#AIRRDb'><p>Example human immune repertoire data</p></a></li>
<li><a href='#cleanSeqs'><p>Clean up nucleotide sequences</p></a></li>
<li><a href='#findNovelAlleles'><p>Find novel alleles from repertoire sequencing data</p></a></li>
<li><a href='#findUnmutatedCalls'><p>Determine which calls represent an unmutated allele</p></a></li>
<li><a href='#generateEvidence'><p>Generate evidence</p></a></li>
<li><a href='#genotypeFasta'><p>Return the nucleotide sequences of a genotype</p></a></li>
<li><a href='#GermlineIGHV'><p>Human IGHV germlines</p></a></li>
<li><a href='#getMutatedPositions'><p>Find the location of mutations in a sequence</p></a></li>
<li><a href='#getMutCount'><p>Determine the mutation counts from allele calls</p></a></li>
<li><a href='#getPopularMutationCount'><p>Find mutation counts for frequency sequences</p></a></li>
<li><a href='#inferGenotype'><p>Infer a subject-specific genotype using a frequency method</p></a></li>
<li><a href='#inferGenotypeBayesian'><p>Infer a subject-specific genotype using a Bayesian approach</p></a></li>
<li><a href='#insertPolymorphisms'><p>Insert polymorphisms into a nucleotide sequence</p></a></li>
<li><a href='#plotGenotype'><p>Show a colorful representation of a genotype</p></a></li>
<li><a href='#plotNovel'><p>Visualize evidence of novel V alleles</p></a></li>
<li><a href='#readIgFasta'><p>Read immunoglobulin sequences</p></a></li>
<li><a href='#reassignAlleles'><p>Correct allele calls based on a personalized genotype</p></a></li>
<li><a href='#SampleDb'><p>Example human immune repertoire data</p></a></li>
<li><a href='#SampleGenotype'><p>Example genotype inferrence results</p></a></li>
<li><a href='#SampleGermlineIGHV'><p>Example Human IGHV germlines</p></a></li>
<li><a href='#SampleNovel'><p>Example novel allele detection results</p></a></li>
<li><a href='#selectNovel'><p>Select rows containing novel alleles</p></a></li>
<li><a href='#sortAlleles'><p>Sort allele names</p></a></li>
<li><a href='#subsampleDb'><p>Subsample repertoire</p></a></li>
<li><a href='#tigger'><p>tigger</p></a></li>
<li><a href='#updateAlleleNames'><p>Update IGHV allele names</p></a></li>
<li><a href='#writeFasta'><p>Write to a fasta file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Infers Novel Immunoglobulin Alleles from Sequencing Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Infers the V genotype of an individual from immunoglobulin (Ig)
    repertoire sequencing data (AIRR-Seq, Rep-Seq). Includes detection of 
    any novel alleles. This information is then used to correct existing V 
    allele calls from among the sample sequences.
    Citations:
    Gadala-Maria, et al (2015) &lt;<a href="https://doi.org/10.1073%2Fpnas.1417683112">doi:10.1073/pnas.1417683112</a>&gt;,
    Gadala-Maria, et al (2019) &lt;<a href="https://doi.org/10.3389%2Ffimmu.2019.00129">doi:10.3389/fimmu.2019.00129</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://tigger.readthedocs.io">http://tigger.readthedocs.io</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/kleinstein/tigger/issues">https://bitbucket.org/kleinstein/tigger/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), ggplot2 (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>alakazam (&ge; 1.3.0), dplyr (&ge; 1.0.0), doParallel, foreach,
graphics, gridExtra, gtools, iterators, lazyeval, parallel,
rlang, stats, stringi, tidyr (&ge; 1.1.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-10 12:54:05 UTC; susanna</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Gadala-Maria [aut],
  Susanna Marquez [aut, cre],
  Moriah Cohen [aut],
  Jason Vander Heiden [aut],
  Gur Yaari [aut],
  Steven Kleinstein [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susanna Marquez &lt;susanna.marquez@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tigger-package'>tigger: Infers Novel Immunoglobulin Alleles from Sequencing Data</h2><span id='topic+tigger-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Infers the V genotype of an individual from immunoglobulin (Ig) repertoire sequencing data (AIRR-Seq, Rep-Seq). Includes detection of any novel alleles. This information is then used to correct existing V allele calls from among the sample sequences. Citations: Gadala-Maria, et al (2015) <a href="https://doi.org/10.1073/pnas.1417683112">doi:10.1073/pnas.1417683112</a>, Gadala-Maria, et al (2019) <a href="https://doi.org/10.3389/fimmu.2019.00129">doi:10.3389/fimmu.2019.00129</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Susanna Marquez <a href="mailto:susanna.marquez@yale.edu">susanna.marquez@yale.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Gadala-Maria <a href="mailto:daniel.gadala-maria@yale.edu">daniel.gadala-maria@yale.edu</a>
</p>
</li>
<li><p> Moriah Cohen <a href="mailto:moriah.cohen@biu.ac.il">moriah.cohen@biu.ac.il</a>
</p>
</li>
<li><p> Jason Vander Heiden <a href="mailto:jason.vanderheiden@gmail.com">jason.vanderheiden@gmail.com</a>
</p>
</li>
<li><p> Gur Yaari <a href="mailto:gur.yaari@biu.ac.il">gur.yaari@biu.ac.il</a>
</p>
</li>
<li><p> Steven Kleinstein <a href="mailto:steven.kleinstein@yale.edu">steven.kleinstein@yale.edu</a> [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://tigger.readthedocs.io">http://tigger.readthedocs.io</a>
</p>
</li>
<li><p> Report bugs at <a href="https://bitbucket.org/kleinstein/tigger/issues">https://bitbucket.org/kleinstein/tigger/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AIRRDb'>Example human immune repertoire data</h2><span id='topic+AIRRDb'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of example V(D)J immunoglobulin sequences derived from a 
single individual (PGP1), sequenced on the Roche 454 platform, and assigned by
IMGT/HighV-QUEST to IGHV1 family alleles.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> where rows correspond to unique V(D)J sequences and
columns include:
</p>

<ul>
<li> <p><code>"sequence_alignment"</code>: IMGT-gapped V(D)J nucleotide sequence.
</p>
</li>
<li> <p><code>"v_call"</code>: IMGT/HighV-QUEST V segment allele calls.
</p>
</li>
<li> <p><code>"d_call"</code>: IMGT/HighV-QUEST D segment allele calls.
</p>
</li>
<li> <p><code>"j_call"</code>: IMGT/HighV-QUEST J segment allele calls.
</p>
</li>
<li> <p><code>"junction_length"</code>: Junction region length.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Gadala-Maria, et al. (2015) Automated analysis of high-throughput B cell 
sequencing data reveals a high frequency of novel immunoglobulin V gene 
segment alleles. PNAS. 112(8):E862-70.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+SampleDb">SampleDb</a> for Change-O formatted version of <code>AIRRDb</code>.
</p>

<hr>
<h2 id='cleanSeqs'>Clean up nucleotide sequences</h2><span id='topic+cleanSeqs'></span>

<h3>Description</h3>

<p><code>cleanSeqs</code> capitalizes nucleotides and replaces all characters 
besides <code>c("A", "C", "G", "T", "-", ".")</code> with <code>"N"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanSeqs(seqs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanSeqs_+3A_seqs">seqs</code></td>
<td>
<p>vector of nucleotide sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified vector of nucleotide sequences.
</p>


<h3>See Also</h3>

<p><a href="#topic+sortAlleles">sortAlleles</a> and <a href="#topic+updateAlleleNames">updateAlleleNames</a> can
help format a list of allele names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Clean messy nucleotide sequences
seqs &lt;- c("AGAT.taa-GAG...ATA", "GATACAGTXXZZAGNNPPACA")
cleanSeqs(seqs)

</code></pre>

<hr>
<h2 id='findNovelAlleles'>Find novel alleles from repertoire sequencing data</h2><span id='topic+findNovelAlleles'></span>

<h3>Description</h3>

<p><code>findNovelAlleles</code> analyzes mutation patterns in sequences thought to
align to each germline allele in order to determine which positions
might be polymorphic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNovelAlleles(
  data,
  germline_db,
  v_call = "v_call",
  j_call = "j_call",
  seq = "sequence_alignment",
  junction = "junction",
  junction_length = "junction_length",
  germline_min = 200,
  min_seqs = 50,
  auto_mutrange = TRUE,
  mut_range = 1:10,
  pos_range = 1:312,
  pos_range_max = NULL,
  y_intercept = 0.125,
  alpha = 0.05,
  j_max = 0.15,
  min_frac = 0.75,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNovelAlleles_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing repertoire data. See details.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_germline_db">germline_db</code></td>
<td>
<p>vector of named nucleotide germline sequences
matching the V calls in <code>data</code>. These should be 
the gapped reference germlines used to make the V calls.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_v_call">v_call</code></td>
<td>
<p>name of the column in <code>data</code> with V allele calls. 
Default is <code>v_call</code>.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_j_call">j_call</code></td>
<td>
<p>name of the column in <code>data</code> with J allele calls. 
Default is <code>j_call</code>.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is <code>sequence_alignment</code>.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_junction">junction</code></td>
<td>
<p>Junction region nucleotide sequence, which includes
the CDR3 and the two flanking conserved codons. Default
is <code>junction</code>.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_junction_length">junction_length</code></td>
<td>
<p>Number of junction nucleotides in the junction sequence.
Default is <code>junction_length</code>.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_germline_min">germline_min</code></td>
<td>
<p>the minimum number of sequences that must have a
particular germline allele call for the allele to
be analyzed.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_min_seqs">min_seqs</code></td>
<td>
<p>minimum number of total sequences (within the
desired mutational range and nucleotide range)
required for the samples to be considered.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_auto_mutrange">auto_mutrange</code></td>
<td>
<p>if <code>TRUE</code>, the algorithm will attempt to
determine the appropriate mutation range
automatically using the mutation count of the most
common sequence assigned to each allele analyzed.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_mut_range">mut_range</code></td>
<td>
<p>range of mutations that samples may carry and
be considered by the algorithm.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_pos_range">pos_range</code></td>
<td>
<p>range of IMGT-numbered positions that should be
considered by the algorithm.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_pos_range_max">pos_range_max</code></td>
<td>
<p>Name of the column in <code>data</code> with the ending
positions of the V alignment in the germline 
(usually <code>v_germline_end</code>). The end of the alignment will
be used to limit the range of positions to be 
considered to count mutations. With <code>NULL</code> all 
positions in the IMGT V region will be considered. In
this case, in sequences where the V was trimmed 
on the 3', mutated nucleotides could include nucleotides
from the CDR3.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_y_intercept">y_intercept</code></td>
<td>
<p>y-intercept threshold above which positions should be
considered potentially polymorphic.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_alpha">alpha</code></td>
<td>
<p>alpha value used for determining whether the 
fit y-intercept is greater than the <code>y_intercept</code>
threshold.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_j_max">j_max</code></td>
<td>
<p>maximum fraction of sequences perfectly aligning
to a potential novel allele that are allowed to
utilize to a particular combination of junction
length and J gene. The closer to 1, the less strict 
the filter for junction length and J gene diversity
will be.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_min_frac">min_frac</code></td>
<td>
<p>minimum fraction of sequences that must have
usable nucleotides in a given position for that
position to considered.</p>
</td></tr>
<tr><td><code id="findNovelAlleles_+3A_nproc">nproc</code></td>
<td>
<p>number of processors to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TIgGER allele-finding algorithm, briefly, works as follows:
Mutations are determined through comparison to the provided germline.
Mutation frequency at each *position* is determined as a function of
*sequence-wide* mutation counts. Polymorphic positions exhibit a high
mutation frequency despite sequence-wide mutation count. False positive of
potential novel alleles resulting from clonally-related sequences are guarded
against by ensuring that sequences perfectly matching the potential novel
allele utilize a wide range of combinations of J gene and junction length.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with a row for each known allele analyzed.
Besides metadata on the the parameters used in the search, each row will have
either a note as to where the polymorphism-finding algorithm exited or a
nucleotide sequence for the predicted novel allele, along with columns providing
additional evidence.
</p>
<p>The output contains the following columns:
</p>

<ul>
<li> <p><code>germline_call</code>: The input (uncorrected) V call.
</p>
</li>
<li> <p><code>note</code>: Comments regarding the inferrence.
</p>
</li>
<li> <p><code>polymorphism_call</code>: The novel allele call.
</p>
</li>
<li> <p><code>nt_substitutions</code>: Mutations identified in the novel allele, relative
to the reference germline (<code>germline_call</code>)
</p>
</li>
<li> <p><code>novel_imgt</code>: The novel allele sequence.
</p>
</li>
<li> <p><code>novel_imgt_count</code>:  The number of times the sequence <code>novel_imgt</code> 
is found in the input data. Considers the subsequence of <code>novel_imgt</code> 
in the <code>pos_range</code>.
</p>
</li>
<li> <p><code>novel_imgt_unique_j</code>: Number of distinct J calls associated to <code>novel_imgt</code> 
in the input data. Considers the subsequence of <code>novel_imgt</code> in the <code>pos_range</code>.       
</p>
</li>
<li> <p><code>novel_imgt_unique_cdr3</code>: Number of distinct CDR3 sequences associated
with <code>novel_imgt</code> in the input data. Considers the subsequence of <code>novel_imgt</code> 
in the <code>pos_range</code>.                                              
</p>
</li>
<li> <p><code>perfect_match_count</code>: Final number of sequences retained to call the new 
allele. These are unique sequences that have V segments that perfectly match 
the predicted germline in the <code>pos_range</code>.
</p>
</li>
<li> <p><code>perfect_match_freq</code>: <code>perfect_match_count / germline_call_count</code>
</p>
</li>
<li> <p><code>germline_call_count</code>: The number of sequences with the <code>germline_call</code> 
in the input data that were initially considered for the analysis.
</p>
</li>
<li> <p><code>germline_call_freq</code>: The fraction of sequences with the <code>germline_call</code> 
in the input data initially considered for the analysis.              
</p>
</li>
<li> <p><code>germline_imgt</code>: Germline sequence for <code>germline_call</code>.
</p>
</li>
<li> <p><code>germline_imgt_count</code>: The number of times the <code>germline_imgt</code> 
sequence is found in the input data.
</p>
</li>
<li> <p><code>mut_min</code>: Minimum mutation considered by the algorithm.
</p>
</li>
<li> <p><code>mut_max</code>: Maximum mutation considered by the algorithm.
</p>
</li>
<li> <p><code>mut_pass_count</code>: Number of sequences in the mutation range.
</p>
</li>
<li> <p><code>pos_min</code>: First position of the sequence considered by the algorithm (IMGT numbering).
</p>
</li>
<li> <p><code>pos_max</code>: Last position of the sequence considered by the algorithm (IMGT numbering).
</p>
</li>
<li> <p><code>y_intercept</code>: The y-intercept above which positions were considered 
potentially polymorphic.
</p>
</li>
<li> <p><code>y_intercept_pass</code>: Number of positions that pass the <code>y_intercept</code> threshold.
</p>
</li>
<li> <p><code>snp_pass</code>: Number of sequences that pass the <code>y_intercept</code> threshold and are
within the desired nucleotide range (<code>min_seqs</code>).
</p>
</li>
<li> <p><code>unmutated_count</code>: Number of unmutated sequences.
</p>
</li>
<li> <p><code>unmutated_freq</code>: Number of unmutated sequences over <code>germline_imgt_count</code>.
</p>
</li>
<li> <p><code>unmutated_snp_j_gene_length_count</code>: Number of distinct combinations
of SNP, J gene, and junction length.     
</p>
</li>
<li> <p><code>snp_min_seqs_j_max_pass</code>: Number of SNPs that pass both the <code>min_seqs</code> 
and <code>j_max</code> thresholds.
</p>
</li>
<li> <p><code>alpha</code>: Significance threshold to be used when constructing the 
confidence interval for the y-intercept.
</p>
</li>
<li> <p><code>min_seqs</code>: Input <code>min_seqs</code>. The minimum number of total sequences 
(within the desired mutational range and nucleotide range) required 
for the samples to be considered.
</p>
</li>
<li> <p><code>j_max</code>: Input <code>j_max</code>. The maximum fraction of sequences perfectly 
aligning to a potential novel allele that are allowed to utilize to a particular 
combination of junction length and J gene.
</p>
</li>
<li> <p><code>min_frac</code>: Input <code>min_frac</code>. The minimum fraction of sequences that must
have usable nucleotides in a given position for that position to be considered.
</p>
</li></ul>

<p>The following comments can appear in the <code>note</code> column:
</p>

<ul>
<li> <p><em>Novel allele found</em>: A novel allele was detected.
</p>
</li>
<li> <p><em>Same as:</em>: The same novel allele sequence
has been identified multiple times. If this happens, the function
will also throw the message 'Duplicated polymorphism(s) found'.
</p>
</li>
<li> <p><em>Plurality sequence too rare</em>: No sequence is frequent enough to pass 
the J test (<code>j_max</code>).
</p>
</li>
<li> <p><em>A J-junction combination is too prevalent</em>: Not enough J diversity (<code>j_max</code>).
</p>
</li>
<li> <p><em>No positions pass y-intercept test</em>: No positions above <code>y_intercept</code>.
</p>
</li>
<li> <p><em>Insufficient sequences in desired mutational range</em>: 
<code>mut_range</code> and <code>pos_range</code>.
</p>
</li>
<li> <p><em>Not enough sequences</em>: Not enough sequences in the desired mutational 
range and nucleotide range (<code>min_seqs</code>).
</p>
</li>
<li> <p><em>No unmutated versions of novel allele found</em>: All observed variants of the 
allele are mutated.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+selectNovel">selectNovel</a> to filter the results to show only novel alleles.
<a href="#topic+plotNovel">plotNovel</a> to visualize the data supporting any
novel alleles hypothesized to be present in the data and
<a href="#topic+inferGenotype">inferGenotype</a> and <a href="#topic+inferGenotypeBayesian">inferGenotypeBayesian</a> to determine if the novel alleles are frequent
enought to be included in the subject's genotype.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: In this example, with SampleGermlineIGHV,
# which contains reference germlines retrieved on August 2014,
# TIgGER finds the allele IGHV1-8*02_G234T. This allele
# was added to IMGT as IGHV1-8*03 on March 28, 2018.

# Find novel alleles and return relevant data
novel &lt;- findNovelAlleles(AIRRDb, SampleGermlineIGHV)
selectNovel(novel)


</code></pre>

<hr>
<h2 id='findUnmutatedCalls'>Determine which calls represent an unmutated allele</h2><span id='topic+findUnmutatedCalls'></span>

<h3>Description</h3>

<p><code>findUnmutatedCalls</code> determines which allele calls would represent a 
perfect match with the germline sequence, given a vector of allele calls and
mutation counts. In the case of multiple alleles being assigned to a
sequence, only the subset that would represent a perfect match is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUnmutatedCalls(allele_calls, sample_seqs, germline_db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUnmutatedCalls_+3A_allele_calls">allele_calls</code></td>
<td>
<p>vector of strings respresenting Ig allele calls,
where multiple calls are separated by a comma.</p>
</td></tr>
<tr><td><code id="findUnmutatedCalls_+3A_sample_seqs">sample_seqs</code></td>
<td>
<p>V(D)J-rearranged sample sequences matching the order
of the given <code>allele_calls</code>.</p>
</td></tr>
<tr><td><code id="findUnmutatedCalls_+3A_germline_db">germline_db</code></td>
<td>
<p>vector of named nucleotide germline sequences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings containing the members of <code>allele_calls</code>
that represent unmutated sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find which of the sample alleles are unmutated
calls &lt;- findUnmutatedCalls(AIRRDb$v_call, AIRRDb$sequence_alignment, 
                            germline_db=SampleGermlineIGHV)

</code></pre>

<hr>
<h2 id='generateEvidence'>Generate evidence</h2><span id='topic+generateEvidence'></span>

<h3>Description</h3>

<p><code>generateEvidence</code> builds a table of evidence metrics for the final novel V 
allele detection and genotyping inferrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateEvidence(
  data,
  novel,
  genotype,
  genotype_db,
  germline_db,
  j_call = "j_call",
  junction = "junction",
  fields = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateEvidence_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing sequence data that has been
passed through <a href="#topic+reassignAlleles">reassignAlleles</a> to correct the allele 
assignments.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_novel">novel</code></td>
<td>
<p>the <code>data.frame</code> returned by <a href="#topic+findNovelAlleles">findNovelAlleles</a>.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_genotype">genotype</code></td>
<td>
<p>the <code>data.frame</code> of alleles generated with <a href="#topic+inferGenotype">inferGenotype</a> 
denoting the genotype of the subject.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_genotype_db">genotype_db</code></td>
<td>
<p>a vector of named nucleotide germline sequences in the genotype.
Returned by <a href="#topic+genotypeFasta">genotypeFasta</a>.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_germline_db">germline_db</code></td>
<td>
<p>the original uncorrected germline database used to by
<a href="#topic+findNovelAlleles">findNovelAlleles</a> to identify novel alleles.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_j_call">j_call</code></td>
<td>
<p>name of the column in <code>data</code> with J allele calls. 
Default is <code>j_call</code>.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_junction">junction</code></td>
<td>
<p>Junction region nucleotide sequence, which includes
the CDR3 and the two flanking conserved codons. Default
is <code>junction</code>.</p>
</td></tr>
<tr><td><code id="generateEvidence_+3A_fields">fields</code></td>
<td>
<p>character vector of column names used to split the data to 
identify novel alleles, if any. If <code>NULL</code> then the data is 
not divided by grouping variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>genotype</code> input <code>data.frame</code> with the following additional columns 
providing supporting evidence for each inferred allele:
</p>

<ul>
<li> <p><code>field_id</code>: Data subset identifier, defined with the input paramter <code>fields</code>.
</p>
</li>
<li><p> A variable number of columns, specified with the input parameter <code>fields</code>.
</p>
</li>
<li> <p><code>polymorphism_call</code>: The novel allele call.
</p>
</li>
<li> <p><code>novel_imgt</code>: The novel allele sequence.
</p>
</li>
<li> <p><code>closest_reference</code>: The closest reference gene and allele in 
the <code>germline_db</code> database.
</p>
</li>
<li> <p><code>closest_reference_imgt</code>: Sequence of the closest reference gene and 
allele in the <code>germline_db</code> database.
</p>
</li>
<li> <p><code>germline_call</code>: The input (uncorrected) V call.
</p>
</li>
<li> <p><code>germline_imgt</code>: Germline sequence for <code>germline_call</code>.
</p>
</li>
<li> <p><code>nt_diff</code>: Number of nucleotides that differ between the new allele and
the closest reference (<code>closest_reference</code>) in the <code>germline_db</code> database.
</p>
</li>
<li> <p><code>nt_substitutions</code>: A comma separated list of specific nucleotide 
differences (e.g. <code>112G&gt;A</code>) in the novel allele.
</p>
</li>
<li> <p><code>aa_diff</code>: Number of amino acids that differ between the new allele and the closest 
reference (<code>closest_reference</code>) in the <code>germline_db</code> database.
</p>
</li>
<li> <p><code>aa_substitutions</code>: A comma separated list with specific amino acid 
differences (e.g. <code>96A&gt;N</code>) in the novel allele.
</p>
</li>
<li> <p><code>sequences</code>: Number of sequences unambiguosly assigned to this allele.
</p>
</li>
<li> <p><code>unmutated_sequences</code>: Number of records with the unmutated novel allele sequence.
</p>
</li>
<li> <p><code>unmutated_frequency</code>: Proportion of records with the unmutated novel allele 
sequence (<code>unmutated_sequences / sequences</code>).
</p>
</li>
<li> <p><code>allelic_percentage</code>: Percentage at which the (unmutated) allele is observed 
in the sequence dataset compared  to other (unmutated) alleles.
</p>
</li>
<li> <p><code>unique_js</code>: Number of unique J sequences found associated with the 
novel allele. The sequences are those who have been unambiguously assigned 
to the novel allelle (<code>polymorphism_call</code>).
</p>
</li>
<li> <p><code>unique_cdr3s</code>: Number of unique CDR3s associated with the inferred allele.
The sequences are those who have been unambiguously assigned to the 
novel allelle (polymorphism_call).
</p>
</li>
<li> <p><code>mut_min</code>: Minimum mutation considered by the algorithm.
</p>
</li>
<li> <p><code>mut_max</code>: Maximum mutation considered by the algorithm.
</p>
</li>
<li> <p><code>pos_min</code>: First position of the sequence considered by the algorithm (IMGT numbering).
</p>
</li>
<li> <p><code>pos_max</code>: Last position of the sequence considered by the algorithm (IMGT numbering).
</p>
</li>
<li> <p><code>y_intercept</code>: The y-intercept above which positions were considered 
potentially polymorphic.
</p>
</li>
<li> <p><code>alpha</code>: Significance threshold to be used when constructing the 
confidence interval for the y-intercept.
</p>
</li>
<li> <p><code>min_seqs</code>: Input <code>min_seqs</code>. The minimum number of total sequences 
(within the desired mutational range and nucleotide range) required 
for the samples to be considered.
</p>
</li>
<li> <p><code>j_max</code>: Input <code>j_max</code>. The maximum fraction of sequences perfectly 
aligning to a potential novel allele that are allowed to utilize to a particular 
combination of junction length and J gene.
</p>
</li>
<li> <p><code>min_frac</code>: Input <code>min_frac</code>. The minimum fraction of sequences that must
have usable nucleotides in a given position for that position to be considered.
</p>
</li>
<li> <p><code>note</code>: Comments regarding the novel allele inferrence.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+findNovelAlleles">findNovelAlleles</a>, <a href="#topic+inferGenotype">inferGenotype</a> and <a href="#topic+genotypeFasta">genotypeFasta</a> 
for generating the required input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate input data
novel &lt;- findNovelAlleles(AIRRDb, SampleGermlineIGHV,
    v_call="v_call", j_call="j_call", junction="junction", 
    junction_length="junction_length", seq="sequence_alignment")
genotype &lt;- inferGenotype(AIRRDb, find_unmutated=TRUE, 
                          germline_db=SampleGermlineIGHV,
                          novel=novel,
                          v_call="v_call", seq="sequence_alignment")
genotype_db &lt;- genotypeFasta(genotype, SampleGermlineIGHV, novel)
data_db &lt;- reassignAlleles(AIRRDb, genotype_db, 
v_call="v_call", seq="sequence_alignment")

# Assemble evidence table
evidence &lt;- generateEvidence(data_db, novel, genotype, 
                             genotype_db, SampleGermlineIGHV,
                             j_call = "j_call", 
                             junction = "junction")


</code></pre>

<hr>
<h2 id='genotypeFasta'>Return the nucleotide sequences of a genotype</h2><span id='topic+genotypeFasta'></span>

<h3>Description</h3>

<p><code>genotypeFasta</code> converts a genotype table into a vector of nucleotide
sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotypeFasta(genotype, germline_db, novel = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotypeFasta_+3A_genotype">genotype</code></td>
<td>
<p><code>data.frame</code> of alleles denoting a genotype, 
as returned by <a href="#topic+inferGenotype">inferGenotype</a>.</p>
</td></tr>
<tr><td><code id="genotypeFasta_+3A_germline_db">germline_db</code></td>
<td>
<p>vector of named nucleotide germline sequences
matching the alleles detailed in <code>genotype</code>.</p>
</td></tr>
<tr><td><code id="genotypeFasta_+3A_novel">novel</code></td>
<td>
<p>an optional <code>data.frame</code> containing putative
novel alleeles of the type returned by
<a href="#topic+findNovelAlleles">findNovelAlleles</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of strings containing the germline nucleotide
sequences of the alleles in the provided genotype.
</p>


<h3>See Also</h3>

<p><a href="#topic+inferGenotype">inferGenotype</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the sequences that correspond to the genotype
genotype_db &lt;- genotypeFasta(SampleGenotype, SampleGermlineIGHV, SampleNovel)

</code></pre>

<hr>
<h2 id='GermlineIGHV'>Human IGHV germlines</h2><span id='topic+GermlineIGHV'></span>

<h3>Description</h3>

<p>A <code>character</code> vector of all human IGHV germline gene segment alleles
in IMGT/GENE-DB (2019-06-01, 372 alleles). 
See IMGT data updates: https://www.imgt.org/IMGTgenedbdoc/dataupdates.html.
</p>


<h3>Format</h3>

<p>Values correspond to IMGT-gaped nuceltoide sequences (with
nucleotides capitalized and gaps represented by &quot;.&quot;) while names correspond
to stripped-down IMGT allele names (e.g. &quot;IGHV1-18*01&quot;).
</p>


<h3>References</h3>


<ol>
<li><p> Xochelli, et al. (2014) Immunoglobulin heavy variable (IGHV) genes and 
alleles: new entities, new names and implications for research and 
prognostication in chronic lymphocytic leukaemia. Immunogenetics. 67(1):61-6.
</p>
</li></ol>


<hr>
<h2 id='getMutatedPositions'>Find the location of mutations in a sequence</h2><span id='topic+getMutatedPositions'></span>

<h3>Description</h3>

<p><code>getMutatedPositions</code> takes two vectors of aligned sequences and
compares pairs of sequences. It returns a list of the nucleotide positions of
any differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMutatedPositions(
  samples,
  germlines,
  ignored_regex = "[\\.N-]",
  match_instead = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMutatedPositions_+3A_samples">samples</code></td>
<td>
<p>vector of strings respresenting aligned sequences</p>
</td></tr>
<tr><td><code id="getMutatedPositions_+3A_germlines">germlines</code></td>
<td>
<p>vector of strings respresenting aligned sequences
to which <code>samples</code> will be compared. If only
one string is submitted, it will be used for all
<code>samples</code>.</p>
</td></tr>
<tr><td><code id="getMutatedPositions_+3A_ignored_regex">ignored_regex</code></td>
<td>
<p>regular expression indicating what characters
should be ignored (such as gaps and N nucleotides).</p>
</td></tr>
<tr><td><code id="getMutatedPositions_+3A_match_instead">match_instead</code></td>
<td>
<p>if <code>TRUE</code>, the function returns the positions
that are the same instead of those that are
different.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the nucleotide positions of any differences between the
input vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create strings to act as a sample sequences and a reference sequence
seqs &lt;- c("----GATA", "GAGAGAGA", "TANA")
ref &lt;- "GATAGATA"

# Find the differences between the two
getMutatedPositions(seqs, ref)

</code></pre>

<hr>
<h2 id='getMutCount'>Determine the mutation counts from allele calls</h2><span id='topic+getMutCount'></span>

<h3>Description</h3>

<p><code>getMutCount</code> takes a set of nucleotide sequences and their allele calls
and determines the distance between that seqeunce and any germline alleles
contained within the call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMutCount(samples, allele_calls, germline_db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMutCount_+3A_samples">samples</code></td>
<td>
<p>vector of IMGT-gapped sample V sequences</p>
</td></tr>
<tr><td><code id="getMutCount_+3A_allele_calls">allele_calls</code></td>
<td>
<p>vector of strings respresenting Ig allele calls for
the sequences in <code>samples</code>, where multiple
calls are separated by a comma</p>
</td></tr>
<tr><td><code id="getMutCount_+3A_germline_db">germline_db</code></td>
<td>
<p>vector of named nucleotide germline sequences
matching the calls detailed in <code>allele_calls</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list equal in length to <code>samples</code>, containing the Hamming
distance to each germline allele contained within each call within
each element of <code>samples</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Insert a mutation into a germline sequence
s2 &lt;- s3 &lt;- SampleGermlineIGHV[1]
stringi::stri_sub(s2, 103, 103) &lt;- "G"
stringi::stri_sub(s3, 107, 107) &lt;- "C"

sample_seqs &lt;- c(SampleGermlineIGHV[2], s2, s3)

# Pretend that one sample sequence has received an ambiguous allele call
sample_alleles &lt;- c(paste(names(SampleGermlineIGHV[1:2]), collapse=","),
                    names(SampleGermlineIGHV[2]),
                    names(SampleGermlineIGHV[1]))

# Compare each sequence to its assigned germline(s) to determine the distance
getMutCount(sample_seqs, sample_alleles, SampleGermlineIGHV)

</code></pre>

<hr>
<h2 id='getPopularMutationCount'>Find mutation counts for frequency sequences</h2><span id='topic+getPopularMutationCount'></span>

<h3>Description</h3>

<p><code>getPopularMutationCount</code> determines which sequences occur frequently
for each V gene and returns the mutation count of those sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopularMutationCount(
  data,
  germline_db,
  v_call = "v_call",
  seq = "sequence_alignment",
  gene_min = 0.001,
  seq_min = 50,
  seq_p_of_max = 1/8,
  full_return = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPopularMutationCount_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> in the Change-O format. See
<a href="#topic+findNovelAlleles">findNovelAlleles</a> for a list of required
columns.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_germline_db">germline_db</code></td>
<td>
<p>named list of IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_v_call">v_call</code></td>
<td>
<p>name of the column in <code>data</code> with V allele calls. 
Default is <code>v_call</code>.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is <code>sequence_alignment</code>.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_gene_min">gene_min</code></td>
<td>
<p>portion of all unique sequences a gene must
constitute to avoid exclusion.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_seq_min">seq_min</code></td>
<td>
<p>number of copies of the V that must be present for
to avoid exclusion.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_seq_p_of_max">seq_p_of_max</code></td>
<td>
<p>ror each gene, the fraction of the most common V sequence
count that a sequence must meet to avoid exclusion.</p>
</td></tr>
<tr><td><code id="getPopularMutationCount_+3A_full_return">full_return</code></td>
<td>
<p>if <code>TRUE</code>, will return all <code>data</code> columns and
will include sequences with mutation count &lt; 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of genes that have a frequent sequence mutation count
above 1.
</p>


<h3>See Also</h3>

<p><a href="#topic+getMutatedPositions">getMutatedPositions</a> can be used to find which positions
of a set of sequences are mutated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getPopularMutationCount(AIRRDb, SampleGermlineIGHV)

</code></pre>

<hr>
<h2 id='inferGenotype'>Infer a subject-specific genotype using a frequency method</h2><span id='topic+inferGenotype'></span>

<h3>Description</h3>

<p><code>inferGenotype</code> infers an subject's genotype using a frequency method.
The genotype is inferred by finding the minimum number set of alleles that 
can explain the majority of each gene's calls. The most common allele of 
each gene is included in the genotype first, and the next most common allele 
is added until the desired fraction of alleles can be explained. In this 
way, mistaken allele calls (resulting from sequences which
by chance have been mutated to look like another allele) can be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferGenotype(
  data,
  germline_db = NA,
  novel = NA,
  v_call = "v_call",
  seq = "sequence_alignment",
  fraction_to_explain = 0.875,
  gene_cutoff = 1e-04,
  find_unmutated = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferGenotype_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing V allele
calls from a single subject.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_germline_db">germline_db</code></td>
<td>
<p>named vector of sequences containing the
germline sequences named in
<code>allele_calls</code>. Only required if
<code>find_unmutated</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_novel">novel</code></td>
<td>
<p>optional <code>data.frame</code> of the type
novel returned by
<a href="#topic+findNovelAlleles">findNovelAlleles</a> containing
germline sequences that will be utilized if
<code>find_unmutated</code> is <code>TRUE</code>. See
Details.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_v_call">v_call</code></td>
<td>
<p>column in <code>data</code> with V allele calls.
Default is <code>"v_call"</code>.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is <code>sequence_alignment</code>.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_fraction_to_explain">fraction_to_explain</code></td>
<td>
<p>the portion of each gene that must be
explained by the alleles that will be included
in the genotype.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_gene_cutoff">gene_cutoff</code></td>
<td>
<p>either a number of sequences or a fraction of
the length of <code>allele_calls</code> denoting the
minimum number of times a gene must be
observed in <code>allele_calls</code> to be included
in the genotype.</p>
</td></tr>
<tr><td><code id="inferGenotype_+3A_find_unmutated">find_unmutated</code></td>
<td>
<p>if <code>TRUE</code>, use <code>germline_db</code> to
find which samples are unmutated. Not needed
if <code>allele_calls</code> only represent
unmutated samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele calls representing cases where multiple alleles have been
assigned to a single sample sequence are rare among unmutated
sequences but may result if nucleotides for certain positions are
not available. Calls containing multiple alleles are treated as
belonging to all groups. If <code>novel</code> is provided, all
sequences that are assigned to the same starting allele as any
novel germline allele will have the novel germline allele appended
to their assignent prior to searching for unmutated sequences.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of alleles denoting the genotype of the subject containing 
the following columns:
</p>

<ul>
<li> <p><code>gene</code>: The gene name without allele.
</p>
</li>
<li> <p><code>alleles</code>: Comma separated list of alleles for the given <code>gene</code>.
</p>
</li>
<li> <p><code>counts</code>: Comma separated list of observed sequences for each 
corresponding allele in the <code>alleles</code> list.
</p>
</li>
<li> <p><code>total</code>: The total count of observed sequences for the given <code>gene</code>.
</p>
</li>
<li> <p><code>note</code>: Any comments on the inferrence.
</p>
</li></ul>



<h3>Note</h3>

<p>This method works best with data derived from blood, where a large
portion of sequences are expected to be unmutated. Ideally, there
should be hundreds of allele calls per gene in the input.
</p>


<h3>See Also</h3>

<p><a href="#topic+plotGenotype">plotGenotype</a> for a colorful visualization and
<a href="#topic+genotypeFasta">genotypeFasta</a> to convert the genotype to nucleotide sequences.
See <a href="#topic+inferGenotypeBayesian">inferGenotypeBayesian</a> to infer a subject-specific genotype 
using a Bayesian approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Infer IGHV genotype, using only unmutated sequences, including novel alleles
inferGenotype(AIRRDb, germline_db=SampleGermlineIGHV, novel=SampleNovel,
              find_unmutated=TRUE)

</code></pre>

<hr>
<h2 id='inferGenotypeBayesian'>Infer a subject-specific genotype using a Bayesian approach</h2><span id='topic+inferGenotypeBayesian'></span>

<h3>Description</h3>

<p><code>inferGenotypeBayesian</code> infers an subject's genotype by applying a Bayesian framework 
with a Dirichlet prior for the multinomial distribution. Up to four distinct alleles are 
allowed in an individual’s genotype. Four likelihood distributions were generated by 
empirically fitting three high coverage genotypes from three individuals 
(Laserson and Vigneault et al, 2014). A posterior probability is calculated for the 
four most common alleles. The certainty of the highest probability model was 
calculated using a Bayes factor (the most likely model divided by second-most likely model). 
The larger the Bayes factor (K), the greater the certainty in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferGenotypeBayesian(
  data,
  germline_db = NA,
  novel = NA,
  v_call = "v_call",
  seq = "sequence_alignment",
  find_unmutated = TRUE,
  priors = c(0.6, 0.4, 0.4, 0.35, 0.25, 0.25, 0.25, 0.25, 0.25)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferGenotypeBayesian_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing V allele
calls from a single subject. If <code>find_unmutated</code> 
is <code>TRUE</code>, then the sample IMGT-gapped V(D)J sequence 
should be provided in column <code>sequence_alignment</code></p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_germline_db">germline_db</code></td>
<td>
<p>named vector of sequences containing the
germline sequences named in <code>allele_calls</code>. 
Only required if <code>find_unmutated</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_novel">novel</code></td>
<td>
<p>an optional <code>data.frame</code> of the type
novel returned by <a href="#topic+findNovelAlleles">findNovelAlleles</a> containing
germline sequences that will be utilized if
<code>find_unmutated</code> is <code>TRUE</code>. See Details.</p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_v_call">v_call</code></td>
<td>
<p>column in <code>data</code> with V allele calls.
Default is <code>"v_call"</code>.</p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is <code>"sequence_alignment"</code>.</p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_find_unmutated">find_unmutated</code></td>
<td>
<p>if <code>TRUE</code>, use <code>germline_db</code> to
find which samples are unmutated. Not needed
if <code>allele_calls</code> only represent
unmutated samples.</p>
</td></tr>
<tr><td><code id="inferGenotypeBayesian_+3A_priors">priors</code></td>
<td>
<p>a numeric vector of priors for the multinomial distribution. 
The <code>priors</code> vector must be nine values that defined
the priors for the heterozygous (two allele), 
trizygous (three allele), and quadrozygous (four allele) 
distributions. The first two values of <code>priors</code> define 
the prior for the heterozygous case, the next three values are for
the trizygous case, and the final four values are for the 
quadrozygous case. Each set of priors should sum to one. 
Note, each distribution prior is actually defined internally 
by set of four numbers, with the unspecified final values 
assigned to <code>0</code>; e.g., the heterozygous case is 
<code>c(priors[1], priors[2], 0, 0)</code>. The prior for the 
homozygous distribution is fixed at <code>c(1, 0, 0, 0)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele calls representing cases where multiple alleles have been
assigned to a single sample sequence are rare among unmutated
sequences but may result if nucleotides for certain positions are
not available. Calls containing multiple alleles are treated as
belonging to all groups. If <code>novel</code> is provided, all
sequences that are assigned to the same starting allele as any
novel germline allele will have the novel germline allele appended
to their assignent prior to searching for unmutated sequences.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of alleles denoting the genotype of the subject with the log10
of the likelihood of each model and the log10 of the Bayes factor. The output 
contains the following columns:
</p>

<ul>
<li> <p><code>gene</code>: The gene name without allele.
</p>
</li>
<li> <p><code>alleles</code>: Comma separated list of alleles for the given <code>gene</code>.
</p>
</li>
<li> <p><code>counts</code>: Comma separated list of observed sequences for each 
corresponding allele in the <code>alleles</code> list.
</p>
</li>
<li> <p><code>total</code>: The total count of observed sequences for the given <code>gene</code>.
</p>
</li>
<li> <p><code>note</code>: Any comments on the inferrence.
</p>
</li>
<li> <p><code>kh</code>: log10 likelihood that the <code>gene</code> is homozygous.
</p>
</li>
<li> <p><code>kd</code>: log10 likelihood that the <code>gene</code> is heterozygous.
</p>
</li>
<li> <p><code>kt</code>: log10 likelihood that the <code>gene</code> is trizygous
</p>
</li>
<li> <p><code>kq</code>: log10 likelihood that the <code>gene</code> is quadrozygous.
</p>
</li>
<li> <p><code>k_diff</code>: log10 ratio of the highest to second-highest zygosity likelihoods.
</p>
</li></ul>



<h3>Note</h3>

<p>This method works best with data derived from blood, where a large
portion of sequences are expected to be unmutated. Ideally, there
should be hundreds of allele calls per gene in the input.
</p>


<h3>References</h3>


<ol>
<li><p>  Laserson U and Vigneault F, et al. High-resolution antibody dynamics of 
vaccine-induced immune responses. PNAS. 2014 111(13):4928-33.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+plotGenotype">plotGenotype</a> for a colorful visualization and
<a href="#topic+genotypeFasta">genotypeFasta</a> to convert the genotype to nucleotide sequences.
See <a href="#topic+inferGenotype">inferGenotype</a> to infer a subject-specific genotype using 
a frequency method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Infer IGHV genotype, using only unmutated sequences, including novel alleles
inferGenotypeBayesian(AIRRDb, germline_db=SampleGermlineIGHV, novel=SampleNovel, 
                      find_unmutated=TRUE, v_call="v_call", seq="sequence_alignment")

</code></pre>

<hr>
<h2 id='insertPolymorphisms'>Insert polymorphisms into a nucleotide sequence</h2><span id='topic+insertPolymorphisms'></span>

<h3>Description</h3>

<p><code>insertPolymorphisms</code> replaces nucleotides in the desired locations of a
provided sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertPolymorphisms(sequence, positions, nucleotides)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertPolymorphisms_+3A_sequence">sequence</code></td>
<td>
<p>starting nucletide sequence.</p>
</td></tr>
<tr><td><code id="insertPolymorphisms_+3A_positions">positions</code></td>
<td>
<p>numeric vector of positions which to be changed.</p>
</td></tr>
<tr><td><code id="insertPolymorphisms_+3A_nucleotides">nucleotides</code></td>
<td>
<p>character vector of nucletides to which to change the
positions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence with the desired nucleotides in the provided locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>insertPolymorphisms("HUGGED", c(1, 6, 2), c("T", "R", "I")) 

</code></pre>

<hr>
<h2 id='plotGenotype'>Show a colorful representation of a genotype</h2><span id='topic+plotGenotype'></span>

<h3>Description</h3>

<p><code>plotGenotype</code> plots a genotype table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGenotype(
  genotype,
  facet_by = NULL,
  gene_sort = c("name", "position"),
  text_size = 12,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGenotype_+3A_genotype">genotype</code></td>
<td>
<p><code>data.frame</code> of alleles denoting a genotype, 
as returned by <a href="#topic+inferGenotype">inferGenotype</a>.</p>
</td></tr>
<tr><td><code id="plotGenotype_+3A_facet_by">facet_by</code></td>
<td>
<p>column name in <code>genotype</code> to facet the plot by. 
if <code>NULL</code>, then do not facet the plot.</p>
</td></tr>
<tr><td><code id="plotGenotype_+3A_gene_sort">gene_sort</code></td>
<td>
<p>string defining the method to use when sorting alleles.
if <code>"name"</code> then sort in lexicographic order. If
<code>"position"</code> then sort by position in the locus, as
determined by the final two numbers in the gene name.</p>
</td></tr>
<tr><td><code id="plotGenotype_+3A_text_size">text_size</code></td>
<td>
<p>point size of the plotted text.</p>
</td></tr>
<tr><td><code id="plotGenotype_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotGenotype_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object defining the plot.
</p>


<h3>See Also</h3>

<p><a href="#topic+inferGenotype">inferGenotype</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot genotype
plotGenotype(SampleGenotype)

# Facet by subject
genotype_a &lt;- genotype_b &lt;- SampleGenotype
genotype_a$SUBJECT &lt;- "A"
genotype_b$SUBJECT &lt;- "B"
geno_sub &lt;- rbind(genotype_a, genotype_b)
plotGenotype(geno_sub, facet_by="SUBJECT", gene_sort="pos")

</code></pre>

<hr>
<h2 id='plotNovel'>Visualize evidence of novel V alleles</h2><span id='topic+plotNovel'></span>

<h3>Description</h3>

<p><code>plotNovel</code> is be used to visualize the evidence of any novel V
alleles found using <a href="#topic+findNovelAlleles">findNovelAlleles</a>. It can also be used to
visualize the results for alleles that did
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNovel(
  data,
  novel_row,
  v_call = "v_call",
  j_call = "j_call",
  seq = "sequence_alignment",
  junction = "junction",
  junction_length = "junction_length",
  pos_range_max = NULL,
  ncol = 1,
  multiplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNovel_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing repertoire data. See
<a href="#topic+findNovelAlleles">findNovelAlleles</a> for details.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_novel_row">novel_row</code></td>
<td>
<p>single row from a data frame as output by
<a href="#topic+findNovelAlleles">findNovelAlleles</a> that contains a
polymorphism-containing germline allele.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_v_call">v_call</code></td>
<td>
<p>name of the column in <code>data</code> with V allele
calls. Default is <code>v_call</code>.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_j_call">j_call</code></td>
<td>
<p>name of the column in <code>data</code> with J allele calls. 
Default is <code>j_call</code>.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is <code>sequence_alignment</code>.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_junction">junction</code></td>
<td>
<p>Junction region nucleotide sequence, which includes
the CDR3 and the two flanking conserved codons. Default
is <code>junction</code>.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_junction_length">junction_length</code></td>
<td>
<p>number of junction nucleotides in the junction sequence.
Default is <code>junction_length</code>.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_pos_range_max">pos_range_max</code></td>
<td>
<p>Name of the column in <code>data</code> with the ending
positions of the V alignment in the germline 
(usually <code>v_germline_end</code>).</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_ncol">ncol</code></td>
<td>
<p>number of columns to use when laying out the plots.</p>
</td></tr>
<tr><td><code id="plotNovel_+3A_multiplot">multiplot</code></td>
<td>
<p>whether to return one single plot (<code>TRUE</code>) or a list 
with the three individual plots (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first panel in the plot shows, for all sequences which align to a particular 
germline allele, the mutation frequency at each postion along the aligned 
sequence as a function of the sequence-wide mutation count. Each line is a position.
Positions that contain polymorphisms (rather than somatic hypermutations) 
will exhibit a high apparent mutation frequency for a range of 
sequence-wide mutation counts. The positions are color coded as follows:
</p>

<ul>
<li><p>  red:    the position(s) pass(ess) the novel allele test 
</p>
</li>
<li><p>  yellow: the position(s) pass(ess) the y-intercept test but not
other tests
</p>
</li>
<li><p>  blue:   the position(s) didn't pass the y-intercept test and 
was(were) not further considered
</p>
</li></ul>

<p>The second panel shows the nucleotide usage at each of the polymorphic positions
as a function of sequence-wide mutation count. If no polymorphisms were identified,
the panel will show the mutation count.
</p>
<p>To avoid cases where a clonal expansion might lead to a false positive, TIgGER examines
the combinations of J gene and junction length among sequences which perfectly 
match the proposed germline allele. Clonally related sequences usually share 
the same V gene, J gene and junction length. Requiring the novel allele
to be found in different combinations of J gene and junction lengths
is a proxy for requiring it to be found in different clonal lineages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the evidence for the first (and only) novel allele in the example data
novel &lt;- selectNovel(SampleNovel)
plotNovel(AIRRDb, novel[1, ], v_call="v_call", j_call="j_call", 
          seq="sequence_alignment", junction="junction", junction_length="junction_length", 
          multiplot=TRUE)

</code></pre>

<hr>
<h2 id='readIgFasta'>Read immunoglobulin sequences</h2><span id='topic+readIgFasta'></span>

<h3>Description</h3>

<p><code>readIgFasta</code> reads a fasta-formatted file of immunoglobulin (Ig)
sequences and returns a named vector of those sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIgFasta(fasta_file, strip_down_name = TRUE, force_caps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readIgFasta_+3A_fasta_file">fasta_file</code></td>
<td>
<p>fasta-formatted file of immunoglobuling sequences.</p>
</td></tr>
<tr><td><code id="readIgFasta_+3A_strip_down_name">strip_down_name</code></td>
<td>
<p>if <code>TRUE</code>, will extract only the allele name
from the strings fasta file's sequence names.</p>
</td></tr>
<tr><td><code id="readIgFasta_+3A_force_caps">force_caps</code></td>
<td>
<p>if <code>TRUE</code>, will force nucleotides to
uppercase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of strings respresenting Ig alleles.
</p>


<h3>See Also</h3>

<p><a href="#topic+writeFasta">writeFasta</a> to do the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# germlines &lt;- readIgFasta("ighv.fasta")

## End(Not run)

</code></pre>

<hr>
<h2 id='reassignAlleles'>Correct allele calls based on a personalized genotype</h2><span id='topic+reassignAlleles'></span>

<h3>Description</h3>

<p><code>reassignAlleles</code> uses a subject-specific genotype to correct
correct preliminary allele assignments of a set of sequences derived
from a single subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reassignAlleles(
  data,
  genotype_db,
  v_call = "v_call",
  seq = "sequence_alignment",
  method = "hamming",
  path = NA,
  keep_gene = c("gene", "family", "repertoire")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reassignAlleles_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing V allele calls from a
single subject and the sample IMGT-gapped V(D)J sequences under
<code>seq</code>.</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_genotype_db">genotype_db</code></td>
<td>
<p>vector of named nucleotide germline sequences
matching the calls detailed in <code>allele_calls</code>
and personalized to the subject</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_v_call">v_call</code></td>
<td>
<p>name of the column in <code>data</code> with V allele
calls. Default is <code>v_call</code>.</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_seq">seq</code></td>
<td>
<p>name of the column in <code>data</code> with the 
aligned, IMGT-numbered, V(D)J nucleotide sequence.
Default is SEQUENCE_IMGT</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_method">method</code></td>
<td>
<p>method to use when realigning sequences to
the genotype_db sequences. Currently, only <code>"hammming"</code>
(for Hamming distance) is implemented.</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_path">path</code></td>
<td>
<p>directory containing the tool used in the
realignment method, if needed. Hamming distance does
not require a path to a tool.</p>
</td></tr>
<tr><td><code id="reassignAlleles_+3A_keep_gene">keep_gene</code></td>
<td>
<p>string indicating if the gene (<code>"gene"</code>), 
family (<code>"family"</code>) or complete repertoire
(<code>"repertoire"</code>) assignments should be performed. 
Use of <code>"gene"</code> increases speed by minimizing required number of 
alignments, as gene level assignments will be maintained when possible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to save time, initial gene assignments are preserved and
the allele calls are chosen from among those provided in <code>genotype_db</code>,
based on a simple alignment to the sample sequence.
</p>


<h3>Value</h3>

<p>A modifed input <code>data.frame</code> containing the best allele call from 
among the sequences listed in <code>genotype_db</code> in the 
<code>v_call_genotyped</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract the database sequences that correspond to the genotype
genotype_db &lt;- genotypeFasta(SampleGenotype, SampleGermlineIGHV, novel=SampleNovel)

# Use the personlized genotype to determine corrected allele assignments
output_db &lt;- reassignAlleles(AIRRDb, genotype_db, v_call="v_call",
                             seq="sequence_alignment")

</code></pre>

<hr>
<h2 id='SampleDb'>Example human immune repertoire data</h2><span id='topic+SampleDb'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of example V(D)J immunoglobulin sequences derived from a 
single individual (PGP1), sequenced on the Roche 454 platform, and assigned by
IMGT/HighV-QUEST to IGHV1 family alleles.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> where rows correspond to unique V(D)J sequences and
columns include:
</p>

<ul>
<li> <p><code>"SEQUENCE_IMGT"</code>: IMGT-gapped V(D)J nucleotide sequence.
</p>
</li>
<li> <p><code>"V_CALL"</code>: IMGT/HighV-QUEST V segment allele calls.
</p>
</li>
<li> <p><code>"D_CALL"</code>: IMGT/HighV-QUEST D segment allele calls.
</p>
</li>
<li> <p><code>"J_CALL"</code>: IMGT/HighV-QUEST J segment allele calls.
</p>
</li>
<li> <p><code>"JUNCTION_LENGTH"</code>: Junction region length.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Gadala-Maria, et al. (2015) Automated analysis of high-throughput B cell 
sequencing data reveals a high frequency of novel immunoglobulin V gene 
segment alleles. PNAS. 112(8):E862-70.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+AIRRDb">AIRRDb</a> for an AIRR formatted version of <code>SampleDb</code>.
</p>

<hr>
<h2 id='SampleGenotype'>Example genotype inferrence results</h2><span id='topic+SampleGenotype'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of genotype inference results from <a href="#topic+inferGenotype">inferGenotype</a>
after novel allele detection via <a href="#topic+findNovelAlleles">findNovelAlleles</a>.
Source data was a collection of V(D)J immunoglobulin sequences derived from a single
individual (PGP1), sequenced on the Roche 454 platform, and assigned by
IMGT/HighV-QUEST to IGHV1 family alleles.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> where rows correspond to genes carried by an
individual and columns lists the alleles of those genes and their counts.
</p>


<h3>References</h3>


<ol>
<li><p> Gadala-Maria, et al. (2015) Automated analysis of high-throughput B cell 
sequencing data reveals a high frequency of novel immunoglobulin V gene 
segment alleles. PNAS. 112(8):E862-70.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+inferGenotype">inferGenotype</a> for detailed column descriptions.
</p>

<hr>
<h2 id='SampleGermlineIGHV'>Example Human IGHV germlines</h2><span id='topic+SampleGermlineIGHV'></span>

<h3>Description</h3>

<p>A <code>character</code> vector of all 344 human IGHV germline gene segment alleles
in IMGT/GENE-DB release 2014-08-4.
</p>


<h3>Format</h3>

<p>Values correspond to IMGT-gaped nuceltoide sequences (with
nucleotides capitalized and gaps represented by &quot;.&quot;) while names correspond
to stripped-down IMGT allele names (e.g. &quot;IGHV1-18*01&quot;).
</p>


<h3>References</h3>


<ol>
<li><p> Xochelli, et al. (2014) Immunoglobulin heavy variable (IGHV) genes and 
alleles: new entities, new names and implications for research and 
prognostication in chronic lymphocytic leukaemia. Immunogenetics. 67(1):61-6.
</p>
</li></ol>


<hr>
<h2 id='SampleNovel'>Example novel allele detection results</h2><span id='topic+SampleNovel'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of novel allele detection results from <a href="#topic+findNovelAlleles">findNovelAlleles</a>. 
Source data was a collection of V(D)J immunoglobulin sequences derived from a single
individual (PGP1), sequenced on the Roche 454 platform, and assigned by
IMGT/HighV-QUEST to IGHV1 family alleles.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> where rows correspond to alleles checked for
polymorphisms and columns give results as well as paramaters used to run
the test.
</p>


<h3>References</h3>


<ol>
<li><p> Gadala-Maria, et al. (2015) Automated analysis of high-throughput B cell 
sequencing data reveals a high frequency of novel immunoglobulin V gene 
segment alleles. PNAS. 112(8):E862-70.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+findNovelAlleles">findNovelAlleles</a> for detailed column descriptions.
</p>

<hr>
<h2 id='selectNovel'>Select rows containing novel alleles</h2><span id='topic+selectNovel'></span>

<h3>Description</h3>

<p><code>selectNovel</code> takes the result from <a href="#topic+findNovelAlleles">findNovelAlleles</a> and
selects only the rows containing unique, novel alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectNovel(novel, keep_alleles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectNovel_+3A_novel">novel</code></td>
<td>
<p><code>data.frame</code> of the type returned by
<a href="#topic+findNovelAlleles">findNovelAlleles</a>.</p>
</td></tr>
<tr><td><code id="selectNovel_+3A_keep_alleles">keep_alleles</code></td>
<td>
<p><code>logical</code> indicating if different alleles
leading to the same novel sequence should be kept.
See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If, for instance, subject has in his genome <code>IGHV1-2*02</code> and a novel 
allele equally close to <code>IGHV1-2*02</code> and <code>IGHV1-2*05</code>, the novel allele may be
detected by analyzing sequences that best align to either of these alleles.
If <code>keep_alleles</code> is <code>TRUE</code>, both polymorphic allele calls will
be retained. In the case that multiple mutation ranges are checked for the
same allele, only one mutation range will be kept in the output.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing only unique, novel alleles (if any)
that were in the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>novel &lt;- selectNovel(SampleNovel)

</code></pre>

<hr>
<h2 id='sortAlleles'>Sort allele names</h2><span id='topic+sortAlleles'></span>

<h3>Description</h3>

<p><code>sortAlleles</code> returns a sorted vector of strings respresenting Ig allele
names. Names are first sorted by gene family, then by gene, then by allele.
Duplicated genes have their alleles are sorted as if they were part of their
non-duplicated counterparts (e.g. <code>IGHV1-69D*01</code> comes after <code>IGHV1-69*01</code> 
but before <code>IGHV1-69*02</code>), and non-localized genes (e.g. <code>IGHV1-NL1*01</code>) 
come last within their gene family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortAlleles(allele_calls, method = c("name", "position"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortAlleles_+3A_allele_calls">allele_calls</code></td>
<td>
<p>vector of strings respresenting Ig allele names.</p>
</td></tr>
<tr><td><code id="sortAlleles_+3A_method">method</code></td>
<td>
<p>string defining the method to use when sorting alleles.
If <code>"name"</code> then sort in lexicographic order. If
<code>"position"</code> then sort by position in the locus, as
determined by the final two numbers in the gene name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted vector of strings respresenting Ig allele names.
</p>


<h3>See Also</h3>

<p>Like <code>sortAlleles</code>, <a href="#topic+updateAlleleNames">updateAlleleNames</a> can help
format a list of allele names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a list of allele names
alleles &lt;- c("IGHV1-69D*01","IGHV1-69*01","IGHV1-2*01","IGHV1-69-2*01",
             "IGHV2-5*01","IGHV1-NL1*01", "IGHV1-2*01,IGHV1-2*05", 
             "IGHV1-2", "IGHV1-2*02", "IGHV1-69*02")

# Sort the alleles by name
sortAlleles(alleles)

# Sort the alleles by position in the locus
sortAlleles(alleles, method="pos")

</code></pre>

<hr>
<h2 id='subsampleDb'>Subsample repertoire</h2><span id='topic+subsampleDb'></span>

<h3>Description</h3>

<p><code>subsampleDb</code> will sample the same number of sequences for each gene, family
or allele (specified with <code>mode</code>) in <code>data</code>. Samples or subjects can
be subsampled indepently by setting <code>group</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsampleDb(
  data,
  gene = "v_call",
  mode = c("gene", "allele", "family"),
  min_n = 1,
  max_n = NULL,
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsampleDb_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing repertoire data.</p>
</td></tr>
<tr><td><code id="subsampleDb_+3A_gene">gene</code></td>
<td>
<p>name of the column in <code>data</code> with allele calls. Default
is <code>v_call</code>.</p>
</td></tr>
<tr><td><code id="subsampleDb_+3A_mode">mode</code></td>
<td>
<p>one of <code>c("gene", "family", "allele")</code> defining the degree of
specificity regarding allele calls when subsetting sequences.
Determines how <code>data</code> will be split into subsets from 
which the same number of sequences will be subsampled. See 
also <code>group</code>.</p>
</td></tr>
<tr><td><code id="subsampleDb_+3A_min_n">min_n</code></td>
<td>
<p>minimum number of observations to sample from each groupe. A group with 
less observations than the minimum is excluded.</p>
</td></tr>
<tr><td><code id="subsampleDb_+3A_max_n">max_n</code></td>
<td>
<p>maximum number of observations to sample for all <code>mode</code> groups.
If <code>NULL</code>, it will be set automatically to the size of 
the smallest group. If <code>max_n</code> is larger than the availabe 
number of sequences for any <code>mode</code> group, if will be 
automatically adjusted and the efective <code>max_n</code> used 
will be the size of the smallest <code>mode</code> group.</p>
</td></tr>
<tr><td><code id="subsampleDb_+3A_group">group</code></td>
<td>
<p>columns containing additional grouping variables, e.g. sample_id.
These groups will be subsampled independently. If
<code>max_n</code> is <code>NULL</code>, a <code>max_n</code> will be 
automatically set for each <code>group</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> will be split into gene, allele or family subsets (<code>mode</code>) from
which the same number of sequences will be subsampled. If <code>mode=gene</code>,
for each gene in the field <code>gene</code> from <code>data</code>, a maximum of 
<code>max_n</code> sequences will be subsampled. Input sequences
that have multiple gene calls (ties), can be subsampled from any of their calls, 
but these duplicated samplings will be removed, and the final 
subsampled <code>data</code> will contain unique rows.
</p>


<h3>Value</h3>

<p>Subsampled version of the input <code>data</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+selectNovel">selectNovel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subsampleDb(AIRRDb)

</code></pre>

<hr>
<h2 id='tigger'>tigger</h2><span id='topic+tigger'></span>

<h3>Description</h3>

<p>Here we provide a <strong>T</strong>ool for <strong>I</strong>mmuno<strong>g</strong>lobulin
<strong>G</strong>enotype <strong>E</strong>lucidation via <strong>R</strong>ep-Seq (TIgGER). 
TIgGER inferrs the set of Ig alleles carried by an
individual (including any novel alleles) and then uses this set of alleles to
correct the initial assignments given to sample sequences by existing tools.
</p>


<h3>Details</h3>

<p>Immunoglobulin repertoire sequencing (AIRR-Seq, Rep-Seq) data is currently the
subject of much study. A key step in analyzing these data involves assigning
the closest known V(D)J germline alleles to the (often somatically mutated)
sample sequences using a tool such as IMGT/HighV-QUEST. However, if the
sample utilizes alleles not in the germline database used for alignment, this
step will fail. Additionally, this alignment has an associated error rate of
~5
mutations. The purpose of TIgGER is to address these issues.
</p>


<h3>Allele detection and genotyping</h3>


<ul>
<li>  <p><a href="#topic+findNovelAlleles">findNovelAlleles</a>:       Detect novel alleles.
</p>
</li>
<li>  <p><a href="#topic+plotNovel">plotNovel</a>:              Plot evidence of novel alleles.
</p>
</li>
<li>  <p><a href="#topic+inferGenotype">inferGenotype</a>:          Infer an Ig genotype using a frequency approach.
</p>
</li>
<li>  <p><a href="#topic+inferGenotypeBayesian">inferGenotypeBayesian</a>:  Infer an Ig genotype using a Bayesian approach.
</p>
</li>
<li>  <p><a href="#topic+plotGenotype">plotGenotype</a>:           A colorful genotype visualization.
</p>
</li>
<li>  <p><a href="#topic+genotypeFasta">genotypeFasta</a>:          Convert a genotype to sequences.
</p>
</li>
<li>  <p><a href="#topic+reassignAlleles">reassignAlleles</a>:        Correct allele calls.
</p>
</li>
<li>  <p><a href="#topic+generateEvidence">generateEvidence</a>:       Generate evidence for the genotype and 
allele detection inferrence.
</p>
</li></ul>



<h3>Mutation handling</h3>


<ul>
<li>  <p><a href="#topic+getMutatedPositions">getMutatedPositions</a>:      Find mutation locations.
</p>
</li>
<li>  <p><a href="#topic+getMutCount">getMutCount</a>:              Find distance from germline.
</p>
</li>
<li>  <p><a href="#topic+findUnmutatedCalls">findUnmutatedCalls</a>:       Subset unmutated sequences.
</p>
</li>
<li>  <p><a href="#topic+getPopularMutationCount">getPopularMutationCount</a>:  Find most common sequence's
mutation count.
</p>
</li>
<li>  <p><a href="#topic+insertPolymorphisms">insertPolymorphisms</a>:      Insert SNPs into a sequence.
</p>
</li></ul>



<h3>Input, output and formatting</h3>


<ul>
<li>  <p><a href="#topic+readIgFasta">readIgFasta</a>:        Read a fasta file of Ig sequences.
</p>
</li>
<li>  <p><a href="#topic+updateAlleleNames">updateAlleleNames</a>:  Correct outdated allele names.
</p>
</li>
<li>  <p><a href="#topic+sortAlleles">sortAlleles</a>:        Sort allele names intelligently.
</p>
</li>
<li>  <p><a href="#topic+cleanSeqs">cleanSeqs</a>:          Standardize sequence format.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Gadala-Maria, et al. (2015) Automated analysis of high-throughput B cell 
sequencing data reveals a high frequency of novel immunoglobulin V gene 
segment alleles. PNAS. 112(8):E862-70.
</p>
</li></ol>


<hr>
<h2 id='updateAlleleNames'>Update IGHV allele names</h2><span id='topic+updateAlleleNames'></span>

<h3>Description</h3>

<p><code>updateAlleleNames</code> takes a set of IGHV allele calls and replaces any
outdated names (e.g. IGHV1-f) with the new IMGT names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateAlleleNames(allele_calls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateAlleleNames_+3A_allele_calls">allele_calls</code></td>
<td>
<p>vector of strings respresenting IGHV allele names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of strings respresenting updated IGHV allele names.
</p>


<h3>Note</h3>

<p>IGMT has removed <code>IGHV2-5*10</code> and <code>IGHV2-5*07</code> as it has determined they
are actually alleles <code>02</code> and <code>04</code>, respectively. The updated allele 
names are based on IMGT release 2014-08-4.
</p>


<h3>References</h3>


<ol>
<li><p> Xochelli et al. (2014) Immunoglobulin heavy variable (IGHV) genes
and alleles: new entities, new names and implications for research and
prognostication in chronic lymphocytic leukaemia. Immunogenetics. 67(1):61-6
</p>
</li></ol>



<h3>See Also</h3>

<p>Like <code>updateAlleleNames</code>, <a href="#topic+sortAlleles">sortAlleles</a> can help
format a list of allele names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a vector that uses old gene/allele names.
alleles &lt;- c("IGHV1-c*01", "IGHV1-f*02", "IGHV2-5*07")

# Update the alleles to the new names
updateAlleleNames(alleles)

</code></pre>

<hr>
<h2 id='writeFasta'>Write to a fasta file</h2><span id='topic+writeFasta'></span>

<h3>Description</h3>

<p><code>writeFasta</code> writes a named vector of sequences to a file in fasta
format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFasta(named_sequences, file, width = 60, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFasta_+3A_named_sequences">named_sequences</code></td>
<td>
<p>vector of named string representing sequences</p>
</td></tr>
<tr><td><code id="writeFasta_+3A_file">file</code></td>
<td>
<p>the name of the output file.</p>
</td></tr>
<tr><td><code id="writeFasta_+3A_width">width</code></td>
<td>
<p>the number of characters to be printed per line.
if not between 1 and 255, width with be infinite.</p>
</td></tr>
<tr><td><code id="writeFasta_+3A_append">append</code></td>
<td>
<p><code>logical</code> indicating if the output should be
appended to <code>file</code> instead of overwriting it</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of strings respresenting Ig alleles.
</p>


<h3>See Also</h3>

<p><a href="#topic+readIgFasta">readIgFasta</a> to do the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# writeFasta(germlines, "ighv.fasta")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
