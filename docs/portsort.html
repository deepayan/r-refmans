<!DOCTYPE html><html lang="en"><head><title>Help for package portsort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {portsort}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conditional.sort'><p>Conditional Portfolio Sort</p></a></li>
<li><a href='#Factors'>
<p>Cryptocurrency Returns and Volume Data</p></a></li>
<li><a href='#portfolio.frequency'>
<p>Calculate Sub-Portfolio Concentration</p></a></li>
<li><a href='#portfolio.mean.size'>
<p>Calculate Mean Sub-Portfolio Size</p></a></li>
<li><a href='#portfolio.turnover'><p>Calculate Sub-Portfolio Turnover</p>
</p></a></li>
<li><a href='#unconditional.sort'><p>Unconditional Portfolio Sort</p>
</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Factor-Based Portfolio Sorts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Dickerson [aut,cre], Jonathan Spohnholtz [aut,cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Dickerson &lt;a.dickerson@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed to aid both academic researchers and asset managers in conducting factor based portfolio sorts.  
    Provides functionality to sort assets into portfolios for up to three factors via a conditional or unconditional sorting procedure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>xts, zoo, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PortfolioAnalytics, PerformanceAnalytics, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-24 08:27:39 UTC; Alexander</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-30 15:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='conditional.sort'>Conditional Portfolio Sort
</h2><span id='topic+conditional.sort'></span>

<h3>Description</h3>

<p>Calculates out-of-sample mean sub-portfolio returns and the composition of each sub-portfolio using the conditional portfolio sorting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional.sort(Fa,Fb=NULL,Fc=NULL,R.Forward,dimA,dimB=NULL,dimC=NULL,type = 7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional.sort_+3A_fa">Fa</code></td>
<td>
<p>xts-object containing data for the first dimension of sort
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_fb">Fb</code></td>
<td>
<p>xts-object containing data for the second dimension of sort (optional)
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_fc">Fc</code></td>
<td>
<p>xts-object containing data for the third dimension of sort (optional) 
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_r.forward">R.Forward</code></td>
<td>
<p>xts-object containing forward returns 
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_dima">dimA</code></td>
<td>
<p>vector of break points between 0 and 1  
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_dimb">dimB</code></td>
<td>
<p>vector of break points between 0 and 1 (optional)  
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_dimc">dimC</code></td>
<td>
<p>vector of break points between 0 and 1 (optional)
</p>
</td></tr>
<tr><td><code id="conditional.sort_+3A_type">type</code></td>
<td>
<p>pass-through parameter to the <code><a href="stats.html#topic+quantile">quantile</a></code> function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional sort function sorts assets based on each factor (Fa to Fc) from low to high in a dependent fashion at each time <em>t</em>.  Based on the sorted assets in each sub-portfolio at time <em>t</em>, mean out-of-sample sub-portfolio returns are computed for time <em>t+1</em>.  After each dimension of sort, the subsequent sort is done only within each prior sorted sub-portfolio.  Hence, the first factor that is sorted on yields greater influence on the overall sorting procedure.  The function outputs out-of-sample returns for each sub-portfolio in columns and a list of the sub-portfolio constituents at each rebalancing point.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>returns</code></td>
<td>
<p>Out-of-sample sub-portfolio returns</p>
</td></tr>
<tr><td><code>portfolio</code></td>
<td>
<p>List of the sub-portfolio constituents over time</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function implicitly handles NA/NaN or Inf values at each rebalancing point (at time <em>t</em>) by excluding them from the <code><a href="stats.html#topic+quantile">quantile</a></code> function.  Furthermore, if there are any NA, NaN or Inf values in the R.Forward object when computing out-of-sample returns, these are also excluded.  The function outputs returns in columns.  For example, if a double sort is conducted with both Fa and Fb including 3 breakpoints (a 3v3) sort, column 1 will contain out-of-sample returns for the 'Low-Low' sub-portfolio, column 4 will contain out-of-sample returns for the 'Mid-Low' sub-portfolio whilst column 9 will contain the 'High-High' sub-portfolio returns.      
</p>


<h3>Author(s)</h3>

<p>Jonathan Spohnholtz and Alexander Dickerson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the included data
library(portsort)
data(Factors)

# Specifiy the sort dimension - in this case, a double sort on lagged returns and Bitcoin volumes
# with 4 breakpoints (a 4v4 sort)
dimA = c(0,0.25,0.5,0.75,1)
dimB = c(0,0.25,0.5,0.75,1)

# Specify the factors for the double sort
# Lagged returns, lagged volumes are stored in the Factors list

R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]

# Subset the data from late 2017
R.Forward = R.Forward["2017-12-01/"]
R.Lag = R.Lag["2017-11-30/2018-09-05"]
V.Lag = V.Lag["2017-11-30/2018-09-05"]

Fa = R.Lag
Fb = V.Lag

# Conduct a conditional sort
sort.output &lt;- conditional.sort(Fa,Fb,Fc=NULL,R.Forward = R.Forward,dimA = dimA,dimB = dimB)

</code></pre>

<hr>
<h2 id='Factors'>
Cryptocurrency Returns and Volume Data
</h2><span id='topic+Factors'></span>

<h3>Description</h3>

<p>The data set includes lagged log returns, lagged volume denominated in Bitcoin and forward log returns aggregated every 24-hours for a  cross-section of 26 cryptocurrency pairs from the 1st January 2017 to 9th September 2018.  The data was downloaded from CryptoCompare - a free API accessible at <a href="https://min-api.cryptocompare.com">https://min-api.cryptocompare.com</a> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Factors")</code></pre>


<h3>Format</h3>

<p>A list of three xts objects including lagged returns (R.Lag), lagged volumes (V.Lag) and forward returns (R.Forward).</p>


<h3>Source</h3>

<p><a href="https://min-api.cryptocompare.com">https://min-api.cryptocompare.com</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(Factors)
# Unlist the data
R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]
head(V.Lag[1:5,1:5])
</code></pre>

<hr>
<h2 id='portfolio.frequency'>
Calculate Sub-Portfolio Concentration
</h2><span id='topic+portfolio.frequency'></span>

<h3>Description</h3>

<p>Computes the frequency that an asset appears in each sub-portfolio based on its rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.frequency(sort.output, rank)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.frequency_+3A_sort.output">sort.output</code></td>
<td>

<p>object returned from either the conditional.sort or unconditional.sort function. 
</p>
</td></tr>
<tr><td><code id="portfolio.frequency_+3A_rank">rank</code></td>
<td>

<p>input the rank of the security you would like to return the frequency for.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the frequency that the security appears in each sub-portfolio based on the rank input.
</p>


<h3>Author(s)</h3>

<p>Alexander Dickerson and Jonathan Spohnholtz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the included data
library(portsort)
data(Factors)

# Specifiy the sort dimension - in this case, a double-sort on lagged returns and Bitcoin volumes
dimA = 0:3/3
dimB = 0:3/3

# Specify the factors
# Lagged returns, lagged volumes are stored in the Factors list
R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]

# Subset the data from late 2017
R.Forward = R.Forward["2017-12-01/"]
R.Lag = R.Lag["2017-11-30/2018-09-05"]
V.Lag = V.Lag["2017-11-30/2018-09-05"]

Fa = R.Lag
Fb = V.Lag



# Conduct an unconditional sort (in this case) or a conditional sort
sort.output = unconditional.sort(Fa = Fa, Fb = Fb , R.Forward = R.Forward, dimA = dimA, dimB = dimB)

# We want to see which security appeared the most in each sub-portfolio, 
# i.e the secruity with a rank of 1.

rank = 1
portfolio.frequency(sort.output,rank)
</code></pre>

<hr>
<h2 id='portfolio.mean.size'>
Calculate Mean Sub-Portfolio Size
</h2><span id='topic+portfolio.mean.size'></span>

<h3>Description</h3>

<p>Primarily used in the case of an unconditional sort - this function computes the average number of securities in each sub-portfolio across time.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.mean.size(sort.output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.mean.size_+3A_sort.output">sort.output</code></td>
<td>

<p>object returned from either the conditional.sort or unconditional.sort function. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Dickerson and Jonathan Spohnholtz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the included data
library(portsort)
data(Factors)

# Specifiy the sort dimension - in this case, a double-sort on lagged returns and Bitcoin volumes
dimA = 0:3/3
dimB = 0:3/3

# Specify the factors
# Lagged returns, lagged volumes are stored in the Factors list
R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]

# Subset the data from late 2017
R.Forward = R.Forward["2017-12-01/"]
R.Lag = R.Lag["2017-11-30/2018-09-05"]
V.Lag = V.Lag["2017-11-30/2018-09-05"]

Fa = R.Lag
Fb = V.Lag

# Conduct an unconditional sort (in this case) or a conditional sort
sort.output = unconditional.sort(Fa = Fa, Fb = Fb , R.Forward = R.Forward, dimA = dimA, dimB = dimB)

# We want to compute the average size of each sub-portfolio

portfolio.mean.size(sort.output)
</code></pre>

<hr>
<h2 id='portfolio.turnover'>Calculate Sub-Portfolio Turnover
</h2><span id='topic+portfolio.turnover'></span>

<h3>Description</h3>

<p>Calculates sub-portfolio turnover between each rebalancing period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio.turnover(sort.output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="portfolio.turnover_+3A_sort.output">sort.output</code></td>
<td>

<p>object returned from either the conditional.sort or unconditional.sort function.   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the turnover within each sub-portfolio over time and returns a list containing the turnover values and the mean turnover across time.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Turnover</code></td>
<td>
<p>xts object of turnovers for each rebalancing point.</p>
</td></tr>
<tr><td><code>Mean Turnover</code></td>
<td>
<p>mean turnover for each sub-portfolio averaged over time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Spohnholtz and Alexander Dickerson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the included data
library(portsort)
data(Factors)

# Specifiy the sort dimension - in this case, a double-sort on lagged returns and Bitcoin volumes
dimA = 0:3/3
dimB = 0:3/3

# Specify the factors
# Lagged returns, lagged volumes are stored in the Factors list
R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]

# Subset the data from late 2017
R.Forward = R.Forward["2017-12-01/"]
R.Lag = R.Lag["2017-11-30/2018-09-05"]
V.Lag = V.Lag["2017-11-30/2018-09-05"]

Fa = R.Lag
Fb = V.Lag

# Conduct an unconditional sort (in this case) or a conditional sort
sort.output = unconditional.sort(Fa = Fa, Fb = Fb , R.Forward = R.Forward, dimA = dimA, dimB = dimB)

# Compute Turnover by passing the sort.output object to the turnover function
sort.turnover = portfolio.turnover(sort.output)

</code></pre>

<hr>
<h2 id='unconditional.sort'>Unconditional Portfolio Sort
</h2><span id='topic+unconditional.sort'></span>

<h3>Description</h3>

<p>Calculates out-of-sample mean sub-portfolio returns and the composition of each sub-portfolio using the unconditional portfolio sorting method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unconditional.sort(Fa,Fb=NULL,Fc=NULL,R.Forward,dimA,dimB=NULL,dimC=NULL,type = 7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unconditional.sort_+3A_fa">Fa</code></td>
<td>
<p>xts-object containing data for the first dimension of sort
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_fb">Fb</code></td>
<td>
<p>xts-object containing data for the second dimension of sort (optional)
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_fc">Fc</code></td>
<td>
<p>xts-object containing data for the third dimension of sort (optional) 
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_r.forward">R.Forward</code></td>
<td>
<p>xts-object containing forward returns 
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_dima">dimA</code></td>
<td>
<p>vector of break points between 0 and 1  
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_dimb">dimB</code></td>
<td>
<p>vector of break points between 0 and 1 (optional)  
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_dimc">dimC</code></td>
<td>
<p>vector of break points between 0 and 1 (optional)
</p>
</td></tr>
<tr><td><code id="unconditional.sort_+3A_type">type</code></td>
<td>
<p>pass-through parameter to the <code><a href="stats.html#topic+quantile">quantile</a></code> function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unconditional sort function sorts assets based on each factor (Fa to Fc) from low to high independently at each time <em>t</em> and forms sub-portfolios based on the intersection between them.  Based on the sorted assets in each sub-portfolio at time <em>t</em>, mean out-of-sample sub-portfolio returns are computed for time <em>t+1</em>.  The function outputs out-of-sample returns for each sub-portfolio in columns and a list of the sub-portfolio constituents at each rebalancing point.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>returns</code></td>
<td>
<p>Out-of-sample sub-portfolio returns</p>
</td></tr>
<tr><td><code>portfolio</code></td>
<td>
<p>List of the sub-portfolio constituents over time</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function implicitly handles NA/NaN or Inf values at each rebalancing point (at time <em>t</em>) by excluding them from the <code><a href="stats.html#topic+quantile">quantile</a></code> function.  Furthermore, if there are any NA, NaN or Inf values in the R.Forward object when computing out-of-sample returns, these are also excluded.  The function outputs returns in columns.  For example, if a double sort is conducted with both Fa and Fb including 3 breakpoints (a 3v3) sort, column 1 will contain out-of-sample returns for the 'Low-Low' sub-portfolio, column 4 will contain out-of-sample returns for the 'Mid-Low' sub-portfolio whilst column 9 will contain the 'High-High' sub-portfolio returns.      
</p>


<h3>Author(s)</h3>

<p>Jonathan Spohnholtz and Alexander Dickerson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the included data
library(portsort)
data(Factors)

# Specifiy the sort dimension - in this case, a double sort on lagged returns and Bitcoin volumes
# with 4 breakpoints (a 4v4 sort)
dimA = c(0,0.25,0.5,0.75,1)
dimB = c(0,0.25,0.5,0.75,1)

# Specify the factors for the double sort
# Lagged returns, lagged volumes are stored in the Factors list

R.Forward = Factors[[1]]; R.Lag = Factors[[2]]; V.Lag = Factors[[3]]

# Subset the data from late 2017
R.Forward = R.Forward["2017-12-01/"]
R.Lag = R.Lag["2017-11-30/2018-09-05"]
V.Lag = V.Lag["2017-11-30/2018-09-05"]

Fa = R.Lag
Fb = V.Lag

# Conduct an unconditional sort
sort.output &lt;- conditional.sort(Fa,Fb,Fc=NULL,R.Forward = R.Forward,dimA = dimA,dimB = dimB)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
