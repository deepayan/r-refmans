<!DOCTYPE html><html lang="en-US"><head><title>Help for package qgcompint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qgcompint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getjointeffects'><p>Calculate joint effect of mixture effect and modifier vs. common referent</p></a></li>
<li><a href='#getstrateffects'><p>Calculate mixture effect at a set value of effect measure modifier</p></a></li>
<li><a href='#getstratweights'><p>Calculate weights at a set value of effect measure modifier</p></a></li>
<li><a href='#modelbound'><p>Estimating qgcomp regression line confidence bounds</p></a></li>
<li><a href='#plot.qgcompemmfit'><p>Default plotting method for a qgcompemmfit object</p></a></li>
<li><a href='#pointwisebound'><p>Estimating pointwise comparisons for qgcompemmfit objects</p></a></li>
<li><a href='#print.qgcompemmfit'><p>Default printing method for a qgcompemmfit object</p></a></li>
<li><a href='#qgcomp.emm.cox.noboot'><p>EMM for Quantile g-computation with survival outcomes under linearity/additivity</p></a></li>
<li><a href='#qgcomp.emm.glm.boot'><p>EMM for Quantile g-computation for continuous, binary, and count outcomes under non-linearity/non-additivity or clustered data</p></a></li>
<li><a href='#qgcomp.emm.glm.ee'><p>EMM for Quantile g-computation for continuous, binary, and count outcomes under linearity/additivity</p></a></li>
<li><a href='#qgcomp.emm.glm.noboot'><p>EMM for Quantile g-computation for continuous, binary, and count outcomes under linearity/additivity</p></a></li>
<li><a href='#simdata_quantized_emm'><p>Simulate quantized exposures for testing methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Quantile G-Computation Extensions for Effect Measure
Modification</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Keil [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Keil &lt;alex.keil@nih.gov&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexpkeil1/qgcompint/">https://github.com/alexpkeil1/qgcompint/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexpkeil1/qgcompint/issues">https://github.com/alexpkeil1/qgcompint/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>G-computation for a set of time-fixed exposures
    with quantile-based basis functions, possibly under linearity and
    homogeneity assumptions. Effect measure modification in this method is a way
    to assess how the effect of the mixture varies by a binary, categorical or continuous variable.  
    Reference: Alexander P. Keil, Jessie P.
    Buckley, Katie M. OBrien, Kelly K. Ferguson, Shanshan Zhao, and
    Alexandra J. White (2019) A quantile-based g-computation approach to
    addressing the effects of exposure mixtures; &lt;<a href="https://doi.org/10.1289%2FEHP5838">doi:10.1289/EHP5838</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>qgcomp, arm, survival, future, future.apply, ggplot2,
gridExtra, rootSolve, numDeriv, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, devtools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-12 15:59:37 UTC; keilap</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-12 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='getjointeffects'>Calculate joint effect of mixture effect and modifier vs. common referent</h2><span id='topic+getjointeffects'></span>

<h3>Description</h3>

<p>A standard qgcomp fit with effect measure modification
only estimates effects at the referent (0) level of the modifier (psi1).
This function can be used to estimate a &quot;common referent&quot; parameter that
estimates the effect of being in a non-referent category of the modifier and
increasing exposure by one quantile, relative to no change in exposure in the
referent category of the modifier. This is generally useful for binary exposures
(for a mixture with a set of binary exposures,
this would be the &quot;effect&quot; of being exposed and at the index level of the mediator,
relative to being unexposed in the referent level of the mediator), but it may also
be of interest with more general exposures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getjointeffects(x, emmval = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getjointeffects_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from qgcomp.emm.glm.noboot
function</p>
</td></tr>
<tr><td><code id="getjointeffects_+3A_emmval">emmval</code></td>
<td>
<p>numerical: value of effect measure modifier at which weights are generated</p>
</td></tr>
<tr><td><code id="getjointeffects_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;qgcompemmeffects&quot;, which inherits from &quot;qgcompemmfit&quot; and &quot;list&quot;
</p>
<p>This class contains the <code>emmval</code>-stratum specific effect estimates of the mixture. By default, this prints a coefficient table, similar to objects of type &quot;qgcompemmfit&quot; which displays the stratum specific joint effects from a &quot;qgcompemmfit&quot; model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code> <code><a href="#topic+getstrateffects">getstrateffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qgcompint)
n = 500
dat &lt;- data.frame(y=rbinom(n, 1, 0.5), cd=runif(n), pb=runif(n),
                  raceth=factor(sample(c("WNH", "BNH", "AMIND"), n, replace=TRUE),
                          levels = c("BNH", "WNH", "AMIND")))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~cd + pb, emmvar="raceth",
                           expnms = c('cd', 'pb'), data=dat, q=4,
                           family=binomial()))


# first level of the stratifying variable should be the referent category,
#  which you can set with the "levels" argument to "factor" when
#  cleaning/generating data
levels(dat$raceth)

# stratum specific mixture log-odds ratios
# this one comes straight from the model (psi 1)
getjointeffects(qfit, emmval = "BNH")
# this will coincide with joint effects, since it is in the referent category
getstrateffects(qfit, emmval = "BNH")

# the stratum specific effect for a non-referent category of the EMM
#  will not coincide with the joint effect
getjointeffects(qfit, emmval = "AMIND")
getstrateffects(qfit, emmval = "AMIND")

</code></pre>

<hr>
<h2 id='getstrateffects'>Calculate mixture effect at a set value of effect measure modifier</h2><span id='topic+getstrateffects'></span>

<h3>Description</h3>

<p>A standard qgcomp fit with effect measure modification
only estimates effects at the referent (0) level of the modifier (psi1).
This function can be used to estimate effects at arbitrary levels of the modifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getstrateffects(x, emmval = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getstrateffects_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from qgcomp.emm.glm.noboot
function</p>
</td></tr>
<tr><td><code id="getstrateffects_+3A_emmval">emmval</code></td>
<td>
<p>numerical: value of effect measure modifier at which weights are generated</p>
</td></tr>
<tr><td><code id="getstrateffects_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;qgcompemmeffects&quot;, which inherits from &quot;qgcompemmfit&quot; and &quot;list&quot;
</p>
<p>This class contains the <code>emmval</code>-stratum specific effect estimates of the mixture. By default, this prints a coefficient table, similar to objects of type &quot;qgcompemmfit&quot; which displays the stratum specific joint effects from a &quot;qgcompemmfit&quot; model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code> <code><a href="#topic+getstratweights">getstratweights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
getstrateffects(qfit, emmval = 0)
strateffects = getstrateffects(qfit, emmval = 1)

</code></pre>

<hr>
<h2 id='getstratweights'>Calculate weights at a set value of effect measure modifier</h2><span id='topic+getstratweights'></span>

<h3>Description</h3>

<p>A standard qgcomp fit with effect measure modification
only estimates weights at the referent (0) level of the modifier.
This function can be used to estimate weights at arbitrary levels of the modifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getstratweights(x, emmval = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getstratweights_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from qgcomp.emm.glm.noboot
function</p>
</td></tr>
<tr><td><code id="getstratweights_+3A_emmval">emmval</code></td>
<td>
<p>numerical: value of effect measure modifier at which weights are generated</p>
</td></tr>
<tr><td><code id="getstratweights_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;qgcompemmweights&quot;, which is just a special R list
</p>
<p>This class contains the <code>emmval</code>-stratum specific weights of components of the mixture. By default, this prints a list of &quot;weights&quot;, similar to objects of type &quot;qgcompemmfit&quot; which displays the stratum specific weights from a &quot;qgcompemmfit&quot; model (if it is run without bootstrapping).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1231)
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
getstratweights(qfit, emmval = 0)
weights1 = getstratweights(qfit, emmval = 1)
weights1$pos.weights
</code></pre>

<hr>
<h2 id='modelbound'>Estimating qgcomp regression line confidence bounds</h2><span id='topic+modelbound'></span>

<h3>Description</h3>

<p>Calculates: expected outcome (on the link scale), and upper and lower
confidence intervals (both pointwise and simultaneous)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelbound(x, emmval = NULL, alpha = 0.05, pwonly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelbound_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from <code>qgcomp.emm.glm.boot</code> or <code>qgcomp.emm.glm.ee</code>,</p>
</td></tr>
<tr><td><code id="modelbound_+3A_emmval">emmval</code></td>
<td>
<p>fixed value for effect measure modifier at which pointwise comparisons are calculated</p>
</td></tr>
<tr><td><code id="modelbound_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals</p>
</td></tr>
<tr><td><code id="modelbound_+3A_pwonly">pwonly</code></td>
<td>
<p>logical: return only pointwise estimates (suppress simultaneous estimates)</p>
</td></tr>
<tr><td><code id="modelbound_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method leverages the distribution of qgcomp model coefficients
to estimate pointwise regression line confidence bounds. These are defined as the bounds
that, for each value of the independent variable X (here, X is the joint exposure quantiles)
the 95% bounds (for example) for the model estimate of the regression line E(Y|X) are expected to include the
true value of E(Y|X) in 95% of studies. The &quot;simultaneous&quot; bounds are also calculated, and the 95%
simultaneous bounds contain the true value of E(Y|X) for all values of X in 95% of studies. The
latter are more conservative and account for the multiple testing implied by the former. Pointwise
bounds are calculated via the standard error for the estimates of E(Y|X), while the simultaneous
bounds are estimated using the method of Cheng (reference below). All bounds are large
sample bounds that assume normality and thus will be underconservative in small samples. These
bounds may also include illogical values (e.g. values less than 0 for a dichotomous outcome) and
should be interpreted cautiously in small samples.
</p>
<p>Following Cheng, this approach is possible on bootstrap fitted models (aside from Cox models).
For estimating equation approaches, a normality assumption is used to draw values from the sampling
distribution of the model parameters based on the covariance matrix of the parameters of the
marginal structural model. Because those parameters are not separately estimated for the <code>noboot</code>
approaches, this method is not available for <code>noboot</code> methods.
</p>
<p>Reference:
</p>
<p>Cheng, Russell CH. &quot;Bootstrapping simultaneous confidence bands.&quot;
Proceedings of the Winter Simulation Conference, 2005.. IEEE, 2005.
</p>


<h3>Value</h3>

<p>A data frame containing
</p>

<dl>
<dt>linpred: </dt><dd><p>The linear predictor from the marginal structural model</p>
</dd>
<dt>r/o/m: </dt><dd><p>The canonical measure (risk/odds/mean) for the marginal structural model link</p>
</dd>
<dt>se....: </dt><dd><p>the stndard error of linpred</p>
</dd>
<dt>ul..../ll....: </dt><dd><p>Confidence bounds for the effect measure, and bounds centered at the canonical measure (for plotting purposes)</p>
</dd>
</dl>

<p>The confidence bounds are either  &quot;pointwise&quot; (pw) and &quot;simultaneous&quot; (simul) confidence
intervals at each each quantized value of all exposures.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.boot">qgcomp.emm.glm.boot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(50)
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
                  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
                           expnms = c('x1', 'x2'), data=dat, q=4, family=gaussian()))
(qfit2 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1,
                          expnms = c('x1', 'x2'), data=dat, q=4, family=gaussian()))
# modelbound(qfit) # this will error (only works with bootstrapped objects)
 modelbound(qfit2)
# logistic model
set.seed(200)
dat2 &lt;- data.frame(y=rbinom(200, 1, 0.3), x1=runif(200), x2=runif(200),
                  z=rbinom(200, 1, 0.5))
(qfit3 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1,
                          expnms = c('x1', 'x2'), data=dat2, q=4, rr = FALSE, family=binomial()))
modelbound(qfit3)
# risk ratios instead (check for upper bound &gt; 1.0, indicating implausible risk)
(qfit3b &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1,
                          expnms = c('x1', 'x2'), data=dat2, q=4, rr = TRUE, family=binomial()))
modelbound(qfit3b)
# categorical modifier
set.seed(50)
dat3 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
   z=sample(0:2, 50, replace=TRUE), r=rbinom(50, 1, 0.5))
dat3$z = as.factor(dat3$z)
(qfit4 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1,
                          expnms = c('x1', 'x2'), data=dat3, q=4, family=gaussian()))
modelbound(qfit4, emmval=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.qgcompemmfit'>Default plotting method for a qgcompemmfit object</h2><span id='topic+plot.qgcompemmfit'></span>

<h3>Description</h3>

<p>Plot a quantile g-computation object from qgcompint.
For qgcomp.emm.glm.noboot, this function will create a butterfly plot of
weights. For qgcomp.emm.glm.boot and qgcomp.emm.glm.ee, this function will create
a box plot with smoothed line overlaying that represents a non-parametric
fit of a model to the expected outcomes in the population at each quantile
of the joint exposures (e.g. '0' represents 'at the lowest quantile for
every exposure')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgcompemmfit'
plot(
  x,
  emmval = NULL,
  suppressprint = FALSE,
  geom_only = FALSE,
  modelband = FALSE,
  flexfit = FALSE,
  modelfitline = FALSE,
  pointwisebars = TRUE,
  pointwiseref = 1,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.qgcompemmfit_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from <code>qgcomp.emm.glm.noboot</code>, <code>qgcomp.emm.glm.boot</code>,
<code>qgcomp.emm.glm.ee</code>, or <code>qgcomp.emm.cox.noboot</code> functions</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_emmval">emmval</code></td>
<td>
<p>fixed value for effect measure modifier at which pointwise comparisons are calculated</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_suppressprint">suppressprint</code></td>
<td>
<p>If TRUE, suppresses the plot, rather than printing it
by default (it can be saved as a ggplot2 object (or list of ggplot2 objects if x is from a zero-
inflated model) and used programmatically)</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_geom_only">geom_only</code></td>
<td>
<p>If TRUE, returns only the geometry (i.e. does not contain the entire plot object). Used for overlays. Only used for <code>.ee</code> and <code>.boot</code> methods.
(default = FALSE)</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_modelband">modelband</code></td>
<td>
<p>(boot/ee only) If TRUE (FALSE=default), adds 95% prediction bands for E(Y|joint exposure) (the MSM fit)</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_flexfit">flexfit</code></td>
<td>
<p>(boot/ee only) if TRUE (FALSE=default), adds flexible interpolation of predictions from underlying (conditional) model</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_modelfitline">modelfitline</code></td>
<td>
<p>(boot/ee only) If TRUE (FALSE=default), adds fitted (MSM) regression line of E(Y|joint exposure) to the smooth regression line plot</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_pointwisebars">pointwisebars</code></td>
<td>
<p>(boot/ee only) If TRUE (TRUE=default), adds 95% error bars for pointwise comparisons of E(Y|joint exposure) to the smooth regression line plot</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_pointwiseref">pointwiseref</code></td>
<td>
<p>(boot/ee only) integer (0=default): which category of exposure (from 1 to q) should serve as the referent category for pointwise comparisons? (default=1)</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for all confidence intervals</p>
</td></tr>
<tr><td><code id="plot.qgcompemmfit_+3A_...">...</code></td>
<td>
<p>Arguments (listed under &ldquo;details&rdquo; ) to underlying functions:</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>...</code> argument calls underlying plot functions, with arguments given here (similar to the plot function in the <code>qgcomp</code> package)
</p>


<h3>Value</h3>

<p>If suppressprint=FALSE, then this function prints a plot specific to a &quot;qgcompemmfit&quot; object.
If no bootstrapping is used, it will print a butterfly plot of the weights at the specified value of the modifier (set via <code>emmval</code> parameter)
If bootstrapping is used, it will print a joint regression line for all exposures at the specified value of the modifier (set via <code>emmval</code> parameter)
</p>
<p>If suppressprint=TRUE, then this function returns a &quot;gg&quot; (regression line) or &quot;gtable&quot; (butterfly plot) object (from ggplot2 package or gtable/grid packages), which can be used to print a ggplot figure and modify either of the above figures (see example below)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code>, <code><a href="#topic+qgcomp.emm.glm.boot">qgcomp.emm.glm.boot</a></code>,  <code><a href="#topic+qgcomp.emm.glm.ee">qgcomp.emm.glm.ee</a></code>, <code><a href="#topic+qgcomp.emm.cox.noboot">qgcomp.emm.cox.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
# linear model, binary modifier
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
plot(qfit, emmval = 1)
#
library(ggplot2)

# example with estimating equation approach
dat2 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
z=sample(0:2, 50, replace=TRUE), r=rbinom(50, 1, 0.5))
dat2$z = as.factor(dat2$z)
(qfit4ee &lt;- qgcomp.emm.glm.ee(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1,
                         expnms = c('x1', 'x2'), data=dat2, q=4, family=gaussian()))
pp0ee = plot(qfit4ee, emmval=0, suppressprint=TRUE)
pp1ee = plot(qfit4ee, emmval=1, suppressprint=TRUE)
pp2ee = plot(qfit4ee, emmval=2, suppressprint=TRUE)
pp1ee + theme_linedraw() # can use with other ggplot functions
# example with bootstrapping
dat2 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
z=sample(0:2, 50, replace=TRUE), r=rbinom(50, 1, 0.5))
dat2$z = as.factor(dat2$z)
(qfit4 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
                          degree = 1, B = 20,
                         expnms = c('x1', 'x2'), data=dat2, q=4, family=gaussian()))
pp0 = plot(qfit4, emmval=0, suppressprint=TRUE)
pp1 = plot(qfit4, emmval=1, suppressprint=TRUE)
pp2 = plot(qfit4, emmval=2, suppressprint=TRUE)
pp1 + theme_linedraw() # can use with other ggplot functions

# overlay (fussy to work with)
#ppom &lt;- ggplot_build(pp0 + pp1[2] + pp2[[2]] + scale_color_discrete(guide="none"))
ppom &lt;- ggplot_build(pp0ee + pp1ee[2] + pp2ee[[2]] + scale_color_discrete(guide="none"))
ppom$data[[1]]$colour &lt;- ppom$data[[2]]$colour &lt;- "gray40" # emmval = 0 -&gt; dark gray
ppom$data[[3]]$colour &lt;- ppom$data[[4]]$colour &lt;- "gray80" # emmval = 1 -&gt; light gray
ppom$data[[5]]$colour &lt;- ppom$data[[6]]$colour &lt;- "black" # emmval = 2 -&gt; black
xincrement = 0.025
ppom$data[[1]]$x &lt;- ppom$data[[2]]$x &lt;- ppom$data[[1]]$x - xincrement
ppom$data[[2]]$xmin &lt;- ppom$data[[2]]$xmin - xincrement
ppom$data[[2]]$xmax &lt;- ppom$data[[2]]$xmax - xincrement
ppom$data[[5]]$x &lt;- ppom$data[[6]]$x &lt;- ppom$data[[5]]$x + xincrement
ppom$data[[6]]$xmin &lt;- ppom$data[[6]]$xmin + xincrement
ppom$data[[6]]$xmax &lt;- ppom$data[[6]]$xmax + xincrement
plot(ggplot_gtable(ppom))

## Not run: 
library(gtable) # may need to separately install gtable
# example with no bootstrapping, adding object from bootstrapped fit
pp2 &lt;- plot(qfit, emmval = 1, suppressprint=TRUE)
grid.draw(pp2)
# insert row on top that is 1/2 height of existing plot
pp2b = gtable::gtable_add_rows(pp2, heights=unit(0.5, 'null') , pos = 0)
# add plot to that row
pp3 = gtable::gtable_add_grob(pp2b, ggplot2::ggplotGrob(pp), t=1, l=1, r=2)
grid.draw(pp3)

## End(Not run)
</code></pre>

<hr>
<h2 id='pointwisebound'>Estimating pointwise comparisons for qgcompemmfit objects</h2><span id='topic+pointwisebound'></span>

<h3>Description</h3>

<p>Calculates: expected outcome (on the link scale), mean difference (link scale) and the standard error of the mean difference (link scale) for pointwise comparisons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointwisebound(x, alpha = 0.05, pointwiseref = 1, emmval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointwisebound_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from <code>qgcomp.emm.glm.boot</code> or <code>qgcomp.emm.glm.ee</code></p>
</td></tr>
<tr><td><code id="pointwisebound_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence intervals</p>
</td></tr>
<tr><td><code id="pointwisebound_+3A_pointwiseref">pointwiseref</code></td>
<td>
<p>referent quantile (e.g. 1 uses the lowest joint-exposure category as the referent category for calculating all mean differences/standard deviations)</p>
</td></tr>
<tr><td><code id="pointwisebound_+3A_emmval">emmval</code></td>
<td>
<p>fixed value for effect measure modifier at which pointwise comparisons are calculated</p>
</td></tr>
<tr><td><code id="pointwisebound_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The comparison of interest following a qgcomp fit is often comparisons of model predictions at various values of the joint-exposures (e.g. expected outcome at all exposures at the 1st quartile vs. the 3rd quartile). The expected outcome at a given joint exposure and at a given level of non-exposure covariates (W) is given as E(Y|S, W=w), where S takes on integer values 0 to q-1. Thus, comparisons are of the type E(Y|S=s, W=w) - E(Y|S=s2, W=w) where s and s2 are two different values of the joint exposures (e.g. 0 and 2). This function yields E(Y|S, W=w) as well as E(Y|S=s, W=w) - E(Y|S=p, W=w) where s is any value of S and p is the value chosen via &quot;pointwise ref&quot; - e.g. for binomial variables this will equal the risk/ prevalence difference at all values of S, with the referent category S=p-1. For the non-boostrapped version of quantile g-computation (under a linear model)
Note that function only works with standard &quot;qgcompint&quot; objects from qgcomp.emm.glm.noboot (so it doesn't work with zero inflated, hurdle, or Cox models)
Variance for the overall effect estimate is given by: <code class="reqn">transpose(G) Cov(\beta) G</code>
Where the &quot;gradient vector&quot; G is given by
</p>
<p style="text-align: center;"><code class="reqn">G = [\partial(f(\beta))/\partial\beta_1 = 1, ..., \partial(f(\beta))/\partial\beta_3= 1]</code>
</p>

<p><code class="reqn">f(\beta) = \sum_i^p \beta_i, and \partial y/ \partial x</code> denotes the partial derivative/gradient. The vector G takes on values that equal the difference in quantiles of S for each pointwise comparison (e.g. for a comparison of the 3rd vs the 5th category, G is a vector of 2s)
This variance is used to create pointwise confidence intervals via a normal approximation: (e.g. upper 95% CI = psi + variance*1.96)
</p>


<h3>Value</h3>

<p>A data frame containing
</p>

<dl>
<dt>hx: </dt><dd><p>The &quot;partial&quot; linear predictor <code class="reqn">\beta_0 + \psi\sum_j X_j^q w_j</code>, or the effect of the mixture + intercept after
conditioning out any confounders. This is similar to the h(x) function in bkmr. This is not a full prediction of the outcome, but
only the partial outcome due to the intercept and the confounders</p>
</dd>
<dt>rr/or/mean.diff: </dt><dd><p>The canonical effect measure (risk ratio/odds ratio/mean difference) for the marginal structural model link</p>
</dd>
<dt>se....: </dt><dd><p>the stndard error of the effect measure</p>
</dd>
<dt>ul..../ll....: </dt><dd><p>Confidence bounds for the effect measure</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code>, <code><a href="qgcomp.html#topic+pointwisebound.noboot">pointwisebound.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
# linear model, binary modifier
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=4, family=gaussian()))
pointwisebound(qfit, pointwiseref = 2, emmval = 0.1)
# linear model, categorical modifier
dat3 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
z=as.factor(sample(0:2, 50, replace=TRUE)), r=rbinom(50, 1, 0.5))
(qfit3 &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
expnms = c('x1', 'x2'), data=dat3, q=5, family=gaussian()))
pointwisebound(qfit3, pointwiseref = 2, emmval = 0)
pointwisebound(qfit3, pointwiseref = 2, emmval = 1)
pointwisebound(qfit3, pointwiseref = 2, emmval = 2)
# linear model, categorical modifier, bootstrapped
# set B larger for real examples
(qfit3b &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
expnms = c('x1', 'x2'), data=dat3, q=5, family=gaussian(), B=10))
pointwisebound(qfit3b, pointwiseref = 2, emmval = 0)
pointwisebound(qfit3b, pointwiseref = 2, emmval = 1)
pointwisebound(qfit3b, pointwiseref = 2, emmval = 2)
# linear model, categorical modifier, estimating equation
(qfit3c &lt;- qgcomp.emm.glm.ee(f=y ~ z + x1 + x2, emmvar="z",
expnms = c('x1', 'x2'), data=dat3, q=5, family=gaussian()))
pointwisebound(qfit3c, pointwiseref = 2, emmval = 0)
pointwisebound(qfit3c, pointwiseref = 2, emmval = 1)
pointwisebound(qfit3c, pointwiseref = 2, emmval = 2)
# logistic model, binary modifier
dat4 &lt;- data.frame(y=rbinom(50, 1, 0.3), x1=runif(50), x2=runif(50),
  z=as.factor(sample(0:1, 50, replace=TRUE)), r=rbinom(50, 1, 0.5))
(qfit4 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
expnms = c('x1', 'x2'), data=dat4, q=5, family=binomial(), B=10))
pointwisebound(qfit4, pointwiseref = 2, emmval = 0) # reverts to odds ratio

</code></pre>

<hr>
<h2 id='print.qgcompemmfit'>Default printing method for a qgcompemmfit object</h2><span id='topic+print.qgcompemmfit'></span>

<h3>Description</h3>

<p>Prints output depending the model used. <code>qgcomp.emm.glm.noboot</code> and <code>qgcomp.emm.cox.noboot</code> will output final estimate of joint exposure
effect, as well
as estimates of the 'weights' (scaled coefficients). <code>qgcomp.emm.glm.boot</code> and <code>qgcomp.emm.glm.ee</code> methods will only output final effect estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qgcompemmfit'
print(x, showweights = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.qgcompemmfit_+3A_x">x</code></td>
<td>
<p>&quot;qgcompemmfit&quot; object from <code>qgcomp.emm.glm.noboot</code>
function</p>
</td></tr>
<tr><td><code id="print.qgcompemmfit_+3A_showweights">showweights</code></td>
<td>
<p>logical: should weights be printed, if estimated?</p>
</td></tr>
<tr><td><code id="print.qgcompemmfit_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns x. Called primarily for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qgcomp.emm.glm.noboot">qgcomp.emm.glm.noboot</a></code>, <code><a href="#topic+getstratweights">getstratweights</a></code>
</p>

<hr>
<h2 id='qgcomp.emm.cox.noboot'>EMM for Quantile g-computation with survival outcomes under linearity/additivity</h2><span id='topic+qgcomp.emm.cox.noboot'></span>

<h3>Description</h3>

<p>This function performs quantile g-computation in a survival
setting, , allowing
effect measure modification by a binary, categorical or continuous covariate. This allows
testing of statistical interaction as well as estimation of stratum specific effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgcomp.emm.cox.noboot(
  f,
  data,
  expnms = NULL,
  emmvar = NULL,
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  cluster = NULL,
  alpha = 0.05,
  errcheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_f">f</code></td>
<td>
<p>R style survival formula, which includes <code><a href="survival.html#topic+Surv">Surv</a></code>
in the outcome definition. E.g. <code>Surv(time, event) ~ exposure</code>. Offset
terms can be included via <code>Surv(time, event) ~ exposure + offset(z)</code></p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_expnms">expnms</code></td>
<td>
<p>character vector of exposures of interest</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_emmvar">emmvar</code></td>
<td>
<p>(character) name of effect measure modifier in dataset (if categorical, must be coded as a factor variable)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_q">q</code></td>
<td>
<p>NULL or number of quantiles used to create quantile indicator variables
representing the exposure variables. If NULL, then gcomp proceeds with un-transformed
version of exposures in the input datasets (useful if data are already transformed,
or for performing standard g-computation)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_breaks">breaks</code></td>
<td>
<p>(optional) NULL, or a list of (equal length) numeric vectors that
characterize the minimum value of each category for which to
break up the variables named in expnms. This is an alternative to using 'q'
to define cutpoints.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_id">id</code></td>
<td>
<p>(optional) NULL, or variable name indexing individual units of
observation (only needed if analyzing data with multiple observations per
id/cluster)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_weights">weights</code></td>
<td>
<p>&quot;case weights&quot; - passed to the &quot;weight&quot; argument of
<code><a href="survival.html#topic+coxph">coxph</a></code></p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_cluster">cluster</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence limit calculation</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_errcheck">errcheck</code></td>
<td>
<p>(logical, default=TRUE) include some basic error checking. Slightly
faster if set to false (but be sure you understand risks)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.cox.noboot_+3A_...">...</code></td>
<td>
<p>arguments to glm (e.g. family)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a qgcompfit object, which contains information about the effect
measure of interest (psi) and associated variance (var.psi), as well
as information on the model fit (fit) and information on the
weights/standardized coefficients in the positive (pos.weights) and
negative (neg.weights) directions.
</p>


<h3>See Also</h3>

<p><code><a href="qgcomp.html#topic+qgcomp.cox.noboot">qgcomp.cox.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
N=200
dat &lt;- data.frame(time=(tmg &lt;- pmin(.1, rweibull(N, 10, 0.1))),
                d=1.0*(tmg&lt;0.1), x1=runif(N), x2=runif(N), z=runif(N))
expnms=paste0("x", 1:2)
f = survival::Surv(time, d)~x1 + x2+z
(fit1 &lt;- survival::coxph(f, data = dat))
(obj &lt;- qgcomp.emm.cox.noboot(f, expnms = expnms, emmvar="z", data = dat))

#categorical emm
dat &lt;- data.frame(time=(tmg &lt;- pmin(.1, rweibull(N, 10, 0.1))),
                d=1.0*(tmg&lt;0.1), x1=runif(N), x2=runif(N),
                z=sample(0:2, N, replace=TRUE))
 dat$z = as.factor(dat$z)
expnms=paste0("x", 1:2)
f = survival::Surv(time, d)~x1 + x2+z
(obj2 &lt;- qgcomp.emm.cox.noboot(f, expnms = expnms, emmvar="z", data = dat))

</code></pre>

<hr>
<h2 id='qgcomp.emm.glm.boot'>EMM for Quantile g-computation for continuous, binary, and count outcomes under non-linearity/non-additivity or clustered data</h2><span id='topic+qgcomp.emm.glm.boot'></span><span id='topic+qgcomp.emm.boot'></span>

<h3>Description</h3>

<p>This function fits a quantile g-computation model, allowing
effect measure modification by a binary or continuous covariate. This allows
testing of statistical interaction as well as estimation of stratum specific effects.
This particular implementation formally fits a marginal structural model using
a Monte Carlo-based g-computation method, utilizing bootstrapping for variance
estimates. Because this approach allows for non-linear/non-additive effects of
exposures, it does not report weights nor EMM stratum specific effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgcomp.emm.glm.boot(
  f,
  data,
  expnms = NULL,
  emmvar = "",
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  alpha = 0.05,
  B = 200,
  rr = TRUE,
  degree = 1,
  seed = NULL,
  bayes = FALSE,
  MCsize = nrow(data),
  parallel = FALSE,
  parplan = FALSE,
  errcheck = FALSE,
  ...
)

qgcomp.emm.boot(
  f,
  data,
  expnms = NULL,
  emmvar = "",
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  alpha = 0.05,
  B = 200,
  rr = TRUE,
  degree = 1,
  seed = NULL,
  bayes = FALSE,
  MCsize = nrow(data),
  parallel = FALSE,
  parplan = FALSE,
  errcheck = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgcomp.emm.glm.boot_+3A_f">f</code></td>
<td>
<p>R style formula</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_expnms">expnms</code></td>
<td>
<p>character vector of exposures of interest</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_emmvar">emmvar</code></td>
<td>
<p>(character) name of effect measure modifier in dataset (if categorical, must be coded as a factor variable)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_q">q</code></td>
<td>
<p>NULL or number of quantiles used to create quantile indicator variables
representing the exposure variables. If NULL, then gcomp proceeds with un-transformed
version of exposures in the input datasets (useful if data are already transformed,
or for performing standard g-computation)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_breaks">breaks</code></td>
<td>
<p>(optional) NULL, or a list of (equal length) numeric vectors that
characterize the minimum value of each category for which to
break up the variables named in expnms. This is an alternative to using 'q'
to define cutpoints.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_id">id</code></td>
<td>
<p>(optional) NULL, or variable name indexing individual units of
observation (only needed if analyzing data with multiple observations per
id/cluster). Note that qgcomp.emm.glm.noboot will not produce cluster-appropriate
standard errors (this parameter is essentially ignored in qgcomp.emm.glm.noboot).
qgcomp.emm.glm.boot can be used for this, which will use bootstrap
sampling of clusters/individuals to estimate cluster-appropriate standard
errors via bootstrapping.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_weights">weights</code></td>
<td>
<p>&quot;case weights&quot; - passed to the &quot;weight&quot; argument of
<code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="arm.html#topic+bayesglm">bayesglm</a></code></p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence limit calculation</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_b">B</code></td>
<td>
<p>integer: number of bootstrap iterations (this should typically be &gt;=200,
though it is set lower in examples to improve run-time).</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_rr">rr</code></td>
<td>
<p>logical: if using binary outcome and rr=TRUE, qgcomp.boot will
estimate risk ratio rather than odds ratio</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_degree">degree</code></td>
<td>
<p>polynomial bases for marginal model (e.g. degree = 2
allows that the relationship between the whole exposure mixture and the outcome
is quadratic (default = 1).</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_seed">seed</code></td>
<td>
<p>integer or NULL: random number seed for replicable bootstrap results</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_bayes">bayes</code></td>
<td>
<p>use underlying Bayesian model (<code>arm</code> package defaults). Results
in penalized parameter estimation that can help with very highly correlated
exposures. Note: this does not lead to fully Bayesian inference in general,
so results should be interpreted as frequentist.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_mcsize">MCsize</code></td>
<td>
<p>integer: sample size for simulation to approximate marginal
zero inflated model parameters. This can be left small for testing, but should be as large
as needed to reduce simulation error to an acceptable magnitude (can compare psi coefficients for
linear fits with qgcomp.noboot to gain some intuition for the level of expected simulation
error at a given value of MCsize). This likely won't matter much in linear models, but may
be important with binary or count outcomes.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_parallel">parallel</code></td>
<td>
<p>use (safe) parallel processing from the future and future.apply packages</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_parplan">parplan</code></td>
<td>
<p>(logical, default=FALSE) automatically set future::plan to plan(multisession) (and set to existing plan after bootstrapping)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_errcheck">errcheck</code></td>
<td>
<p>(logical, default=TRUE) include some basic error checking. Slightly
faster if set to false (but be sure you understand risks)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.boot_+3A_...">...</code></td>
<td>
<p>arguments to glm (e.g. family)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a qgcompfit object, which contains information about the effect
measure of interest (psi) and associated variance (var.psi), as well
as information on the model fit (fit) and information on the
weights/standardized coefficients in the positive (pos.weights) and
negative (neg.weights) directions.
</p>


<h3>See Also</h3>

<p><code><a href="qgcomp.html#topic+qgcomp.noboot">qgcomp.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
# linear model, binary modifier
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=4, family=gaussian()))
# set B larger for real examples
(qfit2 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
  degree = 1,
  expnms = c('x1', 'x2'), data=dat, q=4, family=gaussian(), B=10))
# categorical modifier
dat2 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=sample(0:2, 50, replace=TRUE), r=rbinom(50, 1, 0.5))
dat2$z = as.factor(dat2$z)
(qfit3 &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat2, q=4, family=gaussian()))
# set B larger for real examples
(qfit4 &lt;- qgcomp.emm.glm.boot(f=y ~ z + x1 + x2, emmvar="z",
  degree = 1,
  expnms = c('x1', 'x2'), data=dat2, q=4, family=gaussian(), B=10))
</code></pre>

<hr>
<h2 id='qgcomp.emm.glm.ee'>EMM for Quantile g-computation for continuous, binary, and count outcomes under linearity/additivity</h2><span id='topic+qgcomp.emm.glm.ee'></span><span id='topic+qgcomp.emm.ee'></span>

<h3>Description</h3>

<p>This function estimates a dose-response parameter representing a one quantile
increase in a set of exposures of interest at levels of a binary, factor, or continuous covariate.
This allows
testing of statistical interaction as well as estimation of stratum specific effects.
This model estimates the parameters of a marginal
structural model (MSM) based on g-computation with quantized exposures.
Note: this function allows clustering of data and/or sampling weights and yields cluster-robust standard
errors for all estimates
</p>
<p>Estimating equation methodology is used as the underlying estimation scheme. This allows that observations can be correlated, and is fundementally identical to some implementations of &quot;generalized estimating equations&quot; or GEE. Thus, it allows for a more general set of longitudinal data structures than does the qgcomp.glm.noboot function, because it allows that the outcome can vary over time within an individual. Interpretation of parameters is similar to that of a GEE: this function yields population average estimates of the effect of exposure over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgcomp.emm.glm.ee(
  f,
  data,
  expnms = NULL,
  emmvar = NULL,
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  offset = NULL,
  alpha = 0.05,
  rr = TRUE,
  degree = 1,
  includeX = TRUE,
  verbose = TRUE,
  errcheck = TRUE,
  ...
)

qgcomp.emm.ee(
  f,
  data,
  expnms = NULL,
  emmvar = NULL,
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  offset = NULL,
  alpha = 0.05,
  rr = TRUE,
  degree = 1,
  includeX = TRUE,
  verbose = TRUE,
  errcheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgcomp.emm.glm.ee_+3A_f">f</code></td>
<td>
<p>R style formula</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_expnms">expnms</code></td>
<td>
<p>character vector of exposures of interest</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_emmvar">emmvar</code></td>
<td>
<p>(character) name of effect measure modifier in dataset (if categorical, must be coded as a factor variable)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_q">q</code></td>
<td>
<p>NULL or number of quantiles used to create quantile indicator variables
representing the exposure variables. If NULL, then gcomp proceeds with un-transformed
version of exposures in the input datasets (useful if data are already transformed,
or for performing standard g-computation)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_breaks">breaks</code></td>
<td>
<p>(optional) NULL, or a list of (equal length) numeric vectors that
characterize the minimum value of each category for which to
break up the variables named in expnms. This is an alternative to using 'q'
to define cutpoints.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_id">id</code></td>
<td>
<p>(optional) NULL, or variable name indexing individual units of
observation (only needed if analyzing data with multiple observations per
id/cluster). Note that qgcomp.noboot will not produce cluster-appropriate
standard errors (this parameter is essentially ignored in qgcomp.noboot).
Qgcomp.boot can be used for this, which will use bootstrap
sampling of clusters/individuals to estimate cluster-appropriate standard
errors via bootstrapping.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_weights">weights</code></td>
<td>
<p>&quot;case weights&quot; or sampling weights - a vector of weights representing the contribution of each observation to the overall fit</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_offset">offset</code></td>
<td>
<p>Model offset term on individual basis: not yet implemented
<code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="arm.html#topic+bayesglm">bayesglm</a></code></p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence limit calculation</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_rr">rr</code></td>
<td>
<p>(logical, default=TRUE) estimate a risk ratio from the MSM when using an underlying logistic model</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_degree">degree</code></td>
<td>
<p>polynomial degree for non-linearity of MSM (values other than 1 are not supported, currently)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_includex">includeX</code></td>
<td>
<p>(logical, default=TRUE) include design matrixes in the output?</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_verbose">verbose</code></td>
<td>
<p>(logical, default=TRUE) include informative messages</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_errcheck">errcheck</code></td>
<td>
<p>(logical, default=TRUE) include some basic error checking. Slightly
faster if set to false (but be sure you understand risks)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.ee_+3A_...">...</code></td>
<td>
<p>arguments to glm (e.g. family)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a eeqgcompfit/qgcompemmfit/qgcompfit/list object, which contains information about the effect
measure of interest (psi) and associated variance (var.psi), as well
as information on the conditional/underlying model fit (fit) and the marginal structural model fit (msmfit).
</p>


<h3>See Also</h3>

<p><code><a href="qgcomp.html#topic+qgcomp.noboot">qgcomp.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
# linear model, binary modifier
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
(qfitee &lt;- qgcomp.emm.glm.ee(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
# logistic model, continuous modifier
dat2 &lt;- data.frame(y=rbinom(50, 1, 0.5), x1=runif(50), x2=runif(50),
  z=runif(50), r=rbinom(50, 1, 0.5))
(qfit2 &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat2, q=2, family=binomial()))
(qfit2ee &lt;- qgcomp.emm.glm.ee(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat2, q=2, family=binomial(), rr=FALSE))
# Note under rr = TRUE that the risk ratio will be reported in the MSM results
(qfit2eerr &lt;- qgcomp.emm.glm.ee(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat2, q=2, family=binomial(), rr=TRUE))
# linear model, factor modifier
dat &lt;- data.frame(y=runif(150), x1=runif(150), x2=runif(150),
  r=rbinom(150, 1, 0.5), z=sample(c(1, 2, 3), 150, replace=TRUE))
#note need to declare factor
dat$zfact = as.factor(dat$z)
# this can fail if the model is unidentified (e.g. z and zfact are included in the model)
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ zfact + x1 + x2, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
(qfitee &lt;- qgcomp.emm.glm.ee(f=y ~ zfact + x1 + x2, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
library(qgcomp)
# standard qgcomp model without interaction
(qfitee_noemm &lt;- qgcomp.glm.ee(f=y ~ zfact + x1 + x2,
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
  qfitee_noemm$fit # underlying fit
# global test for interaction
anova(qfitee, qfitee_noemm)
# get stratified effect estimates:
getstrateffects(qfitee, emmval=1)
getstrateffects(qfitee, emmval=2)
getstrateffects(qfitee, emmval=3)
dat$rfact = as.factor(dat$r)
(qfiteer &lt;- qgcomp.emm.glm.ee(f=y ~ zfact + x1 + x2 + r, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
 # factor as a confounder, also works if the modifier is not in the model
(qfiteerr2 &lt;- qgcomp.emm.glm.ee(f=y ~  x1 + x2 + rfact, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
getstrateffects(qfiteerr2, emmval=2)
getjointeffects(qfiteerr2, emmval=2)
modelbound(qfiteerr2, emmval=2)
pointwisebound(qfiteerr2, emmval=2)
(qfitee &lt;- qgcomp.glm.ee(f=y ~ zfact + x1 + x2, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=10, degree=2, family=gaussian()))
(qfitee &lt;- qgcomp.emm.glm.ee(f=y ~ zfact + x1 + x2, emmvar="zfact",
  expnms = c('x1', 'x2'), data=dat, q=10, degree=2, family=gaussian()))
</code></pre>

<hr>
<h2 id='qgcomp.emm.glm.noboot'>EMM for Quantile g-computation for continuous, binary, and count outcomes under linearity/additivity</h2><span id='topic+qgcomp.emm.glm.noboot'></span><span id='topic+qgcomp.emm.noboot'></span>

<h3>Description</h3>

<p>This function fits a quantile g-computation model, allowing
effect measure modification by a binary or continuous covariate. This allows
testing of statistical interaction as well as estimation of stratum specific effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgcomp.emm.glm.noboot(
  f,
  data,
  expnms = NULL,
  emmvar = NULL,
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  alpha = 0.05,
  bayes = FALSE,
  errcheck = TRUE,
  ...
)

qgcomp.emm.noboot(
  f,
  data,
  expnms = NULL,
  emmvar = NULL,
  q = 4,
  breaks = NULL,
  id = NULL,
  weights,
  alpha = 0.05,
  bayes = FALSE,
  errcheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_f">f</code></td>
<td>
<p>R style formula</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_expnms">expnms</code></td>
<td>
<p>character vector of exposures of interest</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_emmvar">emmvar</code></td>
<td>
<p>(character) name of effect measure modifier in dataset (if categorical, must be coded as a factor variable)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_q">q</code></td>
<td>
<p>NULL or number of quantiles used to create quantile indicator variables
representing the exposure variables. If NULL, then gcomp proceeds with un-transformed
version of exposures in the input datasets (useful if data are already transformed,
or for performing standard g-computation)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_breaks">breaks</code></td>
<td>
<p>(optional) NULL, or a list of (equal length) numeric vectors that
characterize the minimum value of each category for which to
break up the variables named in expnms. This is an alternative to using 'q'
to define cutpoints.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_id">id</code></td>
<td>
<p>(optional) NULL, or variable name indexing individual units of
observation (only needed if analyzing data with multiple observations per
id/cluster). Note that qgcomp.noboot will not produce cluster-appropriate
standard errors (this parameter is essentially ignored in qgcomp.noboot).
Qgcomp.boot can be used for this, which will use bootstrap
sampling of clusters/individuals to estimate cluster-appropriate standard
errors via bootstrapping.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_weights">weights</code></td>
<td>
<p>&quot;case weights&quot; - passed to the &quot;weight&quot; argument of
<code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="arm.html#topic+bayesglm">bayesglm</a></code></p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for confidence limit calculation</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_bayes">bayes</code></td>
<td>
<p>use underlying Bayesian model (<code>arm</code> package defaults). Results
in penalized parameter estimation that can help with very highly correlated
exposures. Note: this does not lead to fully Bayesian inference in general,
so results should be interpreted as frequentist.</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_errcheck">errcheck</code></td>
<td>
<p>(logical, default=TRUE) include some basic error checking. Slightly
faster if set to false (but be sure you understand risks)</p>
</td></tr>
<tr><td><code id="qgcomp.emm.glm.noboot_+3A_...">...</code></td>
<td>
<p>arguments to glm (e.g. family)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a qgcompfit object, which contains information about the effect
measure of interest (psi) and associated variance (var.psi), as well
as information on the model fit (fit) and information on the
weights/standardized coefficients in the positive (pos.weights) and
negative (neg.weights) directions.
</p>


<h3>See Also</h3>

<p><code><a href="qgcomp.html#topic+qgcomp.noboot">qgcomp.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
# linear model, binary modifier
dat &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=rbinom(50, 1, 0.5), r=rbinom(50, 1, 0.5))
(qfit &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat, q=2, family=gaussian()))
# logistic model, continuous modifier
dat2 &lt;- data.frame(y=rbinom(50, 1, 0.5), x1=runif(50), x2=runif(50),
  z=runif(50), r=rbinom(50, 1, 0.5))
(qfit2 &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat2, q=2, family=binomial()))
# get weights and stratum specific effects at specific value of Z
#  (note that when Z=0, the effect is equal to psi1)
qgcompint::getstratweights(qfit2, emmval=0)
qgcompint::getstrateffects(qfit2, emmval=0)
qgcompint::getstratweights(qfit2, emmval=0.5)
qgcompint::getstrateffects(qfit2, emmval=0.5)
# linear model, categorical modifier
dat3 &lt;- data.frame(y=runif(50), x1=runif(50), x2=runif(50),
  z=as.factor(sample(0:2, 50, replace=TRUE)), r=rbinom(50, 1, 0.5))
(qfit3 &lt;- qgcomp.emm.glm.noboot(f=y ~ z + x1 + x2, emmvar="z",
  expnms = c('x1', 'x2'), data=dat3, q=2, family=gaussian()))
# get weights and stratum specific effects at each value of Z
#  (note that when Z=0, the effect is equal to psi1)
qgcompint::getstratweights(qfit3, emmval=0)
qgcompint::getstrateffects(qfit3, emmval=0)
qgcompint::getstratweights(qfit3, emmval=1)
qgcompint::getstrateffects(qfit3, emmval=1)
qgcompint::getstratweights(qfit3, emmval=2)
qgcompint::getstrateffects(qfit3, emmval=2)
</code></pre>

<hr>
<h2 id='simdata_quantized_emm'>Simulate quantized exposures for testing methods</h2><span id='topic+simdata_quantized_emm'></span>

<h3>Description</h3>

<p>Simulate quantized exposures for testing methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata_quantized_emm(
  outcometype = c("continuous", "logistic", "survival"),
  n = 100,
  corr = NULL,
  b0 = 0,
  mainterms = c(1, 0, 0, 0),
  prodterms = c(1, 0, 0, 0),
  ztype = "binary",
  q = 4,
  yscale = 1,
  shape0 = 3,
  scale0 = 5,
  censtime = 4,
  ncheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdata_quantized_emm_+3A_outcometype">outcometype</code></td>
<td>
<p>Character variable that is one of c(&quot;continuous&quot;, &quot;logistic&quot;, &quot;survival&quot;). Selects what type of outcome should be simulated (or how). continuous = normal, continous outcome, logistic= binary outcome from logistic model, survival = right censored survival outcome from Weibull model.</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_corr">corr</code></td>
<td>
<p>NULL, or vector of correlations between the first exposure and subsequent exposures (if length(corr) &lt; (length(coef)-1), then this will be backfilled with zeros)</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_b0">b0</code></td>
<td>
<p>(continuous, binary outcomes) model intercept</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_mainterms">mainterms</code></td>
<td>
<p>beta coefficients for X in the outcome model at referent (0) level of interacting variable</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_prodterms">prodterms</code></td>
<td>
<p>product term coefficients for interacting variable</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_ztype">ztype</code></td>
<td>
<p>type of interacting variable: &quot;continuous&quot;, &quot;binary&quot;, &quot;categorical&quot;</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_q">q</code></td>
<td>
<p>Number of levels or &quot;quanta&quot; of each exposure</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_yscale">yscale</code></td>
<td>
<p>(continuous outcomes) error scale (residual error) for normally distributed outcomes</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_shape0">shape0</code></td>
<td>
<p>(survival outcomes) baseline shape of weibull distribution <a href="stats.html#topic+rweibull">rweibull</a></p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_scale0">scale0</code></td>
<td>
<p>(survival outcomes) baseline scale of weibull distribution <a href="stats.html#topic+rweibull">rweibull</a></p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_censtime">censtime</code></td>
<td>
<p>(survival outcomes) administrative censoring time</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_ncheck">ncheck</code></td>
<td>
<p>(logical, default=TRUE) adjust sample size if needed so that exposures are exactly evenly distributed (so that qgcomp::quantize(exposure) = exposure)</p>
</td></tr>
<tr><td><code id="simdata_quantized_emm_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate continuous (normally distributed errors), binary (logistic function), or event-time outcomes as a linear function
</p>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="qgcomp.html#topic+qgcomp.boot">qgcomp.boot</a></code>, and <code><a href="qgcomp.html#topic+qgcomp.noboot">qgcomp.noboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)
qdat = simdata_quantized_emm(
  outcomtype="continuous",
  n=10000, corr=c(.9, .3, 0, 0), mainterms=c(1, 1, 0, 0), prodterms=c(1, 1, 0, 0),
  q = 8
)
cor(qdat)
qdat = simdata_quantized_emm(
  outcomtype="continuous",
  n=10000, corr=c(-.9, .3, 0, 0), mainterms=c(1, 2, 0, 0), prodterms=c(1, 1, 0, 0),
  q = 4
)
cor(qdat)
table(qdat$x1)
qgcomp.emm.glm.noboot(y~x1+x2+x3+x4, expnms = c("x1", "x2", "x3", "x4"), emmvar = "z", data=qdat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
