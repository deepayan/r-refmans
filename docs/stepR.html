<!DOCTYPE html><html><head><title>Help for package stepR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stepR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stepR-package'><p>Multiscale Change-Point Inference</p></a></li>
<li><a href='#BesselPolynomial'><p>Bessel Polynomials</p></a></li>
<li><a href='#bounds'><p>Bounds based on MRC</p></a></li>
<li><a href='#compareBlocks'><p>Compare fit blockwise with ground truth</p></a></li>
<li><a href='#computeBounds'><p>Computation of the bounds</p></a></li>
<li><a href='#computeStat'><p>Computation of the multiscale statistic</p></a></li>
<li><a href='#contMC'><p>Continuous time Markov chain</p></a></li>
<li><a href='#critVal'><p>Critical values</p></a></li>
<li><a href='#dfilter'><p>Digital filters</p></a></li>
<li><a href='#family'><p>Family of distributions</p></a></li>
<li><a href='#intervalSystem'><p>Interval systems</p></a></li>
<li><a href='#jsmurf'><p>Reconstruct filtered piecewise constant functions with noise</p></a></li>
<li><a href='#jumpint'><p>Confidence intervals for jumps and confidence bands for step functions</p></a></li>
<li><a href='#monteCarloSimulation'><p>Monte Carlo simulation</p></a></li>
<li><a href='#MRC'><p>Compute Multiresolution Criterion</p></a></li>
<li><a href='#MRC.1000'><p>Values of the MRC statistic for 1,000 observations (all intervals)</p></a></li>
<li><a href='#MRC.asymptotic'><p>&quot;Asymptotic&quot; values of the MRC statistic (all intervals)</p></a></li>
<li><a href='#MRC.asymptotic.dyadic'><p>&quot;Asymptotic&quot; values of the MRC statistic (dyadic intervals)</p></a></li>
<li><a href='#neighbours'><p>Neighbouring integers</p></a></li>
<li><a href='#parametricFamily'><p>Parametric families</p></a></li>
<li><a href='#penalty'><p>Penalties</p></a></li>
<li><a href='#sdrobnorm'><p>Robust standard deviation estimate</p></a></li>
<li><a href='#smuceR'><p>Piecewise constant regression with SMUCE</p></a></li>
<li><a href='#stepblock'><p>Step function</p></a></li>
<li><a href='#stepbound'><p>Jump estimation under restrictions</p></a></li>
<li><a href='#stepcand'><p>Forward selection of candidate jumps</p></a></li>
<li><a href='#stepfit'><p>Fitted step function</p></a></li>
<li><a href='#stepFit'><p>Piecewise constant multiscale inference</p></a></li>
<li><a href='#steppath'><p>Solution path of step-functions</p></a></li>
<li><a href='#stepsel'><p>Automatic selection of number of jumps</p></a></li>
<li><a href='#testSmallScales'><p>Test Small Scales</p></a></li>
<li><a href='#transit'><p>TRANSIT algorithm for detecting jumps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multiscale Change-Point Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-9</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), lowpassFilter (&ge; 1.0.0), R.cache (&ge;
0.10.0), digest (&ge; 0.6.10), stats, graphics, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.0), knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows fitting of step-functions to univariate serial data where neither the number of jumps nor their positions is known by implementing the multiscale regression estimators SMUCE, simulataneous multiscale changepoint estimator, (K. Frick, A. Munk and H. Sieling, 2014) &lt;<a href="https://doi.org/10.1111%2Frssb.12047">doi:10.1111/rssb.12047</a>&gt; and HSMUCE, heterogeneous SMUCE, (F. Pein, H. Sieling and A. Munk, 2017) &lt;<a href="https://doi.org/10.1111%2Frssb.12202">doi:10.1111/rssb.12202</a>&gt;. In addition, confidence intervals for the change-point locations and bands for the unknown signal can be obtained.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62G08, 92C40, 92D20</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-13 17:15:18 UTC; pein</td>
</tr>
<tr>
<td>Author:</td>
<td>Pein Florian [aut, cre],
  Thomas Hotz [aut],
  Hannes Sieling [aut],
  Timo Aspelmeier [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pein Florian &lt;f.pein@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-13 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stepR-package'>Multiscale Change-Point Inference</h2><span id='topic+stepR-package'></span><span id='topic+stepR'></span>

<h3>Description</h3>

<p>Allows fitting of step-functions to univariate serial data where neither the number of jumps nor their positions is known by implementing the multiscale regression estimators <abbr><span class="acronym">SMUCE</span></abbr> (<cite>Frick et al.</cite>, 2014) and <abbr><span class="acronym">HSMUCE</span></abbr> (<cite>Pein et al.</cite>, 2017). In addition, confidence intervals for the change-point locations and bands for the unknown signal can be obtained. This is implemented in the function <code><a href="#topic+stepFit">stepFit</a></code>. Moreover, technical quantities like the statistics itself, bounds or critical values can be computed by other functions of the package. More details can be found in the vignette.</p>


<h3>Details</h3>

<p>New in version 2.0-0:
</p>

<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+stepFit">stepFit</a></code> </td><td style="text-align: left;"> Piecewise constant multiscale inference</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+critVal">critVal</a></code> </td><td style="text-align: left;"> Critical values</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+computeBounds">computeBounds</a></code> </td><td style="text-align: left;"> Computation of the bounds</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+computeStat">computeStat</a></code> </td><td style="text-align: left;"> Computation of the multiscale statistic</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> </td><td style="text-align: left;"> Monte Carlo simulation</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+parametricFamily">parametricFamily</a></code> </td><td style="text-align: left;"> Parametric families</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+intervalSystem">intervalSystem</a></code> </td><td style="text-align: left;"> Interval systems</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+penalty">penalty</a></code> </td><td style="text-align: left;"> Penalties</td>
</tr>

</table>

<p>From version 1.0-0:
</p>

<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+compareBlocks">compareBlocks</a></code> </td><td style="text-align: left;"> Compare fit blockwise with ground truth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+neighbours">neighbours</a></code> </td><td style="text-align: left;"> Neighbouring integers</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sdrobnorm">sdrobnorm</a></code> </td><td style="text-align: left;"> Robust standard deviation estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+stepblock">stepblock</a></code> </td><td style="text-align: left;"> Step function</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+stepcand">stepcand</a></code> </td><td style="text-align: left;"> Forward selection of candidate jumps</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+stepfit">stepfit</a></code> </td><td style="text-align: left;"> Fitted step function</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+steppath">steppath</a></code> </td><td style="text-align: left;"> Solution path of step-functions</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+stepsel">stepsel</a></code> </td><td style="text-align: left;"> Automatic selection of number of jumps</td>
</tr>

</table>

<p>Mainly used for patchclamp recordings and may be transferred to a specialised package:
</p>

<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+BesselPolynomial">BesselPolynomial</a></code> </td><td style="text-align: left;"> Bessel Polynomials</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+contMC">contMC</a></code> </td><td style="text-align: left;"> Continuous time Markov chain</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+dfilter">dfilter</a></code> </td><td style="text-align: left;"> Digital filters</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+jsmurf">jsmurf</a></code> </td><td style="text-align: left;"> Reconstruct filtered piecewise constant functions with noise</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+transit">transit</a></code> </td><td style="text-align: left;"> TRANSIT algorithm for detecting jumps</td>
</tr>

</table>

<p>Deprecated (please read the documentation of them theirself for more details):
</p>

<table>
<tr>
 <td style="text-align: left;"><code><a href="#topic+MRC">MRC</a></code> </td><td style="text-align: left;"> Compute Multiresolution Criterion</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+MRC.1000">MRC.1000</a></code> </td><td style="text-align: left;"> Values of the MRC statistic for 1,000 observations (all intervals)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+MRC.asymptotic">MRC.asymptotic</a></code> </td><td style="text-align: left;"> "Asymptotic" values of the MRC statistic (all intervals)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+MRC.asymptotic.dyadic">MRC.asymptotic.dyadic</a></code> </td><td style="text-align: left;"> "Asymptotic" values of the MRC statistic(dyadic intervals)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+bounds">bounds</a></code> </td><td style="text-align: left;"> Bounds based on MRC</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+family">family</a></code> </td><td style="text-align: left;"> Family of distributions</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+smuceR">smuceR</a></code> </td><td style="text-align: left;"> Piecewise constant regression with SMUCE</td>
</tr>

</table>



<h3>Storing of Monte-Carlo simulations</h3>

<p>If <code>q == NULL</code> in <code><a href="#topic+critVal">critVal</a></code>, <code><a href="#topic+stepFit">stepFit</a></code> or <code><a href="#topic+computeBounds">computeBounds</a></code> a Monte-Carlo simulation is required for computing critical values. Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package offers multiple possibilities for saving and loading the simulations. Simulations can either be saved in the workspace in the variable <code>critValStepRTab</code> or persistently on the file system for which the package <code><a href="R.cache.html#topic+R.cache">R.cache</a></code> is used. Moreover, storing in and loading from variables and <a href="base.html#topic+readRDS">RDS</a> files is supported. Finally, a pre-simulated collection of simulations can be accessed by installing the package <code>stepRdata</code> available from <a href="http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz">http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz</a>. By default simulations will be saved in the workspace and on the file system.  For more details and for how simulation can be removed see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> in <code><a href="#topic+critVal">critVal</a></code>.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2017) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. <em>arXiv</em>:1706.03671.
</p>
<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing ion channel recordings by a jump segmentation multiresolution filter. <em>IEEE Transactions on NanoBioscience</em> <b>12</b>(4), 376&ndash;386.
</p>
<p>VanDongen, A. M. J. (1996) A new algorithm for idealizing single ion channel data containing multiple unknown conductance levels. <em>Biophysical Journal</em> <b>70</b>(3), 1303&ndash;1315.
</p>
<p>Futschik, A., Hotz, T., Munk, A., Sieling, H. (2014) Multiresolution DNA partitioning: statistical evidence for segments. <em>Bioinformatics</em>,  <b>30</b>(16), 2255&ndash;2262.
</p>
<p>Boysen, L., Kempe, A., Liebscher, V., Munk, A., Wittich, O. (2009) Consistencies and rates of convergence of jump-penalized least squares estimators. <em>The Annals of Statistics</em> <b>37</b>(1), 157&ndash;183.
</p>
<p>Davies, P. L., Kovac, A. (2001) Local extremes, runs, strings and multiresolution. <em>The Annals of Statistics</em> <b>29</b>, 1&ndash;65.
</p>
<p>Friedrich, F., Kempe, A., Liebscher, V., Winkler, G. (2008) Complexity penalized M-estimation: fast computation. <em>Journal of Computational and Graphical Statistics</em> <b>17</b>(1), 201&ndash;224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepFit">stepFit</a></code>, <code><a href="#topic+critVal">critVal</a></code>, <code><a href="#topic+computeStat">computeStat</a></code>, <code><a href="#topic+computeBounds">computeBounds</a></code>,  <code><a href="#topic+jsmurf">jsmurf</a></code>, <code><a href="#topic+transit">transit</a></code>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>, <code><a href="#topic+compareBlocks">compareBlocks</a></code>, <a href="#topic+parametricFamily">parametricFamily</a>, <a href="#topic+intervalSystem">intervalSystem</a>, <a href="#topic+penalty">penalty</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate random observations
set.seed(1)
n &lt;- 100L
x &lt;- seq(1 / n, 1, 1 / n)
mu &lt;- stepfit(cost = 0, family = "gauss", value = c(0, 3, 0, -2, 0), param = NULL,
              leftEnd = x[c(1, 21, 26, 71, 81)],
              rightEnd = x[c(20, 25, 70, 80, 100)], x0 = 0,
              leftIndex = c(1, 21, 26, 71, 81),
              rightIndex = c(20, 25, 70, 80, 100))
sigma0 &lt;- 0.5
epsilon &lt;- rnorm(n, 0, sigma0)
y &lt;- fitted(mu) + epsilon
plot(x, y, pch = 16, col = "grey30", ylim = c(-3, 4))
lines(mu, lwd = 3)

# computation of SMUCE and its confidence statements
fit &lt;- stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red", lwd = 3)
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# higher significance level for larger detection power, but less confidence
# suggested for screening purposes
stepFit(y, x = x, alpha = 0.9, jumpint = TRUE, confband = TRUE)

# smaller significance level for the small risk that the number of
# change-points is overestimated with probability not more than 5%,
# but smaller detection power
stepFit(y, x = x, alpha = 0.05, jumpint = TRUE, confband = TRUE)

# different interval system, lengths, penalty and given parameter sd
stepFit(y, x = x, alpha = 0.5, intervalSystem = "dyaLen",
        lengths = c(1L, 2L, 4L, 8L), penalty = "weights",
        weights = c(0.4, 0.3, 0.2, 0.1), sd = sigma0,
        jumpint = TRUE, confband = TRUE)

# the above calls saved and (attempted to) load Monte-Carlo simulations and
# simulated them for nq = 128 observations
# in the following call no saving, no loading and simulation for n = 100
# observations is required, progress of the simulation will be reported
stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE, messages = 1000L,
        options = list(simulation = "vector", load = list(), save = list()))

# critVal was called in stepFit, can be called explicitly,
# for instance outside of a for loop to save computation time
qVector &lt;- critVal(100L, alpha = 0.5)
identical(stepFit(y, x = x, q = qVector, jumpint = TRUE, confband = TRUE), fit)

qValue &lt;- critVal(100L, alpha = 0.5, output = "value")
identical(stepFit(y, x = x, q = qValue, jumpint = TRUE, confband = TRUE), fit)

# computeBounds gives the multiscale contraint
computeBounds(y, alpha = 0.5)

# monteCarloSimulation will be called in critVal if required
# can be called explicitly
stat &lt;- monteCarloSimulation(n = 100L)
identical(critVal(n = 100L, alpha = 0.5, stat = stat),
          critVal(n = 100L, alpha = 0.5,
                  options = list(load = list(), simulation = "vector")))
identical(critVal(n = 100L, alpha = 0.5, stat = stat, output = "value"),
          critVal(n = 100L, alpha = 0.5, output = "value",
                  options = list(load = list(), simulation = "vector")))

stat &lt;- monteCarloSimulation(n = 100L, output = "maximum")
identical(critVal(n = 100L, alpha = 0.5, stat = stat),
          critVal(n = 100L, alpha = 0.5,
                  options = list(load = list(), simulation = "vector")))
identical(critVal(n = 100L, alpha = 0.5, stat = stat, output = "value"),
          critVal(n = 100L, alpha = 0.5, output = "value",
                  options = list(load = list(), simulation = "vector")))
                  
# fit satisfies the multiscale contraint, i.e.
# the computed penalized multiscale statistic is not larger than the global quantile
computeStat(y, signal = fit, output = "maximum") &lt;= qValue
# multiscale vector of statistics is componentwise not larger than 
# the vector of critical values
all(computeStat(y, signal = fit, output = "vector") &lt;= qVector)


# family "hsmuce"
set.seed(1)
y &lt;- c(rnorm(50, 0, 1), rnorm(50, 1, 0.2))
plot(x, y, pch = 16, col = "grey30", ylim = c(-2.5, 2))

# computation of HSMUCE and its confidence statements
fit &lt;- stepFit(y, x = x, alpha = 0.5, family = "hsmuce",
               jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red", lwd = 3)
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# for comparison SMUCE, not recommend to use here
lines(stepFit(y, x = x, alpha = 0.5,
              jumpint = TRUE, confband = TRUE),
      lwd = 3, col = "blue", lty = "22")


# family "mDependentPS"
# generate observations from a moving average process
set.seed(1)
y &lt;- c(rep(0, 50), rep(2, 50)) +
  as.numeric(arima.sim(n = 100, list(ar = c(), ma = c(0.8, 0.5, 0.3)), sd = sigma0))
correlations &lt;- as.numeric(ARMAacf(ar = c(), ma = c(0.8, 0.5, 0.3), lag.max = 3))
covariances &lt;- sigma0^2 * correlations
plot(x, y, pch = 16, col = "grey30", ylim = c(-2, 4))

# computation of SMUCE for dependent observations with given covariances
fit &lt;- stepFit(y, x = x, alpha = 0.5, family = "mDependentPS",
               covariances = covariances, jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red", lwd = 3)
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# for comparison SMUCE for independent observations, not recommend to use here
lines(stepFit(y, x = x, alpha = 0.5,
              jumpint = TRUE, confband = TRUE),
      lwd = 3, col = "blue", lty = "22")

# with given correlations, standard deviation will be estimated by sdrobnorm
stepFit(y, x = x, alpha = 0.5, family = "mDependentPS",
        correlations = correlations, jumpint = TRUE, confband = TRUE)
        
        
# examples from version 1.0-0
# estimating step-functions with Gaussian white noise added
# simulate a Gaussian hidden Markov model of length 1000 with 2 states
# with identical transition rates 0.01, and signal-to-noise ratio 2
sim &lt;- contMC(1e3, 0:1, matrix(c(0, 0.01, 0.01, 0), 2), param=1/2)
plot(sim$data, cex = 0.1)
lines(sim$cont, col="red")
# maximum-likelihood estimation under multiresolution constraints
fit.MRC &lt;- smuceR(sim$data$y, sim$data$x)
lines(fit.MRC, col="blue")
# choose number of jumps using BIC
path &lt;- steppath(sim$data$y, sim$data$x, max.blocks=1e2)
fit.BIC &lt;- path[[stepsel.BIC(path)]]
lines(fit.BIC, col="green3", lty = 2)

# estimate after filtering
# simulate filtered ion channel recording with two states
set.seed(9)
# sampling rate 10 kHz
sampling &lt;- 1e4
# tenfold oversampling
over &lt;- 10
# 1 kHz 4-pole Bessel-filter, adjusted for oversampling
cutoff &lt;- 1e3
df.over &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling / over))
# two states, leaving state 1 at 10 Hz, state 2 at 20 Hz
rates &lt;- rbind(c(0, 10), c(20, 0))
# simulate 0.5 s, level 0 corresponds to state 1, level 1 to state 2
# noise level is 0.3 after filtering
Sim &lt;- contMC(0.5 * sampling, 0:1, rates, sampling=sampling, family="gaussKern",
  param = list(df=df.over, over=over, sd=0.3))
plot(Sim$data, pch = ".")
lines(Sim$discr, col = "red")
# fit under multiresolution constraints using filter corresponding to sample rate
df &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling))
Fit.MRC &lt;- jsmurf(Sim$data$y, Sim$data$x, param=df, r=1e2)
lines(Fit.MRC, col = "blue")
# fit using TRANSIT
Fit.trans &lt;- transit(Sim$data$y, Sim$data$x)
lines(Fit.trans, col = "green3", lty=2)



</code></pre>

<hr>
<h2 id='BesselPolynomial'>Bessel Polynomials</h2><span id='topic+BesselPolynomial'></span>

<h3>Description</h3>

<p>Recursively compute coefficients of Bessel Polynomials.
</p>
<p><b>Deprecation warning:</b> This function is a help function for the Bessel filters in <code><a href="#topic+dfilter">dfilter</a></code> and may be removed when <code><a href="#topic+dfilter">dfilter</a></code> will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BesselPolynomial(n, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BesselPolynomial_+3A_n">n</code></td>
<td>
<p>order</p>
</td></tr>
<tr><td><code id="BesselPolynomial_+3A_reverse">reverse</code></td>
<td>
<p>whether to return the coefficients of a reverse Bessel Polynomial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the polynom's coefficients ordered increasing with the exponent, i.e. starting with the intercept, as for <code><a href="base.html#topic+polyroot">polyroot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfilter">dfilter</a></code>, <code><a href="base.html#topic+bessel">bessel</a></code>, <code><a href="base.html#topic+polyroot">polyroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 15 x^3 + 15 x^2 + 6 x + 1
BesselPolynomial(3)
</code></pre>

<hr>
<h2 id='bounds'>Bounds based on MRC</h2><span id='topic++5B.bounds'></span><span id='topic+bounds'></span><span id='topic+bounds.MRC'></span>

<h3>Description</h3>

<p>Computes two-sided bounds for a set of intervals based on a multiresolution criterion (MRC).
</p>
<p><b>Deprecation warning:</b> This function is deprecated, but still working, however, may be defunct in a future version. Please use instead the function <code><a href="#topic+computeBounds">computeBounds</a></code>. An example how to reproduce results (currently only <a href="#topic+family">family</a> <code>"gauss"</code> is supported) is given below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(y, type = "MRC", ...)
bounds.MRC(y, q, alpha = 0.05, r = ceiling(50 / min(alpha, 1 - alpha)),
  lengths = if(family == "gaussKern")
    2^(floor(log2(length(y))):ceiling(log2(length(param$kern)))) else
    2^(floor(log2(length(y))):0), penalty = c("none", "len", "var", "sqrt"),
  name = if(family == "gaussKern") ".MRC.ktable" else ".MRC.table", pos = .MCstepR,
  family = c("gauss", "gaussvar", "poisson", "binomial","gaussKern"), param = NULL,
  subset, max.iter = 1e2, eps = 1e-3)
## S3 method for class 'bounds'
x[subset]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounds_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="bounds_+3A_type">type</code></td>
<td>
<p>so far only bounds of type <code>"MRC"</code> are implemented</p>
</td></tr>
<tr><td><code id="bounds_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>bounds.MRC</code></p>
</td></tr>
<tr><td><code id="bounds_+3A_q">q</code></td>
<td>
<p>quantile of the MRC; if specified, <code>alpha</code> and <code>r</code> will be ignored</p>
</td></tr>
<tr><td><code id="bounds_+3A_alpha">alpha</code></td>
<td>
<p>level of significance</p>
</td></tr>
<tr><td><code id="bounds_+3A_r">r</code></td>
<td>
<p>number of simulations to use to obtain quantile of MRC for specified <code>alpha</code></p>
</td></tr>
<tr><td><code id="bounds_+3A_lengths">lengths</code></td>
<td>
<p>vector of interval lengths to use, dyadic intervals by default</p>
</td></tr>
<tr><td><code id="bounds_+3A_penalty">penalty</code></td>
<td>
<p>penalty term in the multiresolution statistic: <code>"none"</code> for no penalty, <code>"len"</code> for penalizing the length of an interval, <code>"var"</code> for penalizing the variance over an interval, and <code>"sqrt"</code> for penalizing the square root of the MRC</p>
</td></tr>
<tr><td><code id="bounds_+3A_family">family</code>, <code id="bounds_+3A_param">param</code></td>
<td>
<p>specifies distribution of data, see <a href="#topic+family">family</a></p>
</td></tr>
<tr><td><code id="bounds_+3A_subset">subset</code></td>
<td>
<p>a subset of indices of <code>y</code> for which bounds should be aggregated</p>
</td></tr>
<tr><td><code id="bounds_+3A_name">name</code>, <code id="bounds_+3A_pos">pos</code></td>
<td>
<p>under which name and where precomputed results are stored, or retrieved, see <code><a href="base.html#topic+assign">assign</a></code></p>
</td></tr>
<tr><td><code id="bounds_+3A_max.iter">max.iter</code></td>
<td>
<p>maximal iterations in Newton's method to compute non-Gaussian MRC bounds</p>
</td></tr>
<tr><td><code id="bounds_+3A_eps">eps</code></td>
<td>
<p>tolerance in Newton's method</p>
</td></tr>
<tr><td><code id="bounds_+3A_x">x</code></td>
<td>
<p>an object of class <code>bounds</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>bounds</code>, i.e. a list whose entry <code>bounds</code> contains two-sided bounds (<code>lower</code> and <code>upper</code>) of the considered intervals (with left index <code>li</code> and right index <code>ri</code>) in a <code><a href="base.html#topic+data.frame">data.frame</a></code>, along with a vector <code>start</code> specifying in which row of entry <code>bounds</code> intervals with corresponding <code>li</code> start (if any; specified as a C-style index), and a <code><a href="base.html#topic+logical">logical</a></code> <code>feasible</code> telling whether a feasible solution exists for these bounds (always <code>TRUE</code> for MRC bounds which are not restricted to a <code>subset</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeBounds">computeBounds</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <a href="#topic+family">family</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100, c(rep(0, 50), rep(1, 50)), 0.5)
b &lt;- computeBounds(y, q = 4, intervalSystem = "dyaLen", penalty = "none")
b &lt;- b[order(b$li, b$ri), ]
attr(b, "row.names") &lt;- seq(along = b$li)

# entries in bounds are recovered by computeBounds
all.equal(bounds(y, q = 4)$bounds, b) # TRUE


# simulate signal of 100 data points
Y &lt;- rpois(100, 1:100 / 10)
# compute bounds for intervals of dyadic lengths
b &lt;- bounds(Y, penalty="len", family="poisson", q=4)
# compute bounds for all intervals
b &lt;- bounds(Y, penalty="len", family="poisson", q=4, lengths=1:100)
</code></pre>

<hr>
<h2 id='compareBlocks'>Compare fit blockwise with ground truth</h2><span id='topic+compareBlocks'></span>

<h3>Description</h3>

<p>Blockwise comparison of a fitted step function with a known ground truth using different criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareBlocks(truth, estimate, dist = 5e3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareBlocks_+3A_truth">truth</code></td>
<td>
<p>an object of class <code><a href="#topic+stepblock">stepblock</a></code> giving the ground truth, or a list of such objects</p>
</td></tr>
<tr><td><code id="compareBlocks_+3A_estimate">estimate</code></td>
<td>
<p>corresponding estimated object(s) of class <code><a href="#topic+stepblock">stepblock</a></code></p>
</td></tr>
<tr><td><code id="compareBlocks_+3A_dist">dist</code></td>
<td>
<p>a single <code><a href="base.html#topic+numeric">numeric</a></code> specifying the distance for at which jumps will be considered as having matched in the qualitative criterion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>, containing just one row if two single <code><a href="#topic+stepblock">stepblock</a></code> were given, with columns
</p>
<table>
<tr><td><code>true.num</code>, <code>est.num</code></td>
<td>
<p>the true / estimated number of blocks</p>
</td></tr>
<tr><td><code>true.pos</code>, <code>false.pos</code>, <code>false.neg</code>, <code>sens.rate</code>, <code>prec.rate</code></td>
<td>
<p>the number of true / false positive, false negatives, as well as the corresponding sensitivity and precision rates, where an estimated block is considered a true positive if it there is a corresponding block in the ground truth with both endpoints within <code>dist</code> of each other</p>
</td></tr>
<tr><td><code>fpsle</code></td>
<td>
<p>false positive sensitive localization error: for each estimated block's midpoint find into which true block it falls, and sum distances of the respective borders</p>
</td></tr>
<tr><td><code>fnsle</code></td>
<td>
<p>false negative sensitive localization error: for each true block's mid-point find into which estimated block it falls, and sum distances of the respective borders</p>
</td></tr>
<tr><td><code>total.le</code></td>
<td>
<p>total localization error: sum of <code>fpsle</code> and <code>fnsle</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>No differences between true and fitted parameter <em>values</em> are taking into account, only the precision of the detected blocks is considered; also, differing from the criteria in Elhaik et al.~(2010), no blocks are merged in the ground truth if its parameter values are close, as this may punish sensitive estimators. 
</p>
<p>Beware that these criteria compare <em>blockwise</em>, i.e. they do <em>not</em> compare the precision of single jumps but for each block both endpoints have to match well at the same time.
</p>


<h3>References</h3>

<p>Elhaik, E., Graur, D., Josić, K. (2010) Comparative testing of DNA segmentation algorithms using benchmark simulations. <em>Molecular Biology and Evolution</em> <b>27</b>(5), 1015-24.
</p>
<p>Futschik, A., Hotz, T., Munk, A. Sieling, H. (2014) Multiresolution DNA partitioning: statistical evidence for segments. <em>Bioinformatics</em>,  <b>30</b>(16), 2255&ndash;2262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepblock">stepblock</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <code><a href="#topic+contMC">contMC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate two Gaussian hidden Markov models of length 1000 with 2 states each
# with identical transition rates being 0.01 and 0.05, resp, signal-to-noise ratio is 5
sim &lt;- lapply(c(0.01, 0.05), function(rate)
  contMC(1e3, 0:1, matrix(c(0, rate, rate, 0), 2), param=1/5))
plot(sim[[1]]$data)
lines(sim[[1]]$cont, col="red")
# use smuceR to estimate fit
fit &lt;- lapply(sim, function(s) smuceR(s$data$y, s$data$x))
lines(fit[[1]], col="blue")
# compare fit with (discretised) ground truth
compareBlocks(lapply(sim, function(s) s$discr), fit)
</code></pre>

<hr>
<h2 id='computeBounds'>Computation of the bounds</h2><span id='topic+computeBounds'></span>

<h3>Description</h3>

<p>Computes the multiscale contraint given by the multiscale test, (3.12) in the vignette. In more detail, returns the bounds of the interval of parameters for which the test statistic is smaller than or equal to the critical value for the corresponding length, i.e. the two solutions resulting from equating the test statistic to the critical value.<br />
If <code>q == NULL</code> a Monte-Carlo simulation is required for computing critical values. Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package saves them by default in the workspace and on the file system such that a second call requiring the same Monte-Carlo simulation will be much faster. For more details, in particular to which arguments the Monte-Carlo simulations are specific, see Section <cite>Storing of Monte-Carlo simulations</cite> below. Progress of a Monte-Carlo simulation can be reported by the argument <code>messages</code> and the saving can be controlled by the argument <code>option</code>, both can be specified in <code>...</code> and are explained in <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> and <code><a href="#topic+critVal">critVal</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeBounds(y, q = NULL, alpha = NULL, family = NULL,
              intervalSystem = NULL, lengths = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeBounds_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the observations</p>
</td></tr>
<tr><td><code id="computeBounds_+3A_q">q</code></td>
<td>
<p>either <code>NULL</code>, then the vector of critical values at level <code>alpha</code> will be computed from a Monte-Carlo simulation, or a numeric giving the global quantile or a numeric vector giving the vector of critical values. Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code>. This argument will be passed to <code><a href="#topic+critVal">critVal</a></code> to obtain the needed critical values. Additional parameters for the computation of <code>q</code> can be specified in <code>...</code>, for more details see the documentation of <code><a href="#topic+critVal">critVal</a></code>. Please note that by default the Monte-Carlo simulation will be saved in the workspace and on the file system, for more details see Section <cite>Storing of Monte-Carlo simulations</cite> below</p>
</td></tr>
<tr><td><code id="computeBounds_+3A_alpha">alpha</code></td>
<td>
<p>a probability, i.e. a single numeric between 0 and 1, giving the significance level. Its choice is a trade-off between data fit and parsimony of the estimator. In other words, this argument balances the risks of missing change-points and detecting additional artefacts. For more details on this choice see (Frick et al., 2014, section 4) and (Pein et al., 2017, section 3.4). Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code></p>
</td></tr>
<tr><td><code id="computeBounds_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, for more details see <a href="#topic+parametricFamily">parametricFamily</a>, currently <code>"gauss"</code>, <code>"hsmuce"</code> and <code>"mDependentPS"</code> are supported. By default (<code>NULL</code>) <code>"gauss"</code> is assumed</p>
</td></tr>
<tr><td><code id="computeBounds_+3A_intervalsystem">intervalSystem</code></td>
<td>
<p>a string giving the used interval system, either <code>"all"</code> for all intervals, <code>"dyaLen"</code> for all intervals of dyadic length or <code>"dyaPar"</code> for the dyadic partition, for more details see <a href="#topic+intervalSystem">intervalSystem</a>. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="computeBounds_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. Note that not all lengths are possible for all interval systems and for all parametric families, see <a href="#topic+intervalSystem">intervalSystem</a> and <a href="#topic+parametricFamily">parametricFamily</a>, respectively, to see which ones are allowed. By default (<code>NULL</code>) all lengths that are possible for the specified <code>intervalSystem</code> and for the specified parametric family will be used</p>
</td></tr>
<tr><td><code id="computeBounds_+3A_...">...</code></td>
<td>
<p>there are two groups of further arguments:
</p>

<ol>
<li><p> further parameters of the parametric family. Depending on argument <code>family</code> some might be required, but others might be optional, please see <a href="#topic+parametricFamily">parametricFamily</a> for more details,
</p>
</li>
<li><p> further parameters that will be passed to <code><a href="#topic+critVal">critVal</a></code>. <code><a href="#topic+critVal">critVal</a></code> will be called automatically with the number of observations <code>n = length(y)</code>, the arguments <code>family</code>, <code>intervalSystem</code>, <code>lengths</code>, <code>q</code> and <code>output</code> set. For these arguments no user interaction is required and possible, all other arguments of <code><a href="#topic+critVal">critVal</a></code> can be passed additionally
</p>
</li></ol>

</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing two integer vectors <code>li</code> and <code>ri</code> and two numeric vectors <code>lower</code> and <code>upper</code>. For each interval in the set of intervals specified by <code>intervalSystem</code> and <code>lengths</code> <code>li</code> and <code>ri</code> give the left and right index of the interval and <code>lower</code> and <code>upper</code> give the lower and upper bounds for the parameter on the given interval.
</p>


<h3>Storing of Monte-Carlo simulations</h3>

<p>If <code>q == NULL</code> a Monte-Carlo simulation is required for computing critical values. Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package offers multiple possibilities for saving and loading the simulations. Progress of a simulation can be reported by the argument <code>messages</code> which can be specified in <code>...</code> and is explained in the documentation of <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. Each Monte-Carlo simulation is specific to the number of observations, the parametric family (including certain parameters, see <a href="#topic+parametricFamily">parametricFamily</a>) and the interval system, and for simulations of class <code>"MCSimulationMaximum"</code>, additionally, to the set of lengths and the used penalty. Monte-Carlo simulations can also be performed for a (slightly) larger number of observations <code class="reqn">n_q</code> given in the argument <code>nq</code> in <code>...</code> and explained in the documentation of <code><a href="#topic+critVal">critVal</a></code>, which avoids extensive resimulations for only a little bit varying number of observations. Simulations can either be saved in the workspace in the variable <code>critValStepRTab</code> or persistently on the file system for which the package <code><a href="R.cache.html#topic+R.cache">R.cache</a></code> is used. Moreover, storing in and loading from variables and <a href="base.html#topic+readRDS">RDS</a> files is supported. Finally, a pre-simulated collection of simulations can be accessed by installing the package <code>stepRdata</code> available from <a href="http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz">http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz</a>. The simulation, saving and loading can be controlled by the argument <code>option</code> which can be specified in <code>...</code> and is explained in the documentation of <code><a href="#topic+critVal">critVal</a></code>. By default simulations will be saved in the workspace and on the file system.  For more details and for how simulation can be removed see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> in <code><a href="#topic+critVal">critVal</a></code>.
</p>


<h3>Note</h3>

<p>Depending on <code>intervalSystem</code> and <code>lengths</code> the intervals might be ordered differently to allow fast computation. For most applications the order should not matter. Otherwise, the entries can be reordered with <code><a href="base.html#topic+order">order</a></code>, an example is given below.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critVal">critVal</a></code>, <code><a href="#topic+penalty">penalty</a></code>, <code><a href="#topic+parametricFamily">parametricFamily</a></code>, <code><a href="#topic+intervalSystem">intervalSystem</a></code>, <code><a href="#topic+stepFit">stepFit</a></code>, <code><a href="#topic+computeStat">computeStat</a></code>, <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

y &lt;- c(rnorm(50), rnorm(50, 1))

# the multiscale contraint
bounds &lt;- computeBounds(y, alpha = 0.5)

# the order of the bounds depends on intervalSystem and lengths
# to allow fast computation
# if a specific order is required it can be reordered by order
# b is ordered with increasing left indices and increasing right indices
b &lt;- bounds[order(bounds$li, bounds$ri), ]
attr(b, "row.names") &lt;- seq(along = b$li)

# higher significance level for larger detection power, but less confidence
computeBounds(y, alpha = 0.99)

# smaller significance level for stronger confidence statements, but at
# the risk of missing change-points
computeBounds(y, alpha = 0.05)

# different interval system, lengths, penalty and given parameter sd
computeBounds(y, alpha = 0.5, intervalSystem = "dyaLen",
              lengths = c(1L, 2L, 4L, 8L), penalty = "weights",
              weights = c(0.4, 0.3, 0.2, 0.1), sd = 0.5)
              
# with given q
identical(computeBounds(y, q = critVal(100L, alpha = 0.5)), bounds)
identical(computeBounds(y, q = critVal(100L, alpha = 0.5, output = "value")),
          bounds)

# the above calls saved and (attempted to) load Monte-Carlo simulations and
# simulated them for nq = 128 observations
# in the following call no saving, no loading and simulation for n = 100
# observations is required, progress of the simulation will be reported
computeBounds(y, alpha = 0.5, messages = 1000L,
              options = list(simulation = "vector",
                             load = list(), save = list()))
                             
# with given stat to compute q
stat &lt;- monteCarloSimulation(n = 128L)
identical(computeBounds(y, alpha = 0.5, stat = stat),
          computeBounds(y, alpha = 0.5, options = list(load = list())))



</code></pre>

<hr>
<h2 id='computeStat'>Computation of the multiscale statistic</h2><span id='topic+computeStat'></span>

<h3>Description</h3>

<p>Computes the multiscale vector of penalised statistics, (3.7) in the vignette, or the penalised multiscale statistic, (3.6) in the vignette, for given signal.</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeStat(y, signal = 0, family = NULL, intervalSystem = NULL, lengths = NULL,
            penalty = NULL, nq = length(y),
            output = c("list", "vector", "maximum"), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeStat_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the observations</p>
</td></tr>
<tr><td><code id="computeStat_+3A_signal">signal</code></td>
<td>
<p>the given signal, either a single numeric for a constant function equal to the given value or an object of class <code><a href="#topic+stepfit">stepfit</a></code>. More precisely, a <code><a href="base.html#topic+list">list</a></code> containing an integer vector <code>leftIndex</code>, an integer vector <code>rightIndex</code> and a numeric vector <code>value</code>, all of the same length, e.g. a <code><a href="base.html#topic+data.frame">data.frame</a></code>, specifying a step function is enough</p>
</td></tr>
<tr><td><code id="computeStat_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, for more details see <a href="#topic+parametricFamily">parametricFamily</a>, currently <code>"gauss"</code>, <code>"hsmuce"</code> and <code>"mDependentPS"</code> are supported. By default (<code>NULL</code>) <code>"gauss"</code> is assumed</p>
</td></tr>
<tr><td><code id="computeStat_+3A_intervalsystem">intervalSystem</code></td>
<td>
<p>a string giving the used interval system, either <code>"all"</code> for all intervals, <code>"dyaLen"</code> for all intervals of dyadic length or <code>"dyaPar"</code> for the dyadic partition, for more details see <a href="#topic+intervalSystem">intervalSystem</a>. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="computeStat_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. Note that not all lengths are possible for all interval systems and for all parametric families, see <a href="#topic+intervalSystem">intervalSystem</a> and <a href="#topic+parametricFamily">parametricFamily</a>, respectively, to see which ones are allowed. By default (<code>NULL</code>) all lengths that are possible for the specified <code>intervalSystem</code> and for the specified parametric family will be used</p>
</td></tr>
<tr><td><code id="computeStat_+3A_penalty">penalty</code></td>
<td>
<p>a string specifying how the statistics will be penalised, either <code>"sqrt"</code>, <code>"log"</code> or <code>"none"</code>, see <a href="#topic+penalty">penalty</a> and section 3.2 in the vignette for more details. By default (<code>NULL</code>) the default penalty of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="computeStat_+3A_nq">nq</code></td>
<td>
<p>a single integer larger than or equal to <code>length(y)</code> giving the number of observations used in the penalty term, see <a href="#topic+penalty">penalty</a> for more details. The possibility to use a number larger than <code>length(y)</code> is given for comparisons, since a (slightly) larger number can be chosen in <code><a href="#topic+critVal">critVal</a></code> and <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> to avoid extensive recomputations for (slightly) varying number of observations. For more details see also the Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> in <code><a href="#topic+critVal">critVal</a></code></p>
</td></tr>
<tr><td><code id="computeStat_+3A_output">output</code></td>
<td>
<p>a string specifying the output, see <cite>Value</cite></p>
</td></tr>
<tr><td><code id="computeStat_+3A_...">...</code></td>
<td>
<p>further parameters of the parametric family. Depending on argument <code>family</code> some might be required, but others might be optional, please see <a href="#topic+parametricFamily">parametricFamily</a> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output == list</code> a list containing in <code>maximum</code> the penalised multiscale statistic, i.e. the maximum over all test statistics, in <code>stat</code> the multiscale vector of penalised statistics, i.e. a vector of length <code>lengths</code> giving the maximum over all tests of that length, and in <code>lengths</code> the vector of lengths. If <code>output == vector</code> a numeric vector giving the multiscale vector of penalised statistics. If <code>output == maximum</code> a single numeric giving the penalised multiscale statistic. <code>-Inf</code> is returned for lengths for which on all intervals of that length contained in the set of intervals the <code>signal</code> is not constant and, hence, no test statistic can be computed. This behaves similar to <code>max(numeric(0))</code>.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><a href="#topic+parametricFamily">parametricFamily</a>, <a href="#topic+intervalSystem">intervalSystem</a>, <a href="#topic+penalty">penalty</a>, <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>, <code><a href="#topic+stepFit">stepFit</a></code>, <code><a href="#topic+computeBounds">computeBounds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

y &lt;- rnorm(100)
# for the default signal = 0 a signal constant 0 is assumed
identical(computeStat(y), computeStat(y,
            signal = list(leftIndex = 1L, rightIndex = 100L, value = 0)))

# different constant value
ret &lt;- computeStat(y, signal = 1)
# penalised multiscale statistic
identical(ret$maximum, computeStat(y, signal = 1, output = "maximum"))
# multiscale vector of penalised statistics
identical(ret$stat, computeStat(y, signal = 1, output = "vector"))

y &lt;- c(rnorm(50), rnorm(50, 1))
# true signal
computeStat(y, signal = list(leftIndex = c(1L, 51L), rightIndex = c(50L, 100L),
                             value = c(0, 1)))

# fit satisfies the multiscale contraint, i.e.
# the penalised multiscale statistic is not larger than the used global quantile 1
computeStat(y, signal = stepFit(y, q = 1), output = "maximum") &lt;= 1

# different interval system, lengths, penalty, given parameter sd
# and computed for an increased number of observations nq
computeStat(y, signal = list(leftIndex = c(1L, 51L), rightIndex = c(50L, 100L),
                             value = c(0, 1)), nq = 128, sd = 0.5,
            intervalSystem = "dyaLen", lengths = c(1L, 2L, 4L, 8L), penalty = "none")

# family "hsmuce"
computeStat(y, signal = mean(y), family = "hsmuce")

# family "mDependentPS"
signal &lt;- list(leftIndex = c(1L, 13L), rightIndex = c(12L, 17L), value = c(0, -1))
y &lt;- c(rep(0, 13), rep(-1, 4)) + 
  as.numeric(arima.sim(n = 17, list(ar = c(), ma = c(0.8, 0.5, 0.3)), sd = 1))
covariances &lt;- as.numeric(ARMAacf(ar = c(), ma = c(0.8, 0.5, 0.3), lag.max = 3))
computeStat(y, signal = signal, family = "mDependentPS", covariances = covariances)


</code></pre>

<hr>
<h2 id='contMC'>Continuous time Markov chain</h2><span id='topic+contMC'></span>

<h3>Description</h3>

<p>Simulate a continuous time Markov chain.
</p>
<p><b>Deprecation warning:</b> This function is mainly used for patchlamp recordings and may be transferred to a specialised package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contMC(n, values, rates, start = 1, sampling = 1, family = c("gauss", "gaussKern"),
  param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contMC_+3A_n">n</code></td>
<td>
<p>number of data points to simulate</p>
</td></tr>
<tr><td><code id="contMC_+3A_values">values</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying signal amplitudes for different states</p>
</td></tr>
<tr><td><code id="contMC_+3A_rates">rates</code></td>
<td>
<p>a square <code><a href="base.html#topic+matrix">matrix</a></code> matching the dimension of <code>values</code> each with <code>rates[i,j]</code> specifying the transition rate from state <code>i</code> to state <code>j</code>; the diagonal entries are ignored</p>
</td></tr>
<tr><td><code id="contMC_+3A_start">start</code></td>
<td>
<p>the state in which the Markov chain is started</p>
</td></tr>
<tr><td><code id="contMC_+3A_sampling">sampling</code></td>
<td>
<p>the sampling rate</p>
</td></tr>
<tr><td><code id="contMC_+3A_family">family</code></td>
<td>
<p>whether Gaussian white (<code>"gauss"</code>) or coloured (<code>"gaussKern"</code>), i.e. filtered, noise should be added; cf. <a href="#topic+family">family</a></p>
</td></tr>
<tr><td><code id="contMC_+3A_param">param</code></td>
<td>
<p>for <code>family="gauss"</code>, a single non-negative <code><a href="base.html#topic+numeric">numeric</a></code> specifying the standard deviation of the noise; for <code>family="gaussKern"</code>, <code>param</code> must be a list with entry <code>df</code> giving the <code><a href="#topic+dfilter">dfilter</a></code> object used for filtering, an <code><a href="base.html#topic+integer">integer</a></code> entry <code>over</code> which specifies the oversampling factor of the filter, i.e. <code>param$df</code> has to be created for a sampling rate of <code>sampling</code> times <code>over</code>, and an additional non-negative <code><a href="base.html#topic+numeric">numeric</a></code> entry <code>sd</code> specifying the noise's standard deviation <em>after</em> filtering; cf. <a href="#topic+family">family</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>cont</code></td>
<td>
<p>an object of class <code><a href="#topic+stepblock">stepblock</a></code> containing the simulated true values in continuous time, with an additional column <code>state</code> specifying the corresponding state</p>
</td></tr>
<tr><td><code>discr</code></td>
<td>
<p>an object of class <code><a href="#topic+stepblock">stepblock</a></code> containing the simulated true values reduced to discrete time, i.e. containing only the observable blocks</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns <code>x</code> and <code>y</code> containing the times and values of the simulated observations, respectively</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This follows the description for simulating ion channels given by VanDongen (1996).
</p>


<h3>References</h3>

<p>VanDongen, A. M. J. (1996) A new algorithm for idealizing single ion channel data containing multiple unknown conductance levels. <em>Biophysical Journal</em> <b>70</b>(3), 1303&ndash;1315.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepblock">stepblock</a></code>, <code><a href="#topic+jsmurf">jsmurf</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+steppath">steppath</a></code>, <code><a href="#topic+family">family</a></code>, <code><a href="#topic+dfilter">dfilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate filtered ion channel recording with two states
set.seed(9)
# sampling rate 10 kHz
sampling &lt;- 1e4
# tenfold oversampling
over &lt;- 10
# 1 kHz 4-pole Bessel-filter, adjusted for oversampling
cutoff &lt;- 1e3
df &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling / over))
# two states, leaving state 1 at 1 Hz, state 2 at 10 Hz
rates &lt;- rbind(c(0, 1e0), c(1e1, 0))
# simulate 5 s, level 0 corresponds to state 1, level 1 to state 2
# noise level is 0.1 after filtering
sim &lt;- contMC(5 * sampling, 0:1, rates, sampling=sampling, family="gaussKern",
  param = list(df=df, over=over, sd=0.1))
sim$cont
plot(sim$data, pch = ".")
lines(sim$discr, col = "red")
# noise level after filtering, estimated from first block
sd(sim$data$y[1:sim$discr$rightIndex[1]])
# show autocovariance in first block
acf(ts(sim$data$y[1:sim$discr$rightIndex[1]], freq=sampling), type = "cov")
# power spectrum in first block
s &lt;- spec.pgram(ts(sim$data$y[1:sim$discr$rightIndex[1]], freq=sampling), spans=c(200,90))
# cutoff frequency is where power spectrum is halved
abline(v=cutoff, h=s$spec[1] / 2, lty = 2)
</code></pre>

<hr>
<h2 id='critVal'>Critical values</h2><span id='topic+critVal'></span>

<h3>Description</h3>

<p>Computes the vector of critical values or the global quantile. This function offers two ways of computation, either at significance level <code>alpha</code> from a Monte-Carlo simulation, see also section 3.2 in the vignette for more details, or from the global quantile / critical values given in the argument <code>q</code>. For more details on these two options see Section <cite>Computation of critical values / global quantile</cite>.<br />
Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package saves them by default in the workspace and on the file system such that a second call requiring the same Monte-Carlo simulation will be much faster. For more details, in particular to which arguments the Monte-Carlo simulations are specific, see Section <cite>Storing of Monte-Carlo simulations</cite> below. Progress of a Monte-Carlo simulation can be reported by the argument <code>messages</code> in <code>...</code>, explained in <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>, and the saving can be controlled by the argument <code>option</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critVal(n, q = NULL, alpha = NULL, nq = 2L^(as.integer(log2(n) + 1e-12) + 1L) - 1L,
        family = NULL, intervalSystem = NULL, lengths = NULL, penalty = NULL,
        weights = NULL, stat = NULL, r = 1e4, output = c("vector", "value"),
        options = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critVal_+3A_n">n</code></td>
<td>
<p>a positive integer giving the number of observations</p>
</td></tr>
<tr><td><code id="critVal_+3A_q">q</code></td>
<td>
<p>either <code>NULL</code>, then the vector of critical values at level <code>alpha</code> will be computed from a Monte-Carlo simulation, or a numeric giving the global quantile or a numeric vector giving the vector of critical values. For more detailed information, in particular of which length the numeric vector should be, see Section <cite>Computation of critical values / global quantile</cite>. Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code>. Please note that by default the Monte-Carlo simulation will be saved in the workspace and on the file system, for more details see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> below</p>
</td></tr>
<tr><td><code id="critVal_+3A_alpha">alpha</code></td>
<td>
<p>a probability, i.e. a single numeric between 0 and 1, giving the significance level. Its choice is a trade-off between data fit and parsimony of the estimator. In other words, this argument balances the risks of missing change-points and detecting additional artefacts. For more details on this choice see (Frick et al., 2014, section 4) and (Pein et al., 2017, section 3.4). Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code></p>
</td></tr>
<tr><td><code id="critVal_+3A_nq">nq</code></td>
<td>
<p>a positive integer larger than or equal to <code>n</code> giving the (increased) number of observations for the Monte-Carlo simulation. See Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> for more details</p>
</td></tr>
<tr><td><code id="critVal_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, for more details see <a href="#topic+parametricFamily">parametricFamily</a>, currently <code>"gauss"</code>, <code>"hsmuce"</code> and <code>"mDependentPS"</code> are supported. By default (<code>NULL</code>) <code>"gauss"</code> is assumed</p>
</td></tr>
<tr><td><code id="critVal_+3A_intervalsystem">intervalSystem</code></td>
<td>
<p>a string giving the used interval system, either <code>"all"</code> for all intervals, <code>"dyaLen"</code> for all intervals of dyadic length or <code>"dyaPar"</code> for the dyadic partition, for more details see <a href="#topic+intervalSystem">intervalSystem</a>. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="critVal_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. Note that not all lengths are possible for all interval systems and for all parametric families, see <a href="#topic+intervalSystem">intervalSystem</a> and <a href="#topic+parametricFamily">parametricFamily</a>, respectively, to see which ones are allowed. By default (<code>NULL</code>) all lengths that are possible for the specified <code>intervalSystem</code> and for the specified parametric family will be used</p>
</td></tr>
<tr><td><code id="critVal_+3A_penalty">penalty</code></td>
<td>
<p>a string specifying how different scales will be balanced, either <code>"sqrt"</code>, <code>"weights"</code>, <code>"log"</code> or <code>"none"</code>, see <a href="#topic+penalty">penalty</a> and section 3.2 in the vignette for more details. By default (<code>NULL</code>) the default penalty of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="critVal_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of length <code>length(lengths)</code> with only positive entries giving the weights that will be used for penalty <code>"weights"</code>, see <a href="#topic+penalty">penalty</a> and section 3.2.2 in the vignette for more details. By default (<code>NULL</code>) equal weights will be used, i.e. </p>
<pre>weights == rep(1 / length(lengths), length(lengths))</pre></td></tr>
<tr><td><code id="critVal_+3A_stat">stat</code></td>
<td>
<p>an object of class <code>"MCSimulationVector"</code> or <code>"MCSimulationMaximum"</code> giving a Monte-Carlo simulations, usually computed by <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. If <code>penalty == "weights"</code> only <code>"MCSimulationVector"</code> is allowed. Has to be simulated for at least the given number of observations <code>n</code> and for the given <code>family</code>, <code>intervalSystem</code> and if <code>"MCSimulationMaximum"</code> for the given <code>lengths</code> and <code>penalty</code>. By default (<code>NULL</code>) the required simulation will be made available automatically accordingly to the given <code>options</code>. For more details see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> and section 3.4 in the vignette</p>
</td></tr>
<tr><td><code id="critVal_+3A_r">r</code></td>
<td>
<p>a positive integer giving the required number of Monte-Carlo simulations if they will be simulated or loaded from the workspace or the file system</p>
</td></tr>
<tr><td><code id="critVal_+3A_output">output</code></td>
<td>
<p>a string specifying the return value, if <code>output == "vector"</code> the vector of critical values will be computed and if <code>output == "value"</code> the global quantile will be computed. For <code>penalty == "weights"</code> the output must be <code>"vector"</code>, since no global quantile can be determined for this penalty</p>
</td></tr>
<tr><td><code id="critVal_+3A_options">options</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> specifying how Monte-Carlo simulations will be simulated, saved and loaded. For more details see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> and section 3.4 in the vignette</p>
</td></tr>
<tr><td><code id="critVal_+3A_...">...</code></td>
<td>
<p>there are two groups of further arguments:
</p>

<ul>
<li><p> further parameters of the parametric family. Depending on the argument <code>family</code> some might be required, but others might be optional, please see <a href="#topic+parametricFamily">parametricFamily</a> for more details
</p>
</li>
<li><p> further arguments (<code>seed</code>, <code>rand.gen</code> and <code>messages</code>) that will be passed to <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> will be called automatically and most of the arguments will be set accordingly to the arguments of <code>critVal</code>, no user interaction is required and possible for these parameters. In addition, <code>seed</code>, <code>rand.gen</code> and <code>messages</code> can be passed by the user
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output == "vector"</code> a numeric vector giving the vector of critical values, i.e. a vector of length <code>length(lengths)</code>, giving for each length the corresponding critical value. If <code>output == "value"</code> a single numeric giving the global quantile. In both cases, additionally, an <code><a href="base.html#topic+attributes">attribute</a></code> <code>"n"</code> gives the number of observations for which the Monte-Carlo simulation was performed.
</p>


<h3>Computation of critical values / global quantile</h3>

<p>This function offers two ways to compute the resulting value:
</p>

<ul>
<li><p> If <code>q == NULL</code> it will be computed at significance level <code>alpha</code> from a Monte-Carlo simulation. For penalties <code>"sqrt"</code>, <code>"log"</code> and <code>"none"</code> the global quantile will be the (<code>1-alpha</code>)-quantile of the penalised multiscale statistic, see section 3.2.1 in the vignette. And if required the vector of critical values will be derived from it. For penalty <code>"weights"</code> the vector of critical values will be calculated accordingly to the given <code>weights</code>. The Monte-Carlo simulation can either be given in <code>stat</code> or will be attempted to load or will be simulated. How Monte-Carlo simulations are simulated, saved and loaded can be controlled by the argument <code>option</code>, for more details see the Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite>.
</p>
</li>
<li><p> If <code>q</code> is given it will be derived from it. For the argument <code>q</code> either a single finite numeric giving the global quantile or a vector of finite numerics giving the vector of critical values (not allowed for <code>output == "value"</code>) is possible:
</p>

<ul>
<li><p> A single numeric giving the global quantile. If <code>output == "vector"</code> the vector of critical values will be computed from it for the given <code>lengths</code> and <code>penalty</code> (penalty <code>"weights"</code> is not allowed). Note that the global quantile is specific to the arguments <code>family</code>, <code>intervalSystem</code>, <code>lengths</code> and <code>penalty</code>.
</p>
</li>
<li><p> A vector of length <code>length(lengths)</code>, giving for each length the corresponding critical value. This vector is identical to the vector of critical values.
</p>
</li>
<li><p> A vector of length <code>n</code> giving for each length <code>1:n</code> the corresponding critical value.
</p>
</li>
<li><p> A vector of length equal to the number of all possible lengths for the given interval system and the given parametric family giving for each possible length the corresponding critical value.
</p>
</li></ul>

<p>Additionally, an <code><a href="base.html#topic+attributes">attribute</a></code> <code>"n"</code> giving the number of observations for which <code>q</code> was computed is allowed. This <code><a href="base.html#topic+attributes">attribute</a></code> must be a single integer and equal to or larger than the argument <code>n</code> which means that <code>q</code> must have been computed for at least <code>n</code> observations. This allows additionally:
</p>

<ul>
<li><p> A vector of length <code>attr(q, "n")</code> giving for each length <code>1:attr(q, "n")</code> the corresponding critical value.
</p>
</li>
<li><p> A vector of length equal to the number of all possible lengths for the given interval system and the given parametric family if the number of observations is <code>attr(q, "n")</code> giving for each possible length the corresponding critical value.
</p>
</li></ul>

<p>The <code><a href="base.html#topic+attributes">attribute</a></code> <code>"n"</code> will be kept or set to <code>n</code> if missing.
</p>
</li></ul>



<h3>Simulating, saving and loading of Monte-Carlo simulations</h3>

<p>Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this function offers multiple possibilities for saving and loading the simulations. The simulation, saving and loading can be controlled by the argument <code>option</code>. This argument has to be a <code><a href="base.html#topic+list">list</a></code> or <code>NULL</code> and the following named entries are allowed: <code>"simulation"</code>, <code>"save"</code>, <code>"load"</code>, <code>"envir"</code> and <code>"dirs"</code>. All missing entries will be set to their default option.<br />
Objects of class <code>"MCSimulationVector"</code>, containing simulations of the multiscale vector of statistics, and objects of class <code>"MCSimulationMaximum"</code>, containing simulations of the penalised multiscale statistic (for penalties <code>"sqrt"</code>, <code>"log"</code> and <code>"none"</code>), can be simulated, saved and loaded. Each Monte-Carlo simulation is specific to the number of observations, the parametric family and the interval system, for <code>"MCSimulationMaximum"</code> additionally to the set of lengths and the used penalty. Both types will lead to the same result, however, an object of class <code>"MCSimulationVector"</code> is more flexible, since critical values for all penalties and all set of lengths can be derived from it, but requires much more storage space and has slightly larger saving and loading times. Note that Monte-Carlo simulations can only be saved and loaded if they are generated with the default function for generating random observations, i.e. when <code>rand.gen</code> (in <code>...</code>) is <code>NULL</code>. For a given simulation this is signalled by the <code><a href="base.html#topic+attributes">attribute</a></code> <code>"save"</code> which is <code>TRUE</code> if a simulation can be saved and <code>FALSE</code> otherwise.<br />
Monte-Carlo simulations can also be performed for a (slightly) larger number of observations <code class="reqn">n_q</code> given in the argument <code>nq</code>, which avoids extensive resimulations for only a little bit varying number of observations. The overestimation control is still satisfied but the detection power is (slightly) smaller. But note that the default <code>lengths</code> might change when the number of observations is increased and, hence, for type <code>"vectorIncreased"</code> still a different simulation might be required.<br />
We refer to the different types as follow:
</p>

<ul>
<li> <p><code>"vector"</code>: an object of class <code>"MCSimulationMaximum"</code>, i.e. simulations of the penalized multiscale statistic, for <code>n</code> observations
</p>
</li>
<li> <p><code>"vectorIncreased"</code>: an object of class <code>"MCSimulationMaximum"</code>, i.e. simulations of the penalized multiscale statistic, for <code>nq</code> observations
</p>
</li>
<li> <p><code>"matrix"</code>: an object of class <code>"MCSimulationVector"</code>, i.e. simulations of the multiscale vector of statistics, for <code>n</code> observations
</p>
</li>
<li> <p><code>"matrixIncreased"</code>: an object of class <code>"MCSimulationVector"</code>, i.e. simulations of the multiscale vector of statistics, for <code>nq</code> observations
</p>
</li></ul>

<p>The simulations can either be saved in the workspace in the variable <code>critValStepRTab</code> or persistently on the file system for which the package <code><a href="R.cache.html#topic+R.cache">R.cache</a></code> is used. Loading from the workspace is faster, but either the user has to store the workspace manually or in a new session simulations have to be performed again. Moreover, storing in and loading from variables and <a href="base.html#topic+readRDS">RDS</a> files is supported. Finally, a pre-computed collection of simulations of type <code>"matrixIncreased"</code> for parametric families <code>"gauss"</code> and <code>"hsmuce"</code> can be accessed by installing the package <code>stepRdata</code> available from <a href="http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz">http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz</a>.<br />
</p>


<h4>options$envir and options$dirs</h4>

<p>For loading from / saving in the workspace the variable <code>critValStepRTab</code> in the <code><a href="base.html#topic+environment">environment</a></code> <code>options$envir</code> will be looked for and if missing in case of saving also created there. Moreover, the variable(s) specified in <code>options$save$variable</code> (explained in the Subsection <cite>Saving: options$save</cite>) will be assigned to this <code><a href="base.html#topic+environment">environment</a></code>. <code>options$envir</code> will be passed to the arguments <code>pos</code> and <code>where</code> in the functions <code><a href="base.html#topic+assign">assign</a></code>, <code><a href="base.html#topic+get">get</a></code>, and <code><a href="base.html#topic+exists">exists</a></code>, respectively. By default, a local enviroment in the package is used.<br />
For loading from / saving on the file system <code><a href="R.cache.html#topic+loadCache">loadCache</a>(key = keyList, dirs = options$dirs)</code> and <code><a href="R.cache.html#topic+saveCache">saveCache</a>(stat, key = attr(stat, "keyList"), dirs = options$dirs)</code> are called, respectively. In other words, <code>options$dirs</code> has to be a <code><a href="base.html#topic+character">character</a></code> <code><a href="base.html#topic+vector">vector</a></code> constituting the path to the cache subdirectory relative to the cache root directory as returned by <code><a href="R.cache.html#topic+getCacheRootPath">getCacheRootPath</a></code>(). If <code>options$dirs == ""</code> the path will be the cache root path. By default the subdirectory <code>"stepR"</code> is used, i.e. <code>options$dirs == "stepR"</code>. Missing directories will be created.
</p>



<h4>Simulation: options$simulation</h4>

<p>Whenever Monte-Carlo simulations have to be performed, i.e. when <code>stat == NULL</code> and the required Monte-Carlo simulation could not be loaded, the type specified in <code>options$simulation</code> will be simulated by <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. In other words, <code>options$simulation</code> must be a single string of the following: <code>"vector"</code>, <code>"vectorIncreased"</code>, <code>"matrix"</code> or <code>"matrixIncreased"</code>. By default (<code>options$simulation == NULL</code>), an object of class <code>"MCSimulationVector"</code> for <code>nq</code> observations will be simulated, i.e. <code>options$simulation</code> <code>== "matrixIncreased"</code>. For this choice please recall the explanations regarding computation time and flexibility at the beginning of this section.
</p>



<h4>Loading: options$load</h4>

<p>Loading of the simulations can be controlled by the entry <code>options$load</code> which itself has to be a <code><a href="base.html#topic+list">list</a></code> with possible entries: <code>"RDSfile"</code>, <code>"workspace"</code>, <code>"package"</code> and <code>"fileSystem"</code>. Missing entries disable the loading from this option.
Whenever a Monte-Carlo simulation is required, i.e. when the variable <code>q</code> is not given, it will be searched for at the following places in the given order until found:
</p>

<ol>
<li><p> in the variable <code>stat</code>,
</p>
</li>
<li><p> in <code>options$load$RDSfile</code> as an <a href="base.html#topic+readRDS">RDS</a> file, i.e. the simulation will be loaded by </p>
<pre>readRDS(options$load$RDSfile).</pre><p> In other words, <code>options$load$RDSfile</code> has to be a <code><a href="base.html#topic+connection">connection</a></code> or the name of the file where the <span class="rlang"><b>R</b></span> object is read from,
</p>
</li>
<li><p> in the workspace or on the file system in the following order: <code>"vector"</code>, <code>"matrix"</code>, <code>"vectorIncreased"</code> and finally of <code>"matrixIncreased"</code>. For <code>penalty == "weights"</code> it will only be looked for <code>"matrix"</code> and <code>"matrixIncreased"</code>. For each options it will first be looked in the workspace and then on the file system. All searches can be disabled by not specifying the corresponding string in <code>options$load$workspace</code> and <code>options$load$fileSystem</code>. In other words, <code>options$load$workspace</code> and <code>options$load$fileSystem</code> have to be vectors of strings containing none, some or all of <code>"vector"</code>, <code>"matrix"</code>, <code>"vectorIncreased"</code> and <code>"matrixIncreased"</code>,
</p>
</li>
<li><p> in the package <code>stepRdata</code> (if installed) and if <code>options$load$package == TRUE</code>. In other words, <code>options$load$package</code> must be a single logical or <code>NULL</code>,
</p>
</li>
<li><p> if all other options fail a Monte-Carlo simulation will be performed.
</p>
</li></ol>

<p>By default (if <code>options$load</code> is missing / <code>NULL</code>) no <a href="base.html#topic+readRDS">RDS</a> file is specified and all other options are enabled, i.e. </p>
<pre>
options$load &lt;- list(workspace = c("vector", "vectorIncreased",
                                   "matrix", "matrixIncreased"),
                     fileSystem = c("vector", "vectorIncreased",
                                    "matrix", "matrixIncreased"),
                     package = TRUE, RDSfile = NULL).</pre>



<h4>Saving: options$save</h4>

<p>Saving of the simulations can be controlled by the entry <code>options$save</code> which itself has to be a <code><a href="base.html#topic+list">list</a></code> with possible entries: <code>"workspace"</code>, <code>"fileSystem"</code>, <code>"RDSfile"</code> and <code>"variable"</code>. Missing entries disable the saving in this option.<br />
All available simulations, no matter whether they are given by <code>stat</code>, loaded, simulated or in case of <code>"vector"</code> and <code>"vectorIncreased"</code> computed from <code>"matrix"</code> and <code>"matrixIncreased"</code>, respectively, will be saved in all options for which the corresponding type is specified. Here we say a simulation is of type <code>"vectorIncreased"</code> or <code>"matrixIncreased"</code> if the simulation is not performed for <code>n</code> observations. More specifically, a simulation will be saved:
</p>

<ol>
<li><p> in the workspace or on the file system if the corresponding string is contained in <code>options$save$workspace</code> and <code>options$save$fileSystem</code>, respectively. In other words, <code>options$save$workspace</code> and <code>options$save$fileSystem</code> have to be vectors of strings containing none, some or all of <code>"vector"</code>, <code>"matrix"</code>, <code>"vectorIncreased"</code> and <code>"matrixIncreased"</code>,
</p>
</li>
<li><p> in an <a href="base.html#topic+readRDS">RDS</a> file specified by <code>options$save$RDSfile</code> which has to be a vector of one or two <code><a href="base.html#topic+connection">connections</a></code> or names of files where the <span class="rlang"><b>R</b></span> object is saved to. If <code>options$save$RDSfile</code> is of length two a simulation of type <code>"vector"</code> or <code>"vectorIncreased"</code> (only one can occur at one function call) will be saved in <code>options$save$RDSfile[1]</code> by </p>
<pre>saveRDS(stat, file = options$save$RDSfile[1])</pre><p> and <code>"matrix"</code> or <code>"matrixIncreased"</code> (only one can occur at one function call) will be saved in <code>options$save$RDSfile[2]</code>. If <code>options$save$RDSfile</code> is of length one both will be saved in <code>options$save$RDSfile</code> which means if both occur at the same call only <code>"vector"</code> or <code>"vectorIncreased"</code> will be saved. Each saving can be disabled by not specifying <code>options$save$RDSfile</code> or by passing an empty string to the corresponding entry of <code>options$save$RDSfile</code>.
</p>
</li>
<li><p> in a variable named by <code>options$save$variable</code> in the <code><a href="base.html#topic+environment">environment</a></code> <code>options$envir</code>. Hence, <code>options$save$variable</code> has to be a vector of one or two containing variable names (character vectors). If <code>options$save$variable</code> is of length two a simulation of type <code>"vector"</code> or <code>"vectorIncreased"</code> (only one can occur at one function call) will be saved in <code>options$save$variable[1]</code> and <code>"matrix"</code> or <code>"matrixIncreased"</code> (only one can occur at one function call) will be saved in <code>options$save$variable[2]</code>. If <code>options$save$variable</code> is of length one both will be saved in <code>options$save$variable</code> which means if both occur at the same call only <code>"vector"</code> or <code>"vectorIncreased"</code> will be saved. Each saving can be disabled by not specifying <code>options$save$variable</code> or by passing <code>""</code> to the corresponding entry of <code>options$save$variable</code>.
</p>
</li></ol>

<p>By default (if <code>options$save</code> is missing) <code>"vector"</code> and <code>"vectorIncreased"</code> will be saved in the workspace and <code>"matrix"</code> and <code>"matrixIncreased"</code> on the file system, i.e. </p>
<pre>
options$save &lt;- list(workspace = c("vector", "vectorIncreased"),
                     fileSystem = c("matrix", "matrixIncreased"),
                     RDSfile = NULL, variable = NULL).</pre>
<p>Simulations can be removed from the workspace by removing the variable <code>critValStepRTab</code>, i.e. by calling <code>remove(critValStepRTab, envir = envir)</code>, with <code>envir</code> the used environment, and from the file system by deleting the corresponding subfolder, i.e. by calling </p>
<pre>unlink(file.path(R.cache::getCacheRootPath(), dirs), recursive = TRUE),</pre><p> with <code>dirs</code> the corresponding subdirectory.
</p>



<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>, <code><a href="#topic+penalty">penalty</a></code>, <code><a href="#topic+parametricFamily">parametricFamily</a></code>, <code><a href="#topic+intervalSystem">intervalSystem</a></code>, <code><a href="#topic+stepFit">stepFit</a></code>, <code><a href="#topic+computeBounds">computeBounds</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# vector of critical values
qVector &lt;- critVal(100L, alpha = 0.5)
# global quantile
qValue &lt;- critVal(100L, alpha = 0.5, output = "value")

# vector can be computed from the global quantile
identical(critVal(100L, q = qValue), qVector)

# for a conservative significance level, stronger confidence statements
critVal(100L, alpha = 0.05)
critVal(100L, alpha = 0.05, output = "value")

# higher significance level for larger detection power, but less confidence
critVal(100L, alpha = 0.99)
critVal(100L, alpha = 0.99, output = "value")

# different parametric family, different intervalSystem, a subset of lengths,
# different penalty and given weights
q &lt;- critVal(100L, alpha = 0.05, family = "hsmuce", intervalSystem = "dyaLen",
             lengths = c(2L, 4L, 16L, 32L), penalty = "weights",
             weights = c(0.4, 0.3, 0.2, 0.1))

# vector of critical values can be given by a vector of length n
vec &lt;- 1:100
vec[c(2L, 4L, 16L, 32L)] &lt;- q
attr(vec, "n") &lt;- 128L
identical(critVal(100L, q = vec, family = "hsmuce", intervalSystem = "dyaLen",
                  lengths = c(2L, 4L, 16L, 32L)), q)

# with a given monte-Carlo simulation for nq = 128 observations
stat &lt;- monteCarloSimulation(128)
critVal(n = 100L, alpha = 0.05, stat = stat)

# the above calls saved and (attempted to) load Monte-Carlo simulations and
# simulated them for nq = 128 observations
# in the following call no saving, no loading and simulation for n = 100
# observations is required, progress of the simulation will be reported
critVal(n = 100L, alpha = 0.05, messages = 1000L,
        options = list(simulation = "vector", load = list(), save = list()))

# only type "vector" will be saved and loaded in the workspace
critVal(n = 100L, alpha = 0.05, messages = 1000L,
        options = list(simulation = "vector", load = list(workspace = "vector"),
                       save = list(workspace = "vector")))

# simulation of type "matrix" will be saved in a RDS file
# saving of type "vector" is disabled by passing "",
# different seed is set and number of simulations is reduced to r = 1e3
# to allow faster computation at the price of a less precise result
file &lt;- tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".RDS")
critVal(n = 100L, alpha = 0.05, seed = 1, r = 1e3,
        options = list(simulation = "matrix", load = list(),
                       save = list(RDSfile = c("", file))))
identical(readRDS(file), monteCarloSimulation(100L, seed = 1, r = 1e3))



</code></pre>

<hr>
<h2 id='dfilter'>Digital filters</h2><span id='topic+dfilter'></span><span id='topic+print.dfilter'></span>

<h3>Description</h3>

<p>Create digital filters.
</p>
<p><b>Deprecation warning:</b> This function is mainly used for patchlamp recordings and may be transferred to a specialised package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfilter(type = c("bessel", "gauss", "custom"), param = list(pole = 4, cutoff = 1 / 10),
  len = ceiling(3/param$cutoff))
## S3 method for class 'dfilter'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfilter_+3A_type">type</code></td>
<td>
<p>allows to choose Bessel, Gauss or custom filters</p>
</td></tr>
<tr><td><code id="dfilter_+3A_param">param</code></td>
<td>
<p>for a <code>"bessel"</code> filter a <code><a href="base.html#topic+list">list</a></code> with entries <code>pole</code> and <code>cutoff</code> giving the filter's number of poles (order) and cut-off frequency, resp.; for a <code>"gauss"</code> filter the filter's bandwidth (standard deviation) as a single <code><a href="base.html#topic+numeric">numeric</a></code>; for a custom filter either a <code><a href="base.html#topic+numeric">numeric</a></code> vector specifying the filter's kernel or a list with items <code>kern</code> and <code>step</code> of the same length giving the filter's kernel and step-response, resp.</p>
</td></tr>
<tr><td><code id="dfilter_+3A_len">len</code></td>
<td>
<p>filter length (unnecessary for <code>"custom"</code> filters</p>
</td></tr>
<tr><td><code id="dfilter_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="dfilter_+3A_...">...</code></td>
<td>
<p>for generic methods only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of <code><a href="base.html#topic+class">class</a></code> <code>dfilter</code> that contains elements <code>kern</code> and <code>step</code>, the (digitised) filter kernel and step-response, resp., as well as an element <code>param</code> containing the argument <code>param</code>, for a <code>"bessel"</code> filter alongside the corresponding analogue kernel, step response, power spectrum, and autocorrelation function depending on time or frequency as elements <code>kernfun</code>, <code>stepfun</code>, <code>spectrum</code>, and <code>acfun</code>, resp.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+filter">filter</a></code>, <code><a href="stats.html#topic+convolve">convolve</a></code>, <code><a href="#topic+BesselPolynomial">BesselPolynomial</a></code>, <code><a href="stats.html#topic+Normal">Normal</a></code>, <a href="#topic+family">family</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># 6-pole Bessel filter with cut-off frequency 1 / 100, with length 100 (too short!)
dfilter("bessel", list(pole = 6, cutoff = 1 / 100), 100)
# custom filter: running mean of length 3
dfilter("custom", rep(1, 3))
dfilter("custom", rep(1, 3))$kern # normalised!
dfilter("custom", rep(1, 3))$step
# Gaussian filter with bandwidth 3 and length 11 (from -5 to 5)
dfilter("gauss", 3, 11)
</code></pre>

<hr>
<h2 id='family'>Family of distributions</h2><span id='topic+family'></span>

<h3>Description</h3>

<p>Families of distributions supported by package <code>stepR</code>.
</p>
<p><b>Deprecation warning:</b> This overviw is deprecated, but still given and up to date for some older, deprecated functions, however, may be removed in a future version. For an overview about the parametric families supported by the new functions see <code><a href="#topic+parametricFamily">parametricFamily</a></code>.
</p>


<h3>Details</h3>

<p>Package <code>stepR</code> supports several families of distributions (mainly exponential) to model the data, some of which require additional (fixed) parameters. In particular, the following families are available:
</p>

<dl>
<dt><code>"gauss"</code></dt><dd><p>normal distribution with unknown mean but known, fixed standard deviation given as a single <code><a href="base.html#topic+numeric">numeric</a></code> (will be estimated using <code><a href="#topic+sdrobnorm">sdrobnorm</a></code> if omitted); cf. <code><a href="stats.html#topic+dnorm">dnorm</a></code>.</p>
</dd>
<dt><code>"gaussvar"</code></dt><dd><p>normal distribution with unknown variance but known, fixed mean assumed to be zero; cf. <code><a href="stats.html#topic+dnorm">dnorm</a></code>.</p>
</dd>
<dt><code>"poisson"</code></dt><dd><p>Poisson distribution with unknown intensity (no additional parameter); cf. <code><a href="stats.html#topic+dpois">dpois</a></code>.</p>
</dd>
<dt><code>"binomial"</code></dt><dd><p>binomial distribution with unknown success probability but known, fixed size given as a single <code><a href="base.html#topic+integer">integer</a></code>; cf. <code><a href="stats.html#topic+dbinom">dbinom</a></code>.</p>
</dd>
<dt><code>"gaussKern"</code></dt><dd><p>normal distribution with unknown mean and unknown, fixed standard deviation (being estimated using <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>), after filtering with a fixed filter which needs to be given as the additional parameter (a <code><a href="#topic+dfilter">dfilter</a></code> object); cf. <code><a href="#topic+dfilter">dfilter</a></code>.</p>
</dd>
</dl>

<p>The family is selected via the <code>family</code> argument, providing the corresponding string, while the <code>param</code> argument contains the parameters if any.
</p>


<h3>Note</h3>

<p>Beware that not all families can be chosen for all functions.</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a>, <code><a href="#topic+parametricFamily">parametricFamily</a></code>, <code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dpois">dpois</a></code>, <code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="#topic+dfilter">dfilter</a></code>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># illustrating different families fitted to the same binomial data set
size &lt;- 200
n &lt;- 200
# truth
p &lt;- 10^seq(-3, -0.1, length = n)
# data
y &lt;- rbinom(n, size, p)
plot(y)
lines(size * p, col = "red")
# fit 4 jumps, binomial family
jumps &lt;- 4
bfit &lt;- steppath(y, family = "binomial", param = size, max.blocks = jumps)
lines(bfit[[jumps]], col = "orange")
# Gaussian approximation with estimated variance
gfit &lt;- steppath(y, family = "gauss", max.blocks = jumps)
lines(gfit[[jumps]], col = "green3", lty = 2)
# Poisson approximation
pfit &lt;- steppath(y, family = "poisson", max.blocks = jumps)
lines(pfit[[jumps]], col = "blue", lty = 2)
legend("topleft", legend = c("binomial", "gauss", "poisson"), lwd = 2,
  col = c("orange", "green3", "blue"))
</code></pre>

<hr>
<h2 id='intervalSystem'>Interval systems</h2><span id='topic+intervalSystem'></span><span id='topic+intervalsystem'></span>

<h3>Description</h3>

<p>Overview about the supported interval systems. More details are given in section 6 of the vignette.
</p>


<h3>Details</h3>

<p>The following interval systems (set of intervals on which tests will be performed) are available. Intervals are given as indices of observations / sample points.
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>all intervals. More precisely, the set <code class="reqn">\{[i, j], 1 \leq i \leq j \leq n\}</code>. This system allows all lengths <code>1:n</code>.</p>
</dd>
<dt><code>"dyaLen"</code></dt><dd><p>all intervals of dyadic length. More precisely, the set <code class="reqn">\{[i, j], 1 \leq i \leq j \leq n\ s.t.\ j - i + 1 = 2^k,\ k\in N_0\}</code>. This system allows all lengths of dyadic length <code>2^(0:as.integer(floor(log2(n)) + 1e-6))</code>.</p>
</dd>
<dt><code>"dyaPar"</code></dt><dd><p>the dyadic partition, i.e. all disjoint intervals of dyadic length. More precisely, the set <code class="reqn">\{[(i - 1) * 2^k + 1, i * 2^k], i = 1,\ldots, \lfloor n / 2^k\rfloor,\ k = 0, \ldots, \lfloor\log_2(n)\rfloor\}</code>. This system allows all lengths of dyadic length <code>2^(0:as.integer(floor(log2(n)) + 1e-6))</code>.</p>
</dd>
</dl>

<p>The interval system is selected via the <code>intervalSystem</code> argument, providing the corresponding string. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code>. With the additional argument <code>lengths</code> it is possible to specify a set of lengths such that only tests on intervals with a length contained in this set will be performed. The set of lengths has to be a subset of all lengths that are allowed by the interval system and the parametric family. By default (<code>NULL</code>) all lengths allowed by the interval system and the parametric family are used.
</p>


<h3>See Also</h3>

<p><a href="#topic+parametricFamily">parametricFamily</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

y &lt;- c(rnorm(50), rnorm(50, 2))

# interval system of all intervals and all lengths
fit &lt;- stepFit(y, alpha = 0.5, intervalSystem = "all", lengths = 1:100,
               jumpint = TRUE, confband = TRUE)

# default for family "gauss" if number of observations is 1000 or less
identical(stepFit(y, alpha = 0.5, jumpint = TRUE, confband = TRUE), fit)

# intervalSystem "dyaLen" and a subset of lengths
!identical(stepFit(y, alpha = 0.5, intervalSystem = "dyaLen", lengths = c(2, 4, 16),
                   jumpint = TRUE, confband = TRUE), fit)

# default for lengths are all possible lengths of the interval system
# and the parametric family
identical(stepFit(y, alpha = 0.5, intervalSystem = "dyaPar",
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, alpha = 0.5, intervalSystem = "dyaPar", lengths = 2^(0:6),
                  jumpint = TRUE, confband = TRUE))

# interval system "dyaPar" is default for parametric family "hsmuce"
# length 1 is not possible for this parametric family
identical(stepFit(y, alpha = 0.5, family = "hsmuce",
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, alpha = 0.5, family = "hsmuce", intervalSystem = "dyaPar",
                  lengths = 2^(1:6), jumpint = TRUE, confband = TRUE))

# interval system "dyaLen" is default for parametric family "mDependentPS"
identical(stepFit(y, alpha = 0.5, family = "mDependentPS", covariances = c(1, 0.5),
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, alpha = 0.5, family = "mDependentPS", covariances = c(1, 0.5),
                  intervalSystem = "dyaLen", lengths = 2^(0:6),
                  jumpint = TRUE, confband = TRUE))



</code></pre>

<hr>
<h2 id='jsmurf'>Reconstruct filtered piecewise constant functions with noise</h2><span id='topic+jsmurf'></span>

<h3>Description</h3>

<p>Reconstructs a piecewise constant function to which white noise was added and the sum filtered afterwards.
</p>
<p><b>Deprecation warning:</b> This function is mainly used for patchlamp recordings and may be transferred to a specialised package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsmurf(y, x = 1:length(y), x0 = 2 * x[1] - x[2], q, alpha = 0.05, r = 4e3,
  lengths = 2^(floor(log2(length(y))):floor(log2(max(length(param$kern) + 1,
    1 / param$param$cutoff)))), param, rm.out = FALSE,
    jumpint = confband, confband = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsmurf_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_q">q</code></td>
<td>
<p>threshold value, by default chosen automatically</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_alpha">alpha</code></td>
<td>
<p>significance level; if set to a value in (0,1), <code>q</code> is chosen as the corresponding quantile of the asymptotic (if <code>r</code> is not given) null distribution (and any value specified for <code>q</code> is silently ignored)</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_r">r</code></td>
<td>
<p>numer of simulations; if specified along <code>alpha</code>, <code>q</code> is chosen as the corresponding quantile of the simulated null distribution</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_lengths">lengths</code></td>
<td>
<p>length of intervals considered; by default up to a sample size of 1000 all lengths, otherwise only dyadic lengths</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_param">param</code></td>
<td>
<p>a <code><a href="#topic+dfilter">dfilter</a></code> object specifiying the filter</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_rm.out">rm.out</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> specifying whether outliers should be removed prior to the analysis</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_jumpint">jumpint</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> (<code>FALSE</code> by default), indicates if confidence sets for jumps should be computed</p>
</td></tr>
<tr><td><code id="jsmurf_+3A_confband">confband</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, indicates if a confidence band for the piecewise-continuous function should be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object object of class <code><a href="#topic+stepfit">stepfit</a></code> that contains the fit; if <code>jumpint == TRUE</code> function <code><a href="#topic+jumpint">jumpint</a></code> allows to extract the <code>1 - alpha</code> confidence interval for the jumps, if <code>confband == TRUE</code> function <code><a href="#topic+confband">confband</a></code> allows to extract the <code>1 - alpha</code> confidence band.
</p>


<h3>References</h3>

<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing ion channel recordings by a jump segmentation multiresolution filter. <em>IEEE Transactions on NanoBioscience</em> <b>12</b>(4), 376&ndash;386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+bounds">bounds</a></code>, <a href="#topic+family">family</a>, <code><a href="#topic+MRC.asymptotic">MRC.asymptotic</a></code>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>, <code><a href="#topic+stepfit">stepfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate filtered ion channel recording with two states
set.seed(9)
# sampling rate 10 kHz
sampling &lt;- 1e4
# tenfold oversampling
over &lt;- 10
# 1 kHz 4-pole Bessel-filter, adjusted for oversampling
cutoff &lt;- 1e3
df.over &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling / over))
# two states, leaving state 1 at 10 Hz, state 2 at 20 Hz
rates &lt;- rbind(c(0, 10), c(20, 0))
# simulate 0.5 s, level 0 corresponds to state 1, level 1 to state 2
# noise level is 0.3 after filtering
sim &lt;- contMC(0.5 * sampling, 0:1, rates, sampling=sampling, family="gaussKern",
  param = list(df=df.over, over=over, sd=0.3))
plot(sim$data, pch = ".")
lines(sim$discr, col = "red")
# fit using filter corresponding to sample rate
df &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling))
fit &lt;- jsmurf(sim$data$y, sim$data$x, param=df, r=1e2)
lines(fit, col = "blue")
# fitted values take filter into account
lines(sim$data$x, fitted(fit), col = "green3", lty = 2)
</code></pre>

<hr>
<h2 id='jumpint'>Confidence intervals for jumps and confidence bands for step functions</h2><span id='topic+jumpint'></span><span id='topic+jumpint.stepfit'></span><span id='topic+points.jumpint'></span><span id='topic+confband'></span><span id='topic+confband.stepfit'></span><span id='topic+lines.confband'></span>

<h3>Description</h3>

<p>Extract and plot confidence intervals and bands from fits given by a <code><a href="#topic+stepfit">stepfit</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jumpint(sb, ...)
## S3 method for class 'stepfit'
jumpint(sb, ...)
## S3 method for class 'jumpint'
points(x, pch.left = NA, pch.right = NA, y.left = NA, y.right = NA, xpd = NA, ...)
confband(sb, ...)
## S3 method for class 'stepfit'
confband(sb, ...)
## S3 method for class 'confband'
lines(x, dataspace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jumpint_+3A_sb">sb</code></td>
<td>
<p>the result of a fit by <code><a href="#topic+stepbound">stepbound</a></code></p>
</td></tr>
<tr><td><code id="jumpint_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="jumpint_+3A_pch.left">pch.left</code>, <code id="jumpint_+3A_pch.right">pch.right</code></td>
<td>
<p>the plotting character to use for the left/right end of the interval with defaults <code>"("</code> and <code>"]"</code> (see parameter <code>pch</code> of <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="jumpint_+3A_y.left">y.left</code>, <code id="jumpint_+3A_y.right">y.right</code></td>
<td>
<p>at which height to plot the interval boundaries with default <code><a href="graphics.html#topic+par">par</a>()$usr[3]</code></p>
</td></tr>
<tr><td><code id="jumpint_+3A_xpd">xpd</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="jumpint_+3A_dataspace">dataspace</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> determining whether the expected value should be plotted instead of the fitted parameter value, useful e.g. for <code>family = "binomial"</code>, where it will plot the fitted success probability times the number of trials per observation</p>
</td></tr>
<tr><td><code id="jumpint_+3A_...">...</code></td>
<td>
<p>arguments to be passed to generic methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>jumpint</code> an object of class <code>jumpint</code>, i.e. a <code><a href="base.html#topic+data.frame">data.frame</a></code> whose columns <code>rightEndLeftBound</code> and <code>rightEndRightBound</code> specify the left and right end of the confidence interval for the block's right end, resp., given the number of blocks was estimated correctly, and similarly columns <code>rightIndexLeftBound</code> and <code>rightIndexRightBound</code> specify the left and right indices of the confidence interval, resp. Function <code><a href="graphics.html#topic+points">points</a></code> plots these intervals on the lower horizontal axis (by default).
</p>
<p>For <code>confband</code> an object of class <code>confband</code>, i.e. a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns <code>lower</code> and <code>upper</code> specifying a confidence band computed at every point <code>x</code>; this is a simultaneous confidence band assuming the true number of jumps has been determined. Function <code><a href="graphics.html#topic+lines">lines</a></code> plots the confidence band.
</p>


<h3>Note</h3>

<p>Observe that jumps may occur immediately before or after an observed <code>x</code>; this lack of knowledge is reflected in the visual impressions by the lower and upper envelopes jumping vertically early, so that possible jumps between <code>x</code>s remain within the band, and by the confidence intervals starting immediately after the last <code>x</code> for which there cannot be a jump, cf. the note in the help for <code><a href="#topic+stepblock">stepblock</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate Bernoulli data with four blocks
y &lt;- rbinom(200, 1, rep(c(0.1, 0.7, 0.3, 0.9), each=50))
# fit step function
sb &lt;- stepbound(y, family="binomial", param=1, confband=TRUE)
plot(y, pch="|")
lines(sb)
# confidence intervals for jumps
jumpint(sb)
points(jumpint(sb), col="blue")
# confidence band
confband(sb)
lines(confband(sb), lty=2, col="blue")
</code></pre>

<hr>
<h2 id='monteCarloSimulation'>Monte Carlo simulation</h2><span id='topic+monteCarloSimulation'></span>

<h3>Description</h3>

<p>Performs Monte-Carlo simulations of the multiscale vector of statistics, (3.9) in the vignette, and of the penalised multiscale statistic, (3.6) in the vignette, when no signal is present, see also section 3.2.3 in the vignette.</p>


<h3>Usage</h3>

<pre><code class='language-R'>monteCarloSimulation(n, r = 1e4L, family = NULL, intervalSystem = NULL,
                     lengths = NULL, penalty = NULL,
                     output = c("vector", "maximum"), seed = n,
                     rand.gen = NULL, messages = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monteCarloSimulation_+3A_n">n</code></td>
<td>
<p>a positive integer giving the number of observations for which the Monte-Carlo simulation will be performed</p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_r">r</code></td>
<td>
<p>a positive integer giving the number of repititions</p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, for more details see <a href="#topic+parametricFamily">parametricFamily</a>, currently <code>"gauss"</code>, <code>"hsmuce"</code> and <code>"mDependentPS"</code> are supported. By default (<code>NULL</code>) <code>"gauss"</code> is assumed</p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_intervalsystem">intervalSystem</code></td>
<td>
<p>a string giving the used interval system, either <code>"all"</code> for all intervals, <code>"dyaLen"</code> for all intervals of dyadic length or <code>"dyaPar"</code> for the dyadic partition, for more details see <a href="#topic+intervalSystem">intervalSystem</a>. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. Only required for <code>output == "maximum"</code>, otherwise ignored with a <code><a href="base.html#topic+warning">warning</a></code>. Note that not all lengths are possible for all interval systems and for all parametric families, see <a href="#topic+intervalSystem">intervalSystem</a> and <a href="#topic+parametricFamily">parametricFamily</a>, respectively, to see which ones are allowed. By default (<code>NULL</code>) all lengths that are possible for the specified <code>intervalSystem</code> and for the specified parametric family will be used</p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_penalty">penalty</code></td>
<td>
<p>a string specifying how the statistics will be penalised, either <code>"sqrt"</code>, <code>"log"</code> or <code>"none"</code>, see <a href="#topic+penalty">penalty</a> and section 3.2 in the vignette for more details. Only required for <code>output == "maximum"</code>, otherwise ignored with a <code><a href="base.html#topic+warning">warning</a></code>. By default (<code>NULL</code>) the default penalty of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_output">output</code></td>
<td>
<p>a string specifying the output, see <cite>Value</cite></p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_seed">seed</code></td>
<td>
<p>will be passed to <code><a href="base.html#topic+set.seed">set.seed</a></code> to set a seed, <code><a href="base.html#topic+set.seed">set.seed</a></code> will not be called if this argument is set to <code>"no"</code>, i.e. a single value, interpreted as an <code><a href="base.html#topic+integer">integer</a></code>, <code>NULL</code> or <code>"no"</code></p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_rand.gen">rand.gen</code></td>
<td>
<p>by default (<code>NULL</code>) this argument will be replaced by the default function to generate random observations of the given <code>family</code>. Note that a Monte-Carlo simulation can only be saved if <code>rand.gen == NULL</code>. Alternatively, an own function expecting a single argument named <code>data</code> and returning a numeric vector of length <code>n</code>, this is given by <code>data$n</code>. Will be called with <code>rand.gen(data = data)</code>, with <code>data</code> a list containing the named entries <code>n</code>, the expected number of data points, and parameters of the parametric family, e.g. <code>sd</code> for <code>family == "gauss"</code> or <code>covariances</code> for <code>family == "mDependentPS"</code></p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_messages">messages</code></td>
<td>
<p>a positive integer or <code>NULL</code>, in each <code>messages</code> iteration a message will be printed in order to show the progress of the simulation, if <code>NULL</code> no message will be given</p>
</td></tr>
<tr><td><code id="monteCarloSimulation_+3A_...">...</code></td>
<td>
<p>further parameters of the parametric family. Depending on the argument <code>family</code> some might be required, but others might be optional, please see <a href="#topic+parametricFamily">parametricFamily</a> for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output == "vector"</code> an object of class <code>"MCSimulationVector"</code>, i.e. a <code class="reqn">d_n</code> times <code>r</code> matrix containing <code>r</code> independent samples of the multiscale vector of statistics, with <code class="reqn">d_n</code> the number of scales, i.e. the number of possible lengths for the given interval system and given parametric family. If <code>output == "maximum"</code> an object of class <code>"MCSimulationMaximum"</code>, i.e. a vector of length <code>r</code> containing <code>r</code> independent samples of the penalised multiscale statistic. For both, additionally, the following <code><a href="base.html#topic+attributes">attributes</a></code> are set:
</p>

<ul>
<li><p> &quot;keyList&quot;: A list specifying for which number of observations <code>n</code>, which parametric family with which parameters by a <abbr><span class="acronym">SHA-1</span></abbr> hash, which interval system and in case of <code>"MCSimulationMaximum"</code>, additionally, for which lengths and which penalisation the simulation was performed.
</p>
</li>
<li><p> &quot;key&quot;: A key used internally for identification when the object will be saved and loaded.
</p>
</li>
<li><p> &quot;n&quot;: The number of observations <code>n</code> for which the simulation was performed.
</p>
</li>
<li><p> &quot;lengths&quot;: The lengths for which the simulation was performed.
</p>
</li>
<li><p> &quot;save&quot;: A <code>logical</code> which is <code>TRUE</code> if the object can be saved which is the case for <code>rand.gen == NULL</code> and <code>FALSE</code> otherwise. 
</p>
</li></ul>



<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critVal">critVal</a></code>, <code><a href="#topic+computeStat">computeStat</a></code>, <code><a href="#topic+penalty">penalty</a></code>, <code><a href="#topic+parametricFamily">parametricFamily</a></code>, <code><a href="#topic+intervalSystem">intervalSystem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# monteCarloSimulation will be called in critVal, can be called explicitly
# object of class MCSimulationVector
stat &lt;- monteCarloSimulation(n = 100L)

identical(critVal(n = 100L, alpha = 0.5, stat = stat),
          critVal(n = 100L, alpha = 0.5,
                  options = list(load = list(), simulation = "matrix")))

# object of class MCSimulationMaximum
stat &lt;- monteCarloSimulation(n = 100L, output = "maximum")
identical(critVal(n = 100L, alpha = 0.5, stat = stat),
          critVal(n = 100L, alpha = 0.5,
                  options = list(load = list(), simulation = "vector")))

# different interval system, lengths and penalty
monteCarloSimulation(n = 100L, output = "maximum", intervalSystem = "dyaLen",
              lengths = c(1L, 2L, 4L, 8L), penalty = "log")

# with a different number of iterations, different seed,
# reported progress and user written rand.gen function
stat &lt;- monteCarloSimulation(n = 100L, r = 1e3, seed = 1, messages = 100,
                             rand.gen = function(data) {rnorm(100)})

# the optional argument sd of parametric family "gauss" will be replaced by 1
identical(monteCarloSimulation(n = 100L, r = 1e3, sd = 5),
          monteCarloSimulation(n = 100L, r = 1e3, sd = 1))

# simulation for family "hsmuce"
monteCarloSimulation(n = 100L, family = "hsmuce")

# simulation for family "mDependentGauss"
# covariances must be given (can also be given by correlations or filter)
stat &lt;- monteCarloSimulation(n = 100L, family = "mDependentPS",
                             covariances = c(1, 0.5, 0.3))

# variance will be standardized to 1
# output might be on some systems even identical
all.equal(monteCarloSimulation(n = 100L, family = "mDependentPS",
                               covariances = c(2, 1, 0.6)), stat)


</code></pre>

<hr>
<h2 id='MRC'>Compute Multiresolution Criterion</h2><span id='topic+MRC'></span><span id='topic+MRCoeff'></span><span id='topic+MRC.pvalue'></span><span id='topic+MRC.quant'></span><span id='topic+MRC.simul'></span><span id='topic+chi'></span><span id='topic+chi.FFT'></span><span id='topic+MRC.FFT'></span><span id='topic+MRCoeff.FFT'></span><span id='topic+kMRC.pvalue'></span><span id='topic+kMRC.quant'></span><span id='topic+kMRC.simul'></span>

<h3>Description</h3>

<p>Computes multiresolution coefficients, the corresponding criterion, simulates these for Gaussian white or coloured noise, based on which p-values and quantiles are obtained.
</p>
<p><b>Deprecation warning:</b> The function <code>MRC.simul</code> is deprecated, but still working, however, may be defunct in a future version. Please use instead the function <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. An example how to reproduce results is given below. Some other functions are help function and might be removed, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRC(x, lengths = 2^(floor(log2(length(x))):0), norm = sqrt(lengths),
  penalty = c("none", "log", "sqrt"))
MRCoeff(x, lengths = 2^(floor(log2(length(x))):0), norm = sqrt(lengths), signed = FALSE)
MRC.simul(n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"))
MRC.pvalue(q, n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"),
  name = ".MRC.table", pos = .MCstepR, inherits = TRUE)
MRC.FFT(epsFFT, testFFT, K = matrix(TRUE, nrow(testFFT), ncol(testFFT)), lengths,
  penalty = c("none", "log", "sqrt"))
MRC.quant(p, n, r, lengths = 2^(floor(log2(n)):0), penalty = c("none", "log", "sqrt"),
  name = ".MRC.table", pos = .MCstepR, inherits = TRUE, ...)
kMRC.simul(n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))))
kMRC.pvalue(q, n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))),
  name = ".MRC.ktable", pos = .MCstepR, inherits = TRUE)
kMRC.quant(p, n, r, kern, lengths = 2^(floor(log2(n)):ceiling(log2(length(kern)))),
  name = ".MRC.ktable", pos = .MCstepR, inherits = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRC_+3A_x">x</code></td>
<td>
<p>a vector of numerical observations</p>
</td></tr>
<tr><td><code id="MRC_+3A_lengths">lengths</code></td>
<td>
<p>vector of interval lengths to use, dyadic intervals by default</p>
</td></tr>
<tr><td><code id="MRC_+3A_signed">signed</code></td>
<td>
<p>whether signed coefficients should be returned</p>
</td></tr>
<tr><td><code id="MRC_+3A_q">q</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="MRC_+3A_n">n</code></td>
<td>
<p>length of data set</p>
</td></tr>
<tr><td><code id="MRC_+3A_r">r</code></td>
<td>
<p>number of simulations to use</p>
</td></tr>
<tr><td><code id="MRC_+3A_name">name</code>, <code id="MRC_+3A_pos">pos</code>, <code id="MRC_+3A_inherits">inherits</code></td>
<td>
<p>under which name and where precomputed results are stored, or retrieved, see <code><a href="base.html#topic+assign">assign</a></code></p>
</td></tr>
<tr><td><code id="MRC_+3A_k">K</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> matrix indicating the set of valid intervals</p>
</td></tr>
<tr><td><code id="MRC_+3A_epsfft">epsFFT</code></td>
<td>
<p>a vector containg the FFT of the data set</p>
</td></tr>
<tr><td><code id="MRC_+3A_testfft">testFFT</code></td>
<td>
<p>a matrix containing the FFTs of the intervals</p>
</td></tr>
<tr><td><code id="MRC_+3A_kern">kern</code></td>
<td>
<p>a filter kernel</p>
</td></tr>
<tr><td><code id="MRC_+3A_penalty">penalty</code></td>
<td>
<p>penalty term in the multiresolution statistic: <code>"none"</code> for no penalty, <code>"log"</code> for penalizing the log-length of an interval, and <code>"sqrt"</code> for penalizing the square root of the MRC; or a <code><a href="base.html#topic+function">function</a></code> taking two arguments, the first being the multiresolution coefficients, the second the interval lenghts</p>
</td></tr>
<tr><td><code id="MRC_+3A_norm">norm</code></td>
<td>
<p>how the partial sums should be normalised, by default <code>sqrt(lengths)</code>, so they are normalised to equal variance across all interval lengths</p>
</td></tr>
<tr><td><code id="MRC_+3A_p">p</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code id="MRC_+3A_...">...</code></td>
<td>
<p>further arguments passed to function <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>MRC</code></td>
<td>
<p>a vector giving the maximum as well as the indices of the corresponding interval's start and length</p>
</td></tr>
<tr><td><code>MRCoeff</code></td>
<td>
<p>a matrix giving the multiresolution coefficients for all test intervals</p>
</td></tr>
<tr><td><code>MRC.pvalue</code>, <code>MRC.quant</code>, <code>MRC.simul</code></td>
<td>
<p>the corresponding p-value / quantile / vector of simulated values under the assumption of standard Gaussian white noise</p>
</td></tr>
<tr><td><code>kMRC.pvalue</code>, <code>kMRC.simul</code>, <code>kMRC.simul</code></td>
<td>
<p>the corresponding p-value / quantile / vector of simulated values under the assumption of filtered Gaussian white noise</p>
</td></tr>
</table>


<h3>References</h3>

<p>Davies, P. L., Kovac, A. (2001) Local extremes, runs, strings and multiresolution. <em>The Annals of Statistics</em> <b>29</b>, 1&ndash;65.
</p>
<p>Dümbgen, L., Spokoiny, V. (2001) Multiscale testing of qualitative hypotheses. <em>The Annals of Statistics</em> <b>29</b>, 124&ndash;152.
</p>
<p>Siegmund, D. O., Venkatraman, E. S. (1995) Using the generalized likelihood ratio statistic for sequential detection of a change-point. <em>The Annals of Statistics</em> <b>23</b>, 255&ndash;271.
</p>
<p>Siegmund, D. O., Yakir, B. (2000) Tail probabilities for the null distribution of scanning statistics. <em>Bernoulli</em> <b>6</b>, 191&ndash;213.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>, <code><a href="#topic+smuceR">smuceR</a></code>, <code><a href="#topic+jsmurf">jsmurf</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+stepsel">stepsel</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
all.equal(MRC.simul(100, r = 100),
          sort(monteCarloSimulation(n = 100, r = 100, output = "maximum",
                                    penalty = "none", intervalSystem = "dyaLen")),
          check.attributes = FALSE)

# simulate signal of 100 data points
set.seed(100)
f &lt;- rep(c(0, 2, 0), c(60, 10, 30))
# add gaussian noise
x &lt;- f + rnorm(100)
# compute multiresolution criterion
m &lt;- MRC(x)
# compute Monte-Carlo p-value based on 100 simulations
MRC.pvalue(m["max"], length(x), 100)
# compute multiresolution coefficients
M &lt;- MRCoeff(x)

# plot multiresolution coefficients, colours show p-values below 5% in 1% steps
op &lt;- par(mar = c(5, 4, 2, 4) + 0.1)
image(1:length(x), seq(min(x), max(x), length = ncol(M)), apply(M[,ncol(M):1], 1:2,
  MRC.pvalue, n = length(x), r = 100), breaks = (0:5) / 100,
  col = rgb(1, seq(0, 1, length = 5), 0, 0.75),
  xlab = "location / left end of interval", ylab ="measurement",
  main = "Multiresolution Coefficients",
  sub = paste("MRC p-value =", signif(MRC.pvalue(m["max"], length(x), 100), 3)))
axis(4, min(x) + diff(range(x)) * ( pretty(1:ncol(M) - 1) ) / dim(M)[2],
  2^pretty(1:ncol(M) - 1))
mtext("interval lengths", 4, 3)
# plot signal and its mean
points(x)
lines(f, lty = 2)
abline(h = mean(x))
par(op)

</code></pre>

<hr>
<h2 id='MRC.1000'>Values of the MRC statistic for 1,000 observations (all intervals)</h2><span id='topic+MRC.1000'></span>

<h3>Description</h3>

<p>Simulated values of the MRC statistic with <code>penalty="sqrt"</code> based on all interval lengths computed from Gaussian white noise sequences of length 1,000.
</p>
<p><b>Deprecation warning:</b> This data set is needed for <code><a href="#topic+smuceR">smuceR</a></code> and may be removed when this function will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRC.1000</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector containing 10,000 sorted values.</p>


<h3>Examples</h3>

<pre><code class='language-R'># threshold value for 95% confidence
quantile(stepR::MRC.1000, .95)
</code></pre>

<hr>
<h2 id='MRC.asymptotic'>&quot;Asymptotic&quot; values of the MRC statistic (all intervals)</h2><span id='topic+MRC.asymptotic'></span>

<h3>Description</h3>

<p>Simulated values of the MRC statistic with <code>penalty="sqrt"</code> based on all interval lengths computed from Gaussian white noise sequences of (&quot;almost infinite&quot;) length 5,000.
</p>
<p><b>Deprecation warning:</b> This data set is needed for <code><a href="#topic+smuceR">smuceR</a></code> and may be removed when this function will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRC.asymptotic</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector containing 10,000 sorted values.</p>


<h3>Examples</h3>

<pre><code class='language-R'># "asymptotic" threshold value for 95% confidence
quantile(stepR::MRC.asymptotic, .95)
</code></pre>

<hr>
<h2 id='MRC.asymptotic.dyadic'>&quot;Asymptotic&quot; values of the MRC statistic (dyadic intervals)</h2><span id='topic+MRC.asymptotic.dyadic'></span>

<h3>Description</h3>

<p>Simulated values of the MRC statistic with <code>penalty="sqrt"</code> based on dyadic interval lengths computed from Gaussian white noise sequences of (&quot;almost infinite&quot;) length 100,000.
</p>
<p><b>Deprecation warning:</b> This data set is needed for <code><a href="#topic+smuceR">smuceR</a></code> and may be removed when this function will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRC.asymptotic.dyadic</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector containing 10,000 sorted values.</p>


<h3>Examples</h3>

<pre><code class='language-R'># "asymptotic" threshold value for 95% confidence
quantile(stepR::MRC.asymptotic.dyadic, .95)
</code></pre>

<hr>
<h2 id='neighbours'>Neighbouring integers</h2><span id='topic+neighbours'></span><span id='topic+neighbors'></span>

<h3>Description</h3>

<p>Find integers within some radius of the given ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbours(k, x = 1:max(k), r = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbours_+3A_k">k</code></td>
<td>
<p>integers within whose neighbourhood to look</p>
</td></tr>
<tr><td><code id="neighbours_+3A_x">x</code></td>
<td>
<p>allowed integers</p>
</td></tr>
<tr><td><code id="neighbours_+3A_r">r</code></td>
<td>
<p>radius within which to look</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns those integers in <code>x</code> which are at most <code>r</code> from some integer in <code>k</code>, i.e. the intersection of <code>x</code> with the union of the balls of radius <code>r</code> centred at the values of <code>k</code>. The return values are unique and sorted.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.element">is.element</a></code>, <code><a href="base.html#topic+match">match</a></code>, <code><a href="base.html#topic+findInterval">findInterval</a></code>, <code><a href="#topic+stepcand">stepcand</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>neighbours(c(10, 0, 5), r = 1)
neighbours(c(10, 0, 5), 0:15, r = 1)
</code></pre>

<hr>
<h2 id='parametricFamily'>Parametric families</h2><span id='topic+parametricFamily'></span><span id='topic+parametricfamily'></span>

<h3>Description</h3>

<p>Overview about the supported parametric families (models). More details are given in section 5 of the vignette.
</p>


<h3>Details</h3>

<p>The following parametric families (models and fitting methods) are available. Some of them have additional parameters that have to / can be specified in <code>...</code>.
</p>

<dl>
<dt><code>"gauss"</code></dt><dd><p>independent normal distributed variables with unknown mean but known, constant standard deviation given by the optional argument <code>sd</code>. Fits are obtained by the method <abbr><span class="acronym">SMUCE</span></abbr> (<cite>Frick et al.</cite>, 2014) for independent normal distributed observations. Argument <code>sd</code> has to be a single, positive, finite <code><a href="base.html#topic+numeric">numeric</a></code>. If omitted it will be estimated by <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>. For <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> <code>sd == 1</code> will be used always. The observations argument <code>y</code> has to be a numeric vector with finite entries. The default <a href="#topic+intervalSystem">interval system</a> is <code>"all"</code> up to 1000 observations and <code>"dyaLen"</code> for more observations. Possible lengths are <code>1:length(y)</code>. The default <a href="#topic+penalty">penalty</a> is <code>"sqrt"</code>. In <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> by default <code>n</code> random observations will be generated by <code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>
</dd>
<dt><code>"hsmuce"</code></dt><dd><p>independent normal distributed variables with unknown mean and also unknown piecewise constant standard deviation as a nuisance parameter. Fits are obtained by the method <abbr><span class="acronym">HSMUCE</span></abbr> (<cite>Pein et al.</cite>, 2017). No additional argument has to be given. The observations argument <code>y</code> has to be a numeric vector with finite entries. The default <a href="#topic+intervalSystem">interval system</a> is <code>"dyaPar"</code> and possible lengths are <code>2:length(y)</code>. The default <a href="#topic+penalty">penalty</a> is <code>"weights"</code>  which will automatically be converted to <code>"none"</code> in <code><a href="#topic+computeStat">computeStat</a></code> and <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. In <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> by default <code>n</code> random observations will be generated by <code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>
</dd>
<dt><code>"mDependentPS"</code></dt><dd><p>normal distributed variables with unknown mean and m-dependent errors with known covariance structure given either by the argument <code>covariances</code>, <code>correlations</code> or <code>filter</code>. Fits are obtained by the method <abbr><span class="acronym">SMUCE</span></abbr> (<cite>Frick et al.</cite>, 2014) for m-dependent normal distributed observations using partial sum tests and minimizing the least squares distance (<cite>Pein et al.</cite>, 2017, (7) and (8)). If <code>correlations</code> or <code>filter</code> is used to specify the covariances an additional optional argument <code>sd</code> can be used to specify the constant standard deviation. If <code>covariances</code> is specified the arguments <code>correlations</code>, <code>filter</code> and <code>sd</code> will be ignored and if <code>correlations</code> is specified the argument <code>filter</code> will be ignored. The argument <code>covariances</code> has to be a finite numeric vector, m will be defined by <code>m = length(covariances) - 1</code>, giving the vector of covariances, i.e. the first element must be positive, the absolute value of every other element must be smaller than or equal to the first one and the last element should not be zero. The argument <code>correlation</code> has to be a finite numeric vector, m will be defined by <code>m = length(correlations) - 1</code>, giving the vector of correlations, i.e. the first element must be 1, the absolute value of every other element must be smaller than or equal to the first one and the last element should not be zero. Covariances will be calculated by <code>correlations * sd^2</code>. The argument <code>filter</code> has to be an object of class <code><a href="lowpassFilter.html#topic+lowpassFilter">lowpassFilter</a></code> from which the correlation vector will be obtained. The argument <code>sd</code> has to be a single, positive, finite <code><a href="base.html#topic+numeric">numeric</a></code>. If omitted it will be estimated by <code><a href="#topic+sdrobnorm">sdrobnorm</a></code> with <code>lag = m + 1</code>. For <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> <code>sd == 1</code> will be used always. The observations argument <code>y</code> has to be a numeric vector with finite entries. The default <a href="#topic+intervalSystem">interval system</a> is <code>"dyaLen"</code> and possible lengths are <code>1:length(y)</code>. The default <a href="#topic+penalty">penalty</a> is <code>"sqrt"</code>. In <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> by default <code>n</code> random observations will be generated by calculating the coefficients of the corresponding moving average process and generating random observations from it.</p>
</dd>
</dl>

<p>The family is selected via the <code>family</code> argument, providing the corresponding string, while additional parameters have to / can be specified in <code>...</code> if any.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2017) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. <em>arXiv</em>:1706.03671.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>, <code><a href="stats.html#topic+rnorm">rnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# parametric family "gauss": independent gaussian errors with constant variance
set.seed(1)
x &lt;- seq(1 / 100, 1, 1 / 100)
y &lt;- c(rnorm(50), rnorm(50, 2))
plot(x, y, pch = 16, col = "grey30", ylim = c(-3, 5))

# computation of SMUCE and its confidence statements
fit &lt;- stepFit(y, x = x, alpha = 0.5, family = "gauss",
               jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red")
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# "gauss" is default for family
identical(stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE), fit)
# missing sd is estimated by sdrobnorm
identical(stepFit(y, x = x, alpha = 0.5, family = "gauss", sd = sdrobnorm(y),
                  jumpint = TRUE, confband = TRUE), fit)

# parametric family "hsmuce": independent gaussian errors with also
# piecewise constant variance
# estimaton that is robust against variance changes
set.seed(1)
y &lt;- c(rnorm(50, 0, 1), rnorm(50, 1, 0.2))
plot(x, y, pch = 16, col = "grey30", ylim = c(-2.5, 2))

# computation of HSMUCE and its confidence statements
fit &lt;- stepFit(y, x = x, alpha = 0.5, family = "hsmuce",
               jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red")
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# for comparison SMUCE
lines(stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE),
      lwd = 3, col = "blue", lty = "22")


# parametric family "mDependentPS": m dependent observations with known covariances
# observations are generated from a moving average process
set.seed(1)
y &lt;- c(rep(0, 50), rep(2, 50)) +
  as.numeric(arima.sim(n = 100, list(ar = c(), ma = c(0.8, 0.5, 0.3)), sd = 0.5))
correlations &lt;- as.numeric(ARMAacf(ar = c(), ma = c(0.8, 0.5, 0.3), lag.max = 3))
covariances &lt;- 0.5^2 * correlations
plot(x, y, pch = 16, col = "grey30", ylim = c(-2, 4))

# computation of SMUCE for dependent observations with given covariances
fit &lt;- stepFit(y, x = x, alpha = 0.5, family = "mDependentPS",
               covariances = covariances, jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red")
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# for comparison SMUCE for independent gaussian errors
lines(stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE),
      lwd = 3, col = "blue", lty = "22")

# covariance structure can also be given by correlations and sd
identical(stepFit(y, x = x, alpha = 0.5, family = "mDependentPS",
                  correlations = correlations, sd = 0.5,
                  jumpint = TRUE, confband = TRUE), fit)

# if sd is missing it will be estimated by sdrobnorm
identical(stepFit(y, x = x, alpha = 0.5,family = "mDependentPS",
                  correlations = correlations, jumpint = TRUE, confband = TRUE),
          stepFit(y, x = x, alpha = 0.5, family = "mDependentPS",
                  correlations = correlations,
                  sd = sdrobnorm(y, lag = length(correlations)),
                  jumpint = TRUE, confband = TRUE))
                  
                  
</code></pre>

<hr>
<h2 id='penalty'>Penalties</h2><span id='topic+penalty'></span><span id='topic+penalties'></span>

<h3>Description</h3>

<p>Overview about the supported penalties. More details are also given in section 3.2 of the vignette.
</p>


<h3>Details</h3>

<p>The penalties (ways to balance different scales) can be divided into two groups: scale penalisation and balancing by weights. More precisely, the scale penalisations <code>"sqrt"</code>, <code>"log"</code> and <code>"none"</code> and balancing by weights called <code>"weights"</code> are available.
</p>
<p>Let <code>T</code> be the unpenalised test statistic of the specified parametric family on an interval of length <code>l</code> and <code>nq</code> the number of observations used for the penalisation, typically the number of observations <code>n</code> but can also be chosen larger.
</p>

<dl>
<dt><code>"sqrt"</code></dt><dd><p>penalised statistic is <code>sqrt(2 * T) - sqrt(2 * log(exp(1) * nq / l)</code>. This penalisation is proposed in (Frick et al., 2014) and guarantees for most parametric families that the penalised multiscale statistic is asymptotically finite. This is not true for parametric family <code>"hsmuce"</code>. Hence, this penalisation is recommended and the default one for the parametric families <code>"gauss"</code> and <code>"mDependentPS"</code>, but not for <code>"hsmuce"</code>.</p>
</dd>
<dt><code>"log"</code></dt><dd><p>penalised statistic is <code>T - log(exp(1) * nq / l)</code>. This penalisation is outdated and only still supported for comparisons.</p>
</dd>
<dt><code>"none"</code></dt><dd><p>no penalisation, penalised statistic is equal to the unpenalised. Multiscale regression without a penalisation is not recommend.</p>
</dd>
<dt><code>"weights"</code></dt><dd><p>critical values will be computed by weights, see section 3.2.2 in the vignette and (Pein et al., 2017, section 2) for more details. This penalty is recommend and the default one for the parametric family <code>"hsmuce"</code>, but can also be used for other families. Will be replaced by <code>"none"</code> in <code><a href="#topic+computeStat">computeStat</a></code> and <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>.</p>
</dd>
</dl>

<p>The penalisation is selected via the <code>penalty</code> argument providing the corresponding string. If <code>NULL</code> the default penalty of the specified parametric family will be used, see <code><a href="#topic+parametricFamily">parametricFamily</a></code> for which one this will be.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><a href="#topic+parametricFamily">parametricFamily</a>, <code><a href="#topic+critVal">critVal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
y &lt;- c(rnorm(50), rnorm(50, 2))

# penalty "sqrt"
fit &lt;- stepFit(y, alpha = 0.5, penalty = "sqrt", jumpint = TRUE, confband = TRUE)

# default for family "gauss"
identical(stepFit(y, alpha = 0.5, jumpint = TRUE, confband = TRUE), fit)

# penalty "weights"
!identical(stepFit(y, alpha = 0.5, penalty = "weights",
                   jumpint = TRUE, confband = TRUE), fit)

# penalty "weights" is default for parametric family "hsmuce"
# by default equal weights are chosen
identical(stepFit(y, alpha = 0.5, family = "hsmuce",
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, alpha = 0.5, family = "hsmuce", penalty = "weights",
                  weights = rep(1 / 6, 6), jumpint = TRUE, confband = TRUE))

# different weights
!identical(stepFit(y, alpha = 0.5, family = "hsmuce", weights = 6:1 / sum(6:1),
                   jumpint = TRUE, confband = TRUE),
           stepFit(y, alpha = 0.5, family = "hsmuce", penalty = "weights",
                   weights = rep(1 / 6, 6), jumpint = TRUE, confband = TRUE))

# penalty "sqrt is default for parametric family "mDependentPS"
identical(stepFit(y, alpha = 0.5, family = "mDependentPS", covariances = c(1, 0.5),
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, alpha = 0.5, family = "mDependentPS", covariances = c(1, 0.5),
                  penalty = "sqrt", jumpint = TRUE, confband = TRUE))


</code></pre>

<hr>
<h2 id='sdrobnorm'>Robust standard deviation estimate</h2><span id='topic+sdrobnorm'></span>

<h3>Description</h3>

<p>Robust estimation of the standard deviation of Gaussian data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdrobnorm(x, p = c(0.25, 0.75), lag = 1,
          supressWarningNA = FALSE, supressWarningResultNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdrobnorm_+3A_x">x</code></td>
<td>
<p>a vector of numerical observations. <code>NA</code> entries will be removed with a warning. The warning can be supressed by setting <code>supressWarningNA</code> to <code>TRUE</code>. Other non finite values are not allowed</p>
</td></tr>
<tr><td><code id="sdrobnorm_+3A_p">p</code></td>
<td>
<p>vector of two distinct probabilities</p>
</td></tr>
<tr><td><code id="sdrobnorm_+3A_lag">lag</code></td>
<td>
<p>a single integer giving the lag of the difference used, see <code><a href="base.html#topic+diff">diff</a></code>, if a numeric is passed a small tolerance will be added and the value will be converted by <code><a href="base.html#topic+as.integer">as.integer</a></code></p>
</td></tr>
<tr><td><code id="sdrobnorm_+3A_supresswarningna">supressWarningNA</code></td>
<td>
<p>a single logical, if <code>TRUE</code> no warning will be given for <code>NA</code> entries in <code>x</code></p>
</td></tr>
<tr><td><code id="sdrobnorm_+3A_supresswarningresultna">supressWarningResultNA</code></td>
<td>
<p>a single logical, if <code>TRUE</code> no warning will be given if the result is <code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the difference between the estimated sample quantile corresponding to <code>p</code> after taking (<code>lag</code>ged) differences) with the corresponding theoretical quantiles of Gaussian white noise to determine the standard deviation under a Gaussian assumption. If the data contain (few) jumps, this will (on average) be a slight overestimate of the true standard deviation.
</p>
<p>This estimator has been inspired by (1.7) in (<cite>Davies and Kovac</cite>, 2001).
</p>


<h3>Value</h3>

<p>Returns the estimate of the sample's standard deviation, i.e. a single non-negative numeric, <code>NA</code> if <code>length(x) &lt; lag + 2</code>.
</p>


<h3>References</h3>

<p>Davies, P. L., Kovac, A. (2001) Local extremes, runs, strings and multiresolution. <em>The Annals of Statistics</em> <b>29</b>, 1&ndash;65.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="base.html#topic+diff">diff</a></code>, <a href="#topic+parametricFamily">parametricFamily</a>, <a href="#topic+family">family</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data sample
y &lt;- rnorm(100, c(rep(1, 50), rep(10, 50)), 2)
# estimate standard deviation
sdrobnorm(y)
</code></pre>

<hr>
<h2 id='smuceR'>Piecewise constant regression with SMUCE</h2><span id='topic+smuceR'></span><span id='topic+thresh.smuceR'></span>

<h3>Description</h3>

<p>Computes the SMUCE estimator for one-dimensional data.
</p>
<p><b>Deprecation warning:</b> This function is deprecated, but still working, however, may be defunct in a future version. Please use instead the function <code><a href="#topic+stepFit">stepFit</a></code>. At the moment some families are supported by this function that are not supported by the current version of <code><a href="#topic+stepFit">stepFit</a></code>. They will be added in a future version. An example how to reproduce results is given below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smuceR(y, x = 1:length(y), x0 = 2 * x[1] - x[2], q = thresh.smuceR(length(y)), alpha, r,
  lengths, family = c("gauss", "gaussvar", "poisson", "binomial"), param,
  jumpint = confband, confband = FALSE)
thresh.smuceR(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smuceR_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="smuceR_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="smuceR_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="smuceR_+3A_q">q</code></td>
<td>
<p>threshold value, by default chosen automatically according to Frick et al.~(2013)</p>
</td></tr>
<tr><td><code id="smuceR_+3A_alpha">alpha</code></td>
<td>
<p>significance level; if set to a value in (0,1), <code>q</code> is chosen as the corresponding quantile of the asymptotic (if <code>r</code> is not given) null distribution (and any value specified for <code>q</code> is silently ignored)</p>
</td></tr>
<tr><td><code id="smuceR_+3A_r">r</code></td>
<td>
<p>numer of simulations; if specified along <code>alpha</code>, <code>q</code> is chosen as the corresponding quantile of the simulated null distribution</p>
</td></tr>
<tr><td><code id="smuceR_+3A_lengths">lengths</code></td>
<td>
<p>length of intervals considered; by default up to a sample size of 1000 all lengths, otherwise only dyadic lengths</p>
</td></tr>
<tr><td><code id="smuceR_+3A_family">family</code>, <code id="smuceR_+3A_param">param</code></td>
<td>
<p>specifies distribution of data, see <a href="#topic+family">family</a></p>
</td></tr>
<tr><td><code id="smuceR_+3A_jumpint">jumpint</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> (<code>FALSE</code> by default), indicates if confidence sets for change-points should be computed</p>
</td></tr>
<tr><td><code id="smuceR_+3A_confband">confband</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, indicates if a confidence band for the piecewise-continuous function should be computed</p>
</td></tr>
<tr><td><code id="smuceR_+3A_v">v</code></td>
<td>
<p>number of data points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>smuceR</code>, an object of class <code><a href="#topic+stepfit">stepfit</a></code> that contains the fit; if <code>jumpint == TRUE</code> function <code><a href="#topic+jumpint">jumpint</a></code> allows to extract the <code>1 - alpha</code> confidence interval for the jumps, if <code>confband == TRUE</code> function <code><a href="#topic+confband">confband</a></code> allows to extract the <code>1 - alpha</code> confidence band.
</p>
<p>For <code>thresh.smuceR</code>, a precomputed threshhold value, see reference.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., and Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Futschik, A., Hotz, T., Munk, A. Sieling, H. (2014) Multiresolution DNA partitioning: statistical evidence for segments. <em>Bioinformatics</em>,  <b>30</b>(16), 2255&ndash;2262.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepFit">stepFit</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+bounds">bounds</a></code>, <a href="#topic+family">family</a>, <code><a href="#topic+MRC.asymptotic">MRC.asymptotic</a></code>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>, <code><a href="#topic+stepfit">stepfit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100, c(rep(0, 50), rep(1, 50)), 0.5)

# fitted function, confidence intervals, and confidence band by stepFit
all.equal(fitted(smuceR(y, q = 1)), fitted(stepFit(y, q = 1)))
all.equal(fitted(smuceR(y, alpha = 0.5)),
          fitted(stepFit(y, q = as.numeric(quantile(stepR::MRC.1000, 0.5)))))
all.equal(fitted(smuceR(y)), fitted(stepFit(y, q = thresh.smuceR(length(y)))))

all.equal(jumpint(smuceR(y, q = 1, jumpint = TRUE)),
          jumpint(stepFit(y, q = 1, jumpint = TRUE)))
all.equal(confband(smuceR(y, q = 1, confband = TRUE)),
          confband(stepFit(y, q = 1, confband = TRUE)),
          check.attributes = FALSE)
          

# simulate poisson data with two levels
y &lt;- rpois(100, c(rep(1, 50), rep(4, 50)))
# compute fit, q is chosen automatically
fit &lt;- smuceR(y, family="poisson", confband = TRUE)
# plot result
plot(y)
lines(fit)
# plot confidence intervals for jumps on axis
points(jumpint(fit), col="blue")
# confidence band
lines(confband(fit), lty=2, col="blue")

# simulate binomial data with two levels
y &lt;- rbinom(200,3,rep(c(0.1,0.7),c(110,90)))
# compute fit, q is the 0.9-quantile of the (asymptotic) null distribution
fit &lt;- smuceR(y, alpha=0.1, family="binomial", param=3, confband = TRUE)
# plot result
plot(y)
lines(fit)
# plot confidence intervals for jumps on axis
points(jumpint(fit), col="blue")
# confidence band
lines(confband(fit), lty=2, col="blue")
</code></pre>

<hr>
<h2 id='stepblock'>Step function</h2><span id='topic+stepblock'></span><span id='topic++5B.stepblock'></span><span id='topic+print.stepblock'></span><span id='topic+plot.stepblock'></span><span id='topic+lines.stepblock'></span>

<h3>Description</h3>

<p>Constructs an object containing a step function sampled over finitely many values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepblock(value, leftEnd = c(1, rightEnd[-length(rightEnd)] + 1), rightEnd, x0 = 0)
## S3 method for class 'stepblock'
x[i, j, drop = if(missing(i)) TRUE else if(missing(j)) FALSE else length(j) == 1, ...]
## S3 method for class 'stepblock'
print(x, ...)
## S3 method for class 'stepblock'
plot(x, type = "c", xlab = "x", ylab = "y", main = "Step function", sub = NULL, ...)
## S3 method for class 'stepblock'
lines(x, type = "c", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepblock_+3A_value">value</code></td>
<td>
<p>a numeric vector containing the fitted values for each block; its length gives the number of blocks</p>
</td></tr>
<tr><td><code id="stepblock_+3A_leftend">leftEnd</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the left end of each block</p>
</td></tr>
<tr><td><code id="stepblock_+3A_rightend">rightEnd</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the right end of each block</p>
</td></tr>
<tr><td><code id="stepblock_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started, i.e. before <code>leftEnd[1]</code></p>
</td></tr>
<tr><td><code id="stepblock_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="stepblock_+3A_i">i</code>, <code id="stepblock_+3A_j">j</code>, <code id="stepblock_+3A_drop">drop</code></td>
<td>
<p>see <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code></p>
</td></tr>
<tr><td><code id="stepblock_+3A_type">type</code></td>
<td>
<p><code>"c"</code> to plot jumps in the middle between the end of the previous block (or <code>x0</code>) and the beginning of the following block; <code>"e"</code> to jump at the end of the previous block; <code>"b"</code> to jump at the beginning of the following block; capital letters also plot points</p>
</td></tr>
<tr><td><code id="stepblock_+3A_xlab">xlab</code>, <code id="stepblock_+3A_ylab">ylab</code>, <code id="stepblock_+3A_main">main</code>, <code id="stepblock_+3A_sub">sub</code></td>
<td>
<p>see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="stepblock_+3A_...">...</code></td>
<td>
<p>for generic methods only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>stepblock</code> an object of class <code>stepblock</code>, i.e. a <code><a href="base.html#topic+data.frame">data.frame</a></code> with columns <code>value</code>, <code>leftEnd</code> and <code>rightEnd</code> and <code><a href="base.html#topic+attr">attr</a></code>ibute <code>x0</code>.
</p>


<h3>Note</h3>

<p>For the purposes of this package step functions are taken to be left-continuous, i.e. the function jumps <strong>after</strong> the <code>rightEnd</code> of a block.
</p>
<p>However, step functions are usually sampled at a discrete set of points so that the exact position of the jump is unknown, except that it has to occur before the next sampling point; this is expressed in the implementation by the specification of a <code>leftEnd</code> <strong>within</strong> the block so that every <code>rightEnd</code> and <code>leftEnd</code> is a sampling point (or the boundary of the observation window), there is no sampling point between one block's <code>rightEnd</code> and the following block's <code>leftEnd</code>, while the step function is constant at least on the closed interval with boundary <code>leftEnd</code>, <code>rightEnd</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+step">step</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <a href="#topic+family">family</a>, <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># step function consisting of 3 blocks: 1 on (0, 3]; 2 on (3, 6], 0 on (6, 8]
# sampled on the integers 1:10
f &lt;- stepblock(value = c(1, 2, 0), rightEnd = c(3, 6, 8))
f
# show different plot types
plot(f, type = "C")
lines(f, type = "E", lty = 2, col = "red")
lines(f, type = "B", lty = 3, col = "blue")
legend("bottomleft", legend = c("C", "E", "B"), lty = 1:3, col = c("black", "red", "blue"))
</code></pre>

<hr>
<h2 id='stepbound'>Jump estimation under restrictions</h2><span id='topic+stepbound'></span><span id='topic+stepbound.default'></span><span id='topic+stepbound.stepcand'></span>

<h3>Description</h3>

<p>Computes piecewise constant maximum likelihood estimators with minimal number of jumps under given restrictions on subintervals.
</p>
<p><b>Deprecation warning:</b> This function is a help function for <code><a href="#topic+smuceR">smuceR</a></code> and <code><a href="#topic+jsmurf">jsmurf</a></code> and may be removed when these function will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepbound(y, bounds, ...)
## Default S3 method:
stepbound(y, bounds, x = 1:length(y), x0 = 2 * x[1] - x[2],
  max.cand = NULL, family = c("gauss", "gaussvar", "poisson", "binomial", "gaussKern"),
  param = NULL, weights = rep(1, length(y)), refit = y,
  jumpint = confband, confband = FALSE, ...)
## S3 method for class 'stepcand'
stepbound(y, bounds, refit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepbound_+3A_y">y</code></td>
<td>
<p>a vector of numerical observations</p>
</td></tr>
<tr><td><code id="stepbound_+3A_bounds">bounds</code></td>
<td>
<p>bounds on the value allowed on intervals; typically computed with <code><a href="#topic+bounds">bounds</a></code></p>
</td></tr>
<tr><td><code id="stepbound_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="stepbound_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="stepbound_+3A_max.cand">max.cand</code>, <code id="stepbound_+3A_weights">weights</code></td>
<td>
<p>see <code><a href="#topic+stepcand">stepcand</a></code></p>
</td></tr>
<tr><td><code id="stepbound_+3A_family">family</code>, <code id="stepbound_+3A_param">param</code></td>
<td>
<p>specifies distribution of data, see <a href="#topic+family">family</a></p>
</td></tr>
<tr><td><code id="stepbound_+3A_refit">refit</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, for <code>family = "gaussKern"</code>; determines whether a fit taken the filter kernel into account will be computed at the end</p>
</td></tr>
<tr><td><code id="stepbound_+3A_jumpint">jumpint</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> (<code>FALSE</code> by default), indicates if confidence sets for jumps should be computed</p>
</td></tr>
<tr><td><code id="stepbound_+3A_confband">confband</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, indicates if a confidence band for the piecewise-continuous function should be computed</p>
</td></tr>
<tr><td><code id="stepbound_+3A_...">...</code></td>
<td>
<p>arguments to be passed to generic methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+stepfit">stepfit</a></code> that contains the fit; if <code>jumpint == TRUE</code> function <code><a href="#topic+jumpint">jumpint</a></code> allows to extract the confidence interval for the jumps, if <code>confband == TRUE</code> function <code><a href="#topic+confband">confband</a></code> allows to extract the confidence band.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., and Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing ion channel recordings by a jump segmentation multiresolution filter. <em>IEEE Transactions on NanoBioscience</em> <b>12</b>(4), 376&ndash;386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bounds">bounds</a></code>, <code><a href="#topic+smuceR">smuceR</a></code>, <code><a href="#topic+jsmurf">jsmurf</a></code>, <code><a href="#topic+stepsel">stepsel</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <code><a href="#topic+jumpint">jumpint</a></code>, <code><a href="#topic+confband">confband</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate poisson data with two levels
y &lt;- rpois(100, c(rep(1, 50), rep(4, 50)))
# compute bounds
b &lt;- bounds(y, penalty="len", family="poisson", q=4)
# fit step function to bounds
sb &lt;- stepbound(y, b, family="poisson", confband=TRUE)
plot(y)
lines(sb)
# plot confidence intervals for jumps on axis
points(jumpint(sb), col="blue")
# confidence band
lines(confband(sb), lty=2, col="blue")
</code></pre>

<hr>
<h2 id='stepcand'>Forward selection of candidate jumps</h2><span id='topic+stepcand'></span>

<h3>Description</h3>

<p>Find candidates for jumps in serial data by forward selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepcand(y, x = 1:length(y), x0 = 2 * x[1] - x[2], max.cand = NULL,
  family = c("gauss", "gaussvar", "poisson", "binomial", "gaussKern"), param = NULL,
  weights = rep(1, length(y)), cand.radius = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepcand_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="stepcand_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="stepcand_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="stepcand_+3A_max.cand">max.cand</code></td>
<td>
<p>single integer giving the maximal number of blocks to find; defaults to using all data (note: there will be one block more than the number of jumps</p>
</td></tr>
<tr><td><code id="stepcand_+3A_family">family</code></td>
<td>
<p>distribution of the errors, either <code>"gauss"</code>, <code>"poisson"</code> or <code>"binomial"</code>; <code>"gaussInhibit"</code> is like <code>"gauss"</code> forbids jumps getting close together or to the ends in <code><a href="#topic+steppath.stepcand">steppath.stepcand</a></code>, &quot;gaussInhibitBoth&quot; already forbids this in <code>stepcand</code> (not recommended)</p>
</td></tr>
<tr><td><code id="stepcand_+3A_param">param</code></td>
<td>
<p>additional parameters specifying the distribution of the errors; the number of trials for family <code>"binomial"</code>; for <code>gaussInhibit</code> and <code>gaussInhibitBoth</code> a numeric of length 3 with components <code>"start"</code>, <code>"middle"</code> and <code>"end"</code> preventing the first jump from getting closer to <code>x0</code> than the <code>"start"</code> value, any two jumps from getting closer than the <code>"middle"</code> value, and the last jump from geting closer than the <code>"end"</code> value to the end, all distances measured by weights (cf. example below)</p>
</td></tr>
<tr><td><code id="stepcand_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing non-negative weights</p>
</td></tr>
<tr><td><code id="stepcand_+3A_cand.radius">cand.radius</code></td>
<td>
<p>a non-negative integer: adds for each candidate found all indices that are at most <code>cand.radius</code> away</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>stepcand</code> extending class <code><a href="#topic+stepfit">stepfit</a></code> such that it can be used as an input to <code><a href="#topic+steppath.stepcand">steppath.stepcand</a></code>: additionally contains columns
</p>
<table>
<tr><td><code>cumSum</code></td>
<td>
<p>The cumulative sum of <code>x</code> up to <code>rightEnd</code>.</p>
</td></tr>
<tr><td><code>cumSumSq</code></td>
<td>
<p>The cumulative sum of squares of <code>x</code> up to <code>rightEnd</code> (for <code>family = "gauss"</code>).</p>
</td></tr>
<tr><td><code>cumSumWe</code></td>
<td>
<p>The cumulative sum of weights up to <code>rightEnd</code>.</p>
</td></tr>
<tr><td><code>improve</code></td>
<td>
<p>The improvement this jump brought about when it was selected.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+steppath">steppath</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <a href="#topic+family">family</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 5 blocks (4 jumps) within a total of 100 data points
b &lt;- c(sort(sample(1:99, 4)), 100)
f &lt;- rep(rnorm(5, 0, 4), c(b[1], diff(b)))
rbind(b = b, f = unique(f), lambda = exp(unique(f) / 10) * 20)
# add gaussian noise
x &lt;- f + rnorm(100)
# find 10 candidate jumps
stepcand(x, max.cand = 10)
# for poisson observations
y &lt;- rpois(100, exp(f / 10) * 20)
# find 10 candidate jumps
stepcand(y, max.cand = 10, family = "poisson")
# for binomial observations
size &lt;- 10
z &lt;- rbinom(100, size, pnorm(f / 10))
# find 10 candidate jumps
stepcand(z, max.cand = 10, family = "binomial", param = size)
</code></pre>

<hr>
<h2 id='stepfit'>Fitted step function</h2><span id='topic++5B.stepfit'></span><span id='topic+stepfit'></span><span id='topic+print.stepfit'></span><span id='topic+plot.stepfit'></span><span id='topic+lines.stepfit'></span><span id='topic+fitted.stepfit'></span><span id='topic+residuals.stepfit'></span><span id='topic+logLik.stepfit'></span>

<h3>Description</h3>

<p>Constructs an object containing a step function fitted to some data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepfit(cost, family, value, param = NULL, leftEnd, rightEnd, x0,
  leftIndex = leftEnd, rightIndex = rightEnd)
## S3 method for class 'stepfit'
x[i, j, drop = if(missing(i)) TRUE else
  if(missing(j)) FALSE else length(j) == 1, refit = FALSE] 
## S3 method for class 'stepfit'
print(x, ...)
## S3 method for class 'stepfit'
plot(x, dataspace = TRUE, ...)
## S3 method for class 'stepfit'
lines(x, dataspace = TRUE, ...)
## S3 method for class 'stepfit'
fitted(object, ...)
## S3 method for class 'stepfit'
residuals(object, y, ...)
## S3 method for class 'stepfit'
logLik(object, df = NULL, nobs = object$rightIndex[nrow(object)], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepfit_+3A_cost">cost</code></td>
<td>
<p>the value of the cost-functional used for the fit: RSS for family <code>gauss</code>, log-likelihood (up to a constant) for families <code>poisson</code> and <code>binomial</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_family">family</code></td>
<td>
<p>distribution of the errors, either <code>"gauss"</code>, <code>"poisson"</code> or <code>"binomial"</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_value">value</code></td>
<td>
<p>a numeric vector containing the fitted values for each block; its length gives the number of blocks</p>
</td></tr>
<tr><td><code id="stepfit_+3A_param">param</code></td>
<td>
<p>additional paramters specifying the distribution of the errors, the number of trials for family <code>"binomial"</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_leftend">leftEnd</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the left end of each block</p>
</td></tr>
<tr><td><code id="stepfit_+3A_rightend">rightEnd</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the left end of each block</p>
</td></tr>
<tr><td><code id="stepfit_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started, i.e. before <code>leftEnd[0]</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_leftindex">leftIndex</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the index of the sample points corresponding to the block's left end, cf. <code><a href="#topic+stepcand">stepcand</a></code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_rightindex">rightIndex</code></td>
<td>
<p>a numeric vector of the same length as <code>value</code> containing the index of the sample points corresponding to the block's right end, cf. <code><a href="#topic+stepcand">stepcand</a></code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_x">x</code>, <code id="stepfit_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="stepfit_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the data with which to compare the fit</p>
</td></tr>
<tr><td><code id="stepfit_+3A_df">df</code></td>
<td>
<p>the number of estimated parameters: by default the number of blocks for families <code>poisson</code> and <code>binomial</code>, one more (for the variance) for family <code>gauss</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations used for estimating</p>
</td></tr>
<tr><td><code id="stepfit_+3A_...">...</code></td>
<td>
<p>for generic methods only</p>
</td></tr>
<tr><td><code id="stepfit_+3A_i">i</code>, <code id="stepfit_+3A_j">j</code>, <code id="stepfit_+3A_drop">drop</code></td>
<td>
<p>see <code>"<a href="base.html#topic++5B.data.frame">[.data.frame</a>"</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_refit">refit</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; determines whether the function will be refitted after subselection, i.e. whether the selection should be interpreted as a fit with fewer jumps); in that case, for <code>family = "gaussKern"</code>, <code>refit</code> needs to be set to the original data, i.e. <code>y</code></p>
</td></tr>
<tr><td><code id="stepfit_+3A_dataspace">dataspace</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> determining whether the expected value should be plotted instead of the fitted parameter value, useful e.g. for <code>family = "binomial"</code>, where it will plot the fitted success probability times the number of trials per observation</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>stepfit</code></td>
<td>
<p>an object of class <code>stepfit</code> which extends <code><a href="#topic+stepblock">stepblock</a></code>, additionally containing <code><a href="base.html#topic+attr">attr</a></code>ibutes <code>cost</code>, <code>family</code> and <code>param</code>, as well as columns <code>leftIndex</code> and <code>rightIndex</code></p>
</td></tr>
<tr><td><code>[.stepfit</code></td>
<td>
<p>an object of class <code>stepfit</code> which contains the selected subset</p>
</td></tr>
<tr><td><code>fitted.stepfit</code></td>
<td>
<p>a numeric vector of length <code>rightIndex[length(rightIndex)]</code> giving the fit at the original sample points</p>
</td></tr>
<tr><td><code>residuals.stepfit</code></td>
<td>
<p>a numeric vector of length <code>rightIndex[length(rightIndex)]</code> giving the residuals at the original sample points</p>
</td></tr>
<tr><td><code>logLik.stepfit</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+logLik">logLik</a></code> giving the likelihood of the data given this fit, e.g. for use with <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="#topic+stepsel">stepsel</a></code>; this will (incorrectly) treat <code>family = "gaussKern"</code> as if it were fitted with <code>family = "gauss"</code></p>
</td></tr>
<tr><td><code>plot.stepfit</code>, <code>plot.stepfit</code></td>
<td>
<p>the corresponding functions for <code><a href="#topic+stepblock">stepblock</a></code> are called</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stepblock">stepblock</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+steppath">steppath</a></code>, <code><a href="#topic+stepsel">stepsel</a></code>, <a href="#topic+family">family</a>, <code>"<a href="base.html#topic++5B.data.frame">[.data.frame</a>"</code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 5 blocks (4 jumps) within a total of 100 data points
b &lt;- c(sort(sample(1:99, 4)), 100)
p &lt;- rep(runif(5), c(b[1], diff(b))) # success probabilities
# binomial observations, each with 10 trials
y &lt;- rbinom(100, 10, p)
# find solution with 5 blocks
fit &lt;- steppath(y, family = "binomial", param = 10)[[5]]
plot(y, ylim = c(0, 10))
lines(fit, col = "red")
# residual diagnostics for Gaussian data
yg &lt;- rnorm(100, qnorm(p), 1)
fitg &lt;- steppath(yg)[[5]]
plot(yg, ylim = c(0, 10))
lines(fitg, col = "red")
plot(resid(fitg, yg))
qqnorm(resid(fitg, yg))
</code></pre>

<hr>
<h2 id='stepFit'>Piecewise constant multiscale inference</h2><span id='topic+stepFit'></span>

<h3>Description</h3>

<p>Computes the multiscale regression estimator, see (3.1) in the vignette, and allows for confidence statements, see section 3 in the vignette. It implements the estimators <abbr><span class="acronym">SMUCE</span></abbr> and <abbr><span class="acronym">HSMUCE</span></abbr> as well as their confidence intervals and bands.<br />
If <code>q == NULL</code> a Monte-Carlo simulation is required for computing critical values. Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package saves them by default in the workspace and on the file system such that a second call requiring the same Monte-Carlo simulation will be much faster. For more details, in particular to which arguments the Monte-Carlo simulations are specific, see Section <cite>Storing of Monte-Carlo simulations</cite> below. Progress of a Monte-Carlo simulation can be reported by the argument <code>messages</code> and the saving can be controlled by the argument <code>option</code>, both can be specified in <code>...</code> and are explained in <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code> and <code><a href="#topic+critVal">critVal</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepFit(y, q = NULL, alpha = NULL, x = 1:length(y), x0 = 2 * x[1] - x[2],
        family = NULL, intervalSystem = NULL, lengths = NULL, confband = FALSE,
        jumpint = confband, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepFit_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the observations</p>
</td></tr>
<tr><td><code id="stepFit_+3A_q">q</code></td>
<td>
<p>either <code>NULL</code>, then the vector of critical values at level <code>alpha</code> will be computed from a Monte-Carlo simulation, or a numeric giving the global quantile or a numeric vector giving the vector of critical values. Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code>. This argument will be passed to <code><a href="#topic+critVal">critVal</a></code> to obtain the needed critical values. Additional parameters for the computation of <code>q</code> can be specified in <code>...</code>, for more details see the documentation of <code><a href="#topic+critVal">critVal</a></code>. Please note that by default the Monte-Carlo simulation will be saved in the workspace and on the file system, for more details see Section <cite>Storing of Monte-Carlo simulations</cite> below</p>
</td></tr>
<tr><td><code id="stepFit_+3A_alpha">alpha</code></td>
<td>
<p>a probability, i.e. a single numeric between 0 and 1, giving the significance level. Its choice is a trade-off between data fit and parsimony of the estimator. In other words, this argument balances the risks of missing change-points and detecting additional artefacts. For more details on this choice see (Frick et al., 2014, section 4) and (Pein et al., 2017, section 3.4). Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code></p>
</td></tr>
<tr><td><code id="stepFit_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="stepFit_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="stepFit_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, for more details see <a href="#topic+parametricFamily">parametricFamily</a>, currently <code>"gauss"</code>, <code>"hsmuce"</code> and <code>"mDependentPS"</code> are supported. By default (<code>NULL</code>) <code>"gauss"</code> is assumed</p>
</td></tr>
<tr><td><code id="stepFit_+3A_intervalsystem">intervalSystem</code></td>
<td>
<p>a string giving the used interval system, either <code>"all"</code> for all intervals, <code>"dyaLen"</code> for all intervals of dyadic length or <code>"dyaPar"</code> for the dyadic partition, for more details see <a href="#topic+intervalSystem">intervalSystem</a>. By default (<code>NULL</code>) the default interval system of the specified parametric family will be used, which one this will be is described in <code><a href="#topic+parametricFamily">parametricFamily</a></code></p>
</td></tr>
<tr><td><code id="stepFit_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. Note that not all lengths are possible for all interval systems and for all parametric families, see <a href="#topic+intervalSystem">intervalSystem</a> and <a href="#topic+parametricFamily">parametricFamily</a>, respectively, to see which ones are allowed. By default (<code>NULL</code>) all lengths that are possible for the specified <code>intervalSystem</code> and for the specified parametric family will be used</p>
</td></tr>
<tr><td><code id="stepFit_+3A_confband">confband</code></td>
<td>
<p>single <code><a href="base.html#topic+logical">logical</a></code>, indicates if a confidence band for the piecewise-continuous function should be computed</p>
</td></tr>
<tr><td><code id="stepFit_+3A_jumpint">jumpint</code></td>
<td>
<p>single <code><a href="base.html#topic+logical">logical</a></code>, indicates if confidence sets for change-points should be computed</p>
</td></tr>
<tr><td><code id="stepFit_+3A_...">...</code></td>
<td>
<p>there are two groups of further arguments:
</p>

<ol>
<li><p> further parameters of the parametric family. Depending on argument <code>family</code> some might be required, but others might be optional, please see <a href="#topic+parametricFamily">parametricFamily</a> for more details,
</p>
</li>
<li><p> further parameters that will be passed to <code><a href="#topic+critVal">critVal</a></code>. <code><a href="#topic+critVal">critVal</a></code> will be called automatically with the number of observations <code>n = length(y)</code>, the arguments <code>family</code>, <code>intervalSystem</code>, <code>lengths</code>, <code>q</code> and <code>output</code> set. For these arguments no user interaction is required and possible, all other arguments of <code><a href="#topic+critVal">critVal</a></code> can be passed additionally
</p>
</li></ol>

</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+stepfit">stepfit</a></code> that contains the fit. If <code>jumpint == TRUE</code> function <code><a href="#topic+jumpint">jumpint</a></code> allows to extract the <code>1 - alpha</code> confidence interval for the jumps. If <code>confband == TRUE</code> function <code><a href="#topic+confband">confband</a></code> allows to extract the <code>1 - alpha</code> confidence band.
</p>


<h3>Storing of Monte-Carlo simulations</h3>

<p>If <code>q == NULL</code> a Monte-Carlo simulation is required for computing critical values. Since a Monte-Carlo simulation lasts potentially much longer (up to several hours or days if the number of observations is in the millions) than the main calculations, this package offers multiple possibilities for saving and loading the simulations. Progress of a simulation can be reported by the argument <code>messages</code> which can be specified in <code>...</code> and is explained in the documentation of <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code>. Each Monte-Carlo simulation is specific to the number of observations, the parametric family (including certain parameters, see <a href="#topic+parametricFamily">parametricFamily</a>) and the interval system, and for simulations of class <code>"MCSimulationMaximum"</code>, additionally, to the set of lengths and the used penalty. Monte-Carlo simulations can also be performed for a (slightly) larger number of observations <code class="reqn">n_q</code> given in the argument <code>nq</code> in <code>...</code> and explained in the documentation of <code><a href="#topic+critVal">critVal</a></code>, which avoids extensive resimulations for only a little bit varying number of observations. Simulations can either be saved in the workspace in the variable <code>critValStepRTab</code> or persistently on the file system for which the package <code><a href="R.cache.html#topic+R.cache">R.cache</a></code> is used. Moreover, storing in and loading from variables and <a href="base.html#topic+readRDS">RDS</a> files is supported. Finally, a pre-simulated collection of simulations can be accessed by installing the package <code>stepRdata</code> available from <a href="http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz">http://www.stochastik.math.uni-goettingen.de/stepRdata_1.0-0.tar.gz</a>. The simulation, saving and loading can be controlled by the argument <code>option</code> which can be specified in <code>...</code> and is explained in the documentation of <code><a href="#topic+critVal">critVal</a></code>. By default simulations will be saved in the workspace and on the file system.  For more details and for how simulation can be removed see Section <cite>Simulating, saving and loading of Monte-Carlo simulations</cite> in <code><a href="#topic+critVal">critVal</a></code>.
</p>


<h3>References</h3>

<p>Frick, K., Munk, A., Sieling, H. (2014) Multiscale change-point inference. With discussion and rejoinder by the authors. <em>Journal of the Royal Statistical Society, Series B</em> <b>76</b>(3), 495&ndash;580.
</p>
<p>Pein, F., Sieling, H., Munk, A. (2017) Heterogeneous change point inference. <em>Journal of the Royal Statistical Society, Series B</em>, <b>79</b>(4), 1207&ndash;1227.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+critVal">critVal</a></code>, <code><a href="#topic+penalty">penalty</a></code>, <code><a href="#topic+parametricFamily">parametricFamily</a></code>, <code><a href="#topic+intervalSystem">intervalSystem</a></code>, <code><a href="#topic+monteCarloSimulation">monteCarloSimulation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate random observations
y &lt;- c(rnorm(50), rnorm(50, 1))
x &lt;- seq(0.01, 1, 0.01)
plot(x, y, pch = 16, col = "grey30", ylim = c(-3, 4))

# computation of SMUCE and its confidence statements
fit &lt;- stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE)
lines(fit, lwd = 3, col = "red", lty = "22")

# confidence intervals for the change-point locations
points(jumpint(fit), col = "red")
# confidence band
lines(confband(fit), lty = "22", col = "darkred", lwd = 2)

# higher significance level for larger detection power, but less confidence
stepFit(y, x = x, alpha = 0.99, jumpint = TRUE, confband = TRUE)

# smaller significance level for the small risk that the number of
# change-points is overestimated with probability not more than 5%,
# but smaller detection power
stepFit(y, x = x, alpha = 0.05, jumpint = TRUE, confband = TRUE)

# different interval system, lengths, penalty and given parameter sd
stepFit(y, x = x, alpha = 0.5, intervalSystem = "dyaLen",
        lengths = c(1L, 2L, 4L, 8L), penalty = "weights",
        weights = c(0.4, 0.3, 0.2, 0.1), sd = 0.5,
        jumpint = TRUE, confband = TRUE)
        
# with given q
identical(stepFit(y, x = x, q = critVal(100L, alpha = 0.5),
                  jumpint = TRUE, confband = TRUE), fit)
identical(stepFit(y, x = x, q = critVal(100L, alpha = 0.5, output = "value"),
                  jumpint = TRUE, confband = TRUE), fit)

# the above calls saved and (attempted to) load Monte-Carlo simulations and
# simulated them for nq = 128 observations
# in the following call no saving, no loading and simulation for n = 100
# observations is required, progress of the simulation will be reported
stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE,
        messages = 1000L, options = list(simulation = "vector",
                                         load = list(), save = list()))

# with given stat to compute q
stat &lt;- monteCarloSimulation(n = 128L)
identical(stepFit(y, x = x, alpha = 0.5, stat = stat,
                  jumpint = TRUE, confband = TRUE),
          stepFit(y, x = x, alpha = 0.5, jumpint = TRUE, confband = TRUE,
                  options = list(load = list())))



</code></pre>

<hr>
<h2 id='steppath'>Solution path of step-functions</h2><span id='topic+steppath'></span><span id='topic+steppath.default'></span><span id='topic+steppath.stepcand'></span><span id='topic++5B+5B.steppath'></span><span id='topic+length.steppath'></span><span id='topic+print.steppath'></span><span id='topic+logLik.steppath'></span>

<h3>Description</h3>

<p>Find optimal fits with step-functions having jumps at given candidate positions for all possible subset sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steppath(y, ..., max.blocks)
## Default S3 method:
steppath(y, x = 1:length(y), x0 = 2 * x[1] - x[2], max.cand = NULL,
  family = c("gauss", "gaussvar", "poisson", "binomial", "gaussKern"), param = NULL,
  weights = rep(1, length(y)), cand.radius = 0, ..., max.blocks = max.cand)
## S3 method for class 'stepcand'
steppath(y, ..., max.blocks = sum(!is.na(y$number)))
## S3 method for class 'steppath'
x[[i]]
## S3 method for class 'steppath'
length(x)
## S3 method for class 'steppath'
print(x, ...)
## S3 method for class 'steppath'
logLik(object, df = NULL, nobs = object$cand$rightIndex[nrow(object$cand)], ...)
</code></pre>


<h3>Arguments</h3>

<p>for <code>steppath</code>:
</p>
<table>
<tr><td><code id="steppath_+3A_y">y</code></td>
<td>
<p>either an object of class <code><a href="#topic+stepcand">stepcand</a></code> for <code>steppath.stepcand</code> or a numeric vector containing the serial data for <code>steppath.default</code></p>
</td></tr>
<tr><td><code id="steppath_+3A_x">x</code>, <code id="steppath_+3A_x0">x0</code>, <code id="steppath_+3A_max.cand">max.cand</code>, <code id="steppath_+3A_family">family</code>, <code id="steppath_+3A_param">param</code>, <code id="steppath_+3A_weights">weights</code>, <code id="steppath_+3A_cand.radius">cand.radius</code></td>
<td>
<p>for <code>steppath.default</code> which calls <code><a href="#topic+stepcand">stepcand</a></code>; see there</p>
</td></tr>
<tr><td><code id="steppath_+3A_max.blocks">max.blocks</code></td>
<td>
<p>single integer giving the maximal number of blocks to find; defaults to number of candidates (note: there will be one block more than the number of jumps</p>
</td></tr>
<tr><td><code id="steppath_+3A_...">...</code></td>
<td>
<p>for generic methods only</p>
</td></tr>
</table>
<p>for methods on a <code>steppath</code> object <code>x</code> or <code>object</code>:
</p>
<table>
<tr><td><code id="steppath_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="steppath_+3A_i">i</code></td>
<td>
<p>if this is an integer returns the fit with <code>i</code> blocks as an object of class <code><a href="#topic+stepcand">stepcand</a></code>, else the standard behaviour of a <code><a href="base.html#topic+list">list</a></code></p>
</td></tr>
<tr><td><code id="steppath_+3A_df">df</code></td>
<td>
<p>the number of estimated parameters: by default the number of blocks for families <code>poisson</code> and <code>binomial</code>, one more (for the variance) for family <code>gauss</code></p>
</td></tr>
<tr><td><code id="steppath_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations used for estimating</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>steppath</code> an object of class <code>steppath</code>, i.e. a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>path</code></td>
<td>
<p>A list of length <code>length(object)</code> where the <code>i</code>th element contains the best fit by a step-function having <code>i-1</code> jumps (i.e. <code>i</code> blocks), given by the candidates indices</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>A numeric vector of length <code>length(object)</code> giving the value of the cost functional corresponding to the solutions.</p>
</td></tr>
<tr><td><code>cand</code></td>
<td>
<p>An object of class <code><a href="#topic+stepcand">stepcand</a></code> giving the candidates among which the jumps were selected.</p>
</td></tr>
</table>
<p><code>[[.steppath</code> returns the fit with <code>i</code> blocks as an object of class <code><a href="#topic+stepfit">stepfit</a></code>; <code>length.steppath</code> the maximum number of blocks for which a fit has been computed. <code>logLik.stepfit</code> returns an object of class <code><a href="stats.html#topic+logLik">logLik</a></code> giving the likelihood of the data given the fits corresponding to <code>cost</code>, e.g. for use with <code><a href="stats.html#topic+AIC">AIC</a>.</code>
</p>


<h3>References</h3>

<p>Friedrich, F., Kempe, A., Liebscher, V., Winkler, G. (2008) Complexity penalized M-estimation: fast computation. <em>Journal of Computational and Graphical Statistics</em> <b>17</b>(1), 201&ndash;224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepcand">stepcand</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <a href="#topic+family">family</a>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 5 blocks (4 jumps) within a total of 100 data points
b &lt;- c(sort(sample(1:99, 4)), 100)
f &lt;- rep(rnorm(5, 0, 4), c(b[1], diff(b)))
# add Gaussian noise
x &lt;- f + rnorm(100)
# find 10 candidate jumps
cand &lt;- stepcand(x, max.cand = 10)
cand
# compute solution path
path &lt;- steppath(cand)
path
plot(x)
lines(path[[5]], col = "red")
# compare result having 5 blocks with truth
fit &lt;- path[[5]]
fit
logLik(fit)
AIC(logLik(fit))
cbind(fit, trueRightEnd = b, trueLevel = unique(f))
# for poisson observations
y &lt;- rpois(100, exp(f / 10) * 20)
# compute solution path, compare result having 5 blocks with truth
cbind(steppath(y, max.cand = 10, family = "poisson")[[5]],
  trueRightEnd = b, trueIntensity = exp(unique(f) / 10) * 20)
# for binomial observations
size &lt;- 10
z &lt;- rbinom(100, size, pnorm(f / 10))
# compute solution path, compare result having 5 blocks with truth
cbind(steppath(z, max.cand = 10, family = "binomial", param = size)[[5]],
  trueRightEnd = b, trueIntensity = pnorm(unique(f) / 10))
# an example where stepcand is not optimal but indices found are close to optimal ones
blocks &lt;- c(rep(0, 9), 1, 3, rep(1, 9))
blocks
stepcand(blocks, max.cand = 3)[,c("rightEnd", "value", "number")]
# erroneously puts the "1" into the right block in the first step
steppath(blocks)[[3]][,c("rightEnd", "value")]
# putting the "1" in the middle block is optimal
steppath(blocks, max.cand = 3, cand.radius = 1)[[3]][,c("rightEnd", "value")]
# also looking in the 1-neighbourhood remedies the problem
</code></pre>

<hr>
<h2 id='stepsel'>Automatic selection of number of jumps</h2><span id='topic+stepsel'></span><span id='topic+stepsel.MRC'></span><span id='topic+stepsel.AIC'></span><span id='topic+stepsel.BIC'></span>

<h3>Description</h3>

<p>Select the number of jumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepsel(path, y, type = c("MRC", "AIC", "BIC"), ...)
stepsel.MRC(path, y, q, alpha = 0.05, r = ceiling(50 / min(alpha, 1 - alpha)),
  lengths = if(attr(path$cand, "family") == "gaussKern")
    2^(floor(log2(length(y))):ceiling(log2(length(attr(path$cand, "param")$kern)))) else
    2^(floor(log2(length(y))):0),
  penalty = c("none", "log", "sqrt"), name = if(attr(path$cand, "family") == "gaussKern")
    ".MRC.ktable" else ".MRC.table",
  pos = .MCstepR)
stepsel.AIC(path, ...)
stepsel.BIC(path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepsel_+3A_path">path</code></td>
<td>
<p>an object of class <code><a href="#topic+steppath">steppath</a></code></p>
</td></tr>
<tr><td><code id="stepsel_+3A_y">y</code></td>
<td>
<p>for <code>type=MRC</code> only: a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="stepsel_+3A_type">type</code></td>
<td>
<p>how to select, dispatches specific method</p>
</td></tr>
<tr><td><code id="stepsel_+3A_...">...</code></td>
<td>
<p>further argument passed to specific method</p>
</td></tr>
<tr><td><code id="stepsel_+3A_q">q</code>, <code id="stepsel_+3A_alpha">alpha</code>, <code id="stepsel_+3A_r">r</code>, <code id="stepsel_+3A_lengths">lengths</code>, <code id="stepsel_+3A_penalty">penalty</code>, <code id="stepsel_+3A_name">name</code>, <code id="stepsel_+3A_pos">pos</code></td>
<td>
<p>see <code><a href="#topic+bounds">bounds</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer giving the number of blocks selected, with <code><a href="base.html#topic+attr">attr</a></code>ibute <code>crit</code> containing the values of the criterion (MRC / AIC / BIC) for each fit in the path.
</p>


<h3>Note</h3>

<p>To obtain the threshold described in Boysen et al.~(2009, Theorem~5), set <code>q=(1+delta) * sdrobnorm(y) * sqrt(2*length(y))</code> for some positive <code>delta</code> and <code>penalty="none"</code>.
</p>


<h3>References</h3>

<p>Boysen, L., Kempe, A., Liebscher, V., Munk, A., Wittich, O. (2009) Consistencies and rates of convergence of jump-penalized least squares estimators. <em>The Annals of Statistics</em> <b>37</b>(1), 157&ndash;183.
</p>
<p>Yao, Y.-C. (1988) Estimating the number of change-points via Schwarz' criterion. <em>Statistics &amp; Probability Letters</em> <b>6</b>, 181&ndash;189.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steppath">steppath</a></code>, <code><a href="#topic+stepfit">stepfit</a></code>, <a href="#topic+family">family</a>, <code><a href="#topic+stepbound">stepbound</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 5 blocks (4 jumps) within a total of 100 data points
b &lt;- c(sort(sample(1:99, 4)), 100)
f &lt;- rep(rnorm(5, 0, 4), c(b[1], diff(b)))
rbind(b = b, f = unique(f))
# add gaussian noise
y &lt;- f + rnorm(100)
# find 10 candidate jumps
path &lt;- steppath(y, max.cand = 10)
# select number of jumps by simulated MRC with sqrt-penalty
# thresholded with positive delta, and by BIC
sel.MRC &lt;- stepsel(path, y, "MRC", alpha = 0.05, r = 1e2, penalty = "sqrt")
sel.MRC
delta &lt;- .1
sel.delta &lt;- stepsel(path, y, "MRC",
  q = (1 + delta) * sdrobnorm(y) * sqrt(2 * length(y)), penalty = "none")
sel.delta
sel.BIC &lt;- stepsel(path, type="BIC")
sel.BIC
# compare results with truth
fit.MRC &lt;- path[[sel.MRC]]
as.data.frame(fit.MRC)
as.data.frame(path[[sel.delta]])
as.data.frame(path[[sel.BIC]])
</code></pre>

<hr>
<h2 id='testSmallScales'>Test Small Scales</h2><span id='topic+testSmallScales'></span><span id='topic+.testSmallScales'></span>

<h3>Description</h3>

<p>For developers only; users should look at the function <code>improveSmallScales</code> in the CRAN package <code>clampSeg</code>. Implements the second step of <abbr><span class="acronym">HILDE</span></abbr> (<cite>Pein et al.</cite>, 2020, Section III-B) in which an initial fit is tested for missed short events.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.testSmallScales(data, family, lengths = NULL, q, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testSmallScales_+3A_data">data</code></td>
<td>
<p>a numeric vector containing the observations</p>
</td></tr>
<tr><td><code id="testSmallScales_+3A_family">family</code></td>
<td>
<p>a string specifying the assumed parametric family, currently <code>"LR"</code> and <code>"2Param"</code> are supported</p>
</td></tr>
<tr><td><code id="testSmallScales_+3A_lengths">lengths</code></td>
<td>
<p>an integer vector giving the set of lengths, i.e. only intervals of these lengths will be considered. By default (<code>NULL</code>) <code>1:20</code> will be used for parametric family <code>"LR"</code> and <code>1:65</code> will be used for parametric family <code>"2Param"</code></p>
</td></tr>
<tr><td><code id="testSmallScales_+3A_q">q</code></td>
<td>
<p>either <code>NULL</code>, then the vector of critical values at level <code>alpha</code> will be computed from a Monte-Carlo simulation or a numeric vector giving the vector of critical values. Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code>. This argument will be passed to <code><a href="#topic+critVal">critVal</a></code> to obtain the needed critical values. Additional parameters for the computation of <code>q</code> can be specified in <code>...</code>, for more details see the documentation of <code><a href="#topic+critVal">critVal</a></code>. Please note that by default the Monte-Carlo simulation will be saved in the workspace and on the file system, for more details see Section <cite>Storing of Monte-Carlo simulations</cite> below</p>
</td></tr>
<tr><td><code id="testSmallScales_+3A_alpha">alpha</code></td>
<td>
<p>a probability, i.e. a single numeric between 0 and 1, giving the significance level. Its choice is a trade-off between data fit and parsimony of the estimator. In other words, this argument balances the risks of missing change-points and detecting additional artefacts. For more details on this choice see (Frick et al., 2014, section 4) and (Pein et al., 2017, section 3.4). Either <code>q</code> or <code>alpha</code> must be given. Otherwise, <code>alpha == 0.5</code> is chosen with a <code><a href="base.html#topic+warning">warning</a></code></p>
</td></tr>
<tr><td><code id="testSmallScales_+3A_...">...</code></td>
<td>
<p>there are two groups of further arguments:
</p>

<ol>
<li><p> further parameters of the parametric family,
</p>
</li>
<li><p> further parameters that will be passed to <code><a href="#topic+critVal">critVal</a></code>. <code><a href="#topic+critVal">critVal</a></code> will be called automatically with the number of observations <code>n = length(y)</code>, the arguments <code>family</code>, <code>intervalSystem</code>, <code>lengths</code>, <code>q</code> and <code>output</code> set. For these arguments no user interaction is required and possible, all other arguments of <code><a href="#topic+critVal">critVal</a></code> can be passed additionally
</p>
</li></ol>

</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with entries <code>jumps, addLeft, addRight, noDeconvolution, data, q</code>
</p>


<h3>References</h3>

<p>Pein, F., Bartsch, A., Steinem, C., and Munk, A. (2020) Heterogeneous idealization of ion channel recordings - Open channel noise. Submitted.
</p>

<hr>
<h2 id='transit'>TRANSIT algorithm for detecting jumps</h2><span id='topic+transit'></span>

<h3>Description</h3>

<p>Reimplementation of VanDongen's algorithm for detecting jumps in ion channel recordings.
</p>
<p><b>Deprecation warning:</b> This function is mainly used for patchlamp recordings and may be transferred to a specialised package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transit(y, x = 1:length(y), x0 = 2 * x[1] - x[2], sigma.amp = NA, sigma.slope = NA,
  amp.thresh = 3, slope.thresh = 2, rel.amp.n = 3, rel.amp.thresh = 4,
  family = c("gauss", "gaussKern"), param = NULL, refit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transit_+3A_y">y</code></td>
<td>
<p>a numeric vector containing the serial data</p>
</td></tr>
<tr><td><code id="transit_+3A_sigma.amp">sigma.amp</code></td>
<td>
<p>amplitude (i.e. raw data within block) standard deviation; estimated using <code><a href="#topic+sdrobnorm">sdrobnorm</a></code> if omitted</p>
</td></tr>
<tr><td><code id="transit_+3A_sigma.slope">sigma.slope</code></td>
<td>
<p>slope (i.e. central difference within block) standard deviation; estimated using <code><a href="#topic+sdrobnorm">sdrobnorm</a></code> if omitted</p>
</td></tr>
<tr><td><code id="transit_+3A_amp.thresh">amp.thresh</code></td>
<td>
<p>amplitude threshold</p>
</td></tr>
<tr><td><code id="transit_+3A_slope.thresh">slope.thresh</code></td>
<td>
<p>slope threshold</p>
</td></tr>
<tr><td><code id="transit_+3A_rel.amp.n">rel.amp.n</code></td>
<td>
<p>relative amplitude threshold will be used for blocks with no more datapoints than this</p>
</td></tr>
<tr><td><code id="transit_+3A_rel.amp.thresh">rel.amp.thresh</code></td>
<td>
<p>relative amplitude threshold</p>
</td></tr>
<tr><td><code id="transit_+3A_x">x</code></td>
<td>
<p>a numeric vector of the same length as <code>y</code> containing the corresponding sample points</p>
</td></tr>
<tr><td><code id="transit_+3A_x0">x0</code></td>
<td>
<p>a single numeric giving the last unobserved sample point directly before sampling started</p>
</td></tr>
<tr><td><code id="transit_+3A_family">family</code>, <code id="transit_+3A_param">param</code></td>
<td>
<p>specifies distribution of data, see <a href="#topic+family">family</a></p>
</td></tr>
<tr><td><code id="transit_+3A_refit">refit</code></td>
<td>
<p>should the <code>value</code>s for <code>family = "gaussKern"</code> be obtained by fitting in the end (otherwise they are meaningless)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+stepfit">stepfit</a></code> which encodes the jumps and corresponding mean values.
</p>


<h3>Note</h3>

<p>Only central, no forward differences have been used in this implementation. Moreover, the standard deviations will be estimated by <code><a href="#topic+sdrobnorm">sdrobnorm</a></code> if omitted (respecting the filter's effect if applicable).
</p>


<h3>References</h3>

<p>VanDongen, A. M. J. (1996) A new algorithm for idealizing single ion channel data containing multiple unknown conductance levels. <em>Biophysical Journal</em> <b>70</b>(3), 1303&ndash;1315.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepfit">stepfit</a></code>, <code><a href="#topic+sdrobnorm">sdrobnorm</a></code>, <code><a href="#topic+jsmurf">jsmurf</a></code>, <code><a href="#topic+stepbound">stepbound</a></code>, <code><a href="#topic+steppath">steppath</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># estimating step-functions with Gaussian white noise added
# simulate a Gaussian hidden Markov model of length 1000 with 2 states
# with identical transition rates 0.01, and signal-to-noise ratio 2
sim &lt;- contMC(1e3, 0:1, matrix(c(0, 0.01, 0.01, 0), 2), param=1/2)
plot(sim$data, cex = 0.1)
lines(sim$cont, col="red")
# maximum-likelihood estimation under multiresolution constraints
fit.MRC &lt;- smuceR(sim$data$y, sim$data$x)
lines(fit.MRC, col="blue")
# choose number of jumps using BIC
path &lt;- steppath(sim$data$y, sim$data$x, max.blocks=1e2)
fit.BIC &lt;- path[[stepsel.BIC(path)]]
lines(fit.BIC, col="green3", lty = 2)

# estimate after filtering
# simulate filtered ion channel recording with two states
set.seed(9)
# sampling rate 10 kHz
sampling &lt;- 1e4
# tenfold oversampling
over &lt;- 10
# 1 kHz 4-pole Bessel-filter, adjusted for oversampling
cutoff &lt;- 1e3
df.over &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling / over))
# two states, leaving state 1 at 10 Hz, state 2 at 20 Hz
rates &lt;- rbind(c(0, 10), c(20, 0))
# simulate 0.5 s, level 0 corresponds to state 1, level 1 to state 2
# noise level is 0.3 after filtering
Sim &lt;- contMC(0.5 * sampling, 0:1, rates, sampling=sampling, family="gaussKern",
  param = list(df=df.over, over=over, sd=0.3))
plot(Sim$data, pch = ".")
lines(Sim$discr, col = "red")
# fit under multiresolution constraints using filter corresponding to sample rate
df &lt;- dfilter("bessel", list(pole=4, cutoff=cutoff / sampling))
Fit.MRC &lt;- jsmurf(Sim$data$y, Sim$data$x, param=df, r=1e2)
lines(Fit.MRC, col = "blue")
# fit using TRANSIT
Fit.trans &lt;- transit(Sim$data$y, Sim$data$x)
lines(Fit.trans, col = "green3", lty=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
