<!DOCTYPE html><html lang="en-US"><head><title>Help for package SunCalcMeeus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SunCalcMeeus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SunCalcMeeus-package'><p>SunCalcMeeus: Sun Position and Daylight Calculations</p></a></li>
<li><a href='#as_tod'><p>Convert datetime to time-of-day</p></a></li>
<li><a href='#as.solar_date'><p>Convert a solar_time object into solar_date object</p></a></li>
<li><a href='#calendar_change'><p>Solar astronomy using Meeus' algorithm</p></a></li>
<li><a href='#day_night'><p>Times for sun positions</p></a></li>
<li><a href='#format.solar_time'><p>Encode in a Common Format</p></a></li>
<li><a href='#format.tod_time'><p>Encode in a Common Format</p></a></li>
<li><a href='#irrad_extraterrestrial'><p>Extraterrestrial solar irradiance</p></a></li>
<li><a href='#is.solar_time'><p>Query class</p></a></li>
<li><a href='#print.solar_time'><p>Print solar time and solar date objects</p></a></li>
<li><a href='#print.tod_time'><p>Print time-of-day objects</p></a></li>
<li><a href='#relative_AM'><p>Relative Air Mass (AM)</p></a></li>
<li><a href='#solar_time'><p>Local solar time</p></a></li>
<li><a href='#sun_angles'><p>Sun angles</p></a></li>
<li><a href='#twilight2angle'><p>twilight argument check and conversion</p></a></li>
<li><a href='#tz_time_diff'><p>Time difference between two time zones</p></a></li>
<li><a href='#validate_geocode'><p>Validate a geocode</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sun Position and Daylight Calculations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute the position of the sun, and local solar time using Meeus'
    formulae. Compute day and/or night length using different
    twilight definitions or arbitrary sun elevation angles. This package is 
    part of the 'r4photobiology' suite, Aphalo, P. J. (2015)
    &lt;<a href="https://doi.org/10.19232%2Fuv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>&gt;. Algorithms from Meeus (1998, ISBN:0943396611).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, tibble (&ge; 3.1.6), lubridate (&ge; 1.9.3), dplyr (&ge;
1.0.9)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.41), rmarkdown (&ge; 2.18), testthat (&ge; 3.2.1),
roxygen2 (&ge; 7.3.0), lutz (&ge; 0.3.2), covr, spelling</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.r4photobiology.info/SunCalcMeeus/">https://docs.r4photobiology.info/SunCalcMeeus/</a>,
<a href="https://github.com/aphalo/SunCalcMeeus">https://github.com/aphalo/SunCalcMeeus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aphalo/SunCalcMeeus/issues">https://github.com/aphalo/SunCalcMeeus/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-09 18:04:52 UTC; aphalo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro J. Aphalo <a href="https://orcid.org/0000-0003-3385-972X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro J. Aphalo &lt;pedro.aphalo@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-09 18:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='SunCalcMeeus-package'>SunCalcMeeus: Sun Position and Daylight Calculations</h2><span id='topic+SunCalcMeeus'></span><span id='topic+SunCalcMeeus-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Compute the position of the sun, and local solar time using Meeus' formulae. Compute day and/or night length using different twilight definitions or arbitrary sun elevation angles. This package is part of the 'r4photobiology' suite, Aphalo, P. J. (2015) <a href="https://doi.org/10.19232/uv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>. Algorithms from Meeus (1998, ISBN:0943396611).
</p>


<h3>Details</h3>

<p>Please see the vignette <em>0: The R for
Photobiology Suite</em> for a description of the suite.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pedro J. Aphalo <a href="mailto:pedro.aphalo@helsinki.fi">pedro.aphalo@helsinki.fi</a> (<a href="https://orcid.org/0000-0003-3385-972X">ORCID</a>)
</p>


<h3>References</h3>

<p>Aphalo, Pedro J. (2015) The r4photobiology suite. <em>UV4Plants Bulletin</em>, 2015:1,
21-29. <a href="https://doi.org/10.19232/uv4pb.2015.1.14">doi:10.19232/uv4pb.2015.1.14</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.r4photobiology.info/SunCalcMeeus/">https://docs.r4photobiology.info/SunCalcMeeus/</a>
</p>
</li>
<li> <p><a href="https://github.com/aphalo/SunCalcMeeus">https://github.com/aphalo/SunCalcMeeus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aphalo/SunCalcMeeus/issues">https://github.com/aphalo/SunCalcMeeus/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># daylength
sunrise_time(lubridate::today(tzone = "EET"), tz = "EET",
             geocode = data.frame(lat = 60, lon = 25),
             unit.out = "hour")
day_length(lubridate::today(tzone = "EET"), tz = "EET",
           geocode = data.frame(lat = 60, lon = 25),
           unit.out = "hour")
sun_angles(lubridate::now(tzone = "EET"), tz = "EET",
           geocode = data.frame(lat = 60, lon = 25))

</code></pre>

<hr>
<h2 id='as_tod'>Convert datetime to time-of-day</h2><span id='topic+as_tod'></span>

<h3>Description</h3>

<p>Convert a datetime into a time of day expressed in hours, minutes or seconds
from midnight in local time for a time zone. This conversion is useful when
time-series data for different days needs to be compared or plotted based on
the local time-of-day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tod(x, unit.out = "hours", tz = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tod_+3A_x">x</code></td>
<td>
<p>a datetime object accepted by lubridate functions.</p>
</td></tr>
<tr><td><code id="as_tod_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;tod_time&quot;, &quot;hours&quot;, &quot;minutes&quot;, or
&quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="as_tod_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>. If
<code>unit.out = "tod_time"</code> an object of class <code>"tod_time"</code> which
a numeric vector as with <code>unit.out = "hours"</code> but with the class
attribute set to <code>"tod_time"</code>, which dispatches to special
<code>format()</code> and <code>print()</code> methods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solar_time">solar_time</a></code>
</p>
<p>Other Time of day functions: 
<code><a href="#topic+format.tod_time">format.tod_time</a>()</code>,
<code><a href="#topic+print.tod_time">print.tod_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
my_instants &lt;- ymd_hms("2020-05-17 12:05:03") + days(c(0, 30))
my_instants
as_tod(my_instants)
as_tod(my_instants, unit.out = "tod_time")

</code></pre>

<hr>
<h2 id='as.solar_date'>Convert a solar_time object into solar_date object</h2><span id='topic+as.solar_date'></span>

<h3>Description</h3>

<p>Convert a solar_time object into solar_date object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.solar_date(x, time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.solar_date_+3A_x">x</code></td>
<td>
<p>solar_time object.</p>
</td></tr>
<tr><td><code id="as.solar_date_+3A_time">time</code></td>
<td>
<p>an R date time object that provides the date part.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class &quot;solar_time&quot; lack date information, it describes
the time since local astronomical or true midnight. This function
adds the date information from the argument passed to time <code>time</code>
assembling a modified <code>time</code> object of class &quot;solar_date&quot;.
</p>


<h3>Value</h3>

<p>An object of class &quot;solar.date&quot; object derived
from POSIXct. This is needed only for unambiguous formatting and
printing.
</p>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='calendar_change'>Solar astronomy using Meeus' algorithm</h2><span id='topic+calendar_change'></span><span id='topic+julian_day'></span><span id='topic+julian_day_fast'></span><span id='topic+julian_century'></span><span id='topic+geom_mean_lon_sun'></span><span id='topic+geom_mean_anom_sun'></span><span id='topic+eccent_earth_orbit'></span><span id='topic+sun_eq_of_ctr'></span><span id='topic+sun_rad_vector'></span><span id='topic+sun_app_lon'></span><span id='topic+mean_obliq_eclip'></span><span id='topic+obliq_corr'></span><span id='topic+sun_rt_ascen'></span><span id='topic+sun_decline'></span><span id='topic+var_y'></span><span id='topic+eq_of_time'></span><span id='topic+ha_sunrise'></span><span id='topic+solar_noon'></span><span id='topic+sunrise'></span><span id='topic+sunset'></span><span id='topic+sunlight_duration'></span><span id='topic+solar_datetime'></span><span id='topic+solar_tod'></span><span id='topic+hour_angle'></span><span id='topic+zenith_angle'></span><span id='topic+elevation_angle'></span><span id='topic+atm_refraction_approx'></span><span id='topic+azimuth_angle'></span>

<h3>Description</h3>

<p>The exact julian day computation is adapted from ode::julianDay() and tested
againts test cases in Redas and Andreas (2008, table A4.1) for validity up
to year 4712 BC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calendar_change

julian_day(time)

julian_day_fast(time)

julian_century(time)

geom_mean_lon_sun(x)

geom_mean_anom_sun(x)

eccent_earth_orbit(x)

sun_eq_of_ctr(x, anom)

sun_rad_vector(eccent, anom)

sun_app_lon(x, lon)

mean_obliq_eclip(x)

obliq_corr(x, eclip)

sun_rt_ascen(app.lon, obliq.corr)

sun_decline(app.lon, obliq.corr)

var_y(obliq.corr)

eq_of_time(mean.lon, eccent.earth, anom.mean, var.y)

ha_sunrise(lat, decline, nag = 0)

solar_noon(lon, eq.of.time)

sunrise(noon, ha.sunrise)

sunset(noon, ha.sunrise)

sunlight_duration(ha.sunrise, unit.out = "hours")

solar_datetime(time, lat, lon, eq.of.time)

solar_tod(time, lat, lon, eq.of.time)

hour_angle(solar.time)

zenith_angle(lat, hour.angle, decline)

elevation_angle(lat, hour.angle, decline)

atm_refraction_approx(elevation.angle)

azimuth_angle(lat, hour.angle, zenith.angle, decline)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calendar_change_+3A_time">time</code></td>
<td>
<p>dateTime</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_x">x</code></td>
<td>
<p>numeric Julian century</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_anom">anom</code></td>
<td>
<p>numeric Solar anomaly in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eccent">eccent</code></td>
<td>
<p>numeric Eccentricity of Earth orbit</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eclip">eclip</code></td>
<td>
<p>numeric Ecliptic</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_app.lon">app.lon</code>, <code id="calendar_change_+3A_obliq.corr">obliq.corr</code>, <code id="calendar_change_+3A_mean.lon">mean.lon</code>, <code id="calendar_change_+3A_nag">nag</code>, <code id="calendar_change_+3A_decline">decline</code></td>
<td>
<p>numeric Angles in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_lat">lat</code>, <code id="calendar_change_+3A_lon">lon</code></td>
<td>
<p>numeric Geographic coordinates in degrees</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_eq.of.time">eq.of.time</code>, <code id="calendar_change_+3A_ha.sunrise">ha.sunrise</code>, <code id="calendar_change_+3A_noon">noon</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="calendar_change_+3A_zenith.angle">zenith.angle</code>, <code id="calendar_change_+3A_elevation.angle">elevation.angle</code>, <code id="calendar_change_+3A_hour.angle">hour.angle</code></td>
<td>
<p>numeric Angles in degrees</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>POSIXct</code> (inherits from <code>POSIXt</code>) of length 1.
</p>


<h3>Details</h3>

<p>Low level functions based on NOAA's Excel worksheet
</p>


<h3>Value</h3>

<p>datetime
</p>
<p>numeric
</p>

<hr>
<h2 id='day_night'>Times for sun positions</h2><span id='topic+day_night'></span><span id='topic+day_night_fast'></span><span id='topic+is_daytime'></span><span id='topic+noon_time'></span><span id='topic+sunrise_time'></span><span id='topic+sunset_time'></span><span id='topic+day_length'></span><span id='topic+night_length'></span>

<h3>Description</h3>

<p>Functions for calculating the timing of solar positions, given geographical
coordinates and dates. They can be also used to find the time for an
arbitrary solar elevation between 90 and -90 degrees by supplying &quot;twilight&quot;
angle(s) as argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>day_night(
  date = lubridate::now(tzone = "UTC"),
  tz = ifelse(lubridate::is.Date(date), "UTC", lubridate::tz(date)),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "hours"
)

day_night_fast(date, tz, geocode, twilight, unit.out)

is_daytime(
  date = lubridate::now(tzone = "UTC"),
  tz = ifelse(lubridate::is.Date(date), "UTC", lubridate::tz(date)),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "hours"
)

noon_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "none",
  unit.out = "datetime"
)

sunrise_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "datetime"
)

sunset_time(
  date = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(date),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "datetime"
)

day_length(
  date = lubridate::now(tzone = "UTC"),
  tz = "UTC",
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "hours"
)

night_length(
  date = lubridate::now(tzone = "UTC"),
  tz = "UTC",
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  twilight = "sunlight",
  unit.out = "hours"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="day_night_+3A_date">date</code></td>
<td>
<p>&quot;vector&quot; of <code>POSIXct</code> times or<code>Date</code> objects, any valid
TZ is allowed, default is current date at Greenwich matching the default
for <code>geocode</code>.</p>
</td></tr>
<tr><td><code id="day_night_+3A_tz">tz</code></td>
<td>
<p>character vector indicating time zone to be used in output and to
interpret <code>Date</code> values passed as argument to <code>date</code>.</p>
</td></tr>
<tr><td><code id="day_night_+3A_geocode">geocode</code></td>
<td>
<p>data frame with one or more rows and variables lon and lat as
numeric values (degrees). If present, address will be copied to the output.</p>
</td></tr>
<tr><td><code id="day_night_+3A_twilight">twilight</code></td>
<td>
<p>character string, one of &quot;none&quot;, &quot;rim&quot;, &quot;refraction&quot;,
&quot;sunlight&quot;, &quot;civil&quot;, &quot;nautical&quot;, &quot;astronomical&quot;, or a <code>numeric</code> vector
of length one, or two, giving solar elevation angle(s) in degrees (negative
if below the horizon).</p>
</td></tr>
<tr><td><code id="day_night_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;datetime&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;,
or &quot;second&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Twilight names are interpreted as follows. &quot;none&quot;: solar elevation =
0 degrees. &quot;rim&quot;: upper rim of solar disk at the horizon or solar elevation
= -0.53 / 2. &quot;refraction&quot;: solar elevation = 0 degrees + refraction
correction. &quot;sunlight&quot;: upper rim of solar disk corrected for refraction,
which is close to the value used by the online NOAA Solar Calculator.
&quot;civil&quot;: -6 degrees, &quot;naval&quot;: -12 degrees, and &quot;astronomical&quot;: -18 degrees.
Unit names for output are as follows: &quot;day&quot;, &quot;hours&quot;, &quot;minutes&quot; and
&quot;seconds&quot; times for sunrise and sunset are returned as times-of-day since
midnight expressed in the chosen unit. &quot;date&quot; or &quot;datetime&quot; return the same
times as datetime objects with TZ set (this is much slower than &quot;hours&quot;).
Day length and night length are returned as numeric values expressed in
hours when &lsquo;&quot;datetime&quot;&rsquo; is passed as argument to <code>unit.out</code>. If
twilight is a numeric vector of length two, the element with index 1 is
used for sunrise and that with index 2 for sunset.
</p>
<p><code>is_daytime()</code> supports twilight specifications by name, a test
like <code>sun_elevation() &gt; 0</code> may be used directly for a numeric angle.
</p>


<h3>Value</h3>

<p>A tibble with variables day, tz, twilight.rise, twilight.set,
longitude, latitude, address, sunrise, noon, sunset, daylength,
nightlength or the corresponding individual vectors.
</p>
<p>The value returned represents an instant in time or a duration. The
class of the object returned varies depending on the argument passed to
parameter <code>unit.out</code>. If <code>unit.out = "datetime"</code>, the returned
value is a &quot;POSIXct&quot; vector, otherwise it is a &quot;numeric&quot; vector.
</p>
<p><code>is_daytime()</code> returns a logical vector, with <code>TRUE</code> for
day time and <code>FALSE</code> for night time.
</p>
<p><code>noon_time</code>, <code>sunrise_time</code> and <code>sunset_time</code> return a
vector of POSIXct times
</p>
<p><code>day_length</code> and <code>night_length</code> return numeric a vector
giving the length in hours
</p>


<h3>Warning</h3>

<p>Be aware that R's <code>Date</code> class does not save time zone
metadata. This can lead to ambiguities in the current implementation
based on time instants. The argument passed to <code>date</code> should be
of class <code>POSIXct</code>, in other words an instant in time, from which
the correct date will be computed based on the <code>tz</code> argument.
</p>
<p>The time zone in which times passed to <code>date</code> as argument are
expressed does not need to be the local one or match the geocode, however,
the returned values will be in the same time zone as the input.
</p>


<h3>Note</h3>

<p>Function <code>day_night()</code> is an implementation of Meeus equations as
used in NOAAs on-line web calculator, which are very precise and valid for
a very broad range of dates. For sunrise and sunset the times are affected
by refraction in the atmosphere, which does in turn depend on weather
conditions. The effect of refraction on the apparent position of the sun is
only an estimate based on &quot;typical&quot; conditions. The more tangential to the
horizon is the path of the sun, the larger the effect of refraction is on
the times of visual occlusion of the sun behind the horizon&mdash;i.e. the
largest timing errors occur at high latitudes. The computation is not
defined for latitudes 90 and -90 degrees, i.e. at the poles.
</p>
<p>There exists a different R implementation of the same algorithms called
&quot;AstroCalcPureR&quot; available as function <code>astrocalc4r</code> in package
'fishmethods'. Although the equations used are almost all the same, the
function signatures and which values are returned differ. In particular,
the implementation in 'photobiology' splits the calculation into two
separate functions, one returning angles at given instants in time, and a
separate one returning the timing of events for given dates. In
'fishmethods' (= 1.11-0) there is a bug in function astrocalc4r() that
affects sunrise and sunset times. The times returned by the functions in
package 'photobiology' have been validated against the NOAA base
implementation.
</p>
<p>In the current implementation functions <code>sunrise_time</code>,
<code>noon_time</code>, <code>sunset_time</code>, <code>day_length</code>,
<code>night_length</code> and <code>is_daytime</code> are all wrappers
on <code>day_night</code>, so if more than one quantity is needed it is
preferable to directly call <code>day_night</code> and extract the different
components from the returned list.
</p>
<p><code>night_length</code> returns the length of night-time conditions in one
day (00:00:00 to 23:59:59), rather than the length of the night between two
consecutive days.
</p>


<h3>References</h3>

<p>The primary source for the algorithm used is the book:
Meeus, J. (1998) Astronomical Algorithms, 2 ed., Willmann-Bell, Richmond,
VA, USA. ISBN 978-0943396613.
</p>
<p>A different implementation is available at
<a href="https://github.com/NEFSC/READ-PDB-AstroCalc4R/">https://github.com/NEFSC/READ-PDB-AstroCalc4R/</a> and in R paclage
'fishmethods'. In 'fishmethods' (= 1.11-0) there is a bug in function
astrocalc4r() that affects sunrise and sunset times.
</p>
<p>An interactive web page using the same algorithms is available at
<a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>. There are small
differences in the returned times compared to our function that seem to be
related to the estimation of atmospheric refraction (about 0.1 degrees).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sun_angles">sun_angles</a></code>.
</p>
<p>Other astronomy related functions: 
<code><a href="#topic+format.solar_time">format.solar_time</a>()</code>,
<code><a href="#topic+sun_angles">sun_angles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

my.geocode &lt;- data.frame(lon = 24.93838,
                         lat = 60.16986,
                         address = "Helsinki, Finland")

day_night(ymd("2015-05-30", tz = "EET"),
          geocode = my.geocode)
day_night(ymd("2015-05-30", tz = "EET") + days(1:10),
          geocode = my.geocode,
          twilight = "civil")
sunrise_time(ymd("2015-05-30", tz = "EET"),
             geocode = my.geocode)
noon_time(ymd("2015-05-30", tz = "EET"),
          geocode = my.geocode)
sunset_time(ymd("2015-05-30", tz = "EET"),
            geocode = my.geocode)
day_length(ymd("2015-05-30", tz = "EET"),
           geocode = my.geocode)
day_length(ymd("2015-05-30", tz = "EET"),
           geocode = my.geocode,
           unit.out = "day")
is_daytime(ymd("2015-05-30", tz = "EET") + hours(c(0, 6, 12, 18, 24)),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 03:00:00", tz = "EET"),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 00:00:00", tz = "UTC"),
           geocode = my.geocode)
is_daytime(ymd_hms("2015-05-30 03:00:00", tz = "EET"),
           geocode = my.geocode,
           twilight = "civil")
is_daytime(ymd_hms("2015-05-30 00:00:00", tz = "UTC"),
           geocode = my.geocode,
           twilight = "civil")

</code></pre>

<hr>
<h2 id='format.solar_time'>Encode in a Common Format</h2><span id='topic+format.solar_time'></span>

<h3>Description</h3>

<p>Format a <code>solar_time</code> object for pretty printing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solar_time'
format(x, ..., sep = ":")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.solar_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="format.solar_time_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="format.solar_time_+3A_sep">sep</code></td>
<td>
<p>character used as separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the time formatted as &quot;HH:MM:SS&quot;, where &quot;:&quot;
is the argument passed to <code>sep</code>.
</p>


<h3>See Also</h3>

<p>Other astronomy related functions: 
<code><a href="#topic+day_night">day_night</a>()</code>,
<code><a href="#topic+sun_angles">sun_angles</a>()</code>
</p>

<hr>
<h2 id='format.tod_time'>Encode in a Common Format</h2><span id='topic+format.tod_time'></span>

<h3>Description</h3>

<p>Format a <code>tod_time</code> object into a character string for pretty printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tod_time'
format(x, ..., sep = ":")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.tod_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="format.tod_time_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="format.tod_time_+3A_sep">sep</code></td>
<td>
<p>character used as separator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the time formatted as &quot;HH:MM:SS&quot;, where &quot;:&quot;
is the argument passed to <code>sep</code>.
</p>


<h3>See Also</h3>

<p>Other Time of day functions: 
<code><a href="#topic+as_tod">as_tod</a>()</code>,
<code><a href="#topic+print.tod_time">print.tod_time</a>()</code>
</p>

<hr>
<h2 id='irrad_extraterrestrial'>Extraterrestrial solar irradiance</h2><span id='topic+irrad_extraterrestrial'></span>

<h3>Description</h3>

<p>Estimate of down-welling solar (short wave) irradiance at the top of the
atmosphere above a location on Earth, computed based on angles, Sun-Earth
distance and the solar constant. Astronomical computations are done with
function <code>sun_angles()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irrad_extraterrestrial(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = data.frame(lon = 0, lat = 51.5, address = "Greenwich"),
  solar.constant = "NASA"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irrad_extraterrestrial_+3A_time">time</code></td>
<td>
<p>A &quot;vector&quot; of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td></tr>
<tr><td><code id="irrad_extraterrestrial_+3A_solar.constant">solar.constant</code></td>
<td>
<p>numeric or character If character, &quot;WMO&quot; or &quot;NASA&quot;, if
numeric, an irradiance value in the same units as the value to be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of extraterrestrial irradiance (in W / m2 if solar
constant is a character value).
</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+sun_angles">sun_angles</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

irrad_extraterrestrial(ymd_hm("2021-06-21 12:00", tz = "UTC"))

irrad_extraterrestrial(ymd_hm("2021-12-21 20:00", tz = "UTC"))

irrad_extraterrestrial(ymd_hm("2021-06-21 00:00", tz = "UTC") + hours(1:23))

</code></pre>

<hr>
<h2 id='is.solar_time'>Query class</h2><span id='topic+is.solar_time'></span><span id='topic+is.solar_date'></span>

<h3>Description</h3>

<p>Query class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.solar_time(x)

is.solar_date(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.solar_time_+3A_x">x</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if the object <code>x</code> is of class
<code>"solar_time"</code> or <code>"solar_date"</code>, depending on the function.
</p>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='print.solar_time'>Print solar time and solar date objects</h2><span id='topic+print.solar_time'></span><span id='topic+print.solar_date'></span>

<h3>Description</h3>

<p>The object <code>x</code> is printed and returned invisibly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'solar_time'
print(x, ...)

## S3 method for class 'solar_date'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.solar_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="print.solar_time_+3A_...">...</code></td>
<td>
<p>passed to <code>format</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object <code>x</code>, invisibly.
</p>


<h3>Note</h3>

<p>Default is to print the underlying POSIXct or Date as a solar time.
</p>


<h3>See Also</h3>

<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+solar_time">solar_time</a>()</code>
</p>

<hr>
<h2 id='print.tod_time'>Print time-of-day objects</h2><span id='topic+print.tod_time'></span>

<h3>Description</h3>

<p>Defaults to print the underlying <code>numeric</code> vector as a solar time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tod_time'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tod_time_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="print.tod_time_+3A_...">...</code></td>
<td>
<p>passed to <code>format</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns object <code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other Time of day functions: 
<code><a href="#topic+as_tod">as_tod</a>()</code>,
<code><a href="#topic+format.tod_time">format.tod_time</a>()</code>
</p>

<hr>
<h2 id='relative_AM'>Relative Air Mass (AM)</h2><span id='topic+relative_AM'></span><span id='topic+relative_AMt'></span><span id='topic+relative_AM_geotime'></span><span id='topic+relative_AMt_geotime'></span>

<h3>Description</h3>

<p>Approximate relative air mass (AM) computed from the sun's apparent or true
position (sun elevation or sun zenith angle) or from geographic and time
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_AM(
  elevation.angle = NULL,
  zenith.angle = NULL,
  occluded.value = NA_real_
)

relative_AMt(
  elevation.angle = NULL,
  zenith.angle = NULL,
  occluded.value = NA_real_
)

relative_AM_geotime(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  occluded.value = NA_real_
)

relative_AMt_geotime(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  occluded.value = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relative_AM_+3A_elevation.angle">elevation.angle</code>, <code id="relative_AM_+3A_zenith.angle">zenith.angle</code></td>
<td>
<p>numeric vector Angle in degrees for the
sun position. An argument should be passed to one and only one of
<code>elevation_angle</code> or <code>zenith_angle</code>.</p>
</td></tr>
<tr><td><code id="relative_AM_+3A_occluded.value">occluded.value</code></td>
<td>
<p>numeric Value to return when elevation angle is
negative (sun below the horizon).</p>
</td></tr>
<tr><td><code id="relative_AM_+3A_time">time</code></td>
<td>
<p>A &quot;vector&quot; of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td></tr>
<tr><td><code id="relative_AM_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
<tr><td><code id="relative_AM_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>relative_AM()</code> implements equation (3) in Kasten and
Young (1989). This equation is only an approximation to the tabulated
values in the same paper and based on the apparent position of the sun as
observed from Earth surface. <code>relative_AMt()</code> implements equation (5)
in Young (1994). This equation is only an approximation to the tabulated
values based on the true or astronomical position of the sun.
</p>
<p>In both cases returned values are rounded to three significant digits.
</p>
<p>Function <code>relative_AM_geotime()</code> is a wrapper on <code>relative_AM()</code>
that calls function <code>sun_elevation()</code> to obtain the apparent position
of the sun from the geographic and time coordinates. Function
<code>relative_AMt_geotime()</code> is a wrapper on <code>relative_AMt()</code> that
calls function <code>sun_elevation()</code> to obtain the true position of the
sun from the geographic and time coordinates. At very low sun elevations
the values returned by these two functions differ slightly because of the
use of different approximations to correct for atmospheric refraction.
</p>


<h3>Value</h3>

<p>A numeric vector with the relative air mass values.
</p>


<h3>Note</h3>

<p>Although relative air mass is not defined when the sun is not visible,
returning a value different from the default <code>NA</code> might be useful in
some cases and made possible by passing an argument to parameter
<code>occluded.value</code>.
</p>


<h3>References</h3>

<p>F. Kasten, A. T. Young (1989) Revised optical air mass tables and
approximation formula. Applied Optics, 28, 4735-4738. <a href="https://doi.org/10.1364/AO.28.004735">doi:10.1364/AO.28.004735</a>.
</p>
<p>Young, A. T. (1994) Air mass and refraction. Applied Optics, 33, 1108-1110.
<a href="https://doi.org/10.1364/AO.33.001108">doi:10.1364/AO.33.001108</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sun_angles">sun_angles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the apparent sun elevation
relative_AM(elevation.angle = c(90, 60, 30, 1, -10))
relative_AM(elevation.angle = c(90, 60, 30, 1, -10),
            occluded.value = Inf)
relative_AM(zenith.angle = 0)

# using the true or astronomical sun elevation
relative_AMt(elevation.angle = c(90, 60, 30, 1, -10))
relative_AMt(elevation.angle = c(90, 60, 30, 1, -10),
            occluded.value = Inf)
relative_AMt(zenith.angle = 0)

# Define example geographic and time coordinates
baires.geo &lt;-
  data.frame(lat = 34.60361, lon = -58.38139, address = "Buenos Aires")

# using time and geographic coordinates
library(lubridate)
relative_AM_geotime(ymd_hms("2014-06-23 12:00:00",
                            tz = "America/Argentina/Buenos_Aires"),
                    geocode = baires.geo)
relative_AMt_geotime(ymd_hms("2014-06-23 12:00:00",
                             tz = "America/Argentina/Buenos_Aires"),
                    geocode = baires.geo)
relative_AM_geotime(ymd_hms("2014-06-23 12:00:00",
                            tz = "America/Argentina/Buenos_Aires") +
                      hours(0:12),
                    geocode = baires.geo)

</code></pre>

<hr>
<h2 id='solar_time'>Local solar time</h2><span id='topic+solar_time'></span>

<h3>Description</h3>

<p><code>solar_time()</code> computes the time of day expressed in seconds since the
astronomical midnight using and instant in time and a geocode as input. Solar
time is useful when we want to plot data according to the local solar time
rather than the local time in use at a time zone. How the returned instant in
time is expressed depends on the argument passed to <code>unit.out</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_time(
  time = lubridate::now(),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  unit.out = "time"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solar_time_+3A_time">time</code></td>
<td>
<p>POSIXct Time, any valid time zone (TZ) is allowed, default is
current time.</p>
</td></tr>
<tr><td><code id="solar_time_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees).</p>
</td></tr>
<tr><td><code id="solar_time_+3A_unit.out">unit.out</code></td>
<td>
<p>character string, One of &quot;datetime&quot;, &quot;time&quot;, &quot;hour&quot;, &quot;minute&quot;, or
&quot;second&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solar time is determined by the position of the sun in the sky and
it almost always differs from the time expressed in the local time
coordinates in use. The differences can vary from a few minutes up to a
couple of hours depending on the exact location within the time zone and the
use or not of daylight saving time.
</p>


<h3>Value</h3>

<p>In all cases solar time is expressed as time since local astronomical
midnight and, thus, lacks date information. If <code>unit.out = "time"</code>, a
numeric value in seconds with an additional class attribute
&quot;solar_time&quot;; if <code>unit.out = "datetime"</code>, a &quot;POSIXct&quot; value in seconds
from midnight but with an additional class attribute &quot;solar_date&quot;; if
<code>unit.out = "hour"</code> or <code>unit.out = "minute"</code> or <code>unit.out =
  "second"</code>, a numeric value.
</p>


<h3>Warning!</h3>

<p>Returned values are computed based on the time zone of the
argument for parameter time. In the case of solar time, this timezone does
not affect the result. However, in the case of solar dates the date part
may be off by one day, if the time zone does not match the coordinates of
the geocode value provided as argument.
</p>


<h3>Note</h3>

<p>The algorithm is approximate, it calculates the difference between
local solar noon and noon in the time zone of <code>time</code> and uses this
value for the whole day when converting times into solar time. Days are not
exactly 24 h long. Between successive days the shift is only a few seconds,
and this leads to a small jump at midnight.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_tod">as_tod</a></code>
</p>
<p>Other Local solar time functions: 
<code><a href="#topic+as.solar_date">as.solar_date</a>()</code>,
<code><a href="#topic+is.solar_time">is.solar_time</a>()</code>,
<code><a href="#topic+print.solar_time">print.solar_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BA.geocode &lt;-
  data.frame(lon = -58.38156, lat = -34.60368, address = "Buenos Aires, Argentina")
sol_t &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode)
sol_t
class(sol_t)

sol_d &lt;- solar_time(lubridate::dmy_hms("21/06/2016 10:00:00", tz = "UTC"),
                    BA.geocode,
                    unit.out = "datetime")
sol_d
class(sol_d)

</code></pre>

<hr>
<h2 id='sun_angles'>Sun angles</h2><span id='topic+sun_angles'></span><span id='topic+sun_angles_fast'></span><span id='topic+sun_elevation'></span><span id='topic+sun_zenith_angle'></span><span id='topic+sun_azimuth'></span><span id='topic+distance_to_sun'></span>

<h3>Description</h3>

<p>Function <code>sun_angles()</code> returns the solar angles and Sun to Earth
relative distance for given times and locations using a very accurate
algorithm. Convenience functions <code>sun_azimuth()</code>,
<code>sun_elevation()</code>, <code>sun_zenith_angle()</code> and
<code>distance_to_sun()</code> are wrappers on <code>sun_angles()</code> that return
individual vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sun_angles(
  time = lubridate::now(tzone = "UTC"),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_angles_fast(time, tz, geocode, use.refraction)

sun_elevation(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_zenith_angle(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

sun_azimuth(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)

distance_to_sun(
  time = lubridate::now(),
  tz = lubridate::tz(time),
  geocode = tibble::tibble(lon = 0, lat = 51.5, address = "Greenwich"),
  use.refraction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sun_angles_+3A_time">time</code></td>
<td>
<p>A &quot;vector&quot; of POSIXct Time, with any valid time zone (TZ) is
allowed, default is current time.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_tz">tz</code></td>
<td>
<p>character string indicating time zone to be used in output.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_geocode">geocode</code></td>
<td>
<p>data frame with variables lon and lat as numeric values
(degrees), nrow &gt; 1, allowed.</p>
</td></tr>
<tr><td><code id="sun_angles_+3A_use.refraction">use.refraction</code></td>
<td>
<p>logical Flag indicating whether to correct for
fraction in the atmosphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of Meeus equations as used in
NOAA's on-line web calculator, which are precise and valid for a very broad
range of dates (years -1000 to 3000 at least). The apparent solar
elevations near sunrise and sunset are affected by refraction in the
atmosphere, which does in turn depend on weather conditions. The effect of
refraction on the apparent position of the sun is only an estimate based on
&quot;typical&quot; conditions for the atmosphere. The computation is not defined for
latitudes 90 and -90 degrees, i.e. exactly at the poles. The function is
vectorized and in particular passing a vector of times for a single geocode
enhances performance very much as the equation of time, the most time
consuming step, is computed only once.
</p>
<p>For improved performance, if more than one angle is needed it
is preferable to directly call <code>sun_angles</code> instead of the wrapper
functions as this avoids the unnecesary recalculation.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with variables <code>time</code> (in same TZ as input),
<code>TZ</code>, <code>solartime</code>, <code>longitude</code>, <code>latitude</code>,
<code>address</code>, <code>azimuth</code>, <code>elevation</code>, <code>declination</code>,
<code>eq.of.time</code>, <code>hour.angle</code>, and <code>distance</code>. If a data frame
with multiple rows is passed to <code>geocode</code> and a vector of times longer
than one is passed to <code>time</code>, sun position for all combinations of
locations and times are returned by <code>sun_angles</code>. Angles are expressed
in degrees, <code>solartime</code> is a vector of class <code>"solar.time"</code>,
<code>distance</code> is expressed in relative sun units.
</p>


<h3>Important!</h3>

<p>Given an instant in time and a time zone, the date is
computed from these, and may differ by one day to that at the location
pointed by <code>geocode</code> at the same instant in time, unless the argument
passed to <code>tz</code> matches the time zone at this location.
</p>


<h3>Note</h3>

<p>There exists a different R implementation of the same algorithms called
&quot;AstroCalcPureR&quot; available as function <code>astrocalc4r</code> in package
'fishmethods'. Although the equations used are almost all the same, the
function signatures and which values are returned differ. In particular,
the present implementation splits the calculation into two separate
functions, one returning angles at given instants in time, and a separate
one returning the timing of events for given dates.
</p>


<h3>References</h3>

<p>The primary source for the algorithm used is the book:
Meeus, J. (1998) Astronomical Algorithms, 2 ed., Willmann-Bell, Richmond,
VA, USA. ISBN 978-0943396613.
</p>
<p>A different implementation is available at
<a href="https://github.com/NEFSC/READ-PDB-AstroCalc4R/">https://github.com/NEFSC/READ-PDB-AstroCalc4R/</a>.
</p>
<p>An interactive web page using the same algorithms is available at
<a href="https://gml.noaa.gov/grad/solcalc/">https://gml.noaa.gov/grad/solcalc/</a>. There are small
differences in the returned times compared to our function that seem to be
related to the estimation of atmospheric refraction (about 0.1 degrees).
</p>


<h3>See Also</h3>

<p>Other astronomy related functions: 
<code><a href="#topic+day_night">day_night</a>()</code>,
<code><a href="#topic+format.solar_time">format.solar_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
sun_angles()
sun_azimuth()
sun_elevation()
sun_zenith_angle()
sun_angles(ymd_hms("2014-09-23 12:00:00"))
sun_angles(ymd_hms("2014-09-23 12:00:00"),
           geocode = data.frame(lat=60, lon=0))
sun_angles(ymd_hms("2014-09-23 12:00:00") + minutes((0:6) * 10))

</code></pre>

<hr>
<h2 id='twilight2angle'>twilight argument check and conversion</h2><span id='topic+twilight2angle'></span>

<h3>Description</h3>

<p>twilight argument check and conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twilight2angle(twilight)
</code></pre>


<h3>Value</h3>

<p>numeric Solar elevation angle at sunrise or sunset
</p>

<hr>
<h2 id='tz_time_diff'>Time difference between two time zones</h2><span id='topic+tz_time_diff'></span>

<h3>Description</h3>

<p>Returns the difference in local time expressed in hours between two time
zones at a given instant in time. The difference due to daylight saving time
or Summer and Winter time as well as historical changes in time zones are
taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tz_time_diff(
  when = lubridate::now(),
  tz.target = lubridate::tz(when),
  tz.reference = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tz_time_diff_+3A_when">when</code></td>
<td>
<p>datetime A time instant</p>
</td></tr>
<tr><td><code id="tz_time_diff_+3A_tz.target">tz.target</code>, <code id="tz_time_diff_+3A_tz.reference">tz.reference</code></td>
<td>
<p>character Two time zones using names
recognized by functions from package 'lubridate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value.
</p>


<h3>Note</h3>

<p>This function is implemented using functions from package 'lubridate'.
For details on the handling of time zones, please, consult the
documentation for <code><a href="base.html#topic+Sys.timezone">Sys.timezone</a></code> about system differences in
time zone names and handling.
</p>

<hr>
<h2 id='validate_geocode'>Validate a geocode</h2><span id='topic+validate_geocode'></span><span id='topic+is_valid_geocode'></span><span id='topic+length_geocode'></span><span id='topic+na_geocode'></span>

<h3>Description</h3>

<p>Test validity of a geocode or ensure that a geocode is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_geocode(geocode)

is_valid_geocode(geocode)

length_geocode(geocode)

na_geocode()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_geocode_+3A_geocode">geocode</code></td>
<td>
<p>data.frame with geocode data in columns <code>"lat"</code>,
<code>"lon"</code>, and possibly also <code>"address"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>validate_geocode</code> Converts to tibble, checks data bounds, converts
address to character if it is not already a character vector, or add
character NAs if the address column is missing.
</p>
<p><code>is_valid_geocode</code> Checks if a geocode is valid, returning 0L if not,
and the number of row otherwise.
</p>


<h3>Value</h3>

<p>A valid geocode stored in a tibble.
</p>
<p>FALSE for invalid, TRUE for valid.
</p>
<p>FALSE for invalid, number of rows for valid.
</p>
<p>A geo_code tibble with all fields set to suitable NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
validate_geocode(NA)
validate_geocode(data.frame(lon = -25, lat = 66))

is_valid_geocode(NA)
is_valid_geocode(1L)
is_valid_geocode(data.frame(lon = -25, lat = 66))

na_geocode()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
