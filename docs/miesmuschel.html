<!DOCTYPE html><html><head><title>Help for package miesmuschel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miesmuschel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#miesmuschel-package'><p>miesmuschel: Mixed Integer Evolution Strategies</p></a></li>
<li><a href='#crate_env'><p>Set a Function's Environment</p></a></li>
<li><a href='#dict_filtors'><p>Dictionary of Filtors</p></a></li>
<li><a href='#dict_filtors_maybe'><p>Filtor-Combination that Filters According to Two Filtors</p></a></li>
<li><a href='#dict_filtors_null'><p>Null-Filtor</p></a></li>
<li><a href='#dict_filtors_proxy'><p>Proxy-Filtor that Filters According to its Configuration Parameter</p></a></li>
<li><a href='#dict_filtors_surprog'><p>Progressive Surrogate Model Filtering</p></a></li>
<li><a href='#dict_filtors_surtour'><p>Tournament Surrogate Model Filtering</p></a></li>
<li><a href='#dict_mutators'><p>Dictionary of Mutators</p></a></li>
<li><a href='#dict_mutators_cmpmaybe'><p>Mutator Choosing Action Component-Wise Independently</p></a></li>
<li><a href='#dict_mutators_erase'><p>Uniform Sample Mutator</p></a></li>
<li><a href='#dict_mutators_gauss'><p>Gaussian Distribution Mutator</p></a></li>
<li><a href='#dict_mutators_maybe'><p>Mutator Choosing Action Probabilistically</p></a></li>
<li><a href='#dict_mutators_null'><p>Null Mutator</p></a></li>
<li><a href='#dict_mutators_proxy'><p>Proxy-Mutator that Mutates According to its Configuration parameter</p></a></li>
<li><a href='#dict_mutators_sequential'><p>Run Multiple Mutator Operations in Sequence</p></a></li>
<li><a href='#dict_mutators_unif'><p>Uniform Discrete Mutator</p></a></li>
<li><a href='#dict_recombinators'><p>Dictionary of Recombinators</p></a></li>
<li><a href='#dict_recombinators_cmpmaybe'><p>Recombinator Choosing Action Component-Wise Independently</p></a></li>
<li><a href='#dict_recombinators_convex'><p>Convex Combination Recombinator</p></a></li>
<li><a href='#dict_recombinators_cvxpair'><p>Convex Combination Recombinator for Pairs</p></a></li>
<li><a href='#dict_recombinators_maybe'><p>Recombinator Choosing Action Probabilistically</p></a></li>
<li><a href='#dict_recombinators_null'><p>Null-Recombinator</p></a></li>
<li><a href='#dict_recombinators_proxy'><p>Proxy-Recombinator that Recombines According to its Configuration parameter</p></a></li>
<li><a href='#dict_recombinators_sbx'><p>Simulated Binary Crossover Recombinator</p></a></li>
<li><a href='#dict_recombinators_sequential'><p>Run Multiple Recombinator Operations in Sequence</p></a></li>
<li><a href='#dict_recombinators_swap'><p>Swap Recombinator</p></a></li>
<li><a href='#dict_recombinators_xonary'><p>N-ary Crossover Recombinator</p></a></li>
<li><a href='#dict_recombinators_xounif'><p>Crossover Recombinator</p></a></li>
<li><a href='#dict_scalors'><p>Dictionary of Scalors</p></a></li>
<li><a href='#dict_scalors_aggregate'><p>Scalor giving Weighted Sum of Multiple Scalors</p></a></li>
<li><a href='#dict_scalors_domcount'><p>Scalor Counting Dominating Individuals</p></a></li>
<li><a href='#dict_scalors_fixedprojection'><p>Multi-Objective Fixed Projection Scalor</p></a></li>
<li><a href='#dict_scalors_hypervolume'><p>Hypervolume Scalor</p></a></li>
<li><a href='#dict_scalors_nondom'><p>Nondominated Sorting Scalor</p></a></li>
<li><a href='#dict_scalors_one'><p>Single Dimension Scalor</p></a></li>
<li><a href='#dict_scalors_proxy'><p>Proxy-Scalor that Scales According to its Configuration parameter</p></a></li>
<li><a href='#dict_scalors_single'><p>Single Objective Scalor</p></a></li>
<li><a href='#dict_selectors'><p>Dictionary of Selectors</p></a></li>
<li><a href='#dict_selectors_best'><p>Best Value Selector</p></a></li>
<li><a href='#dict_selectors_maybe'><p>Selector-Combination that Selects According to Two Selectors</p></a></li>
<li><a href='#dict_selectors_null'><p>Null Selector</p></a></li>
<li><a href='#dict_selectors_proxy'><p>Proxy-Selector that Selects According to its Configuration Parameter</p></a></li>
<li><a href='#dict_selectors_random'><p>Random Selector</p></a></li>
<li><a href='#dict_selectors_sequential'><p>Run Multiple Selection Operations in Sequence</p></a></li>
<li><a href='#dict_selectors_tournament'><p>Tournament Selector</p></a></li>
<li><a href='#dist_crowding'><p>Calculate Crowding Distance</p></a></li>
<li><a href='#domhv'><p>Calculate Dominated Hypervolume</p></a></li>
<li><a href='#domhv_contribution'><p>Calculate Hypervolume Contribution</p></a></li>
<li><a href='#domhv_improvement'><p>Calculate Hypervolume Improvement</p></a></li>
<li><a href='#Filtor'><p>Filtor Base Class</p></a></li>
<li><a href='#FiltorSurrogate'><p>Abstract Surrogate Model Filtering Base Class</p></a></li>
<li><a href='#mies_aggregate_generations'><p>Get Aggregated Performance Values by Generation</p></a></li>
<li><a href='#mies_aggregate_single_generation'><p>Aggregate a Value for a given Generation</p></a></li>
<li><a href='#mies_evaluate_offspring'><p>Evaluate Proposed Configurations Generated in a MIES Iteration</p></a></li>
<li><a href='#mies_filter_offspring'><p>Filter Offspring</p></a></li>
<li><a href='#mies_generate_offspring'><p>Generate Offspring Through Mutation and Recombination</p></a></li>
<li><a href='#mies_generation'><p>Get the Last Generation that was Evaluated</p></a></li>
<li><a href='#mies_generation_apply'><p>Aggregate Values for All Generations Present</p></a></li>
<li><a href='#mies_get_fitnesses'><p>Get Fitness Values from OptimInstance</p></a></li>
<li><a href='#mies_get_generation_results'><p>Get Performance Values by Generation</p></a></li>
<li><a href='#mies_init_population'><p>Initialize MIES Optimization</p></a></li>
<li><a href='#mies_prime_operators'><p>Prime MIES Operators</p></a></li>
<li><a href='#mies_select_from_archive'><p>Select Individuals from an OptimInstance</p></a></li>
<li><a href='#mies_step_fidelity'><p>Re-Evaluate Existing Configurations with Higher Fidelity</p></a></li>
<li><a href='#mies_survival_comma'><p>Choose Survivors According to the &quot;Mu , Lambda&quot; (&quot;Comma&quot;) Strategy</p></a></li>
<li><a href='#mies_survival_plus'><p>Choose Survivors According to the &quot;Mu + Lambda&quot; (&quot;Plus&quot;) Strategy</p></a></li>
<li><a href='#MiesOperator'><p>Operator Base Class</p></a></li>
<li><a href='#mlr_terminators_budget'><p>Terminator that Limits Total Budget Component Evaluation</p></a></li>
<li><a href='#mlr_terminators_genperfreached'><p>Terminator That Stops When a Generation-Wise Aggregated Value Reaches a Target</p></a></li>
<li><a href='#mlr_terminators_gens'><p>Terminator that Counts OptimizerMies Generations</p></a></li>
<li><a href='#mlr_terminators_genstag'><p>Terminator That Stops When a Generation-Wise Aggregated Value Stagnates</p></a></li>
<li><a href='#mut'><p>Short Access Forms for Operators</p></a></li>
<li><a href='#Mutator'><p>Mutator Base Class</p></a></li>
<li><a href='#MutatorDiscrete'><p>Discrete Mutator Base Class</p></a></li>
<li><a href='#MutatorNumeric'><p>Numeric Mutator Base Class</p></a></li>
<li><a href='#OperatorCombination'><p>Self-Adaptive Operator Combinations</p></a></li>
<li><a href='#OptimInstanceMultiCrit'><p>OptimInstanceMultiCrit Class</p></a></li>
<li><a href='#OptimInstanceSingleCrit'><p>OptimInstanceSingleCrit Class</p></a></li>
<li><a href='#Optimizer'><p>Optimizer Class</p></a></li>
<li><a href='#OptimizerMies'><p>Mixed Integer Evolution Strategies Optimizer</p></a></li>
<li><a href='#ParamSetShadow'><p>ParamSetShadow</p></a></li>
<li><a href='#rank_nondominated'><p>Perform Nondominated Sorting</p></a></li>
<li><a href='#Recombinator'><p>Recombinator Base Class</p></a></li>
<li><a href='#RecombinatorPair'><p>Pair Recombinator Base Class</p></a></li>
<li><a href='#repr'><p>Create a 'call' Object Representation</p></a></li>
<li><a href='#SamplerRandomWeights'><p>Sampler for Projection Weights</p></a></li>
<li><a href='#Scalarizer'><p>Scalarizer</p></a></li>
<li><a href='#scalarizer_chebyshev'><p>Chebyshev Scalarizer</p></a></li>
<li><a href='#scalarizer_linear'><p>Linear Scalarizer</p></a></li>
<li><a href='#Scalor'><p>Scalor Base Class</p></a></li>
<li><a href='#Selector'><p>Selector Base Class</p></a></li>
<li><a href='#SelectorScalar'><p>Selector making use of Scalors</p></a></li>
<li><a href='#terminator_get_generations'><p>Get the Numger of Generations that a Terminator Allows</p></a></li>
<li><a href='#TuningInstanceMultiCrit'><p>TuningInstanceMultiCrit Class</p></a></li>
<li><a href='#TuningInstanceSingleCrit'><p>TuningInstanceSingleCrit Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mixed Integer Evolution Strategies</td>
</tr>
<tr>
<td>Description:</td>
<td>Evolutionary black box optimization algorithms building on the
  'bbotk' package. 'miesmuschel' offers both ready-to-use optimization
  algorithms, as well as their fundamental building blocks that can be used to
  manually construct specialized optimization loops. The Mixed Integer Evolution
  Strategies as described by Li et al. (2013) &lt;<a href="https://doi.org/10.1162%2FEVCO_a_00059">doi:10.1162/EVCO_a_00059</a>&gt; can be
  implemented, as well as the multi-objective optimization algorithms NSGA-II
  by Deb, Pratap, Agarwal, and Meyarivan (2002) &lt;<a href="https://doi.org/10.1109%2F4235.996017">doi:10.1109/4235.996017</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlr-org/miesmuschel">https://github.com/mlr-org/miesmuschel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/miesmuschel/issues">https://github.com/mlr-org/miesmuschel/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>paradox (&ge; 0.7.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mlr3misc (&ge; 0.5.0), checkmate (&ge; 1.9.0), R6, bbotk (&ge;
0.3.0.900), data.table, matrixStats, lgr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, mlr3tuning, mlr3, mlr3learners, ranger, xgboost,
rpart</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'dictionaries.R' 'MiesOperator.R' 'Filtor.R' 'FiltorMaybe.R'
'FiltorNull.R' 'FiltorProxy.R' 'FiltorSurrogate.R'
'FiltorSurrogateProgressive.R' 'FiltorSurrogateTournament.R'
'Mutator.R' 'MutatorCmpMaybe.R' 'MutatorDiscreteUniform.R'
'MutatorErase.R' 'MutatorGauss.R' 'MutatorMaybe.R'
'MutatorNull.R' 'MutatorProxy.R' 'MutatorSequential.R'
'ParamSetShadow.R' 'OperatorCombination.R' 'Recombinator.R'
'Selector.R' 'mies_methods.R' 'OptimizerMies.R'
'RecombinatorCmpMaybe.R' 'RecombinatorConvex.R'
'RecombinatorConvexPair.R' 'RecombinatorCrossoverNary.R'
'RecombinatorCrossoverUniform.R' 'RecombinatorMaybe.R'
'RecombinatorNull.R' 'RecombinatorProxy.R'
'RecombinatorSequential.R'
'RecombinatorSimulatedBinaryCrossover.R' 'RecombinatorSwap.R'
'Scalor.R' 'ScalorAggregate.R' 'ScalorDomcount.R'
'ScalorFixedProjections.R' 'ScalorHypervolume.R'
'ScalorNondom.R' 'ScalorOne.R' 'ScalorProxy.R'
'ScalorSingleObjective.R' 'SelectorBest.R' 'SelectorMaybe.R'
'SelectorNull.R' 'SelectorProxy.R' 'SelectorRandom.R'
'SelectorSequential.R' 'SelectorTournament.R'
'TerminatorBudget.R' 'TerminatorGenerationPerfReached.R'
'TerminatorGenerationStagnation.R' 'TerminatorGenerations.R'
'TunerMies.R' 'bibentries.R' 'repr.R' 'utils.R' 'utils_mo.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 11:46:11 UTC; user</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Binder [aut, cre],
  Lennart Schneider <a href="https://orcid.org/0000-0003-4152-5308"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Susanne Dandl <a href="https://orcid.org/0000-0003-4324-4163"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Andreas Hofheinz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Binder &lt;mlr.developer@mb706.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='miesmuschel-package'>miesmuschel: Mixed Integer Evolution Strategies</h2><span id='topic+miesmuschel'></span><span id='topic+miesmuschel-package'></span>

<h3>Description</h3>

<p><code>miesmuschel</code> offers both an <code>Optimizer</code> and a <code>Tuner</code> for general
MIES-optimization, as well as all the building blocks for building a custom optimization algorithm that
is more flexible and can be used for research into novel evolution strategies.
</p>
<p>The call-graph of the default algorithm in <code><a href="#topic+OptimizerMies">OptimizerMies</a></code> / <code><a href="#topic+TunerMies">TunerMies</a></code> is as follows, and is shown
here as an overview over the <code style="white-space: pre;">&#8288;mies_*&#8288;</code> functions, and how they are usually connected. (Note that only the
exported <code style="white-space: pre;">&#8288;mies_*&#8288;</code> functions are shown.) See the help information of these functions for more info.
</p>
<div class="sourceCode"><pre>OptimizerMies$.optimize(inst)
|- mies_prime_operators()  # prime operators on instance's search_space
|- mies_init_population()  # sample and evaluate first generation
|  `- mies_evaluate_offspring()  # evaluate sampled individuals
|     `- inst$eval_batch()  # The OptimInst's evaluation method
`- repeat # Repeat the following until terminated
   |- mies_step_fidelity()  # Evaluate individuals with changing fidelity
   |  `- inst$eval_batch()  # The OptimInst's evaluation method
   |- mies_generate_offspring()  # Sample parents, recombine, mutate
   |  `- mies_select_from_archive()  # Use 'Selector' on 'Archive'
   |     `- mies_get_fitnesses()  # Get objective values as fitness matrix
   |- mies_evaluate_offspring()  # evaluate sampled individuals
   |  `- inst$eval_batch()  # The OptimInst's evaluation method
   `- mies_survival_plus() / mies_survival_comma()  # survival
      `- mies_select_from_archive()  # Use 'Selector' on 'Archive'
</pre></div>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Binder <a href="mailto:mlr.developer@mb706.com">mlr.developer@mb706.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Lennart Schneider <a href="mailto:lennart.sch@web.de">lennart.sch@web.de</a> (<a href="https://orcid.org/0000-0003-4152-5308">ORCID</a>) [contributor]
</p>
</li>
<li><p> Susanne Dandl <a href="mailto:dandl.susanne@googlemail.com">dandl.susanne@googlemail.com</a> (<a href="https://orcid.org/0000-0003-4324-4163">ORCID</a>) [contributor]
</p>
</li>
<li><p> Andreas Hofheinz <a href="mailto:andreas.hofheinz@outlook.com">andreas.hofheinz@outlook.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlr-org/miesmuschel">https://github.com/mlr-org/miesmuschel</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/miesmuschel/issues">https://github.com/mlr-org/miesmuschel/issues</a>
</p>
</li></ul>


<hr>
<h2 id='crate_env'>Set a Function's Environment</h2><span id='topic+crate_env'></span>

<h3>Description</h3>

<p>Useful to represent functions efficiently within <code>repr()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crate_env(fun, namespace = "R_GlobalEnv", ..., selfref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crate_env_+3A_fun">fun</code></td>
<td>
<p>(<code>function</code>)<br />
Function of which the environment should be set.</p>
</td></tr>
<tr><td><code id="crate_env_+3A_namespace">namespace</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the namespace, as given by <code><a href="base.html#topic+environment">environmentName()</a></code>,
to be used as the (parent of the) environment of <code>fun</code>. Special values
<code>"R_GlobalEnv"</code> (global environment), <code>"R_BaseEnv"</code> (base environment;
note this one is non-standard within R), <code>"R_EmptyEnv"</code> (empty environment).
The content of the namespace is not modified. Default <code>"R_GlobalEnv"</code>.</p>
</td></tr>
<tr><td><code id="crate_env_+3A_...">...</code></td>
<td>
<p>(<code>list</code>)<br />
Content of environments within which to place <code>fun</code>.</p>
</td></tr>
<tr><td><code id="crate_env_+3A_selfref">selfref</code></td>
<td>
<p>(<code>character(1)</code> | named <code>integer</code> | <code>NULL</code>)<br />
If <code>character(1)</code>: The name of the entry of the first element in <code>...</code> that
refers to the function itself. If a named <code>integer</code>, then the values
indicate the lists in <code>...</code> where the reference to the function should be
placed see examples. Default <code>NULL</code>: No reference to the function itself is
present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>function</code>: The given <code>fun</code> with changed environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
identity2 = crate_env(function(x) x, "base")
identical(identity, identity2)  # TRUE

y = 1
f1 = mlr3misc::crate(function(x) x + y, y, .parent = .GlobalEnv)
f2 = crate_env(function(x) x + y, "R_GlobalEnv", list(y = 1))

# Note identical() does not apply because both contain (equal, but not
# identical) 'y = 1'-environments
all.equal(f1, f2)  # TRUE
f1(10)  # 10 + 1 == 11

factorial1 = mlr3misc::crate(
  function(x) if (x &gt; 0) x * factorial1(x - 1) else 1,
  y, .parent = .GlobalEnv
)
environment(factorial1)$factorial1 = factorial1

factorial2 = crate_env(
  function(x) if (x &gt; 0) x * factorial1(x - 1) else 1,
  "R_GlobalEnv", list(y = 1), selfref = "factorial1")
# putting 'factorial1' into the list (or repeating function(x) ....)
# would *not* work, since we want:
identical(environment(factorial2)$factorial1, factorial2)  # TRUE

all.equal(factorial1, factorial2)  # TRUE

g = crate_env(function(x) x + y + z, "miesmuschel",
  list(y = 1), list(z = 2), selfref = c(X = 1, Y = 2, Z = 2))
g(0)  # 0 + 1 + 2 == 3
identical(environment(g)$X, g)
identical(parent.env(environment(g))$Y, g)
identical(parent.env(environment(g))$Z, g)
identical(
  parent.env(parent.env(environment(g))),
  loadNamespace("miesmuschel")
)
</code></pre>

<hr>
<h2 id='dict_filtors'>Dictionary of Filtors</h2><span id='topic+dict_filtors'></span>

<h3>Description</h3>

<p>Dictionary of Filtors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_filtors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>DictionaryFiltor</code> (inherits from <code>DictionaryEx</code>, <code>Dictionary</code>, <code>R6</code>) of length 15.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>, as well as:
</p>

<ul>
<li> <p><code>help(key, help_type)</code><br />
(<code>character(1)</code>, <code>character(1)</code>)<br />
Displays help for the dictionary entry <code>key</code>. <code>help_type</code> is one of
<code>"text"</code>, <code>"html"</code>, <code>"pdf"</code> and given as the <code>help_type</code> argument of R's <code>help()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_mutators">dict_mutators</a></code>,
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code>,
<code><a href="#topic+dict_scalors">dict_scalors</a></code>,
<code><a href="#topic+dict_selectors">dict_selectors</a></code>,
<code><a href="#topic+mut">mut</a>()</code>
</p>

<hr>
<h2 id='dict_filtors_maybe'>Filtor-Combination that Filters According to Two Filtors</h2><span id='topic+dict_filtors_maybe'></span><span id='topic+FiltorMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Filtor">Filtor</a></code> that wraps two other <code><a href="#topic+Filtor">Filtor</a></code>s given during construction and chooses which operation to perform.
Each of the resulting <code>n_filter</code> individuals is chosen either from <code style="white-space: pre;">&#8288;$filtor&#8288;</code>, or from <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code>.
</p>
<p>This makes it possible to implement filter methods such as random interleaving, where only a fraction of <code>p</code>
individuals were filtered and the others were not.
</p>
<p>Letting the number of individuals chosen by <code style="white-space: pre;">&#8288;$filtor&#8288;</code> be <code>n_filter_f</code>, then <code>n_filter_f</code> is either fixed
set to <code>round(n_filter * p)</code>, (when <code>random_choise</code> is <code>FALSE</code>) or to <code>rbinom(1, n_filter, p)</code> (when <code>random_choice</code> is <code>TRUE</code>).
</p>
<p>When <code>random_choice</code> is <code>FALSE</code>, then <code style="white-space: pre;">&#8288;$needed_input()&#8288;</code> is calculated directly from <code style="white-space: pre;">&#8288;$needed_input()&#8288;</code> of <code style="white-space: pre;">&#8288;$filtor&#8288;</code> and <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code>,
as well as <code>n_filter_f</code> and <code>n_filter - n_filter_f</code>.
</p>
<p>When <code>random_choice</code> is <code>TRUE</code>, then <code style="white-space: pre;">&#8288;$needed_input()&#8288;</code> is considers the &quot;worst case&quot; from <code style="white-space: pre;">&#8288;$filtor&#8288;</code> and <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code>, and assumes that
<code style="white-space: pre;">&#8288;$needed_input()&#8288;</code> is monotonically increasing in its input argument.
</p>
<p>To make the worst case less extreme, the number of individuals chosen with <code>random_choice</code> set to <code>TRUE</code> is limited to
<code>qbinom(-20, n_filter, p, log.p = TRUE)</code> (with <code>lower.tail</code> <code>FALSE</code> and <code>TRUE</code> for <code style="white-space: pre;">&#8288;$filtor&#8288;</code> and <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code>, respectively), which distorts the binomial
distribution with probability <code>1 - exp(-20)</code> or about <code>1 - 0.5e-9</code>.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Filtor">Filtor</a></code>s that it wraps: The configuration parameters of the operator given to the <code>filtor</code> construction argument
are prefixed with <code>"maybe."</code>, the configuration parameters of the operator given to the <code>filtor_not</code> construction argument are prefixed with <code>"maybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p</code> :: <code>numeric(1)</code> <br />
Probability per individual (when <code>random_choise</code> is <code>TRUE</code>), or fraction of individuals (when <code>random_choice</code> is <code>FALSE</code>),
that are chosen from <code style="white-space: pre;">&#8288;$filtor&#8288;</code> instead of <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code>. Must be set by the user.
</p>
</li>
<li> <p><code>random_choice</code> :: <code>logical(1)</code> <br />
Whether to sample the number of individuals chosen by <code style="white-space: pre;">&#8288;$filtor&#8288;</code> according to <code>rbinom(1, n_filter, p)</code>, or to use a fixed fraction.
Initialized to <code>FALSE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>filtor</code> and <code>filtor_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Filtor">Filtor</a></code> can be created with the short access form <code><a href="#topic+ftr">ftr()</a></code>
(<code><a href="#topic+ftrs">ftrs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_filtors">dict_filtors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
ftr("maybe", &lt;filtor&gt; [, &lt;filtor_not&gt;])
ftrs("maybe", &lt;filtor&gt; [, &lt;filtor_not&gt;])  # takes vector IDs, returns list of Filtors

# long form:
dict_filtors$get("maybe", &lt;filtor&gt; [, &lt;filtor_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code>FiltorMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>filtor</code></dt><dd><p>(<code><a href="#topic+Filtor">Filtor</a></code>)<br />
<code><a href="#topic+Filtor">Filtor</a></code> being wrapped. This operator gets run with probability / proportion <code>p</code> (configuration parameter).</p>
</dd>
<dt><code>filtor_not</code></dt><dd><p>(<code><a href="#topic+Filtor">Filtor</a></code>)<br />
Alternative <code><a href="#topic+Filtor">Filtor</a></code> being wrapped. This operator gets run with probability / proportion <code>1 - p</code> (configuration parameter).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorMaybe-new"><code>FiltorMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorMaybe-prime"><code>FiltorMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorMaybe-clone"><code>FiltorMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>FiltorMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorMaybe$new(filtor, filtor_not = FiltorNull$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filtor</code></dt><dd><p>(<code><a href="#topic+Filtor">Filtor</a></code>)<br />
<code><a href="#topic+Filtor">Filtor</a></code> to wrap. This operator gets run with probability <code>p</code> (Configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$filtor&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>filtor_not</code></dt><dd><p>(<code><a href="#topic+Filtor">Filtor</a></code>)<br />
Another <code><a href="#topic+Filtor">Filtor</a></code> to wrap. This operator runs when <code>filtor</code> is not chosen. By
default, this is <code><a href="#topic+FiltorNull">FiltorNull</a></code>, i.e. no filtering. With this default, the
<code>FiltorMaybe</code> object applies the <code>filtor</code> operation with probability / proportion <code>p</code>, and
no operation at all otherwise.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$filtor_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FiltorMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>filtor</code> and <code>filtor_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-FiltorMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>
<p>Other filtor wrappers: 
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("mlr3")
library("mlr3learners")

fm = ftr("maybe", ftr("surprog", lrn("regr.lm"), filter.pool_factor = 2), p = 0.5)
p = ps(x = p_dbl(-5, 5))
known_data = data.frame(x = 1:5)
fitnesses = 1:5
new_data = data.frame(x = c(0.5, 1.5, 2.5, 3.5, 4.5))

fm$prime(p)

fm$needed_input(2)

fm$operate(new_data, known_data, fitnesses, 2)

fm$param_set$values$p = 0.33

fm$needed_input(3)

fm$operate(new_data, known_data, fitnesses, 3)

</code></pre>

<hr>
<h2 id='dict_filtors_null'>Null-Filtor</h2><span id='topic+dict_filtors_null'></span><span id='topic+FiltorNull'></span>

<h3>Description</h3>

<p>Null-filtor that does not perform filtering. Its <code>needed_input()</code> is always  the <code>output_size</code>, and <code>operate()</code> selects the first <code>n_filter</code> values from its input.
</p>
<p>Useful in particular with operator-wrappers such as <code><a href="#topic+FiltorProxy">FiltorProxy</a></code>, and to make filtering optional.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has no configuration parameters.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Filtor">Filtor</a></code> can be created with the short access form <code><a href="#topic+ftr">ftr()</a></code>
(<code><a href="#topic+ftrs">ftrs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_filtors">dict_filtors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
ftr("null")
ftrs("null")  # takes vector IDs, returns list of Filtors

# long form:
dict_filtors$get("null")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code>FiltorNull</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorNull-new"><code>FiltorNull$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorNull-clone"><code>FiltorNull$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorNull-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>FiltorNull</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorNull$new()</pre></div>


<hr>
<a id="method-FiltorNull-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorNull$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn = ftr("null")

p = ps(x = p_dbl(-5, 5))
known_data = data.frame(x = 1:5)
fitnesses = 1:5

new_data = data.frame(x = c(2.5, 4.5))

fn$prime(p)

fn$needed_input(1)

fn$operate(new_data, known_data, fitnesses, 1)

</code></pre>

<hr>
<h2 id='dict_filtors_proxy'>Proxy-Filtor that Filters According to its Configuration Parameter</h2><span id='topic+dict_filtors_proxy'></span><span id='topic+FiltorProxy'></span>

<h3>Description</h3>

<p>Filtor that performs the operation in its <code>operation</code> configuration parameter. This can be used to make filtor operations fully parametrizable.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>operation</code> :: <code><a href="#topic+Filtor">Filtor</a></code><br />
Operation to perform. Must be set by the user.
This is primed when <code style="white-space: pre;">&#8288;$prime()&#8288;</code> of <code>SelectorProxy</code> is called, and also when <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is called, to make changing
the operation as part of self-adaption possible. However, if the same operation gets used inside multiple <code>SelectorProxy</code>
objects, then it is recommended to <code style="white-space: pre;">&#8288;$clone(deep = TRUE)&#8288;</code> the object before assigning them to <code>operation</code> to avoid
frequent re-priming.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("proxy")
sels("proxy")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("proxy")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code>FiltorProxy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorProxy-new"><code>FiltorProxy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorProxy-prime"><code>FiltorProxy$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorProxy-clone"><code>FiltorProxy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorProxy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>FiltorProxy</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorProxy$new()</pre></div>


<hr>
<a id="method-FiltorProxy-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorProxy$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-FiltorProxy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorProxy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>
<p>Other filtor wrappers: 
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("mlr3")
library("mlr3learners")
fp = ftr("proxy")
p = ps(x = p_dbl(-5, 5))
known_data = data.frame(x = 1:5)
fitnesses = 1:5
new_data = data.frame(x = c(2.5, 4.5))

fp$param_set$values$operation = ftr("null")
fp$prime(p)
fp$operate(new_data, known_data, fitnesses, 1)

fp$param_set$values$operation = ftr("surprog", lrn("regr.lm"), filter.pool_factor = 2)
fp$operate(new_data, known_data, fitnesses, 1)
</code></pre>

<hr>
<h2 id='dict_filtors_surprog'>Progressive Surrogate Model Filtering</h2><span id='topic+dict_filtors_surprog'></span><span id='topic+FiltorSurrogateProgressive'></span>

<h3>Description</h3>

<p>Performs progressive surrogate model filtering. A surrogate model is used, as described in the parent class <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>.
The filtering is &quot;progressive&quot; in that successive values are filtered more agressively.
</p>


<h3>Algorithm</h3>

<p>Given the number <code>n_filter</code> of of individuals to sample, and the desired pool size at round <code>i</code> <code>pool_size(i)</code>, progressive
surrogate model filtering proceeds as follows:
</p>

<ol>
<li><p> Train the <code>surrogate_learner</code> <code><a href="mlr3.html#topic+LearnerRegr">LearnerRegr</a></code> on the <code>known_values</code> and their <code>fitnesses</code>.
</p>
</li>
<li><p> Take <code>pool_size(1)</code> configurations, predict their expected performance using the surrogate model, and put them
into a pool <code>P</code> of configurations to consider.
</p>
</li>
<li><p> Initialize <code>i</code> to 1.
</p>
</li>
<li><p> Take the individual that is optimal according to predicted performance, remove it from <code>P</code> and add it to solution set <code>S</code>.
</p>
</li>
<li><p> If the number of solutions in <code>S</code> equals <code>n_filter</code>, quit.
</p>
</li>
<li><p> If <code>pool_size(i + 1)</code> is larger than <code>pool_size(i)</code>, take the next <code>pool_size(i + 1) - pool_size(i)</code> configurations,
predict their expected performance using the surrogate model, and add them to <code>P</code>. Otherwise, remove <code>pool_size(i) - pool_size(i + 1)</code>
random individuals from the pool. The size of <code>P</code> ends up being <code>pool_size(i + 1) - i</code>, as <code>i</code> individuals have also been removed and
added to <code>S</code>.
</p>
</li>
<li><p> Increment <code>i</code>, jump to 4.
</p>
</li></ol>

<p>(The algorithm presented here is optimized for clarity; the actual implementation does all the surrogate model prediction in one go, but is functionally
equivalent).
</p>
<p><code>pool_size(i)</code> is calculated as <code>round(n_filter * pool_factor * (pool_factor_last / pool_factor) ^ (i / n_filter))</code>, i.e. a log-linear interpolation from
<code>pool_factor * n_filter</code> to <code>pool_factor_last * n_filter</code>.
</p>
<p>The <code>pool_factor</code> and <code>pool_factor_last</code> configuration parameters of this algorithm determine how agressively the surrogate model is used to
filter out sampled configurations. If the filtering is agressive (large values), then more &quot;exploitation&quot; at the cost of &quot;exploration&quot; is performed.
When <code>pool_factor</code> is small but <code>pool_factor_last</code> is large (or vice-versa), then different individuals are filtered with different agressiveness, potentially
leading to a tradeoff between &quot;exploration&quot; and &quot;exploitation&quot;.
</p>
<p>When <code>pool_factor_last</code> is set, it defaults to <code>pool_factor</code>, with no new individuals added and no individuals removed from the filter pool during filtering.
It is equivalent to taking the top <code>n_filter</code> individuals out of a sample of <code>n_filter * pool_factor</code>.
</p>


<h3>Configuration Parameters</h3>

<p><code>FiltorSurrogateProgressive</code>'s configuration parameters are the hyperparameters of the <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code> base class, as well as:
</p>

<ul>
<li> <p><code>filter.pool_factor</code> :: <code>numeric(1)</code><br />
<code>pool_factor</code> parameter of the progressive surrogate model filtering algorithm, see the corresponding section. Initialized to 1. Together with the
default of <code>filter.pool_factor_last</code>, this is equivalent to random sampling new individuals.
</p>
</li>
<li> <p><code>filter.pool_factor_last</code> :: <code>numeric(1)</code><br />
<code>pool_factor_last</code> parameter of the progressive surrogate model filtering algorithm, see the corresponding section.
When not given, it defaults to <code>filter.pool_factor</code>, equivalent to taking the top <code>n_filter</code> from <code>n_filter * pool_factor</code> individuals.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>See <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code> about supported operand types.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Filtor">Filtor</a></code> can be created with the short access form <code><a href="#topic+ftr">ftr()</a></code>
(<code><a href="#topic+ftrs">ftrs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_filtors">dict_filtors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
ftr("surprog", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])
ftrs("surprog", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])  # takes vector IDs, returns list of Filtors

# long form:
dict_filtors$get("surprog", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code><a href="#topic+FiltorSurrogate">miesmuschel::FiltorSurrogate</a></code> -&gt; <code>FiltorSurrogateProgressive</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorSurrogateProgressive-new"><code>FiltorSurrogateProgressive$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorSurrogateProgressive-clone"><code>FiltorSurrogateProgressive$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="FiltorSurrogate" data-id="prime"><a href='../../miesmuschel/html/FiltorSurrogate.html#method-FiltorSurrogate-prime'><code>miesmuschel::FiltorSurrogate$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorSurrogateProgressive-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>FiltorSurrogateProgressive</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogateProgressive$new(
  surrogate_learner,
  surrogate_selector = SelectorBest$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FiltorSurrogateProgressive-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogateProgressive$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("mlr3")
library("mlr3learners")
fp = ftr("surprog", lrn("regr.lm"), filter.pool_factor = 2)

p = ps(x = p_dbl(-5, 5))
known_data = data.frame(x = 1:5)
fitnesses = 1:5
new_data = data.frame(x = c(2.5, 4.5))

fp$prime(p)

fp$needed_input(1)

fp$operate(new_data, known_data, fitnesses, 1)

</code></pre>

<hr>
<h2 id='dict_filtors_surtour'>Tournament Surrogate Model Filtering</h2><span id='topic+dict_filtors_surtour'></span><span id='topic+FiltorSurrogateTournament'></span>

<h3>Description</h3>

<p>Performs tournament surrogate model filtering. A surrogate model is used, as described in the parent class <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>.
</p>


<h3>Algorithm</h3>

<p>Selects individuals from a tournament by taking the top <code>per_tournament</code> individuals, according to <code>surrogate_selector</code> and
as predicted by <code>surrogate_learner</code>, from a sample of <code>tournament_size(i)</code>, where <code>tournament_size(1)</code> is given by
<code>tournament_size</code>, <code>tournament_size(ceiling(n_filter / per_tournament))</code> is given by <code>tournament_size_last</code>, and
<code>tournament_size(i)</code> for <code>i</code> between these values is linearly interpolated on a log scale.
</p>


<h3>Configuration Parameters</h3>

<p><code>FiltorSurrogateProgressive</code>'s configuration parameters are the hyperparameters of the <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code> base class, as well as:
</p>

<ul>
<li> <p><code>filter.per_tournament</code> :: <code>integer(1)</code><br />
Number of individuals to select from each tournament. If <code>per_tournament</code> is not a divider of <code>n_filter</code>, then
the last tournament selects a random subset of <code>n_filter %% per_tournament</code> individuals out of the top <code>per_tournament</code> individuals.
Initialized to 1.
</p>
</li>
<li> <p><code>filter.tournament_size</code> :: <code>numeric(1)</code><br />
Tournament size used for filtering. If <code>tournament_size_last</code> is not given, all <code>n_filter</code> individuals are selected
in batches of <code>per_tournament</code> from tournaments of this size. If it is given, then the actual tournament size is interpolated
between <code>tournament_size</code> and <code>tournament_size_last</code> on a logarithmic scale.
Tournaments with tournament size below <code>per_tournament</code> select <code>per_tournament</code> individuals without tournament, i.e. no filtering.
Initialized to 1.
</p>
</li>
<li> <p><code>filter.tournament_size_last</code> :: <code>numeric(1)</code><br />
Tournament size used for the last tournament, see description of <code>tournament_size</code>. Defaults to <code>tournament_size</code> when not given,
i.e. all tournaments have the same size.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>See <code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code> about supported operand types.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Filtor">Filtor</a></code> can be created with the short access form <code><a href="#topic+ftr">ftr()</a></code>
(<code><a href="#topic+ftrs">ftrs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_filtors">dict_filtors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
ftr("surtour", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])
ftrs("surtour", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])  # takes vector IDs, returns list of Filtors

# long form:
dict_filtors$get("surtour", &lt;surrogate_learner&gt; [, &lt;surrogate_selector&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code><a href="#topic+FiltorSurrogate">miesmuschel::FiltorSurrogate</a></code> -&gt; <code>FiltorSurrogateTournament</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorSurrogateTournament-new"><code>FiltorSurrogateTournament$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorSurrogateTournament-clone"><code>FiltorSurrogateTournament$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="FiltorSurrogate" data-id="prime"><a href='../../miesmuschel/html/FiltorSurrogate.html#method-FiltorSurrogate-prime'><code>miesmuschel::FiltorSurrogate$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorSurrogateTournament-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>FiltorSurrogateTournament</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogateTournament$new(
  surrogate_learner,
  surrogate_selector = SelectorBest$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FiltorSurrogateTournament-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogateTournament$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("mlr3")
library("mlr3learners")
fp = ftr("surtour", lrn("regr.lm"), filter.tournament_size = 2)

p = ps(x = p_dbl(-5, 5))
known_data = data.frame(x = 1:5)
fitnesses = 1:5
new_data = data.frame(x = c(2.5, 4.5))

fp$prime(p)

fp$needed_input(1)

fp$operate(new_data, known_data, fitnesses, 1)

</code></pre>

<hr>
<h2 id='dict_mutators'>Dictionary of Mutators</h2><span id='topic+dict_mutators'></span>

<h3>Description</h3>

<p>Dictionary of Mutators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_mutators
</code></pre>


<h3>Format</h3>

<p>An object of class <code>DictionaryMutator</code> (inherits from <code>DictionaryEx</code>, <code>Dictionary</code>, <code>R6</code>) of length 15.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>, as well as:
</p>

<ul>
<li> <p><code>help(key, help_type)</code><br />
(<code>character(1)</code>, <code>character(1)</code>)<br />
Displays help for the dictionary entry <code>key</code>. <code>help_type</code> is one of
<code>"text"</code>, <code>"html"</code>, <code>"pdf"</code> and given as the <code>help_type</code> argument of R's <code>help()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_filtors">dict_filtors</a></code>,
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code>,
<code><a href="#topic+dict_scalors">dict_scalors</a></code>,
<code><a href="#topic+dict_selectors">dict_selectors</a></code>,
<code><a href="#topic+mut">mut</a>()</code>
</p>

<hr>
<h2 id='dict_mutators_cmpmaybe'>Mutator Choosing Action Component-Wise Independently</h2><span id='topic+dict_mutators_cmpmaybe'></span><span id='topic+MutatorCmpMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Mutator">Mutator</a></code> that chooses which operation to perform probabilistically. The <code><a href="#topic+Mutator">Mutator</a></code> wraps two other <code><a href="#topic+Mutator">Mutator</a></code>s given during construction,
and both of these operators are run. The ultimate result is sampled from the results of these operations independently for each
individuum and component: with probability <code>p</code> (configuration parameter), the result from the <code><a href="#topic+Mutator">Mutator</a></code> given to the <code>mutator</code>
construction argument is used, and with probability <code>p - 1</code> the one given to <code>mutator_not</code> is used.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Mutator">Mutator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>mutator</code> construction argument
are prefixed with <code>"cmpmaybe."</code>, the configuration parameters of the operator given to the <code>mutator_not</code> construction argument are prefixed with <code>"cmpmaybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p</code> :: <code>numeric(1)</code> <br />
Probability per component with which to apply the operator given to the <code>mutator</code> construction argument. Must be set by the user.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>mutator</code> and <code>mutator_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("cmpmaybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])
muts("cmpmaybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("cmpmaybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorCmpMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> being wrapped. This operator gets run with probability <code>p</code> (configuration parameter).</p>
</dd>
<dt><code>mutator_not</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Alternative <code><a href="#topic+Mutator">Mutator</a></code> being wrapped. This operator gets run with probability <code>1 - p</code> (configuration parameter).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorCmpMaybe-new"><code>MutatorCmpMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorCmpMaybe-prime"><code>MutatorCmpMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorCmpMaybe-clone"><code>MutatorCmpMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorCmpMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorCmpMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorCmpMaybe$new(mutator, mutator_not = MutatorNull$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> to wrap. Component-wise results of this operator are used with probability <code>p</code> (Configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$mutator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>mutator_not</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Another <code><a href="#topic+Mutator">Mutator</a></code> to wrap. Results from this operator are used when <code>mutator</code> is not chosen. By
default, this is <code><a href="#topic+MutatorNull">MutatorNull</a></code>, i.e. no operation.<br />
With this default, the
<code>MutatorCmpMaybe</code> object applies the <code>mutator</code> operation with probability <code>p</code>, and
no operation at all otherwise.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$mutator_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorCmpMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>mutator</code> and <code>mutator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorCmpMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-MutatorCmpMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorCmpMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>
<p>Other mutator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mcm = mut("cmpmaybe", mut("gauss", sdev = 5), p = 0.5)
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5), y = rep(0, 5))

mcm$prime(p)
mcm$operate(data)

mcm$param_set$values$p = 0.2
mcm$operate(data)

mcm2 = mut("cmpmaybe",
  mutator = mut("gauss", sdev = 0.01),
  mutator_not = mut("gauss", sdev = 10),
  p = 0.5
)

mcm2$prime(p)
mcm2$operate(data)
</code></pre>

<hr>
<h2 id='dict_mutators_erase'>Uniform Sample Mutator</h2><span id='topic+dict_mutators_erase'></span><span id='topic+MutatorErase'></span>

<h3>Description</h3>

<p>&quot;Mutates&quot; individuals by forgetting the current value and sampling new individuals from scratch.
</p>
<p>Since the information loss is very high, this should in most cases be combined with <code><a href="#topic+MutatorCmpMaybe">MutatorCmpMaybe</a></code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>initializer</code> :: <code>function</code><br />
Function that generates the initial population as a <code><a href="paradox.html#topic+Design">Design</a></code> object,
with arguments <code>param_set</code> and <code>n</code>, functioning like <code><a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a></code> or <code><a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a></code>.
This is equivalent to the <code>initializer</code> parameter of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>, see there for more information. Initialized to
<code><a href="paradox.html#topic+generate_design_random">generate_design_random()</a></code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("erase")
muts("erase")  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("erase")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorErase</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorErase-new"><code>MutatorErase$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorErase-clone"><code>MutatorErase$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorErase-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorErase</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorErase$new()</pre></div>


<hr>
<a id="method-MutatorErase-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorErase$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mer = mut("erase")
p = ps(x = p_lgl(), y = p_fct(c("a", "b", "c")), z = p_dbl(0, 1))
data = data.frame(x = rep(TRUE, 5), y = rep("a", 5),
  z = seq(0, 1, length.out = 5),
  stringsAsFactors = FALSE)  # necessary for R &lt;= 3.6

mer$prime(p)
mer$operate(data)

</code></pre>

<hr>
<h2 id='dict_mutators_gauss'>Gaussian Distribution Mutator</h2><span id='topic+dict_mutators_gauss'></span><span id='topic+MutatorGauss'></span>

<h3>Description</h3>

<p>Individuals are mutated with an independent normal random variable on each component.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>sdev</code> :: <code>numeric</code><br />
Standard deviation of normal distribuion. This is absolute if <code>sdev_is_relative</code> is <code>FALSE</code>, and
multiplied with each individual component's range (upper - lower) if <code>sdev_is_relative</code> is <code>TRUE</code>.
This may either be a scalar, in which case it is applied to all input components, or a vector,
in which case it must have the length of the input and applies to components in order in which
they appear in the priming <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. Must be set by the user.
</p>
</li>
<li> <p><code>sdev_is_relative</code> :: <code>logical(1)</code><br />
Whether <code>sdev</code> is absolute (<code>FALSE</code>) or relative to component range (<code>TRUE</code>). Initialized to <code>FALSE</code>.
</p>
</li>
<li> <p><code>truncated_normal</code> :: <code>logical(1)</code><br />
Whether to draw individuals from a normal distribution that is truncated at the bounds of each
component (<code>TRUE</code>), or to draw from a normal distribution and then restrict to bounds afterwards
(<code>FALSE</code>). The former (<code>TRUE</code>) will lead to very few to no samples landing on the exact bounds
(analytically it would be none almost surely, but this is subject to machine precision), the latter
(<code>FALSE</code>) can lead to a substantial number of samples landing on the exact bounds. Initialized to <code>FALSE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("gauss")
muts("gauss")  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("gauss")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code><a href="#topic+MutatorNumeric">miesmuschel::MutatorNumeric</a></code> -&gt; <code>MutatorGauss</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorGauss-new"><code>MutatorGauss$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorGauss-clone"><code>MutatorGauss$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorGauss-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorGauss</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorGauss$new()</pre></div>


<hr>
<a id="method-MutatorGauss-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorGauss$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mg = mut("gauss", sdev = 0.1)
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5), y = rep(0, 5))

mg$prime(p)
mg$operate(data)

mg$param_set$values$sdev = 100
mg$operate(data)
</code></pre>

<hr>
<h2 id='dict_mutators_maybe'>Mutator Choosing Action Probabilistically</h2><span id='topic+dict_mutators_maybe'></span><span id='topic+MutatorMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Mutator">Mutator</a></code> that chooses which operation to perform probabilistically. The <code><a href="#topic+Mutator">Mutator</a></code> wraps two other <code><a href="#topic+Mutator">Mutator</a></code>s given during construction,
and for each individuum, the operation to perform is sampled: with probability <code>p</code> (configuration parameter), the <code><a href="#topic+Mutator">Mutator</a></code> given to the <code>mutator</code>
construction argument is applied, and with probability <code>p - 1</code> the one given to <code>mutator_not</code> is applied.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Mutator">Mutator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>mutator</code> construction argument
are prefixed with <code>"maybe."</code>, the configuration parameters of the operator given to the <code>mutator_not</code> construction argument are prefixed with <code>"maybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p</code> :: <code>numeric(1)</code> <br />
Probability per individual with which to apply the operator given to the <code>mutator</code> construction argument. Must be set by the user.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>mutator</code> and <code>mutator_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("maybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])
muts("maybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("maybe", &lt;mutator&gt; [, &lt;mutator_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> being wrapped. This operator gets run with probability <code>p</code> (configuration parameter).</p>
</dd>
<dt><code>mutator_not</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Alternative <code><a href="#topic+Mutator">Mutator</a></code> being wrapped. This operator gets run with probability <code>1 - p</code> (configuration parameter).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorMaybe-new"><code>MutatorMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorMaybe-prime"><code>MutatorMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorMaybe-clone"><code>MutatorMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorMaybe$new(mutator, mutator_not = MutatorNull$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> to wrap. This operator gets run with probability <code>p</code> (configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.<br />
The <code style="white-space: pre;">&#8288;$mutator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>mutator_not</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Another <code><a href="#topic+Mutator">Mutator</a></code> to wrap. This operator runs when <code>mutator</code> is not chosen. By
default, this is <code><a href="#topic+MutatorNull">MutatorNull</a></code>, i.e. no operation. With this default, the
<code>MutatorMaybe</code> object applies the <code>mutator</code> operation with probability <code>p</code>, and
no operation at all otherwise.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$mutator_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>mutator</code> and <code>mutator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-MutatorMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>
<p>Other mutator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mm = mut("maybe", mut("gauss", sdev = 5), p = 0.5)
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5), y = rep(0, 5))

mm$prime(p)
mm$operate(data)

mm$param_set$values$p = 0.3
mm$operate(data)

mm2 = mut("maybe",
  mutator = mut("gauss", sdev = 0.01),
  mutator_not = mut("gauss", sdev = 10),
  p = 0.5
)

mm2$prime(p)
mm2$operate(data)
</code></pre>

<hr>
<h2 id='dict_mutators_null'>Null Mutator</h2><span id='topic+dict_mutators_null'></span><span id='topic+MutatorNull'></span>

<h3>Description</h3>

<p>Null-mutator that does not perform any operation on its input. Useful in particular with operator-wrappers such as <code><a href="#topic+MutatorMaybe">MutatorMaybe</a></code> or <code><a href="#topic+MutatorCombination">MutatorCombination</a></code>.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has no configuration parameters.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("null")
muts("null")  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("null")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorNull</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorNull-new"><code>MutatorNull$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorNull-clone"><code>MutatorNull$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorNull-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorNull</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorNull$new()</pre></div>


<hr>
<a id="method-MutatorNull-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorNull$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn = mut("null")
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5), z = p_lgl())
data = data.frame(x = rep(0, 5), y = rep(0, 5), z = rep(TRUE, 5))

mn$prime(p)
mn$operate(data)
</code></pre>

<hr>
<h2 id='dict_mutators_proxy'>Proxy-Mutator that Mutates According to its Configuration parameter</h2><span id='topic+dict_mutators_proxy'></span><span id='topic+MutatorProxy'></span>

<h3>Description</h3>

<p>Mutator that performs the operation in its <code>operation</code> configuration parameter. This is useful, e.g., to make
<code><a href="#topic+OptimizerMies">OptimizerMies</a></code>'s mutation operation fully parametrizable.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>operation</code> :: <code><a href="#topic+Mutator">Mutator</a></code><br />
Operation to perform. Must be set by the user.
This is primed when <code style="white-space: pre;">&#8288;$prime()&#8288;</code> of <code>MutatorProxy</code> is called, and also when <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is called, to make changing
the operation as part of self-adaption possible. However, if the same operation gets used inside multiple <code>MutatorProxy</code>
objects, then it is recommended to <code style="white-space: pre;">&#8288;$clone(deep = TRUE)&#8288;</code> the object before assigning them to <code>operation</code> to avoid
frequent re-priming.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("proxy")
muts("proxy")  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("proxy")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorProxy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorProxy-new"><code>MutatorProxy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorProxy-prime"><code>MutatorProxy$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorProxy-clone"><code>MutatorProxy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorProxy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorProxy</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorProxy$new()</pre></div>


<hr>
<a id="method-MutatorProxy-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorProxy$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-MutatorProxy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorProxy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>
<p>Other mutator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mp = mut("proxy", operation = mut("gauss", sdev = 0.1))
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5), y = rep(0, 5))

mp$prime(p)
mp$operate(data)

mp$param_set$values$operation = mut("null")
mp$operate(data)
</code></pre>

<hr>
<h2 id='dict_mutators_sequential'>Run Multiple Mutator Operations in Sequence</h2><span id='topic+dict_mutators_sequential'></span><span id='topic+MutatorSequential'></span>

<h3>Description</h3>

<p><code><a href="#topic+Mutator">Mutator</a></code> that wraps multiple other <code><a href="#topic+Mutator">Mutator</a></code>s given during construction and uses them for mutation in sequence.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Mutator">Mutator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>mutators</code> construction
argument are prefixed with <code>"mutator_1"</code>, <code>"mutator_2"</code>, ... up to <code>"mutator_#"</code>, where <code style="white-space: pre;">&#8288;#&#8288;</code> is <code>length(mutators)</code>.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of the <code><a href="#topic+Mutator">Mutator</a></code>s given in <code>mutators</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("sequential", &lt;mutators&gt;)
muts("sequential", &lt;mutators&gt;)  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("sequential", &lt;mutators&gt;)
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorSequential</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mutators</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code>s being wrapped. These operators get run sequentially in order.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorSequential-new"><code>MutatorSequential$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorSequential-prime"><code>MutatorSequential$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorSequential-clone"><code>MutatorSequential$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorSequential-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorSequential</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorSequential$new(mutators)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mutators</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code>s to wrap. The operations are run in order given to <code>mutators</code>.
The constructed object gets a <em>clone</em> of this argument. The <code style="white-space: pre;">&#8288;$mutators&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorSequential-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>mutator</code> and <code>mutator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorSequential$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-MutatorSequential-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorSequential$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>
<p>Other mutator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# dataset:
#  - x1 is mutated around +- 10
#  - x2 influences sdev of mutation of x1
ds = data.frame(x1 = 0, x2 = c(.01, 0.1, 1))
p = ps(x1 = p_dbl(-10, 10), x2 = p_dbl(0, 10))

# operator that only mutates x1, with sdev given by x2
gauss_x1 = mut("combine",
  operators = list(
    x1 = mut("gauss", sdev_is_relative = FALSE),
    x2 = mut("null")
  ),
  adaptions = list(x1.sdev = function(x) x$x2)
)

gauss_x1$prime(p)
gauss_x1$operate(ds)  # see how x1[1] changes little, x1[3] changes a lot

# operator that mutates x1  with sdev given by x2, as well as x2. However,
# the value that x2 takes after mutation does not influence the value that
# the mutator of x1 "sees" -- although x2 is mutated to extreme values,
# mutation of x1 happens as in `gauss_x1`.
gauss_x1_x2 = mut("combine",
  operators = list(
    x1 = mut("gauss", sdev_is_relative = FALSE),
    x2 = mut("gauss", sdev = 100)
  ),
  adaptions = list(x1.sdev = function(x) x$x2)
)

gauss_x1_x2$prime(p)
gauss_x1_x2$operate(ds)  # see how x1 changes in similar ways to above

# operator that mutates sequentially: first x2, and then x1 with sdev given
# by x2. The value that x2 takes after mutation *does* influence the value
# that the mutator of x1 "sees": x1 is mutated either to a large degree,
# or not at all.

gauss_x2_then_x1 = mut("sequential", list(
    mut("combine",
      operators = list(
        x1 = mut("null"),
        x2 = mut("gauss", sdev = 100)
      )
    ),
    mut("combine",
      operators = list(
        x1 = mut("gauss", sdev_is_relative = FALSE),
        x2 = mut("null")
      ),
      adaptions = list(x1.sdev = function(x) x$x2)
    )
))

gauss_x2_then_x1$prime(p)
gauss_x2_then_x1$operate(ds)
</code></pre>

<hr>
<h2 id='dict_mutators_unif'>Uniform Discrete Mutator</h2><span id='topic+dict_mutators_unif'></span><span id='topic+MutatorDiscreteUniform'></span>

<h3>Description</h3>

<p>Discrete components are mutated by sampling from a uniform distribution, either from all possible
values of each component, or from all values except the original value.
</p>
<p>Since the information loss is very high, this should in most cases be combined with <code><a href="#topic+MutatorCmpMaybe">MutatorCmpMaybe</a></code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>can_mutate_to_same</code> :: <code>logical(1)</code><br />
Whether to sample from entire range of each parameter (<code>TRUE</code>) or from all values except the
current value (<code>FALSE</code>). Initialized to <code>TRUE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("unif")
muts("unif")  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("unif")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code><a href="#topic+MutatorDiscrete">miesmuschel::MutatorDiscrete</a></code> -&gt; <code>MutatorDiscreteUniform</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorDiscreteUniform-new"><code>MutatorDiscreteUniform$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorDiscreteUniform-clone"><code>MutatorDiscreteUniform$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorDiscreteUniform-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorDiscreteUniform</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorDiscreteUniform$new()</pre></div>


<hr>
<a id="method-MutatorDiscreteUniform-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorDiscreteUniform$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
mdu = mut("unif")
p = ps(x = p_lgl(), y = p_fct(c("a", "b", "c")))
data = data.frame(x = rep(TRUE, 5), y = rep("a", 5),
  stringsAsFactors = FALSE)  # necessary for R &lt;= 3.6

mdu$prime(p)
mdu$operate(data)

mdu$param_set$values$can_mutate_to_same = FALSE
mdu$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators'>Dictionary of Recombinators</h2><span id='topic+dict_recombinators'></span>

<h3>Description</h3>

<p>Dictionary of Recombinators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_recombinators
</code></pre>


<h3>Format</h3>

<p>An object of class <code>DictionaryRecombinator</code> (inherits from <code>DictionaryEx</code>, <code>Dictionary</code>, <code>R6</code>) of length 15.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>, as well as:
</p>

<ul>
<li> <p><code>help(key, help_type)</code><br />
(<code>character(1)</code>, <code>character(1)</code>)<br />
Displays help for the dictionary entry <code>key</code>. <code>help_type</code> is one of
<code>"text"</code>, <code>"html"</code>, <code>"pdf"</code> and given as the <code>help_type</code> argument of R's <code>help()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_filtors">dict_filtors</a></code>,
<code><a href="#topic+dict_mutators">dict_mutators</a></code>,
<code><a href="#topic+dict_scalors">dict_scalors</a></code>,
<code><a href="#topic+dict_selectors">dict_selectors</a></code>,
<code><a href="#topic+mut">mut</a>()</code>
</p>

<hr>
<h2 id='dict_recombinators_cmpmaybe'>Recombinator Choosing Action Component-Wise Independently</h2><span id='topic+dict_recombinators_cmpmaybe'></span><span id='topic+RecombinatorCmpMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Recombinator">Recombinator</a></code> that chooses which operation to perform probabilistically and independently for each component.
The <code><a href="#topic+Recombinator">Recombinator</a></code> wraps two other <code><a href="#topic+Recombinator">Recombinator</a></code>s given during construction,
and both of these operators are run. The ultimate result is sampled from the results of these operations independently for each individuum
and component: with probability <code>p</code> (configuration parameter), the result from the <code><a href="#topic+Recombinator">Recombinator</a></code> given to
the <code>recombinator</code> construction argument is used, and with probability <code>p - 1</code> the one given to <code>recombinator_not</code> is used.
</p>
<p>The values of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> is set to the corresponding values of the wrapped <code><a href="#topic+Recombinator">Recombinator</a></code>s. Both <code>recombinator</code> and <code>recombinator_not</code>
must currently have the same respective <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> values.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Recombinator">Recombinator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>recombinator</code> construction argument
are prefixed with <code>"cmpmaybe."</code>, the configuration parameters of the operator given to the <code>recombinator_not</code> construction argument are prefixed with <code>"cmpmaybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p</code> :: <code>numeric(1)</code> <br />
Probability per component with which to use the result of applying the operator given to the <code>recombinator</code> construction argument. Must be set by the user.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>recombinator</code> and <code>recombinator_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("cmpmaybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])
recs("cmpmaybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("cmpmaybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorCmpMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> being wrapped. This operator gets run with probability <code>p</code> (configuration parameter).</p>
</dd>
<dt><code>recombinator_not</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Alternative <code><a href="#topic+Recombinator">Recombinator</a></code> being wrapped. This operator gets run with probability <code>1 - p</code> (configuration parameter).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorCmpMaybe-new"><code>RecombinatorCmpMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorCmpMaybe-prime"><code>RecombinatorCmpMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorCmpMaybe-clone"><code>RecombinatorCmpMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorCmpMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorCmpMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCmpMaybe$new(recombinator, recombinator_not = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> to wrap. Component-wise results of this operator are used with probability <code>p</code> (Configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$recombinator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>recombinator_not</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Another <code><a href="#topic+Recombinator">Recombinator</a></code> to wrap. Results from this operator are used when <code>recombinator</code> is not chosen. By
default, this is <code><a href="#topic+RecombinatorNull">RecombinatorNull</a></code>, i.e. no operation, with both <code>n_indivs_in</code> and <code>n_indivs_out</code> set
to match <code>recombinator</code>. This does not work when <code>recombinator</code> has <code>n_indivs_in &lt; n_indivs_out</code>, in which
case this argument must be set explicitly.<br />
With this default, the <code>RecombinatorCmpMaybe</code> object applies the <code>recombinator</code> operation with probability <code>p</code>, and
no operation at all otherwise.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$recombinator_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorCmpMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>recombinator</code> and <code>recombinator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCmpMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-RecombinatorCmpMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCmpMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>
<p>Other recombinator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rm = rec("cmpmaybe", rec("swap"), p = 0.5)
p = ps(x = p_int(1, 8), y = p_dbl(1, 8), z = p_lgl())
data = data.frame(x = 1:8, y = 1:8, z = rep(TRUE, 4))

rm$prime(p)
rm$operate(data)

rm$param_set$values$p = 0.3
rm$operate(data)

# equivalent to rec("cmpmaybe", rec("swap", keep_complement = FALSE), p = 0.7)
rm2 = rec("cmpmaybe",
  recombinator = rec("null", 2, 1),
  recombinator_not = rec("swap", keep_complement = FALSE),
  p = 0.3
)

rm2$prime(p)
rm2$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators_convex'>Convex Combination Recombinator</h2><span id='topic+dict_recombinators_convex'></span><span id='topic+RecombinatorConvex'></span>

<h3>Description</h3>

<p>Numeric Values between various individuals are recombined via component-wise convex combination (or weighted mean). The number of individuals
over which the convex combination is taken must be determined during construction as <code>n_indivs_in</code>.
</p>
<p>The number of output individuals is always 1, i.e. <code>n_indivs_in</code> are used to create one output value. When using this
recombinator in a typical EA setting, e.g. with <code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a></code>, it is therefore recommended to use a parent-selector
where the expected quality of selected parents does not depend on the number of parents selected when <code>n_indivs_in</code> is large:
<code><a href="#topic+SelectorTournament">sel(&quot;tournament&quot;)</a></code> is preferred to <code><a href="#topic+SelectorBest">sel(&quot;best&quot;)</a></code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>lambda</code> :: <code>numeric</code> | <code>matrix</code><br />
Combination weights; these are normalized to sum to 1 internally.
Must either be a vector of length <code>n_indivs_in</code>, or a matrix with <code>n_indivs_in</code> rows and as many columns as there
are components in the values being operated on. Must be non-negative, at least one value per column must be greater than zero, but it is not
necessary that they sum to 1.<br />
Initialized to <code>rep(1, n_indivs_in)</code>, i.e. equal weights to all individuals being operated on.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("convex")
recs("convex")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("convex")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorConvex</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorConvex-new"><code>RecombinatorConvex$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorConvex-clone"><code>RecombinatorConvex$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorConvex-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorConvex</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvex$new(n_indivs_in = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.
Default 2.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorConvex-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvex$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rcvx = rec("convex", n_indivs_in = 3)
p = ps(x = p_dbl(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rcvx$prime(p)
rcvx$operate(data)  # mean of groups of 3

rcvx = rec("convex", 3, lambda = c(0, 1, 2))$prime(p)
rcvx$operate(data)  # for groups of 3, take 1/3 of 2nd and 2/3 of 3rd row

lambda = matrix(c(0, 1, 2, 1, 1, 1, 1, 0, 0), ncol = 3)
lambda

rcvx = rec("convex", 3, lambda = lambda)$prime(p)
rcvx$operate(data)  # componentwise different operation

</code></pre>

<hr>
<h2 id='dict_recombinators_cvxpair'>Convex Combination Recombinator for Pairs</h2><span id='topic+dict_recombinators_cvxpair'></span><span id='topic+RecombinatorConvexPair'></span>

<h3>Description</h3>

<p>Numeric Values between various individuals are recombined via component-wise convex combination (or weighted mean). Exactly two
individuals are being recombined, and the <code>lambda</code> configuration parameter determines the relative weight of the first
individual in each pair for the first result, and the relative weight of the second indivudual for the complement, if
initialized with <code>keep_complement</code> set to <code>TRUE</code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>lambda</code> :: <code>numeric</code><br />
Combination weight. If <code>keep_complement</code> is <code>TRUE</code>, then two individuals are returned for each pair of input individuals:
one corresponding to <code style="white-space: pre;">&#8288;lambda * &lt;1st individual&gt; + (1-lambda) * &lt;2nd individual&gt;&#8288;</code>, and one corresponding to
<code style="white-space: pre;">&#8288;(1-lambda) * &lt;1st individual&gt; + lambda * &lt;2nd individual&gt;&#8288;</code> (i.e. the complement). Otherwise, only the first of these two
is generated.
Must either be a scalar, or a vector with length equal to the number of
components in the values being operated on. Must be between 0 and 1.<br />
Initialized to 0.5.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("convex")
recs("convex")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("convex")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code><a href="#topic+RecombinatorPair">miesmuschel::RecombinatorPair</a></code> -&gt; <code>RecombinatorConvexPair</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorConvexPair-new"><code>RecombinatorConvexPair$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorConvexPair-clone"><code>RecombinatorConvexPair$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorConvexPair-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorConvexPair</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvexPair$new(keep_complement = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">&#8288;$keep_complement&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorConvexPair-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorConvexPair$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rcvx = rec("cvxpair")
p = ps(x = p_dbl(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rcvx$prime(p)
rcvx$operate(data)  # mean of groups of 2
# with the default value of lambda = 0.5, the default of
# keep_complement = TRUE means that pairs of equal values are generated;
# consider setting keep_complement = FALSE int that case.

rcvx$param_set$values$lambda = 0.1
rcvx$operate(data)

</code></pre>

<hr>
<h2 id='dict_recombinators_maybe'>Recombinator Choosing Action Probabilistically</h2><span id='topic+dict_recombinators_maybe'></span><span id='topic+RecombinatorMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Recombinator">Recombinator</a></code> that chooses which operation to perform probabilistically. The <code><a href="#topic+Recombinator">Recombinator</a></code> wraps two other <code><a href="#topic+Recombinator">Recombinator</a></code>s given during construction,
and for each group of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> individuals, the operation to perform is sampled: with probability <code>p</code> (configuration parameter), the <code><a href="#topic+Recombinator">Recombinator</a></code> given to
the <code>recombinator</code> construction argument is applied, and with probability <code>p - 1</code> the one given to <code>recombinator_not</code> is applied.
</p>
<p>The values of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> is set to the corresponding values of the wrapped <code><a href="#topic+Recombinator">Recombinator</a></code>s. Both <code>recombinator</code> and <code>recombinator_not</code>
must currently have the same respective <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> values.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Recombinator">Recombinator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>recombinator</code> construction argument
are prefixed with <code>"maybe."</code>, the configuration parameters of the operator given to the <code>recombinator_not</code> construction argument are prefixed with <code>"maybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p</code> :: <code>numeric(1)</code> <br />
Probability per group of <code>n_indivs_in</code> individuals with which to apply the operator given to the <code>recombinator</code> construction argument. Must be set by the user.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>recombinator</code> and <code>recombinator_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("maybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])
recs("maybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("maybe", &lt;recombinator&gt; [, &lt;recombinator_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> being wrapped. This operator gets run with probability <code>p</code> (configuration parameter).</p>
</dd>
<dt><code>recombinator_not</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Alternative <code><a href="#topic+Recombinator">Recombinator</a></code> being wrapped. This operator gets run with probability <code>1 - p</code> (configuration parameter).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorMaybe-new"><code>RecombinatorMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorMaybe-prime"><code>RecombinatorMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorMaybe-clone"><code>RecombinatorMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorMaybe$new(recombinator, recombinator_not = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> to wrap. This operator gets run with probability <code>p</code> (Configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$recombinator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>recombinator_not</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Another <code><a href="#topic+Recombinator">Recombinator</a></code> to wrap. This operator runs when <code>recombinator</code> is not chosen. By
default, this is <code><a href="#topic+RecombinatorNull">RecombinatorNull</a></code>, i.e. no operation, with both <code>n_indivs_in</code> and <code>n_indivs_out</code> set
to match <code>recombinator</code>. This does not work when <code>recombinator</code> has <code>n_indivs_in &lt; n_indivs_out</code>, in which
case this argument must be set explicitly.<br />
With this default, the <code>RecombinatorMaybe</code> object applies the <code>recombinator</code> operation with probability <code>p</code>, and
no operation at all otherwise.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$recombinator_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>recombinator</code> and <code>recombinator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-RecombinatorMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>
<p>Other recombinator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rm = rec("maybe", rec("xounif", p = 1), p = 0.5)
p = ps(x = p_int(1, 8), y = p_dbl(1, 8), z = p_lgl())
data = data.frame(x = 1:8, y = 1:8, z = rep(TRUE, 4))

rm$prime(p)
rm$operate(data)

rm$param_set$values$p = 0.3
rm$operate(data)

rm2 = rec("maybe",
  recombinator = rec("xounif", p = 1),
  recombinator_not = rec("xounif", p = 0.5),
  p = 0.5
)

rm2$prime(p)
rm2$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators_null'>Null-Recombinator</h2><span id='topic+dict_recombinators_null'></span><span id='topic+RecombinatorNull'></span>

<h3>Description</h3>

<p>Null-recombinator that does not perform any operation on its input. Useful in particular with operator-wrappers such as <code><a href="#topic+RecombinatorMaybe">RecombinatorMaybe</a></code> or
<code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code>.
</p>
<p><code>n_indivs_in</code> and <code>n_indivs_out</code> can be set during construction, where <code>n_indivs_out</code> must be less or equal <code>n_indivs_in</code>. If it is strictly less,
then the operation returns only the first <code>n_indivs_out</code> individuals out of each <code>n_indivs_in</code> sized group.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has no configuration parameters.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("null")
recs("null")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("null")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorNull</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorNull-new"><code>RecombinatorNull$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorNull-clone"><code>RecombinatorNull$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorNull-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Recombinator</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorNull$new(n_indivs_in = 1, n_indivs_out = n_indivs_in)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.
Setting this number to a number unequal 1 is mostly useful when incorporating this operator in wrappers such as <code><a href="#topic+RecombinatorMaybe">RecombinatorMaybe</a></code> or
<code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code>.
Default 1.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>n_indivs_out</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals that result for each <code>n_indivs_in</code> lines of input. Must be at most <code>n_indivs_in</code>. If this is less than <code>n_indivs_in</code>,
then only the first <code>n_indivs_out</code> individuals out of each <code>n_indivs_in</code> sized group are returned by an operation.
Setting this number to a number unequal 1 is mostly useful when incorporating this operator in wrappers such as <code><a href="#topic+RecombinatorMaybe">RecombinatorMaybe</a></code> or
<code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code>.
Default equal to <code>n_indivs_in</code>.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorNull-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorNull$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rn = rec("null")
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5), z = p_lgl())
data = data.frame(x = 1:4, y = 0:3, z = rep(TRUE, 4))

rn$prime(p)
rn$operate(data)

rn_half = rec("null", n_indivs_in = 2, n_indivs_out = 1)
rn_half$prime(p)
rn_half$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators_proxy'>Proxy-Recombinator that Recombines According to its Configuration parameter</h2><span id='topic+dict_recombinators_proxy'></span><span id='topic+RecombinatorProxy'></span>

<h3>Description</h3>

<p>Recombinator that performs the operation in its <code>operation</code> configuration parameter. This is useful, e.g., to make
<code><a href="#topic+OptimizerMies">OptimizerMies</a></code>'s recombination operation fully parametrizable.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>operation</code> :: <code><a href="#topic+Recombinator">Recombinator</a></code><br />
Operation to perform. Must be set by the user.
This is primed when <code style="white-space: pre;">&#8288;$prime()&#8288;</code> of <code>RecombinatorProxy</code> is called, and also when <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is called, to make changing
the operation as part of self-adaption possible. However, if the same operation gets used inside multiple <code>RecombinatorProxy</code>
objects, then it is recommended to <code style="white-space: pre;">&#8288;$clone(deep = TRUE)&#8288;</code> the object before assigning them to <code>operation</code> to avoid
frequent re-priming.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("proxy")
recs("proxy")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("proxy")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorProxy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorProxy-new"><code>RecombinatorProxy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorProxy-prime"><code>RecombinatorProxy$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorProxy-clone"><code>RecombinatorProxy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorProxy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorProxy</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorProxy$new(n_indivs_in = 2, n_indivs_out = n_indivs_in)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.
Furthermore, the <code><a href="#topic+Recombinator">Recombinator</a></code> assigned to the <code>operation</code> configuration parameter must have an <code>n_indivs_in</code> that is a divisor of this number.
Default 2.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>n_indivs_out</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals that result for each <code>n_indivs_in</code> lines of input. Must be at most <code>n_indivs_in</code>.
The ratio of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> to <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> of the <code><a href="#topic+Recombinator">Recombinator</a></code> assigned to the <code>operation</code> configuration parameter must be the same as
<code>n_indivs_in</code> to <code>n_indivs_out</code> of this object.
Default equal to <code>n_indivs_in</code>.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorProxy-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorProxy$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-RecombinatorProxy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorProxy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>
<p>Other recombinator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rp = rec("proxy", operation = rec("xounif"))
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5), z = p_lgl())
data = data.frame(x = 1:4, y = 0:3, z = rep(TRUE, 4))

rp$prime(p)
rp$operate(data)  # default operation: null

rp$param_set$values$operation = rec("xounif", p = 0.5)
rp$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators_sbx'>Simulated Binary Crossover Recombinator</h2><span id='topic+dict_recombinators_sbx'></span><span id='topic+RecombinatorSimulatedBinaryCrossover'></span>

<h3>Description</h3>

<p>Numeric Values between two individuals are recombined via component-wise independent simulated
binary crossover. See Deb (1995) for more details.
</p>
<p>This operator is applied to all components; It is common to apply the operator to only some randomly
chosen components, in which case the <code><a href="#topic+RecombinatorCmpMaybe">rec(&quot;cmpmaybe&quot;)</a></code> operator should
be used; see examples.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>n</code> :: <code>numeric</code><br />
Non-negative distribution index of the polynomial distribution for each component.
Generally spoken, the higher <code>n</code>, the higher the probability of creating near parent values.
This may either be a scalar in which case it is applied to all input components, or a vector,
in which case it must have the length of the input components and applies to components in
order in which they appear in the priming <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. Initialized to 1.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("sbx")
recs("sbx")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("sbx")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code><a href="#topic+RecombinatorPair">miesmuschel::RecombinatorPair</a></code> -&gt; <code>RecombinatorSimulatedBinaryCrossover</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorSimulatedBinaryCrossover-new"><code>RecombinatorSimulatedBinaryCrossover$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorSimulatedBinaryCrossover-clone"><code>RecombinatorSimulatedBinaryCrossover$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorSimulatedBinaryCrossover-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorSimulatedBinaryCrossover</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSimulatedBinaryCrossover$new(keep_complement = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">&#8288;$keep_complement&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorSimulatedBinaryCrossover-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSimulatedBinaryCrossover$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Deb, Kalyanmoy, Agrawal, Bhushan R, others (1995).
&ldquo;Simulated binary crossover for continuous search space.&rdquo;
<em>Complex systems</em>, <b>9</b>(2), 115&ndash;148.
</p>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rsbx = rec("cmpmaybe", rec("sbx"), p = 0.5)
p = ps(x = p_dbl(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rsbx$prime(p)
rsbx$operate(data)

rsbx = rec("sbx", n = c(0.5, 1, 10))
rsbx$prime(p)
rsbx$operate(data)
</code></pre>

<hr>
<h2 id='dict_recombinators_sequential'>Run Multiple Recombinator Operations in Sequence</h2><span id='topic+dict_recombinators_sequential'></span><span id='topic+RecombinatorSequential'></span>

<h3>Description</h3>

<p><code><a href="#topic+Recombinator">Recombinator</a></code> that wraps multiple other <code><a href="#topic+Recombinator">Recombinator</a></code>s given during construction and uses them for mutation in sequence.
</p>
<p>When subsequent <code><a href="#topic+Recombinator">Recombinator</a></code>s have mismatching <code>n_indivs_out</code> / <code>n_indivs_in</code>, then <code>RecombinatorSequential</code> tries to
match them by running them multiple times. If e.g. <code>recombinators[[1]]$n_indivs_out</code> is 2 and <code>recombinators[[2]]$n_indivs_in</code> is 1, then
<code>recombinators[[2]]</code> is run twice, once for each output of <code>recombinators[[1]]</code>.
</p>
<p>When the <code>allow_lcm_packing</code> argument is <code>FALSE</code>, then an error is given if neither <code>n_indivs_out</code> of a <code><a href="#topic+Recombinator">Recombinator</a></code> divides <code>n_indivs_in</code> of the
following <code><a href="#topic+Recombinator">Recombinator</a></code>, nor <code>n_indivs_in</code> of the latter divides <code>n_indivs_out</code> of the former even when considering that the former is run multiple times.
If <code>allow_lcm_packing</code> is <code>TRUE</code>, then both recombinators are run multiple times, according to the lowest common multiple (&quot;lcm&quot;)
of the two.
</p>
<p>However, <code>allow_lcm_packing</code> can lead to very large values of <code>n_indivs_in</code> / <code>n_indivs_out</code>, so it may instead be preferred to add <code><a href="#topic+RecombinatorNull">RecombinatorNull</a></code> objects
with fitting <code>n_indivs_in</code> / <code>n_indivs_out</code> values to match subsequent recombinators.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Recombinator">Recombinator</a></code>s that it wraps: The configuration parameters of the operator given to the <code>recombinators</code> construction
argument are prefixed with <code>"recombinator_1"</code>, <code>"recombinator_2"</code>, ... up to <code>"recombinator_#"</code>, where <code style="white-space: pre;">&#8288;#&#8288;</code> is <code>length(recombinators)</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>shuffle_between</code> :: <code>logical(1)</code> <br />
Whether to reorder <code>values</code> between invocations of recombinators. Initialized to <code>TRUE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of the <code><a href="#topic+Recombinator">Recombinator</a></code>s given in <code>recombinators</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("sequential", &lt;recombinators&gt;)
recs("sequential", &lt;recombinators&gt;)  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("sequential", &lt;recombinators&gt;)
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorSequential</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>recombinators</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code>s being wrapped. These operators get run sequentially in order.</p>
</dd>
<dt><code>allow_lcm_packing</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to allow lowest common multiple packing.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorSequential-new"><code>RecombinatorSequential$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorSequential-prime"><code>RecombinatorSequential$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorSequential-clone"><code>RecombinatorSequential$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorSequential-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorSequential</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSequential$new(recombinators, allow_lcm_packing = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recombinators</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code>s to wrap. The operations are run in order given to <code>recombinators</code>.
The constructed object gets a <em>clone</em> of this argument. The <code style="white-space: pre;">&#8288;$recombinators&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>allow_lcm_packing</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to allow lowest common multiple packing. Default <code>FALSE</code>.
The <code style="white-space: pre;">&#8288;$allow_lcm_packing&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorSequential-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>recombinator</code> and <code>recombinator_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSequential$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-RecombinatorSequential-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSequential$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>
<p>Other recombinator wrappers: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

ds = data.frame(a = c(0, 1), b = c(0, 1))
p = ps(a = p_dbl(0, 1), b = p_dbl(0, 1))


convex = rec("cvxpair", lambda = 0.7)
swap = rec("swap")

convex_then_swap = rec("sequential", list(convex, swap))

ds

convex$prime(p)$operate(ds)

swap$prime(p)$operate(ds)

convex_then_swap$prime(p)$operate(ds)
</code></pre>

<hr>
<h2 id='dict_recombinators_swap'>Swap Recombinator</h2><span id='topic+dict_recombinators_swap'></span><span id='topic+RecombinatorSwap'></span>

<h3>Description</h3>

<p>Values between two individuals are exchanged. This is relatively useless as an operator by itself, but is used
in combination with <code><a href="#topic+RecombinatorCmpMaybe">RecombinatorCmpMaybe</a></code> to get a recombinator that is crossing over individuals
uniformly at random. Because this is such a frequently-used operation, the <code><a href="#topic+RecombinatorCrossoverUniform">RecombinatorCrossoverUniform</a></code> pseudo-class
exists as a shortcut.
</p>


<h3>Configuration Parameters</h3>

<p>None.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("swap")
recs("swap")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("swap")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code><a href="#topic+RecombinatorPair">miesmuschel::RecombinatorPair</a></code> -&gt; <code>RecombinatorSwap</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorSwap-new"><code>RecombinatorSwap$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorSwap-clone"><code>RecombinatorSwap$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorSwap-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorCrossoverSwap</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSwap$new(keep_complement = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">&#8288;$keep_complement&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorSwap-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorSwap$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rs = rec("swap")
p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rs$prime(p)
rs$operate(data)

rx = rec("cmpmaybe", rec("swap"), p = 0.5)  # the same as 'rec("xounif")'
rx$prime(p)
rx$operate(data)

</code></pre>

<hr>
<h2 id='dict_recombinators_xonary'>N-ary Crossover Recombinator</h2><span id='topic+dict_recombinators_xonary'></span><span id='topic+RecombinatorCrossoverNary'></span>

<h3>Description</h3>

<p>Values are chosen componentwise independently at random from multiple individuals.
The number of individuals must be determined during construction as <code>n_indivs_in</code>.
</p>
<p>The number of output individuals is always 1, i.e. <code>n_indivs_in</code> are used to create one output value. When using this
recombinator in a typical EA setting, e.g. with <code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a></code>, it is therefore recommended to use a parent-selector
where the expected quality of selected parents does not depend on the number of parents selected when <code>n_indivs_in</code> is large:
<code><a href="#topic+SelectorTournament">sel(&quot;tournament&quot;)</a></code> is preferred to <code><a href="#topic+SelectorBest">sel(&quot;best&quot;)</a></code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>p</code> :: <code>numeric</code> | <code>matrix</code><br />
Sampling weights these are normalized to sum to 1 internally. Must either be a vector of length <code>n_indivs_in</code>, or a matrix with
<code>n_indivs_in</code> rows and as many columns as there
are components in the values being operated on. Must be non-negative, at least one value per column must be greater than zero, but it is not
necessary that they sum to 1.<br />
Initialized to <code>rep(1, n_indivs_in)</code>, i.e. uniform sampling from all individuals being operated on.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("convex")
recs("convex")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("convex")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorCrossoverNary</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorCrossoverNary-new"><code>RecombinatorCrossoverNary$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorCrossoverNary-clone"><code>RecombinatorCrossoverNary$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorCrossoverNary-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorConvex</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCrossoverNary$new(n_indivs_in = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.
Default 2.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorCrossoverNary-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCrossoverNary$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rxon = rec("xonary", n_indivs_in = 3)
p = ps(x = p_dbl(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rxon$prime(p)
rxon$operate(data)  # uniform sampling from groups of 3

rxon = rec("xonary", 3, p = c(0, 1, 2))$prime(p)
# for groups of 3, take with probability 1/3 from 2nd and with probability 2/3 from 3rd row
rxon$operate(data)

pmat = matrix(c(0, 1, 2, 1, 1, 1, 1, 0, 0), ncol = 3)
pmat

rxon = rec("xonary", 3, p = pmat)$prime(p)
rxon$operate(data)  # componentwise different operation

</code></pre>

<hr>
<h2 id='dict_recombinators_xounif'>Crossover Recombinator</h2><span id='topic+dict_recombinators_xounif'></span><span id='topic+RecombinatorCrossoverUniform'></span>

<h3>Description</h3>

<p>Values between two individuals are exchanged with component-wise independent probability.
</p>
<p>This is a pseudo-class: It does not create a single R6-object of a class;
instead, it creates the object <code>rec("cmpmaybe", rec("swap"), p = 0.5)</code>,
making use of the <code><a href="#topic+RecombinatorCmpMaybe">RecombinatorCmpMaybe</a></code> and <code><a href="#topic+RecombinatorSwap">RecombinatorSwap</a></code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RecombinatorCrossoverUniform(keep_complement = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dict_recombinators_xounif_+3A_keep_complement">keep_complement</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">&#8288;$keep_complement&#8288;</code> field will reflect this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+Recombinator">Recombinator</a></code>: <code>rec("cmpmaybe", rec("swap"))</code>.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("xounif")
recs("xounif")  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("xounif")
</pre></div>


<h3>See Also</h3>

<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
rx = rec("xounif")

print(rx)

p = ps(x = p_int(-5, 5), y = p_dbl(-5, 5), z = p_dbl(-5, 5))
data = data.frame(x = 0:5, y = 0:5, z = 0:5)

rx$prime(p)
rx$operate(data)

rx$param_set$values$p = 0.3
rx$operate(data)
</code></pre>

<hr>
<h2 id='dict_scalors'>Dictionary of Scalors</h2><span id='topic+dict_scalors'></span>

<h3>Description</h3>

<p>Dictionary of Scalors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_scalors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>DictionaryScalor</code> (inherits from <code>DictionaryEx</code>, <code>Dictionary</code>, <code>R6</code>) of length 15.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>, as well as:
</p>

<ul>
<li> <p><code>help(key, help_type)</code><br />
(<code>character(1)</code>, <code>character(1)</code>)<br />
Displays help for the dictionary entry <code>key</code>. <code>help_type</code> is one of
<code>"text"</code>, <code>"html"</code>, <code>"pdf"</code> and given as the <code>help_type</code> argument of R's <code>help()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_filtors">dict_filtors</a></code>,
<code><a href="#topic+dict_mutators">dict_mutators</a></code>,
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code>,
<code><a href="#topic+dict_selectors">dict_selectors</a></code>,
<code><a href="#topic+mut">mut</a>()</code>
</p>

<hr>
<h2 id='dict_scalors_aggregate'>Scalor giving Weighted Sum of Multiple Scalors</h2><span id='topic+dict_scalors_aggregate'></span><span id='topic+ScalorAggregate'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that applies multiple other <code><a href="#topic+Scalor">Scalor</a></code>s and calculates their weighted sum.
</p>


<h3>Configuration Parameters</h3>

<p>This operation has the configuration parameters of the <code><a href="#topic+Scalor">Scalor</a></code>s that it wraps: The configuration
parameters of the operator given to the <code>scalors</code> construction argument are prefixed with <code>"scalor_1"</code>,
<code>"scalor_2"</code>, ... up to <code>"scalor_#"</code>, where <code style="white-space: pre;">&#8288;#&#8288;</code> is <code>length(scalors)</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>weight_1</code>, <code>weight_2</code>, ... :: <code>numeric(1)</code><br />
Weight factors of <code>scalors[[1]]</code>, <code>scalors[[2]]</code>, etc. Depending on <code>scaling</code>, the outputs of <code>scalors</code>
is multiplied with this (when <code>scaling</code> is <code>"linear"</code> or <code>"rank"</code>), or ties between ranks are broken
with it (when <code>scaling</code> is <code>"tiebreak"</code>). Initialized to 1.
</p>
</li>
<li> <p><code>scaling</code> :: <code>character(1)</code><br />
How to calculate output values, one of <code>"linear"</code>, <code>"rank"</code> or <code>"tiebreak"</code>. When <code>scaling</code> is <code>"linear"</code>,
then the output is calculated as the weighted sum of the outputs of <code>scalors</code>, weighted by <code>weight_1</code>,
<code>weight_2</code> etc. When <code>scaling</code> is <code>"rank"</code>, then the output is calculated as the weighted sum of the
<code>rank()</code> of <code>scalors</code>, weighted by <code>weight_1</code>, <code>weight_2</code> etc., with ties broken by average. When <code>scaling</code>
is <code>"tiebreak"</code>, then the output is calculated as the averaged <code>rank()</code> of the <code>scalors</code> with the
highest <code>weight_#</code>, with ties broken by the average <code>rank()</code> of the second highest <code>weight_#</code>, with
remaining ties broken by <code>scalors</code> with third highest <code>weight_#</code> etc. Initialized to <code>"linear"</code>.
</p>
</li>
<li> <p><code>scale_output</code> :: <code>logical(1)</code><br />
Whether to scale the output to lie between 0 and 1. Initialized to <code>FALSE</code>.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("aggregate", &lt;scalors&gt;)
scls("aggregate", &lt;scalors&gt;)  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("aggregate", &lt;scalors&gt;)
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorAggregate</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>scalors</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code>s being wrapped. These operators are run and their outputs weighted.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorAggregate-new"><code>ScalorAggregate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorAggregate-prime"><code>ScalorAggregate$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorAggregate-clone"><code>ScalorAggregate$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorAggregate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorAggregate</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorAggregate$new(scalors)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scalors</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code>s to wrap. The operations are run and weighted by <code>weight_#</code> configuration parameters,
depending on the <code>scaling</code> configuration parameter.
The constructed object gets a <em>clone</em> of this argument. The <code style="white-space: pre;">&#8288;$scalors&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ScalorAggregate-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>scalors</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorAggregate$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-ScalorAggregate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorAggregate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>
<p>Other scalor wrappers: 
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = ps(x = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5))

sa = scl("aggregate", list(
    scl("one", objective = 1),
    scl("one", objective = 2)
))
sa$prime(p)

(fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2))

# to see the fitness matrix, use:
## plot(fitnesses, pch = as.character(1:5))

# default weight 1 -- sum of both objectives
sa$operate(data, fitnesses)

# only first objective
sa$param_set$values[c("weight_1", "weight_2")] = c(1, 0)
sa$operate(data, fitnesses)

# only 2 * second objective
sa$param_set$values[c("weight_1", "weight_2")] = c(0, 2)
sa$operate(data, fitnesses)
</code></pre>

<hr>
<h2 id='dict_scalors_domcount'>Scalor Counting Dominating Individuals</h2><span id='topic+dict_scalors_domcount'></span><span id='topic+ScalorDomcount'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that returns a the number of (weakly, epsilon-) dominated or dominating individuals for each individuum.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>output</code> :: <code>character(1)</code><br />
What to count: individuals that are being dominated by the point under consideration(<code>"count_dominated"</code>),
or individuals that do not dominate the point under consideration (<code>"count_not_dominating"</code>).
In both cases, a larger output means the individual is &quot;better&quot;, in some way, according to the fitness values.
Initialized with <code>"count_not_dominating"</code>.
</p>
</li>
<li> <p><code>epsilon</code> :: <code>numeric</code><br />
Epsilon-value for non-dominance, as used by <code><a href="#topic+rank_nondominated">rank_nondominated</a></code>. Initialized to <code>0</code>.
</p>
</li>
<li> <p><code>jitter</code> :: <code>logical(1)</code><br />
Whether to add random jitter to points, with magnitude <code>sqrt(.Machine$double.eps)</code> relative to fitness values.
This is used to effectively break ties.
</p>
</li>
<li> <p><code>scale_output</code> :: <code>logical(1)</code><br />
Whether to scale output by the total numberof individuals, giving output between <code>0</code> and <code>1</code> (inclusive) when <code>TRUE</code>
or integer outputs ranging from 0 and <code>nrow(fitnesses)</code> (inclusive) when <code>FALSE</code>. Initialized to <code>TRUE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("domcount")
scls("domcount")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("domcount")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorDomcount</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorDomcount-new"><code>ScalorDomcount$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorDomcount-clone"><code>ScalorDomcount$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorDomcount-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorNondom</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorDomcount$new()</pre></div>


<hr>
<a id="method-ScalorDomcount-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorDomcount$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = ps(x = p_dbl(-5, 5))
data = data.frame(x = rep(0, 5))

sd = scl("domcount")
sd$prime(p)

(fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2))

# to see the fitness matrix, use:
## plot(fitnesses, pch = as.character(1:5))

# note that for both 2 and 4, all points do not dominate them
# their value is therefore 1
sd$operate(data, fitnesses)

sd$param_set$values$scale_output = FALSE
sd$operate(data, fitnesses)

sd$param_set$values$output = "count_dominated"
# point 4 dominates three other points, point 2 only one other point.
sd$operate(data, fitnesses)
</code></pre>

<hr>
<h2 id='dict_scalors_fixedprojection'>Multi-Objective Fixed Projection Scalor</h2><span id='topic+dict_scalors_fixedprojection'></span><span id='topic+ScalorFixedProjection'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that returns the maximum of a set of projections.
</p>
<p>Priming PS must contain a <code>"scalarization_weights"</code> tagged <code><a href="paradox.html#topic+Domain">p_uty</a></code> that contains
weight matrices (Nobjectives x Nweights) or vectors (if Nweights is 1).
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>scalarization</code> :: <code><a href="base.html#topic+function">function</a></code><br />
Function taking a fitness-matrix <code>fitnesses</code> (Nindivs x Nobjectives, with higher values indicating higher desirability)
and a list of weight matrices <code>weights</code> (Nindivs elements of Nobjectives x Nweights matrices; positive weights should indicate a positive contribution
to scale)
and returns a matrix of scalarizations (Nindivs x Nweights, with higher values indicating greater desirability).<br />
While custom functions can be used, it is recommended to use a <code><a href="#topic+Scalarizer">Scalarizer</a></code>, such as <code><a href="#topic+scalarizer_linear">scalarizer_linear()</a></code>, or <code><a href="#topic+scalarizer_chebyshev">scalarizer_chebyshev()</a></code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("fixedprojection")
scls("fixedprojection")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("fixedprojection")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorFixedProjection</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>weights_component_id</code></dt><dd><p>(<code>numeric(1)</code>)<br />
search space component identifying the weights by which to scalarize.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorFixedProjection-new"><code>ScalorFixedProjection$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorFixedProjection-prime"><code>ScalorFixedProjection$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorFixedProjection-clone"><code>ScalorFixedProjection$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorFixedProjection-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorFixedProjection</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorFixedProjection$new(weights_component_id = "scalarization_weights")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weights_component_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Id of the search space component identifying the weights by which to scalarize. Default <code>"scalarization_weights"</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ScalorFixedProjection-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorFixedProjection$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-ScalorFixedProjection-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorFixedProjection$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>
<p>Other scalor wrappers: 
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
</code></pre>

<hr>
<h2 id='dict_scalors_hypervolume'>Hypervolume Scalor</h2><span id='topic+dict_scalors_hypervolume'></span><span id='topic+ScalorHypervolume'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that returns the hypervolume of each individual, relative to <code>nadir</code> and as a contribution over <code>baseline</code>.
The returned scalar value is the measure of all points that have fitnesses that are
</p>

<ul>
<li><p> greater than the respective value in <code>nadir</code> in all dimensions, and
</p>
</li>
<li><p> smaller than the respective value in the given point in all dimensions, and
</p>
</li>
<li><p> greater than all points in <code>baseline</code> in at least one dimension.
</p>
</li></ul>

<p><code>baseline</code> should probably be a <code>paradox::ContextPV</code> and generate fitness values from the <code><a href="bbotk.html#topic+Archive">Archive</a></code>
in the context using <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a></code>.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>scale_output</code> :: <code>logical(1)</code><br />
Whether to scale output to lie between 0 and 1.
</p>
</li>
<li> <p><code>nadir</code> :: <code>numeric</code><br />
Nadir of fitness values relative to which hypervolume ution is calculated.
</p>
</li>
<li> <p><code>baseline</code> :: <code>matrix</code><br />
Fitness-matrix with one column per objective, giving a population over which the hypervolume improvement should be calculated.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("hypervolume")
scls("hypervolume")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("hypervolume")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorHypervolume</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorHypervolume-new"><code>ScalorHypervolume$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorHypervolume-clone"><code>ScalorHypervolume$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorHypervolume-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorHypervolume</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorHypervolume$new()</pre></div>


<hr>
<a id="method-ScalorHypervolume-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorHypervolume$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sv = scl("hypervolume")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that ScalorHV does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2)
sv$param_set$values$baseline = matrix(c(1, 1), ncol = 2)
sv$param_set$values$nadir = c(0, -1)

sv$prime(p)

sv$operate(data, fitnesses)
</code></pre>

<hr>
<h2 id='dict_scalors_nondom'>Nondominated Sorting Scalor</h2><span id='topic+dict_scalors_nondom'></span><span id='topic+ScalorNondom'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that returns a the rank of the pareto-front in nondominated sorting as scale. Higher ranks
indocate higher fitnesses and therefore &quot;better&quot; individuals.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>epsilon</code>
</p>
</li>
<li> <p><code>nadir</code>
</p>
</li>
<li> <p><code>jitter</code>
</p>
</li>
<li> <p><code>scale_output</code>
</p>
</li>
<li> <p><code>tiebreak</code>
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("nondom")
scls("nondom")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("nondom")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorNondom</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorNondom-new"><code>ScalorNondom$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorNondom-clone"><code>ScalorNondom$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorNondom-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorNondom</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorNondom$new()</pre></div>


<hr>
<a id="method-ScalorNondom-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorNondom$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>so = scl("nondom")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that ScalorNondom does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2)

so$prime(p)

so$operate(data, fitnesses)
</code></pre>

<hr>
<h2 id='dict_scalors_one'>Single Dimension Scalor</h2><span id='topic+dict_scalors_one'></span><span id='topic+ScalorOne'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that returns a the fitness value of a single objective dimension as scale.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>objective</code> :: <code>integer(1)</code><br />
objective to return as scale, ranges from 1 (the default, first objective) to the number of objectives
of the function being optimized.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("one")
scls("one")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("one")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorOne</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorOne-new"><code>ScalorOne$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorOne-clone"><code>ScalorOne$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorOne-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorOne</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorOne$new()</pre></div>


<hr>
<a id="method-ScalorOne-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorOne$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>so = scl("one")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that ScalorOne does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2)

so$prime(p)

so$operate(data, fitnesses)

so$param_set$values$objective = 2

so$operate(data, fitnesses)
</code></pre>

<hr>
<h2 id='dict_scalors_proxy'>Proxy-Scalor that Scales According to its Configuration parameter</h2><span id='topic+dict_scalors_proxy'></span><span id='topic+ScalorProxy'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that performs the operation in its <code>operation</code> configuration parameter. This is useful, e.g., to make
<code><a href="#topic+SelectorBest">SelectorBest</a></code>'s operation fully parametrizable.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>operation</code> :: <code><a href="#topic+Scalor">Scalor</a></code><br />
Operation to perform. Initialized to <code><a href="#topic+ScalorSingleObjective">ScalorSingleObjective</a></code>.
This is primed when <code style="white-space: pre;">&#8288;$prime()&#8288;</code> of <code>ScalorProxy</code> is called, and also when <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is called, to make changing
the operation as part of self-adaption possible. However, if the same operation gets used inside multiple <code>ScalorProxy</code>
objects, then it is recommended to <code style="white-space: pre;">&#8288;$clone(deep = TRUE)&#8288;</code> the object before assigning them to <code>operation</code> to avoid
frequent re-priming.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("proxy")
scls("proxy")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("proxy")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorProxy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorProxy-new"><code>ScalorProxy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorProxy-prime"><code>ScalorProxy$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorProxy-clone"><code>ScalorProxy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorProxy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorProxy</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorProxy$new()</pre></div>


<hr>
<a id="method-ScalorProxy-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorProxy$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-ScalorProxy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorProxy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>
<p>Other scalor wrappers: 
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sp = scl("proxy")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that ScalorOne does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = c(1, 5, 2, 3, 0)

sp$param_set$values$operation = scl("one")
sp$prime(p)
sp$operate(data, fitnesses)

</code></pre>

<hr>
<h2 id='dict_scalors_single'>Single Objective Scalor</h2><span id='topic+dict_scalors_single'></span><span id='topic+ScalorSingleObjective'></span>

<h3>Description</h3>

<p><code><a href="#topic+Scalor">Scalor</a></code> that uses a single given objective, throwing an error in case it is used in a multi-objective problem.
</p>
<p>In contrast to <code><a href="#topic+ScalorOne">ScalorOne</a></code>, this <code><a href="#topic+Scalor">Scalor</a></code> throws an error when more than one objective is present. When
this <code><a href="#topic+Scalor">Scalor</a></code> gets used as the default value, e.g. for a <code><a href="#topic+Selector">Selector</a></code>, then it
forces the user to make an explicit decision about what <code><a href="#topic+Scalor">Scalor</a></code> to use in a multi-objective setting.
</p>


<h3>Configuration Parameters</h3>

<p>No configuration parameters.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Scalor">Scalor</a></code> can be created with the short access form <code><a href="#topic+scl">scl()</a></code>
(<code><a href="#topic+scls">scls()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_scalors">dict_scalors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
scl("single")
scls("single")  # takes vector IDs, returns list of Scalors

# long form:
dict_scalors$get("single")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Scalor">miesmuschel::Scalor</a></code> -&gt; <code>ScalorSingleObjective</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ScalorSingleObjective-new"><code>ScalorSingleObjective$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ScalorSingleObjective-clone"><code>ScalorSingleObjective$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ScalorSingleObjective-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ScalorSingleObjective</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorSingleObjective$new()</pre></div>


<hr>
<a id="method-ScalorSingleObjective-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ScalorSingleObjective$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other scalors: 
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss = scl("single")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that ScalorOne does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses_so = c(1, 5, 2, 3, 0)
fitnesses_mo = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2)

ss$prime(p)

ss$operate(data, fitnesses_so)

try(ss$operate(data, fitnesses_mo))

</code></pre>

<hr>
<h2 id='dict_selectors'>Dictionary of Selectors</h2><span id='topic+dict_selectors'></span>

<h3>Description</h3>

<p>Dictionary of Selectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_selectors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>DictionarySelector</code> (inherits from <code>DictionaryEx</code>, <code>Dictionary</code>, <code>R6</code>) of length 15.
</p>


<h3>Methods</h3>

<p>Methods inherited from <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>, as well as:
</p>

<ul>
<li> <p><code>help(key, help_type)</code><br />
(<code>character(1)</code>, <code>character(1)</code>)<br />
Displays help for the dictionary entry <code>key</code>. <code>help_type</code> is one of
<code>"text"</code>, <code>"html"</code>, <code>"pdf"</code> and given as the <code>help_type</code> argument of R's <code>help()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_filtors">dict_filtors</a></code>,
<code><a href="#topic+dict_mutators">dict_mutators</a></code>,
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code>,
<code><a href="#topic+dict_scalors">dict_scalors</a></code>,
<code><a href="#topic+mut">mut</a>()</code>
</p>

<hr>
<h2 id='dict_selectors_best'>Best Value Selector</h2><span id='topic+dict_selectors_best'></span><span id='topic+SelectorBest'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that selects the top <code>n_select</code> individuals based on the  fitness value, breaking ties randomly. When <code>n_select</code> is larger than the number
of individuals, the selection wraps around: All <code>nrow(values)</code> individuals are selected at least <code>floor(nrow(values) / n_select)</code>
times, with the top <code>nrow(values) %% n_select</code> individuals being selected one more time.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>shuffle_selection</code> :: <code>logical(1)</code><br />
Whether to shuffle the selected output. When this is <code>TRUE</code>, selected individuals are returned in random order, so when this
operator is e.g. used in <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, then subsequent recombination operators effectively operate on pairs
(or larger groups) of random individuals. Otherwise they are returned in order, and recombination operates on the first
batch of <code>n_indivs_in</code> returned individuals first, then the second batch etc. in order. Initialized to <code>TRUE</code> (recommended).
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("best")
sels("best")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("best")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code><a href="#topic+SelectorScalar">miesmuschel::SelectorScalar</a></code> -&gt; <code>SelectorBest</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorBest-new"><code>SelectorBest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorBest-clone"><code>SelectorBest$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="SelectorScalar" data-id="prime"><a href='../../miesmuschel/html/SelectorScalar.html#method-SelectorScalar-prime'><code>miesmuschel::SelectorScalar$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorBest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorBest</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorBest$new(scalor = ScalorSingleObjective$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scalor</code></dt><dd><p>(<code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code> to use to generate scalar values from multiple objectives, if multi-objective optimization is performed.
Initialized to <code><a href="#topic+ScalorSingleObjective">ScalorSingleObjective</a></code>: Doing single-objective optimization normally, throwing an error if used
in multi-objective setting: In that case, a <code><a href="#topic+Scalor">Scalor</a></code> needs to be explicitly chosen.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SelectorBest-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorBest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sb = sel("best")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that SelectorBest does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = c(1, 5, 2, 3, 0)

sb$prime(p)

sb$operate(data, fitnesses, 2)

sb$param_set$values$shuffle_selection = FALSE

sb$operate(data, fitnesses, 4)
</code></pre>

<hr>
<h2 id='dict_selectors_maybe'>Selector-Combination that Selects According to Two Selectors</h2><span id='topic+dict_selectors_maybe'></span><span id='topic+SelectorMaybe'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that wraps two other <code><a href="#topic+Selector">Selector</a></code>s given during construction and uses both for selection proportionally.
Each of the resulting <code>n_select</code> individuals is chosen either from <code style="white-space: pre;">&#8288;$selector&#8288;</code>, or from <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>.
</p>
<p>This makes it possible to implement selection methods such as random interleaving, where only a fraction of <code>p</code>
individuals were selected by a criterion, while the others are taken randomly.
</p>


<h3>Algorithm</h3>

<p>To perform selection, <code>n_selector_in</code> rows of <code>values</code> are given to <code style="white-space: pre;">&#8288;$selector&#8288;</code>, and the remaining
<code>nrow(values) - n_selector_in</code> rows are given to <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>. Both selectors are used to generate
a subset of selected individuals: <code style="white-space: pre;">&#8288;$selector&#8288;</code> generates <code>n_selector_out</code> individuals, and <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> generates
<code>n_select - n_selector_out</code> individuals.
</p>
<p><code>n_selector_in</code> is either set to
<code>round(nrow(values) * p_in)</code> when <code>proportion_in</code> is <code>"exact"</code>, or to <code>rbinom(1, nrow(values), p_in)</code> when <code>proportion_in</code> is <code>"random"</code>.
</p>
<p><code>n_selector_out</code> is set to <code>round(n_select * p_out)</code> when <code>proportion_out</code> is <code>"exact"</code>, or to <code>rbinom(1, n_select, p_out)</code> when <code>proportion_out</code> is <code>"random"</code>.
</p>
<p>When <code>odds_correction</code> is <code>TRUE</code>, then <code>p_out</code> is adjusted depending on the used <code>n_selector_in</code> value before being applied. Let <code>odds(p) = p/(1-p)</code>.
Then the effective <code>p_out</code> is set such that <code style="white-space: pre;">&#8288;odds(effective p_out) = odds(p_out) * n_selector_in / (nrow(values) - n_selector_in) / odds(p_in)&#8288;</code>.
This corrects for the discrepancy between the chosen <code>p_in</code> and the effective proportion of <code>n_selector_in / nrow(values)</code> caused either by rounding
errors or when <code>proportion_in</code> is <code>"random"</code>.
</p>
<p>When <code>p_in</code> is exactly 1 or exactly 0, and <code>p_out</code> is not equal to <code>p_in</code>, then an error is given.
</p>
<p>If <code>nrow(values)</code> is 1, then this individuum is returned and <code style="white-space: pre;">&#8288;$selector&#8288;</code> / <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> are not called.
</p>
<p>If <code>try_unique</code> is <code>TRUE</code>, then <code>n_selector_out</code> is set to at most <code>n_selector_in</code> and at least <code>n_select - nrow(values) + n_selector_in</code>,
and an error is generated when <code>nrow(values)</code> is less than <code>n_select</code>.
</p>
<p>If <code>try_unique</code> is <code>FALSE</code> and <code>odds_correction</code> is <code>TRUE</code> and <code>n_selector_in</code> is either 0 or <code>nrow(values)</code>, then <code style="white-space: pre;">&#8288;$p_out&#8288;</code> is set to either 0 or 1, respectively.
</p>
<p>If <code>try_unique</code> is <code>FALSE</code> and <code>odds_correction</code> is <code>FALSE</code> and <code>n_selector_in</code> is either 0 or <code>nrow(values)</code>, and <code>n_selector_out</code> is not equal
to 0 or <code>n_select</code>, respectively, then
<code>n_selector_in</code> is increased / decreased by 1 to give <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> / <code style="white-space: pre;">&#8288;$selector&#8288;</code> at least one individuum to choose from. While this behaviour
may seem pathological, it is to ensure continuity with sampled values of <code>n_selector_in</code> that are close to 0 or <code>n_select</code>.
</p>
<p>If <code>n_selector_out</code> is <code>n_select</code> or 0, or if <code>n_selector_in</code> is <code>nrows(values) - 1</code> or 1,
then only <code style="white-space: pre;">&#8288;$selector&#8288;</code> / <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> is executed, respectively; possibly with a subset
of <code>values</code> if <code>n_selector_in</code> differs from <code>nrow(values)</code> / 0.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Selector">Selector</a></code>s that it wraps: The configuration parameters of the operator given to the <code>selector</code> construction argument
are prefixed with <code>"maybe."</code>, the configuration parameters of the operator given to the <code>selector_not</code> construction argument are prefixed with <code>"maybe_not."</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>p_in</code> :: <code>numeric(1)</code> <br />
Probability per individual (when <code>random_choise</code> is <code>TRUE</code>), or fraction of individuals (when <code>random_choice</code> is <code>FALSE</code>),
that are given to <code style="white-space: pre;">&#8288;$selector&#8288;</code> instead of <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>. This may be overriden when <code>try_unique</code> is <code>TRUE</code>, in which
case at least as many rows are given to <code style="white-space: pre;">&#8288;$selector&#8288;</code> and <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> as they are generating output values respectively.
When this is exactly 1 or exactly 0, then <code>p_out</code> must be equal to <code>p_in</code>.
Must be set by the user.
</p>
</li>
<li> <p><code>p_out</code> :: <code>numeric(1)</code> <br />
Probability per output value (when <code>random_choise</code> is <code>TRUE</code>), or fraction of output values (when <code>random_choice</code> is <code>FALSE</code>),
that are generated by <code style="white-space: pre;">&#8288;$selector&#8288;</code> instead of <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>. When this values is not given, it defaults to <code>p_in</code>.
</p>
</li>
<li> <p><code>shuffle_input</code> :: <code>logical(1)</code> <br />
Whether to distribute input values randomly to <code style="white-space: pre;">&#8288;$selector&#8288;</code> / <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>. If <code>FALSE</code>, then the first part of <code>values</code>
is given to <code style="white-space: pre;">&#8288;$selector&#8288;</code>. This only randomizes <em>which</em> lines of <code>values</code> are given to <code style="white-space: pre;">&#8288;$selector&#8288;</code> / <code style="white-space: pre;">&#8288;$selector_not&#8288;</code>, but it
does not necessarily reorder the lines of values given to each. In particular, if <code>p_out</code> is 0 or 1, then no shuffling takes place. Initialized to <code>TRUE</code>.
</p>
</li>
<li> <p><code>proportion_in</code> :: <code>character(1)</code> <br />
When set to <code>"random"</code>, sample the number of individuals given to <code style="white-space: pre;">&#8288;$selector&#8288;</code> according to <code>rbinom(1, nrow(values), p_in)</code>.
When set to <code>"exact"</code>, give <code style="white-space: pre;">&#8288;$selector&#8288;</code> <code>round(nrow(values) * p_in)</code> individuals. Initialized to <code>"exact"</code>.
</p>
</li>
<li> <p><code>proportion_out</code> :: <code>character(1)</code> <br />
When set to <code>"random"</code>, sample the number of individuals generated by <code style="white-space: pre;">&#8288;$selector&#8288;</code> according to <code>rbinom(1, n_select, p_out)</code>.
When set to <code>"exact"</code>, have <code style="white-space: pre;">&#8288;$selector&#8288;</code> generate <code>round(n_select * p_out)</code> individuals.
</p>
</li>
<li> <p><code>odds_correction</code> :: <code>logical(1)</code><br />
When set, the effectively used value of <code>p_out</code> is set to
<code>1 / (1 + ((nrow(values) - n_selector_in) * p_in * (1 - p_out)) / (n_selector_in * p_out * (1 - p_in)))</code>, see the <strong>Algorithm</strong> section.
Initialized to <code>FALSE</code>.
</p>
</li>
<li> <p><code>try_unique</code> :: <code>logical(1)</code><br />
Whether to give at least as many rows of <code>values</code> to each of <code style="white-space: pre;">&#8288;$selector&#8288;</code> and <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> as they are generating output
values. This should be set to <code>TRUE</code> whenever <code>SelectorMaybe</code> is used to select unique values, and can be set to
<code>FALSE</code> when selecting values multiple times is acceptable. When this is <code>TRUE</code>, then having <code>n_select &gt; nrow(values)</code>
generates an error. Initialized to <code>TRUE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of <code>selector</code> and <code>selector_not</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Filtor">Filtor</a></code> can be created with the short access form <code><a href="#topic+ftr">ftr()</a></code>
(<code><a href="#topic+ftrs">ftrs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_filtors">dict_filtors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
ftr("maybe", &lt;selector&gt; [, &lt;selector_not&gt;])
ftrs("maybe", &lt;selector&gt; [, &lt;selector_not&gt;])  # takes vector IDs, returns list of Filtors

# long form:
dict_filtors$get("maybe", &lt;selector&gt; [, &lt;selector_not&gt;])
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorMaybe</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> being wrapped. This operator gets run with probability / proportion <code>p_in</code> and generates
output with probability / proportion <code>p_out</code> (configuration parameters).</p>
</dd>
<dt><code>selector_not</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Alternative <code><a href="#topic+Selector">Selector</a></code> being wrapped. This operator gets run with probability / proportion <code>1 - p_in</code>
and generates output with probability / proportion <code>1 - p_out</code> (configuration parameters).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorMaybe-new"><code>SelectorMaybe$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorMaybe-prime"><code>SelectorMaybe$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorMaybe-clone"><code>SelectorMaybe$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorMaybe-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorMaybe</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorMaybe$new(selector, selector_not = SelectorRandom$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> to wrap. This operator gets run with probability / fraction <code>p_in</code> (Configuration parameter).<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>selector_not</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Another <code><a href="#topic+Selector">Selector</a></code> to wrap. This operator runs when <code>selector</code> is not chosen. By
default, this is <code><a href="#topic+SelectorRandom">SelectorRandom</a></code>, i.e. selecting randomly.<br />
The constructed object gets a <em>clone</em> of this argument.
The <code style="white-space: pre;">&#8288;$selector_not&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SelectorMaybe-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>selector</code> and <code>selector_not</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorMaybe$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-SelectorMaybe-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorMaybe$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>
<p>Other selector wrappers: 
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>
</p>

<hr>
<h2 id='dict_selectors_null'>Null Selector</h2><span id='topic+dict_selectors_null'></span><span id='topic+SelectorNull'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that disregards fitness and individual values and selects individuals by order in which they are given.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>shuffle_selection</code> :: <code>logical(1)</code><br />
Whether to shuffle the selected output. When this is <code>TRUE</code>, selected individuals are returned in random order, so when this
operator is e.g. used in <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, then subsequent recombination operators effectively operate on pairs
(or larger groups) of random individuals. Otherwise they are returned in order, and recombination operates on the first
batch of <code>n_indivs_in</code> returned individuals first, then the second batch etc. in order. Initialized to <code>TRUE</code> (recommended).
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("null")
sels("null")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("null")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorNull</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorNull-new"><code>SelectorNull$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorNull-clone"><code>SelectorNull$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorNull-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorNull</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorNull$new()</pre></div>


<hr>
<a id="method-SelectorNull-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorNull$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sn = sel("null")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that SelectorNull does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = c(1, 5, 2, 3, 0)

sn$prime(p)

sn$operate(data, fitnesses, 2)
sn$operate(data, fitnesses, 4)
sn$operate(data, fitnesses, 6)
</code></pre>

<hr>
<h2 id='dict_selectors_proxy'>Proxy-Selector that Selects According to its Configuration Parameter</h2><span id='topic+dict_selectors_proxy'></span><span id='topic+SelectorProxy'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that performs the operation in its <code>operation</code> configuration parameter. This is useful, e.g., to make
<code><a href="#topic+OptimizerMies">OptimizerMies</a></code>'s selection operations fully parametrizable.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>operation</code> :: <code><a href="#topic+Selector">Selector</a></code><br />
Operation to perform. Initialized to <code><a href="#topic+SelectorBest">SelectorBest</a></code>.
This is primed when <code style="white-space: pre;">&#8288;$prime()&#8288;</code> of <code>SelectorProxy</code> is called, and also when <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is called, to make changing
the operation as part of self-adaption possible. However, if the same operation gets used inside multiple <code>SelectorProxy</code>
objects, then it is recommended to <code style="white-space: pre;">&#8288;$clone(deep = TRUE)&#8288;</code> the object before assigning them to <code>operation</code> to avoid
frequent re-priming.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("proxy")
sels("proxy")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("proxy")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorProxy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorProxy-new"><code>SelectorProxy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorProxy-prime"><code>SelectorProxy$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorProxy-clone"><code>SelectorProxy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorProxy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorProxy</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorProxy$new()</pre></div>


<hr>
<a id="method-SelectorProxy-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the operator given to the <code>operation</code> configuration parameter.
Note that this modifies the <code style="white-space: pre;">&#8288;$param_set$values$operation&#8288;</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorProxy$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-SelectorProxy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorProxy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>
<p>Other selector wrappers: 
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sp = sel("proxy")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that SelectorBest does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = c(1, 5, 2, 3, 0)

sp$param_set$values$operation = sel("random")
sp$prime(p)
sp$operate(data, fitnesses, 2)

sp$param_set$values$operation = sel("best")
sp$operate(data, fitnesses, 2)
</code></pre>

<hr>
<h2 id='dict_selectors_random'>Random Selector</h2><span id='topic+dict_selectors_random'></span><span id='topic+SelectorRandom'></span>

<h3>Description</h3>

<p>Random selector that disregards fitness and individual values and selects individuals randomly. Depending on the configuration parameter <code>replace</code>,
it samples with or without replacement.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>sample_unique</code> :: <code>character(1)</code><br />
Whether to sample individuals globally unique (<code>"global"</code>), unique within groups (<code>"groups"</code>), or not unique at all (<code>"no"</code>, sample with replacement).
This is done with best effort; if <code>group_size</code> (when <code>sample_unique</code> is <code>"groups"</code>) or <code>n_select</code> (when <code>sample_unique</code> is <code>"global"</code>)
is greater than <code>nrow(values)</code>, then individuals are selected with as few repeats as possible. Initialized to <code>"groups"</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("random")
sels("random")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("random")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorRandom</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorRandom-new"><code>SelectorRandom$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorRandom-clone"><code>SelectorRandom$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorRandom-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorRandom</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorRandom$new()</pre></div>


<hr>
<a id="method-SelectorRandom-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorRandom$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
sr = sel("random")
p = ps(x = p_dbl(-5, 5))
# dummy data; note that SelectorRandom does not depend on data content
data = data.frame(x = rep(0, 5))
fitnesses = c(1, 5, 2, 3, 0)

sr$prime(p)

sr$operate(data, fitnesses, 2)
sr$operate(data, fitnesses, 2)
sr$operate(data, fitnesses, 2)

sr$operate(data, fitnesses, 4)
sr$operate(data, fitnesses, 4)
sr$operate(data, fitnesses, 4)
</code></pre>

<hr>
<h2 id='dict_selectors_sequential'>Run Multiple Selection Operations in Sequence</h2><span id='topic+dict_selectors_sequential'></span><span id='topic+SelectorSequential'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that wraps multiple other <code><a href="#topic+Selector">Selector</a></code>s given during construction and uses them for selection in sequence.
This makes it possible for one <code><a href="#topic+Selector">Selector</a></code> to discard a few individuals, followed by a second <code><a href="#topic+Selector">Selector</a></code> to
discard more, etc., until <code>n_select</code> individuals are remaining.
</p>


<h3>Algorithm</h3>

<p>Given that there are <code>nrow(values)</code> input individuals in an operation, and <code>n_select</code> individuals requested to be selected,
the operation calls <code>selector_i</code> for <code>i</code> in 1 ... <code>length(selectors)</code> to reduce the number of individuals in this pipeline.
The relative quantity by which the number of individuals is reduced in each step is determined by the configuration parameters
<code>reduction_1</code>, <code>reduction_2</code>, etc., and also dependent on the sum of these values, in the following denoted, with a slight abuse of notation, by <code style="white-space: pre;">&#8288;sum[reduction_#]&#8288;</code>.
</p>
<p>Let the number of individuals passed to step <code>i</code> be denoted by <code>n_values[i]</code>, and the number of individuals requested to be
selected by that step be denoted as <code>n_select_[i]</code>. In particular, <code>n_values[1] == nrow(values)</code>, and <code>n_select_[length(selectors)] == n_select</code>.
</p>
<p>When <code>reduction_by_factor</code> is <code>TRUE</code>, then the reduction at step <code>i</code> is done by a factor, meaning that <code>n_values[i] / n_select_[i]</code> is set (up to rounding).
This factor is <code style="white-space: pre;">&#8288;(nrow(values) / n_select) ^ (reduction_i / sum[reduction_#])&#8288;</code>.
</p>
<p>When <code>reduction_by_factor</code> is <code>FALSE</code>, then the reduction at step <code>i</code> is done by absolute differences, meaning that <code>n_values[i] - n_select_[i]</code> is set (up to rounding).
This difference is <code style="white-space: pre;">&#8288;(nrow(values) - n_select) * (reduction_i / sum[reduction_#])&#8288;</code>, with <code style="white-space: pre;">&#8288;sum[reduction_#]&#8288;</code> as above.
</p>
<p>In particular, this means that when all <code>reduction_#</code> values are the same and <code>reduction_by_factor</code> is <code>TRUE</code>, then each operation reduces the number of
individuals in the pipeline by the same factor. When <code>reduction_by_factor</code> is <code>FALSE</code>, then each operation removes the same absolute number of individuals.
</p>
<p>While the illustrations are done with the assumption that <code>nrow(values) &gt;= n_select</code>, they hold equivalently with <code>nrow(values) &lt; n_select</code>.
</p>
<p>All except the last <code><a href="#topic+Selector">Selector</a></code>s are called with <code>group_size</code> set to their <code>n_select</code> value; the last <code><a href="#topic+Selector">Selector</a></code> is called with the <code>group_size</code> value
given as input.
</p>


<h3>Configuration Parameters</h3>

<p>This operator has the configuration parameters of the <code><a href="#topic+Selector">Selector</a></code>s that it wraps: The configuration parameters of the operator given to the <code>selectors</code> construction
argument are prefixed with <code>"selector_1"</code>, <code>"selector_2"</code>, ... up to <code>"selector_#"</code>, where <code style="white-space: pre;">&#8288;#&#8288;</code> is <code>length(selectors)</code>.
</p>
<p>Additional configuration parameters:
</p>

<ul>
<li> <p><code>reduction_1</code>, <code>reduction_2</code>, ... :: <code>numeric(1)</code><br />
Relative reduction done by <code>selector_1</code>, <code>selector_2</code>, ..., as described in the section <strong>Algorithm</strong>. The values are all initialized to 1, meaning
the same factor (when <code>reduction_by_factor</code> is <code>TRUE</code>) or absolute number (otherwise) of reduction by each operation.
</p>
</li>
<li> <p><code>reduction_by_factor</code> :: <code>logical(1)</code><br />
Whether to do reduction by factor (<code>TRUE</code>) or absolute number (<code>FALSE</code>), as described in <strong>Algorithm</strong>. Initialized to <code>TRUE</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are the set intersection of supported classes of the <code><a href="#topic+Selector">Selector</a></code>s given in <code>selectors</code>.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("sequential", &lt;selectors&gt;)
sels("sequential", &lt;selectors&gt;)  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("sequential", &lt;selectors&gt;)
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorSequential</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>selectors</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code>s being wrapped. These operators get run sequentially in order.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorSequential-new"><code>SelectorSequential$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorSequential-prime"><code>SelectorSequential$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorSequential-clone"><code>SelectorSequential$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorSequential-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorSequential</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorSequential$new(selectors)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>selectors</code></dt><dd><p>(<code>list</code> of <code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code>s to wrap. The operations are run in order given to <code>selectors</code>.
The constructed object gets a <em>clone</em> of this argument. The <code style="white-space: pre;">&#8288;$selectors&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SelectorSequential-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>selectors</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorSequential$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-SelectorSequential-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorSequential$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>
<p>Other selector wrappers: 
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>
</p>

<hr>
<h2 id='dict_selectors_tournament'>Tournament Selector</h2><span id='topic+dict_selectors_tournament'></span><span id='topic+SelectorTournament'></span>

<h3>Description</h3>

<p><code><a href="#topic+Selector">Selector</a></code> that repeatedly samples <code>k</code> individuals and selects the best ouf of these.
</p>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>k</code> :: <code>integer(1)</code><br />
Tournament size. Must be set by the user.
</p>
</li>
<li> <p><code>choose_per_tournament</code> :: Number of individuals to choose in each tournament. Must be smaller than <code>k</code>. The special value <code>0</code> sets this to the <code>group_size</code>
hint given to the <code style="white-space: pre;">&#8288;$operate()&#8288;</code>-call (but at most <code>k</code>). This is equal to <code>n_select</code> when used as survival-selector in <code><a href="#topic+mies_survival_plus">mies_survival_plus()</a></code>/<code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code>,
and equal to <code>n_indivs_in</code> of a <code><a href="#topic+Recombinator">Recombinator</a></code> used in <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>.<br />
Initialized to 1.
</p>
</li>
<li> <p><code>sample_unique</code> :: <code>character(1)</code><br />
Whether to sample individuals globally unique (<code>"global"</code>, selected individuals are removed from the population after each tournament),
unique within groups (<code>"groups"</code>, individuals are replaced when <code>group_size</code> individuals were sampled), unique per tournament (<code>"tournament"</code>, individuals are replaced
after each tournament), or not unique at all (<code>"no"</code>, individuals are sampled with replacement within tournaments).
This is done with best effort; if <code>group_size</code> (when <code>sample_unique</code> is <code>"groups"</code>) or <code>n_select</code> (when <code>sample_unique</code> is <code>"global"</code>)
is greater than <code>nrow(values)</code>, then the first <code>nrow(values) * floor(group_size / nrow(values))</code> or <code>nrow(values) * floor(n_select / nrow(values))</code> individuals
are chosen deterministically by selecting every individual with the same frequency, followed by tournament selection for the remaining required individuals.
Initialized to <code>"groups"</code>.
</p>
</li></ul>



<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are: <code><a href="paradox.html#topic+Domain">p_lgl</a></code> ('ParamLgl'), <code><a href="paradox.html#topic+Domain">p_int</a></code> ('ParamInt'), <code><a href="paradox.html#topic+Domain">p_dbl</a></code> ('ParamDbl'), <code><a href="paradox.html#topic+Domain">p_fct</a></code> ('ParamFct')
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Selector">Selector</a></code> can be created with the short access form <code><a href="#topic+sel">sel()</a></code>
(<code><a href="#topic+sels">sels()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_selectors">dict_selectors</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
sel("tournament")
sels("tournament")  # takes vector IDs, returns list of Selectors

# long form:
dict_selectors$get("tournament")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code><a href="#topic+SelectorScalar">miesmuschel::SelectorScalar</a></code> -&gt; <code>SelectorTournament</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorTournament-new"><code>SelectorTournament$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorTournament-clone"><code>SelectorTournament$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="SelectorScalar" data-id="prime"><a href='../../miesmuschel/html/SelectorScalar.html#method-SelectorScalar-prime'><code>miesmuschel::SelectorScalar$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorTournament-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SelectorTournament</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorTournament$new(scalor = ScalorSingleObjective$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scalor</code></dt><dd><p>(<code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code> to use to generate scalar values from multiple objectives, if multi-objective optimization is performed.
Initialized to <code><a href="#topic+ScalorSingleObjective">ScalorSingleObjective</a></code>: Doing single-objective optimization normally, throwing an error if used
in multi-objective setting: In that case, a <code><a href="#topic+Scalor">Scalor</a></code> needs to be explicitly chosen.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SelectorTournament-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorTournament$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sb = sel("tournament", k = 4)
p = ps(x = p_dbl(-5, 5))
# dummy data; note that SelectorBest does not depend on data content
data = data.frame(x = rep(0, 7))
fitnesses = c(1, 5, 2, 3, 0, 4, 6)

sb$prime(p)

sb$operate(data, fitnesses, 2)

sb$operate(data, fitnesses, 4, group_size = 2)
</code></pre>

<hr>
<h2 id='dist_crowding'>Calculate Crowding Distance</h2><span id='topic+dist_crowding'></span>

<h3>Description</h3>

<p>Takes a <code>matrix</code> of fitness values and calculates the crowding distance for individuals in that <code>matrix</code>.
</p>
<p>Individuals that are minimal or maximal with respect to at least one dimension are assigned infinite
crowding distance.
</p>
<p>Individuals are assumed to be in a (epsilon-) nondominated front.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_crowding(fitnesses)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_crowding_+3A_fitnesses">fitnesses</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric matrix&#8288;</code>)<br />
fitness matrix, with one row per individual and one column per objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>: Vector of crowding distances.
</p>

<hr>
<h2 id='domhv'>Calculate Dominated Hypervolume</h2><span id='topic+domhv'></span>

<h3>Description</h3>

<p>Use Chan's algorithm (Chan, M T (2013).
&ldquo;Klee's measure problem made easy.&rdquo;
In <em>2013 IEEE 54th annual symposium on foundations of computer science</em>, 410&ndash;419.
IEEE.) to calculate dominated hypervolume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domhv(fitnesses, nadir = 0, prefilter = TRUE, on_worse_than_nadir = "warn")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domhv_+3A_fitnesses">fitnesses</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric matrix&#8288;</code>)<br />
fitness matrix, with one row per individual and one column per objective</p>
</td></tr>
<tr><td><code id="domhv_+3A_nadir">nadir</code></td>
<td>
<p>(<code>numeric</code>)<br />
Lowest fitness point up to which to calculate dominated hypervolume. May be a scalar, in which case
it is used for all dimensions, or a vector, in which case its length must match the number of dimensions.
Default 0.</p>
</td></tr>
<tr><td><code id="domhv_+3A_prefilter">prefilter</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to make a first pass that filters out dominated individuals.
If it can be guaranteed that all individuals are non-dominated, setting this to <code>FALSE</code> improves performance a bit.
Otherwise the recommended value is the default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="domhv_+3A_on_worse_than_nadir">on_worse_than_nadir</code></td>
<td>
<p>(<code>character(1)</code>)
Action when individuals that do not dominate the nadir are found. One of <code>"quiet"</code> (ignore), <code>"warn"</code> (give warning, default), or <code>"stop"</code> (throw error).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric(1)</code>: The dominated hypervolume of individuals in <code>fitnesses</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2))

# to see the fitness matrix, use:
## plot(fitnesses, pch = as.character(1:5))

domhv(fitnesses)
</code></pre>

<hr>
<h2 id='domhv_contribution'>Calculate Hypervolume Contribution</h2><span id='topic+domhv_contribution'></span>

<h3>Description</h3>

<p>Takes a <code>matrix</code> of fitness values and calculates the hypervolume contributions of individuals in that <code>matrix</code>.
</p>
<p>Hypervolume contribution of an individual I is the difference between the dominated hypervolume of a set of
individuals including I, where the fitness of I is increased by <code>epsilon</code>, and the dominated hypervolume of
the same set but excluding I.
</p>
<p>Individuals that are less than another individual more than <code>epsilon</code> in any dimension have hypervolume contribution
of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domhv_contribution(fitnesses, nadir = 0, epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domhv_contribution_+3A_fitnesses">fitnesses</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric matrix&#8288;</code>)<br />
fitness matrix, with one row per individual and one column per objective</p>
</td></tr>
<tr><td><code id="domhv_contribution_+3A_nadir">nadir</code></td>
<td>
<p>(<code>numeric</code>)<br />
Lowest fitness point up to which to calculate dominated hypervolume. May be a scalar, in which case
it is used for all dimensions, or a vector, in which case its length must match the number of dimensions.
Default 0.</p>
</td></tr>
<tr><td><code id="domhv_contribution_+3A_epsilon">epsilon</code></td>
<td>
<p>(<code>numeric</code>)<br />
Added to each individual before calculating its particular hypervolume contribution. <code>epsilon</code> may
be a scalar, in which case it is used for all dimensions, or a vector, in which case its length must match
the number of dimensions. Default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>: The vector of dominated hypervolume contributions for each individual in <code>fitnesses</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2))

# to see the fitness matrix, use:
## plot(fitnesses, pch = as.character(1:5))

domhv_contribution(fitnesses)
</code></pre>

<hr>
<h2 id='domhv_improvement'>Calculate Hypervolume Improvement</h2><span id='topic+domhv_improvement'></span>

<h3>Description</h3>

<p>Takes a <code>matrix</code> of fitness values and calculates the hypervolume improvement of individuals in that <code>matrix</code>, one by one,
over the <code>baseline</code> individuals.
</p>
<p>The hypervolume improvement for each point is the measure of all points that have fitnesses that are
</p>

<ul>
<li><p> greater than the respective value in <code>nadir</code> in all dimensions, and
</p>
</li>
<li><p> smaller than the respective value in the given point in all dimensions, and
</p>
</li>
<li><p> greater than all points in <code>baseline</code> in at least one dimension.
</p>
</li></ul>

<p>Individuals in <code>fitnesses</code> are considered independently of each other. A possible speedup is achieved because
<code>baseline</code> individuals only need to be pre-filtered once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domhv_improvement(fitnesses, baseline = NULL, nadir = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domhv_improvement_+3A_fitnesses">fitnesses</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric matrix&#8288;</code>)<br />
fitness matrix, with one row per individual and one column per objective</p>
</td></tr>
<tr><td><code id="domhv_improvement_+3A_baseline">baseline</code></td>
<td>
<p>(<code>matrix</code> | <code>NULL</code>)<br />
Fitness-matrix with one column per objective, giving a population over which the hypervolume improvement should be calculated.
If <code>NULL</code>, the hypervolume of each individual in <code>fitnesses</code> is calculated.</p>
</td></tr>
<tr><td><code id="domhv_improvement_+3A_nadir">nadir</code></td>
<td>
<p>(<code>numeric</code>)<br />
Lowest fitness point up to which to calculate dominated hypervolume. May be a scalar, in which case
it is used for all dimensions, or a vector, in which case its length must match the number of dimensions.
Default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>: The vector of dominated hypervolume contributions for each individual in <code>fitnesses</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(fitnesses = matrix(c(1, 5, 2, 3, 0, 3, 1, 0, 10, 8), ncol = 2))

# to see the fitness matrix, use:
## plot(fitnesses, pch = as.character(1:5))

domhv_improvement(fitnesses)

domhv_improvement(fitnesses, fitnesses[1, , drop = FALSE])
</code></pre>

<hr>
<h2 id='Filtor'>Filtor Base Class</h2><span id='topic+Filtor'></span>

<h3>Description</h3>

<p>Base class representing filter operations, inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>.
</p>
<p>A <code><a href="#topic+Filtor">Filtor</a></code> gets a table of individuals that are to be filtered, as well as a table of individuals that were already evaluated,
along with information on the latter individuals' performance values. Furthermore, the
number of individuals to return is given. The <code>Filtor</code> returns a vector of unique integers indicating which individuals were selected.
</p>
<p>Filter operations are performed in ES algorithms to facilitate concentration towards individuals that likely perform well with regard to the
fitness measure, without evaluating the fitness measure, for example through a surrogate model.
</p>
<p>Fitness values are always <em>maximized</em>, both in single- and multi-criterion optimization.
</p>
<p>Unlike most other operator types inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>, the <code style="white-space: pre;">&#8288;$operate()&#8288;</code> function has four arguments, which are passed on to <code style="white-space: pre;">&#8288;$.filter()&#8288;</code>
</p>

<ul>
<li> <p><code>values</code> :: <code>data.frame</code><br />
Individuals to filter. Must pass the check of the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> given in the last <code style="white-space: pre;">&#8288;$prime()&#8288;</code> call
and may not have any missing components.
</p>
</li>
<li> <p><code>known_values</code> :: <code>data.frame</code><br />
Individuals to use for filtering. Must pass the check of the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> given in the last <code style="white-space: pre;">&#8288;$prime()&#8288;</code> call
and may not have any missing components. Note that <code>known_values</code> may be empty.
</p>
</li>
<li> <p><code>fitnesses</code> :: <code>numeric</code> | <code>matrix</code><br />
Fitnesses for each individual given in <code>known_values</code>. If this is a <code>numeric</code>, then its length must be equal to the number of rows in <code>values</code>. If
this is a <code>matrix</code>, if number of rows must be equal to the number of rows in <code>values</code>, and it must have one column when doing single-crit optimization
and one column each for each  &quot;criterion&quot; when doing multi-crit optimization.
</p>
</li>
<li> <p><code>n_filter</code> :: <code>integer(1)</code><br />
Number of individuals to select. Some <code>Filtor</code>s select individuals with replacement, for which this value may be greater than the number of
rows in <code>values</code>.
</p>
</li></ul>

<p>The return value for an operation will be a numeric vector of integer values of ength <code>n_filter</code> indexing the individuals that were selected. <code>Filtor</code>
must always return unique integers, i.e. select every individual at most once.
</p>


<h3>Inheriting</h3>

<p><code>Filtor</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.filter()&#8288;</code>
function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, and the arguments are passed on to private <code style="white-space: pre;">&#8288;$.filter()&#8288;</code> after checking that
the operator is primed, that the <code>values</code> and <code>known_values</code> arguments conforms to the primed domain and that other values match.
</p>
<p>The <code>private$.needed_input()</code> function should also be overloaded, it is called by the public <code style="white-space: pre;">&#8288;$needed_input()&#8288;</code> function after initial checks;
see the documentation there.
</p>
<p>Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> function should also be overloaded, and optionally the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function; they should call their <code>super</code> equivalents.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>Filtor</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Optimization supported by this <code>Filtor</code>, can be <code>"single-crit"</code>, <code>"multi-crit"</code>, or both.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Filtor-new"><code>Filtor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Filtor-needed_input"><code>Filtor$needed_input()</code></a>
</p>
</li>
<li> <p><a href="#method-Filtor-clone"><code>Filtor$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Filtor-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Filtor</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filtor$new(
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  supported = c("single-crit", "multi-crit"),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Subset of <code>"single-crit"</code> and <code>"multi-crit"</code>, indicating wether single and / or multi-criterion optimization is supported.
Default both of them.<br />
The <code style="white-space: pre;">&#8288;$supported&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Filtor-needed_input"></a>



<h4>Method <code>needed_input()</code></h4>

<p>Calculate the number of <code>values</code> that are required to
filter down to <code>output_size</code>, given the current configuraiton parameter settings.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filtor$needed_input(output_size)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>output_size</code></dt><dd><p>(<code>integer(1)</code>)<br />
A positive integer indicating the number of individuals for which the needed input size should be calculated.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>integer(1)</code>: The minimum number of rows required to filter down to <code>output_size</code>. At least <code>output_size</code>.
</p>


<hr>
<a id="method-Filtor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Filtor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other filtors: 
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>

<hr>
<h2 id='FiltorSurrogate'>Abstract Surrogate Model Filtering Base Class</h2><span id='topic+FiltorSurrogate'></span>

<h3>Description</h3>

<p>Abstract base class for surrogate model filtering.
</p>
<p>A <em>surrogate model</em> is a regression model, based on an <code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code>, which predicts the approximate performance of newly sampled configurations
given the empirical performance of already evaluated configurations. The surrogate model can be used to propose points that have, according to the
surrogate model, a relatively high chance of performing well.
</p>
<p>The <code>FiltorSurrogate</code> base class can be inherited from to create different <code><a href="#topic+Filtor">Filtor</a></code>s that filter based on a surrogate model, for example tournament
filtering or progresive filtering.
</p>


<h3>Configuration Parameters</h3>

<p><code>FiltorSurrogateProgressive</code>'s configuration parameters are the hyperparameters of the <code>surrogate_learner</code> <code><a href="mlr3.html#topic+Learner">Learner</a></code>, as well as
the configuration parameters of the <code>surrogate_selector</code> <code><a href="#topic+Selector">Selector</a></code>.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes depend on the supported feature types of the <code>surrogate_learner</code>, as reported
by <code>surrogate_learner$feature_types</code>: <code>"ParamInt"</code> requires
<code>"integer"</code>, <code>"ParamDbl"</code> requires <code>"numeric"</code>, <code>"ParamLgl"</code> requires <code>"logical"</code>, and <code>"ParamFct"</code> requires <code>"factor"</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Filtor">miesmuschel::Filtor</a></code> -&gt; <code>FiltorSurrogate</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> with which to select using surrogate-predicted performance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FiltorSurrogate-new"><code>FiltorSurrogate$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorSurrogate-prime"><code>FiltorSurrogate$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-FiltorSurrogate-clone"><code>FiltorSurrogate$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="Filtor" data-id="needed_input"><a href='../../miesmuschel/html/Filtor.html#method-Filtor-needed_input'><code>miesmuschel::Filtor$needed_input()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FiltorSurrogate-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the base class components of the <code>FiltorSurrogate</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogate$new(
  surrogate_learner,
  surrogate_selector = SelectorBest$new(),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_learner</code></dt><dd><p>(<code><a href="mlr3.html#topic+LearnerRegr">mlr3::LearnerRegr</a></code>)<br />
Regression learner for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_learner&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>surrogate_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)
<code><a href="#topic+Selector">Selector</a></code> for the surrogate model filtering algorithm.<br />
The <code style="white-space: pre;">&#8288;$surrogate_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> of the method implemented in the inheriting class with configuration parameters that go beyond the
parameters of the <code>surrogate_learner</code> and <code>surrogate_selector</code>.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FiltorSurrogate-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operator
given to <code>surrogate_selector</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogate$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-FiltorSurrogate-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FiltorSurrogate$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other filtors: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+dict_filtors_maybe">dict_filtors_maybe</a></code>,
<code><a href="#topic+dict_filtors_null">dict_filtors_null</a></code>,
<code><a href="#topic+dict_filtors_proxy">dict_filtors_proxy</a></code>,
<code><a href="#topic+dict_filtors_surprog">dict_filtors_surprog</a></code>,
<code><a href="#topic+dict_filtors_surtour">dict_filtors_surtour</a></code>
</p>

<hr>
<h2 id='mies_aggregate_generations'>Get Aggregated Performance Values by Generation</h2><span id='topic+mies_aggregate_generations'></span>

<h3>Description</h3>

<p>Get evaluated performance values from an <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> aggregated for each generation.
This may either concern all individuals that were alive at the end of a given generation (<code>survivors_only</code> <code>TRUE</code>)
or at any point during a generation (<code>survivors_only</code> <code>FALSE</code>).
</p>
<p>The result is a single <code><a href="data.table.html#topic+data.table">data.table</a></code> object with a <code>dob</code> column indicating the
generation, as well as one column for each <code>aggregations</code> entry crossed with each objective of <code>inst</code>.
</p>
<p>See <code><a href="#topic+mies_generation_apply">mies_generation_apply()</a></code> on how to apply functions to entire fitness-matrices, not only individual objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_aggregate_generations(
  inst,
  objectives = inst$archive$codomain$ids(),
  aggregations = list(min = min, mean = mean, max = max, median = stats::median, size =
    length),
  as_fitnesses = TRUE,
  survivors_only = TRUE,
  condition_on_budget_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_aggregate_generations_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_aggregate_generations_+3A_objectives">objectives</code></td>
<td>
<p>(<code>character</code>)<br />
Objectives for which to calculate aggregates. Must be a subset of the codomain elements of <code>inst</code>, but when <code>as_fitnesses</code> is <code>TRUE</code>, elements
that are neither being minimized nor maximized are ignored.</p>
</td></tr>
<tr><td><code id="mies_aggregate_generations_+3A_aggregations">aggregations</code></td>
<td>
<p>(named <code>list</code> of <code>function</code>)<br />
List containing aggregation functions to be evaluated on a vector of objective falues for each generation. These functions should take
a single argument and return a scalar value.</p>
</td></tr>
<tr><td><code id="mies_aggregate_generations_+3A_as_fitnesses">as_fitnesses</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to transform performance values into &quot;fitness&quot; values that are always to be maximized.
This means that values that objectives that should originally be minimized are multiplied with -1,
and that parts of the objective codomain that are neither being minimized nor maximized are dropped.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mies_aggregate_generations_+3A_survivors_only">survivors_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to ignore configurations that have <code>"eol"</code> set to the given generation, i.e. individuals that were killed during that generation.
When this is <code>TRUE</code> (default), then only individuals that are alive at the <em>end</em> of a generation are considered; otherwise all individuals
alive at any point of a generation are considered. If it is <code>TRUE</code>, this leads to individuals that have <code>"dob"</code> == <code>"eol"</code> being ignored.</p>
</td></tr>
<tr><td><code id="mies_aggregate_generations_+3A_condition_on_budget_id">condition_on_budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component when doing multi-fidelity optimization. When this is given, then for each generation, only individuals with the highest value for this
component are considered. If <code>survivors_only</code> is <code>TRUE</code>, this means the highest value of all survivors of a given generation, if it is <code>FALSE</code>, then it
is the highest value of all individuals alive at any point of a generation. To ignore possible budget-parameters, set this to <code>NULL</code> (default).
This is inparticular necessary when fidelity is not monotonically increasing (e.g. if it is categorical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the column <code>"dob"</code>, indicating the generation, as well as further
columns named by the items in <code>aggregations</code>. There is more on element in <code>objectives</code>
(or more than one element not being minimized/maximized when <code>as_fitnesses</code> is <code>TRUE</code>), then columns are named <code style="white-space: pre;">&#8288;&lt;aggregations element name&gt;.&lt;objective name&gt;&#8288;</code>.
Otherwise, they are named by <code style="white-space: pre;">&#8288;&lt;aggregations element name&gt;&#8288;</code> only. To get a guarantee that elements are only named after elements in <code>aggregations</code>, set <code>objectives</code>
to a length 1 <code>character</code>.
</p>


<h3>See Also</h3>

<p>Other aggregation methods: 
<code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation</a>()</code>,
<code><a href="#topic+mies_get_generation_results">mies_get_generation_results</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- 10 - exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "minimize"))
)

oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 6)
)

op &lt;- opt("mies",
  lambda = 2, mu = 2,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("best")
)
set.seed(1)
op$optimize(oi)

# negates objectives that are minimized:
mies_aggregate_generations(oi)

# silly aggregation: first element
mies_aggregate_generations(oi, aggregations = list(first = function(x) x[1]))

# real objective values:
mies_aggregate_generations(oi, as_fitnesses = FALSE)

# Individuals that died are included:
mies_aggregate_generations(oi, survivors_only = FALSE)
</code></pre>

<hr>
<h2 id='mies_aggregate_single_generation'>Aggregate a Value for a given Generation</h2><span id='topic+mies_aggregate_single_generation'></span>

<h3>Description</h3>

<p>Applies a <code>fitness_aggregator</code> function to the values that were alive in the archive at a given generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_aggregate_single_generation(
  archive,
  fitness_aggregator,
  generation = NA,
  include_previous_generations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_aggregate_single_generation_+3A_archive">archive</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+Archive">Archive</a></code>)<br />
The archive over which to aggregate.</p>
</td></tr>
<tr><td><code id="mies_aggregate_single_generation_+3A_fitness_aggregator">fitness_aggregator</code></td>
<td>
<p>(<code>function</code>)<br />
Aggregation function, called with information about alive individuals of each generation. See details.</p>
</td></tr>
<tr><td><code id="mies_aggregate_single_generation_+3A_generation">generation</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Generation for which to aggregate the value.
If <code>include_previous_generations</code> is <code>FALSE</code>, then an individual is considered to be alive at generation <code>i</code> if its <code>dob</code> is smaller or equal to <code>i</code>, and
if its <code>eol</code> is either <code>NA</code> or greater than <code>i</code>. If <code>include_previous_generations</code> is <code>TRUE</code>, then all individuals with <code>dob</code> smaller or equal to <code>i</code> are
considered.
If this is <code>NA</code>, the currently alive (<code>include_previous_generations</code> <code>FALSE</code>) or all (<code>include_previous_generations</code> <code>TRUE</code>) individuals are aggregated.
If multiple individuals considered &quot;alive&quot; with the same <code>x_id</code> are found, then only the last individual is used.
This excludes previous individuals that were re-evaluated with a different fidelity.</p>
</td></tr>
<tr><td><code id="mies_aggregate_single_generation_+3A_include_previous_generations">include_previous_generations</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Aggregate all individuals that were alive at <code>generation</code> or at any point before that.
Duplicates with the same <code>x_id</code> are removed, meaning that if an individual was re-evaluated with different fidelity, only the last
re-evaluation is counted.
However, note that individuals from different generations may still have been evaluated with different fidelity, so if
Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fitness_aggregator</code> function may have any of the following arguments, which will be given the following information when
<code>fitness_aggregator</code> is called:
</p>

<ul>
<li> <p><code>fitnesses</code> :: <code>matrix</code><br />
Will contain fitnesses for each alive individual. This value has one column when doing single-crit optimization and one column for
each &quot;criterion&quot; when doing multi-crit optimization.
Fitnesses are always being maximized, so if an objective is being minimized, the <code>fitness_aggregator</code> function is given the objective values * -1.
</p>
</li>
<li> <p><code>objectives_unscaled</code> :: <code>matrix</code><br />
The objective values as given to <code>fitnesses</code>, but not multiplied by -1 if they are being minimized. It is recommended that
the <code>codomain</code> argument is queried for <code>"maximize"</code> or <code>"minimize"</code> tags when <code>objectives_unscaled</code> is used.
</p>
</li>
<li> <p><code>budget</code> :: <code>scalar</code><br />
If multi-fidelity evaluation is being performed, then this is the &quot;budget&quot; value of each individual. Otherwise it is a vector containing the value
1 for each individual.
</p>
</li>
<li> <p><code>xdt</code> :: <code>data.table</code><br />
The configurations that were evaluated for the alive individuals. Rows are in the same order as the values given to <code>fitnesses</code>
or <code>objectives_unscaled</code>.
</p>
</li>
<li> <p><code>search_space</code> :: <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code><br />
The search space of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> under evaluation.
</p>
</li>
<li> <p><code>codomain</code> :: <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code><br />
The codomain of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> under evaluation.
This is particularly useful when using <code>objectives_unscaled</code> to determine minimization or maximization.
</p>
</li></ul>

<p>Not all of these arguments need to present, but at least one of <code>fitnesses</code>, <code>objectives_unscaled</code>, or <code>xdt</code> must be.
</p>
<p><code>fitness_aggregator</code> will never be called for an empty generation.
</p>


<h3>Value</h3>

<p>The value returned by <code>fitness_aggregator</code> when applied to individuals alive at generation <code>generation</code>. If no
individuals of the requested generation are present, <code>fitness_aggregator</code> is not called
and <code>mies_aggregate_single_generation()</code> returns <code>NULL</code> instead.
</p>


<h3>See Also</h3>

<p>Other aggregation methods: 
<code><a href="#topic+mies_aggregate_generations">mies_aggregate_generations</a>()</code>,
<code><a href="#topic+mies_get_generation_results">mies_get_generation_results</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi &lt;- OptimInstanceMultiCrit$new(objective, terminator = trm("none"))

try(mies_aggregate_single_generation(oi$archive, identity), silent = TRUE)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses)


mies_init_population(oi, 2, budget_id = "x1", fidelity = .5)

oi$archive$data

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses)

# Notice how fitnesses are positive, since x2 is scaled with -1.
# To get the original objective-values, use objectives_unscaled:
mies_aggregate_single_generation(oi$archive,
  function(objectives_unscaled) objectives_unscaled)

# When `...` is used, all information is passed:
mies_aggregate_single_generation(oi$archive, function(...) names(list(...)))

# Generation 10 is not present, but individuals with eol `NA` are still
# considered alive:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 10)

# Re-evaluating points with higher "fidelity" (x1)
mies_step_fidelity(oi, budget_id = "x1", fidelity = 0.7)

oi$archive$data
# Lower-fidelity values are considered dead now, even for generation 1:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 1)

# This adds two new alive individuals at generation 2.
# Also the individuals from gen 1 are reevaluated with fidelity 0.8
mies_evaluate_offspring(oi, offspring = data.frame(x2 = c(-0.1, -0.2)),
  budget_id = "x1", fidelity = 0.9, reevaluate_fidelity = 0.8)

oi$archive$data

mies_aggregate_single_generation(oi$archive, function(budget, ...) budget)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 1)

mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 2)

# No individuals were killed, but some were fidelity-reevaluated.
# These are not present with include_previous_generations:
mies_aggregate_single_generation(oi$archive, function(fitnesses) fitnesses,
  generation = 2, include_previous_generations = TRUE)

# Typical use-case: get dominated hypervolume
mies_aggregate_single_generation(oi$archive, function(fitnesses) domhv(fitnesses))

# Get generation-wise mean fitness values
mies_aggregate_single_generation(oi$archive, function(fitnesses) {
  apply(fitnesses, 2, mean)
})
</code></pre>

<hr>
<h2 id='mies_evaluate_offspring'>Evaluate Proposed Configurations Generated in a MIES Iteration</h2><span id='topic+mies_evaluate_offspring'></span>

<h3>Description</h3>

<p>Calls <code style="white-space: pre;">&#8288;$eval_batch&#8288;</code> of a given <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> on a set
of configurations as part of a MIES operation. The <code>dob</code> extra-info in the archive
is also set properly to indicate a progressed generation.
</p>
<p>This function can be used directly, but it is easier to use it within the <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>
class if standard GA operation is desired.
</p>
<p>Multifidelity evaluation is supported as described in <code>vignette("mies-multifid")</code>. For this,
an extra component named after <code>budget_id</code> is appended to each individual, chosen from
the <code>fidelity</code> argument and depending on the value of <code>survivor_budget</code>. <code>budget_id</code> should
have the same values as given to the other <code style="white-space: pre;">&#8288;mies_*&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_evaluate_offspring(
  inst,
  offspring,
  budget_id = NULL,
  fidelity = NULL,
  reevaluate_fidelity = NULL,
  fidelity_monotonic = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_evaluate_offspring_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_evaluate_offspring_+3A_offspring">offspring</code></td>
<td>
<p>(<code>data.frame</code>)<br />
Proposed configurations to be evaluated, must have columns named after the <code>inst</code>'s search space, minus <code>budget_id</code> if not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mies_evaluate_offspring_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component when doing multi-fidelity optimization. This component of the search space is added
to <code>individuals</code> according to <code>fidelity</code>. Should be <code>NULL</code> when no multi-fidelity optimization is performed (default).</p>
</td></tr>
<tr><td><code id="mies_evaluate_offspring_+3A_fidelity">fidelity</code></td>
<td>
<p>(<code>atomic(1)</code> | <code>NULL</code>)<br />
Atomic scalar indicating the value to be assigned to the <code>budget_id</code> component of offspring.
This value must be <code>NULL</code> if no multi-fidelity optimization is performed (the default).</p>
</td></tr>
<tr><td><code id="mies_evaluate_offspring_+3A_reevaluate_fidelity">reevaluate_fidelity</code></td>
<td>
<p>(<code>atomic(1)</code>)<br />
Fidelity with which to evaluate alive individuals from previous generations that have a budget value below (if <code>fidelity_monotonic</code> is <code>TRUE</code>) or
different from the current <code>fidelity</code> value. Default <code>NULL</code>: Do not re-evaluate. Must be <code>NULL</code> when <code>budget_id</code> and <code>fidelity</code> are <code>NULL</code>.
See also <code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a></code>.</p>
</td></tr>
<tr><td><code id="mies_evaluate_offspring_+3A_fidelity_monotonic">fidelity_monotonic</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
When <code>reevaluate_fidelity</code> is non-<code>NULL</code>, then this indicates whether individuals should only ever be re-evaluated when fidelity would be increased.
Default <code>TRUE</code>. Ignored when <code>reevaluate_fidelity</code> is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+invisible">invisible</a> <code><a href="data.table.html#topic+data.table">data.table</a></code>: the performance values returned when evaluating the <code>offspring</code> values
through <code>eval_batch</code>.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)
# Initial state:
oi$archive

# 'offspring' is just a data.frame of values to evaluate.
# In general it should be created using 'mies_generate_offspring()'.
offspring = data.frame(x = 1:2, y = 2:1)

mies_evaluate_offspring(oi, offspring = offspring)

# This evaluated the given points and assigned them 'dob' 2.
oi$archive

# Note that at this point one would ordinarily call a 'mies_survival_*()'
# function.

###
# Advanced demo, making use of additional components and doing multi-fidelity
##

# declare 'y' the budget parameter. It will not be in the 'offspring'
# table any more.
budget_id = "y"
# but: offspring may contain any other value that is appended to 'oi'. These
# are ignored by the objective.
offspring = data.frame(x = 0:1, z = 3)

mies_evaluate_offspring(oi, offspring = offspring, budget_id = budget_id,
  fidelity = 1)

# This now has the additional column 'z'. Values of y for the new evaluations
# are 1.
oi$archive

offspring = data.frame(x = 2, z = 3)
# Increasing the fidelity will not cause re-evaluation of existing individuals
# when `reevaluate_fidelity` is not given.
mies_evaluate_offspring(oi, offspring = offspring, budget_id = budget_id,
  fidelity = 2)
oi$archive

offspring = data.frame(x = 3, z = 3)
# Depending on the effect of fidelity, this may however have a biasing effect,
# so it may be desirable to re-evaluate surviving individuals from previous
# generations. The 'reevaluate_fidelity' may even be different from 'fidelity'
mies_evaluate_offspring(oi, offspring = offspring, budget_id = budget_id,
  fidelity = 3, reevaluate_fidelity = 2)

# In this example, only individuals with 'y = 1' were re-evaluated, since
# 'fidelity_monotonic' is TRUE.
oi$archive

</code></pre>

<hr>
<h2 id='mies_filter_offspring'>Filter Offspring</h2><span id='topic+mies_filter_offspring'></span>

<h3>Description</h3>

<p>Uses a <code><a href="#topic+Filtor">Filtor</a></code> to extract a subset of individuals from a given set. The individuals are either returned directly (when <code>get_indivs</code> is <code>TRUE</code>)
or in form of an index into the given individuals (when <code>get_indivs</code> is <code>FALSE</code>).
</p>
<p><code><a href="#topic+Filtor">Filtor</a></code>s must always select individuals without replacement, so selected individual indices are unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_filter_offspring(
  inst,
  individuals,
  lambda,
  filtor = NULL,
  budget_id = NULL,
  fidelity = NULL,
  get_indivs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_filter_offspring_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_individuals">individuals</code></td>
<td>
<p>(<code>data.frame</code> | <code><a href="data.table.html#topic+data.table">data.table</a></code>)<br />
Individuals to filter. Must have columns according to <code>filtor$primed_ps</code>, and must have at least <code>filtor$needed_input(lambda)</code> rows.</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_lambda">lambda</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of individuals to filter down to.</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_filtor">filtor</code></td>
<td>
<p>(<code><a href="#topic+Filtor">Filtor</a></code> | <code>NULL</code>)<br />
<code><a href="#topic+Filtor">Filtor</a></code> operator that filters. When <code>NULL</code> is given, then the <code><a href="#topic+FiltorNull">FiltorNull</a></code> operation is performed and the first <code>lambda</code> individuals are
taken from <code>individuals</code>.</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component when doing multi-fidelity optimization. This component of the search space is added
to <code>individuals</code> according to <code>fidelity</code>. Should be <code>NULL</code> when no multi-fidelity optimization is performed (default).</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_fidelity">fidelity</code></td>
<td>
<p>(<code>atomic</code> | <code>NULL</code>)<br />
scalar indicating the value of the <code>budget_id</code> component with which to evaluate individuals to be filtered.<br />
This value must be <code>NULL</code> when no multi-fidelity optimization is performed, but it may <strong>also</strong> be <code>NULL</code> when the
maximum value of the <code>budget_id</code> found in <code>inst$archive</code> should be used (the default).</p>
</td></tr>
<tr><td><code id="mies_filter_offspring_+3A_get_indivs">get_indivs</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to return the <code>data.frame</code> or <code><a href="data.table.html#topic+data.table">data.table</a></code> of selected individuals, or an index into <code>individuals</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>get_indivs</code> is <code>TRUE</code>: a <code>data.frame</code> or <code><a href="data.table.html#topic+data.table">data.table</a></code> (depending on the input type of <code>individuals</code>) of filtered configurations.
If <code>get_indivs</code> is <code>FALSE</code>: an <code>integer</code> vector indexing the filtered individuals.
</p>

<hr>
<h2 id='mies_generate_offspring'>Generate Offspring Through Mutation and Recombination</h2><span id='topic+mies_generate_offspring'></span>

<h3>Description</h3>

<p>Generate new proposal individuals to be evaluated using <code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring()</a></code>.
</p>
<p>Parent individuals are selected using <code>parent_selector</code>, then mutated using <code>mutator</code>, and thend
recombined using <code>recombinator</code>. If only a subset of these operations is desired, then
it is possible to set <code>mutator</code> or <code>recombinator</code> to the respective &quot;null&quot;-operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_generate_offspring(
  inst,
  lambda,
  parent_selector = NULL,
  mutator = NULL,
  recombinator = NULL,
  budget_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_generate_offspring_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_generate_offspring_+3A_lambda">lambda</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of new individuals to generate. This is not necessarily the number with which <code>parent_selector</code>
gets called, because <code>recombinator</code> could in principle need more than <code>lambda</code> input individuals to
generate <code>lambda</code> output individuals.</p>
</td></tr>
<tr><td><code id="mies_generate_offspring_+3A_parent_selector">parent_selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code> | <code>NULL</code>)<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects parent individuals depending on configuration values
and objective results. When <code>parent_selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses()</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.
When this is <code>NULL</code> (default), then a <code><a href="#topic+SelectorBest">SelectorBest</a></code> us used.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on a superset of <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization. All components on which <code>selector</code> is primed on must occur in the archive.<br />
The given <code><a href="#topic+Selector">Selector</a></code> <em>may</em> return duplicates.</p>
</td></tr>
<tr><td><code id="mies_generate_offspring_+3A_mutator">mutator</code></td>
<td>
<p>(<code><a href="#topic+Mutator">Mutator</a></code> | <code>NULL</code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> operation to apply to individuals selected out of <code>inst</code> using <code>parent_selector</code>.<br />
The <code><a href="#topic+Mutator">Mutator</a></code> must be primed on a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> similar to <code>inst$search_space</code>,
but <em>without</em> the &quot;budget&quot; component when <code>budget_id</code> is given (multi-fidelity optimization). Such a
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> can be generated for example using <code><a href="#topic+mies_prime_operators">mies_prime_operators</a></code>.<br />
When this is <code>NULL</code> (default), then a <code><a href="#topic+MutatorNull">MutatorNull</a></code> is used, effectively disabling mutation.</p>
</td></tr>
<tr><td><code id="mies_generate_offspring_+3A_recombinator">recombinator</code></td>
<td>
<p>(<code><a href="#topic+Recombinator">Recombinator</a></code> | <code>NULL</code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> operation to apply to individuals selected out of <code>int</code> using <code>parent_selector</code> after mutation using <code>mutator</code>.
The <code><a href="#topic+Recombinator">Recombinator</a></code> must be primed on a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> similar to <code>inst$search_space</code>,
but <em>without</em> the &quot;budget&quot; component when <code>budget_id</code> is given (multi-fidelity optimization). Such a
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> can be generated for example using <code><a href="#topic+mies_prime_operators">mies_prime_operators</a></code>.<br />
When this is <code>NULL</code> (default), then a <code><a href="#topic+RecombinatorNull">RecombinatorNull</a></code> is used, effectively disabling recombination.</p>
</td></tr>
<tr><td><code id="mies_generate_offspring_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget compnent when doing multi-fidelity optimization. This component of the search space is removed from
individuals sampled from the archive in <code>inst</code> before giving it to <code>mutator</code> and <code>recombinator</code>.
Should be <code>NULL</code> when not doing multi-fidelity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table">data.table</a></code>: A table of configurations proposed as offspring to be evaluated
using <code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring()</a></code>.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

# Demo operators
m = mut("gauss", sdev = 0.1)
r = rec("xounif")
s = sel("random")
# Operators must be primed
mies_prime_operators(objective$domain, list(m), list(r), list(s))

# We would normally call mies_init_population, but for reproducibility
# we are going to evaluate three given points

oi$eval_batch(data.table::data.table(x = 0:2, y = 2:0, dob = 1, eol = NA_real_))

# Evaluated points:
oi$archive

# Use default operators: no mutation, no recombination, parent_selctor is
# sel("best") --&gt; get one individual, the one with highest performance in the
# archive (x = 1, y = 1).
# (Note 'mies_generate_offspring()' does not modify 'oi')
mies_generate_offspring(oi, lambda = 1)

# Mutate the selected individual after selection. 'm' has 'sdev' set to 0.1,
# so the (x = 1, y = 1) is slightly permuted.
mies_generate_offspring(oi, lambda = 1, mutator = m)

# Recombination, then mutation.
# Even though lambda is 1, there will be two individuals selected with
# sel("best") and recombined, because rec("xounif") needs two parents. One
# of the crossover results is discarded (respecting that 'lambda' is 1),
# the other is mutated and returned.
mies_generate_offspring(oi, lambda = 1, mutator = m, recombinator = r)

# General application: select, recombine, then mutate.
mies_generate_offspring(oi, lambda = 5, parent_selector = s, mutator = m, recombinator = r)

</code></pre>

<hr>
<h2 id='mies_generation'>Get the Last Generation that was Evaluated</h2><span id='topic+mies_generation'></span>

<h3>Description</h3>

<p>Gets the last generation that was evaluated as counted by the <code>"dob"</code> column in the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>'s <code><a href="bbotk.html#topic+Archive">Archive</a></code>.
</p>
<p>This accepts <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>s that were not evaluated with <code>miesmuschel</code> and are therefore missing the <code>"dob"</code> column, returning
a value of 0. However, if the <code>"dob"</code> column is invalid (the inferred generation is not integer numeric or not non-negative), an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_generation(inst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_generation_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar integer value indicating the last generation that was evaluated in <code>inst</code>. It is 0 when <code>inst</code> is empty, and also typically 0 if all evaluations
in <code>inst</code> so far were performed outside of <code>miesmuschel</code>. Every call of <code><a href="#topic+mies_init_population">mies_init_population</a></code> that actually performs evaluations, as well as each call to
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a></code> with non-empty <code>offspring</code>, increases the generation by 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- 10 - exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "minimize"))
)

oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 6)
)

op &lt;- opt("mies",
  lambda = 2, mu = 2,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("best")
)
set.seed(1)

mies_generation(oi)

op$optimize(oi)
mies_generation(oi)

oi$terminator = trm("evals", n_evals = 10)

op$optimize(oi)
mies_generation(oi)
</code></pre>

<hr>
<h2 id='mies_generation_apply'>Aggregate Values for All Generations Present</h2><span id='topic+mies_generation_apply'></span>

<h3>Description</h3>

<p>Applies a <code>fitness_aggregator</code> function to the values that were alive in the archive at at any generation.
<code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code> is used, see there for more information about <code>fitness_aggregator</code>.
</p>
<p>Generations for which <code>fitness_aggregator</code> returns <code>NULL</code>, or which are not present in any <code>dob</code> in the archive,
or which contain no alive individuals (e.g. because <code>eol</code> is smaller or equal <code>dob</code> for all of them) are ignored.
</p>
<p><code>as.list()</code> is applied to the values returned by <code>fitness_aggregator</code>, and <code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code> is called on
the list of resulting values. If the first non-<code>NULL</code>-value returned by <code>fitness_aggregator</code>, then <code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code>
is called with <code>fill = TRUE</code> and <code>use.names = TRUE</code>.
</p>
<p>If no non-empty generations are present, or <code>fitness_aggregator</code> returns <code>NULL</code> on every call, then the return value
is <code>data.table(dob = numeric(0))</code>.
</p>
<p>In contrast with <code><a href="#topic+mies_aggregate_generations">mies_aggregate_generations()</a></code>, <code>mies_generate_apply()</code> can construct aggregated values for
entire fitness matrices, not only individual objectives (see examples). However, <code><a href="#topic+mies_aggregate_generations">mies_aggregate_generations()</a></code> is simpler
if per-objective aggregates are desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_generation_apply(
  archive,
  fitness_aggregator,
  include_previous_generations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_generation_apply_+3A_archive">archive</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+Archive">Archive</a></code>)<br />
The archive over which to aggregate.</p>
</td></tr>
<tr><td><code id="mies_generation_apply_+3A_fitness_aggregator">fitness_aggregator</code></td>
<td>
<p>(<code>function</code>)<br />
Aggregation function, called with information about alive individuals of each generation. See <code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code>.</p>
</td></tr>
<tr><td><code id="mies_generation_apply_+3A_include_previous_generations">include_previous_generations</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Aggregate all individuals that were alive at <code>generation</code> or at any point before that.
Duplicates with the same <code>x_id</code> are removed, meaning that if an individual was re-evaluated with different fidelity, only the last
re-evaluation is counted.
However, note that individuals from different generations may still have been evaluated with different fidelity, so if
Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.table</code> with columns <code>dob</code>, next to the columns constructed from the return values of <code>fitness_aggregator</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)
oi &lt;- OptimInstanceMultiCrit$new(objective,
  terminator = trm("evals", n_evals = 40))

op &lt;- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# Aggregated hypervolume of individuals alive in each gen:
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
})

# Aggregated hypervolume of all points evaluated up to each gen
# (may be slightly more, since the domhv of more points is evaluated).
# This would be the dominated hypervolume of the result set at each
# generation:
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)

# The following are simpler with mies_aggregate_single_generations():
mies_generation_apply(oi$archive, function(fitnesses) {
  apply(fitnesses, 2, mean)
})
# Compare:
mies_aggregate_generations(oi, aggregations = list(mean = mean))

mies_generation_apply(oi$archive, function(objectives_unscaled) {
  apply(objectives_unscaled, 2, mean)
})
# Compare:
mies_aggregate_generations(oi, aggregations = list(mean = mean),
  as_fitnesses = FALSE)
</code></pre>

<hr>
<h2 id='mies_get_fitnesses'>Get Fitness Values from OptimInstance</h2><span id='topic+mies_get_fitnesses'></span>

<h3>Description</h3>

<p>Get fitness values in the correct form as used by <code><a href="#topic+Selector">Selector</a></code> operators from an
<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>.
This works for both single-criterion and multi-criterion optimization, and entails multiplying
objectives with -1 if they are being minimized, since <code><a href="#topic+Selector">Selector</a></code> tries to maximize fitness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_get_fitnesses(inst, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_get_fitnesses_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_get_fitnesses_+3A_rows">rows</code></td>
<td>
<p>optional (<code>integer</code>)<br />
Indices of rows within <code>inst</code> to consider. If this is not given, then the entire archive is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> <code>matrix</code> with <code>length(rows)</code> (if <code>rows</code> is given, otherwise <code>nrow(inst$archive$data)</code>) rows
and one column for each objective: fitnesses to be maximized.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)

oi$archive

mies_get_fitnesses(oi, c(2, 3))

###
# Multi-objective, and automatic maximization:
objective2 &lt;- ObjectiveRFun$new(
  fun = function(xs) list(Obj1 = xs$x^2, Obj2 = -xs$y^2),
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(
    Obj1 = p_dbl(tags = "minimize"),
    Obj2 = p_dbl(tags = "maximize")
  )
)
# Using MultiCrit!
oi &lt;- OptimInstanceMultiCrit$new(objective2,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)

oi$archive

# Note Obj1 has a different sign than in the archive.
mies_get_fitnesses(oi, c(2, 3))

</code></pre>

<hr>
<h2 id='mies_get_generation_results'>Get Performance Values by Generation</h2><span id='topic+mies_get_generation_results'></span>

<h3>Description</h3>

<p>Get evaluated performance values from an <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> for all individuals that were alive
at a given generation. Depending on <code>survivors_only</code>, all individuals alive at the <em>end</em> of a generation are returned,
or all individuals alive at any point during a generation.
</p>
<p>The resulting <code><a href="data.table.html#topic+data.table">data.table</a></code> object is formatted for easy manipulation to get relevant
information about optimization progress. To get aggregated values per generation, use <code>by = "dob"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_get_generation_results(
  inst,
  as_fitnesses = TRUE,
  survivors_only = TRUE,
  condition_on_budget_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_get_generation_results_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_get_generation_results_+3A_as_fitnesses">as_fitnesses</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to transform performance values into &quot;fitness&quot; values that are always to be maximized.
This means that values that objectives that should originally be minimized are multiplied with -1,
and that parts of the objective codomain that are neither being minimized nor maximized are dropped.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mies_get_generation_results_+3A_survivors_only">survivors_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to ignore configurations that have <code>"eol"</code> set to the given generation, i.e. individuals that were killed during that generation.
When this is <code>TRUE</code> (default), then only individuals that are alive at the <em>end</em> of a generation are considered; otherwise all individuals
alive at any point of a generation are considered. If it is <code>TRUE</code>, this leads to individuals that have <code>"dob"</code> == <code>"eol"</code> being ignored.</p>
</td></tr>
<tr><td><code id="mies_get_generation_results_+3A_condition_on_budget_id">condition_on_budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component when doing multi-fidelity optimization. When this is given, then for each generation, only individuals with the highest value for this
component are considered. If <code>survivors_only</code> is <code>TRUE</code>, this means the highest value of all survivors of a given generation, if it is <code>FALSE</code>, then it
is the highest value of all individuals alive at any point of a generation. To ignore possible budget-parameters, set this to <code>NULL</code> (default).
This is inparticular necessary when fidelity is not monotonically increasing (e.g. if it is categorical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the column <code>"dob"</code>, indicating the generation, as well as further
columns named by the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>'s objectives.
</p>


<h3>See Also</h3>

<p>Other aggregation methods: 
<code><a href="#topic+mies_aggregate_generations">mies_aggregate_generations</a>()</code>,
<code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- 10 - exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "minimize"))
)

oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 6)
)

op &lt;- opt("mies",
  lambda = 2, mu = 2,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("best")
)
set.seed(1)
op$optimize(oi)

# negates objectives that are minimized:
mies_get_generation_results(oi)

# real objective values:
mies_get_generation_results(oi, as_fitnesses = FALSE)

# Individuals that died are included:
mies_get_generation_results(oi, survivors_only = FALSE)
</code></pre>

<hr>
<h2 id='mies_init_population'>Initialize MIES Optimization</h2><span id='topic+mies_init_population'></span>

<h3>Description</h3>

<p>Set up an <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> for MIES optimization.
This adds the <code>dob</code> and <code>eol</code> columns to the instance's archive, and makes sure there are at least <code>mu</code> survivors
(i.e. entries with <code>eol</code> set to <code>NA</code>) present. If there are already <code style="white-space: pre;">&#8288;&gt;= mu&#8288;</code> prior evaluations present, then the last
<code>mu</code> of these remain alive (the other's <code>eol</code> set to 0); otherwise, up to <code>mu</code> new randomly sampled configurations
are evaluated and added to the archive and have <code>eol</code> set to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_init_population(
  inst,
  mu,
  initializer = generate_design_random,
  survival_selector = SelectorBest$new()$prime(inst$search_space),
  budget_id = NULL,
  fidelity = NULL,
  fidelity_new_individuals_only = FALSE,
  fidelity_monotonic = TRUE,
  additional_component_sampler = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_init_population_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_mu">mu</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Population target size, non-negative integer.</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_initializer">initializer</code></td>
<td>
<p>(<code>function</code>)<br />
Function that generates a <code><a href="paradox.html#topic+Design">Design</a></code> object, with arguments <code>param_set</code> and <code>n</code>, functioning like <code><a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a></code>
or <code><a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a></code>. Note that <code><a href="paradox.html#topic+generate_design_grid">paradox::generate_design_grid</a></code> can not be used and must be wrapped with
a custom function that ensures that only <code>n</code> individuals are produced. The generated design must correspond to the <code>inst</code>'s <code style="white-space: pre;">&#8288;$search_space&#8288;</code>; for
components that are not in the objective's search space, the <code>additional_component_sampler</code> is used.</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_survival_selector">survival_selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Used when the given <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> already contains more individuals than <code>mu</code>.<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects surviving individuals depending on configuration values
and objective results,  When <code>survival_selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization. Default is <code><a href="#topic+SelectorBest">SelectorBest</a></code>.<br />
The given <code><a href="#topic+Selector">Selector</a></code> may <em>not</em> return duplicates.<br /></p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component when doing multi-fidelity optimization. This component of the search space is added
to <code>individuals</code> according to <code>fidelity</code>. Should be <code>NULL</code> when no multi-fidelity optimization is performed (default).</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_fidelity">fidelity</code></td>
<td>
<p>(<code>atomic(1)</code> | <code>NULL</code>)<br />
Atomic scalar indicating the value to be assigned to the <code>budget_id</code> component of offspring.
This value must be <code>NULL</code> if no multi-fidelity optimization is performed (the default).</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_fidelity_new_individuals_only">fidelity_new_individuals_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
When <code>fidelity</code> is not <code>NULL</code>: Whether to re-evaluate individuals that are already present in <code>inst</code> should they have a smaller (if <code>fidelity_monotonic</code> is <code>TRUE</code>) or different
(if <code>fidelity_monotonic</code> is <code>FALSE</code>) value from the one given to <code>fidelity</code>. Default <code>FALSE</code>. Ignored when <code>fidelity</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_fidelity_monotonic">fidelity_monotonic</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to only re-evaluate configurations for which the fidelity would increase. Default <code>TRUE</code>.
Ignored when <code>fidelity</code> is <code>NULL</code> or when <code>fidelity_new_individuals_only</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mies_init_population_+3A_additional_component_sampler">additional_component_sampler</code></td>
<td>
<p>(<code><a href="paradox.html#topic+Sampler">Sampler</a></code> | <code>NULL</code>)<br />
<code><a href="paradox.html#topic+Sampler">Sampler</a></code> for components of individuals that are not part of <code>inst</code>'s <code style="white-space: pre;">&#8288;$search_space&#8288;</code>. These components
are never used for performance evaluation, but they may be useful for self-adaptive <code><a href="#topic+OperatorCombination">OperatorCombination</a></code>s. See the description
of <code><a href="#topic+mies_prime_operators">mies_prime_operators()</a></code> on how operators need to be primed to respect additional components.<br />
It is possible that <code>additional_component_sampler</code> is used for <em>more</em> rows than <code>initializer</code>, which happens
when the <code>inst</code>'s <code style="white-space: pre;">&#8288;$archive&#8288;</code> contains prior evaluations that are alive, but does not contain columns pertaining to additional columns,
or contains <em>all</em> these columns but there are rows that are <code>NA</code> valued. If only <em>some</em> of the columns are present, or if all these columns
are present but there are rows that are only <code>NA</code> valued for some columns, then an error is thrown.<br />
Default is <code>NULL</code>: no additional components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+invisible">invisible</a> <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>: the input
instance, modified by-reference.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)

# 3 evaluations, archive contains 'dob' and 'eol'
oi$archive

###
# Advanced demo, making use of additional components and fidelity
##

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3, budget_id = "y", fidelity = 2,
  additional_component_sampler = Sampler1DRfun$new(
    param = ps(additional = p_dbl(-1, 1)), rfun = function(n) rep(-1, n)
  )
)

# 3 evaluations. We also have 'additional', sampled from rfun (always -1),
# which is ignored by the objective. Besides, we have "y", which is 2,
# according to 'fidelity'.
oi$archive

</code></pre>

<hr>
<h2 id='mies_prime_operators'>Prime MIES Operators</h2><span id='topic+mies_prime_operators'></span>

<h3>Description</h3>

<p>Prime the given <code><a href="#topic+MiesOperator">MiesOperator</a></code>s for an optimization run with the given search space.
</p>
<p>In its simplest form, MIES optimization only optimizes the search space of the <code><a href="bbotk.html#topic+Objective">Objective</a></code> to be optimized. However,
more advanced optimization may handle a &quot;budget&quot; parameter for multi-fidelity optimization differently: It is still selected by <code><a href="#topic+Selector">Selector</a></code>s,
but not mutated or recombined and instead handled separately. It is also possible to add additional components to the search space that are
not evaluated by the objective function, but that are used for self-adaption by other operators.
</p>
<p>The <code>mies_prime_operators()</code> function uses the information that the user usually has readily at hand &ndash; the <code><a href="bbotk.html#topic+Objective">Objective</a></code><code style="white-space: pre;">&#8288;s search space, the budget parameter, and additional components -- and primes [&#8288;</code>Mutator<code style="white-space: pre;">&#8288;], [&#8288;</code>Recombinator<code style="white-space: pre;">&#8288;], and [&#8288;</code>Selector'] objects in the right way:
</p>

<ul>
<li> <p><code><a href="#topic+Selector">Selector</a></code>s are primed on a union of <code>search_space</code> and <code>additional_components</code>
</p>
</li>
<li> <p><code><a href="#topic+Mutator">Mutator</a></code>s and <code><a href="#topic+Recombinator">Recombinator</a></code>s are primed on the <code><a href="#topic+Selector">Selector</a></code>'s space with the <code>budget_id</code> <code><a href="paradox.html#topic+Domain">Domain</a></code> removed.
</p>
</li></ul>

<p><code>mies_prime_operators()</code> is called with an arbitrary number of <code><a href="#topic+MiesOperator">MiesOperator</a></code> arguments; typically one <code><a href="#topic+Mutator">Mutator</a></code>, one <code><a href="#topic+Recombinator">Recombinator</a></code> and
at least two <code><a href="#topic+Selector">Selector</a></code>: one for survival selection, and one parent selection. Supplied <code><a href="#topic+MiesOperator">MiesOperator</a></code>s are primed by-reference, but
they are also returned as <a href="base.html#topic+invisible">invisible</a> <code>list</code>.
</p>
<p>If neither additional components nor multi-fidelity optimization is used, it is also possible to use the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function of hte <code><a href="#topic+MiesOperator">MiesOperator</a></code>s
directly, although using <code>mies_prime_operators()</code> gives flexibility for future extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_prime_operators(
  search_space,
  mutators = list(),
  recombinators = list(),
  selectors = list(),
  filtors = list(),
  ...,
  additional_components = NULL,
  budget_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_prime_operators_+3A_search_space">search_space</code></td>
<td>
<p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Search space of the <code><a href="bbotk.html#topic+Objective">Objective</a></code> or <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> to be optimized.</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_mutators">mutators</code></td>
<td>
<p>(<code>list</code> of <code><a href="#topic+Mutator">Mutator</a></code>)<br />
<code><a href="#topic+Mutator">Mutator</a></code> objects to prime. May be empty (default).</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_recombinators">recombinators</code></td>
<td>
<p>(<code>list</code> of <code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
<code><a href="#topic+Recombinator">Recombinator</a></code> objects to prime. May be empty (default).</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_selectors">selectors</code></td>
<td>
<p>(<code>list</code> of <code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> objects to prime. May be empty (default).</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_filtors">filtors</code></td>
<td>
<p>(<code>list</code> of <code><a href="#topic+Filtor">Filtor</a></code>)<br />
<code><a href="#topic+Filtor">Filtor</a></code> objects to prime. May be empty (default).</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_...">...</code></td>
<td>
<p>(any)<br />
Must not be given. Other operators may be added in the future, so the following arguments should be passed by name.</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_additional_components">additional_components</code></td>
<td>
<p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>NULL</code>)<br />
Additional components to optimize over, not included in <code>search_space</code>, but possibly used for self-adaption. This must be the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
of <code>mies_init_population()</code>'s <code>additional_component_sampler</code> argument.</p>
</td></tr>
<tr><td><code id="mies_prime_operators_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code> | <code>NULL</code>)<br />
Budget component used for multi-fidelity optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible</code> named <code>list</code> with entries <code style="white-space: pre;">&#8288;$mutators&#8288;</code> (<code>list</code> of <code><a href="#topic+Mutator">Mutator</a></code>, primed <code>mutators</code>), <code style="white-space: pre;">&#8288;$recombinators&#8288;</code> (<code>list</code> of <code><a href="#topic+Recombinator">Recombinator</a></code>, primed <code>recombinators</code>),
and <code style="white-space: pre;">&#8288;$selectors&#8288;</code> (<code>list</code> of <code><a href="#topic+Selector">Selector</a></code>, primed <code>selectors</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Search space of a potential TuningInstance for optimization:
search_space = ps(x = p_dbl(), y = p_dbl())
# Additoinal search space components that are not part of the TuningInstance
additional_components = ps(z = p_dbl())
# Budget parameter not subject to mutation or recombination
budget_id = "y"

m = mut("gauss")
r = rec("xounif")
s1 = sel("best")
s2 = sel("random")
f = ftr("null")

mies_prime_operators(search_space, mutators = list(m),
  recombinators = list(r), selectors = list(s1, s2), filtors = list(f),
  additional_components = additional_components, budget_id = budget_id
)

# contain search_space without budget parameter, with additional_components
m$primed_ps
r$primed_ps

# contain also the budget parameter
s1$primed_ps
s2$primed_ps
f$primed_ps
</code></pre>

<hr>
<h2 id='mies_select_from_archive'>Select Individuals from an OptimInstance</h2><span id='topic+mies_select_from_archive'></span>

<h3>Description</h3>

<p>Apply a <code><a href="#topic+Selector">Selector</a></code> operator to a subset of configurations inside
an <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>
and return the index within the archive (when <code>get_indivs</code> <code>FALSE</code>) or the configurations themselves
(when <code>get_indivs</code> is <code>TRUE</code>).
</p>
<p>It is not strictly necessary for the selector to select unique individuals / individuals without replacement.
</p>
<p>Individuals are selected independently of whether they are &quot;alive&quot; or not. To select only from alive individuals,
set <code>rows</code> to <code>inst$archive$data[, which(is.na(eol))]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_select_from_archive(
  inst,
  n_select,
  rows,
  selector = SelectorBest$new()$prime(inst$search_space),
  group_size = 1,
  get_indivs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_select_from_archive_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_select_from_archive_+3A_n_select">n_select</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of individuals to select.</p>
</td></tr>
<tr><td><code id="mies_select_from_archive_+3A_rows">rows</code></td>
<td>
<p>optional (<code>integer</code>)<br />
Indices of rows within <code>inst</code> to consider. If this is not given, then the entire archive is used.</p>
</td></tr>
<tr><td><code id="mies_select_from_archive_+3A_selector">selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects individuals depending on configuration values
and objective results. When <code>selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses()</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.
Defaults to <code><a href="#topic+SelectorBest">SelectorBest</a></code>.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on a superset of <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization. All components on which <code>selector</code> is primed on must occur in the archive.<br />
The given <code><a href="#topic+Selector">Selector</a></code> <em>may</em> return duplicates.</p>
</td></tr>
<tr><td><code id="mies_select_from_archive_+3A_group_size">group_size</code></td>
<td>
<p>(<code>integer</code>)<br />
Sampling group size hint, indicating that the caller would prefer there to not be any duplicates within this group size.
The <code><a href="#topic+Selector">Selector</a></code> may or may not ignore this value, however.
This may possibly happen because of certain configuration parameters, or because the input size is too small.<br />
Must either be a scalar value or sum up to <code>n_select</code>. Must be non-negative. A scalar value of 0 is interpreted the same as 1.<br />
Default is 1.</p>
</td></tr>
<tr><td><code id="mies_select_from_archive_+3A_get_indivs">get_indivs</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to return configuration values from within the archive (<code>TRUE</code>) or just the indices within
the archive (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>integer</code> | <code><a href="data.table.html#topic+data.table">data.table</a></code>: Selected individuals, either index into <code>inst</code> or subset of archive table,
depending on <code>get_indivs</code>.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

s = sel("best")
s$prime(oi$search_space)

mies_init_population(inst = oi, mu = 6)

oi$archive

# Default: get individuals
mies_select_from_archive(oi, n_select = 2, rows = 1:6, selector = s)

# Alternatively: get rows within archive
mies_select_from_archive(oi, n_select = 2, rows = 1:6, selector = s,
  get_indivs = FALSE)

# Rows gotten from archive are relative from *all* rows, not from archive[rows]:
mies_select_from_archive(oi, n_select = 2, rows = 3:6, selector = s,
  get_indivs = FALSE)

##
# When using additional components: mies_select_from_archive learns about
# additional components from primed selector.

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 6,
  additional_component_sampler = Sampler1DRfun$new(
    param = ps(additional = p_dbl(-1, 1)), rfun = function(n) -1
  )
)

oi$archive

# Wrong: using selector primed only on search space. The resulting
# individuals do not have the additional component.
mies_select_from_archive(oi, n_select = 2, rows = 1:6, selector = s)

# Correct: selector must be primed on search space + additional component
mies_prime_operators(oi$search_space, selectors = list(s),
  additional_components = ps(additional = p_dbl(-1, 1)))

mies_select_from_archive(oi, n_select = 2, rows = 1:6, selector = s)
</code></pre>

<hr>
<h2 id='mies_step_fidelity'>Re-Evaluate Existing Configurations with Higher Fidelity</h2><span id='topic+mies_step_fidelity'></span>

<h3>Description</h3>

<p>As part of the &quot;rolling-tide&quot; multifidelity-setup, do reevaluation of configurations with
higher fidelity that have survived lower-fidelity selection. The evaluations are done as part of the
<em>current</em> generation, so the <code>dob</code> value is not increased.
</p>
<p>This function should only be called when doing rolling-tide multifidelity, and should not be part of the
MIES cycle otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_step_fidelity(
  inst,
  budget_id,
  fidelity,
  current_gen_only = FALSE,
  fidelity_monotonic = TRUE,
  additional_components = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_step_fidelity_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_step_fidelity_+3A_budget_id">budget_id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Budget component that is set to the <code>fidelity</code> value.</p>
</td></tr>
<tr><td><code id="mies_step_fidelity_+3A_fidelity">fidelity</code></td>
<td>
<p>(<code>atomic(1)</code>)<br />
Atomic scalar indicating the value to be assigned to the <code>budget_id</code> component of offspring.</p>
</td></tr>
<tr><td><code id="mies_step_fidelity_+3A_current_gen_only">current_gen_only</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to only re-evaluate survivors individuals generated in the latest generation (<code>TRUE</code>), or re-evaluate all currently alive
individuals (<code>FALSE</code>). In any case, only individuals that were not already evaluated with the chosen fidelity are evaluated,
so this will usually only have an effect when the fidelity of surviving individuals changed between generations.</p>
</td></tr>
<tr><td><code id="mies_step_fidelity_+3A_fidelity_monotonic">fidelity_monotonic</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to only re-evaluate configurations for which the fidelity would increase. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mies_step_fidelity_+3A_additional_components">additional_components</code></td>
<td>
<p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>NULL</code>)<br />
Additional components to optimize over, not included in <code>search_space</code>, but possibly used for self-adaption. This must be the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
of <code>mies_init_population()</code>'s <code>additional_component_sampler</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="base.html#topic+invisible">invisible</a> <code><a href="data.table.html#topic+data.table">data.table</a></code>: the performance values returned when evaluating the <code>offspring</code> values
through <code>eval_batch</code>.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

budget_id = "y"

# Create an initial population with fidelity ("y") value 1
mies_init_population(oi, mu = 2, budget_id = budget_id, fidelity = 1)

oi$archive

# Re-evaluate these individuals with higher fidelity
mies_step_fidelity(oi, budget_id = budget_id, fidelity = 2)

oi$archive

# The following creates a new generation without killing the initial
# generation
offspring = data.frame(x = 0:1)
mies_evaluate_offspring(oi, offspring = offspring, budget_id = budget_id,
  fidelity = 3)

oi$archive

# Re-evaluate only individuals from last generation by setting current_gen_only
mies_step_fidelity(oi, budget_id = budget_id, fidelity = 4,
  current_gen_only = TRUE)

oi$archive

# Default: Re-evaluate all that *increase* fidelity: Only the initial
# population is re-evaluated here.
mies_step_fidelity(oi, budget_id = budget_id, fidelity = 3)

oi$archive

# To also re-evaluate individuals with *higher* fidelity, use
# 'fidelity_monotonic = FALSE'. This does not re-evaluate the points that already have
# the requested fidelity, however.
mies_step_fidelity(oi, budget_id = budget_id, fidelity = 3, fidelity_monotonic = FALSE)

oi$archive
</code></pre>

<hr>
<h2 id='mies_survival_comma'>Choose Survivors According to the &quot;Mu , Lambda&quot; (&quot;Comma&quot;) Strategy</h2><span id='topic+mies_survival_comma'></span>

<h3>Description</h3>

<p>Choose survivors during a MIES iteration using the &quot;Comma&quot; survival strategy, i.e.
selecting survivors from the latest generation only, using a <code><a href="#topic+Selector">Selector</a></code> operator, and choosing
&quot;elites&quot; from survivors from previous generations using a different <code><a href="#topic+Selector">Selector</a></code> operator.
</p>
<p>When <code>n_elite</code> is greater than the number of alive individuals from previous generations,
then all these individuals from previous generations survive. In this case, it is
possible that more than <code>mu - n_elite</code> individuals from the current generation survive.
Similarly, when <code>mu</code> is greater
than the number of alive individuals from the last generation, then all these individuals survive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_survival_comma(inst, mu, survival_selector, n_elite, elite_selector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_survival_comma_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_survival_comma_+3A_mu">mu</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Population target size, non-negative integer.</p>
</td></tr>
<tr><td><code id="mies_survival_comma_+3A_survival_selector">survival_selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects surviving individuals depending on configuration values
and objective results. When <code>survival_selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization.<br />
The given <code><a href="#topic+Selector">Selector</a></code> may <em>not</em> return duplicates.</p>
</td></tr>
<tr><td><code id="mies_survival_comma_+3A_n_elite">n_elite</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of individuals to carry over from previous generations. <code>n_elite</code> individuals will be selected
by <code>elite_selector</code>, while <code>mu - n_elite</code> will be selected by <code>survival_selector</code> from the most
recent generation. <code>n_elite</code> may be 0 (no elitism), in which case only individuals from the newest
generation survive. <code>n_elite</code> must be strictly smaller than <code>mu</code> to permit any optimization progress.</p>
</td></tr>
<tr><td><code id="mies_survival_comma_+3A_elite_selector">elite_selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects &quot;elites&quot;, i.e. surviving individuals from previous generations,
depending on configuration values
and objective results. When <code>elite_selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses()</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization.<br />
The given <code><a href="#topic+Selector">Selector</a></code> may <em>not</em> return duplicates.</p>
</td></tr>
<tr><td><code id="mies_survival_comma_+3A_...">...</code></td>
<td>
<p>(any)<br />
Ignored, for compatibility with other <code style="white-space: pre;">&#8288;mies_survival_*&#8288;</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code><a href="data.table.html#topic+data.table">data.table</a></code>: The value of <code>inst$archive$data</code>, changed
in-place with <code>eol</code> set to the current generation for non-survivors.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_plus">mies_survival_plus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)
# Usually the offspring is generated using mies_generate_offspring()
# Here shorter for demonstration purposes.
offspring = generate_design_random(oi$search_space, 3)$data
mies_evaluate_offspring(oi, offspring = offspring)

# State before: different generations of individuals. Alive individuals have
# 'eol' set to 'NA'.
oi$archive

s = sel("best")
s$prime(oi$search_space)
mies_survival_comma(oi, mu = 3, survival_selector = s,
  n_elite = 2, elite_selector = s)

# sel("best") lets only the best individuals survive.
# mies_survival_comma selects from new individuals (generation 2 in this case)
# and old individuals (all others) separately: n_elite = 2 from old,
# mu - n_elite = 1 from new.
# The surviving individuals have 'eol' set to 'NA'
oi$archive
</code></pre>

<hr>
<h2 id='mies_survival_plus'>Choose Survivors According to the &quot;Mu + Lambda&quot; (&quot;Plus&quot;) Strategy</h2><span id='topic+mies_survival_plus'></span>

<h3>Description</h3>

<p>Choose survivors during a MIES iteration using the &quot;Plus&quot; survival strategy, i.e.
combining all alive individuals from the latest and from prior generations indiscriminately and
choosing survivors using a survival <code><a href="#topic+Selector">Selector</a></code> operator.
</p>
<p>When <code>mu</code> is greater than the number of alive individuals, then all individuals survive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mies_survival_plus(inst, mu, survival_selector, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mies_survival_plus_+3A_inst">inst</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>)<br />
Optimization instance to evaluate.</p>
</td></tr>
<tr><td><code id="mies_survival_plus_+3A_mu">mu</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Population target size, non-negative integer.</p>
</td></tr>
<tr><td><code id="mies_survival_plus_+3A_survival_selector">survival_selector</code></td>
<td>
<p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
<code><a href="#topic+Selector">Selector</a></code> operator that selects surviving individuals depending on configuration values
and objective results. When <code>survival_selector$operate()</code> is called, then objectives that
are being minimized are multiplied with -1 (through <code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a></code>), since <code><a href="#topic+Selector">Selector</a></code>s always try to maximize fitness.<br />
The <code><a href="#topic+Selector">Selector</a></code> must be primed on <code>inst$search_space</code>; this <em>includes</em> the &quot;budget&quot; component
when performing multi-fidelity optimization.<br />
The given <code><a href="#topic+Selector">Selector</a></code> may <em>not</em> return duplicates.</p>
</td></tr>
<tr><td><code id="mies_survival_plus_+3A_...">...</code></td>
<td>
<p>(any)<br />
Ignored, for compatibility with other <code style="white-space: pre;">&#8288;mies_survival_*&#8288;</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code><a href="data.table.html#topic+data.table">data.table</a></code>: The value of <code>inst$archive$data</code>, changed
in-place with <code>eol</code> set to the current generation for non-survivors.
</p>


<h3>See Also</h3>

<p>Other mies building blocks: 
<code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring</a>()</code>,
<code><a href="#topic+mies_generate_offspring">mies_generate_offspring</a>()</code>,
<code><a href="#topic+mies_get_fitnesses">mies_get_fitnesses</a>()</code>,
<code><a href="#topic+mies_init_population">mies_init_population</a>()</code>,
<code><a href="#topic+mies_select_from_archive">mies_select_from_archive</a>()</code>,
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity</a>()</code>,
<code><a href="#topic+mies_survival_comma">mies_survival_comma</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

mies_init_population(inst = oi, mu = 3)
offspring = generate_design_random(oi$search_space, 2)$data
mies_evaluate_offspring(oi, offspring = offspring)

# State before: different generations of individuals. Alive individuals have
# 'eol' set to 'NA'.
oi$archive

s = sel("best")
s$prime(oi$search_space)
mies_survival_plus(oi, mu = 3, survival_selector = s)

# sel("best") lets only the three best individuals survive.
# The others have 'eol = 2' (the current generation).
oi$archive
</code></pre>

<hr>
<h2 id='MiesOperator'>Operator Base Class</h2><span id='topic+MiesOperator'></span>

<h3>Description</h3>

<p>Base class representing MIES-operators: <code><a href="#topic+Recombinator">Recombinator</a></code>, <code><a href="#topic+Mutator">Mutator</a></code>, and <code><a href="#topic+Selector">Selector</a></code>.
</p>
<p>Operators perform a specific function within ES algorithms, and by exchanging them, the character of ES
algorithms can be modified. Operators operate on collections of individuals and return
modified individuals (mutated or recombined) or indices of selected individuals. Operators can be combined using
<code><a href="#topic+MutatorCombination">MutatorCombination</a></code> / <code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code> and other operators wrappers.
</p>
<p>Before applying operators, they have to be <em>primed</em> for the domain of the individuals which they are operating on;
this is done using the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function. Afterwards, the <code style="white-space: pre;">&#8288;$operate()&#8288;</code> function may be called with a <code>data.frame</code>
of individuals that fall into this domain. <code style="white-space: pre;">&#8288;$operate()&#8288;</code> may be called multiple times after priming, and a once
primed operator can be primed again for a different domain by calling <code style="white-space: pre;">&#8288;$prime()&#8288;</code> agian (which forgets the old priming).
</p>


<h3>Inheriting</h3>

<p><code>MiesOperator</code> is an abstract base class and should be inherited from. Inheriting classes should implement the
private <code style="white-space: pre;">&#8288;$.operate()&#8288;</code> function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, and the arguments are passed on to
private <code style="white-space: pre;">&#8288;$.operate()&#8288;</code> after checking that the operator is primed, and that the <code>values</code> argument conforms to the
primed domain. Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> and <code style="white-space: pre;">&#8288;$prime()&#8288;</code> functions are also overloaded, but should call their
<code>super</code> equivalents.
</p>
<p>In most cases, the <code>MiesOperator</code> class should not be inherited from, directly; instead, the operator classes
(<code><a href="#topic+Recombinator">Recombinator</a></code>, <code><a href="#topic+Mutator">Mutator</a></code>, <code><a href="#topic+Selector">Selector</a></code>) or their subclasses should be inherited.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Configuration parameters of the <code>MiesOperator</code> object. Read-only.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle, contains any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>. Read-only.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)<br />
Packages needed for the operator. Read-only.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of this class in its respective <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>.
Is <code>NULL</code> if this class it not (known to be) in a <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>. Read-only.</p>
</dd>
<dt><code>dict_shortaccess</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Name of <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> short-access function where an object of this class can be retrieved.
Is <code>NULL</code> if this class is not (known to be) in a <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code>
with a short-access function. Read-only.</p>
</dd>
<dt><code>endomorphism</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the output of <code style="white-space: pre;">&#8288;$operate()&#8288;</code> is a <code>data.frame</code> / <code><a href="data.table.html#topic+data.table">data.table</a></code> in the same domain as its input. Read-only.</p>
</dd>
<dt><code>primed_ps</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>NULL</code>)<br />
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> on which the <code>MiesOperator</code> is primed. Is <code>NULL</code> if it has not been primed.
Writing to this acrive binding calls <code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
<dt><code>is_primed</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the <code>MiesOperator</code> was primed before. Is <code>FALSE</code> exactly when <code style="white-space: pre;">&#8288;$primed_ps&#8288;</code> is <code>NULL</code>. Read-only.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of this class, in the form <code style="white-space: pre;">&#8288;&lt;package&gt;::&lt;classname&gt;&#8288;</code>. Used by the <code style="white-space: pre;">&#8288;$help()&#8288;</code> method.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MiesOperator-new"><code>MiesOperator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-repr"><code>MiesOperator$repr()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-print"><code>MiesOperator$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-prime"><code>MiesOperator$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-operate"><code>MiesOperator$operate()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-help"><code>MiesOperator$help()</code></a>
</p>
</li>
<li> <p><a href="#method-MiesOperator-clone"><code>MiesOperator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MiesOperator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>MiesOperator</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$new(
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  dict_shortaccess = NULL,
  own_param_set = quote(self$param_set),
  endomorphism = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>dict_shortaccess</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Name of the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> short access function in which the operator is registered.
This is used to inform the user about how to construct a given object. Should ordinarily be one of
<code>"mut"</code>, <code>"rec"</code>, <code>"sel"</code>.<br />
The <code style="white-space: pre;">&#8288;$dict_shortaccess&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
<dt><code>endomorphism</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the private <code style="white-space: pre;">&#8288;$.operate()&#8288;</code> operation creates a <code><a href="data.table.html#topic+data.table">data.table</a></code> with the same columns as the input
(i.e. conforming to the primed <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>). If this is <code>TRUE</code> (default), then the return value of <code style="white-space: pre;">&#8288;$.operate()&#8288;</code>
is checked for this and columns are put in the correct order.<br />
The <code style="white-space: pre;">&#8288;$endomorphsim&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MiesOperator-repr"></a>



<h4>Method <code>repr()</code></h4>

<p>Create a <code><a href="base.html#topic+call">call</a></code> object representing this operator.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$repr(
  skip_defaults = TRUE,
  show_params = TRUE,
  show_constructor_args = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>skip_defaults</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to skip construction arguments that have their default value. Default <code>TRUE</code>.</p>
</dd>
<dt><code>show_params</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to show <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> values. Default <code>TRUE</code>.</p>
</dd>
<dt><code>show_constructor_args</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to show construction args that are not <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> values. Default <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>(any)<br />
Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MiesOperator-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this operator.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$print(verbose = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to show all construction arguments, even the ones at default values. Default <code>FALSE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>(any)<br />
Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MiesOperator-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>Prepare the <code>MiesOperator</code> to function on the given <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. This must be called before
<code style="white-space: pre;">&#8288;$operate()&#8288;</code>. It may be called multiple times in the lifecycle of the <code>MiesOperator</code> object, and prior primings are
forgotten when priming on a new <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. The <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> on which
the <code>MiesOperator</code> was last primed can be read from <code style="white-space: pre;">&#8288;$primed_ps&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
The <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> to which all <code>values</code> tables passed to <code style="white-space: pre;">&#8288;$operate()&#8288;</code> will need to conform to.
May only contiain <code><a href="paradox.html#topic+Domain">Domain</a></code> objects that conform to the classes listed in <code style="white-space: pre;">&#8288;$param_classes&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-MiesOperator-operate"></a>



<h4>Method <code>operate()</code></h4>

<p>Operate on the given individuals. This calls private <code style="white-space: pre;">&#8288;$.operate()&#8288;</code>, which must be overloaded by an inheriting class,
passing through all function arguments after performing some checks.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$operate(values, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>(<code>data.frame</code>)<br />
Individuals to operate on. Must pass the check of the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> given in the last <code style="white-space: pre;">&#8288;$prime()&#8288;</code> call
and may not have any missing components.</p>
</dd>
<dt><code>...</code></dt><dd><p>(any)<br />
Depending on the concrete class, passed on to <code style="white-space: pre;">&#8288;$.operate()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data.frame</code>: the result of the operation. If the input was a <code><a href="data.table.html#topic+data.table">data.table</a></code> instead of
a <code>data.frame</code>, the output is also <code><a href="data.table.html#topic+data.table">data.table</a></code>.
</p>


<hr>
<a id="method-MiesOperator-help"></a>



<h4>Method <code>help()</code></h4>

<p>Run <code><a href="utils.html#topic+help">utils::help()</a></code> for this object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$help(help_type = getOption("help_type"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>help_type</code></dt><dd><p>(<code>character(1)</code>)<br />
One of <code>"text"</code>, <code>"html"</code>, or <code>"pdf"</code>: The type of help page to open. Defaults to the <code>"help_type"</code> option.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>help_files_with_dopic</code> object, which opens the help page.
</p>


<hr>
<a id="method-MiesOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MiesOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>

<hr>
<h2 id='mlr_terminators_budget'>Terminator that Limits Total Budget Component Evaluation</h2><span id='topic+mlr_terminators_budget'></span><span id='topic+TerminatorBudget'></span>

<h3>Description</h3>

<p><code><a href="bbotk.html#topic+Terminator">Terminator</a></code> that terminates after the sum (or similar aggregate) of a given &quot;budget&quot; search space component croses a threshold.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="bbotk.html#topic+Terminator">Terminator</a></code> can be created with the short access form <code><a href="bbotk.html#topic+trm">trm()</a></code> (<code><a href="bbotk.html#topic+trm">trms()</a></code> to get a list),
or through the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <code><a href="bbotk.html#topic+mlr_terminators">mlr_terminators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred
trm("budget")
trms("budget")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("budget")
</pre></div>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>budget</code> :: <code>numeric(1)</code><br />
Total budget available, after which to stop. Not initialized and should be set to the desired value during construction.
</p>
</li>
<li> <p><code>aggregate</code> :: <code>function</code><br />
Function taking a vector of values of the budget search space component, returning a scalar value to be compared
to the <code>budget</code> configuration parameter. If this function returns a value greater or equal to <code>budget</code> the termination
criterion is matched. Calling this function with <code>NULL</code> must return the lower bound of the budget value; percentage
progress is reported as the progress from this lower bound to the value of <code>budget</code>. Initialized to <code>sum()</code>.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorBudget</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorBudget-new"><code>TerminatorBudget$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorBudget-is_terminated"><code>TerminatorBudget$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorBudget-clone"><code>TerminatorBudget$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorBudget-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>TerminatorBudget</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorBudget$new()</pre></div>


<hr>
<a id="method-TerminatorBudget-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> if when the termination criterion is matched, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorBudget$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p><code><a href="bbotk.html#topic+Archive">Archive</a></code>
Archive to check.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether to terminate.
</p>


<hr>
<a id="method-TerminatorBudget-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorBudget$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
# Evaluate until sum of budget component of evaluated configs is &gt;= 100
trm("budget", budget = 100)

# Evaluate until sum of two to the power of budget component is &gt;= 100
trm("budget", budget = 1024, aggregate = function(x) sum(2 ^ x))
</code></pre>

<hr>
<h2 id='mlr_terminators_genperfreached'>Terminator That Stops When a Generation-Wise Aggregated Value Reaches a Target</h2><span id='topic+mlr_terminators_genperfreached'></span><span id='topic+TerminatorGenerationPerfReached'></span>

<h3>Description</h3>

<p><code><a href="bbotk.html#topic+Terminator">Terminator</a></code> that terminates when a value, aggregated over generations, reaches a target value.
</p>
<p>The user-supplied <code>fitness_aggregator</code> function is called whenever the archive of evaluated configurations contains a new generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point
(<code>include_previous_generations = FALSE</code>) or at any point (<code>include_previous_generations = TRUE</code>).
Its result is saved inside the <code style="white-space: pre;">&#8288;$data_extra&#8288;</code> field of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> object.
Termination is then signaled when the aggregated value meets or exceeds <code>level</code>.
</p>
<p>The <code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code> function is used, see the documentation there for the functioning of <code>fitness_aggregator</code>.
The <code>fitness_aggregator</code> functions used for termination must return a scalar value or <code>NULL</code>, if a generation should be ignored.
The value returned by <code>fitness_aggregator</code> should be increasing for better performance, even if the underlying objective is being minimized.
</p>


<h3>Multi-Fidelity Optimization</h3>

<p>Multi-fidelity optimization can introduce a few edge-cases because the individuals inside the generation(s) being aggregated may have
been evaluated with different fidelity values, which can give biased results.
</p>
<p>When <code><a href="#topic+OptimizerMies">OptimizerMies</a></code> is constructed with <code>multi_fidelity</code> set to <code>TRUE</code>, it typically evaluates some configurations multiple times,
at first with a lower fidelity, followed by an evaluation at &quot;full&quot; fidelity.
<code>fitness_aggregator</code> will only be called for generations containing entirely full-fidelity-evaluations will be aggregated.
</p>
<p>This is achieved by caching aggregated fitness values in the <code style="white-space: pre;">&#8288;$data_extra&#8288;</code> field of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> and only ever calling
<code>fitness_aggregator</code> for a generation that does not have a cached value. Since <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> will
count low-fidelity evaluations as part of the &quot;previous&quot; generation, <code>fitness_aggregator</code> will not see them.
Note, however that if <code>fitness_aggregator</code> returns <code>NULL</code>, it will be called again should a second evaluation occur in the same generation,
since <code>NULL</code> is not cached and instead treated as absent.
</p>
<p>It is possible for <code>fitness_aggregator</code> to see fitness values that were evaluated with different fidelities when using <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>,
and
</p>

<ol>
<li> <p><code>fidelity_monotonic</code> is set to <code>TRUE</code> and fidelity decreases (unlikely setup), or
</p>
</li>
<li><p> if <code>fidelity_current_gen_only</code> is set to <code>FALSE</code> (advanced usage), or
</p>
</li>
<li><p> The value returned by the <code>fidelity</code> configuration parameter (not <code>fidelity_offspring</code>) changes over the course of optimization and
<code>include_previous_generations</code> of <code>TerminatorGenerationStagnation</code> is set to <code>TRUE</code>.
</p>
</li></ol>

<p>(1) and (2) only need consideration in advanced scenarios, but (3) may be a common, e.g. when doing multi-fidelity optimization
and stopping on reaching an overall dominated hypervolume target. In this case, it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code>
and to remove all individuals evaluated with a different than the current fidelity.
</p>
<p>When using a custom-written optimization loop, case (1) relates to <code>fidelity_monotonic</code> argument of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> and <code><a href="#topic+mies_init_population">mies_init_population()</a></code>,
and case (2) relates to the <code>current_gen_only</code> argument of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> and the <code>fidelity_new_individuals_only</code> argument of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>.
Case (3) relates to changing the fidelity given to <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> if that function is used, or to changing the fidelity given to <code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring()</a></code> if
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> is not used.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="bbotk.html#topic+Terminator">Terminator</a></code> can be created with the short access form <code><a href="bbotk.html#topic+trm">trm()</a></code> (<code><a href="bbotk.html#topic+trm">trms()</a></code> to get a list),
or through the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <code><a href="bbotk.html#topic+mlr_terminators">mlr_terminators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred
trm("genperfreached")
trms("genperfreached")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("genperfreached")
</pre></div>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>fitness_aggregator</code> :: <code>function</code><br />
Aggregation function, called with information about alive individuals of each generation.
This argument is passed to <code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code>, see there for more details.
The aggregated values returned by <code>fitness_aggregator</code> should be maximized, so a larger value must be returned to indicate improvement in a generation,
even if an underlying objective is being minimized. The return value must be a scalar <code>numeric(1)</code>.
</p>
</li>
<li> <p><code>include_previous_generations</code> :: <code>logical(1)</code><br />
Whether to aggregate over all individuals that were evaluated (<code>TRUE</code>), or only the individuals alive in the current generation (<code>FALSE</code>).
If multi-fidelity optimization is being performed and individuals were re-evaluated with a different fidelity, their <code>x_id</code> will be the same and only
the last fidelity-reevaluation will be given to <code>fitness_aggregator</code>. However, individuals from different generations may still have been evaluated
with different fidelity and it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code> if <code>include_previous_generations</code> is <code>TRUE</code> in a
multi-fidelity-setting. See the &quot;Multi-Fidelity Optimization&quot; section for more.
</p>
</li>
<li> <p><code>level</code> :: <code>numeric(1)</code><br />
Minimum aggregated value for which to terminate.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorGenerationPerfReached</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorGenerationPerfReached-new"><code>TerminatorGenerationPerfReached$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationPerfReached-is_terminated"><code>TerminatorGenerationPerfReached$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationPerfReached-clone"><code>TerminatorGenerationPerfReached$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorGenerationPerfReached-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>TerminatorGenerationPerfReached</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationPerfReached$new()</pre></div>


<hr>
<a id="method-TerminatorGenerationPerfReached-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> if when the termination criterion is matched, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationPerfReached$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p><code><a href="bbotk.html#topic+Archive">Archive</a></code>
Archive to check.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether to terminate.
</p>


<hr>
<a id="method-TerminatorGenerationPerfReached-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationPerfReached$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Terminate when hypervolume with nadir `c(0, 0, ...)`
# does not improve for 3 generations by at least 0.1:
tg &lt;- trm("genperfreached",
  fitness_aggregator = function(fitnesses) domhv(fitnesses),
  include_previous_generations = TRUE,
  level = 1
)

set.seed(1)
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi &lt;- OptimInstanceMultiCrit$new(objective, terminator = tg)

op &lt;- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# the observed aggregated values:
oi$archive$data_extra$TerminatorGenerationPerfReached

# ... or as calculated by mies_generation_apply
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)
#' @export
</code></pre>

<hr>
<h2 id='mlr_terminators_gens'>Terminator that Counts OptimizerMies Generations</h2><span id='topic+mlr_terminators_gens'></span><span id='topic+TerminatorGenerations'></span>

<h3>Description</h3>

<p><code><a href="bbotk.html#topic+Terminator">Terminator</a></code> that terminates after a given number of generations have passed in <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>.
</p>
<p>If <code><a href="#topic+OptimizerMies">OptimizerMies</a></code> is started on an archive that already has evaluated configurations, these evaluations count as
generation 0. If an initial, randomly sampled generation is generated by <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>, it has generation number 1.
Setting <code>generation</code> to 1 therefore terminates after the evaluation of the initial sample, <em>unless</em> no initial sample is
generated by <code><a href="#topic+OptimizerMies">OptimizerMies</a></code> and instead found in the archive. <code>generation</code> set to 0 avoids any evaluation within <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>
(but is ignored if no <code>dob</code> column is in the archive).
</p>
<p>When doing multi-fidelity optimization, and fidelity of a configuration is increased because of a step in the fidelity schedule,
or because they were sampled new and survived, then this fidelity refinement happens as part of an already started generation. This means
termination at this fidelity refinement step is avoided.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="bbotk.html#topic+Terminator">Terminator</a></code> can be created with the short access form <code><a href="bbotk.html#topic+trm">trm()</a></code> (<code><a href="bbotk.html#topic+trm">trms()</a></code> to get a list),
or through the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <code><a href="bbotk.html#topic+mlr_terminators">mlr_terminators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred
trm("gens")
trms("gens")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("gens")
</pre></div>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>generations</code> :: <code>integer(1)</code><br />
Number of generations to evaluate, after which to stop. Not initialized and should be set to the desired value during construction.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorGenerations</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorGenerations-new"><code>TerminatorGenerations$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerations-is_terminated"><code>TerminatorGenerations$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerations-clone"><code>TerminatorGenerations$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorGenerations-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>TerminatorGenerations</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerations$new()</pre></div>


<hr>
<a id="method-TerminatorGenerations-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> if when the termination criterion is matched, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerations$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p><code><a href="bbotk.html#topic+Archive">Archive</a></code>
Archive to check.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether to terminate.
</p>


<hr>
<a id="method-TerminatorGenerations-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerations$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library("bbotk")
trm("gens", generations = 10)
</code></pre>

<hr>
<h2 id='mlr_terminators_genstag'>Terminator That Stops When a Generation-Wise Aggregated Value Stagnates</h2><span id='topic+mlr_terminators_genstag'></span><span id='topic+TerminatorGenerationStagnation'></span>

<h3>Description</h3>

<p><code><a href="bbotk.html#topic+Terminator">Terminator</a></code> that terminates when a value, aggregated over generations, stagnates.
</p>
<p>The user-supplied <code>fitness_aggregator</code> function is called whenever the archive of evaluated configurations contains a new generation.
The function is supplied with the fitness values, and optionally other data, of all individuals that are alive at that point
(<code>include_previous_generations = FALSE</code>) or at any point (<code>include_previous_generations = TRUE</code>).
Its result is saved inside the <code style="white-space: pre;">&#8288;$data_extra&#8288;</code> field of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> object.
Termination is then signaled when the aggregated value has stagnated, or not improved enough, for a given number of generations.
</p>
<p>The <code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code> function is used, see the documentation there for the functioning of <code>fitness_aggregator</code>.
The <code>fitness_aggregator</code> functions used for termination must return a scalar value or <code>NULL</code>, if a generation should be ignored.
The value returned by <code>fitness_aggregator</code> should be increasing for better performance, even if the underlying objective is being minimized.
</p>
<p>Termination is triggered in generation <code>i</code> when the aggregated value, returned by <code>fitness_aggregator</code>, of generation <code>i - patience</code>
is not greater than the maximum of all later generations (<code>i - patience + 1</code> .. <code>i</code>) by at least <code>min_delta</code>.
</p>
<p>If the aggregated value for generation <code>i - patience</code> is not known, for example because fewer than <code>patience + 1</code> generations
have been evaluated so far, because <code>fitness_aggregator</code> returned <code>NULL</code>, or because previous generations were evaluated
when <code>TerminatorGenerationStagnation</code> was not used, then termination is not triggered, regardless of whether values are known
for generations <em>before</em> generation <code>i - patience</code>.
</p>


<h3>Multi-Fidelity Optimization</h3>

<p>Multi-fidelity optimization can introduce a few edge-cases, for one because the individuals inside the generation(s) being aggregated may have
been evaluated with different fidelity values, which can give biased results. Besides that, it may also be problematic that increase of
fidelity could lead to &quot;worse&quot; aggregated results (e.g. because of reduced noise making max-aggregation worse), triggering an undesired termination.
</p>


<h4>Termination from fidelity changes</h4>

<p>Higher fidelity values can sometimes lead to worse aggregated fitness values, which can trigger undesired termination.
However, in many multi-fidelity-setups, terminating before the last fidelity increase, controlled e.g. by the <code>fidelity</code>
configuration parameter of <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>, may be undesirable to begin with.
</p>
<p>If the fidelity increase follows a fixed schedule based on evaluations or generations, one solution may be to use a
<code><a href="bbotk.html#topic+mlr_terminators_combo">TerminatorCombo</a></code> together with a <code><a href="bbotk.html#topic+mlr_terminators_evals">TerminatorEvals</a></code> or <code><a href="#topic+TerminatorGenerations">TerminatorGenerations</a></code>
that prevents premature termination. Termination should happen at least <code>patience</code> generations after the last switch to the
highest fidelity if termination from biased values because of fidelity changes should be avoided.
</p>
<p>Otherwise it may be necessary to check whether the <code>budget</code> value given to <code>fitness_aggregator</code> reached the desired level,
and to prevent comparisons by letting <code>fitness_aggregator</code> return <code>NULL</code> if not.
</p>
<p>In both cases one may still have a problem with biased aggregations within an aggregated set of individuals if <code>include_previous_generations</code>
is <code>TRUE</code>.
</p>



<h4>Biases within aggregated generation(s)</h4>

<p>When <code><a href="#topic+OptimizerMies">OptimizerMies</a></code> is constructed with <code>multi_fidelity</code> set to <code>TRUE</code>, it typically evaluates some configurations multiple times,
at first with a lower fidelity, followed by an evaluation at &quot;full&quot; fidelity.
<code>fitness_aggregator</code> will only be called for generations containing entirely full-fidelity-evaluations will be aggregated.
</p>
<p>This is achieved by caching aggregated fitness values in the <code style="white-space: pre;">&#8288;$data_extra&#8288;</code> field of the <code><a href="bbotk.html#topic+Archive">Archive</a></code> and only ever calling
<code>fitness_aggregator</code> for a generation that does not have a cached value. Since <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> will
count low-fidelity evaluations as part of the &quot;previous&quot; generation, <code>fitness_aggregator</code> will not see them.
Note, however that if <code>fitness_aggregator</code> returns <code>NULL</code>, it will be called again should a second evaluation occur in the same generation,
since <code>NULL</code> is not cached and instead treated as absent.
</p>
<p>It is possible for <code>fitness_aggregator</code> to see fitness values that were evaluated with different fidelities when using <code><a href="#topic+OptimizerMies">OptimizerMies</a></code>,
and
</p>

<ol>
<li> <p><code>fidelity_monotonic</code> is set to <code>TRUE</code> and fidelity decreases (unlikely setup), or
</p>
</li>
<li><p> if <code>fidelity_current_gen_only</code> is set to <code>FALSE</code> (advanced usage), or
</p>
</li>
<li><p> The value returned by the <code>fidelity</code> configuration parameter (not <code>fidelity_offspring</code>) changes over the course of optimization and
<code>include_previous_generations</code> of <code>TerminatorGenerationStagnation</code> is set to <code>TRUE</code>.
</p>
</li></ol>

<p>(1) and (2) only need consideration in advanced scenarios, but (3) may be a common, e.g. when doing multi-fidelity optimization
and stopping on overall dominated hypervolume stagnation. In this case, it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code>
and to remove all individuals evaluated with a different than the current fidelity.
</p>
<p>When using a custom-written optimization loop, case (1) relates to <code>fidelity_monotonic</code> argument of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> and <code><a href="#topic+mies_init_population">mies_init_population()</a></code>,
and case (2) relates to the <code>current_gen_only</code> argument of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> and the <code>fidelity_new_individuals_only</code> argument of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>.
Case (3) relates to changing the fidelity given to <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> if that function is used, or to changing the fidelity given to <code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring()</a></code> if
<code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> is not used.
</p>



<h3>Dictionary</h3>

<p>This <code><a href="bbotk.html#topic+Terminator">Terminator</a></code> can be created with the short access form <code><a href="bbotk.html#topic+trm">trm()</a></code> (<code><a href="bbotk.html#topic+trm">trms()</a></code> to get a list),
or through the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <code><a href="bbotk.html#topic+mlr_terminators">mlr_terminators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred
trm("genstag")
trms("genstag")  # takes vector IDs, returns list of Terminators

# long form
mlr_terminators$get("genstag")
</pre></div>


<h3>Configuration Parameters</h3>


<ul>
<li> <p><code>fitness_aggregator</code> :: <code>function</code><br />
Aggregation function, called with information about alive individuals of each generation.
This argument is passed to <code><a href="#topic+mies_aggregate_single_generation">mies_aggregate_single_generation()</a></code>, see there for more details.
The aggregated values returned by <code>fitness_aggregator</code> should be maximized, so a larger value must be returned to indicate improvement in a generation,
even if an underlying objective is being minimized. The return value must be a scalar <code>numeric(1)</code>.
</p>
</li>
<li> <p><code>include_previous_generations</code> :: <code>logical(1)</code><br />
Whether to aggregate over all individuals that were evaluated (<code>TRUE</code>), or only the individuals alive in the current generation (<code>FALSE</code>).
If multi-fidelity optimization is being performed and individuals were re-evaluated with a different fidelity, their <code>x_id</code> will be the same and only
the last fidelity-reevaluation will be given to <code>fitness_aggregator</code>. However, individuals from different generations may still have been evaluated
with different fidelity and it may be necessary to inspect the <code>budget</code> value given to <code>fitness_aggregator</code> if <code>include_previous_generations</code> is <code>TRUE</code> in a
multi-fidelity-setting. See the &quot;Multi-Fidelity Optimization&quot; section for more.
</p>
</li>
<li> <p><code>min_delta</code> :: <code>numeric(1)</code><br />
Minimum positive change of aggregated value to count as improvement.
This value may also be negative, resulting in termination only when aggregated value <em>decreases</em> by at least the given amount.
However, depending on the survival setup, or on <code>include_previous_generations</code>, it is possible that aggregate values never decrease; in this
case, setting <code>min_delta</code> to a negative value may never trigger termination.
Initialized to 0.
</p>
</li>
<li> <p><code>patience</code> :: <code>integer(1)</code><br />
Number of generations with no improvement better than <code>min_delta</code> after which to terminate.
Initialized to 1.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Terminator">bbotk::Terminator</a></code> -&gt; <code>TerminatorGenerationStagnation</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TerminatorGenerationStagnation-new"><code>TerminatorGenerationStagnation$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationStagnation-is_terminated"><code>TerminatorGenerationStagnation$is_terminated()</code></a>
</p>
</li>
<li> <p><a href="#method-TerminatorGenerationStagnation-clone"><code>TerminatorGenerationStagnation$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="format"><a href='../../bbotk/html/Terminator.html#method-Terminator-format'><code>bbotk::Terminator$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="print"><a href='../../bbotk/html/Terminator.html#method-Terminator-print'><code>bbotk::Terminator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="remaining_time"><a href='../../bbotk/html/Terminator.html#method-Terminator-remaining_time'><code>bbotk::Terminator$remaining_time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Terminator" data-id="status"><a href='../../bbotk/html/Terminator.html#method-Terminator-status'><code>bbotk::Terminator$status()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TerminatorGenerationStagnation-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>TerminatorGenerationStagnation</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$new()</pre></div>


<hr>
<a id="method-TerminatorGenerationStagnation-is_terminated"></a>



<h4>Method <code>is_terminated()</code></h4>

<p>Is <code>TRUE</code> if when the termination criterion is matched, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$is_terminated(archive)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>archive</code></dt><dd><p><code><a href="bbotk.html#topic+Archive">Archive</a></code>
Archive to check.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>: Whether to terminate.
</p>


<hr>
<a id="method-TerminatorGenerationStagnation-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TerminatorGenerationStagnation$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
library("bbotk")
lgr::threshold("warn")

# Terminate when hypervolume with nadir `c(0, 0, ...)`
# does not improve for 3 generations by at least 0.1:
tg &lt;- trm("genstag",
  fitness_aggregator = function(fitnesses) domhv(fitnesses),
  include_previous_generations = TRUE,
  min_delta = 0.1,
  patience = 3
)

set.seed(1)
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    list(y1 = xs$x1, y2 = xs$x2)
  },
  domain = ps(x1 = p_dbl(0, 1), x2 = p_dbl(-1, 0)),
  codomain = ps(y1 = p_dbl(0, 1, tags = "maximize"),
    y2 = p_dbl(-1, 0, tags = "minimize"))
)

oi &lt;- OptimInstanceMultiCrit$new(objective, terminator = tg)

op &lt;- opt("mies",
  lambda = 4, mu = 4,
  mutator = mut("gauss", sdev = 0.1),
  recombinator = rec("xounif"),
  parent_selector = sel("random"),
  survival_selector = sel("best", scl("hypervolume"))
)

op$optimize(oi)

# the observed aggregated values:
oi$archive$data_extra$TerminatorGenerationStagnation

# ... or as calculated by mies_generation_apply
mies_generation_apply(oi$archive, function(fitnesses) {
  domhv(fitnesses)
}, include_previous_generations = TRUE)
#' @export
</code></pre>

<hr>
<h2 id='mut'>Short Access Forms for Operators</h2><span id='topic+mut'></span><span id='topic+muts'></span><span id='topic+rec'></span><span id='topic+recs'></span><span id='topic+sel'></span><span id='topic+sels'></span><span id='topic+scl'></span><span id='topic+scls'></span><span id='topic+ftr'></span><span id='topic+ftrs'></span>

<h3>Description</h3>

<p>These functions complement <a href="#topic+dict_mutators">dict_mutators</a>, <a href="#topic+dict_recombinators">dict_recombinators</a>, <a href="#topic+dict_selectors">dict_selectors</a> with functions in the spirit
of <a href="mlr3.html#topic+mlr_sugar">mlr3::mlr_sugar</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mut(.key, ...)

muts(.keys, ...)

rec(.key, ...)

recs(.key, ...)

sel(.key, ...)

sels(.key, ...)

scl(.key, ...)

scls(.key, ...)

ftr(.key, ...)

ftrs(.key, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mut_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve the object.</p>
</td></tr>
<tr><td><code id="mut_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="mut_+3A_.keys">.keys</code></td>
<td>
<p>(<code>character()</code>)<br />
Keys passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve multiple objects.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+Mutator">Mutator</a></code> for <code>mut()</code>
</p>
</li>
<li><p> list of <code><a href="#topic+Mutator">Mutator</a></code> for <code>muts()</code>
</p>
</li>
<li> <p><code><a href="#topic+Recombinator">Recombinator</a></code> for <code>rec()</code>.
</p>
</li>
<li><p> list of <code><a href="#topic+Recombinator">Recombinator</a></code> for <code>recs()</code>.
</p>
</li>
<li> <p><code><a href="#topic+Selector">Selector</a></code> for <code>sel()</code>.
</p>
</li>
<li><p> list of <code><a href="#topic+Selector">Selector</a></code> for <code>sels()</code>.
</p>
</li>
<li> <p><code><a href="#topic+Scalor">Scalor</a></code> for <code>scl()</code>.
</p>
</li>
<li><p> list of <code><a href="#topic+Scalor">Scalor</a></code> for <code>scls()</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other dictionaries: 
<code><a href="#topic+dict_filtors">dict_filtors</a></code>,
<code><a href="#topic+dict_mutators">dict_mutators</a></code>,
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code>,
<code><a href="#topic+dict_scalors">dict_scalors</a></code>,
<code><a href="#topic+dict_selectors">dict_selectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mut("gauss", sdev = 0.5)
rec("xounif")
sel("random")
scl("nondom")
</code></pre>

<hr>
<h2 id='Mutator'>Mutator Base Class</h2><span id='topic+Mutator'></span>

<h3>Description</h3>

<p>Base class representing mutation operations, inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>.
</p>
<p>Mutations get a table of individuals as input and return a table of modified individuals as output. Individuals are acted on as
individuals: every line of output corresponds to the same line of input, and presence or absence of other input lines does not
affect the result.
</p>
<p>Mutation operations are performed in ES algorithms to facilitate exploration of the search space around individuals.
</p>


<h3>Inheriting</h3>

<p><code>Mutator</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.mutate()&#8288;</code>
function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, and the arguments are passed on to private <code style="white-space: pre;">&#8288;$.mutate()&#8288;</code> after checking that
the operator is primed, and that the <code>values</code> argument conforms to the primed domain. Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> function
should also be overloaded, and optionally the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function; they should call their <code>super</code> equivalents.
</p>
<p>In many cases, it is advisable to inherit from one of the abstract subclasses, such as <code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>, or <code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>Mutator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Mutator-new"><code>Mutator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Mutator-clone"><code>Mutator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Mutator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Mutator</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mutator$new(
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Mutator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Mutator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other mutators: 
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>

<hr>
<h2 id='MutatorDiscrete'>Discrete Mutator Base Class</h2><span id='topic+MutatorDiscrete'></span>

<h3>Description</h3>

<p>Base class for mutation operations on discrete individuals, inheriting from <code><a href="#topic+Mutator">Mutator</a></code>.
</p>
<p><code>MutatorDiscrete</code> operators perform mutation on discrete (logical and factor valued) individuals. Inheriting
operators implement the private <code style="white-space: pre;">&#8288;$.mutate_discrete()&#8288;</code> function that is called once for each individual
and is given a character vector.
</p>


<h3>Inheriting</h3>

<p><code>MutatorDiscrete</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.mutate_discrete()&#8288;</code>
function. During <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, the <code style="white-space: pre;">&#8288;$.mutate_discrete()&#8288;</code> function is called once for each individual, with the parameters <code>values</code> (the
individual as a single <code>character</code> vector), and <code>levels</code> (a list of <code>character</code> containing the possible values for each element of <code>values</code>). Typically,
<code style="white-space: pre;">&#8288;$initialize()&#8288;</code> should also be overloaded.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorDiscrete</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorDiscrete-new"><code>MutatorDiscrete$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorDiscrete-clone"><code>MutatorDiscrete$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorDiscrete-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>MutatorNumeric</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorDiscrete$new(
  param_classes = c("ParamLgl", "ParamFct"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamFct"</code>.
Default is both of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorDiscrete-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorDiscrete$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>

<hr>
<h2 id='MutatorNumeric'>Numeric Mutator Base Class</h2><span id='topic+MutatorNumeric'></span>

<h3>Description</h3>

<p>Base class for mutation operations on numeric and integer valued individuals, inheriting from <code><a href="#topic+Mutator">Mutator</a></code>.
</p>
<p><code>MutatorNumeric</code> operators perform mutation on numeric (integer and real valued) individuals. Inheriting
operators implement the private <code style="white-space: pre;">&#8288;$.mutate_numeric()&#8288;</code> function that is called once for each individual
and is given a numeric vector.
</p>


<h3>Inheriting</h3>

<p><code>MutatorNumeric</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.mutate_numeric()&#8288;</code>
function. During <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, the <code style="white-space: pre;">&#8288;$.mutate_numeric()&#8288;</code> function is called once for each individual, with the parameters <code>values</code> (the
individual as a single <code>numeric</code> vector), <code>lowers</code> and <code>uppers</code> (<code>numeric</code> vectors, the lower and upper bounds for each component of <code>values</code>). Typically,
<code style="white-space: pre;">&#8288;$initialize()&#8288;</code> should also be overloaded.
</p>
<p><code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>s that perform real-valued operations, such as e.g. <code><a href="#topic+MutatorGauss">MutatorGauss</a></code>, operate on integers by widening the lower and upper bounds
of integer components by 0.5, applying their operation, and rounding resulting values to the nearest integer (while always staying inside bounds).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Mutator">miesmuschel::Mutator</a></code> -&gt; <code>MutatorNumeric</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorNumeric-new"><code>MutatorNumeric$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorNumeric-clone"><code>MutatorNumeric$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorNumeric-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>MutatorNumeric</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorNumeric$new(
  param_classes = c("ParamInt", "ParamDbl"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamInt"</code>, <code>"ParamDbl"</code>.
Default is both of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorNumeric-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorNumeric$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>

<hr>
<h2 id='OperatorCombination'>Self-Adaptive Operator Combinations</h2><span id='topic+OperatorCombination'></span><span id='topic+MutatorCombination'></span><span id='topic+dict_mutators_combine'></span><span id='topic+RecombinatorCombination'></span><span id='topic+dict_recombinators_combine'></span>

<h3>Description</h3>

<p>Combines multiple operators and makes operator-configuration parameters self-adaptive.
</p>
<p>The <code>OperatorCombination</code> operators combine operators for different subspaces of individuals by wraping other <code><a href="#topic+MiesOperator">MiesOperator</a></code>s given during construction.
Different <code><a href="#topic+MiesOperator">MiesOperator</a></code>s are assigned to different components or sets of components and operate on them independently of the rest of the components
or the other operators. An operator can be assigned to a single component by giving it in <code>operators</code> with the name of the component, or to multiple components by
giving it in <code>operators</code> with the name of a <em>group</em>. Groups are created by the <code>groups</code> argument, but several default groups that catch components by type
exist.
</p>


<h3>Details</h3>

<p>Operators can be made <em>self-adaptive</em> by coupling their configuration parameter values to values in individuals. This is done by giving functions in <code>adaptions</code>; these
functions are executed for each individual before an operator is applied, and the result given to a named operator configuration parameter.
</p>
<p><code>OperatorCombination</code> is the base class from which <code>MutatorCombination</code> and <code>RecombinatorCombination</code> inherit. The latter two are to be used for <code><a href="#topic+Mutator">Mutator</a></code> and
<code><a href="#topic+Recombinator">Recombinator</a></code> objects, respectively.
</p>
<p>Besides groups created with the <code>groups</code> construction argument, there are special groups that all unnamed operators fall into based on their <code><a href="paradox.html#topic+Domain">Domain</a></code>
class: <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>, and <code>"ParamLgl"</code>. A component of an individual that is not named directly in <code>operators</code> or made part of a group
in <code>groups</code> is automatically in one of these special groups. There is furthermore a special catch-all group <code>"ParamAny"</code>, which catches all components that are
are not operated directly, not in a group, and not in another special group that is itself named directly or in a group. I.e., all components that would otherwise
have no assigned operation.
</p>
<p><code>RecombinatorCombination</code> can only combine operators where <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> can be combined. This is
currently supported either when <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> for each operator are the same (but <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> may be unequal <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> in
eacho of them); or when <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> is equal to <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> for each operator and the set of all <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> that occur contains <code>1</code> and one more integer.
<code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> for the resulting <code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code> operator will be set the maximum of occuring <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code>,
respectively.
</p>


<h3>Supported Operand Types</h3>

<p>Supported <code><a href="paradox.html#topic+Domain">Domain</a></code> classes are calculated based on the supported classes of the wrapped operators.
They are frequently just the set union of supported classes, unless inference can be drawn from type-specific groups that an operator is assigned to.
If e.g. an operator that supports <code><a href="paradox.html#topic+Domain">p_dbl</a></code> and <code><a href="paradox.html#topic+Domain">p_int</a></code> is assigned to group <code>"ParamInt"</code>, and
an operator that supports <code><a href="paradox.html#topic+Domain">p_lgl</a></code> is assigned to component <code>"a"</code>, then the result will support <code><a href="paradox.html#topic+Domain">p_lgl</a></code> and
<code><a href="paradox.html#topic+Domain">p_int</a></code> only.
</p>


<h3>Configuration Parameters</h3>

<p>The <code>OperatorCombination</code> has the configuration parameters of all encapsulated <code><a href="#topic+MiesOperator">MiesOperator</a></code>s, minus the configuration parameters that are named in the <code>adaptions</code>.
Configuration parameter names are prefixed with the name of the <code><a href="#topic+MiesOperator">MiesOperator</a></code> in the <code>operators</code> list.
</p>


<h3>Dictionary</h3>

<p>This <code><a href="#topic+Mutator">Mutator</a></code> can be created with the short access form <code><a href="#topic+mut">mut()</a></code>
(<code><a href="#topic+muts">muts()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_mutators">dict_mutators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
mut("combine", &lt;operators&gt;, ...)
muts("combine", &lt;operators&gt;, ...)  # takes vector IDs, returns list of Mutators

# long form:
dict_mutators$get("combine", &lt;operators&gt;, ...)
</pre></div>
<p>This <code><a href="#topic+Recombinator">Recombinator</a></code> can be created with the short access form <code><a href="#topic+rec">rec()</a></code>
(<code><a href="#topic+recs">recs()</a></code> to get a list), or through the the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
<code><a href="#topic+dict_recombinators">dict_recombinators</a></code> in the following way:
</p>
<div class="sourceCode"><pre># preferred:
rec("combine", &lt;operators&gt;, ...)
recs("combine", &lt;operators&gt;, ...)  # takes vector IDs, returns list of Recombinators

# long form:
dict_recombinators$get("combine", &lt;operators&gt;, ...)
</pre></div>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>OperatorCombination</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>operators</code></dt><dd><p>(named <code>list</code> of <code><a href="#topic+MiesOperator">MiesOperator</a></code>)<br />
List of operators to apply to components of individuals, as set during construction. Read-only.</p>
</dd>
<dt><code>groups</code></dt><dd><p>(named <code>list</code> of <code>character</code>)<br />
List of groups that operators can act on, as set during construction. Read-only.</p>
</dd>
<dt><code>adaptions</code></dt><dd><p>(named <code>list</code> of <code>function</code>)<br />
List of functions used for self-adaption of operators, as set during construction. Read-only.</p>
</dd>
<dt><code>binary_fct_as_logical</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to treat binary <code><a href="paradox.html#topic+Domain">p_fct</a></code> components of <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s as <code><a href="paradox.html#topic+Domain">p_lgl</a></code> with respect
to the special groups <code>"ParamLgl"</code> and <code>"ParamFct"</code>, as set during construction. Read-only.</p>
</dd>
<dt><code>on_type_not_present</code></dt><dd><p>(<code>character(1)</code>)<br />
Action to perform during <code style="white-space: pre;">&#8288;$prime()&#8288;</code> when an operator is assigned to a type special group but there is no component available that falls in this group.
See the construction argument. Can be changed during the object's lifetime.</p>
</dd>
<dt><code>on_name_not_present</code></dt><dd><p>(<code>character(1)</code>)<br />
Action to perform during <code style="white-space: pre;">&#8288;$prime()&#8288;</code> when an operator is assigned to a specifically named component, but the component is not present.
See the construction argument. Can be changed during the object's lifetime.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OperatorCombination-new"><code>OperatorCombination$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OperatorCombination-prime"><code>OperatorCombination$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-OperatorCombination-clone"><code>OperatorCombination$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OperatorCombination-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>OperatorCombination</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OperatorCombination$new(
  operators,
  groups = list(),
  adaptions = list(),
  binary_fct_as_logical = FALSE,
  on_type_not_present = "warn",
  on_name_not_present = "stop",
  granularity = 1,
  dict_entry = NULL,
  dict_shortaccess = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>operators</code></dt><dd><p>(named <code>list</code> of <code><a href="#topic+MiesOperator">MiesOperator</a></code>)<br />
List of operators to apply to components of individuals. Names are either names of individual components, or group names which are either as defined
through <code>groups</code> or special groups. Individual components can only be member of either a (non-special) group or named in <code>operators</code>, so a name
that occurs in <code>operators</code> may not be a member of a group as defined in <code>groups</code>.<br />
The <code style="white-space: pre;">&#8288;$operators&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>groups</code></dt><dd><p>(named <code>list</code> of <code>character</code>)<br />
List of groups that operators can act on. Names of this list define new groups. The content of each list element contains the names of
components or special groups (a <code><a href="paradox.html#topic+Domain">Domain</a></code> subclass name or <code>"ParamAny"</code>) to subsume under the group.
Individual components can only be member of either a (non-special) group or named in <code>operators</code>, so a name
that occurs in <code>operators</code> may not be a member of a group as defined in <code>groups</code>. The default is the empty list.<br />
The <code style="white-space: pre;">&#8288;$groups&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>adaptions</code></dt><dd><p>(named <code>list</code> of <code>function</code>)<br />
List of functions used for self-adaption of operators. The names of the list must be names of configuration parameters of wrapped operators, prefixed
with the corresponding name in the <code>operators</code> list. This is the same name as the configuration parameter would otherwise have if exposed by the
<code>OperatorCombination</code> object. The values in the list must be functions that receive a single input, the individual or individuals being operated on,
as a <code><a href="data.table.html#topic+data.table">data.table</a></code>. It must return a value that is then assigned to the configuration parameter of the operator to which it pertains.
Note that <code><a href="#topic+MutatorCombination">MutatorCombination</a></code> adaption functions are always called with a <code><a href="data.table.html#topic+data.table">data.table</a></code> containing a single row, while
<code><a href="#topic+RecombinatorCombination">RecombinatorCombination</a></code> adaption functions are called with <code><a href="data.table.html#topic+data.table">data.table</a></code>s with multiple rows according to <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code>.
In both cases, the return value must be a scalar. The default is the empty list.<br />
The <code style="white-space: pre;">&#8288;$adaption&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>binary_fct_as_logical</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to treat binary <code><a href="paradox.html#topic+Domain">p_fct</a></code> components of <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s as <code><a href="paradox.html#topic+Domain">p_lgl</a></code> with respect
to the special groups <code>"ParamLgl"</code> and <code>"ParamFct"</code>. This does <em>not</em> perform any conversion, so a <code><a href="#topic+MiesOperator">MiesOperator</a></code> assigned to the <code>"ParamLgl"</code> special
group when <code>binary_fct_as_logical</code> is <code>TRUE</code> and there are binary <code><a href="paradox.html#topic+Domain">p_fct</a></code>s present will receive
a factorial value and must also support <code><a href="paradox.html#topic+Domain">p_fct</a></code> in this case. This is checked during <code style="white-space: pre;">&#8288;$prime()&#8288;</code>, but not during construction.
Default is <code>FALSE</code>.<br />
The <code style="white-space: pre;">&#8288;$binary_fct_as_logical&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>on_type_not_present</code></dt><dd><p>(<code>character(1)</code>)<br />
Action to perform during <code style="white-space: pre;">&#8288;$prime()&#8288;</code> when an operator is assigned to a type special group but there is no component available that falls in this group, either
because no components of the respective type are present, or because all these components are also directly named in <code>operators</code> or in <code>groups</code>.
One of <code>"quiet"</code> (do nothing), <code>"warn"</code> (give warning, default), or <code>"stop"</code> (generate an error).<br />
The writable <code style="white-space: pre;">&#8288;$on_type_not_present&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>on_name_not_present</code></dt><dd><p>(<code>character(1)</code>)<br />
Action to perform during <code style="white-space: pre;">&#8288;$prime()&#8288;</code> when an operator is assigned to a specifically named component, but the component is not present.
One of <code>"quiet"</code> (do nothing), <code>"warn"</code> (give warning), or <code>"stop"</code> (generate an error, default).<br />
The writable <code style="white-space: pre;">&#8288;$on_name_not_present&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>granularity</code></dt><dd><p>(<code>integer(1)</code>)<br />
At what granularity to query <code>adaptions</code> for sets of individuals. Functions in <code>adaptions</code> are always called once per <code>granularity</code> individuals
in input <code>values</code>, and the function argument in these calls will then have <code>granularity</code> number of rows. This is used internally, it is set to
1 for <code>MutatorCombination</code>, and to <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> for <code>RecombinatorCombination</code>.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>dict_shortaccess</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Name of the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> short access function in which the operator is registered.
This is used to inform the user about how to construct a given object. Should ordinarily be one of
<code>"mut"</code>, <code>"rec"</code>, <code>"sel"</code>.<br />
The <code style="white-space: pre;">&#8288;$dict_shortaccess&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OperatorCombination-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operators
given to <code>operators</code> during construction. Priming of wrapped operators happens according
to component assignments to wrapped operators.
</p>


<h5>Usage</h5>

<div class="r"><pre>OperatorCombination$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-OperatorCombination-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OperatorCombination$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+OperatorCombination">miesmuschel::OperatorCombination</a></code> -&gt; <code>MutatorCombination</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MutatorCombination-new"><code>MutatorCombination$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MutatorCombination-clone"><code>MutatorCombination$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="OperatorCombination" data-id="prime"><a href='../../miesmuschel/html/OperatorCombination.html#method-OperatorCombination-prime'><code>miesmuschel::OperatorCombination$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MutatorCombination-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>MutatorCombination</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorCombination$new(
  operators = list(),
  groups = list(),
  adaptions = list(),
  binary_fct_as_logical = FALSE,
  on_type_not_present = "warn",
  on_name_not_present = "stop"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>operators</code></dt><dd><p>see above.</p>
</dd>
<dt><code>groups</code></dt><dd><p>see above.</p>
</dd>
<dt><code>adaptions</code></dt><dd><p>see above.</p>
</dd>
<dt><code>binary_fct_as_logical</code></dt><dd><p>see above.</p>
</dd>
<dt><code>on_type_not_present</code></dt><dd><p>see above.</p>
</dd>
<dt><code>on_name_not_present</code></dt><dd><p>see above.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MutatorCombination-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MutatorCombination$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+OperatorCombination">miesmuschel::OperatorCombination</a></code> -&gt; <code>RecombinatorCombination</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.</p>
</dd>
<dt><code>n_indivs_out</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals produced for each group of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> individuals.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorCombination-new"><code>RecombinatorCombination$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorCombination-clone"><code>RecombinatorCombination$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="OperatorCombination" data-id="prime"><a href='../../miesmuschel/html/OperatorCombination.html#method-OperatorCombination-prime'><code>miesmuschel::OperatorCombination$prime()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorCombination-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>RecombinatorCombination</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCombination$new(
  operators = list(),
  groups = list(),
  adaptions = list(),
  binary_fct_as_logical = FALSE,
  on_type_not_present = "warn",
  on_name_not_present = "stop"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>operators</code></dt><dd><p>see above.</p>
</dd>
<dt><code>groups</code></dt><dd><p>see above.</p>
</dd>
<dt><code>adaptions</code></dt><dd><p>see above.</p>
</dd>
<dt><code>binary_fct_as_logical</code></dt><dd><p>see above.</p>
</dd>
<dt><code>on_type_not_present</code></dt><dd><p>see above.</p>
</dd>
<dt><code>on_name_not_present</code></dt><dd><p>see above.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorCombination-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorCombination$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other mutators: 
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_erase">dict_mutators_erase</a></code>,
<code><a href="#topic+dict_mutators_gauss">dict_mutators_gauss</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_null">dict_mutators_null</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>,
<code><a href="#topic+dict_mutators_unif">dict_mutators_unif</a></code>
</p>
<p>Other mutator wrappers: 
<code><a href="#topic+dict_mutators_cmpmaybe">dict_mutators_cmpmaybe</a></code>,
<code><a href="#topic+dict_mutators_maybe">dict_mutators_maybe</a></code>,
<code><a href="#topic+dict_mutators_proxy">dict_mutators_proxy</a></code>,
<code><a href="#topic+dict_mutators_sequential">dict_mutators_sequential</a></code>
</p>
<p>Other recombinators: 
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>
<p>Other recombinator wrappers: 
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data = data.frame(x = 0, y = 0, a = TRUE, b = "a",
  stringsAsFactors = FALSE)  # necessary for R &lt;= 3.6
p = ps(x = p_dbl(-1, 1), y = p_dbl(-1, 1), a = p_lgl(), b = p_fct(c("a", "b")))

# Demo operators:
m0 = mut("null")  # no mutation
msmall = mut("gauss", sdev = 0.1)  # mutates to small value around 0
mbig = mut("gauss", sdev = 100)  # likely mutates to +1 or -1
mflip = mut("unif", can_mutate_to_same = FALSE)  # flips TRUE/"a" to FALSE/"b"

# original:
data

# operators by name
op = mut("combine", operators = list(x = msmall, y = mbig, a = m0, b = mflip))
op$prime(p)
op$operate(data)

# operators by type
op = mut("combine",
  operators = list(ParamDbl = msmall, ParamLgl = m0, ParamFct = mflip)
)
op$prime(p)
op$operate(data)

# the binary ParamFct 'b' counts as 'ParamLgl' when
# 'binary_fct_as_logical' is set to 'TRUE'.
op = mut("combine",
  operators = list(ParamDbl = msmall, ParamLgl = m0),
  binary_fct_as_logical = TRUE
)
op$prime(p)
op$operate(data)

# operators by type; groups can be mixed types
op = mut("combine",
  operators = list(group1 = m0, group2 = msmall, group3 = mflip),
  groups = list(group1 = c("a", "x"), group2 = "y", group3 = "b")
)
op$prime(p)
op$operate(data)

# Special type-groups can be used inside groups.
op = mut("combine",
  operators = list(group1 = m0, b = mflip),
  groups = list(group1 = c("ParamDbl", "a"))
)
op$prime(p)
op$operate(data)

# Type-groups only capture all parameters that were not caught by name.
# The special 'ParamAny' group captures all that is left.
op = mut("combine",
  operators = list(ParamAny = m0, ParamDbl = msmall, x = mbig)
)
op$prime(p)
op$operate(data)

# Configuration parameters are named by names in the 'operators' list.
op$param_set

###
# Self-adaption:
# In this example, the 'ParamDbl''s operation is changed depending on the
# value of 'b'.
op = mut("combine",
  operators = list(ParamAny = m0, ParamLgl = mflip, ParamDbl = msmall),
  adaptions = list(ParamDbl.sdev = function(x) if (x$a) 100 else 0.1)
)
op$prime(p)

data2 = data[c(1, 1, 1, 1), ]
data2$a = c(TRUE, TRUE, FALSE, FALSE)

data2
# Note the value of x$a gets used line-wise, and that it is used *before*
# being flipped here. So the first two lines get large mutations, even though
# they have 'a' 'FALSE' after the operation.
op$operate(data2)
</code></pre>

<hr>
<h2 id='OptimInstanceMultiCrit'>OptimInstanceMultiCrit Class</h2><span id='topic+OptimInstanceMultiCrit'></span>

<h3>Description</h3>

<p><code>bbotk</code>'s <code>OptimInstanceMultiCrit</code> class.
Re-exported since <code>bbotk</code> will change the name.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a></code> -&gt; <code>OptimInstanceMultiCrit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimInstanceMultiCrit-clone"><code>OptimInstanceMultiCrit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatchMultiCrit" data-id="assign_result"><a href='../../bbotk/html/OptimInstanceBatchMultiCrit.html#method-OptimInstanceBatchMultiCrit-assign_result'><code>bbotk::OptimInstanceBatchMultiCrit$assign_result()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatchMultiCrit" data-id="initialize"><a href='../../bbotk/html/OptimInstanceBatchMultiCrit.html#method-OptimInstanceBatchMultiCrit-initialize'><code>bbotk::OptimInstanceBatchMultiCrit$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimInstanceMultiCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceMultiCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='OptimInstanceSingleCrit'>OptimInstanceSingleCrit Class</h2><span id='topic+OptimInstanceSingleCrit'></span>

<h3>Description</h3>

<p><code>bbotk</code>'s <code>OptimInstanceSingleCrit</code> class.
Re-exported since <code>bbotk</code> will change the name.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a></code> -&gt; <code>OptimInstanceSingleCrit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimInstanceSingleCrit-clone"><code>OptimInstanceSingleCrit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatchSingleCrit" data-id="assign_result"><a href='../../bbotk/html/OptimInstanceBatchSingleCrit.html#method-OptimInstanceBatchSingleCrit-assign_result'><code>bbotk::OptimInstanceBatchSingleCrit$assign_result()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatchSingleCrit" data-id="initialize"><a href='../../bbotk/html/OptimInstanceBatchSingleCrit.html#method-OptimInstanceBatchSingleCrit-initialize'><code>bbotk::OptimInstanceBatchSingleCrit$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimInstanceSingleCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimInstanceSingleCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Optimizer'>Optimizer Class</h2><span id='topic+Optimizer'></span>

<h3>Description</h3>

<p><code>bbotk</code>'s <code>Optimizer</code> class.
Re-exported since <code>bbotk</code> will change the name.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code><a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a></code> -&gt; <code>Optimizer</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Optimizer-clone"><code>Optimizer$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="initialize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-initialize'><code>bbotk::Optimizer$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimizerBatch" data-id="optimize"><a href='../../bbotk/html/OptimizerBatch.html#method-OptimizerBatch-optimize'><code>bbotk::OptimizerBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Optimizer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Optimizer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='OptimizerMies'>Mixed Integer Evolution Strategies Optimizer</h2><span id='topic+OptimizerMies'></span><span id='topic+TunerMies'></span>

<h3>Description</h3>

<p>Perform optimization using evolution strategies. <code>OptimizerMies</code> and <code>TunerMies</code> implement a standard ES optimization
algorithm, performing initialization first, followed by a loop of performance evaluation, survival selection, parent selection, mutation, and
recombination to generate new individuals to be evaluated. Currently, two different survival modes (&quot;comma&quot; and &quot;plus&quot;) are supported.
Multi-fidelity optimization, similar to the &quot;rolling-tide&quot; algorithm described in Fieldsend (2014), is supported.
The modular design and reliance on <code><a href="#topic+MiesOperator">MiesOperator</a></code> objects to perform central parts of the optimization algorithm makes this
<code>Optimizer</code> highly flexible and configurable. In combination with <code><a href="#topic+OperatorCombination">OperatorCombination</a></code> mutators and recombinators, an algorithm
as presented in Li (2013) can easily be implemented.
</p>
<p><code>OptimizerMies</code> implements a standard evolution strategies loop:
</p>

<ol>
<li><p> Prime operators, using <code>mies_prime_operators()</code>
</p>
</li>
<li><p> Initialize and evaluate population, using <code>mies_init_population()</code>
</p>
</li>
<li><p> Generate offspring by selecting parents, recombining and mutating them, using <code>mies_generate_offspring()</code>
</p>
</li>
<li><p> Evaluate performance, using <code>mies_evaluate_offspring()</code>
</p>
</li>
<li><p> Select survivors, using either <code>mies_survival_plus()</code> or <code>mies_survival_comma()</code>, depending on the <code>survival_strategy</code> configuration parameter
</p>
</li>
<li><p> Optionally, evaluate survivors with higher fidelity if the multi-fidelity functionality is being used
</p>
</li>
<li><p> Jump to 3.
</p>
</li></ol>



<h3>Terminating</h3>

<p>As with all optimizers, <code><a href="bbotk.html#topic+Terminator">Terminator</a></code>s are used to end optimization after a specific number of evaluations were performed,
time elapsed, or other conditions are satisfied. Of particular interest is <code><a href="#topic+TerminatorGenerations">TerminatorGenerations</a></code>, which terminates after a number
of generations were evaluated in <code>OptimizerMies</code>. The initial population counts as generation 1, its offspring as generation 2 etc.;
fidelity refinements (step 6. in the algorithm description above) are always included in their generation, <code><a href="#topic+TerminatorGenerations">TerminatorGenerations</a></code>
avoids terminating right before they are evaluated. Other terminators may, however, end the optimization process at any time.
</p>


<h3>Multi-Fidelity</h3>

<p><code>miesmuschel</code> provides a simple multi-fidelity optimization mechanism that allows both the refinement of fidelity as the optimization progresses,
as well as fidelity refinement within each generation. When <code>multi_fidelity</code> is <code>TRUE</code>, then one search space component of the
<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> must have the <code>"budget"</code> tag, which is then optimized as the &quot;budget&quot; component. This means that the value of this component is
determined by the <code>fidelity</code>/<code>fidelity_offspring</code> parameters, which are functions that get called whenever individuals get evaluated.
The <code>fidelity</code> function is evaluated before step 2 and before every occurrence of step 6 in the algorithm, it returns the value of the budget search space component that all individuals
that survive the current generation should be evaluated with. <code>fidelity_offspring</code> is called before step 4 and determines the fidelity that newly
sampled offspring individuals should be evaluated with; it may be desirable to set this to a lower value than <code>fidelity</code> to save budget when
preliminarily evaluating newly sampled individuals that may or may not perform well compared to already sampled individuals.
Individuals that survive the generation and are not removed in step 5 will be re-evaluated with the <code>fidelity</code>-value in step 6 before the next loop
iteration.
</p>
<p><code>fidelity</code> and <code>fidelity_offspring</code> must have arguments <code>inst</code>, <code>budget_id</code>, <code>last_fidelity</code> and <code>last_fidelity_offspring</code>. <code>inst</code> is the
<code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> bein optimized, the functions can use it to determine the progress of the optimization, e.g. query
the current generation with <code><a href="#topic+mies_generation">mies_generation</a></code>. <code>budget_id</code> identifies the search space component being used as budget parameter. <code>last_fidelity</code>
and <code>last_fidelity_offspring</code> contain the last values given by <code>fidelity</code> / <code>fidelity_offspring</code>. Should the offspring-fidelity (as returned
by <code>fidelity_offspring</code> always be the same as the parent generation fidelity (as returned by <code>fidelity</code>), for example, then <code>fidelity_offspring</code>
can be set to a function that just returns <code>last_fidelity</code>; this is actually the behaviour that <code>fidelity_offspring</code> is initialized with.
</p>
<p><code>OptimizerMies</code> avoids re-evaluating individuals if the fidelity parameter does not change. This means that setting <code>fidelity</code> and <code>fidelity_offspring</code>
to the same value avoids re-evaluating individuals in step 6. When <code>fidelity_monotonic</code> is <code>TRUE</code>, re-evaluation is also avoided should the
desired fidelity parameter value decrease. When <code>fidelity_current_gen_only</code> is <code>TRUE</code>, then step 6 only re-evaluates individuals that were
created in the current generation (in the previous step 4) and sets the fidelity for individuals that are created in step 6, but it does not
re-evaluate individuals that survived from earlier generations or were already in the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> when
optimization started; it is recommended to leave this value at <code>TRUE</code> which it is initialized with.
</p>


<h3>Additional Components</h3>

<p>The search space over which the optimization is performed is fundamentally tied to the <code><a href="bbotk.html#topic+Objective">Objective</a></code>, and therefore
to the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> given to <code>OptimizerMies$optimize()</code>. However, some advanced Evolution Strategy based
algorithms may need to make use of additional search space components that are independent of the particular objective. An example is
self-adaption as implemented in <code><a href="#topic+OperatorCombination">OperatorCombination</a></code>, where one or several components can be used to adjust operator behaviour.
These additional components are supplied to the optimizer through the <code>additional_component_sampler</code> configuration parameter, which takes
a <code><a href="paradox.html#topic+Sampler">Sampler</a></code> object. This object both has an associated <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> which represents the
additional components that are present, and it provides a method for generating the initial values of these components. The search space
that is seen by the <code><a href="#topic+MiesOperator">MiesOperator</a></code>s is then the union of the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, and the
<code><a href="paradox.html#topic+Sampler">Sampler</a></code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.
</p>


<h3>Configuration Parameters</h3>

<p><code>OptimizerMies</code> has the configuration parameters of the <code>mutator</code>, <code>recombinator</code>, <code>parent_selector</code>, <code>survival_selector</code>, <code>init_selector</code>, and, if given,
<code>elite_selector</code> operator given during construction, and prefixed according to the name of the argument (<code>mutator</code>'s configuration parameters
are prefixed <code>"mutator."</code> etc.). When using the construction arguments' default values, they are all &quot;proxy&quot; operators: <code><a href="#topic+MutatorProxy">MutatorProxy</a></code>,
<code><a href="#topic+RecombinatorProxy">RecombinatorProxy</a></code> and <code><a href="#topic+SelectorProxy">SelectorProxy</a></code>. This means that the respective configuration parameters become <code>mutator.operation</code>, <code>recombinator.operation</code> etc.,
so the operators themselves can be set via configuration parameters in this case.
</p>
<p>Further configuration parameters are:
</p>

<ul>
<li> <p><code>lambda</code> :: <code>integer(1)</code><br />
Offspring size: Number of individuals that are created and evaluated anew for each generation. This is equivalent to the
<code>lambda</code> parameter of <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, see there for more information. Must be set by the user.
</p>
</li>
<li> <p><code>mu</code> :: <code>integer(1)</code><br />
Population size: Number of individuals that are sampled in the beginning, and which are selected with each survival step.
This is equivalent to the <code>mu</code> parameter of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>, see there for more information. Must be set by the user.
</p>
</li>
<li> <p><code>survival_strategy</code> :: <code>character(1)</code><br />
May be <code>"plus"</code>, or, if the <code>elite_selector</code> construction argument is not <code>NULL</code>, <code>"comma"</code>: Choose whether <code><a href="#topic+mies_survival_plus">mies_survival_plus()</a></code>
or <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code> is used for survival selection. Initialized to <code>"plus"</code>.
</p>
</li>
<li> <p><code>n_elite</code> :: <code>integer(1)</code><br />
Only if the <code>elite_selector</code> construction argument is not <code>NULL</code>, and only valid when <code>survival_strategy</code> is <code>"comma"</code>:
Number of elites, i.e. individuals from the parent generation, to keep during &quot;Comma&quot; survival.
This is equivalent to the <code>n_elite</code> parameter of <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code>, see there for more information.
</p>
</li>
<li> <p><code>initializer</code> :: <code>function</code><br />
Function that generates the initial population as a <code><a href="paradox.html#topic+Design">Design</a></code> object,
with arguments <code>param_set</code> and <code>n</code>, functioning like <code><a href="paradox.html#topic+generate_design_random">paradox::generate_design_random</a></code> or <code><a href="paradox.html#topic+generate_design_lhs">paradox::generate_design_lhs</a></code>.
This is equivalent to the <code>initializer</code> parameter of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>, see there for more information. Initialized to
<code><a href="paradox.html#topic+generate_design_random">generate_design_random()</a></code>.
</p>
</li>
<li> <p><code>additional_component_sampler</code> :: <code><a href="paradox.html#topic+Sampler">Sampler</a></code> | <code>NULL</code><br />
Additional components that may be part of individuals as seen by mutation, recombination, and selection <code><a href="#topic+MiesOperator">MiesOperator</a></code>s, but
that are not part of the search space of the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> being optimized.
This is equivalent to the <code>additional_component_sampler</code> parameter of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>, see there for more information.
Initialized to <code>NULL</code> (no additional components).
</p>
</li>
<li> <p><code>fidelity</code> :: <code>function</code><br />
Only if the <code>multi_fidelity</code> construction argument is <code>TRUE</code>:
Function that determines the value of the &quot;budget&quot; component of surviving individuals being evaluated when doing multi-fidelity optimization.
It must have arguments named <code>inst</code>, <code>budget_id</code>, <code>last_fidelity</code> and <code>last_fidelity_offspring</code>, see the &quot;Multi-Fidelity&quot;-section
for more details. Its return value is given to <code><a href="#topic+mies_init_population">mies_init_population()</a></code> and <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code>.
When this configuration parameter is present (i.e. <code>multi_fidelity</code> is <code>TRUE</code>), then it is initialized to a <code>function</code> returning the value 1.
</p>
</li>
<li> <p><code>fidelity_offspring</code> :: <code>function</code><br />
Only if the <code>multi_fidelity</code> construction argument is <code>TRUE</code>:
Function that determines the value of the &quot;budget&quot; component of newly sampled offspring individuals being evaluated when doing multi-fidelity optimization.
It must have arguments named <code>inst</code>, <code>budget_id</code>, <code>last_fidelity</code> and <code>last_fidelity_offspring</code>, see the &quot;Multi-Fidelity&quot;-section
for more details. Its return value is given to <code><a href="#topic+mies_evaluate_offspring">mies_evaluate_offspring()</a></code>.
When this configuration parameter is present (i.e. <code>multi_fidelity</code> is <code>TRUE</code>), then it is initialized to a <code>function</code> returning the value of <code>last_fidelity</code>,
i.e. the value returned by the last call to the <code>fidelity</code> configuration parameter. This is the recommended value when fidelity should not change within
a generation, since this means that survivor selection is performed with individuals that were evaluated with the same fidelity
(at least if <code>fidelity_current_gen_only</code> is also set to <code>FALSE</code>) .
</p>
</li>
<li> <p><code>fidelity_current_gen_only</code> :: <code>logical(1)</code><br />
Only if the <code>multi_fidelity</code> construction argument is <code>TRUE</code>:
When doing fidelity refinement in <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code>, whether to refine all individuals with different budget component,
or only individuals created in the current generation.
This is equivalent to the <code>current_gen_only</code> parameter of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code>, see there for more information.<br />
When this configuration parameter is present (i.e. <code>multi_fidelity</code> is <code>TRUE</code>), then it is initialized to <code>FALSE</code>, the recommended value.
</p>
</li>
<li> <p><code>fidelity_monotonic</code> :: <code>logical(1)</code><br />
Only if the <code>multi_fidelity</code> construction argument is <code>TRUE</code>:
Whether to only do fidelity refinement in <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code> for individuals for which the budget component value would <em>increase</em>.
This is equivalent to the <code>monotonic</code> parameter of <code><a href="#topic+mies_step_fidelity">mies_step_fidelity()</a></code>, see there for more information.<br />
When this configuration parameter is present (i.e. <code>multi_fidelity</code> is <code>TRUE</code>), then it is initialized to <code>TRUE</code>. When optimization is performed
on problems that have a categorical &quot;budget&quot; parameter, then this value should be set to <code>FALSE</code>.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimizerBatch">bbotk::OptimizerBatch</a></code> -&gt; <code><a href="#topic+Optimizer">miesmuschel::Optimizer</a></code> -&gt; <code>OptimizerMies</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Mutation operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>.</p>
</dd>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Recombination operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>.</p>
</dd>
<dt><code>parent_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Parent selection operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>.</p>
</dd>
<dt><code>survival_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Survival selection operation to use in <code><a href="#topic+mies_survival_plus">mies_survival_plus()</a></code> or <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code>.</p>
</dd>
<dt><code>elite_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code> | <code>NULL</code>)<br />
Elite selector used in <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code>.</p>
</dd>
<dt><code>init_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Selection operation to use when there are more than <code>mu</code> individuals present at the beginning of the optimization.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Configuration parameters of the optimization algorithm.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerMies-new"><code>OptimizerMies$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerMies-clone"><code>OptimizerMies$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimizerBatch" data-id="optimize"><a href='../../bbotk/html/OptimizerBatch.html#method-OptimizerBatch-optimize'><code>bbotk::OptimizerBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerMies-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>OptimizerMies</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMies$new(
  mutator = MutatorProxy$new(),
  recombinator = RecombinatorProxy$new(),
  parent_selector = SelectorProxy$new(),
  survival_selector = SelectorProxy$new(),
  elite_selector = NULL,
  init_selector = survival_selector,
  multi_fidelity = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)<br />
Mutation operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, see there for more information. Default is <code><a href="#topic+MutatorProxy">MutatorProxy</a></code>, which
exposes the operation as a configuration parameter of the optimizer itself.<br />
The <code style="white-space: pre;">&#8288;$mutator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)<br />
Recombination operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, see there for more information. Default is <code><a href="#topic+RecombinatorProxy">RecombinatorProxy</a></code>,
which exposes the operation as a configuration parameter of the optimizer itself. Note: The default <code><a href="#topic+RecombinatorProxy">RecombinatorProxy</a></code> has <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> set to 2,
so to use recombination operations with more than two inputs, or to use population size of 1, it may be necessary to construct this
argument explicitly.<br />
The <code style="white-space: pre;">&#8288;$recombinator&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>parent_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Parent selection operation to perform during <code><a href="#topic+mies_generate_offspring">mies_generate_offspring()</a></code>, see there for more information. Default is <code><a href="#topic+SelectorProxy">SelectorProxy</a></code>,
which exposes the operation as a configuration parameter of the optimizer itself.<br />
The <code style="white-space: pre;">&#8288;$parent_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>survival_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Survival selection operation to use in <code><a href="#topic+mies_survival_plus">mies_survival_plus()</a></code> or <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code> (depending on the <code>survival_strategy</code> configuration parameter),
see there for more information. Default is <code><a href="#topic+SelectorProxy">SelectorProxy</a></code>, which exposes the operation as a configuration parameter of the optimizer itself.<br />
The <code style="white-space: pre;">&#8288;$survival_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>elite_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code> | <code>NULL</code>)<br />
Elite selector used in <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code>, see there for more information. &quot;Comma&quot; selection is only available when this
argument is not <code>NULL</code>. Default <code>NULL</code>.<br />
The <code style="white-space: pre;">&#8288;$elite_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>init_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)<br />
Survival selection operation to give to the <code>survival_selector</code> argument of <code><a href="#topic+mies_init_population">mies_init_population()</a></code>; it is used if
the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> being optimized already
contains more (alive) individuals than <code>mu</code>. Default is the value given to <code>survival_selector</code>.
The <code style="white-space: pre;">&#8288;$init_selector&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>multi_fidelity</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to enable multi-fidelity optimization. When this is <code>TRUE</code>, then the <code><a href="bbotk.html#topic+OptimInstance">OptimInstance</a></code> being optimized must
contain a <code><a href="paradox.html#topic+Domain">Domain</a></code> tagged <code>"budget"</code>, which is then used as the &quot;budget&quot; search space component, determined by
<code>fidelity</code> and <code>fidelity_offspring</code> instead of by the <code><a href="#topic+MiesOperator">MiesOperator</a></code>s themselves. For multi-fidelity optimization, the <code>fidelity</code>,
<code>fidelity_offspring</code>, <code>fidelity_current_gen_only</code>, and <code>fidelity_monotonic</code> configuration parameters must be given to determine
multi-fidelity behaviour. (While the initial values for most of these are probably good for most cases in which more budget implies
higher fidelity, at least the <code>fidelity</code> configuration parameter should be adjusted in most cases). Default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-OptimizerMies-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerMies$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerBatch">mlr3tuning::TunerBatch</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerBatchFromOptimizerBatch">mlr3tuning::TunerBatchFromOptimizerBatch</a></code> -&gt; <code>TunerMies</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerMies-new"><code>TunerMies$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerMies-clone"><code>TunerMies$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="print"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-print'><code>mlr3tuning::Tuner$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerBatchFromOptimizerBatch" data-id="optimize"><a href='../../mlr3tuning/html/TunerBatchFromOptimizerBatch.html#method-TunerBatchFromOptimizerBatch-optimize'><code>mlr3tuning::TunerBatchFromOptimizerBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerMies-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>TunerMies</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMies$new(
  mutator = MutatorProxy$new(),
  recombinator = RecombinatorProxy$new(),
  parent_selector = SelectorProxy$new(),
  survival_selector = SelectorProxy$new(),
  elite_selector = NULL,
  init_selector = survival_selector,
  multi_fidelity = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mutator</code></dt><dd><p>(<code><a href="#topic+Mutator">Mutator</a></code>)</p>
</dd>
<dt><code>recombinator</code></dt><dd><p>(<code><a href="#topic+Recombinator">Recombinator</a></code>)</p>
</dd>
<dt><code>parent_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)</p>
</dd>
<dt><code>survival_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)</p>
</dd>
<dt><code>elite_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code> | <code>NULL</code>)</p>
</dd>
<dt><code>init_selector</code></dt><dd><p>(<code><a href="#topic+Selector">Selector</a></code>)</p>
</dd>
<dt><code>multi_fidelity</code></dt><dd><p>(<code>logical(1)</code>)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TunerMies-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerMies$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Fieldsend, E J, Everson, M R (2014).
&ldquo;The rolling tide evolutionary algorithm: A multiobjective optimizer for noisy optimization problems.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>19</b>(1), 103&ndash;117.
</p>
<p>Li, Rui, Emmerich, TM M, Eggermont, Jeroen, B&quot;ack, Thomas, Sch&quot;utz, Martin, Dijkstra, Jouke, Reiber, HC J (2013).
&ldquo;Mixed integer evolution strategies for parameter optimization.&rdquo;
<em>Evolutionary computation</em>, <b>21</b>(1), 29&ndash;64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lgr::threshold("warn")

op.m &lt;- mut("gauss", sdev = 0.1)
op.r &lt;- rec("xounif", p = .3)
op.parent &lt;- sel("random")
op.survival &lt;- sel("best")

#####
# Optimizing a Function
#####

library("bbotk")

# Define the objective to optimize
objective &lt;- ObjectiveRFun$new(
  fun = function(xs) {
    z &lt;- exp(-xs$x^2 - xs$y^2) + 2 * exp(-(2 - xs$x)^2 - (2 - xs$y)^2)
    list(Obj = z)
  },
  domain = ps(x = p_dbl(-2, 4), y = p_dbl(-2, 4)),
  codomain = ps(Obj = p_dbl(tags = "maximize"))
)

# Get a new OptimInstance
oi &lt;- OptimInstanceSingleCrit$new(objective,
  terminator = trm("evals", n_evals = 100)
)

# Create OptimizerMies object
mies_opt &lt;- opt("mies", mutator = op.m, recombinator = op.r,
  parent_selector = op.parent, survival_selector = op.survival,
  mu = 10, lambda = 5)

# mies_opt$optimize performs MIES optimization and returns the optimum
mies_opt$optimize(oi)

#####
# Optimizing a Machine Learning Method
#####

# Note that this is a short example, aiming at clarity and short runtime.
# The settings are not optimal for hyperparameter tuning. The resampling
# in particular should not be "holdout" for small datasets where this gives
# a very noisy estimate of performance.

library("mlr3")
library("mlr3tuning")

# The Learner to optimize
learner = lrn("classif.rpart")

# The hyperparameters to optimize
learner$param_set$values[c("cp", "maxdepth")] = list(to_tune())

# Get a TuningInstance
ti = TuningInstanceSingleCrit$new(
  task = tsk("iris"),
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.acc"),
  terminator = trm("gens", generations = 10)
)

# Create TunerMies object
mies_tune &lt;- tnr("mies", mutator = op.m, recombinator = op.r,
  parent_selector = op.parent, survival_selector = op.survival,
  mu = 10, lambda = 5)

# mies_tune$optimize performs MIES optimization and returns the optimum
mies_tune$optimize(ti)

</code></pre>

<hr>
<h2 id='ParamSetShadow'>ParamSetShadow</h2><span id='topic+ParamSetShadow'></span>

<h3>Description</h3>

<p>Wraps another <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> and shadows out a subset of its <code><a href="paradox.html#topic+Domain">Domain</a></code>s.
The original <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> can still be accessed through the <code style="white-space: pre;">&#8288;$origin&#8288;</code> field;
otherwise, the <code>ParamSetShadow</code> behaves like a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> where the shadowed
<code><a href="paradox.html#topic+Domain">Domain</a></code>s are not present.
</p>


<h3>Super class</h3>

<p><code><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a></code> -&gt; <code>ParamSetShadow</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>params</code></dt><dd><p>(named <code>list()</code>)<br />
Table of rows identifying the contained <code><a href="paradox.html#topic+Domain">Domain</a></code>s</p>
</dd>
<dt><code>params_unid</code></dt><dd><p>(named <code>list</code> of <code>Param</code>)
List of <code>Param</code> that are members of the wrapped <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> with the
shadowed <code>Param</code>s removed. This is a field mostly for internal usage that has the
<code style="white-space: pre;">&#8288;$id&#8288;</code>s set to invalid values but avoids cloning overhead.<br />
Deprecated by the upcoming <code>paradox</code> package update and will be removed in the future.</p>
</dd>
<dt><code>deps</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table</a></code>)<br />
Table of dependencies, as in <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. The dependencies that are related to shadowed
parameters are not exposed. This <code><a href="data.table.html#topic+data.table">data.table</a></code> should be seen as read-only and not
modified in-place; instead, the <code style="white-space: pre;">&#8288;$origin&#8288;</code>'s <code style="white-space: pre;">&#8288;$deps&#8288;</code> should be modified.</p>
</dd>
<dt><code>values</code></dt><dd><p>(named <code>list</code>)<br />
List of values, as in <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, with the shadowed values removed.</p>
</dd>
<dt><code>set_id</code></dt><dd><p>(<code><a href="data.table.html#topic+data.table">data.table</a></code>)<br />
Id of the wrapped <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>. Changing this value will also change the wrapped <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>'s <code style="white-space: pre;">&#8288;$set_id&#8288;</code> accordingly.</p>
</dd>
<dt><code>origin</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> being wrapped. This object can be modified by reference to influence the <code>ParamSetShadow</code> object itself.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ParamSetShadow-new"><code>ParamSetShadow$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetShadow-test_constraint"><code>ParamSetShadow$test_constraint()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetShadow-add_dep"><code>ParamSetShadow$add_dep()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamSetShadow-clone"><code>ParamSetShadow$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="aggr_internal_tuned_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-aggr_internal_tuned_values'><code>paradox::ParamSet$aggr_internal_tuned_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert'><code>paradox::ParamSet$assert()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="assert_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-assert_dt'><code>paradox::ParamSet$assert_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check'><code>paradox::ParamSet$check()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check_dependencies"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check_dependencies'><code>paradox::ParamSet$check_dependencies()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="check_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-check_dt'><code>paradox::ParamSet$check_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="convert_internal_search_space"><a href='../../paradox/html/ParamSet.html#method-ParamSet-convert_internal_search_space'><code>paradox::ParamSet$convert_internal_search_space()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="disable_internal_tuning"><a href='../../paradox/html/ParamSet.html#method-ParamSet-disable_internal_tuning'><code>paradox::ParamSet$disable_internal_tuning()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="flatten"><a href='../../paradox/html/ParamSet.html#method-ParamSet-flatten'><code>paradox::ParamSet$flatten()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="format"><a href='../../paradox/html/ParamSet.html#method-ParamSet-format'><code>paradox::ParamSet$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="get_domain"><a href='../../paradox/html/ParamSet.html#method-ParamSet-get_domain'><code>paradox::ParamSet$get_domain()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="get_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-get_values'><code>paradox::ParamSet$get_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="ids"><a href='../../paradox/html/ParamSet.html#method-ParamSet-ids'><code>paradox::ParamSet$ids()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="print"><a href='../../paradox/html/ParamSet.html#method-ParamSet-print'><code>paradox::ParamSet$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="qunif"><a href='../../paradox/html/ParamSet.html#method-ParamSet-qunif'><code>paradox::ParamSet$qunif()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="search_space"><a href='../../paradox/html/ParamSet.html#method-ParamSet-search_space'><code>paradox::ParamSet$search_space()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="set_values"><a href='../../paradox/html/ParamSet.html#method-ParamSet-set_values'><code>paradox::ParamSet$set_values()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="subset"><a href='../../paradox/html/ParamSet.html#method-ParamSet-subset'><code>paradox::ParamSet$subset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="subspaces"><a href='../../paradox/html/ParamSet.html#method-ParamSet-subspaces'><code>paradox::ParamSet$subspaces()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test'><code>paradox::ParamSet$test()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_constraint_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_constraint_dt'><code>paradox::ParamSet$test_constraint_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="test_dt"><a href='../../paradox/html/ParamSet.html#method-ParamSet-test_dt'><code>paradox::ParamSet$test_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="ParamSet" data-id="trafo"><a href='../../paradox/html/ParamSet.html#method-ParamSet-trafo'><code>paradox::ParamSet$trafo()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ParamSetShadow-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>ParamSetShadow</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetShadow$new(set, shadowed)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> to wrap.</p>
</dd>
<dt><code>shadowed</code></dt><dd><p>(<code>character</code>)<br />
Ids of <code><a href="paradox.html#topic+Domain">Domain</a></code>s to shadow from <code>sets</code>, must be a subset of <code>set$ids()</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ParamSetShadow-test_constraint"></a>



<h4>Method <code>test_constraint()</code></h4>

<p>Checks underlying <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>'s constraint.
It uses the underlying <code style="white-space: pre;">&#8288;$values&#8288;</code> for shadowed values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetShadow$test_constraint(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(named <code>list</code>) values to test</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>'s <code style="white-space: pre;">&#8288;$test_constraint()&#8288;</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>logical(1)</code>.
</p>


<hr>
<a id="method-ParamSetShadow-add_dep"></a>



<h4>Method <code>add_dep()</code></h4>

<p>Adds a dependency to the unterlying <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetShadow$add_dep(id, on, cond, allow_dangling_dependencies = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)</p>
</dd>
<dt><code>on</code></dt><dd><p>(<code>character(1)</code>)</p>
</dd>
<dt><code>cond</code></dt><dd><p>(<code><a href="paradox.html#topic+Condition">Condition</a></code>)</p>
</dd>
<dt><code>allow_dangling_dependencies</code></dt><dd><p>(<code>logical(1)</code>): Whether to allow dependencies on parameters that are not present.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>'s <code style="white-space: pre;">&#8288;$add_dep()&#8288;</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>invisible(self)</code>.
</p>


<hr>
<a id="method-ParamSetShadow-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamSetShadow$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>p1 = ps(x = p_dbl(0, 1), y = p_lgl())
p1$values = list(x = 0.5, y = TRUE)
print(p1)

p2 = ParamSetShadow$new(p1, "x")
print(p2$values)

p2$values$y = FALSE
print(p2)

print(p2$origin$values)
</code></pre>

<hr>
<h2 id='rank_nondominated'>Perform Nondominated Sorting</h2><span id='topic+rank_nondominated'></span>

<h3>Description</h3>

<p>Assign elements of <code>fitnesses</code> to nondominated fronts.
</p>
<p>The first nondominated front is the set of individuals that is not dominated by any other
individual with respect to any fitness dimension, i.e. where no other individual exists that
has all fitness values greater or equal, with at least one fitness value strictly greater.
</p>
<p>The n'th nondominated front is the set of individuals that is not dominated by any other
individual that is not in any nondominated front with smaller n.
</p>
<p>Fitnesses are <em>maximized</em>, so the individuals in lower numbered nondominated fronts tend
to have higher fitness values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_nondominated(fitnesses, epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_nondominated_+3A_fitnesses">fitnesses</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;numeric matrix&#8288;</code>)<br />
fitness matrix, with one row per individual and one column per objective</p>
</td></tr>
<tr><td><code id="rank_nondominated_+3A_epsilon">epsilon</code></td>
<td>
<p>(<code>numeric</code>)<br />
Epsilon-vaue for non-dominance. A value is epsilon-dominated by another if it is at least <code>epsilon</code> smaller than
the other in all dimensions, and more than <code>epsilon</code> smaller than the other in one dimension. <code>epsilon</code> may
be a scalar, in which case it is used for all dimensions or a vector, in which case its length must match
the number of dimensions. Default 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>: <code style="white-space: pre;">&#8288;$front&#8288;</code>: Vector assigning each individual in <code>fitnesses</code> its nondominated front.
<code style="white-space: pre;">&#8288;$domcount&#8288;</code>: Length N vector counting the number of individuals that dominate the given individual.
</p>

<hr>
<h2 id='Recombinator'>Recombinator Base Class</h2><span id='topic+Recombinator'></span>

<h3>Description</h3>

<p>Base class representing recombination operations, inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>.
</p>
<p>Recombinators get a table of individuals as input and return a table of modified individuals as output. Individuals are acted on by
groups: every <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> lines of output corresponds to a group of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> lines of input, and presence or absence
of other input groups does not affect the result.
</p>
<p>Recombination operations are performed in ES algorithms to facilitate exploration of the search space that combine partial
solutions.
</p>


<h3>Inheriting</h3>

<p><code>Recombinator</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.recombine()&#8288;</code>
function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, which calls <code style="white-space: pre;">&#8288;$.recombine()&#8288;</code> for each <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> sized group of individuals after checking that
the operator is primed, that the <code>values</code> argument conforms to the primed domain. <code style="white-space: pre;">&#8288;$.recombine()&#8288;</code> should then return a table of
<code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> individuals for each call. Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> function
should also be overloaded, and optionally the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function; they should call their <code>super</code> equivalents.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>Recombinator</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.</p>
</dd>
<dt><code>n_indivs_out</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals produced for each group of <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> individuals.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Recombinator-new"><code>Recombinator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Recombinator-clone"><code>Recombinator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Recombinator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Recombinator</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Recombinator$new(
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  n_indivs_in = 2,
  n_indivs_out = n_indivs_in,
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>n_indivs_in</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals to consider at the same time. When operating, the number of input individuals must be divisible by this number.
Default 2.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>n_indivs_out</code></dt><dd><p>(<code>integer(1)</code>)<br />
Number of individuals that result for each <code>n_indivs_in</code> lines of input. The number of results from the recombinator will be
<code>nrow(values) / n_indivs_in * n_indivs_out</code>. Default equal to <code>n_indivs_in</code>.<br />
The <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Recombinator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Recombinator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>

<hr>
<h2 id='RecombinatorPair'>Pair Recombinator Base Class</h2><span id='topic+RecombinatorPair'></span>

<h3>Description</h3>

<p>Base class for recombination that covers the common case of combining two individuals, where two (typically complementary) child individuals
could be taken as the result, such as <a href="#topic+RecombinatorCrossoverUniform">bitwise crossover</a> or <a href="#topic+RecombinatorSimulatedBinaryCrossover">SBX crossover</a>.
</p>
<p>This is a relatively lightweight class, it adds the <code>keep_complement</code> active binding and sets <code style="white-space: pre;">&#8288;$n_indivs_in&#8288;</code> and <code style="white-space: pre;">&#8288;$n_indivs_out&#8288;</code> appropriately.
</p>


<h3>Inheriting</h3>

<p><code>RecombinatorPair</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private
<code style="white-space: pre;">&#8288;$.recombine_pair()&#8288;</code> function. During <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, the <code style="white-space: pre;">&#8288;$.recombine_pair()&#8288;</code> function is called with the same input as the <code style="white-space: pre;">&#8288;$.recombine()&#8288;</code> function
of the <code><a href="#topic+Recombinator">Recombinator</a></code> class. It should return a <code>data.table</code> of two individuals.
</p>
<p>Constructors of inheriting  classes should have a <code>keep_complement</code> argument.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Recombinator">miesmuschel::Recombinator</a></code> -&gt; <code>RecombinatorPair</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>keep_complement</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the operation keeps both resulting individuals of the operation or discards the complement.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RecombinatorPair-new"><code>RecombinatorPair$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RecombinatorPair-clone"><code>RecombinatorPair$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-RecombinatorPair-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>RecombinatorPair</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorPair$new(
  keep_complement = TRUE,
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_complement</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the operation should keep both resulting individuals (<code>TRUE</code>), or only the first and discard
the complement (<code>FALSE</code>). Default <code>TRUE</code>.
The <code style="white-space: pre;">&#8288;$keep_complement&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RecombinatorPair-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RecombinatorPair$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other recombinators: 
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+dict_recombinators_cmpmaybe">dict_recombinators_cmpmaybe</a></code>,
<code><a href="#topic+dict_recombinators_convex">dict_recombinators_convex</a></code>,
<code><a href="#topic+dict_recombinators_cvxpair">dict_recombinators_cvxpair</a></code>,
<code><a href="#topic+dict_recombinators_maybe">dict_recombinators_maybe</a></code>,
<code><a href="#topic+dict_recombinators_null">dict_recombinators_null</a></code>,
<code><a href="#topic+dict_recombinators_proxy">dict_recombinators_proxy</a></code>,
<code><a href="#topic+dict_recombinators_sbx">dict_recombinators_sbx</a></code>,
<code><a href="#topic+dict_recombinators_sequential">dict_recombinators_sequential</a></code>,
<code><a href="#topic+dict_recombinators_swap">dict_recombinators_swap</a></code>,
<code><a href="#topic+dict_recombinators_xonary">dict_recombinators_xonary</a></code>,
<code><a href="#topic+dict_recombinators_xounif">dict_recombinators_xounif</a></code>
</p>

<hr>
<h2 id='repr'>Create a 'call' Object Representation</h2><span id='topic+repr'></span>

<h3>Description</h3>

<p><code>repr()</code> creates a <code><a href="base.html#topic+call">call</a></code> object representing <code>obj</code>, if possible.
Evaluating the call should come close to recreating the original object.
</p>
<p>In the most trivial cases, it should be possible to recreate objects from their
representation by evaluating them using <code><a href="base.html#topic+eval">eval()</a></code>. Important exceptions
are:
</p>

<ul>
<li><p> Functions are represented by their source code, if available, and by their AST if not.
This drops the context from their environments and recreated objects will not work
if they contain functions that depend on specific environments
</p>
</li>
<li> <p><code><a href="base.html#topic+environment">environment</a></code>s are not represented.
</p>
</li>
<li> <p><code><a href="R6.html#topic+R6Class">R6</a></code> objects are only represented if they have a <code style="white-space: pre;">&#8288;$repr()&#8288;</code> function.
This function may have arbitrary arguments, and should have a <code>...</code> argument to
capture ignored arguments.
</p>
</li></ul>

<p>Objects that can not be represented are currently mapped to the call <code>stop("&lt;###&gt;")</code>, where
<code style="white-space: pre;">&#8288;###&#8288;</code> is a short description of the non-representable object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repr_+3A_obj">obj</code></td>
<td>
<p>(any)<br />
Object to create a representation of.</p>
</td></tr>
<tr><td><code id="repr_+3A_...">...</code></td>
<td>
<p>(any)<br />
Further arguments to be passed to class methods. Currently in use are:
</p>

<ul>
<li> <p><code>skip_defaults</code> (<code>logical(1)</code>) whether to skip construction arguments that have their default value. Default <code>TRUE</code>.
</p>
</li>
<li> <p><code>show_params</code> (<code>logical(1)</code>) whether to show <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> values. Default <code>TRUE</code>.
</p>
</li>
<li> <p><code>show_constructor_args</code> (<code>logical(1)</code>) whether to show construction args that are not <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> values. Default <code>TRUE</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+call">call</a></code>: A call that, when evaluated, tries to re-create the object.
</p>

<hr>
<h2 id='SamplerRandomWeights'>Sampler for Projection Weights</h2><span id='topic+SamplerRandomWeights'></span>

<h3>Description</h3>

<p>Sampler for a single <code><a href="paradox.html#topic+Domain">p_uty</a></code> that samples weight-matrices
as used by <code><a href="#topic+ScalorFixedProjection">ScalorFixedProjection</a></code>.
</p>


<h3>Super class</h3>

<p><code><a href="paradox.html#topic+Sampler">paradox::Sampler</a></code> -&gt; <code>SamplerRandomWeights</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nobjectives</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Number of objectives for which weights are generated.</p>
</dd>
<dt><code>nweights</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Number of weight vectors generated for each configuration.</p>
</dd>
<dt><code>weights_component_id</code></dt><dd><p>(<code>numeric(1)</code>)<br />
search space component identifying the weights by which to scalarize.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SamplerRandomWeights-new"><code>SamplerRandomWeights$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SamplerRandomWeights-clone"><code>SamplerRandomWeights$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="format"><a href='../../paradox/html/Sampler.html#method-Sampler-format'><code>paradox::Sampler$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="print"><a href='../../paradox/html/Sampler.html#method-Sampler-print'><code>paradox::Sampler$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="paradox" data-topic="Sampler" data-id="sample"><a href='../../paradox/html/Sampler.html#method-Sampler-sample'><code>paradox::Sampler$sample()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SamplerRandomWeights-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize the <code>SamplerRandomWeights</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerRandomWeights$new(
  nobjectives = 2,
  nweights = 1,
  weights_component_id = "scalarization_weights"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nobjectives</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Number of objectives for which weights are generated.</p>
</dd>
<dt><code>nweights</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Number of weight vectors generated for each configuration.</p>
</dd>
<dt><code>weights_component_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Id of the <code><a href="paradox.html#topic+Domain">p_uty</a></code>. Default is <code>"scalarization_weights"</code>.
Can be changed arbitrarily but should match the <code><a href="#topic+ScalorFixedProjection">ScalorFixedProjection</a></code>'s <code>weights_component_id</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SamplerRandomWeights-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SamplerRandomWeights$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
</code></pre>

<hr>
<h2 id='Scalarizer'>Scalarizer</h2><span id='topic+Scalarizer'></span>

<h3>Description</h3>

<p><code>Scalarizer</code> objects are functions taking a fitness-matrix <code>fitnesses</code> (Nindivs x Nobjectives, with higher values indicating higher desirability)
and a list of weight matrices <code>weights</code> (Nindivs elements of Nobjectives x Nweights matrices; positive weights indicate a positive contribution
to scale) and returns a matrix of scalarizations (Nindivs x Nweights, with higher values indicating greater desirability).
</p>
<p>Any other function conforming to these requirements can also be used in place of a <code>Scalarizer</code>, but the provided <code>Scalarizer</code> functions cover
the most common use cases.
</p>
<p><code>Scalarizer</code>s are constructed from constructor-functions, such as <code><a href="#topic+scalarizer_linear">scalarizer_linear()</a></code> or <code><a href="#topic+scalarizer_chebyshev">scalarizer_chebyshev()</a></code>.
</p>


<h3>See Also</h3>

<p>Other Scalarizers: 
<code><a href="#topic+scalarizer_chebyshev">scalarizer_chebyshev</a>()</code>,
<code><a href="#topic+scalarizer_linear">scalarizer_linear</a>()</code>
</p>

<hr>
<h2 id='scalarizer_chebyshev'>Chebyshev Scalarizer</h2><span id='topic+scalarizer_chebyshev'></span>

<h3>Description</h3>

<p>Constructs a <code><a href="#topic+Scalarizer">Scalarizer</a></code> that does Chebyshev scalarization, as employed in ParEGO by Knowles (2006).
</p>
<p>The Chebyshev scalarization for a single individual with
fitness values <code>f</code> and given weight vector <code>w</code> is
<code>min(w * f) + rho * sum(w * f)</code>, where <code>rho</code> is a hyperparameter
given during construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarizer_chebyshev(rho = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarizer_chebyshev_+3A_rho">rho</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Small positive value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+Scalarizer">Scalarizer</a></code> object.
</p>


<h3>References</h3>

<p>Knowles, Joshua (2006).
&ldquo;ParEGO: A hybrid algorithm with on-line landscape approximation for expensive multiobjective optimization problems.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>10</b>(1), 50&ndash;66.
</p>


<h3>See Also</h3>

<p>Other Scalarizers: 
<code><a href="#topic+Scalarizer">Scalarizer</a></code>,
<code><a href="#topic+scalarizer_linear">scalarizer_linear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fitnesses: three rows (i.e. thee indivs) with two objective values each
fitnesses &lt;- matrix(0:5, ncol = 2)

# weights: contains one matrix for each row of 'fitnesses' (i.e. each indiv)
# which get multiplied with their respective row.
weights &lt;- list(
 matrix(c(1, 0, 0, 1), ncol = 2),
 matrix(c(1, 2, 0, 0), ncol = 2),
 matrix(c(0, 1, 0, 1), ncol = 2)
)

sc &lt;- scalarizer_chebyshev()

# The resulting row-vectors are the different scalarizations according to the
# columns in the 'weights' matrices.
sc(fitnesses, weights)

sc &lt;- scalarizer_chebyshev(rho = 0.1)
sc(fitnesses, weights)
</code></pre>

<hr>
<h2 id='scalarizer_linear'>Linear Scalarizer</h2><span id='topic+scalarizer_linear'></span>

<h3>Description</h3>

<p>Constructs a linear <code><a href="#topic+Scalarizer">Scalarizer</a></code>, which performs linear scalarization for <code><a href="#topic+ScalorFixedProjection">ScalorFixedProjection</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarizer_linear()
</code></pre>


<h3>Value</h3>

<p>a <code><a href="#topic+Scalarizer">Scalarizer</a></code> object.
</p>


<h3>See Also</h3>

<p>Other Scalarizers: 
<code><a href="#topic+Scalarizer">Scalarizer</a></code>,
<code><a href="#topic+scalarizer_chebyshev">scalarizer_chebyshev</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fitnesses: three rows (i.e. thee indivs) with two objective values each
fitnesses &lt;- matrix(0:5, ncol = 2)

# weights: contains one matrix for each row of 'fitnesses' (i.e. each indiv)
# which get multiplied with their respective row.
weights &lt;- list(
 matrix(c(1, 0, 0, 1), ncol = 2),
 matrix(c(1, 2, 0, 0), ncol = 2),
 matrix(c(0, 1, 0, 1), ncol = 2)
)

sc &lt;- scalarizer_linear()

# The resulting row-vectors are the different scalarizations according to the
# columns in the 'weights' matrices.
sc(fitnesses, weights)
</code></pre>

<hr>
<h2 id='Scalor'>Scalor Base Class</h2><span id='topic+Scalor'></span>

<h3>Description</h3>

<p>Base class representing ranking operations, inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>.
</p>
<p>A <code><a href="#topic+Scalor">Scalor</a></code> gets a table of individuals as input, along with information on the individuals' performance values
and returns a vector of a possible scalarization of individuals' fitness (or other qualities).
</p>
<p><code><a href="#topic+Scalor">Scalor</a></code>s can be used by <code><a href="#topic+Selector">Selector</a></code>s as a basis to select individuals by. This way it is possible to have tournament
selection (<code><a href="#topic+SelectorTournament">SelectorTournament</a></code>) or elite selection (<code><a href="#topic+SelectorBest">SelectorBest</a></code>) based on different, configurable qualities of
individuals.
</p>
<p>Unlike most other operator types inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>, the <code style="white-space: pre;">&#8288;$operate()&#8288;</code> function has two arguments, which are passed on to <code style="white-space: pre;">&#8288;$.scale()&#8288;</code>
</p>

<ul>
<li> <p><code>values</code> :: <code>data.frame</code><br />
Individuals to operate on. Must pass the check of the <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> given in the last <code style="white-space: pre;">&#8288;$prime()&#8288;</code> call
and may not have any missing components.
</p>
</li>
<li> <p><code>fitnesses</code> :: <code>numeric</code> | <code>matrix</code><br />
Fitnesses for each individual given in <code>values</code>. If this is a <code>numeric</code>, then its length must be equal to the number of rows in <code>values</code>. If
this is a <code>matrix</code>, if number of rows must be equal to the number of rows in <code>values</code>, and it must have one column when doing single-crit optimization
and one column each for each &quot;criterion&quot; when doing multi-crit optimization.<br />
Note that fitness values are always <em>maximized</em>, both in single- and multi-criterion optimization, so objective output is multiplied with <code>-1</code> if it
is tagged as <code>"minimize"</code>.
</p>
</li></ul>

<p>The return value of an operation should be a numeric vector with one finite value for each entry of <code>values</code>, assigning high values to individuals in
some way more &quot;desirable&quot; than others with low values.
</p>


<h3>Inheriting</h3>

<p><code>Scalor</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.scale()&#8288;</code>
function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, and the arguments are passed on to private <code style="white-space: pre;">&#8288;$.scale()&#8288;</code> after checking that
the operator is primed, that the <code>values</code> argument conforms to the primed domain and that other values match. Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> function
should also be overloaded, and optionally the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function; they should call their <code>super</code> equivalents.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>Scalor</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Optimization supported by this <code>Scalor</code>, can be <code>"single-crit"</code>, <code>"multi-crit"</code>, or both.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Scalor-new"><code>Scalor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Scalor-clone"><code>Scalor$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Scalor-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Mutator</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scalor$new(
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  supported = c("single-crit", "multi-crit"),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Subset of <code>"single-crit"</code> and <code>"multi-crit"</code>, indicating wether single and / or multi-criterion optimization is supported.
Default both of them.<br />
The <code style="white-space: pre;">&#8288;$supported&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Scalor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Scalor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other scalors: 
<code><a href="#topic+dict_scalors_aggregate">dict_scalors_aggregate</a></code>,
<code><a href="#topic+dict_scalors_domcount">dict_scalors_domcount</a></code>,
<code><a href="#topic+dict_scalors_fixedprojection">dict_scalors_fixedprojection</a></code>,
<code><a href="#topic+dict_scalors_hypervolume">dict_scalors_hypervolume</a></code>,
<code><a href="#topic+dict_scalors_nondom">dict_scalors_nondom</a></code>,
<code><a href="#topic+dict_scalors_one">dict_scalors_one</a></code>,
<code><a href="#topic+dict_scalors_proxy">dict_scalors_proxy</a></code>,
<code><a href="#topic+dict_scalors_single">dict_scalors_single</a></code>
</p>

<hr>
<h2 id='Selector'>Selector Base Class</h2><span id='topic+Selector'></span>

<h3>Description</h3>

<p>Base class representing selection operations, inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>.
</p>
<p>A <code><a href="#topic+Selector">Selector</a></code> gets a table of individuals as input, along with information on the individuals' performance values and the
number of individuals to select, and returns a vector of integers indicating which individuals were selected.
</p>
<p>Selection operations are performed in ES algorithms to facilitate concentration towards individuals that perform well with regard to the
fitness measure.
</p>
<p>Fitness values are always <em>maximized</em>, both in single- and multi-criterion optimization.
</p>
<p>Unlike most other operator types inheriting from <code><a href="#topic+MiesOperator">MiesOperator</a></code>, the <code style="white-space: pre;">&#8288;$operate()&#8288;</code> function has three arguments, which are passed on to <code style="white-space: pre;">&#8288;$.select()&#8288;</code>
</p>

<ul>
<li> <p><code>values</code> :: <code>data.frame</code><br />
Individuals to operate on. Must pass the check of the <code><a href="paradox.html#topic+Domain">Domain</a></code> given in the last <code style="white-space: pre;">&#8288;$prime()&#8288;</code> call
and may not have any missing components.
</p>
</li>
<li> <p><code>fitnesses</code> :: <code>numeric</code> | <code>matrix</code><br />
Fitnesses for each individual given in <code>values</code>. If this is a <code>numeric</code>, then its length must be equal to the number of rows in <code>values</code>. If
this is a <code>matrix</code>, if number of rows must be equal to the number of rows in <code>values</code>, and it must have one column when doing single-crit optimization
and one column each for each  &quot;criterion&quot; when doing multi-crit optimization.<br />
The <code>fitnesses</code>-value passed on to <code style="white-space: pre;">&#8288;$.select()&#8288;</code> is always a <code>matrix</code>.
</p>
</li>
<li> <p><code>n_select</code> :: <code>integer(1)</code><br />
Number of individuals to select. Some <code>Selector</code>s select individuals with replacement, for which this value may be greater than the number of
rows in <code>values</code>.
</p>
</li>
<li> <p><code>group_size</code> :: <code>integer</code><br />
Sampling group size hint, indicating that the caller would prefer there to not be any duplicates within this group size, e.g. because the
<code><a href="#topic+Selector">Selector</a></code> is called to select individuals to be given to a <code><a href="#topic+Recombinator">Recombinator</a></code> with a certain <code>n_indivs_in</code>, or because it is called as a
<code>survival_selector</code> in <code><a href="#topic+mies_survival_comma">mies_survival_comma()</a></code> or <code><a href="#topic+mies_survival_plus">mies_survival_plus()</a></code>. The <code><a href="#topic+Selector">Selector</a></code> may or may not ignore this value, however.
This may possibly happen because of certain configuration parameters, or because the input size is too small.<br />
Must either be a scalar value or sum up to <code>n_select</code>. Must be non-negative. A scalar value of 0 is interpreted the same as 1.<br />
If not given, this value defaults to 1.
</p>
</li></ul>

<p>The return value for an operation will be a numeric vector of integer values of length <code>n_select</code> indexing the individuals that were selected. Some <code>Selector</code>s
select individuals with replacement, for which the return value may contain indices more than once.
</p>


<h3>Inheriting</h3>

<p><code>Selector</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.select()&#8288;</code>
function. The user of the object calls <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, and the arguments are passed on to private <code style="white-space: pre;">&#8288;$.select()&#8288;</code> after checking that
the operator is primed, that the <code>values</code> argument conforms to the primed domain and that other values match. Typically, the <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> function
should also be overloaded, and optionally the <code style="white-space: pre;">&#8288;$prime()&#8288;</code> function; they should call their <code>super</code> equivalents.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code>Selector</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Optimization supported by this <code>Selector</code>, can be <code>"single-crit"</code>, <code>"multi-crit"</code>, or both.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Selector-new"><code>Selector$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Selector-clone"><code>Selector$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="prime"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-prime'><code>miesmuschel::MiesOperator$prime()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Selector-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>Selector</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Selector$new(
  is_deterministic = FALSE,
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  supported = c("single-crit", "multi-crit"),
  packages = character(0),
  dict_entry = NULL,
  own_param_set = quote(self$param_set)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>is_deterministic</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the <code><a href="#topic+Selector">Selector</a></code> is deterministic. Setting this to <code>TRUE</code> adds a configuration parameter <code>shuffle_selection</code> (initialized to <code>TRUE</code>)
that causes the selection to be shuffled.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Subset of <code>"single-crit"</code> and <code>"multi-crit"</code>, indicating wether single and / or multi-criterion optimization is supported.
Default both of them.<br />
The <code style="white-space: pre;">&#8288;$supported&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>own_param_set</code></dt><dd><p>(<code>language</code>)<br />
An expression that evaluates to a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> indicating the configuration parameters that are entirely owned by
this operator class (and not proxied from a construction argument object). This should be <code>quote(self$param_set)</code> (the default) when
the <code>param_set</code> argument is not a list of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Selector-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Selector$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>
</p>
<p>Other selectors: 
<code><a href="#topic+SelectorScalar">SelectorScalar</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>

<hr>
<h2 id='SelectorScalar'>Selector making use of Scalors</h2><span id='topic+SelectorScalar'></span>

<h3>Description</h3>

<p>Base class inheriting from <code><a href="#topic+Selector">Selector</a></code> for selection operations that make use of scalar values, generated by <code><a href="#topic+Scalor">Scalor</a></code>.
</p>


<h3>Inheriting</h3>

<p><code>SelectorScaling</code> is an abstract base class and should be inherited from. Inheriting classes should implement the private <code style="white-space: pre;">&#8288;$.select_scalar()&#8288;</code>
function. During <code style="white-space: pre;">&#8288;$operate()&#8288;</code>, the <code style="white-space: pre;">&#8288;$.select_scalar()&#8288;</code> function is called, it should have three arguments, similar to <code><a href="#topic+Selector">Selector</a></code>'s <code style="white-space: pre;">&#8288;$.select()&#8288;</code> function.
<code>values</code> and <code>n_select</code> are as given to <code style="white-space: pre;">&#8288;$.select()&#8288;</code> of the <code><a href="#topic+Selector">Selector</a></code>. The <code>fitnesses</code> argument is first scaled by the associated <code><a href="#topic+Scalor">Scalor</a></code>
and then passed on as a <code>numeric</code> vector.
</p>
<p>Typically, <code style="white-space: pre;">&#8288;$initialize()&#8288;</code> should also be overloaded when inheriting.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+MiesOperator">miesmuschel::MiesOperator</a></code> -&gt; <code><a href="#topic+Selector">miesmuschel::Selector</a></code> -&gt; <code>SelectorScalar</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>scalor</code></dt><dd><p>(<code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code> used to scalarize fitnesses for selection.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SelectorScalar-new"><code>SelectorScalar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorScalar-prime"><code>SelectorScalar$prime()</code></a>
</p>
</li>
<li> <p><a href="#method-SelectorScalar-clone"><code>SelectorScalar$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="help"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-help'><code>miesmuschel::MiesOperator$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="operate"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-operate'><code>miesmuschel::MiesOperator$operate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="print"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-print'><code>miesmuschel::MiesOperator$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="miesmuschel" data-topic="MiesOperator" data-id="repr"><a href='../../miesmuschel/html/MiesOperator.html#method-MiesOperator-repr'><code>miesmuschel::MiesOperator$repr()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SelectorScalar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize base class components of the <code>SelectorScalar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorScalar$new(
  scalor = ScalorSingleObjective$new(),
  is_deterministic = FALSE,
  param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
  param_set = ps(),
  supported = scalor$supported,
  packages = character(0),
  dict_entry = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scalor</code></dt><dd><p>(<code><a href="#topic+Scalor">Scalor</a></code>)<br />
<code><a href="#topic+Scalor">Scalor</a></code> to use to generate scalar values from multiple objectives, if multi-objective optimization is performed.
Initialized to <code><a href="#topic+ScalorSingleObjective">ScalorSingleObjective</a></code>: Doing single-objective optimization normally, throwing an error if used
in multi-objective setting: In that case, a <code><a href="#topic+Scalor">Scalor</a></code> needs to be explicitly chosen.</p>
</dd>
<dt><code>is_deterministic</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether the <code><a href="#topic+Selector">Selector</a></code> is deterministic. Setting this to <code>TRUE</code> adds a configuration parameter <code>shuffle_selection</code> (initialized to <code>TRUE</code>)
that causes the selection to be shuffled.</p>
</dd>
<dt><code>param_classes</code></dt><dd><p>(<code>character</code>)<br />
Classes of parameters that the operator can handle. May contain any of <code>"ParamLgl"</code>, <code>"ParamInt"</code>, <code>"ParamDbl"</code>, <code>"ParamFct"</code>.
Default is all of them.<br />
The <code style="white-space: pre;">&#8288;$param_classes&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> | <code>list</code> of <code>expression</code>)<br />
Strategy parameters of the operator. This should be created by the subclass and given to <code>super$initialize()</code>.
If this is a <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>, it is used as the <code>MiesOperator</code>'s <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>
directly. Otherwise it must be a <code>list</code> of expressions e.g. created by <code>alist()</code> that evaluate to <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>s,
possibly referencing <code>self</code> and <code>private</code>.
These <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code> are then combined using a <code><a href="paradox.html#topic+ParamSetCollection">ParamSetCollection</a></code>.
Default is the empty <code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>.<br />
The <code style="white-space: pre;">&#8288;$param_set&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>supported</code></dt><dd><p>(<code>character</code>)<br />
Subset of <code>"single-crit"</code> and <code>"multi-crit"</code>, indicating wether single and / or multi-criterion optimization is supported.
Default to the supported set of <code>scalor</code>.<br />
The <code style="white-space: pre;">&#8288;$supported&#8288;</code> field will reflect this value.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character</code>)
Packages that need to be loaded for the operator to function. This should
be declared so these packages can be loaded when operators run on parallel
instances. Default is <code>character(0)</code>.<br />
The <code style="white-space: pre;">&#8288;$packages&#8288;</code> field will reflect this values.</p>
</dd>
<dt><code>dict_entry</code></dt><dd><p>(<code>character(1)</code> | <code>NULL</code>)<br />
Key of the class inside the <code><a href="mlr3misc.html#topic+Dictionary">Dictionary</a></code> (usually one of
<code><a href="#topic+dict_mutators">dict_mutators</a></code>, <code><a href="#topic+dict_recombinators">dict_recombinators</a></code>, <code><a href="#topic+dict_selectors">dict_selectors</a></code>), where it can
be retrieved using a <a href="#topic+mut">short access function</a>. May be <code>NULL</code> if the operator
is not entered in a dictionary.<br />
The <code style="white-space: pre;">&#8288;$dict_entry&#8288;</code> field will reflect this value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SelectorScalar-prime"></a>



<h4>Method <code>prime()</code></h4>

<p>See <code><a href="#topic+MiesOperator">MiesOperator</a></code> method. Primes both this operator, as well as the wrapped operator
given to <code>scalor</code> during construction.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorScalar$prime(param_set)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_set</code></dt><dd><p>(<code><a href="paradox.html#topic+ParamSet">ParamSet</a></code>)<br />
Passed to <code><a href="#topic+MiesOperator">MiesOperator</a></code><code style="white-space: pre;">&#8288;$prime()&#8288;</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="base.html#topic+invisible">invisible</a> <code>self</code>.
</p>


<hr>
<a id="method-SelectorScalar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SelectorScalar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other base classes: 
<code><a href="#topic+Filtor">Filtor</a></code>,
<code><a href="#topic+FiltorSurrogate">FiltorSurrogate</a></code>,
<code><a href="#topic+MiesOperator">MiesOperator</a></code>,
<code><a href="#topic+Mutator">Mutator</a></code>,
<code><a href="#topic+MutatorDiscrete">MutatorDiscrete</a></code>,
<code><a href="#topic+MutatorNumeric">MutatorNumeric</a></code>,
<code><a href="#topic+OperatorCombination">OperatorCombination</a></code>,
<code><a href="#topic+Recombinator">Recombinator</a></code>,
<code><a href="#topic+RecombinatorPair">RecombinatorPair</a></code>,
<code><a href="#topic+Scalor">Scalor</a></code>,
<code><a href="#topic+Selector">Selector</a></code>
</p>
<p>Other selectors: 
<code><a href="#topic+Selector">Selector</a></code>,
<code><a href="#topic+dict_selectors_best">dict_selectors_best</a></code>,
<code><a href="#topic+dict_selectors_maybe">dict_selectors_maybe</a></code>,
<code><a href="#topic+dict_selectors_null">dict_selectors_null</a></code>,
<code><a href="#topic+dict_selectors_proxy">dict_selectors_proxy</a></code>,
<code><a href="#topic+dict_selectors_random">dict_selectors_random</a></code>,
<code><a href="#topic+dict_selectors_sequential">dict_selectors_sequential</a></code>,
<code><a href="#topic+dict_selectors_tournament">dict_selectors_tournament</a></code>
</p>

<hr>
<h2 id='terminator_get_generations'>Get the Numger of Generations that a Terminator Allows</h2><span id='topic+terminator_get_generations'></span>

<h3>Description</h3>

<p>Get the number of generations of a <code><a href="#topic+TerminatorGenerations">TerminatorGenerations</a></code>. When the <code><a href="#topic+TerminatorGenerations">TerminatorGenerations</a></code>
is wrapped in a <code><a href="bbotk.html#topic+mlr_terminators_combo">TerminatorCombo</a></code>, then the minimum number of generations
allowed by it are retrieved. This is the minimum of all <code>terminator_get_generations</code> if <code style="white-space: pre;">&#8288;$any&#8288;</code> is set
to <code>TRUE</code>, and the maximum if <code style="white-space: pre;">&#8288;$any&#8288;</code> is set to <code>FALSE</code>.
</p>
<p>The number of generations allowed by other <code><a href="bbotk.html#topic+Terminator">Terminator</a></code>s is infinity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminator_get_generations(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terminator_get_generations_+3A_x">x</code></td>
<td>
<p>(<code><a href="bbotk.html#topic+Terminator">Terminator</a></code>)<br />
<code><a href="bbotk.html#topic+Terminator">Terminator</a></code> to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric(1)</code>: The theoretical maximum number of generations allowed by the <code><a href="bbotk.html#topic+Terminator">Terminator</a></code>.
</p>

<hr>
<h2 id='TuningInstanceMultiCrit'>TuningInstanceMultiCrit Class</h2><span id='topic+TuningInstanceMultiCrit'></span>

<h3>Description</h3>

<p><code>mlr3tuning</code>'s <code>TuningInstanceMultiCrit</code> class.
Re-exported since <code>mlr3tuning</code> will change the name.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TuningInstanceBatchMultiCrit">mlr3tuning::TuningInstanceBatchMultiCrit</a></code> -&gt; <code>TuningInstanceMultiCrit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TuningInstanceMultiCrit-clone"><code>TuningInstanceMultiCrit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TuningInstanceBatchMultiCrit" data-id="assign_result"><a href='../../mlr3tuning/html/TuningInstanceBatchMultiCrit.html#method-TuningInstanceBatchMultiCrit-assign_result'><code>mlr3tuning::TuningInstanceBatchMultiCrit$assign_result()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TuningInstanceBatchMultiCrit" data-id="initialize"><a href='../../mlr3tuning/html/TuningInstanceBatchMultiCrit.html#method-TuningInstanceBatchMultiCrit-initialize'><code>mlr3tuning::TuningInstanceBatchMultiCrit$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TuningInstanceMultiCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TuningInstanceMultiCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='TuningInstanceSingleCrit'>TuningInstanceSingleCrit Class</h2><span id='topic+TuningInstanceSingleCrit'></span>

<h3>Description</h3>

<p><code>mlr3tuning</code>'s <code>TuningInstanceSingleCrit</code> class.
Re-exported since <code>mlr3tuning</code> will change the name.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TuningInstanceBatchSingleCrit">mlr3tuning::TuningInstanceBatchSingleCrit</a></code> -&gt; <code>TuningInstanceSingleCrit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TuningInstanceSingleCrit-clone"><code>TuningInstanceSingleCrit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="print"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-print'><code>bbotk::OptimInstance$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TuningInstanceBatchSingleCrit" data-id="assign_result"><a href='../../mlr3tuning/html/TuningInstanceBatchSingleCrit.html#method-TuningInstanceBatchSingleCrit-assign_result'><code>mlr3tuning::TuningInstanceBatchSingleCrit$assign_result()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TuningInstanceBatchSingleCrit" data-id="initialize"><a href='../../mlr3tuning/html/TuningInstanceBatchSingleCrit.html#method-TuningInstanceBatchSingleCrit-initialize'><code>mlr3tuning::TuningInstanceBatchSingleCrit$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TuningInstanceSingleCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TuningInstanceSingleCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
