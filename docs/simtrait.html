<!DOCTYPE html><html lang="en"><head><title>Help for package simtrait</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simtrait}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simtrait'><p>simtrait: simulate complex traits from genotypes</p></a></li>
<li><a href='#allele_freqs'><p>Compute locus allele frequencies</p></a></li>
<li><a href='#cov_trait'><p>The model covariance matrix of the trait</p></a></li>
<li><a href='#herit_loci'><p>Per-locus heritability contribution from allele frequency and causal coefficient</p></a></li>
<li><a href='#pval_aucpr'><p>Area under the precision-recall curve</p></a></li>
<li><a href='#pval_infl'><p>Calculate inflation factor from p-values</p></a></li>
<li><a href='#pval_power_calib'><p>Estimate calibrated power</p></a></li>
<li><a href='#pval_srmsd'><p>Signed RMSD measure of null p-value uniformity</p></a></li>
<li><a href='#pval_type_1_err'><p>Estimate type I error rate</p></a></li>
<li><a href='#rmsd'><p>Root mean square deviation</p></a></li>
<li><a href='#sim_trait'><p>Simulate a complex trait from genotypes</p></a></li>
<li><a href='#sim_trait_mvn'><p>Simulate traits from a kinship matrix under the infinitesimal model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulate Complex Traits from Genotypes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate complex traits given a SNP genotype matrix and model parameters (the desired heritability, number of causal loci, and either the true ancestral allele frequencies used to generate the genotypes or the mean kinship for a real dataset).  Emphasis on avoiding common biases due to the use of estimated allele frequencies.  The code selects random loci to be causal, constructs coefficients for these loci and random independent non-genetic effects, and can optionally generate random group effects.  Traits can follow three models: random coefficients, fixed effect sizes, and infinitesimal (multivariate normal).  GWAS method benchmarking functions are also provided.  Described in Yao and Ochoa (2022) &lt;<a href="https://doi.org/10.1101%2F2022.03.25.485885">doi:10.1101/2022.03.25.485885</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>PRROC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>popkin, testthat, knitr, rmarkdown, bnpsd, BEDMatrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/OchoaLab/simtrait">https://github.com/OchoaLab/simtrait</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OchoaLab/simtrait/issues">https://github.com/OchoaLab/simtrait/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 16:33:52 UTC; viiia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alejandro Ochoa <a href="https://orcid.org/0000-0003-4928-3403"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alejandro Ochoa &lt;alejandro.ochoa@duke.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simtrait'>simtrait: simulate complex traits from genotypes</h2><span id='topic+simtrait'></span><span id='topic+simtrait-package'></span>

<h3>Description</h3>

<p>This package enables simulation of complex (polygenic and continuous) traits from a simulated or real genotype matrix.
The focus is on constructing the mean and covariance structure of the data to yield the desired heritability.
The main function is <code><a href="#topic+sim_trait">sim_trait()</a></code>, which returns the simulated trait and the vector of causal loci (randomly selected) and their coefficients.
The causal coefficients are constructed under two models: <em>random coefficients</em> (RC) and <em>fixed effect sizes</em> (FES).
The function <code><a href="#topic+cov_trait">cov_trait()</a></code> computes the expected covariance matrix of the trait given the model parameters (namely the desired heritability and the true kinship matrix).
Infinitesimal traits (without causal loci) can also be simulated using <code><a href="#topic+sim_trait_mvn">sim_trait_mvn()</a></code>.
</p>


<h3>Details</h3>

<p>Package also provides some functions for evaluating genetic association approaches.
<code><a href="#topic+pval_srmsd">pval_srmsd()</a></code> and <code><a href="#topic+pval_infl">pval_infl()</a></code> quantify null p-value accuracy, while <code><a href="#topic+pval_aucpr">pval_aucpr()</a></code> quantifies predictive power.
</p>
<p>The recommended inputs are simulated genotypes with known ancestral allele frequencies.
The <code>bnpsd</code> package simulates genotypes for admixed individuals, resulting in a complex population structure.
</p>
<p>For real data it is necessary to estimate the kinship matrix.
<code><a href="popkin.html#topic+popkin">popkin::popkin()</a></code>' provides high-accuracy kinship estimates.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alejandro Ochoa <a href="mailto:alejandro.ochoa@duke.edu">alejandro.ochoa@duke.edu</a> (<a href="https://orcid.org/0000-0003-4928-3403">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/OchoaLab/simtrait">https://github.com/OchoaLab/simtrait</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OchoaLab/simtrait/issues">https://github.com/OchoaLab/simtrait/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># construct a dummy genotype matrix
X &lt;- matrix(
    data = c(
        0, 1, 2,
        1, 2, 1,
        0, 0, 1
    ),
    nrow = 3,
    byrow = TRUE
)
# made up ancestral allele frequency vector for example
p_anc &lt;- c(0.5, 0.6, 0.2)
# desired heritability
herit &lt;- 0.8
# create a dummy kinship matrix for example
# make sure it is positive definite!
kinship &lt;- matrix(
    data = c(
        0.6, 0.1, 0.0,
        0.1, 0.5, 0.0,
        0.0, 0.0, 0.5
    ),
    nrow = 3
)

# create simulated trait and associated data
# default is *random coefficients* (RC) model
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, p_anc = p_anc)
# trait vector
obj$trait
# randomly-picked causal locus indeces
obj$causal_indexes
# regression coefficient vector
obj$causal_coeffs

# *fixed effect sizes* (FES) model
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, p_anc = p_anc, fes = TRUE)

# either model, can apply to real data by replacing `p_anc` with `kinship`
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, kinship = kinship)

# covariance of simulated traits
V &lt;- cov_trait(kinship = kinship, herit = herit)

# draw simulated traits (matrix of replicates) from infinitesimal model
traits &lt;- sim_trait_mvn( rep = 10, kinship = kinship, herit = herit )
traits

# Metrics for genetic association approaches

# simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# for toy example, take these p-value to be truly causal
causal_indexes &lt;- c(1, 5, 7)

# calculate desired measures
# this one quantifies p-value uniformity
pval_srmsd( pvals, causal_indexes )
# related, calculates inflation factors
pval_infl( pvals )
# this one quantifies predictive power
pval_aucpr( pvals, causal_indexes )


</code></pre>

<hr>
<h2 id='allele_freqs'>Compute locus allele frequencies</h2><span id='topic+allele_freqs'></span>

<h3>Description</h3>

<p>On a regular matrix, this is essentially a wrapper for <code><a href="base.html#topic+colMeans">colMeans()</a></code> or <code><a href="base.html#topic+rowMeans">rowMeans()</a></code> depending on <code>loci_on_cols</code>.
On a BEDMatrix object, the locus allele frequencies are computed keeping memory usage low.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele_freqs(X, loci_on_cols = FALSE, fold = FALSE, m_chunk_max = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allele_freqs_+3A_x">X</code></td>
<td>
<p>The genotype matrix (regular R matrix or BEDMatrix object).
Missing values are ignored in averages.</p>
</td></tr>
<tr><td><code id="allele_freqs_+3A_loci_on_cols">loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>X</code> has loci on columns and individuals on rows; if false (the default), loci are on rows and individuals on columns.
If <code>X</code> is a BEDMatrix object, code assumes loci on columns (<code>loci_on_cols</code> is ignored).</p>
</td></tr>
<tr><td><code id="allele_freqs_+3A_fold">fold</code></td>
<td>
<p>If <code>TRUE</code>, allele frequencies are converted to minor allele frequencies.
Default is to return frequencies for the given allele counts in <code>X</code> (regardless of whether it is the minor or major allele).</p>
</td></tr>
<tr><td><code id="allele_freqs_+3A_m_chunk_max">m_chunk_max</code></td>
<td>
<p>BEDMatrix-specific, sets the maximum number of loci to process at the time.
If memory usage is excessive, set to a lower value than default (expected only for extremely large numbers of individuals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of allele frequencies, one per locus.
Names are set to the locus names, if present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct toy data
X &lt;- matrix(
    c(0, 1, 2,
      1, 0, 1,
      1, NA, 2),
    nrow = 3,
    byrow = TRUE
)

# row means
allele_freqs(X)
c(1/2, 1/3, 3/4)

# row means, in minor allele frequencies
allele_freqs(X, fold = TRUE)
c(1/2, 1/3, 1/4)

# col means
allele_freqs(X, loci_on_cols = TRUE)
c(1/3, 1/4, 5/6)

</code></pre>

<hr>
<h2 id='cov_trait'>The model covariance matrix of the trait</h2><span id='topic+cov_trait'></span>

<h3>Description</h3>

<p>This function returns the expected covariance matrix of trait vectors simulated via <code><a href="#topic+sim_trait">sim_trait()</a></code> and <code><a href="#topic+sim_trait_mvn">sim_trait_mvn()</a></code>.
Below there are <code>n</code> individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_trait(kinship, herit, sigma_sq = 1, labs = NULL, labs_sigma_sq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cov_trait_+3A_kinship">kinship</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> kinship matrix of the individuals.
These values should be scaled such that an outbred individual has 1/2 self-kinship, the parent-child relationship is 1/4, etc (which is half the values sometimes defined for kinship).</p>
</td></tr>
<tr><td><code id="cov_trait_+3A_herit">herit</code></td>
<td>
<p>The desired heritability (proportion of trait variance due to genetics).</p>
</td></tr>
<tr><td><code id="cov_trait_+3A_sigma_sq">sigma_sq</code></td>
<td>
<p>The desired parametric variance factor of the trait (scalar, default 1).
Corresponds to the variance of an outbred individual.</p>
</td></tr>
<tr><td><code id="cov_trait_+3A_labs">labs</code></td>
<td>
<p>Optional labels assigning individuals to groups, to simulate group effects.
If vector, length must be number of individuals.
If matrix, individuals must be along rows, and levels along columns (for multiple levels of group effects).
The levels are not required to be nested (as the name may falsely imply).
Values can be numeric or strings, simply assigning the same values to individuals in the same group.
If this is non-<code>NULL</code>, then <code>labs_sigma_sq</code> must also be given!</p>
</td></tr>
<tr><td><code id="cov_trait_+3A_labs_sigma_sq">labs_sigma_sq</code></td>
<td>
<p>Optional vector of group effect variance proportions, one value for each level given in <code>labs</code> (a scalar if <code>labs</code> is a vector, otherwise its length should be the number of columns of <code>labs</code>).
Ignored unless <code>labs</code> is also given.
As these are variance proportions, each value must be non-negative and <code>sum(labs_sigma_sq) + herit &lt;= 1</code> is required so residual variance is non-negative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code>-by-<code>n</code> trait covariance matrix, which under no environment effects equals
<code>sigma_sq * ( herit * 2 * kinship + sigma_sq_residual * I )</code>,
where <code>I</code> is the <code>n</code>-by-<code>n</code> identity matrix and <code>sigma_sq_residual = 1 - herit</code>.
If there are labels, covariance will include the specified block diagonal effects and <code>sigma_sq_residual = 1 - herit - sum(labs_sigma_sq)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_trait">sim_trait()</a></code>, <code><a href="#topic+sim_trait_mvn">sim_trait_mvn()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a dummy kinship matrix
kinship &lt;- matrix(
    data = c(
        0.6, 0.1, 0.0,
        0.1, 0.6, 0.1,
        0.0, 0.1, 0.6
    ),
    nrow = 3,
    byrow = TRUE
)
# covariance of simulated traits
V &lt;- cov_trait(kinship = kinship, herit = 0.8)

</code></pre>

<hr>
<h2 id='herit_loci'>Per-locus heritability contribution from allele frequency and causal coefficient</h2><span id='topic+herit_loci'></span>

<h3>Description</h3>

<p>Calculates the vector of per-locus heritability values, with each causal locus <code>i</code> calculated as
<code>h_i^2 = 2 * p_i * ( 1 - p_i ) * beta_i^2 / sigma_sq</code>,
where <code>p_i</code> is the ancestral allele frequency,
<code>beta_i</code> is the causal coefficient,
and <code>sigma_sq</code> is the trait variance scale.
These are all assumed to be true parameters (not estimated).
These per-locus heritabilities equal per-locus effect sizes divided by <code>sigma_sq</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herit_loci(p_anc, causal_coeffs, causal_indexes = NULL, sigma_sq = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="herit_loci_+3A_p_anc">p_anc</code></td>
<td>
<p>The ancestral allele frequency vector.</p>
</td></tr>
<tr><td><code id="herit_loci_+3A_causal_coeffs">causal_coeffs</code></td>
<td>
<p>The vector of causal coefficients.</p>
</td></tr>
<tr><td><code id="herit_loci_+3A_causal_indexes">causal_indexes</code></td>
<td>
<p>The optional vector of causal indexes.
If <code>NULL</code> (default), <code>p_anc</code> and <code>causal_coeffs</code> are assumed to be for causal loci only (must be the same length).
If non-<code>NULL</code>, <code>causal_loci</code> is used to subset both <code>p_anc</code> and <code>causal_coeffs</code> as needed: if each of these vectors is longer than <code>causal_loci</code>, then it is subset; otherwise they must have equal lengths as <code>causal_loci</code> or an error is thrown.</p>
</td></tr>
<tr><td><code id="herit_loci_+3A_sigma_sq">sigma_sq</code></td>
<td>
<p>The parametric variance factor of the trait (default 1).
This factor corresponds to the variance of an outbred individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of per-locus heritability contributions.
The sum of these values gives the overall heritability.
This value can be greater than one (or wrong, more generally) if <code>sigma_sq</code> is misspecified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_trait">sim_trait()</a></code> generates random traits by drawing causal loci and their coefficients to fit a desired heritability.
<code><a href="#topic+cov_trait">cov_trait()</a></code> calculates the covariance structure of the random traits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create toy random data
m_loci &lt;- 10
# ancestral allele frequencies
p_anc &lt;- runif( m_loci )
# causal loci
causal_coeffs &lt;- rnorm( m_loci ) / m_loci
# resulting heritability contributions vector
herit_loci( p_anc, causal_coeffs )

</code></pre>

<hr>
<h2 id='pval_aucpr'>Area under the precision-recall curve</h2><span id='topic+pval_aucpr'></span>

<h3>Description</h3>

<p>Calculates the Precision-Recall (PR) Area Under the Curve (AUC) given a vector of p-values and the true classes (causal (alternative) vs non-causal (null)).
This is a wrapper around <code><a href="PRROC.html#topic+pr.curve">PRROC::pr.curve()</a></code>, which actually calculates the AUC (see that for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_aucpr(pvals, causal_indexes, curve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_aucpr_+3A_pvals">pvals</code></td>
<td>
<p>The vector of association p-values to analyze.
<code>NA</code> values are allowed in input, are internally set to 1 (worst score) prior to AUC calculation (to prevent methods to get good AUCs by setting more cases to <code>NA</code>).
Non-<code>NA</code> values outside of [0,1] will trigger an error.</p>
</td></tr>
<tr><td><code id="pval_aucpr_+3A_causal_indexes">causal_indexes</code></td>
<td>
<p>The vector of causal indexes, defining the true classes used for AUC calculation.
Values of <code>causal_indexes</code> as returned by <code>sim_trait</code> work.
There must be at least one causal index and at least one non-causal case.</p>
</td></tr>
<tr><td><code id="pval_aucpr_+3A_curve">curve</code></td>
<td>
<p>If <code>FALSE</code> (default), only scalar AUC is returned.
If <code>TRUE</code>, then <code>curve = TRUE</code> is passed to <code><a href="PRROC.html#topic+pr.curve">PRROC::pr.curve()</a></code> and the full object (class <code>PRROC</code>) is returned (see below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>curve = FALSE</code>, returns the PR AUC scalar value.
If <code>curve = TRUE</code>, returns the <code>PRROC</code> object as returned by <code><a href="PRROC.html#topic+pr.curve">PRROC::pr.curve()</a></code>, which can be plotted directly, and which contains the AUC under the named value <code>auc.integral</code>.
</p>
<p>However, if the input <code>pvals</code> is <code>NULL</code> (taken for case of singular association test, which is rare but may happen), then the returned value is <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="PRROC.html#topic+pr.curve">PRROC::pr.curve()</a></code>, which is used internally by this function.
</p>
<p><code><a href="#topic+pval_power_calib">pval_power_calib()</a></code> for calibrated power estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# for toy example, take the first two p-values to be truly causal
causal_indexes &lt;- 1:2
# calculate desired measure
pval_aucpr( pvals, causal_indexes )

</code></pre>

<hr>
<h2 id='pval_infl'>Calculate inflation factor from p-values</h2><span id='topic+pval_infl'></span>

<h3>Description</h3>

<p>The inflation factor is defined as the median association test statistic divided by the expected median under the null hypothesis, which is typically assumed to have a chi-squared distribution.
This function takes a p-value distribution and maps its median back to the chi-squared value (using the quantile function) in order to compute the inflation factor in the chi-squared scale.
The full p-value distribution (a mix of null and alternative cases) is used to calculate the desired median value (the true <code>causal_loci</code> is not needed, unlike <code><a href="#topic+pval_srmsd">pval_srmsd()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_infl(pvals, df = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_infl_+3A_pvals">pvals</code></td>
<td>
<p>The vector of association p-values to analyze.
This function assumes all p-values are provided (a mix of null and alternative tests).
<code>NA</code> values are allowed in input and removed.
Non-<code>NA</code> values outside of [0, 1] will trigger an error.</p>
</td></tr>
<tr><td><code id="pval_infl_+3A_df">df</code></td>
<td>
<p>The degrees of freedom of the assumed chi-squared distribution (default 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inflation factor
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pval_srmsd">pval_srmsd()</a></code>, a more robust measure of null p-value accuracy, but which requires knowing the true causal loci.
</p>
<p><code><a href="#topic+pval_type_1_err">pval_type_1_err()</a></code> for classical type I error rate estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# calculate desired measure
pval_infl( pvals )

</code></pre>

<hr>
<h2 id='pval_power_calib'>Estimate calibrated power</h2><span id='topic+pval_power_calib'></span>

<h3>Description</h3>

<p>Given a significance level <code>alpha</code> and p-values with known causal status, this function estimates the calibrated power.
First it estimates the p-value threshold at which the desired type I error of <code>alpha</code> is achieved, then it uses this p-value threshold (not <code>alpha</code>) to estimate statistical power.
Note that these simple empirical estimates are likely to be inaccurate unless the number of p-values is much larger than <code>1/alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_power_calib(pvals, causal_indexes, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_power_calib_+3A_pvals">pvals</code></td>
<td>
<p>The vector of association p-values to analyze.
This function assumes all p-values are provided (a mix of null and alternative tests).
<code>NA</code> values are allowed in input and removed.
Non-<code>NA</code> values outside of [0, 1] will trigger an error.</p>
</td></tr>
<tr><td><code id="pval_power_calib_+3A_causal_indexes">causal_indexes</code></td>
<td>
<p>The vector of causal indexes, defining the true classes used for calibrated power estimation.
Values of <code>causal_indexes</code> as returned by <code>sim_trait</code> work.
There must be at least one causal index and at least one non-causal case.</p>
</td></tr>
<tr><td><code id="pval_power_calib_+3A_alpha">alpha</code></td>
<td>
<p>The desired significance level (default 0.05).
May be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The calibrated power estimates at each <code>alpha</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pval_aucpr">pval_aucpr()</a></code>, a robust proxy for calibrated power that integrates across significance thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# for toy example, take the first two p-values to be truly causal
causal_indexes &lt;- 1:2
# estimate desired measure
pval_power_calib( pvals, causal_indexes )

</code></pre>

<hr>
<h2 id='pval_srmsd'>Signed RMSD measure of null p-value uniformity</h2><span id='topic+pval_srmsd'></span>

<h3>Description</h3>

<p>Quantifies null p-value uniformity by computing the RMSD (root mean square deviation) between the sorted observed null (truly non-causal) p-values and their expected quantiles under a uniform distribution.
Meant as a more robust alternative to the &quot;inflation factor&quot; common in the GWAS literature, which compares median values only and uses all p-values (not just null p-values).
Our signed RMSD, to correspond with the inflation factor, includes a sign that depends on the median null p-value:
positive if this median is <code style="white-space: pre;">&#8288;&lt;= 0.5&#8288;</code> (corresponds with test statistic inflation), negative otherwise (test statistic deflation).
Zero corresponds to uniform null p-values, which arises in expectation only if test statistics have their assumed null distribution (there is no misspecification, including inflation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_srmsd(pvals, causal_indexes, detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_srmsd_+3A_pvals">pvals</code></td>
<td>
<p>The vector of association p-values to analyze.
This function assumes all p-values are provided (a mix of null and alternative tests).
<code>NA</code> values are allowed in input and removed.
Non-<code>NA</code> values outside of [0, 1] will trigger an error.</p>
</td></tr>
<tr><td><code id="pval_srmsd_+3A_causal_indexes">causal_indexes</code></td>
<td>
<p>The vector of causal indexes, whose p-values will be omitted.
Values of <code>causal_indexes</code> as returned by <code>sim_trait</code> work.
This parameter is required to prevent use of this function except when the true status of every test (null vs alternative) is known.
Set to <code>NULL</code> if all loci are truly null (non-causal).
Otherwise, <code>causal_indexes</code> must have at least one causal index.</p>
</td></tr>
<tr><td><code id="pval_srmsd_+3A_detailed">detailed</code></td>
<td>
<p>If <code>FALSE</code> (default) only SRMSD is returned.
If <code>TRUE</code>, sorted null p-values without NAs and their expectations are returned (useful for plots).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>detailed</code> is <code>FALSE</code>, returns the signed RMSD between the observed p-value order statistics and their expectation under true uniformity.
If <code>detailed</code> is <code>TRUE</code>, returns data useful for plots, a named list containing:
</p>

<ul>
<li> <p><code>srmsd</code>: The signed RMSD between the observed p-value order statistics and their expectation under true uniformity.
</p>
</li>
<li> <p><code>pvals_null</code>: Sorted null p-values (observed order statistics).  If any input null p-values were <code>NA</code>, these have been removed here (removed by <code><a href="base.html#topic+sort">sort()</a></code>).
</p>
</li>
<li> <p><code>pvals_unif</code>: Expected order statistics assuming uniform distribution, same length as <code>pvals_null</code>.
</p>
</li></ul>

<p>If the input <code>pvals</code> is <code>NULL</code> (taken for case of singular association test, which is rare but may happen), then the returned value is <code>NA</code> if <code>detailed</code> was <code>FALSE</code>, or otherwise the list contains <code>NA</code>, <code>NULL</code> and <code>NULL</code> for the above three items.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmsd">rmsd()</a></code> for the generic root-mean-square deviation function.
</p>
<p><code><a href="#topic+pval_infl">pval_infl()</a></code> for the more traditional inflation factor, which focuses on the median of the full distribution (combination of causal and null cases).
</p>
<p><code><a href="#topic+pval_type_1_err">pval_type_1_err()</a></code> for classical type I error rate estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# for toy example, take the first p-value to be truly causal (will be ignored below)
causal_indexes &lt;- 1
# calculate desired measure
pval_srmsd( pvals, causal_indexes )

</code></pre>

<hr>
<h2 id='pval_type_1_err'>Estimate type I error rate</h2><span id='topic+pval_type_1_err'></span>

<h3>Description</h3>

<p>Given a significance level and p-values with known causal status, this function estimates the type I error rate, defined as the proportion of null p-values that are below or equal to the threshold.
Note that these simple empirical estimates are likely to be zero unless the number of p-values is much larger than <code>1/alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_type_1_err(pvals, causal_indexes, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval_type_1_err_+3A_pvals">pvals</code></td>
<td>
<p>The vector of association p-values to analyze.
This function assumes all p-values are provided (a mix of null and alternative tests).
<code>NA</code> values are allowed in input and removed.
Non-<code>NA</code> values outside of [0, 1] will trigger an error.</p>
</td></tr>
<tr><td><code id="pval_type_1_err_+3A_causal_indexes">causal_indexes</code></td>
<td>
<p>The vector of causal indexes, whose p-values will be omitted.
Values of <code>causal_indexes</code> as returned by <code>sim_trait</code> work.
This parameter is required to prevent use of this function except when the true status of every test (null vs alternative) is known.
Set to <code>NULL</code> if all loci are truly null (non-causal).
Otherwise, <code>causal_indexes</code> must have at least one causal index.</p>
</td></tr>
<tr><td><code id="pval_type_1_err_+3A_alpha">alpha</code></td>
<td>
<p>The desired significance level (default 0.05).
May be a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type I error rate estimates at each <code>alpha</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pval_srmsd">pval_srmsd()</a></code> to directly quantify null p-value uniformity, a more robust alternative to type I error rate.
</p>
<p><code><a href="#topic+pval_infl">pval_infl()</a></code> for the more traditional inflation factor, which focuses on the median of the full distribution (combination of causal and null cases).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate truly null p-values, which should be uniform
pvals &lt;- runif(10)
# for toy example, take the first p-value to be truly causal (will be ignored below)
causal_indexes &lt;- 1
# estimate desired measure
pval_type_1_err( pvals, causal_indexes )

</code></pre>

<hr>
<h2 id='rmsd'>Root mean square deviation</h2><span id='topic+rmsd'></span>

<h3>Description</h3>

<p>Calculates the euclidean distance between two vectors <code>x</code> and <code>y</code> divided by the square root of the lengths of the vectors.
<code>NA</code> values are ignored by default when calculating the mean squares (so the denominator is the number of non-<code>NA</code> differences).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsd(x, y, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmsd_+3A_x">x</code></td>
<td>
<p>The first vector to compare (required).</p>
</td></tr>
<tr><td><code id="rmsd_+3A_y">y</code></td>
<td>
<p>The second vector to compare (required).
Lengths of <code>x</code> and <code>y</code> must be equal.</p>
</td></tr>
<tr><td><code id="rmsd_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code> (default), <code>NA</code> values are removed before calculating the mean square difference.
If <code>FALSE</code>, any missing values in either <code>x</code> or <code>y</code> result in <code>NA</code> returned.
Passed to <code><a href="base.html#topic+mean">mean()</a></code>, see that for more info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the square root of the mean square difference between <code>x</code> and <code>y</code>, after removing <code>NA</code> comparisons (cases where either is <code>NA</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(10)
y &lt;- rnorm(10)
rmsd( x, y )

</code></pre>

<hr>
<h2 id='sim_trait'>Simulate a complex trait from genotypes</h2><span id='topic+sim_trait'></span>

<h3>Description</h3>

<p>Simulate a complex trait given a SNP genotype matrix and model parameters, which are minimally: the number of causal loci, the heritability, and either the true ancestral allele frequencies used to generate the genotypes or the mean kinship of all individuals.
An optional minimum marginal allele frequency for the causal loci can be set.
The output traits have by default a zero mean and unit variance (for outbred individuals), but those parameters can be modified.
The code selects random loci to be causal, constructs coefficients for these loci (scaled appropriately) and random Normal independent non-genetic effects and random group effects if specified.
There are two models for constructing causal coefficients: random coefficients (RC; default) and fixed effect sizes (FES; i.e., coefficients roughly inversely proportional to allele frequency; use <code>fes = TRUE</code>).
Suppose there are <code>m</code> loci and <code>n</code> individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trait(
  X,
  m_causal,
  herit,
  p_anc = NULL,
  kinship = NULL,
  mu = 0,
  sigma_sq = 1,
  labs = NULL,
  labs_sigma_sq = NULL,
  maf_cut = NA,
  loci_on_cols = FALSE,
  m_chunk_max = 1000,
  fes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_trait_+3A_x">X</code></td>
<td>
<p>The <code>m</code>-by-<code>n</code> genotype matrix (if <code>loci_on_cols = FALSE</code>, transposed otherwise), or a BEDMatrix object.
This is a numeric matrix consisting of reference allele counts (in <code>c(0, 1, 2, NA)</code> for a diploid organism).</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_m_causal">m_causal</code></td>
<td>
<p>The desired number of causal loci.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_herit">herit</code></td>
<td>
<p>The desired heritability (proportion of trait variance due to genetics).</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_p_anc">p_anc</code></td>
<td>
<p>The length-<code>m</code> vector of true ancestral allele frequencies.
Optional but recommended for simulations.
Either this or <code>kinship</code> must be specified.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_kinship">kinship</code></td>
<td>
<p>The mean kinship value of the individuals in the data.
The <code>n</code>-by-<code>n</code> kinship matrix of the individuals in the data is also accepted.
Optional but recommended for real data.
Either this or <code>p_anc</code> must be specified.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_mu">mu</code></td>
<td>
<p>The desired parametric mean value of the trait (scalar, default 0).</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_sigma_sq">sigma_sq</code></td>
<td>
<p>The desired parametric variance factor of the trait (scalar, default 1).
Corresponds to the variance of an outbred individual.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_labs">labs</code></td>
<td>
<p>Optional labels assigning individuals to groups, to simulate group effects.
If vector, length must be number of individuals.
If matrix, individuals must be along rows, and levels along columns (for multiple levels of group effects).
The levels are not required to be nested (as the name may falsely imply).
Values can be numeric or strings, simply assigning the same values to individuals in the same group.
If this is non-<code>NULL</code>, then <code>labs_sigma_sq</code> must also be given!</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_labs_sigma_sq">labs_sigma_sq</code></td>
<td>
<p>Optional vector of group effect variance proportions, one value for each level given in <code>labs</code> (a scalar if <code>labs</code> is a vector, otherwise its length should be the number of columns of <code>labs</code>).
Ignored unless <code>labs</code> is also given.
As these are variance proportions, each value must be non-negative and <code>sum(labs_sigma_sq) + herit &lt;= 1</code> is required so residual variance is non-negative.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_maf_cut">maf_cut</code></td>
<td>
<p>The optional minimum allele frequency threshold (default <code>NA</code>, no threshold).
This prevents rare alleles from being causal in the simulation.
Threshold is applied to the <em>sample</em> allele frequencies and not their true parametric values (<code>p_anc</code>), even if these are available.</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_loci_on_cols">loci_on_cols</code></td>
<td>
<p>If <code>TRUE</code>, <code>X</code> has loci on columns and individuals on rows; if <code>FALSE</code> (the default), loci are on rows and individuals on columns.
If <code>X</code> is a BEDMatrix object, loci are always on the columns (<code>loci_on_cols</code> is ignored).</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_m_chunk_max">m_chunk_max</code></td>
<td>
<p>BEDMatrix-specific, sets the maximum number of loci to process at the time.
If memory usage is excessive, set to a lower value than default (expected only for extremely large numbers of individuals).</p>
</td></tr>
<tr><td><code id="sim_trait_+3A_fes">fes</code></td>
<td>
<p>If <code>TRUE</code>, causal coefficients are inversely proportional to the square root of <code>p_anc * ( 1 - p_anc )</code> (estimated when <code>p_anc</code> is unavailable), which ensures <em>fixed effect sizes</em> (FES) per causal locus.
Signs (+/-) are drawn randomly with equal probability.
If <code>FALSE</code> (the default), <em>random coefficients</em> (RC) are drawn from a standard Normal distribution.
In both cases coefficients are rescaled to result in the desired heritability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To center and scale the trait and locus coefficients vector correctly to the desired parameters (mean, variance, heritability), the parametric ancestral allele frequencies (<code>p_anc</code>) must be known.
This is necessary since in the heritability model the genotypes are random variables (with means given by <code>p_anc</code> and a covariance structure given by <code>p_anc</code> and the kinship matrix), so these genotype distribution parameters are required.
If <code>p_anc</code> are known (true for simulated genotypes), then the trait will have the specified mean and covariance matrix in agreement with <code><a href="#topic+cov_trait">cov_trait()</a></code>.
To simulate traits using real genotypes, where <code>p_anc</code> is unknown, a compromise that works well in practice is possible if the mean <code>kinship</code> is known (see package vignette).
We recommend estimating the mean kinship using the <code>popkin</code> package!
</p>


<h3>Value</h3>

<p>A named list containing:
</p>

<ul>
<li> <p><code>trait</code>: length-<code>n</code> vector of the simulated trait
</p>
</li>
<li> <p><code>causal_indexes</code>: length-<code>m_causal</code> vector of causal locus indexes
</p>
</li>
<li> <p><code>causal_coeffs</code>: length-<code>m_causal</code> vector of coefficients at the causal loci
</p>
</li>
<li> <p><code>group_effects</code>: length-<code>n</code> vector of simulated group effects, or 0 (scalar) if not simulated
</p>
</li></ul>

<p>However, if <code>herit = 0</code> then <code>causal_indexes</code> and <code>causal_coeffs</code> will have zero length regardless of <code>m_causal</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_trait">cov_trait()</a></code>, <code><a href="#topic+sim_trait_mvn">sim_trait_mvn()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a dummy genotype matrix
X &lt;- matrix(
    data = c(
        0, 1, 2,
        1, 2, 1,
        0, 0, 1
    ),
    nrow = 3,
    byrow = TRUE
)
# made up ancestral allele frequency vector for example
p_anc &lt;- c(0.5, 0.6, 0.2)
# made up mean kinship
kinship &lt;- 0.2
# desired heritability
herit &lt;- 0.8

# create simulated trait and associated data
# default is *random coefficients* (RC) model
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, p_anc = p_anc)

# trait vector
obj$trait
# randomly-picked causal locus indexes
obj$causal_indexes
# regression coefficients vector
obj$causal_coeffs

# *fixed effect sizes* (FES) model
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, p_anc = p_anc, fes = TRUE)

# either model, can apply to real data by replacing `p_anc` with `kinship`
obj &lt;- sim_trait(X = X, m_causal = 2, herit = herit, kinship = kinship)

</code></pre>

<hr>
<h2 id='sim_trait_mvn'>Simulate traits from a kinship matrix under the infinitesimal model</h2><span id='topic+sim_trait_mvn'></span>

<h3>Description</h3>

<p>Simulate matrix of trait replicates given a kinship matrix and model parameters (the desired heritability, group effects, total variance scale, and mean).
Although these traits have the covariance structure of genetic traits, and have heritabilities that can be estimated, they do not have causal loci (an association test against any locus should fail).
Below <code>n</code> is the number of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_trait_mvn(
  rep,
  kinship,
  herit,
  mu = 0,
  sigma_sq = 1,
  labs = NULL,
  labs_sigma_sq = NULL,
  tol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_trait_mvn_+3A_rep">rep</code></td>
<td>
<p>The number of replicate traits to simulate.
Simulating all you need at once is more efficient than simulating each separately (the kinship matrix is eigendecomposed once per run, shared across replicates).</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_kinship">kinship</code></td>
<td>
<p>The <code>n</code>-by-<code>n</code> kinship matrix of the individuals to simulate from.</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_herit">herit</code></td>
<td>
<p>The desired heritability (proportion of trait variance due to genetics).</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_mu">mu</code></td>
<td>
<p>The desired parametric mean value of the trait (scalar, default 0).</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_sigma_sq">sigma_sq</code></td>
<td>
<p>The desired parametric variance factor of the trait (scalar, default 1).
Corresponds to the variance of an outbred individual.</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_labs">labs</code></td>
<td>
<p>Optional labels assigning individuals to groups, to simulate group effects.
If vector, length must be number of individuals.
If matrix, individuals must be along rows, and levels along columns (for multiple levels of group effects).
The levels are not required to be nested (as the name may falsely imply).
Values can be numeric or strings, simply assigning the same values to individuals in the same group.
If this is non-<code>NULL</code>, then <code>labs_sigma_sq</code> must also be given!</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_labs_sigma_sq">labs_sigma_sq</code></td>
<td>
<p>Optional vector of group effect variance proportions, one value for each level given in <code>labs</code> (a scalar if <code>labs</code> is a vector, otherwise its length should be the number of columns of <code>labs</code>).
Ignored unless <code>labs</code> is also given.
As these are variance proportions, each value must be non-negative and <code>sum(labs_sigma_sq) + herit &lt;= 1</code> is required so residual variance is non-negative.</p>
</td></tr>
<tr><td><code id="sim_trait_mvn_+3A_tol">tol</code></td>
<td>
<p>Tolerance factor for an internal test of positive semi-definiteness of the trait covariance matrix.
Procedure fails if any eigenvalues are smaller than <code>-tol</code> times the absolute value of the largest eigenvalue.
Increase this value only if you are getting errors but you're sure your covariance matrix (the output of <code><a href="#topic+cov_trait">cov_trait()</a></code>) is positive semi-definite.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>rep</code>-by-<code>n</code> matrix containing the simulated traits along the rows, individuals along the columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov_trait">cov_trait()</a></code>, <code><a href="#topic+sim_trait">sim_trait()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a dummy kinship matrix
# make sure it is positive definite!
kinship &lt;- matrix(
    data = c(
        0.6, 0.1, 0.0,
        0.1, 0.5, 0.0,
        0.0, 0.0, 0.5
    ),
    nrow = 3
)
# draw simulated traits (matrix)
traits &lt;- sim_trait_mvn( rep = 10, kinship = kinship, herit = 0.8 )
traits

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
