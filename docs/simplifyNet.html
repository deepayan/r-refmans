<!DOCTYPE html><html><head><title>Help for package simplifyNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simplifyNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.edges'><p>Add edges</p></a></li>
<li><a href='#bestpath'><p>Sparsification via Best Path</p></a></li>
<li><a href='#DFS'><p>Depth First search</p></a></li>
<li><a href='#EffR'><p>Effective resistances calculator</p></a></li>
<li><a href='#EffRSparse'><p>Sparsification through edge sampling via effective resistances</p></a></li>
<li><a href='#EList_Mtrx'><p>Edge list to adjacency matrix</p></a></li>
<li><a href='#find.neighbors'><p>Find Neighbors</p></a></li>
<li><a href='#gns'><p>Global Network Sparsification</p></a></li>
<li><a href='#igraph.to.elist'><p>igraph to EList</p></a></li>
<li><a href='#irefit'><p>Iterative refitting</p></a></li>
<li><a href='#is.connected'><p>Connectivity of Graph</p></a></li>
<li><a href='#lans'><p>Local Adaptive Network Sparsification</p></a></li>
<li><a href='#Lap'><p>Graph Laplacian calculator</p></a></li>
<li><a href='#Mtrx_EList'><p>Adjacency matrix to edge list</p></a></li>
<li><a href='#net.as'><p>Network format converter</p></a></li>
<li><a href='#normProbs'><p>Normalize probabilities</p></a></li>
<li><a href='#remove.edges'><p>Remove edges</p></a></li>
<li><a href='#rerank'><p>Rerank edges</p></a></li>
<li><a href='#sparse.step'><p>Iterative refitting sparsification step</p></a></li>
<li><a href='#sqrt_WDiag'><p>Diagonal, m by m, weight matrix with <code>sqrt(w_e)</code> on the diagonal.</p></a></li>
<li><a href='#sVIM'><p>Signed vertex incidence matrix</p></a></li>
<li><a href='#WDiag'><p>Diagonal, m by m, weight matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Sparsification</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Mercier &lt;amercier@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Network sparsification with a variety of novel and known network sparsification 
    techniques. All network sparsification techniques reduce the number of edges, not the number 
    of nodes. Network sparsification is sometimes referred to as network dimensionality reduction. 
    This package is based on the work of Spielman, D., Srivastava, N. (2009)&lt;<a href="https://arxiv.org/abs/0803.0929">arXiv:0803.0929</a>&gt;.
    Koutis I., Levin, A., Peng, R. (2013)&lt;<a href="https://arxiv.org/abs/1209.5821">arXiv:1209.5821</a>&gt;. Toivonen, H., Mahler, S., Zhou, F. 
    (2010)&lt;<a href="https://doi.org/10.1007">doi:10.1007</a>&gt;. Foti, N., Hughes, J., Rockmore, D. (2011)&lt;<a href="https://doi.org/10.1371">doi:10.1371</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4),</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 1.3.1), sanic (&ge; 0.0.1), Matrix (&ge; 1.2-18),
methods (&ge; 4.0.2), stats (&ge; 4.0.2), dplyr (&ge; 1.0.9)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-07 18:41:16 UTC; henry</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Kramer [aut],
  Alexander Mercier [aut, cre, trl],
  Shubhankar Tripathi [ctb],
  Tomlin Pulliam [ctb],
  John Drake <a href="https://orcid.org/0000-0003-4646-1235"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.edges'>Add edges</h2><span id='topic+add.edges'></span>

<h3>Description</h3>

<p>Add edges for iterative refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.edges(per, E_List, S_List)
</code></pre>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return an expanded edge list with an increased number of edges determined by <code>per</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='bestpath'>Sparsification via Best Path</h2><span id='topic+bestpath'></span>

<h3>Description</h3>

<p>Calculates network sparsifier from best path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestpath(network, directed = FALSE, associative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestpath_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="bestpath_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, specifies that the inputted network is directed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bestpath_+3A_associative">associative</code></td>
<td>
<p>Designates if the network is associative where edge weight determines &quot;similarity&quot; or &quot;strength&quot; or dissociative where edge weight denotes &quot;dissimilarity&quot; or &quot;distance&quot;.<br />
If the network is associative, then the shortest path would be found by looking at <code>w_e^-1</code> where weaker association between nodes suggests a larger distance between nodes for shortest paths. <br />
If the network is dissociative, then the shortest path would be between <code>w_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Edge list of sparsified network via best path.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>
<p>Andrew Kramer
</p>


<h3>References</h3>

<p>Toivonen, H., Mahler, S., &amp; Zhou, F. (2010, May). A framework for path-oriented network simplification. In International Symposium on Intelligent Data Analysis (pp. 220-231). Springer, Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate random ER graph with uniformly random edge weights
g = igraph::erdos.renyi.game(50, 0.1)
igraph::E(g)$weight &lt;- runif(length(igraph::E(g)))
#Sparsify g via bestpath
S = simplifyNet::bestpath(g, directed = FALSE, associative = TRUE) #Show edge list conversion
sg = simplifyNet::net.as(S, net.to="igraph", directed=FALSE)
igraph::ecount(sg)/igraph::ecount(g)#fraction of edges in the sparsifier
</code></pre>

<hr>
<h2 id='DFS'>Depth First search</h2><span id='topic+DFS'></span>

<h3>Description</h3>

<p>Iterative depth first search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFS(Adj, v, discovered)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFS_+3A_adj">Adj</code></td>
<td>
<p>Adjacency matrix.</p>
</td></tr>
<tr><td><code id="DFS_+3A_v">v</code></td>
<td>
<p>Node to perform DFS from.</p>
</td></tr>
<tr><td><code id="DFS_+3A_discovered">discovered</code></td>
<td>
<p>A list of discovered nodes from <code>v</code>. If initializing the search, should be all FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Logical of length n where TRUE denotes connected to node <code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='EffR'>Effective resistances calculator</h2><span id='topic+EffR'></span>

<h3>Description</h3>

<p>Calculate or approximate the effective resistances of an inputted, undirected graph. There are three methods. <br />
(1) 'ext' which exactly calculates the effective resistances (WARNING! Not ideal for large graphs).<br />
(2) 'spl' which approximates the effective resistances of the inputted graph using the original Spielman-Srivastava algorithm.<br />
(3) 'kts' which approximates the effective resistances of the inputted graph using the implementation by Koutis et al. (ideal for large graphs where memory usage is a concern).<br />
The relative fidelity of the approximation methods is governed by the variable epsilon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EffR(network, epsilon = 0.1, type = "kts", tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EffR_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="EffR_+3A_epsilon">epsilon</code></td>
<td>
<p>Variable epsilon governs the relative fidelity of the approximation methods 'spl' and 'kts'. The smaller the value the greater the fidelity of the approximation. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="EffR_+3A_type">type</code></td>
<td>
<p>There are three methods. <br />
(1) 'ext' which exactly calculates the effective resistances (WARNING! Not ideal for large graphs).<br />
(2) 'spl' which approximates the effective resistances of the inputted graph using the original Spielman-Srivastava algorithm.<br />
(3) 'kts' which approximates the effective resistances of the inputted graph using the implementation by Koutis et al. (ideal for large graphs where memory usage is a concern).</p>
</td></tr>
<tr><td><code id="EffR_+3A_tol">tol</code></td>
<td>
<p>Tolerance for the linear algebra (conjugate gradient) solver to find the effective resistances. Default value is 1e-10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fidelity of the effective resistance approximation decreases with a decrease in <code>epsilon</code>. However, it is more important for sparsification by effective resistances that the approximations be roughly equivalent relative to one another, as they will be normalized in a probability distribution where exact values are not needed. <br />
The number of edges contained in the sparsifier will be less than or equal to the number of samples taken, <code>q</code>.
</p>


<h3>Value</h3>

<p>Return either exact or approximate effective resistances for each edge in the same order as &quot;weight&quot; in the edge list.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>


<h3>References</h3>

<p>Spielman, D. A., &amp; Srivastava, N. (2011). Graph sparsification by effective resistances. SIAM Journal on Computing, 40(6), 1913-1926.<br />
Koutis, I., Miller, G. L., &amp; Peng, R. (2014). Approaching optimality for solving SDD linear systems. SIAM Journal on Computing, 43(1), 337-354.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E_List = matrix(c(1,1,2,2,3,3,1,1,1), 3, 3) #Triangle graph, \eqn{K_3}, with edge weights equal to 1
effR = simplifyNet::EffR(E_List, epsilon = 0.1, type = 'kts', tol = 1e-10)
</code></pre>

<hr>
<h2 id='EffRSparse'>Sparsification through edge sampling via effective resistances</h2><span id='topic+EffRSparse'></span>

<h3>Description</h3>

<p>Sparsify an undirected network by sampling edges proportional to <code class="reqn">w_e * R_e</code> where <code class="reqn">w_e</code> is the weight of edge <code class="reqn">e</code> and <code class="reqn">R_e</code> is the effective resistance of edge <code class="reqn">e</code>.<br />
Approximately preserves the graph Laplacian, <code>L</code>, with increasing fidelity as the number of samples taken increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EffRSparse(network, q, effR, seed, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EffRSparse_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="EffRSparse_+3A_q">q</code></td>
<td>
<p>The numbers of samples taken. The fidelity to the original network increases as the number of samples increases, but decreases the sparseness.</p>
</td></tr>
<tr><td><code id="EffRSparse_+3A_effr">effR</code></td>
<td>
<p>Effective resistances corresponding to each edge. Should be in the same order as &quot;weight&quot;.</p>
</td></tr>
<tr><td><code id="EffRSparse_+3A_seed">seed</code></td>
<td>
<p>Set the seed to reproduce results of random sampling.</p>
</td></tr>
<tr><td><code id="EffRSparse_+3A_n">n</code></td>
<td>
<p>The number of nodes in the network. Default is the max node index of the edge list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The performance of this method is dependent on the size of the network and fidelity of the effective resistance approximation. The network should be &quot;sufficiently large.&quot; <br />
For more details, see: https://epubs.siam.org/doi/epdf/10.1137/080734029
</p>


<h3>Value</h3>

<p>A sparsified network, <code>H</code>, edge list where the number of edges is dependent on the number of samples taken, <code>q</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel A. Spielman,
</p>
<p>Alexander Mercier
</p>


<h3>References</h3>

<p>Spielman, D. A., &amp; Srivastava, N. (2011). Graph sparsification by effective resistances. SIAM Journal on Computing, 40(6), 1913-1926.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate random ER graph with uniformly random edge weights
g = igraph::erdos.renyi.game(100, 0.1)
igraph::E(g)$weight &lt;- runif(length(igraph::E(g)))
#Approximate effective resistances
effR = simplifyNet::EffR(g)
#Use effective resistances to create spectral sparsifier by edge sampling
S = simplifyNet::EffRSparse(g, q = 200, effR = effR, seed = 150)
sg = simplifyNet::net.as(S, net.to="igraph", directed=FALSE)
igraph::ecount(sg)/igraph::ecount(g)#fraction of edges in the sparsifier
</code></pre>

<hr>
<h2 id='EList_Mtrx'>Edge list to adjacency matrix</h2><span id='topic+EList_Mtrx'></span>

<h3>Description</h3>

<p>Convert an edge list to an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EList_Mtrx(E_List, directed = FALSE, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EList_Mtrx_+3A_e_list">E_List</code></td>
<td>
<p>Edge list formatted | n1 | n2 | weight |.</p>
</td></tr>
<tr><td><code id="EList_Mtrx_+3A_directed">directed</code></td>
<td>
<p>Specifies if the network is directed or undirected. Default is set to undirected.</p>
</td></tr>
<tr><td><code id="EList_Mtrx_+3A_n">n</code></td>
<td>
<p>Specify number of nodes. Default is <code>max(E_List[,1:2])</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency matrix constructed from edge list, <code>E_List</code>, of the class dgCMatrix.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='find.neighbors'>Find Neighbors</h2><span id='topic+find.neighbors'></span>

<h3>Description</h3>

<p>Finds the neighbors of a given node, <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.neighbors(Adj, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.neighbors_+3A_adj">Adj</code></td>
<td>
<p>Adjacency matrix</p>
</td></tr>
<tr><td><code id="find.neighbors_+3A_v">v</code></td>
<td>
<p>Node to find the neighbors of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Integers designating node indices of the adjacency matrix for the neighbors of <code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='gns'>Global Network Sparsification</h2><span id='topic+gns'></span>

<h3>Description</h3>

<p>Remove all edges under certain edge weight threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gns(network, remove.prop, cutoff, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gns_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="gns_+3A_remove.prop">remove.prop</code></td>
<td>
<p>The proportion of highest weighted edges to retain. A value between 0 and 1.</p>
</td></tr>
<tr><td><code id="gns_+3A_cutoff">cutoff</code></td>
<td>
<p>Threshold value for edge weight thresholding.</p>
</td></tr>
<tr><td><code id="gns_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, specifies that the inputted network is directed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Edge list of sparsified network
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate random ER graph with uniformly random edge weights
g = igraph::erdos.renyi.game(100, 0.1)
igraph::E(g)$weight &lt;- runif(length(igraph::E(g)))
#Sparsify g via GNS
S = gns(g, remove.prop = 0.5)
sg = simplifyNet::net.as(S, net.to="igraph", directed=FALSE)
igraph::ecount(sg)/igraph::ecount(g)#fraction of edges in the sparsifier
</code></pre>

<hr>
<h2 id='igraph.to.elist'>igraph to EList</h2><span id='topic+igraph.to.elist'></span>

<h3>Description</h3>

<p>Convert igraph object to edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.to.elist(g)
</code></pre>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return an edge list with weights from an igraph object.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='irefit'>Iterative refitting</h2><span id='topic+irefit'></span>

<h3>Description</h3>

<p>Iterative sparsifcation based refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irefit(
  network,
  func,
  tol,
  rank = "none",
  connected = FALSE,
  directed = FALSE,
  per = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irefit_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="irefit_+3A_func">func</code></td>
<td>
<p>Model function whose input is the network and whose output is a single real value or a list of reevaluated weights in the first index and a real value in the second.<br />
A wrapper function may have to be written.</p>
</td></tr>
<tr><td><code id="irefit_+3A_tol">tol</code></td>
<td>
<p>Allowed error around the original output of <code>func</code> approximated by the sparsified network within which edges are removed. Specifies if method converges.</p>
</td></tr>
<tr><td><code id="irefit_+3A_rank">rank</code></td>
<td>
<p>Ranking of edges. Lower ranked edges are removed first. Must be the same length as <code>nrow(E_List)</code>.</p>
</td></tr>
<tr><td><code id="irefit_+3A_connected">connected</code></td>
<td>
<p>If TRUE, connectivity of the network is prioritized over scoring by <code>func</code>.</p>
</td></tr>
<tr><td><code id="irefit_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, specifies that the inputted network is directed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="irefit_+3A_per">per</code></td>
<td>
<p>Percentage of edges to add/remove from the sparsifier at each step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparsified network, <code>H</code>, which still maintains evaluator function, <code>func</code>, plus/minus <code>tol</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>
<p>Andrew Kramer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Set scoring function
mean.weight.degree &lt;- function(graph){
graph.ob &lt;- igraph::graph_from_edgelist(graph[,1:2])
igraph::E(graph.ob)$weight &lt;- graph[,3]
return(mean(igraph::strength(graph.ob)))
}

#Generate random graph
g &lt;- igraph::erdos.renyi.game(100, 0.1)
igraph::E(g)$weight &lt;- rexp(length(igraph::E(g)), rate=10) #random edge weights from exp(10)
E_List &lt;- cbind(igraph::as_edgelist(g), igraph::E(g)$weight)
colnames(E_List) &lt;- c("n1", "n2", "weight")
sparse_dist &lt;- simplifyNet::irefit(E_List, func=mean.weight.degree, tol = 0.1)
</code></pre>

<hr>
<h2 id='is.connected'>Connectivity of Graph</h2><span id='topic+is.connected'></span>

<h3>Description</h3>

<p>Tests the connectivity of a graph by performing a Depth First Search (DFS) from a random node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connected(Adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected_+3A_adj">Adj</code></td>
<td>
<p>Adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return TRUE if network is connected and FALSE if not connected.If the network is directed, then this function checks if the network is strongly connected.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='lans'>Local Adaptive Network Sparsification</h2><span id='topic+lans'></span>

<h3>Description</h3>

<p>Remove all edges under certain probability of the fractional edge weight, <code>alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lans(network, alpha, output, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lans_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="lans_+3A_alpha">alpha</code></td>
<td>
<p>The <code>alpha</code> value is a predetermined threshold to designate statistically important edges by their fractional edge weight at each node. If the probability of choosing that edge via the CDF is less than or equal to <code>alpha</code>, then the edge is not included.</p>
</td></tr>
<tr><td><code id="lans_+3A_output">output</code></td>
<td>
<p>If the output should be directed or undirected. Default is that the output is the same as the input based on adjacency matrix symmetry. If the default is overridden, set as either &quot;undirected&quot; or &quot;directed&quot;.</p>
</td></tr>
<tr><td><code id="lans_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, specifies that the inputted network is directed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on finding alpha values, see: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0016431#s5
</p>


<h3>Value</h3>

<p>Weighted adjacency matrix of sparsified network.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>


<h3>References</h3>

<p>Foti, N. J., Hughes, J. M., &amp; Rockmore, D. N. (2011). Nonparametric sparsification of complex multiscale networks. PloS one, 6(2), e16431.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate random ER graph with uniformly random edge weights
g = igraph::erdos.renyi.game(100, 0.1)
igraph::E(g)$weight &lt;- runif(length(igraph::E(g)))
#Sparsify g via LANS
S = lans(g, alpha = 0.3, output = "undirected", directed = FALSE)
#Convert sparsifier to edge list
S_List = simplifyNet::Mtrx_EList(S, directed = FALSE)
sg = simplifyNet::net.as(S_List, net.to="igraph", directed=FALSE)
igraph::ecount(sg)/igraph::ecount(g)#fraction of edges in the sparsifier
</code></pre>

<hr>
<h2 id='Lap'>Graph Laplacian calculator</h2><span id='topic+Lap'></span>

<h3>Description</h3>

<p>Find the graph Laplacian from a weighted adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lap(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lap_+3A_a">A</code></td>
<td>
<p>Weighted adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Graph Laplacian, <code>L</code>, of the class dgCMatrix.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(0,1,1,1,0,1,1,1,0), 3 ,3)
L = Lap(A)
</code></pre>

<hr>
<h2 id='Mtrx_EList'>Adjacency matrix to edge list</h2><span id='topic+Mtrx_EList'></span>

<h3>Description</h3>

<p>Convert an adjacency matrix to an edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mtrx_EList(A, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mtrx_EList_+3A_a">A</code></td>
<td>
<p>Weighted adjacency matrix.</p>
</td></tr>
<tr><td><code id="Mtrx_EList_+3A_directed">directed</code></td>
<td>
<p>Specifies if the network is directed or undirected. Default is set to undirected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge list, <code>E_List</code>, of adjacency matrix, <code>A</code>, of the form | n1 | n2 | weight |.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='net.as'>Network format converter</h2><span id='topic+net.as'></span>

<h3>Description</h3>

<p>Convert a network in weighted adjacency matrix, edge list, or igraph to a weighted adjacency matrix, edge list, or igraph format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.as(network, net.to = "E_List", directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.as_+3A_network">network</code></td>
<td>
<p>Weighted adjacency matrix, weighted <code>igraph</code> network, or edge list formatted | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.</p>
</td></tr>
<tr><td><code id="net.as_+3A_net.to">net.to</code></td>
<td>
<p>Specifics to what format the imputed network is to be converted: <br />
(1) 'E_List' convert to an edge list of the format | n1 | n2 | weight | with colnames <code>c("n1", "n2", "weight")</code>.<br />
(2) 'Adj' convert to a weighted adjacency matrix.<br />
(3) 'igraph' convert to a weighted igraph object.</p>
</td></tr>
<tr><td><code id="net.as_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, specifies that the inputted network is directed. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network of the format specified by <code>net.to</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='normProbs'>Normalize probabilities</h2><span id='topic+normProbs'></span>

<h3>Description</h3>

<p>Normalize numerics to probabilities such that the sum of the vector equals 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normProbs(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normProbs_+3A_p">P</code></td>
<td>
<p>Numerics to be normalized to probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return probabilities where their sum is 1.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='remove.edges'>Remove edges</h2><span id='topic+remove.edges'></span>

<h3>Description</h3>

<p>remove edges for iterative refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.edges(per, E_List, S_List)
</code></pre>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return a truncated edge list with a decreased number of edges determined by <code>per</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='rerank'>Rerank edges</h2><span id='topic+rerank'></span>

<h3>Description</h3>

<p>Rerank edges for iterative refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerank(E_List, rank)
</code></pre>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return an edge list reordered according to <code>rank</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='sparse.step'>Iterative refitting sparsification step</h2><span id='topic+sparse.step'></span>

<h3>Description</h3>

<p>Recursive sparsification step for iterative refitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.step(
  E_List,
  S_List,
  stepsize,
  spr_score,
  org_score,
  func,
  tol,
  per,
  connected
)
</code></pre>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return sparsified edge list.
</p>


<h3>Author(s)</h3>

<p>Andrew Kramer
</p>
<p>Alexander Mercier
</p>

<hr>
<h2 id='sqrt_WDiag'>Diagonal, m by m, weight matrix with <code>sqrt(w_e)</code> on the diagonal.</h2><span id='topic+sqrt_WDiag'></span>

<h3>Description</h3>

<p>Calculate the m by m diagonal weight matrix, <code>W</code>, for an inputted graph with <code>sqrt(w_e)</code> on the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrt_WDiag(weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrt_WDiag_+3A_weights">weights</code></td>
<td>
<p>List of edges corresponding to edge list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return diagonal weight matrix, <code>W</code>, with <code class="reqn">\sqrt(w_e)</code> on the diagonal.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

<hr>
<h2 id='sVIM'>Signed vertex incidence matrix</h2><span id='topic+sVIM'></span>

<h3>Description</h3>

<p>Calculate the signed vertex incidence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sVIM(E_List)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sVIM_+3A_e_list">E_List</code></td>
<td>
<p>Edge list formatted | n1 | n2 | weight |.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return a signed, m by n, vertex incidence matrix, <code>B</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>E_List = matrix(c(1,1,2,2,3,3,1,1,1), 3, 3)
colnames(E_List) &lt;- c("n1", "n2", "weight")
B = sVIM(E_List)
</code></pre>

<hr>
<h2 id='WDiag'>Diagonal, m by m, weight matrix</h2><span id='topic+WDiag'></span>

<h3>Description</h3>

<p>Calculate the m by m diagonal weight matrix, <code>W</code>, for an imputed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WDiag(weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WDiag_+3A_weights">weights</code></td>
<td>
<p>List of edges corresponding to edge list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended as internal function.
</p>


<h3>Value</h3>

<p>Return diagonal weight matrix, <code>W</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Mercier
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
