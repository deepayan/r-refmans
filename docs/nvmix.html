<!DOCTYPE html><html lang="en"><head><title>Help for package nvmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nvmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#copula'><p>Functionalities for Normal Variance Mixture Copulas</p></a></li>
<li><a href='#dependencemeasures'><p>Dependence Measures for grouped normal variance mixture copulas</p></a></li>
<li><a href='#dgnvmix'><p>Density of Grouped Normal Variance Mixtures</p></a></li>
<li><a href='#dnvmix'><p>Density of Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#fitnvmix'><p>Fitting Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#gammamix'><p>Functionalities for Gamma Scale Mixture Models</p></a></li>
<li><a href='#get_set_param'><p>Algorithm-specific Parameters</p></a></li>
<li><a href='#get_set_qqplot_param'><p>Plotting parameters for QQ Plots</p></a></li>
<li><a href='#numerical_experiments_data'><p>Data Generated by the Demo 'numerical_experiments'</p></a></li>
<li><a href='#pgnvmix'><p>Distribution Function of Grouped Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#pnvmix'><p>Distribution Function of Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#qnvmix'><p>Quantile Function of a univariate Normal Variance Mixture Distribution</p></a></li>
<li><a href='#qqplot_maha'><p>QQ Plot for Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#rgnvmix'><p>(Quasi-)Random Number Generator for Grouped Normal Variance Mixtures</p></a></li>
<li><a href='#riskmeasures'><p>Risk measures for normal variance mixtures</p></a></li>
<li><a href='#rnvmix'><p>(Quasi-)Random Number Generation for Multivariate Normal Variance Mixtures</p></a></li>
<li><a href='#skewstudent'><p>Functionalities for the skew-t distribution and copula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Normal Variance Mixtures</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for working with (grouped) multivariate normal variance mixture
  distributions (evaluation of distribution functions and densities,
  random number generation and parameter estimation), including
  Student's t distribution for non-integer degrees-of-freedom as well as the grouped t
  distribution and copula with multiple degrees-of-freedom parameters.
  See &lt;<a href="https://doi.org/10.18637%2Fjss.v102.i02">doi:10.18637/jss.v102.i02</a>&gt; for a high-level description of select functionality.</td>
</tr>
<tr>
<td>Author:</td>
<td>Marius Hofert [aut, cre],
  Erik Hintz [aut],
  Christiane Lemieux [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marius Hofert &lt;mhofert@hku.hk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, qrng, Matrix, copula, pcaPP, ADGofTest,
mnormt, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, lattice, qrmdata, xts, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a> | file LICENCE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 16:20:10 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 10:09:34 UTC; mhofert</td>
</tr>
</table>
<hr>
<h2 id='copula'>Functionalities for Normal Variance Mixture Copulas</h2><span id='topic+dnvmixcopula'></span><span id='topic+pnvmixcopula'></span><span id='topic+rnvmixcopula'></span><span id='topic+dStudentcopula'></span><span id='topic+pStudentcopula'></span><span id='topic+rStudentcopula'></span><span id='topic+pgStudentcopula'></span><span id='topic+dgStudentcopula'></span><span id='topic+rgStudentcopula'></span><span id='topic+fitgStudentcopula'></span><span id='topic+fitStudentcopula'></span>

<h3>Description</h3>

<p>Evaluate the density / distribution function of normal variance mixture
copulas (including Student <em>t</em> and normal copula) and generate vectors
of random variates from normal variance mixture copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnvmixcopula(u, qmix, scale = diag(d), factor = NULL, control = list(),
             verbose = FALSE, log = FALSE, ...)
pnvmixcopula(upper, lower = matrix(0, nrow = n, ncol = d), qmix, scale = diag(d),
             control = list(), verbose = FALSE, ...)
rnvmixcopula(n, qmix, scale = diag(2), factor = NULL,
             method = c("PRNG", "sobol", "ghalton"), skip = 0,
             control = list(), verbose = FALSE, ...)

dStudentcopula(u, df, scale = diag(d), factor = NULL, log = FALSE, verbose = TRUE)
pStudentcopula(upper, lower = matrix(0, nrow = n, ncol = d), df, scale = diag(d),
               control = list(), verbose = TRUE)
rStudentcopula(n, df, scale = diag(2), method = c("PRNG", "sobol", "ghalton"),
               skip = 0)

pgStudentcopula(upper, lower = matrix(0, nrow = n, ncol = d), groupings = 1:d,
                df, scale = diag(d), control = list(), verbose = TRUE)
dgStudentcopula(u, groupings = 1:d, df, scale = diag(d), factor = NULL,
                factor.inv = NULL, control = list(), verbose = TRUE, log = FALSE)
rgStudentcopula(n, groupings = 1:d, df, scale = diag(2), factor = NULL,
                method = c("PRNG", "sobol", "ghalton"), skip = 0)

fitgStudentcopula(x, u, df.init = NULL, scale = NULL, groupings = rep(1, d),
                  df.bounds = c(0.5, 30), fit.method = c("joint-MLE",
                  "groupewise-MLE"), control = list(), verbose = TRUE)
fitStudentcopula(u, fit.method = c("Moment-MLE", "EM-MLE", "Full-MLE"),
                 df.init = NULL, df.bounds = c(0.1, 30), control = list(),
                 verbose = TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copula_+3A_u">u</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of evaluation points or data;
Have to be in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_upper">upper</code>, <code id="copula_+3A_lower">lower</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of upper/lower evaluation
limits. Have to be in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_n">n</code></td>
<td>
<p>sample size <code class="reqn">n</code> (positive integer).</p>
</td></tr>
<tr><td><code id="copula_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code>; see
<code><a href="#topic+pnvmix">pnvmix</a>()</code> for the ungrouped and <code><a href="#topic+pgnvmix">pgnvmix</a>()</code> for the
grouped case.</p>
</td></tr>
<tr><td><code id="copula_+3A_groupings">groupings</code></td>
<td>
<p>see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_df">df</code></td>
<td>
<p>positive degress of freedom; can also be <code>Inf</code> in which
case the copula is interpreted as the Gaussian copula.</p>
</td></tr>
<tr><td><code id="copula_+3A_scale">scale</code></td>
<td>
<p>scale matrix (a covariance matrix entering the
distribution as a parameter) of dimension <code class="reqn">(d, d)</code> (defaults to
<code class="reqn">d = 2</code>);
this equals the covariance matrix of a random vector following
the specified normal variance mixture distribution divided by
the expecation of the mixing variable <code class="reqn">W</code> if and only if the
former exists.
Note that <code>scale</code> must be positive definite; sampling from
singular ungrouped normal variance mixtures can be achieved by providing
<code>factor</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_factor">factor</code></td>
<td>

<p><code class="reqn">(d, k)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> such that
<code>factor %*% t(factor)</code> equals <code>scale</code>; the non-square
case <code class="reqn">k \neq d</code> can be used to sample from singular
normal variance mixtures. For <code>dnvmixcopula()</code>, this has to be
a square matrix. Note that this notation coincides with
McNeil et al. (2015, Chapter 6). If not provided, <code>factor</code> is
internally determined via <code><a href="base.html#topic+chol">chol</a>()</code> (and multiplied
from the right to an <code class="reqn">(n, k)</code>-matrix of independent
standard normals to obtain a sample from a multivariate normal
with zero mean vector and covariance matrix <code>scale</code>).</p>
</td></tr>
<tr><td><code id="copula_+3A_factor.inv">factor.inv</code></td>
<td>
<p>inverse of <code>factor</code>; if not provided, computed via
<code>solve(factor)</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_skip">skip</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_df.init">df.init</code></td>
<td>
<p><code><a href="base.html#topic+NULL">NULL</a></code> or vector with initial estimates for <code>df</code>;
can contain NAs.</p>
</td></tr>
<tr><td><code id="copula_+3A_df.bounds">df.bounds</code></td>
<td>
<p><code class="reqn">2</code>-<code><a href="base.html#topic+vector">vector</a></code> with the lower/upper bounds on
the degree-of-freedom parameter for the fitting.</p>
</td></tr>
<tr><td><code id="copula_+3A_fit.method">fit.method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> indicating which fitting method is to
be used; see details below.</p>
</td></tr>
<tr><td><code id="copula_+3A_x">x</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> data matrix of which the underlying
copula is to be estimated. See also details below.</p>
</td></tr>
<tr><td><code id="copula_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_verbose">verbose</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>
indicating whether a warning is given if the required precision
<code>abstol</code> has not been reached.</p>
</td></tr>
<tr><td><code id="copula_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the logarithmic
density is to be computed.</p>
</td></tr>
<tr><td><code id="copula_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to the
underlying mixing distribution when <code>rmix</code> or <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functionalities for normal variance mixture copulas provided here
essentially call <code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+dnvmix">dnvmix</a>()</code> and
<code><a href="#topic+rnvmix">rnvmix</a>()</code> as well as <code><a href="#topic+qnvmix">qnvmix</a>()</code>, see their
documentations for more details.
</p>
<p>We remark that computing normal variance mixtures is a challenging
task; evaluating normal variance mixture copulas additionally requires
the approximation of a univariate quantile function so that for large
dimensions and sample sizes, these procedures can be fairly slow. As
there are approximations on many levels, reported error estimates for
the copula versions of <code>pnvmix</code>() and <code>dnvmix</code>() can be
flawed.
</p>
<p>The functions <code>[d/p/r]Studentcopula()</code> are user-friendly wrappers for
<code>[d/p/r]nvmixcopula(, qmix = "inverse.gamma")</code>, designed for the imporant
case of a t copula with degrees-of-freedom <code>df</code>.
</p>
<p>The function <code>fitgStudentcopula()</code> can be used to estimate the matrix
<code>scale</code> and the degrees-of-freedom for grouped t-copulas. The matrix
<code>scale</code>, if not provided, is estimated non-parametrically. Initial values
for the degrees-of-freedom are estimated for each group separately (by fitting
the corresponding marginal t copula). Using these initial values, the joint
likelihood over all (<code>length(unique(groupings))</code>-many) degrees-of-freedom
parameters is optimized via <code><a href="stats.html#topic+optim">optim</a>()</code>. For small dimensions,
the results are satisfactory but the optimization becomes extremely challenging
when the dimension is large, so care should be taking when interpreting the
results.
</p>


<h3>Value</h3>

<p>The values returned by <code>dnvmixcopula()</code>, <code>rnvmixcopula()</code> and
<code>pnvmixcopula()</code> are similar to the ones returned by their
non-copula alternatives <code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+rnvmix">rnvmix</a>()</code>
and <code><a href="#topic+pnvmix">pnvmix</a>()</code>.
</p>
<p>The function <code>fitgStudentcopula()</code> returns an S3 object of
<code><a href="base.html#topic+class">class</a></code> <code>"fitgStudentcopula"</code>, basically a <code><a href="base.html#topic+list">list</a></code>
which contains, among others, the components
</p>

<dl>
<dt><code>df</code></dt><dd><p>Estimated degrees-of-freedom for each group.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Estimated or provided <code>scale</code> matrix.</p>
</dd>
<dt><code>max.ll</code></dt><dd><p>Estimated log-likelihood at reported estimates.</p>
</dd>
<dt><code>df.init</code></dt><dd><p>Initial estimate for the degrees-of-freedom.</p>
</dd>
</dl>

<p>The methods <code>print()</code> and <code>summary()</code> are defined for the class
<code>"fitgStudentcopula"</code>.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Luo, X. and Shevchenko, P. (2010).
The <em>t</em> copula with multiple parameters of degrees of freedom: bivariate
characteristics and application to risk management.
<em>Quantitative Finance</em> 10(9),
1039-1054.
</p>
<p>Daul, S., De Giorgi, E. G., Lindskog, F. and McNeil, A (2003).
The grouped <em>t</em> copula with an application to credit risk.
<em>Available at SSRN 1358956</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>,
<code><a href="#topic+rnvmix">rnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a random correlation matrix in d dimensions
d &lt;- 2 # dimension
set.seed(42) # for reproducibility
rho &lt;- runif(1, min = -1, max = 1)
P &lt;- matrix(rho, nrow = d, ncol = d) # build the correlation matrix P
diag(P) &lt;- 1
## Generate two random evaluation points:
u &lt;- matrix(runif(2*d), ncol = d)
## We illustrate using a t-copula
df = 2.1
## Define quantile function which is inverse-gamma here:
qmix. &lt;- function(u) 1/qgamma(1-u, shape = df/2, rate = df/2)


### Example for dnvmixcopula() ####################################################

## If qmix = "inverse.gamma", dnvmix() calls qt and dt:
d1 &lt;- dnvmixcopula(u, qmix = "inverse.gamma", scale = P, df = df)
## Same can be obtained using 'dStudentcopula()'
d2 &lt;- dStudentcopula(u, scale = P, df = df)
stopifnot(all.equal(d1, d2))
## Use qmix. to force the algorithm to use a rqmc procedure:
d3 &lt;- dnvmixcopula(u, qmix = qmix., scale = P)
stopifnot(all.equal(d1, d3, tol = 1e-3, check.attributes = FALSE))


### Example for pnvmixcopula() ####################################################

## Same logic as above:
p1 &lt;- pnvmixcopula(u, qmix = "inverse.gamma", scale = P, df = df)
p2 &lt;- pnvmixcopula(u, qmix = qmix., scale = P)
stopifnot(all.equal(p1, p2, tol = 1e-3, check.attributes = FALSE))


### Examples for rnvmixcopula() ###################################################

## Draw random variates and compare
n &lt;- 60
set.seed(1)
X  &lt;- rnvmixcopula(n, qmix = "inverse.gamma", df = df, scale = P) # with scale
set.seed(1)
X. &lt;- rnvmixcopula(n, qmix = "inverse.gamma", df = df, factor = t(chol(P))) # with factor
stopifnot(all.equal(X, X.))


### Example for the grouped case ##################################################

d &lt;- 4 # dimension
set.seed(42) # for reproducibility
P &lt;- matrix(runif(1, min = -1, max = 1), nrow = d, ncol = d) # build the correlation matrix P
diag(P) &lt;- 1
groupings &lt;- c(1, 1, 2, 2) # two groups of size two each
df &lt;- c(1, 4) # dof for each of the two groups
U &lt;- rgStudentcopula(n, groupings = groupings, df = df, scale = P)
(fit &lt;- fitgStudentcopula(u = U, groupings = groupings, verbose = FALSE))
</code></pre>

<hr>
<h2 id='dependencemeasures'>Dependence Measures for grouped normal variance mixture copulas</h2><span id='topic+lambda_gStudent'></span><span id='topic+corgnvmix'></span>

<h3>Description</h3>

<p>Computation of rank correlation coefficients Spearman's rho and Kendall's tau
for grouped normal variance mixture copulas as well as computation of the
(lower and upper) tail dependence coefficient of a grouped <em>t</em> copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corgnvmix(scale, qmix, method = c("kendall", "spearman"), groupings = 1:2,
          ellip.kendall = FALSE, control = list(), verbose = TRUE, ...)

lambda_gStudent(df, scale, control = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dependencemeasures_+3A_scale">scale</code></td>
<td>
<p><code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> giving the <code class="reqn">\rho</code> parameters of
the copula.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variables; see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> indicating if Spearman's rho or
Kendall's tau is to be computed.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_groupings">groupings</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> specifying the grouping structure; either
<code>rep(1, 2)</code> (ungrouped) or <code>1:2</code> (grouped case).</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_ellip.kendall">ellip.kendall</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> if the formula for Kendalll's tau
for elliptical copulas shall be used; see details below.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_df">df</code></td>
<td>
<p>either scalar or <code class="reqn">2</code>-<code><a href="base.html#topic+vector">vector</a></code> giving the degrees-of-
freedoms for the t copula; if provided as scalar, the copula is an (ungrouped)
t copula and <code>lambda_gStudent()</code> uses a closed formula.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_verbose">verbose</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>
indicating whether a warning is given if the required precision
has not been reached.</p>
</td></tr>
<tr><td><code id="dependencemeasures_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed
to the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For grouped normal variance mixture copulas, including the grouped <em>t</em>,
there is no closed formula for Kendall's tau and Spearman's rho. The function
<code>corgnvmix()</code> approximates these dependence measures by numerically
approximating an integral representation for these measures.
</p>
<p>If no grouping is present (i.e., when <code>groupings = rep(1, 2)</code>), the
copula is an elliptical copula for which the formula <code class="reqn">\tau = 2asin(\rho)/pi</code>
holds. This formula holds only approximately in the grouped case; the quality
of the approximation depends on how different the mixing variables for the
two components are. When the mixing distributions are not too far apart and
when the copula parameter is not close to 1, this approximation is &ldquo;very
accurate&ldquo;, as demonstrated in Daul et al (2003).
</p>
<p>In the ungrouped case, <code>lambda_gStudent()</code> computes the tail dependence
coefficient <code class="reqn">lambda</code> based on the known formula
<code>2 * pt( -sqrt( (df + 1)*(1 - rho) / (1 + rho)), df = df + 1)</code> for
the tail dependence coefficient of a <em>t</em> copula.
</p>
<p>In the grouped case, RQMC methods are used to efficiently approximate the
integral given in Eq. (26) of Luo and Shevchenko (2010).
</p>


<h3>Value</h3>

<p><code>lambda_gStudent()</code> and <code>corgnvmix()</code> return
a <code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed
dependence measure with corresponding attributes
<code>"abs. error"</code> and <code>"rel. error"</code>(error estimates of the RQMC estimator)
and <code>"numiter"</code> (number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>Luo, X. and Shevchenko, P. (2010).
The <em>t</em> copula with multiple parameters of degrees of freedom: bivariate
characteristics and application to risk management.
<em>Quantitative Finance</em> 10(9),
1039-1054.
</p>
<p>Daul, S., De Giorgi, E. G., Lindskog, F. and McNeil, A (2003).
The grouped <em>t</em> copula with an application to credit risk.
<em>Available at SSRN 1358956</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgStudentcopula">dgStudentcopula</a>()</code>, <code><a href="#topic+pgStudentcopula">pgStudentcopula</a>()</code>,
<code><a href="#topic+rgStudentcopula">rgStudentcopula</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples for corgnvmix() ###################################################

## Create a plot displaying Spearman's rho for a grouped t copula as a function
## of the copula parameter for various choices of the degrees-of-freedom
qmix &lt;- "inverse.gamma"
df &lt;- matrix( c(1, 2, 1, 5, 1, Inf), ncol = 2, byrow = TRUE)
l.df &lt;- nrow(df)
scale &lt;- seq(from = 0, to = 1, length.out = 99)
set.seed(1) # for reproducibility
kendalls &lt;- sapply(seq_len(l.df), function(i)
   corgnvmix(scale, qmix = qmix, method = "kendall", df = df[i, ]))
## Include the elliptical approximation (exact when df1 = df2)
kendall_ell &lt;- corgnvmix(scale, method = "kendall", ellip.kendall = TRUE)
## Plot
lgnd &lt;- character(l.df + 1)
lgnd[1] &lt;- "elliptical (equal df)"
plot(NA, xlim = c(0, 1), ylim = c(0, 1), xlab = expression(rho),
     ylab = "Kendall's tau")
lines(scale, kendall_ell, lty = 1)
for(i in 1:l.df){
   lines(scale, kendalls[, i], col = i + 1, lty = i + 1)
   lgnd[i+1] &lt;- paste0("df1 = ", df[i, 1], ", df2 = ", df[i, 2])
}
legend("topleft", lgnd, col = 1:(l.df + 1), lty = 1:(l.df + 1), bty = 'n')


### Examples for lambda_gStudent() #############################################

## Create a plot displaying 'lambda' as a function of the copula parameter
## for various choices of the degrees-of-freedom
df &lt;- c(3, 6, 9)
df_ &lt;- list( rep(df[1], 2), rep(df[2], 2), rep(df[3], 2), # ungrouped
             c(df[1], df[2]), c(df[1], df[3]), c(df[2], df[3])) # grouped
l.df_ &lt;- length(df_)
scale &lt;- seq(from = -0.99, to = 0.99, length.out = 112) # scale parameters
set.seed(1) # for reproducibilty
lambdas &lt;-
   sapply(seq_len(l.df_), function(i) lambda_gStudent(df_[[i]], scale = scale))
lgnd &lt;- character(length(df_))
plot(NA, xlim = range(scale), ylim = range(lambdas), xlab = expression(rho),
     ylab = expression(lambda))
for(i in seq_len(l.df_)){
   lines(scale, lambdas[, i], col = i, lty = i)
   lgnd[i] &lt;- if(df_[[i]][1] == df_[[i]][2]) paste0("df = ", df_[[i]][1]) else
      paste0("df1 = ", df_[[i]][1], ", df2 = ", df_[[i]][2])
}
legend("topleft", lgnd, col = seq_len(l.df_), lty = seq_len(l.df_),
       bty = 'n')
## If called with 'df' a 1-vector, closed formula for lambda is used =&gt; check
lambda.true &lt;- sapply(1:3, function(i) lambda_gStudent(df_[[i]][1], scale = scale))
stopifnot(max(abs( lambda.true - lambdas[, 1:3])) &lt; 4e-4)
</code></pre>

<hr>
<h2 id='dgnvmix'>Density of Grouped Normal Variance Mixtures</h2><span id='topic+dgnvmix'></span><span id='topic+dgStudent'></span>

<h3>Description</h3>

<p>Evaluating grouped normal variance mixture density functions
(including Student <em>t</em> with multiple degrees-of-freedom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgnvmix(x, groupings = 1:d, qmix, loc = rep(0, d), scale = diag(d), factor = NULL,
        factor.inv = NULL, control = list(), log = FALSE, verbose = TRUE, ...)
dgStudent(x, groupings = 1:d, df, loc = rep(0, d), scale = diag(d), factor = NULL,
          factor.inv = NULL, control = list(), log = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgnvmix_+3A_x">x</code></td>
<td>
<p>see <code><a href="#topic+dnvmix">dnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_groupings">groupings</code></td>
<td>
<p>see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variables <code class="reqn">W_i</code> via quantile
functions; see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_loc">loc</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>; must be positive definite.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_factor">factor</code></td>
<td>
<p><code class="reqn">(d, d)</code> lower triangular <code><a href="base.html#topic+matrix">matrix</a></code>
such that <code>factor %*% t(factor)</code> equals <code>scale</code>. Internally
used is <code>factor.inv</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_factor.inv">factor.inv</code></td>
<td>
<p>inverse of <code>factor</code>; if not provided, computed via
<code>solve(factor)</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_df">df</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of length <code>length(unique(groupings))</code> so that
variable <code>i</code> has degrees-of-freedom <code>df[groupings[i]]</code>; all elements
must be positive
and can be <code>Inf</code>, in which case the corresponding marginal is normally
distributed.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the logarithmic
density is to be computed.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="dgnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed
to the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or an element of <code>qmix</code> is a
<code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally used is <code>factor.inv</code>, so <code>factor</code> and <code>scale</code> are not
required to be provided (but allowed for consistency with other functions in the
package).
</p>
<p><code>dgStudent()</code> is a wrapper of
<code>dgnvmix(, qmix = "inverse.gamma", df = df)</code>. If there is no grouping,
the analytical formula for the density of a multivariate <em>t</em> distribution
is used.
</p>
<p>Internally, an adaptive randomized Quasi-Monte Carlo (RQMC) approach
is used to estimate the log-density. It is an iterative algorithm that
evaluates the integrand at a randomized Sobol' point-set (default) in
each iteration until the pre-specified error tolerance
<code>control$dnvmix.reltol</code> in the <code>control</code> argument
is reached for the log-density.  The attribute
<code>"numiter"</code> gives the worst case number of such iterations needed
(over all rows of <code>x</code>). Note that this function calls underlying
C code.
</p>
<p>Algorithm specific parameters (such as above mentioned <code>control$dnvmix.reltol</code>)
can be passed as a <code><a href="base.html#topic+list">list</a></code> via the <code>control</code> argument,
see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for details and defaults.
</p>
<p>If the error tolerance cannot be achieved within <code>control$max.iter.rqmc</code>
iterations and <code>fun.eval[2]</code> function evaluations, an additional
warning is thrown if <code>verbose=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>dgnvmix()</code> and <code>dgStudent()</code> return a
<code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed density values
and corresponding attributes <code>"abs. error"</code> and <code>"rel. error"</code>
(error estimates of the RQMC estimator) and <code>"numiter"</code> (number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgnvmix">rgnvmix</a>()</code>, <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100 # sample size to generate evaluation points

### 1. Inverse-gamma mixture
## 1.1. Grouped t with mutliple dof

d &lt;- 3 # dimension
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A)) # random scale matrix
df &lt;- c(1.1, 2.4, 4.9) # dof for margin i
groupings &lt;- 1:d
x &lt;- rgStudent(n, df = df, scale = P) # evaluation points for the density

### Call 'dgnvmix' with 'qmix' a string:
set.seed(12)
dgt1 &lt;- dgnvmix(x, qmix = "inverse.gamma", df = df, scale = P)
### Version providing quantile functions of the mixing distributions as list
qmix_ &lt;- function(u, df) 1 / qgamma(1-u, shape = df/2, rate = df/2)
qmix &lt;- list(function(u) qmix_(u, df = df[1]), function(u) qmix_(u, df = df[2]),
             function(u) qmix_(u, df = df[3]))
set.seed(12)
dgt2 &lt;- dgnvmix(x, groupings = groupings, qmix = qmix, scale = P)
### Similar, but using ellipsis argument:
qmix &lt;- list(function(u, df1) qmix_(u, df1), function(u, df2) qmix_(u, df2),
             function(u, df3) qmix_(u, df3))
set.seed(12)
dgt3 &lt;- dgnvmix(x, groupings = groupings, qmix = qmix, scale = P, df1 = df[1],
                df2 = df[2], df3 = df[3])
### Using the wrapper 'dgStudent()'
set.seed(12)
dgt4 &lt;- dgStudent(x, groupings = groupings, df = df, scale = P)
stopifnot(all.equal(dgt1, dgt2, tol = 1e-5, check.attributes = FALSE),
          all.equal(dgt1, dgt3, tol = 1e-5, check.attributes = FALSE),
          all.equal(dgt1, dgt4, tol = 1e-5, check.attributes = FALSE))


## 1.2 Classical multivariate t

df &lt;- 2.4
groupings &lt;- rep(1, d) # same df for all components
x &lt;- rStudent(n, scale = P, df = df) # evaluation points for the density
dt1 &lt;- dStudent(x, scale = P, df = df, log = TRUE) # uses analytical formula
## If 'qmix' provided as string and no grouping, dgnvmix() uses analytical formula
dt2 &lt;- dgnvmix(x, qmix = "inverse.gamma", groupings = groupings, df = df, scale = P, log = TRUE)
stopifnot(all.equal(dt1, dt2))
## Provide 'qmix' as a function to force estimation in 'dgnvmix()'
dt3 &lt;- dgnvmix(x, qmix = qmix_, groupings = groupings, df = df, scale = P, log = TRUE)
stopifnot(all.equal(dt1, dt3, tol = 5e-4, check.attributes = FALSE))

### 2. More complicated mixutre

## Let W1 ~ IG(1, 1), W2 = 1, W3 ~ Exp(1), W4 ~ Par(2, 1), W5 = W1, all comonotone
## =&gt; X1 ~ t_2; X2 ~ normal; X3 ~ Exp-mixture; X4 ~ Par-mixture; X5 ~ t_2

d &lt;- 5
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))
b &lt;- 3 * runif(d) * sqrt(d) # random upper limit
groupings &lt;- c(1, 2, 3, 4, 1) # since W_5 = W_1
qmix &lt;- list(function(u) qmix_(u, df = 2), function(u) rep(1, length(u)),
             list("exp", rate=1), function(u) (1-u)^(-1/2)) # length 4 (# of groups)
x &lt;- rgnvmix(n, groupings = groupings, qmix = qmix, scale = P)
dg &lt;- dgnvmix(x, groupings = groupings, qmix = qmix, scale = P, log = TRUE)
</code></pre>

<hr>
<h2 id='dnvmix'>Density of Multivariate Normal Variance Mixtures</h2><span id='topic+dnvmix'></span><span id='topic+dStudent'></span><span id='topic+dNorm'></span>

<h3>Description</h3>

<p>Evaluating multivariate normal variance mixture densities
(including Student <em>t</em> and normal densities).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnvmix(x, qmix, loc = rep(0, d), scale = diag(d),
       factor = NULL, control = list(), log = FALSE, verbose = TRUE,...)

dStudent(x, df, loc = rep(0, d), scale = diag(d), factor = NULL,
         log = FALSE, verbose = TRUE, ...)
dNorm(x, loc = rep(0, d), scale = diag(d), factor = NULL,
      log = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dnvmix_+3A_x">x</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of evaluation points.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code>; see
<code><a href="#topic+pnvmix">pnvmix</a>()</code> for details and examples.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_df">df</code></td>
<td>
<p>positive degress of freedom; can also be <code>Inf</code> in which
case the distribution is interpreted as the multivariate normal
distribution with mean vector <code>loc</code> and covariance matrix
<code>scale</code>).</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_loc">loc</code></td>
<td>
<p>location vector of dimension <code class="reqn">d</code>; this equals the mean
vector of a random vector following the specified normal variance
mixture distribution if and only if the latter exists.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_scale">scale</code></td>
<td>
<p>scale matrix (a covariance matrix entering the
distribution as a parameter) of dimension <code class="reqn">(d, d)</code>;
this equals the covariance matrix of a random vector following
the specified normal variance mixture distribution divided by
the expecation of the mixing variable <code class="reqn">W</code> if and only if the
former exists. Needs to be full rank for the density to exist.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_factor">factor</code></td>
<td>
<p><code class="reqn">(d, d)</code> lower triangular <code><a href="base.html#topic+matrix">matrix</a></code>
such that <code>factor %*% t(factor)</code> equals <code>scale</code>;
note that for performance reasons, this property is not tested.
If not provided, <code>factor</code> is internally determined via
<code>t(<a href="base.html#topic+chol">chol</a>())</code>.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the logarithmic
density is to be computed.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether a
warning is given if the required precision <code>abstol</code> has not
been reached.</p>
</td></tr>
<tr><td><code id="dnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters)
passed to the underlying mixing distribution when <code>qmix</code>
is a <code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the density to exist, <code>scale</code> must be full rank.
Internally used is <code>factor</code>, so <code>scale</code> is not required
to be provided if <code>factor</code> is given. The default factorization
used to obtain <code>factor</code> is the Cholesky
decomposition via <code><a href="base.html#topic+chol">chol</a>()</code>.
</p>
<p><code>dStudent()</code> and <code>dNorm()</code> are wrappers of
<code>dnvmix(, qmix = "inverse.gamma", df = df)</code> and
<code>dnvmix(, qmix = "constant")</code>, respectively.
In these cases, <code>dnvmix()</code> uses the analytical formulas for the
density of a multivariate Student <em>t</em> and normal distribution,
respectively.
</p>
<p>Internally, an adaptive randomized Quasi-Monte Carlo (RQMC) approach
is used to estimate the log-density. It is an iterative algorithm that
evaluates the integrand at a randomized Sobol' point-set (default) in
each iteration until the pre-specified error tolerance
<code>control$dnvmix.reltol</code> in the <code>control</code> argument
is reached for the log-density.  The attribute
<code>"numiter"</code> gives the worst case number of such iterations needed
(over all rows of <code>x</code>). Note that this function calls underlying
C code.
</p>
<p>Algorithm specific parameters (such as above mentioned <code>control$dnvmix.reltol</code>)
can be passed as a <code><a href="base.html#topic+list">list</a></code> via the <code>control</code> argument,
see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for details and defaults.
</p>
<p>If the error tolerance cannot be achieved within <code>control$max.iter.rqmc</code>
iterations and <code>fun.eval[2]</code> function evaluations, an additional
warning is thrown if <code>verbose=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>dnvmix()</code>, <code>dStudent()</code> and <code>dNorm()</code> return a
<code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed (log-)density
values and attributes <code>"abs. error"</code> and <code>"rel. error"</code>
(containing the absolute and relative error
estimates of the of the (log-)density) and <code>"numiter"</code>
(containing the number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux.</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>,
<code><a href="#topic+get_set_param">get_set_param</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples for dnvmix() ######################################################

## Generate a random correlation matrix in three dimensions
d &lt;- 3
set.seed(271)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))

## Evaluate a t_{3.5} density
df &lt;- 3.5
x &lt;- matrix(1:12/12, ncol = d) # evaluation points
dt1 &lt;- dnvmix(x, qmix = "inverse.gamma", df = df, scale = P)
stopifnot(all.equal(dt1, c(0.013266542, 0.011967156, 0.010760575, 0.009648682),
                    tol = 1e-7, check.attributes = FALSE))

## Here is a version providing the quantile function of the mixing distribution
qW &lt;- function(u, df) 1 / qgamma(1-u, shape = df/2, rate = df/2)
dt2 &lt;- dnvmix(x, qmix = qW, df = df, scale = P)

## Compare
stopifnot(all.equal(dt1, dt2, tol = 5e-4, check.attributes = FALSE))

## Evaluate a normal density
dn &lt;- dnvmix(x, qmix = "constant", scale = P)
stopifnot(all.equal(dn, c(0.013083858, 0.011141923, 0.009389987, 0.007831596),
                    tol = 1e-7, check.attributes = FALSE))

## Case with missing data
x. &lt;- x
x.[3,2] &lt;- NA
x.[4,3] &lt;- NA
dt &lt;- dnvmix(x., qmix = "inverse.gamma", df = df, scale = P)
stopifnot(is.na(dt) == rep(c(FALSE, TRUE), each = 2))

## Univariate case
x.. &lt;- cbind(1:10/10) # (n = 10, 1)-matrix; vectors are considered rows in dnvmix()
dt1 &lt;- dnvmix(x.., qmix = "inverse.gamma", df = df, factor = 1)
dt2 &lt;- dt(as.vector(x..), df = df)
stopifnot(all.equal(dt1, dt2, check.attributes = FALSE))


### Examples for dStudent() and dNorm() ########################################

## Evaluate a t_{3.5} density
dt &lt;- dStudent(x, df = df, scale = P)
stopifnot(all.equal(dt, c(0.013266542, 0.011967156, 0.010760575, 0.009648682),
                    tol = 1e-7, check.attributes = FALSE))

## Evaluate a normal density
x &lt;- x[1,] # use just the first point this time
dn &lt;- dNorm(x, scale = P)
stopifnot(all.equal(dn, 0.013083858, tol = 1e-7, check.attributes = FALSE))
</code></pre>

<hr>
<h2 id='fitnvmix'>Fitting Multivariate Normal Variance Mixtures</h2><span id='topic+fitnvmix'></span><span id='topic+fitStudent'></span><span id='topic+fitNorm'></span>

<h3>Description</h3>

<p>Functionalities for fitting multivariate normal variance mixtures (in
particular also Multivariate <em>t</em> distributions) via an ECME algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitnvmix(x, qmix, mix.param.bounds, nu.init = NA, loc = NULL, scale = NULL,
         init.size.subsample = min(n, 100), size.subsample = n,
         control = list(), verbose = TRUE)

fitStudent(x, loc = NULL, scale = NULL, mix.param.bounds = c(1e-3, 1e2), ...)
fitNorm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitnvmix_+3A_x">x</code></td>
<td>
<p><code class="reqn">(n, d)</code>-data <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code>; see McNeil et
al. (2015, Chapter 6). Supported are the following types of
specification (see also the examples below):
</p>

<dl>
<dt><code><a href="base.html#topic+character">character</a></code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string
specifying a supported distribution; currently available are
<code>"constant"</code> (in which case <code class="reqn">W = 1</code> and thus
the multivariate normal distribution with mean vector
<code>loc</code> and covariance matrix <code>scale</code> results),
<code>"inverse.gamma"</code> (in which case <code class="reqn">W</code> is
inverse gamma distributed with shape and rate parameters
<code>df</code>/2 and thus the multivariate
Student <em>t</em> distribution with <code>df</code> degrees of freedom
results) and <code>"pareto"</code> (in which case <code class="reqn">W</code> is
Pareto distributed with scale equal to unity and shape equal to
<code>alpha</code>).
</p>
</dd>
<dt><code><a href="base.html#topic+function">function</a></code>:</dt><dd><p><code><a href="base.html#topic+function">function</a></code>
interpreted as the quantile function of the mixing
variable <code class="reqn">W</code>. In this case, <code>qmix</code> <em>must</em> have the
form <code>qmix = function(u, nu)</code>, where the argument <code>nu</code>
corresponds to the parameter (vector) specifying the distribution
of the mixing variable.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fitnvmix_+3A_mix.param.bounds">mix.param.bounds</code></td>
<td>
<p>either <code><a href="base.html#topic+numeric">numeric</a>(2)</code> or a
<code><a href="base.html#topic+matrix">matrix</a></code> with two columns. The first/second column
corresponds to the lower/upper bound of <code class="reqn">nu_i</code>, the ith
component of the parameter vector <code class="reqn">nu</code> of the mixing variable
<code class="reqn">W</code>. All elements need to be finite, numeric values.
Note: The algorithm tends to converge quicker if the parameter
ranges supplied are smaller.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_nu.init">nu.init</code></td>
<td>
<p>either <code>NA</code> or an initial guess for the parameter
(vector) <code class="reqn">nu</code>. In the former case an initial estimate is
calculated by the algorithm. If <code>nu.init</code> is provided, the
algorithm often converges faster; the better the starting value,
the faster convergence.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_loc">loc</code></td>
<td>
<p><code class="reqn">d</code>-<code><a href="base.html#topic+vector">vector</a></code>; if provided, taken as the 'true'
location vector in which case <code>loc</code> is not estimated.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_scale">scale</code></td>
<td>
<p>positive definite <code class="reqn">(d, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code>; if provided,
taken as the 'true' scale matrix in which case <code>scale</code> is not estimated.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_init.size.subsample">init.size.subsample</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, non-negative,
giving the sub-samplesize used to get an initial estimate for
<code class="reqn">nu</code>. Only used if <code>is.na(nu.init)</code>, otherwise ignored.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_size.subsample">size.subsample</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, non-negative, specifying
the size of the subsample that is being used in the ECME iterations
to optimize the log-likelihood over <code class="reqn">nu</code>. Defaults to <code>n</code>,
so that the full sample is being used. Decreasing this number can
lead to faster run-times (as fewer log-densities need to be
estimated) but also to an increase in bias and variance.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see below under 'Details' and <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+logical">logical</a></code> (in
which case it is converted to <code>numeric</code>) specifying the
amount of tracing to be done. If <code>0</code> or <code>FALSE</code>, neither tracing
nor warnigns are communicated; if <code>1</code>, only warnigns are communicated,
if <code>2</code> or <code>3</code>, warnings and (shorter or longer) tracing information is
provided.</p>
</td></tr>
<tr><td><code id="fitnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the underlying
<code>fitnvmix()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fitnvmix()</code> uses an ECME algorithm to approximate the
MLEs of the parameters <code>nu</code>, <code>loc</code> and <code>scale</code> of a
normal variance mixture specified by <code>qmix</code>. The underlying
procedure successively estimates <code>nu</code> (with given <code>loc</code> and
<code>scale</code>) by maximizing the likelihood which is approximated by
<code><a href="#topic+dnvmix">dnvmix</a>()</code> (unless <code>qmix</code> is a <code>character</code>
string, in which case analytical formulas for the log-densities are
used) and <code>scale</code> and <code>loc</code> (given <code>nu</code>) using weights
(which again need to be approximated) related to the posterior
distribution, details can be found in the first reference below.
</p>
<p>It should be highlighted that (unless unless <code>qmix</code> is a
<code>character</code> string), every log-likelihood and every weight needed
in the estimation is numerically approximated via RQMC methods. For
large dimensions and sample sizes this procedure can therefore be
slow.
</p>
<p>Various tolerances and convergence criteria can be changed by the user
via the <code>control</code> argument. For more details, see
<code><a href="#topic+get_set_param">get_set_param</a>()</code>.
</p>


<h3>Value</h3>

<p>The function <code>fitnvmix()</code> returns an S3 object of
<code><a href="base.html#topic+class">class</a></code> <code>"fitnvmix"</code>, basically a <code><a href="base.html#topic+list">list</a></code>
which contains, among others, the components
</p>

<dl>
<dt><code>nu</code></dt><dd><p>Estimated mixing parameter (vector) <code>nu</code>.</p>
</dd>
<dt><code>loc</code></dt><dd><p>Estimated or provided <code>loc</code> vector.</p>
</dd>
<dt><code>scale</code></dt><dd><p>Estimated or provided <code>scale</code> matrix.</p>
</dd>
<dt><code>max.ll</code></dt><dd><p>Estimated log-likelihood at reported estimates.</p>
</dd>
<dt><code>x</code></dt><dd><p>Input data matrix <code>x</code>.</p>
</dd>
</dl>

<p>The methods <code>print()</code>, <code>summary()</code> and <code>plot()</code> are defined
for the class <code>"fitnvmix"</code>.
</p>
<p><code>fitStudent()</code> is a wrapper to <code>fitnvmix()</code> for parameter
estimation of multivariate Student <em>t</em> distributions; it also
returns an S3 object of <code><a href="base.html#topic+class">class</a></code> <code>"fitnvmix"</code> where
the fitted degrees of freedom are called <code>"df"</code> instead of
<code>"nu"</code> (to be consistent
with the other wrappers for the Student <em>t</em> distributions).
</p>
<p><code>fitNorm()</code> just returns a <code><a href="base.html#topic+list">list</a></code> with components
<code>loc</code> (columnwise sample means) and <code>scale</code> (sample
covariance matrix).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Liu, C. and Rubin, D. (1994).
The ECME algorithm: a simple extension of EM and ECM with faster monotone
convergence.
<em>Biometrika</em> 81(4),
633&ndash;648.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>,
<code><a href="#topic+qqplot_maha">qqplot_maha</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sampling parameters
set.seed(274) # for reproducibility
nu               &lt;- 2.8 # parameter used to sample data
d                &lt;- 4 # dimension
n                &lt;- 75 # small sample size to have examples run fast
loc              &lt;- rep(0, d) # location vector
A                &lt;- matrix(runif(d * d), ncol = d)
diag_vars        &lt;- diag(runif(d, min = 2, max = 5))
scale            &lt;- diag_vars %*% cov2cor(A %*% t(A)) %*% diag_vars # scale matrix
mix.param.bounds &lt;- c(1, 5) # nu in [1, 5]

### Example 1: Fitting a multivariate t distribution ###########################

if(FALSE){
    ## Define 'qmix' as the quantile function of an IG(nu/2, nu/2) distribution
    qmix &lt;- function(u, nu) 1 / qgamma(1 - u, shape = nu/2, rate = nu/2)
    ## Sample data using 'rnvmix'
    x &lt;- rnvmix(n, qmix = qmix, nu = nu, loc = loc, scale = scale)
    ## Call 'fitvnmix' with 'qmix' as a function (so all densities/weights are estimated)
    (MyFit11 &lt;- fitnvmix(x, qmix = qmix, mix.param.bounds = mix.param.bounds))
    ## Call 'fitnvmix' with 'qmix = "inverse.gamma"' in which case analytical formulas
    ## for weights and densities are used:
    (MyFit12 &lt;- fitnvmix(x, qmix = "inverse.gamma",
                         mix.param.bounds = mix.param.bounds))
    ## Alternatively, use the wrapper 'fitStudent()'
    (MyFit13 &lt;- fitStudent(x))
    ## Check
    stopifnot(all.equal(MyFit11$nu, MyFit12$nu, tol = 5e-2),
              all.equal(MyFit11$nu, MyFit13$nu, tol = 5e-2))
    ## Can also provide 'loc' and 'scale' in which case only 'nu' is estimated
    (MyFit13 &lt;- fitnvmix(x, qmix = "inverse.gamma", mix.param.bounds = mix.param.bounds,
                         loc = loc, scale = scale))
    (MyFit14 &lt;- fitStudent(x, loc = loc, scale = scale))
    stopifnot(all.equal(MyFit13$nu, MyFit14$df, tol = 1e-6))
}

### Example 2: Fitting a Pareto mixture ########################################

## Define 'qmix' as the quantile function of a Par(nu, 1) distribution
qmix &lt;- function(u, nu) (1-u)^(-1/nu)
## Sample data using 'rnvmix':
x &lt;- rnvmix(n, qmix = qmix, nu = nu, loc = loc, scale = scale)
## Call 'fitvnmix' with 'qmix' as function (=&gt; densities/weights estimated)
(MyFit21 &lt;- fitnvmix(x, qmix = qmix, mix.param.bounds = mix.param.bounds))
## Call 'fitnvmix' with 'qmix = "pareto"' in which case an analytical formula
## for the density is used
(MyFit22 &lt;- fitnvmix(x, qmix = "pareto", mix.param.bounds = mix.param.bounds))
stopifnot(all.equal(MyFit21$nu, MyFit22$nu, tol = 5e-2))

</code></pre>

<hr>
<h2 id='gammamix'>Functionalities for Gamma Scale Mixture Models</h2><span id='topic+dgammamix'></span><span id='topic+pgammamix'></span><span id='topic+qgammamix'></span><span id='topic+rgammamix'></span>

<h3>Description</h3>

<p>Evaluating density-, distribution- and quantile-function of Gamma scale
mixtures as well as random variate generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgammamix(x, qmix, d, control = list(), verbose = TRUE, log = FALSE, ...)
pgammamix(x, qmix, d, lower.tail = TRUE, control = list(), verbose = TRUE, ...)
qgammamix(u, qmix, d, control = list(), verbose = TRUE, q.only = TRUE,
          stored.values = NULL, ...)
rgammamix(n, rmix, qmix, d, method = c("PRNG", "sobol", "ghalton"),
          skip = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammamix_+3A_x">x</code></td>
<td>
<p><code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> of evaluation points.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_u">u</code></td>
<td>
<p><code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> of probabilities.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_qmix">qmix</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_rmix">rmix</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_d">d</code></td>
<td>
<p>dimension of the underlying normal variance mixture, see also
details below.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_n">n</code></td>
<td>
<p>sample size <code class="reqn">n</code> (positive integer).</p>
</td></tr>
<tr><td><code id="gammamix_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if <code>TRUE</code> (default),
probabilities are <code class="reqn">P(X&lt;= x)</code>, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the log-density
shall be returned.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_q.only">q.only</code></td>
<td>
<p>see <code><a href="#topic+qnvmix">qnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_stored.values">stored.values</code></td>
<td>
<p>see <code><a href="#topic+qnvmix">qnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_skip">skip</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_verbose">verbose</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>
indicating whether a warning is given if the required precision
has not been reached.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to
the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We define a Gamma mixture as a random variable <code class="reqn">Dsq</code> satisfying,
in distribution, <code class="reqn">Dsq = W*Gamma(d/2, 2)</code> where <code class="reqn">W</code> is
specified via <code>qmix</code>.  If <code class="reqn">X</code> follows a <code class="reqn">d-</code>dimensional
normal variance mixture, the squared Mahalanobis distance
<code class="reqn">(X-\mu)^T Sigma^{-1}(X-\mu)</code> has the same distribution as
<code class="reqn">Dsq</code>.
</p>
<p>The functions presented here are similar to the corresponding
functions for normal variance mixtures (<code>d/p/q/rnvmix()</code>),
details can be found in the corresponding help-files there.
</p>


<h3>Value</h3>

<p><code>pgammamix()</code> and <code>dgammamix()</code> return
a <code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed
probabilities/densities and corresponding attributes <code>"abs. error"</code>
and <code>"rel. error"</code> (error estimates of the RQMC estimator) and
<code>"numiter"</code> (number of iterations).
</p>
<p>If <code>q.only = TRUE</code>, <code>qgammamix()</code> a vector of the same length as
<code>u</code> with entries <code class="reqn">q_i</code> where <code class="reqn">q_i</code> satisfies
<code class="reqn">q_i = inf_x { F(x) &gt;= u_i}</code> where <code class="reqn">F(x)</code> the df of the Gamma mixture
specified via qmix; if <code>q.only = FALSE</code>, see <code><a href="#topic+qnvmix">qnvmix</a></code>.
</p>
<p><code>rgammamix()</code> returns a <code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> containing <code class="reqn">n</code>
samples of the specified (via mix) Gamma mixture.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>,
<code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>,
<code><a href="#topic+qqplot_maha">qqplot_maha</a>()</code>, <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Specify inverse-gamma mixture =&gt; results in d * F(d, nu) dist'n,
## handled correctly when 'qmix = "inverse.gamma"' is specified
qmix &lt;- function(u, nu) 1/qgamma(1 - u, shape = nu/2, rate = nu/2)

## Example for rgammamix()
set.seed(271) # for reproducibility
n  &lt;- 25
nu &lt;- 3
d  &lt;- 5
x  &lt;- rgammamix(n, qmix = qmix, d = d, nu = nu)

## Evaluate distribution function at 'x'
p.true_1 &lt;- pgammamix(x, qmix = "inverse.gamma", d = d, df = nu) # calls pf(...)
p.true_2 &lt;- pf(x/d, df1 = d, df2 = nu)
p.estim  &lt;- pgammamix(x, qmix = qmix, d = d, nu = nu)
stopifnot(all.equal(p.true_1, p.true_2, tol = 1e-3,
                    check.attributes = FALSE),
          all.equal(p.true_1, p.estim, tol = 1e-3,
                    check.attributes = FALSE))

## Evaluate density function at 'x'
d.true_1 &lt;- dgammamix(x, qmix = "inverse.gamma", d = d, df = nu)
d.true_2 &lt;- df(x/d, df1 = d, df2 = nu)/d
d.est  &lt;- dgammamix(x, qmix = qmix, d = d, nu = nu)
stopifnot(all.equal(d.true_1, d.true_2, tol = 5e-4,
                    check.attributes = FALSE),
          all.equal(d.true_1, d.est, tol = 5e-4,
                    check.attributes = FALSE))

## Evaluate quantile function
u &lt;- seq(from = 0.5, to = 0.9, by = 0.1)
q.true_1 &lt;- qgammamix(u, qmix = "inverse.gamma", d = d, df = nu)
q.true_2 &lt;- qf(u, df1 = d, df2 = nu) * d
q.est  &lt;- qgammamix(u, qmix = qmix, d = d, nu = nu)
stopifnot(all.equal(q.true_1, q.true_2, tol = 5e-4,
                    check.attributes = FALSE),
          all.equal(q.true_1, q.est, tol = 5e-4,
                    check.attributes = FALSE))

</code></pre>

<hr>
<h2 id='get_set_param'>Algorithm-specific Parameters</h2><span id='topic+get_set_param'></span>

<h3>Description</h3>

<p>Algorithm specific parameters for functionalities in the <code>nvmix</code>
package, notably for <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>, <code><a href="#topic+dnvmix">dnvmix</a>()</code>,
<code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>, <code><a href="#topic+pgammamix">pgammamix</a>()</code>,
<code><a href="#topic+dgammamix">dgammamix</a>()</code> and <code><a href="#topic+ES_nvmix">ES_nvmix</a>()</code> as well as the
corresponding functions for grouped mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_set_param(control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_set_param_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters to beset; see below under details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most functions in the <code>nvmix</code> package, internally, an
iterative randomized Quasi-Monte Carlo (RQMC) approach is used to
estimate probabilities, weights and (log-)densities. There are various
parameters of underlying methods than can be changed.
</p>
<p>Algorithm specific parameters can be passed as a list via
<code>control</code>.  It can contain any of the following:
</p>

<dl>
<dt>For all algorithms:</dt><dd>

<dl>
<dt><code>method</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> string indicating the
method to be used to compute the integral. Available are:
</p>

<dl>
<dt><code>"sobol"</code>:</dt><dd><p>Sobol' sequence (default),</p>
</dd>
<dt><code>"ghalton"</code>:</dt><dd><p>generalized Halton sequence,</p>
</dd>
<dt><code>"PRNG"</code>:</dt><dd><p>plain Monte Carlo based on a pseudo-random
number generator.</p>
</dd>
</dl>

</dd>
<dt><code>increment</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> string indicating how
the sample size should be increased in each iteration. Available are:
</p>

<dl>
<dt><code>"doubling"</code>:</dt><dd><p>next iteration has as many sample points
as all the previous iterations combined,</p>
</dd>
<dt><code>"num.init"</code>:</dt><dd><p>all iterations use an additional
<code>fun.eval[1]</code>-many points (default for most functions).</p>
</dd>
</dl>

</dd>
<dt><code>CI.factor</code></dt><dd><p>multiplier of the Monte Carlo confidence interval
bounds. The algorithm runs until <code>CI.factor</code> times the estimated
standard error is less than <code>abstol</code> or <code>reltol</code> (whichever
is provided). If <code>CI.factor = 3.5</code> (the default), one can expect
the actual absolute error to be less than <code>abstol</code> in
99.9% of the cases.</p>
</dd>
<dt><code>fun.eval</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a>(2)</code> providing the size of
the first point set to be used to estimate integrals
(typically a power of 2) and the maximal number of function
evaluations. <code>fun.eval</code> defaults to <code>c(2^7, 1e12)</code>.</p>
</dd>
<dt><code>max.iter.rqmc</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, providing the maximum
number of iterations allowed in the RQMC approach; the default is <code>15</code>
if <code>increment = "doubling"</code> and <code>1250</code> otherwise.</p>
</dd>
<dt><code>B</code></dt><dd><p>number of randomizations for obtaining an error estimate
in the RQMC approach; the default is <code>15</code>.</p>
</dd>
</dl>

</dd>
<dt>For <code>pnvmix()</code> and <code>pgnvmix()</code>:</dt><dd>

<dl>
<dt><code>pnvmix.abstol</code>, <code>pnvmix.reltol</code></dt><dd><p>non-negative <code><a href="base.html#topic+numeric">numeric</a></code>
providing the relative/absolute precision required for the distribution
function. Relative precision via <code>pnvmix.reltol</code> is only used
when <code>pnvmix.abstol = NA</code>; in all other cases, absolute precision
will be used. <code>pnvmix.abstol</code> defaults to <code>1e-3</code>.
If <code>pnvmix.abstol = 0</code> and <code>pnvmix.reltol = 0</code>, the algorithm
will typically run until the total number of function evaluations
exceeds <code>fun.eval[2]</code> or until the total number of iterations exeeds
<code>max.iter.rqmc</code>, whichever happens first.
If <code class="reqn">n &gt; 1</code> (so <code>upper</code> has more than
one row), the algorithm runs until the precision requirement is reached
for all <code class="reqn">n</code> probability estimates.</p>
</dd>
<dt><code>mean.sqrt.mix</code></dt><dd><p>expectation of the square root <code class="reqn">\sqrt(W)</code>
of the mixing variable <code class="reqn">W</code>. If <code>NULL</code>, it will be estimated via
QMC; this is only needed for determining the reordering of the
integration bounds, so a rather crude approximation is fine.</p>
</dd>
<dt><code>precond</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating whether
preconditioning is applied, that is, reordering of the integration
variables. If <code>TRUE</code>, integration limits <code>lower</code>, <code>upper</code>
as well as <code>scale</code>
are internally re-ordered in a way such that the overall variance of the
integrand is usually smaller than with the original ordering; this
usually leads smaller run-times.</p>
</dd>
<dt><code>cholesky.tol</code></dt><dd><p>non-negative numeric providing lower threshold
for non-zero elements in the computation of the cholesky factor: If
calculated <code class="reqn">C(i,i)^2 &lt; | cholesky.tol * Scale(i,i)|</code>, the diagonal
element (and all other elements in column <code class="reqn">i</code>) of the cholesky factor
<code class="reqn">C</code> are set to zero, yielding a singular matrix. <code>cholesky.tol</code>
defaults to <code>1e-9</code>.</p>
</dd>
</dl>

</dd>
<dt>For <code>dnvmix()</code> and <code>dgnvmix()</code>:</dt><dd>

<dl>
<dt><code>dnvmix.reltol</code>, <code>dnvmix.abstol</code></dt><dd><p>non-negative
<code><a href="base.html#topic+numeric">numeric</a></code> providing the relative/absolute precision for the *log-*
density required. Absolute precision via <code>dnvmix.abstol</code>
is only used when <code>dnvmix.reltol = NA</code>; in all other
cases, relative precision will be used. <code>dnvmix.reltol</code>
defaults to <code>1e-2</code>.
If <code>dnvmix.reltol=0</code> and <code>dnvmix.abstol=0</code>, the algorithm
will typically run until the total number of function evaluations exceeds
<code>fun.eval[2]</code> or until the total number of iterations exeeds
<code>max.iter.rqmc</code>, whichever happens first.
If <code class="reqn">n &gt; 1</code> (so <code>x</code> has more than one row), the algorithm runs until
the precision requirement is reached for all <code class="reqn">n</code> log-density estimates.</p>
</dd>
<dt><code>dnvmix.doAdapt</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating if an adaptive
integration procedure shall be used that only samples in relevant subdomains
of the mixing variable; defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>dnvmix.max.iter.rqmc.pilot</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, providing
the maximum number of unstratified, non-adaptive pilot runs the internal
integration procedure performs. Defaults to <code>6</code>.</p>
</dd>
<dt><code>dnvmix.tol.int.lower</code>, <code>dnvmix.order.lower</code></dt><dd>
<p>both <code><a href="base.html#topic+numeric">numeric</a></code> and nonnegative. RQMC integration
is only performed where the integrand is &gt; than the maximum of
<code>dnvmix.tol.int.lower</code> and <code class="reqn">10^{-c} g_{max}</code>, where
<code class="reqn">g_{max}</code> is the theoretical maximum of the integrand and <code class="reqn">c</code>
is the specified <code>dnvmix.order.lower</code>. Default to <code>1e-100</code>
and <code>5</code>, respectively.</p>
</dd>
<dt><code>dnvmix.tol.bisec</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> <code>vector</code> of
length 3 specifying bisection tolerances in the adaptive RQMC algorithm.
First/second/third element specify the tolerance on <code class="reqn">u</code>, <code class="reqn">W</code> and
the log-integrand and default to <code>1e-6</code>, <code>1e-1</code> and
<code>1e-1</code>, respectively.</p>
</dd>
<dt><code>dnvmix.max.iter.bisec</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, maximum number
of iterations in the internal bisection procedure to find good cutting
points allowed, defaults to <code>15</code>.</p>
</dd>
<dt><code>dnvmix.tol.stratlength</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, nonnegative.
If the stratum found by the adaptive integration method has length &gt;
<code>dnvmix.tol.stratlength</code> RQMC integration is used there; otherwise
a crude approximation. Defaults to <code>1e-50</code>.</p>
</dd>
</dl>

</dd>
<dt>For <code>fitnvmix()</code>:</dt><dd>

<dl>
<dt><code>ECMEstep</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code> (default),
ECME iteration is performed;
if <code>FALSE</code>, no ECME step is performed so that <code>fitnvmix()</code>
performs between zero and two optimizations over <code class="reqn">nu</code>, depending
on <code>laststep.do.nu</code> and whether <code>nu.init</code> was provided.</p>
</dd>
<dt><code>ECMEstep.do.nu</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code>
(default), the likelihood is maximized over <code class="reqn">nu</code> in each ECME
iteration; if <code>FALSE</code>, this step is omitted.</p>
</dd>
<dt><code>laststep.do.nu</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code>
another last maximization of the likelihood over <code class="reqn">nu</code> is
performed using all  observations after the ECME iterations.
Only makes sense if either <code>ECMEstep.do.nu=FALSE</code> or
if <code>size.subsample</code> is smaller than the number of observations.
Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>resample</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code>, a different
subsample of <code>x</code> is taken in each optimization over <code class="reqn">nu</code> in
the ECME iterations. Only relevant when <code>size.subsample</code> is
smaller than the number of observations. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>ECME.miniter</code>, <code>ECME.maxiter</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>
positive, minimum and maximum number
of ECME iterations. Default to <code>5</code> and <code>200</code>, respectively.</p>
</dd>
<dt><code>max.iter.locscaleupdate</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> positive.
Maximum number of location-scale updates (while helding <code class="reqn">nu</code> fixed)
in each individual ECME iteration; defaults to <code>50</code>.</p>
</dd>
<dt><code>weights.reltol</code></dt><dd><p><code>numeric</code> non-negative. Relative
tolerance to estimate internal weights used to update
<code class="reqn">loc</code> and <code class="reqn">scale</code> estimates in the ECME iterations. Defaults to
<code>1e-2</code>.</p>
</dd>
<dt><code>weights.interpol.reltol</code></dt><dd><p><code>numeric</code>
non-negative. Some weights can be obtained by interpolating
previously calculated weights; if the maximal relative
interpolation error is smaller than
<code>weights.interpol.reltol</code>, this is done. Defaults to <code>1e-2</code>.</p>
</dd>
<dt><code>ECME.rel.conv.tol</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a>(3)</code> vector
specifying relative convergence tolerances for <code>loc</code>, <code>scale</code>
and <code>nu</code> (in this order). Defaults to <code>c(1e-2, 1e-2, 1e-3)</code>.</p>
</dd>
<dt><code>control.optim</code></dt><dd><p><code><a href="base.html#topic+list">list</a></code> of control parameters
passed to the underlying <code>optim</code> in the initial step as well as
in the ECME iterations. See <code><a href="stats.html#topic+optim">optim</a>()</code> for details; defaults to
<code>list(maxit=75)</code>.</p>
</dd>
<dt><code>control.optim.laststep</code></dt><dd><p>like <code>control.optim</code>;
this list of control arguments is passed to <code>optim</code> in the last-step.
Only relevant when <code>laststep.do.nu = TRUE</code> and defaults to
<code>list()</code> (so no defaults of <code><a href="stats.html#topic+optim">optim</a>()</code> changed).</p>
</dd>
</dl>

</dd>
<dt>For <code>qnvmix()</code>:</dt><dd>

<dl>
<dt><code>max.iter.newton</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, maximum number
of Newton iterations allowed to approximate the quantile; defaults
to <code>45</code>.</p>
</dd>
<dt><code>newton.conv.abstol</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, convergence
tolerance for the Newton proceudre; convergence is detected once
the difference of estimated quantiles in two successive iterations
is smaller than <code>newton.conv.abstol</code>; defaults to <code>5e-4</code>.</p>
</dd>
<dt><code>newton.df.reltol</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, relative error
tolerance for estimating the univariate distribution function;
defaults to <code>2.5e-4</code>.</p>
</dd>
<dt><code>newton.logdens.abstol</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, absolute error
tolerance for the internal estimation of the log-density needed for the
update; defaults to <code>1e-2</code>.</p>
</dd>
<dt><code>newton.df.max.iter.rqmc</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, maximum
number of iterations to estimate the univariate distribution function
required in the Newton update; defaults to <code>350</code>. Note that
internally used is <code>increment = "doubling"</code>, no matter what.</p>
</dd>
</dl>

</dd>
<dt>For <code>qqplot_maha()</code>:</dt><dd>

<dl>
<dt><code>qqplot.df.reltol</code></dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code>, with the same
meaning as <code>newton.df.reltol</code> for the function <code>qnvmix()</code>.
Defaults to <code>5e-3</code>.</p>
</dd>
</dl>

</dd>
<dt>For <code>ES_nvmix()</code>:</dt><dd>

<dl>
<dt><code>riskmeasures.abstol, riskmeasures.reltol</code></dt><dd>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, absolute or relative error tolerance for
estimating riskmeasures, notably for <code>ES_nvmix()</code>. By default,
<code>riskmeasures.reltol=5e-2</code> and <code>riskmeasures.abstol=NA</code>,
so that a relative tolerance is used.</p>
</dd>
</dl>

</dd>
</dl>

<p>Care should be taken when changing algorithm specific parameters, notably
tolerances, as the accuracy of the result is heavily influenced by those.
</p>


<h3>Value</h3>

<p><code>get_set_param()</code> returns a <code><a href="base.html#topic+list">list</a></code> with more
than 30 elements specifying algorithm specific parameters for the
functions <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>, <code><a href="#topic+dnvmix">dnvmix</a>()</code>,
<code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>, <code><a href="#topic+pgammamix">pgammamix</a>()</code>,
<code><a href="#topic+dgammamix">dgammamix</a>()</code> and <code><a href="#topic+ES_nvmix">ES_nvmix</a>()</code>, as well as the
corresponding functions for grouped mixtures such as <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>
and <code><a href="#topic+dgnvmix">dgnvmix</a>()</code>.
Parameter values passed to <code>get_set_param()</code> via the
<code>control</code> argument overwrite the defaults; for parameters not
specified in the <code>control</code> argument, the default values are being
returned.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitnvmix">fitnvmix</a>()</code>, <code><a href="#topic+dnvmix">dnvmix</a>()</code>,
<code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>, <code><a href="#topic+pgammamix">pgammamix</a>()</code>,
<code><a href="#topic+dgammamix">dgammamix</a>()</code>, <code><a href="#topic+ES_nvmix">ES_nvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_set_param() # obtain defaults
</code></pre>

<hr>
<h2 id='get_set_qqplot_param'>Plotting parameters for QQ Plots</h2><span id='topic+get_set_qqplot_param'></span>

<h3>Description</h3>

<p>Plotting parameters for the method <code>plot()</code> of the class 
<code>qqplot_maha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_set_qqplot_param(plot.pars = list(log = ""))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_set_qqplot_param_+3A_plot.pars">plot.pars</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying plotting
parameters to be set; see below under details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a convenient way to set plotting parameters in the 
argument <code>plot.pars</code> of the 
function <code><a href="#topic+qqplot_maha">qqplot_maha</a>()</code> (more precisely, the underlying
<code>plot()</code> method), such as logarithmic plotting, colors, linetypes and more. 
</p>
<p>The input list <code>plot.pars</code> can contain any of the following:
</p>

<dl>
<dt><code>log</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> specifying the logarithmic 
axes. Just like for the generic <code>plot</code>, must be one of <code>""</code>,
<code>"x"</code>, <code>"y"</code> or <code>"xy"</code>. </p>
</dd>
<dt><code>xlim, ylim</code></dt><dd><p>The x- and y-limits for plotting.</p>
</dd>
<dt><code>xlab, ylab</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> specifying the x- and 
y-axis labels. Default to <code>"Theoretical quantiles"</code> and 
<code>"Sample quantiles"</code>, respectively.</p>
</dd>
<dt><code>sub, main</code></dt><dd><p><code><a href="base.html#topic+character">character</a></code> specifying title and subtitle
of the plot; default to <code>""</code>, so no titles.</p>
</dd>
<dt><code>plot_legend, plot_test, plot_line</code></dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> 
specifying if a legend should be plotted; if the test result of 
the GoF test should be displayed on the 3rd axis and if the plot should 
contain a fitted line. All default to <code>TRUE</code>.</p>
</dd>
<dt><code>pch</code></dt><dd><p>specification of the plotting symbol; see 
<code>?<a href="graphics.html#topic+points">points</a>()</code>. Defaults to <code>1</code>.</p>
</dd>
<dt><code>lty</code></dt><dd><p>3-<code><a href="base.html#topic+vector">vector</a></code> containing the specification of
the linetypes for i) the diagonal, ii) the asymptotic CI and iii)
the bootstrap CI; see also <code>?<a href="graphics.html#topic+par">par</a>()</code>. Defaults to 
<code>1:3</code>.</p>
</dd>
<dt><code>col</code></dt><dd><p>4-<code><a href="base.html#topic+vector">vector</a></code> specifying the colors to be used 
for i) the points in the QQ plot; ii) the diagonal; iii) the asymptotic
CI and iv) the bootstrap CI. Defaults to <code>c("black", "red", "azure4", 
    "chocolate4")</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>get_set_qqplot_param()</code> returns a <code><a href="base.html#topic+list">list</a></code> with 13 elements
that is passed to <code><a href="#topic+qqplot_maha">qqplot_maha</a>()</code>, more specifically, to the
underlying <code>plot()</code> method. 
Parameter values passed to <code>get_set_qqplot_param()</code> via the
<code>plot.pars</code> argument overwrite the defaults; for parameters not
specified in the <code>plot.pars</code> argument, the default values are being
returned.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqplot_maha">qqplot_maha</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>get_set_qqplot_param(plot.pars = list()) # obtain defaults

## See ?qqplot_maha() for more examples.
</code></pre>

<hr>
<h2 id='numerical_experiments_data'>Data Generated by the Demo 'numerical_experiments'</h2><span id='topic+numerical_experiments_data'></span>

<h3>Description</h3>

<p>Data generated by the <code>demo('numerical_experiments')</code> of the
<code>nvmix</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(numerical_experiments_data, package = "nvmix")</code></pre>


<h3>Format</h3>

<p>A list with 10 elements:
</p>

<dl>
<dt><code>$pnvmix.abserrors</code></dt><dd><p>Array as returned by the function
<code>pnvmix_testing_abserr()</code>, 
see Section 1.1 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$pnvmix.t.variances</code></dt><dd><p>Array as returned by the function
<code>precond_testing_variance()</code>,
see Section 1.1 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$pnvmix.t.sobolind</code></dt><dd><p>Array as returned by the function
<code>pnvmix_estimate_sobolind()</code>,
see Section 1.1 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$pnvmix.t.timing</code></dt><dd><p>Array as returned by the function
<code>pnvmix_timing_mvt()</code>,
see Section 1.1 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$dnvmix.results</code></dt><dd><p>Array as returned by the function
<code>dnvmix_testing()</code>,
see Section 1.2 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$fitnvmix.results</code></dt><dd><p>Array as returned by the function
<code>fitnvmix_testing()</code>,
see Section 1.3 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$fit.dj30.anaylytical</code></dt><dd><p>Array containing results of
<code>fitnvmix()</code> applied to DJ30 data using analytical
weights/densities, see Section 5 of
<code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$fit.dj30.estimated</code></dt><dd><p>Array containing results of
<code>fitnvmix()</code> applied to DJ30 data using estimated
weights/densities, see Section 5 of
<code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$qqplots.dj30</code></dt><dd><p>Array containing results of <code>qqplot.maha()</code>
applied to DJ30 data, see Section 5 of the <code>demo('numerical_experiments')</code>.</p>
</dd>
<dt><code>$tailprobs.dj30</code></dt><dd><p>Array containing estimated quantile shortfall
probabilities of models fitted to DJ30 data, see Section 5 of
<code>demo('numerical_experiments')</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>

<hr>
<h2 id='pgnvmix'>Distribution Function of Grouped Multivariate Normal Variance Mixtures</h2><span id='topic+pgnvmix'></span><span id='topic+pgStudent'></span>

<h3>Description</h3>

<p>Evaluating grouped and generalized multivariate normal variance mixture distribution
functions (including Student <em>t</em> with multiple degrees-of-freedom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgnvmix(upper, lower = matrix(-Inf, nrow = n, ncol = d), groupings = 1:d, qmix,
        rmix, loc = rep(0, d), scale = diag(d), standardized = FALSE,
        control = list(), verbose = TRUE, ...)

pgStudent(upper, lower = matrix(-Inf, nrow = n, ncol = d), groupings = 1:d, df,
          loc = rep(0, d), scale = diag(d), standardized = FALSE,
          control = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pgnvmix_+3A_upper">upper</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_lower">lower</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_groupings">groupings</code></td>
<td>
<p><code class="reqn">d</code>-<code><a href="base.html#topic+vector">vector</a></code>. Specification of the groupings
so that variable <code class="reqn">i</code> has mixing variable <code class="reqn">W_k</code> where
<code>k = groupings[i]</code>. If <code>groupings = 1:d</code>, each variable has a different
mixing distribution. </p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variables <code class="reqn">W_i</code> via quantile
functions; see McNeil et al. (2015, Chapter 6) and Hintz et al. (2020).
Supported are the following types of
specification (see also the examples below):
</p>
<dl>
<dt><code><a href="base.html#topic+character">character</a></code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string
specifying a supported distribution; currently available are
<code>"inverse.gamma"</code> (in which case <code class="reqn">W_i</code> is
inverse gamma distributed with shape and rate parameters
<code>df[groupings[i]]</code>/2 and a multivariate
Student <em>t</em> distribution multiple degreess-of-freedom
results) and
<code>"pareto"</code> (in which case <code class="reqn">W_i</code> is
Pareto distributed with scale equal to unity and shape equal to
<code>alpha[groupings[i]]</code>. <code>alpha</code> and <code>df</code> must be of length
<code>length(unique(groupings))</code> and need to be provided via the ellipsis
argument).</p>
</dd>
<dt><code><a href="base.html#topic+list">list</a></code>:</dt><dd><p><code><a href="base.html#topic+list">list</a></code> of length
<code>length(unique(groupings))</code> (number of different mixing distributions).
Element <code class="reqn">i</code> of this list specifies the mixing variable for component
<code>groupings[i]</code>. Each element of this list can be
</p>
<dl>
<dt><code><a href="base.html#topic+list">list</a></code>:</dt><dd><p>a <code><a href="base.html#topic+list">list</a></code> of length at
least one, where the first component is a <code><a href="base.html#topic+character">character</a></code>
string specifying the base name of a distribution whose
quantile function can be accessed via the prefix <code>"q"</code>. An example
<code>"exp"</code> for which <code>"qexp"</code> exists.
If the list is of length larger than one, the remaining elements
contain additional parameters of the distribution; for <code>"exp"</code>,
for example, this can be the parameter <code>rate</code>.</p>
</dd>
<dt><code><a href="base.html#topic+function">function</a></code>:</dt><dd><p><code><a href="base.html#topic+function">function</a></code>
interpreted as the quantile function or random number generator of the mixing
variable <code class="reqn">W_i</code></p>
</dd></dl>
</dd>
</dl>

</td></tr>
<tr><td><code id="pgnvmix_+3A_rmix">rmix</code></td>
<td>
<p>only allowed when <code>groupings = rep(1, d)</code> in which case
<code>pgnvmix()</code> is equivalent to <code><a href="#topic+pnvmix">pnvmix</a>()</code>; see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_df">df</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> of length <code>length(unique(groupings))</code> so that
variable <code>i</code> has degrees-of-freedom <code>df[groupings[i]]</code>; all elements
must be positive
and can be <code>Inf</code>, in which case the corresponding marginal is normally
distributed.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_loc">loc</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>; must be positive definite.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_standardized">standardized</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="pgnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed
to the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or an element of <code>qmix</code> is a
<code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One should highlight that evaluating grouped normal variance mixtures is a
non-trivial tasks which, at the time of development of <span class="pkg">nvmix</span>,
was not available in <span class="rlang"><b>R</b></span> before, not even the special case of a
multivariate Student <em>t</em> distribution for non-integer degrees of
freedoms, which frequently appears in applications in finance,
insurance and risk management after estimating such distributions.
</p>
<p>Internally, an iterative randomized Quasi-Monte Carlo (RQMC) approach
is used to estimate the probabilities. It is an iterative algorithm
that evaluates the integrand at a point-set (with size as specified by
<code>control$increment</code> in the <code>control</code> argument) in each
iteration until the pre-specified absolute error tolerance
<code>control$pnvmix.abstol</code> (or relative error tolerance
<code>control$pnvmix.reltol</code> which is used only when
<code>control$pnvmix.abstol = NA</code>) is reached.  The attribute
<code>"numiter"</code> gives the number of such iterations needed.
Algorithm specific parameters (such as the above mentioned
<code>control$pnvmix.abstol</code>) can be passed as a list
via <code>control</code>, see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for more
details. If specified error tolerances are not reached and
<code>verbose = TRUE</code>, a warning is thrown.
</p>
<p><code>pgStudent()</code> is a wrapper of
<code>pgnvmix(, qmix = "inverse.gamma", df = df)</code>.
</p>


<h3>Value</h3>

<p><code>pgnvmix()</code> and <code>pgStudent()</code> return a
<code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed probabilities
and corresponding attributes <code>"abs. error"</code> and <code>"rel. error"</code>
(error estimates of the RQMC estimator) and <code>"numiter"</code> (number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Genz, A. and Bretz, F. (1999).
Numerical computation of multivariate t-probabilities with
application to power calculation of multiple contrasts.
<em>Journal of Statistical Computation and Simulation</em> 63(4),
103&ndash;117.
</p>
<p>Genz, A. and Bretz, F. (2002).
Comparison of methods for the computation of multivariate <em>t</em>
probabilities.
<em>Journal of Computational and Graphical Statistics</em> 11(4),
950&ndash;971.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rgnvmix">rgnvmix</a>()</code>, <code><a href="#topic+dgnvmix">dgnvmix</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples for pgnvmix() #####################################################

## 1. Inverse-gamma mixture (=&gt; distribution is grouped t with mutliple dof)
d &lt;- 3
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))
a &lt;- -3 * runif(d) * sqrt(d) # random lower limit
b &lt;-  3 * runif(d) * sqrt(d) # random upper limit
df &lt;- c(1.1, 2.4, 4.9) # dof for margin i
groupings &lt;- 1:d

### Call 'pgnvmix' with 'qmix' a string:
set.seed(12)
(pgt1 &lt;- pgnvmix(b, lower = a, groupings = groupings, qmix = "inverse.gamma",
                df = df, scale = P))
### Version providing quantile functions of the mixing distributions as list
qmix_ &lt;- function(u, df) 1 / qgamma(1-u, shape = df/2, rate = df/2)
qmix &lt;- list(function(u) qmix_(u, df = df[1]), function(u) qmix_(u, df = df[2]),
             function(u) qmix_(u, df = df[3]))
set.seed(12)
(pgt2 &lt;- pgnvmix(b, lower = a, groupings = groupings, qmix = qmix, scale = P))
### Similar, but using ellipsis argument:
qmix &lt;- list(function(u, df1) qmix_(u, df1), function(u, df2) qmix_(u, df2),
             function(u, df3) qmix_(u, df3))
set.seed(12)
(pgt3 &lt;- pgnvmix(b, lower = a, groupings = groupings, qmix = qmix,
                        scale = P, df1 = df[1], df2 = df[2], df3 = df[3]))
## Version using the user friendly wrapper 'pgStudent()'
set.seed(12)
(pgt4 &lt;- pgStudent(b, lower = a, groupings = groupings, scale = P, df = df))
stopifnot(all.equal(pgt1, pgt2, tol = 1e-4, check.attributes = FALSE),
          all.equal(pgt2, pgt3), all.equal(pgt1, pgt4))

## 2. More complicated mixutre
## Let W1 ~ IG(1, 1), W2 = 1, W3 ~ Exp(1), W4 ~ Par(2, 1), W5 = W1, all comonotone
## =&gt; X1 ~ t_2; X2 ~ normal; X3 ~ Exp-mixture; X4 ~ Par-mixture; X5 ~ t_2

d &lt;- 5
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))
b &lt;- 3 * runif(d) * sqrt(d) # random upper limit
groupings &lt;- c(1, 2, 3, 4, 1) # since W_5 = W_1
qmix &lt;- list(function(u) qmix_(u, df = 2), function(u) rep(1, length(u)),
             list("exp", rate=1), function(u) (1-u)^(-1/2)) # length 4 (# of groups)
pg1 &lt;- pgnvmix(b, groupings = groupings, qmix = qmix, scale = P)
stopifnot(all.equal(pg1, 0.78711, tol = 5e-6, check.attributes = FALSE))
</code></pre>

<hr>
<h2 id='pnvmix'>Distribution Function of Multivariate Normal Variance Mixtures</h2><span id='topic+pnvmix'></span><span id='topic+pStudent'></span><span id='topic+pNorm'></span>

<h3>Description</h3>

<p>Evaluating multivariate normal variance mixture distribution functions
(including Student <em>t</em> and normal distributions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnvmix(upper, lower = matrix(-Inf, nrow = n, ncol = d), qmix, rmix,
      loc = rep(0, d), scale = diag(d), standardized = FALSE,
      control = list(), verbose = TRUE, ...)

pStudent(upper, lower = matrix(-Inf, nrow = n, ncol = d), df, loc = rep(0, d),
         scale = diag(d), standardized = FALSE, control = list(), verbose = TRUE)
pNorm(upper, lower = matrix(-Inf, nrow = n, ncol = d), loc = rep(0, d),
      scale = diag(d), standardized = FALSE, control = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnvmix_+3A_upper">upper</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of upper integration limits;
each row represents a <code class="reqn">d</code>-vector of upper integration limits.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_lower">lower</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of lower integration limits
(componentwise less than or equal to <code>upper</code>);
each row represents a <code class="reqn">d</code>-vector of lower integration limits.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_qmix">qmix</code>, <code id="pnvmix_+3A_rmix">rmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code> via a quantile
function (<code>qmix</code>) (recommended, see details below)
*or* random number generator (<code>rmix</code>); see McNeil et
al. (2015, Chapter 6) and Hintz et al. (2020). Supported are the following types of
specification (see also the examples below):
</p>
<dl>
<dt><code><a href="base.html#topic+character">character</a></code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string
specifying a supported distribution; currently available are
<code>"constant"</code> (in which case <code class="reqn">W = 1</code> and thus
the multivariate normal distribution with mean vector
<code>loc</code> and covariance matrix <code>scale</code> results),
<code>"inverse.gamma"</code> (in which case <code class="reqn">W</code> is
inverse gamma distributed with shape and rate parameters
<code>df</code>/2 and thus the multivariate
Student <em>t</em> distribution with <code>df</code> degrees of freedom
(required to be provided via the ellipsis argument) results) and
<code>"pareto"</code> (in which case <code class="reqn">W</code> is
Pareto distributed with scale equal to unity and shape equal to
<code>alpha</code>, which needs to be provided via the ellipsis
argument).</p>
</dd>
<dt><code><a href="base.html#topic+list">list</a></code>:</dt><dd><p><code><a href="base.html#topic+list">list</a></code> of length at least
one, where the first component is a <code><a href="base.html#topic+character">character</a></code>
string specifying the base name of a distribution whose
quantile function or random number generator can be accessed via the prefix
<code>"q"</code> and <code>"r"</code>, respectively.
an example is <code>"exp"</code> for which <code>"qexp"</code> exists.
If the list is of length larger than one, the remaining elements
contain additional parameters of the distribution; for <code>"exp"</code>,
for example, this can be the parameter <code>rate</code>.</p>
</dd>
<dt><code><a href="base.html#topic+function">function</a></code>:</dt><dd><p><code><a href="base.html#topic+function">function</a></code>
interpreted as the quantile function or random number generator of the mixing
variable <code class="reqn">W</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="pnvmix_+3A_df">df</code></td>
<td>
<p>positive degress of freedom; can also be <code>Inf</code> in which
case the distribution is interpreted as the multivariate normal
distribution with mean vector <code>loc</code> and covariance matrix
<code>scale</code>.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_loc">loc</code></td>
<td>
<p>location vector of dimension <code class="reqn">d</code>; this equals the mean
vector of a random vector following the specified normal variance
mixture distribution if and only if the latter exists.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_scale">scale</code></td>
<td>
<p>scale matrix (a covariance matrix entering the
distribution as a parameter) of dimension <code class="reqn">(d, d)</code>;
this equals the covariance matrix of a random vector following
the specified normal variance mixture distribution divided by
the expecation of the mixing variable <code class="reqn">W</code> if and only if the
former exists. <code>scale</code> is allowed to be singular in which case
the distribution function of the singular normal variance mixture
is returned.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_standardized">standardized</code></td>
<td>
<p><code>logical</code> indicating whether <code>scale</code> is
assumed to be a correlation matrix.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_verbose">verbose</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>
indicating whether a warning is thrown if the required precision
<code>pnvmix.abstol</code> or <code>pnvmix.reltol</code> as specified in the
<code>control</code> argument has not been reached; can also be an
<code><a href="base.html#topic+integer">integer</a></code> in which case 0 is <code>FALSE</code>, 1 is
<code>TRUE</code> and 2 stands for producing a more verbose warning (for
each set of provided integration bounds).</p>
</td></tr>
<tr><td><code id="pnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed
to the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One should highlight that evaluating normal variance mixtures is a
non-trivial tasks which, at the time of development of <span class="pkg">nvmix</span>,
was not available in <span class="rlang"><b>R</b></span> before, not even the special case of a
multivariate Student <em>t</em> distribution for non-integer degrees of
freedom, which frequently appears in applications in finance,
insurance and risk management after estimating such distributions.
</p>
<p>Note that the procedures call underlying C code. Currently, dimensions
<code class="reqn">d\ge 16510</code> are not supported for the default method
<code>sobol</code>.
</p>
<p>Internally, an iterative randomized Quasi-Monte Carlo (RQMC) approach
is used to estimate the probabilities. It is an iterative algorithm
that evaluates the integrand at a point-set (with size as specified by
<code>control$increment</code> in the <code>control</code> argument) in each
iteration until the pre-specified absolute error tolerance
<code>control$pnvmix.abstol</code> (or relative error tolerance
<code>control$pnvmix.reltol</code> which is used only when
<code>control$pnvmix.abstol = NA</code>) is reached.  The attribute
<code>"numiter"</code> gives the number of such iterations needed.
Algorithm specific parameters (such as the above mentioned
<code>control$pnvmix.abstol</code>) can be passed as a list
via <code>control</code>, see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for more
details. If specified error tolerances are not reached and
<code>verbose = TRUE</code>, a warning is thrown.
</p>
<p>If provided <code>scale</code>
is singular, <code>pnvmix()</code> estimates the correct probability but
throws a warning if <code>verbose = TRUE</code>.
</p>
<p>It is recommended to supply a quantile function via <code>qmix</code>, if available,
as in this case efficient RQMC methods are used to approximate the probability.
If <code>rmix</code> is provided, internally used is
plain MC integration, typically leading to slower convergence.
If both <code>qmix</code> and <code>rmix</code> are provided, the latter
is ignored.
</p>
<p><code>pStudent()</code> and <code>pNorm()</code> are wrappers of
<code>pnvmix(, qmix = "inverse.gamma", df = df)</code> and
<code>pnvmix(, qmix = "constant")</code>, respectively.
In the univariate case, the functions
<code><a href="stats.html#topic+pt">pt</a>()</code> and <code><a href="stats.html#topic+pnorm">pnorm</a>()</code> are used.
</p>


<h3>Value</h3>

<p><code>pnvmix()</code>, <code>pStudent()</code> and <code>pNorm()</code> return a
<code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed probabilities
and corresponding attributes <code>"abs. error"</code> and <code>rel. error</code>
(error estimates of the RQMC estimator) and <code>"numiter"</code> (number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Genz, A. and Bretz, F. (1999).
Numerical computation of multivariate t-probabilities with
application to power calculation of multiple contrasts.
<em>Journal of Statistical Computation and Simulation</em> 63(4),
103&ndash;117.
</p>
<p>Genz, A. and Bretz, F. (2002).
Comparison of methods for the computation of multivariate <em>t</em>
probabilities.
<em>Journal of Computational and Graphical Statistics</em> 11(4),
950&ndash;971.
</p>
<p>Genz, A. and Kwong, K. (2000).
Numerical evaluation of singular multivariate normal distributions.
<em>Journal of Statistical Computation and Simulation</em> 68(1),
1&ndash;21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>,
<code><a href="#topic+pgnvmix">pgnvmix</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples for pnvmix() ######################################################

## Generate a random correlation matrix in d dimensions
d &lt;- 3
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))

## Evaluate a t_{1/2} distribution function
a &lt;- -3 * runif(d) * sqrt(d) # random lower limit
b &lt;-  3 * runif(d) * sqrt(d) # random upper limit
df &lt;- 1.5 # note that this is *non-integer*
set.seed(123)
pt1 &lt;- pnvmix(b, lower = a, qmix = "inverse.gamma", df = df, scale = P)

## Here is a version providing the quantile function of the mixing distribution
qmix &lt;- function(u, df) 1 / qgamma(1-u, shape = df/2, rate = df/2)
mean.sqrt.mix &lt;- sqrt(df) * gamma(df/2) / (sqrt(2) * gamma((df+1) / 2))
set.seed(123)
pt2 &lt;- pnvmix(b, lower = a, qmix = qmix, df  = df, scale = P,
              control = list(mean.sqrt.mix = mean.sqrt.mix))

## Compare
stopifnot(all.equal(pt1, pt2, tol = 7e-4, check.attributes = FALSE))

## mean.sqrt.mix will be approximated by QMC internally if not provided,
## so the results will differ slightly.
set.seed(123)
pt3 &lt;- pnvmix(b, lower = a, qmix = qmix, df = df, scale = P)
stopifnot(all.equal(pt3, pt1, tol = 7e-4, check.attributes = FALSE))

## Here is a version providing a RNG for the mixing distribution
## Note the significantly larger number of iterations in the attribute 'numiter'
## compared to when 'qmix' was provided (=&gt; plain MC versus RQMC)
set.seed(123)
pt4 &lt;- pnvmix(b, lower = a,
              rmix = function(n, df) 1/rgamma(n, shape = df/2, rate = df/2),
              df = df, scale = P)
stopifnot(all.equal(pt4, pt1, tol = 8e-4, check.attributes = FALSE))

## Case with missing data and a matrix of lower and upper bounds
a. &lt;- matrix(rep(a, each = 4), ncol = d)
b. &lt;- matrix(rep(b, each = 4), ncol = d)
a.[2,1] &lt;- NA
b.[3,2] &lt;- NA
pt &lt;- pnvmix(b., lower = a., qmix = "inverse.gamma", df = df, scale = P)
stopifnot(is.na(pt) == c(FALSE, TRUE, TRUE, FALSE))

## Case where upper = (Inf,..,Inf) and lower = (-Inf,...,-Inf)
stopifnot(all.equal(pnvmix(upper = rep(Inf, d), qmix = "constant"), 1,
                    check.attributes = FALSE))

## An example with singular scale:
A &lt;- matrix( c(1, 0, 0, 0,
               2, 1, 0, 0,
               3, 0, 0, 0,
               4, 1, 0, 1), ncol = 4, nrow = 4, byrow = TRUE)
scale &lt;- A%*%t(A)
upper &lt;- 2:5

pn &lt;- pnvmix(upper, qmix = "constant", scale = scale) # multivariate normal
pt &lt;- pnvmix(upper, qmix = "inverse.gamma", scale = scale, df = df) # multivariate t

stopifnot(all.equal(pn, 0.8581, tol = 1e-3, check.attributes = FALSE))
stopifnot(all.equal(pt, 0.7656, tol = 1e-3, check.attributes = FALSE))

## Evaluate a Exp(1)-mixture
## Specify the mixture distribution parameter
rate &lt;- 1.9 # exponential rate parameter

## Method 1: Use R's qexp() function and provide a list as 'mix'
set.seed(42)
(p1 &lt;- pnvmix(b, lower = a, qmix = list("exp", rate = rate), scale = P))

## Method 2: Define the quantile function manually (note that
##           we do not specify rate in the quantile function here,
##           but conveniently pass it via the ellipsis argument)
set.seed(42)
(p2 &lt;- pnvmix(b, lower = a, qmix = function(u, lambda) -log(1-u)/lambda,
              scale = P, lambda = rate))

## Check
stopifnot(all.equal(p1, p2))


### Examples for pStudent() and pNorm() ########################################

## Evaluate a t_{3.5} distribution function
set.seed(271)
pt &lt;- pStudent(b, lower = a, df = 3.5, scale = P)
stopifnot(all.equal(pt, 0.6180, tol = 7e-5, check.attributes = FALSE))

## Evaluate a normal distribution function
set.seed(271)
pn &lt;- pNorm(b, lower = a, scale = P)
stopifnot(all.equal(pn, 0.7001, tol = 1e-4, check.attributes = FALSE))

## pStudent deals correctly with df = Inf:
set.seed(123)
p.St.dfInf &lt;- pStudent(b, df = Inf, scale = P)
set.seed(123)
p.Norm &lt;- pNorm(b, scale = P)
stopifnot(all.equal(p.St.dfInf, p.Norm, check.attributes = FALSE))
</code></pre>

<hr>
<h2 id='qnvmix'>Quantile Function of a univariate Normal Variance Mixture Distribution</h2><span id='topic+qnvmix'></span>

<h3>Description</h3>

<p>Evaluating multivariate normal variance mixture distribution functions
(including normal and Student <em>t</em> for non-integer degrees of freedom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnvmix(u, qmix, control = list(),
       verbose = TRUE, q.only = TRUE, stored.values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qnvmix_+3A_u">u</code></td>
<td>
<p>vector of probabilities .</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code>; see
<code><a href="#topic+pnvmix">pnvmix</a>()</code> for details and examples.</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, if <code>TRUE</code> a warning is printed if
one of the error tolerances is not met.</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_q.only">q.only</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>. If <code>TRUE</code>, only the quantiles are
returned; if <code>FALSE</code>, see Section 'value' below.</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_stored.values">stored.values</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code> with 3 columns of the form
<code class="reqn">[x, F(x), logf(x)]</code> where <code class="reqn">F()</code> and <code class="reqn">logf()</code> are the distribution-
and log-density function of the distribution specified in <code>qmix</code>.
If provided it is used to determine starting values for internal newton proceudures.
Only very basic checking is done.</p>
</td></tr>
<tr><td><code id="qnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments containing parameters of
mixing distributions when <code>qmix</code> is a <code><a href="base.html#topic+character">character</a></code>
string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a Newton procedure to estimate the quantile of the
specified univariate normal variance mixture distribution. Internally,
a randomized quasi-Monte Carlo (RQMC) approach is used to estimate the
distribution and (log)density function; the method is similar to the
one in <code><a href="#topic+pnvmix">pnvmix</a>()</code> and <code><a href="#topic+dnvmix">dnvmix</a>()</code>. The result depends
slightly on <code>.random.seed</code>.
</p>
<p>Internally, symmetry is used for <code class="reqn">u \le 0.5</code>. Function values
(i.e., df and log-density values) are stored and reused to get good
starting values. These values are returned if <code>q.only = FALSE</code>
and can be re-used by passing it to <code>qnvmix()</code> via the argument
<code>stored.values</code>; this can significantly reduce run-time.
</p>
<p>Accuracy and run-time depend on both the magnitude of <code class="reqn">u</code> and on
how heavy the tail of the underlying distributions is.  Numerical
instabilities can occur for values of <code class="reqn">u</code> close to 0 or 1,
especially when the tail of the distribution is heavy.
</p>
<p>If <code>q.only = FALSE</code> the log-density values of the underlying
distribution evaluated at the estimated quantiles are returned as
well: This can be useful for copula density evaluations where both
quantities are needed.
</p>
<p>Underlying algorithm specific parameters can be changed via the <code>control</code>
argument, see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for details.
</p>


<h3>Value</h3>

<p>If <code>q.only = TRUE</code> a vector of the same length as <code>u</code> with
entries <code class="reqn">q_i</code> where <code class="reqn">q_i</code> satisfies <code class="reqn">q_i = inf_x { F(x)
  \ge u_i}</code> where <code class="reqn">F(x)</code> the univariate df of the normal variance
mixture specified via <code>qmix</code>;
</p>
<p>if <code>q.only = FALSE</code> a list of four:
</p>

<dl>
<dt><code>$q</code>:</dt><dd><p>Vector of quantiles,</p>
</dd>
<dt><code>$log.density</code>:</dt><dd><p>vector log-density values at <code>q</code>,</p>
</dd>
<dt><code>$computed.values</code>:</dt><dd><p>matrix with 3 columns [x, F(x), logf(x)];
see details above,</p>
</dd>
<dt><code>$newton.iterations</code>:</dt><dd><p>vector giving the number of Newton
iterations needed for <code>u[i]</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R., and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Evaluation points
u &lt;- seq(from = 0.05, to = 0.95, by = 0.025)
set.seed(271) # for reproducibility

## Evaluate the t_{1.4} quantile function
df &lt;- 1.4
qmix. &lt;- function(u) 1/qgamma(1-u, shape = df/2, rate = df/2)
## If qmix = "inverse.gamma", qt() is being called
qt1 &lt;- qnvmix(u, qmix = "inverse.gamma", df = df)
## Estimate quantiles (without using qt())
qt1. &lt;- qnvmix(u, qmix = qmix., q.only = FALSE)
stopifnot(all.equal(qt1, qt1.$q, tolerance = 2.5e-3))
## Look at absolute error:
abs.error &lt;- abs(qt1 - qt1.$q)
plot(u, abs.error, type = "l", xlab = "u", ylab = "Absolute error")
## Now do this again but provide qt1.$stored.values, in which case at most
## one Newton iteration will be needed:
qt2 &lt;- qnvmix(u, qmix = qmix., stored.values = qt1.$computed.values, q.only = FALSE)
stopifnot(max(qt2$newton.iterations) &lt;= 1)

</code></pre>

<hr>
<h2 id='qqplot_maha'>QQ Plot for Multivariate Normal Variance Mixtures</h2><span id='topic+qqplot_maha'></span>

<h3>Description</h3>

<p>Visual goodness-of-fit test for multivariate normal variance mixtures:
Plotting squared Mahalanobis distances against their theoretical quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqplot_maha(x, qmix, loc, scale, fitnvmix_object,
            trafo.to.normal = FALSE, test = c("KS.AD", "KS", "AD", "none"),
            boot.pars = list(B = 500, level = 0.95),
            plot = TRUE, verbose = TRUE, control = list(),
            digits = max(3, getOption("digits") - 4), plot.pars = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqplot_maha_+3A_x">x</code></td>
<td>
<p><code class="reqn">(n, d)</code>-data <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_qmix">qmix</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_loc">loc</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_fitnvmix_object">fitnvmix_object</code></td>
<td>
<p>Optional. Object of class <code>"fitnvmix"</code> typically
returned by <code><a href="#topic+fitnvmix">fitnvmix</a>()</code>; if provided, <code>x</code>, <code>qmix</code>,
<code>loc</code> and <code>scale</code> are ignored.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_trafo.to.normal">trafo.to.normal</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>. If <code>TRUE</code>, the
underlying Mahalanobis distances are mapped to normals by a probability-
quantile-transform so that the resulting QQ plot is essentially a normal
QQ plot. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_test">test</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> specifying if (and which) GoF test
shall be performed. <code>"KS"</code> performs a Kolmogorov-Smirnoff (see
<code><a href="stats.html#topic+ks.test">ks.test</a>()</code>), <code>"AD"</code> an Anderson-Darling test (see
<code><a href="ADGofTest.html#topic+ad.test">ad.test</a>()</code> from the package <code>ADGofTest</code> and <code>"none"</code>
performs no test. By default, <code>test = "KS.AD"</code> in which case both tests
are performed.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_boot.pars">boot.pars</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> with elements <code>B</code>
(Bootstrap sample size for computing CIs; if <code>B &lt;= 1</code>,
no Bootstrap is performed) and
<code>level</code> specifying the confidence level.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_plot">plot</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> specifying if the results should be
plotted.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_verbose">verbose</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_control">control</code></td>
<td>
<p>see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_digits">digits</code></td>
<td>
<p>integer specifying the number of digits of the test
statistic and the p-value to be displayed.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_plot.pars">plot.pars</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying plotting parameters such
as logarithmic axes; see <code><a href="#topic+get_set_qqplot_param">get_set_qqplot_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="qqplot_maha_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to the
underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows a multivariate normal variance mixture, the distribution of
the Mahalanobis distance <code class="reqn">D^2 = (X-\mu)^T \Sigma^{-1} (X-\mu)</code>
is a gamma mixture whose distribution function can be approximated.
</p>
<p>The function <code>qqplot_maha()</code> first estimates the theoretical quantiles
by calling <code><a href="#topic+qgammamix">qgammamix</a>()</code> and then plots those against
the empirical squared Mahalanobis distances
from the data in <code>x</code> (with <code class="reqn">\mu=</code><code>loc</code> and
<code class="reqn">\Sigma=</code><code>scale</code>). Furthermore, the function computes
asymptotic standard errors of the sample quantiles by using an asymptotic
normality result for the order statistics which
are used to plot the asymptotic CI; see Fox (2008, p. 35 &ndash; 36).+
</p>
<p>If <code>boot.pars$B &gt; 1</code> (which is the default), the function additionally
performs Bootstrap to construct a CI. Note that by default, the plot contains
both the asymptotic and the Bootstrap CI.
</p>
<p>Finally, depending on the parameter <code>test</code>, the function performs a
univariate GoF test of the observed Mahalanobis distances as described above.
The test result (i.e., the value of the statistic along with a p-value) are
typically plotted on the second y-axis.
</p>
<p>The return object of class <code>"qqplot_maha"</code> contains all computed values
(such as p-value, test-statistics, Bootstrap CIs and more). We highlight that
storing this return object makes the QQ plot
quickly reproducible, as in this case, the theoretical quantiles do not need
to be recomputed.
</p>
<p>For changing plotting parameters (such as logarithmic axes or colors)
via the argument <code>plot.pars</code>, see <code><a href="#topic+get_set_qqplot_param">get_set_qqplot_param</a>()</code>.
</p>


<h3>Value</h3>

<p><code>qqplot_maha()</code> (invisibly) returns an object of the class
<code>"qqplot_maha"</code> for which the methods <code>plot()</code> and <code>print()</code>
are defined. The return object contains, among others, the components
</p>

<dl>
<dt><code>maha2</code></dt><dd><p>Sorted, squared Mahalanobis distances of the data
from <code>loc</code> wrt to <code>scale</code>.</p>
</dd>
<dt><code>theo_quant</code></dt><dd><p>The theoretical quantile function
evaluated at <code>ppoints(length(maha2))</code>.</p>
</dd>
<dt><code>boot_CI</code></dt><dd><p><code class="reqn">(2,length(maha2))</code> matrix containing the
Bootstrap CIs for the empirical quantiles.</p>
</dd>
<dt><code>asymptSE</code></dt><dd><p><code><a href="base.html#topic+vector">vector</a></code> of length <code>length(maha2)</code>
with estimated, asympotic standard errors for the empirical quantiles.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitnvmix">fitnvmix</a>()</code>, <code><a href="#topic+get_set_qqplot_param">get_set_qqplot_param</a>()</code>,
<code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+dnvmix">dnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample from a heavy tailed multivariate t and construct QQ plot
set.seed(1)
d &lt;- 2
n &lt;- 1000
df &lt;- 3.1
rho &lt;- 0.5
loc &lt;- rep(0, d)
scale &lt;- matrix(c(1, rho, rho, 1), ncol = 2)
qmix &lt;- "inverse.gamma"
## Sample data
x &lt;- rnvmix(n, qmix = qmix, loc = loc, scale = scale, df = df)
# Construct QQ Plot with 'true' parameters and store result object
qq1 &lt;- qqplot_maha(x, qmix = qmix, df = df, loc = loc, scale = scale)
## ... which is an object of class "qqplot_maha" with two methods
stopifnot(class(qq1) == "qqplot_maha", "plot.qqplot_maha" %in% methods(plot),
          "print.qqplot_maha" %in% methods(print))
plot(qq1) # reproduce the plot
plot(qq1, plotpars = list(log = "xy")) # we can also plot on log-log scale

## In fact, with the 'plotpars' argument, we can change a lot of things
plot(qq1, plotpars = list(col = rep("black", 4), lty = 4:6, pch = "*",
                          plot_test = FALSE, main = "Same with smaller y limits",
                          sub = "MySub", xlab = "MyXlab", ylim = c(0, 1.5e3)))

## What about estimated parameters?
myfit &lt;- fitStudent(x)
## We can conveniently pass 'myfit', rather than specifying 'x', 'loc', ...
set.seed(1)
qq2.1 &lt;- qqplot_maha(fitnvmix_object = myfit, test = "AD", trafo_to_normal = TRUE)
set.seed(1)
qq2.2 &lt;- qqplot_maha(x, qmix = "inverse.gamma", loc = myfit$loc,
                     scale = myfit$scale, df = myfit$df,
                     test = "AD", trafo_to_normal = TRUE)
stopifnot(all.equal(qq2.1$boot_CI, qq2.2$boot_CI)) # check
qq2.2 # it mentions here that the Maha distances were transformed to normal


## Another example where 'qmix' is a function, so quantiles are internally
## estimated via 'qgammamix()'
n &lt;- 15 # small sample size to have examples run fast
## Define the quantile function of an IG(nu/2, nu/2) distribution
qmix &lt;- function(u, df) 1 / qgamma(1 - u, shape = df/2, rate = df/2)
## Sample data
x &lt;- rnvmix(n, qmix = qmix, df = df, loc = loc, scale = scale)
## QQ Plot of empirical quantiles vs true quantiles, all values estimated
## via RQMC:
set.seed(1)
qq3.1 &lt;- qqplot_maha(x, qmix = qmix, loc = loc, scale = scale, df = df)
## Same could be obtained by specifying 'qmix' as string in which case
## qqplot_maha() calls qf()
set.seed(1)
qq3.2 &lt;- qqplot_maha(x, qmix = "inverse.gamma", loc = loc, scale = scale, df = df)
</code></pre>

<hr>
<h2 id='rgnvmix'>(Quasi-)Random Number Generator for Grouped Normal Variance Mixtures</h2><span id='topic+rgnvmix'></span><span id='topic+rgStudent'></span>

<h3>Description</h3>

<p>Generate vectors of random variates from grouped normal variance
mixtures (including Student <em>t</em> with multiple degrees-of-freedom).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgnvmix(n, qmix, groupings = 1:d, loc = rep(0, d), scale = diag(2),
       factor = NULL, method = c("PRNG", "sobol", "ghalton"), skip = 0, ...)
rgStudent(n, groupings = 1:d, df, loc = rep(0, d), scale = diag(2),
          factor = NULL, method = c("PRNG", "sobol", "ghalton"), skip = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgnvmix_+3A_n">n</code></td>
<td>
<p>sample size <code class="reqn">n</code> (positive integer).</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variables <code class="reqn">W_i</code>; see
<code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_groupings">groupings</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> specifying the group structure; see
<code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_df">df</code></td>
<td>
<p><code><a href="base.html#topic+vector">vector</a></code> specifying the degrees-of-freedom; see
see <code><a href="#topic+pgStudent">pgStudent</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_loc">loc</code></td>
<td>
<p>see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>. <code>scale</code> must be positive definite;
sampling from singular normal variance mixtures can be achieved by providing
<code>factor</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_factor">factor</code></td>
<td>

<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_skip">skip</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="rgnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to
the underlying mixing distribution when <code>qmix</code>
is a <code><a href="base.html#topic+character">character</a></code> string or an element of <code>qmix</code> is
a <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally used is <code>factor</code>, so <code>scale</code> is not required
to be provided if <code>factor</code> is given.
</p>
<p>The default factorization used to obtain <code>factor</code> is the Cholesky
decomposition via <code><a href="base.html#topic+chol">chol</a>()</code>. To this end, <code>scale</code>
needs to have full rank.
</p>
<p><code>rgStudent()</code> is a wrapper of
<code>rgnvmix(, qmix = "inverse.gamma", df = df)</code>.
</p>


<h3>Value</h3>

<p><code>rgnvmix()</code> returns an <code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code>
containing <code class="reqn">n</code> samples of the specified (via <code>qmix</code>)
<code class="reqn">d</code>-dimensional grouped normal variance mixture with
location vector <code>loc</code> and scale matrix <code>scale</code>
(a covariance matrix).
</p>
<p><code>rgStudent()</code> returns samples from the <code class="reqn">d</code>-dimensional
multivariate <em>t</em> distribution with multiple degrees-of-freedom
specified by <code>df</code>, location vector
<code>loc</code> and scale matrix <code>scale</code>.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+pgnvmix">pgnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000 # sample size

## Generate a random correlation matrix in d dimensions
d &lt;- 2
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
scale &lt;- cov2cor(A %*% t(A))

## Example 1: Exponential mixture
## Let W_1 ~ Exp(1), W_2 ~ Exp(10)
rates &lt;- c(1, 10)
#qmix &lt;- list(list("exp", rate = rates[1]), list("exp", rate = rates[2]))
qmix &lt;- lapply(1:2, function(i) list("exp", rate = rates[i]))
set.seed(1)
X.exp1 &lt;- rgnvmix(n, qmix = qmix, scale = scale)
## For comparison, consider NVM distribution with W ~ Exp(1)
set.seed(1)
X.exp2 &lt;- rnvmix(n, qmix = list("exp", rate = rates[1]), scale = scale)
## Plot both samples with the same axes
opar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2))
plot(X.exp1, xlim = range(X.exp1, X.exp2), ylim = range(X.exp1, X.exp2),
     xlab = expression(X[1]), ylab = expression(X[2]))
mtext("Two groups with rates 1 and 10")
plot(X.exp2, xlim = range(X.exp1, X.exp2), ylim = range(X.exp1, X.exp2),
     xlab = expression(X[1]), ylab = expression(X[2]))
mtext("One group with rate 1")
par(opar)

## Example 2: Exponential + Inverse-gamma mixture
## Let W_1 ~ Exp(1), W_2 ~ IG(1.5, 1.5) (=&gt; X_2 ~ t_3 marginally)
df &lt;- 3
qmix &lt;- list(list("exp", rate = rates[1]),
             function(u, df) 1/qgamma(1-u, shape = df/2, rate = df/2))
set.seed(1)
X.mix1 &lt;- rgnvmix(n, qmix = qmix, scale = scale, df = df)
plot(X.mix1, xlab = expression(X[1]), ylab = expression(X[2]))

## Example 3: Mixtures in d &gt; 2
d &lt;- 5
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
scale &lt;- cov2cor(A %*% t(A))

## Example 3.1: W_i ~ Exp(i), i = 1,...,d
qmix &lt;- lapply(1:d, function(i) list("exp", rate = i))
set.seed(1)
X.mix2 &lt;- rgnvmix(n, qmix = qmix, scale = scale)

## Example 3.2: W_1, W_2 ~ Exp(1), W_3, W_4, W_5 ~ Exp(2)
## =&gt; 2 groups, so we need two elements in 'qmix'
qmix &lt;- lapply(1:2, function(i) list("exp", rate = i))
groupings &lt;- c(1, 1, 2, 2, 2)
set.seed(1)
X.mix3 &lt;- rgnvmix(n, qmix = qmix, groupings = groupings, scale = scale)

## Example 3.3: W_1, W_3 ~ IG(1, 1), W_2, W_4 ~ IG(2, 2), W_5 = 1
## =&gt; X_1, X_3 ~ t_2; X_2, X_4 ~ t_4, X_5 ~ N(0, 1)
qmix &lt;- list(function(u, df1) 1/qgamma(1-u, shape = df1/2, rate = df1/2),
             function(u, df2) 1/qgamma(1-u, shape = df2/2, rate = df2/2),
             function(u) rep(1, length(u)))
groupings = c(1, 2, 1, 2, 3)
df = c(2, 4, Inf)
set.seed(1)
X.t1 &lt;- rgnvmix(n, qmix = qmix, groupings = groupings, scale = scale,
                df1 = df[1], df2 = df[2])

## This is equivalent to calling 'rgnmvix' with 'qmix = "inverse.gamma"'
set.seed(1)
X.t2 &lt;- rgnvmix(n, qmix = "inverse.gamma", groupings = groupings, scale = scale,
                df = df)

## Alternatively, one can use the user friendly wrapper 'rgStudent()'
set.seed(1)
X.t3 &lt;- rgStudent(n, df = df, groupings = groupings, scale = scale)

stopifnot(all.equal(X.t1, X.t2), all.equal(X.t1, X.t3))
</code></pre>

<hr>
<h2 id='riskmeasures'>Risk measures for normal variance mixtures</h2><span id='topic+VaR_nvmix'></span><span id='topic+ES_nvmix'></span>

<h3>Description</h3>

<p>Estimation of value-at-risk and expected shortfall for univariate
normal variance mixtures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaR_nvmix(level, qmix, loc = 0, scale = 1, control = list(), verbose = TRUE, ...)
ES_nvmix(level, qmix, loc = 0, scale = 1, control = list(), verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riskmeasures_+3A_level">level</code></td>
<td>
<p><code class="reqn">n</code>-<code><a href="base.html#topic+vector">vector</a></code> of confidence levels.</p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_qmix">qmix</code></td>
<td>
<p>see <code><a href="#topic+pnvmix">pnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_loc">loc</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> location, see also <code><a href="#topic+pnvmix">pnvmix</a>()</code></p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_scale">scale</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> scale, see also <code><a href="#topic+pnvmix">pnvmix</a>()</code></p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> specifying algorithm specific
parameters; see <code><a href="#topic+get_set_param">get_set_param</a>()</code>.</p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_verbose">verbose</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>
indicating whether a warning is given if the required precision
has not been reached.</p>
</td></tr>
<tr><td><code id="riskmeasures_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to
the underlying mixing distribution when <code>qmix</code> is a
<code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>, see also
<code><a href="#topic+pnvmix">pnvmix</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>VaR_nvmix</code> calls <code><a href="#topic+qnvmix">qnvmix</a>()</code>.
</p>
<p>The function <code>ES_nvmix()</code> estimates the expected shortfall using a
randomized quasi Monte Carlo procedure by sampling from the mixing variable
specified via <code>qmix</code> and and using the identity
<code class="reqn">\int_k^{\infty} x\phi(x)dx=\phi(k)</code> where <code class="reqn">\phi(x)</code> denotes the
density of a standard normal distribution.
Algorithm specific paramaters (such as tolerances) can be conveniently passed
via the <code>control</code> argument, see <code><a href="#topic+get_set_param">get_set_param</a>()</code> for more
details.
</p>


<h3>Value</h3>

<p><code>VaR_nvmix()</code> and <code>ES_nvmix()</code> return
a <code><a href="base.html#topic+numeric">numeric</a></code> <code class="reqn">n</code>-vector with the computed
risk measures and in case of <code>ES_nvmix()</code> corresponding attributes
<code>"abs. error"</code> and <code>"rel. error"</code>(error estimates of the RQMC estimator)
and <code>"numiter"</code> (number of iterations).
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>, <code><a href="#topic+qnvmix">qnvmix</a>()</code>,
<code><a href="#topic+rnvmix">rnvmix</a>()</code>, <code><a href="#topic+get_set_param">get_set_param</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for inverse-gamma mixture (resulting in a t distribution) for
## which the expected shortfall admits a closed formula
set.seed(42) # reproducibility
level &lt;- seq(from = 0.9, to = 0.95, by = 0.01)
df &lt;- 4
## If 'qmix' is provided as string, ES_nvmix() uses the closed formula
ES1 &lt;- ES_nvmix(level, qmix = "inverse.gamma", df = df)
## If 'qmix' is provided as function, the expected shortfall is estimated
ES2 &lt;- ES_nvmix(level, qmix = function(u, df) 1/qgamma(1-u, shape = df/2, rate = df/2),
       df = df)
stopifnot(all.equal(ES1, ES2, tol = 1e-2, check.attributes = FALSE))
</code></pre>

<hr>
<h2 id='rnvmix'>(Quasi-)Random Number Generation for Multivariate Normal Variance Mixtures</h2><span id='topic+rnvmix'></span><span id='topic+rStudent'></span><span id='topic+rNorm'></span><span id='topic+rNorm_sumconstr'></span>

<h3>Description</h3>

<p>Generate vectors of random variates from multivariate normal variance
mixtures (including Student <em>t</em> and normal distributions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnvmix(n, rmix, qmix, loc = rep(0, d), scale = diag(2),
       factor = NULL, method = c("PRNG", "sobol", "ghalton"),
       skip = 0, ...)

rStudent(n, df, loc = rep(0, d), scale = diag(2), factor = NULL,
         method = c("PRNG", "sobol", "ghalton"), skip = 0)
rNorm(n, loc = rep(0, d), scale = diag(2), factor = NULL,
      method = c("PRNG", "sobol", "ghalton"), skip = 0)
rNorm_sumconstr(n, weights, s, method = c("PRNG", "sobol", "ghalton"), skip = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnvmix_+3A_n">n</code></td>
<td>
<p>sample size <code class="reqn">n</code> (positive integer).</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_rmix">rmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code>, see McNeil
et al. (2015, Chapter 6) and Hintz et al. (2020),
via a random number generator.
This argument is ignored for <code>method = "sobol"</code> and
<code>method = "ghalton"</code>. Supported are the
following types of specification (see also the examples below):
</p>

<dl>
<dt><code><a href="base.html#topic+character">character</a></code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string
specifying a supported distribution; currently available are
<code>"constant"</code> (in which case <code class="reqn">W = 1</code> and thus a sample
from the multivariate normal distribution with mean vector
<code>loc</code> and covariance matrix <code>scale</code> results) and
<code>"inverse.gamma"</code> (in which case <code class="reqn">W</code> is
inverse gamma distributed with shape and rate parameters
<code>df</code>/2 and thus the multivariate
Student <em>t</em> distribution with <code>df</code> degrees of freedom
(required to be provided via the ellipsis argument) results).</p>
</dd>
<dt><code><a href="base.html#topic+list">list</a></code>:</dt><dd><p><code><a href="base.html#topic+list">list</a></code> of length at least
one, where the first component is a <code><a href="base.html#topic+character">character</a></code>
string specifying the base name of a distribution which can be
sampled via prefix <code>"r"</code>; an example is <code>"exp"</code>
for which <code>"rexp"</code> exists for sampling. If the list is
of length larger than one, the remaining elements contain
additional parameters of the distribution; for <code>"exp"</code>,
for example, this can be the parameter <code>rate</code>.</p>
</dd>
<dt><code><a href="base.html#topic+function">function</a></code>:</dt><dd><p><code><a href="base.html#topic+function">function</a></code>
interpreted as a random number generator of the mixing
variable <code class="reqn">W</code>; additional arguments (such as parameters)
can be passed via the ellipsis argument.</p>
</dd>
<dt><code><a href="base.html#topic+numeric">numeric</a></code>:</dt><dd><p><code><a href="base.html#topic+numeric">numeric</a></code> vector
of length <code>n</code> providing a random sample of the mixing
variable <code class="reqn">W</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="rnvmix_+3A_qmix">qmix</code></td>
<td>
<p>specification of the mixing variable <code class="reqn">W</code> via a quantile
function. This argument is required
for <code>method = "sobol"</code> and <code>method = "ghalton"</code>. Supported are
the following types of specification (see also the examples below):
</p>

<dl>
<dt><code><a href="base.html#topic+character">character</a></code>:</dt><dd><p><code><a href="base.html#topic+character">character</a></code> string
specifying a supported distribution; currently available are
<code>"constant"</code> (in which case <code class="reqn">W = 1</code> and thus a sample
from the multivariate normal distribution with mean vector
<code>loc</code> and covariance matrix <code>scale</code> results) and
<code>"inverse.gamma"</code> (in which case <code class="reqn">W</code> is
inverse gamma distributed with shape and rate parameters
<code>df</code>/2 and thus the multivariate
Student <em>t</em> distribution with <code>df</code> degrees of freedom
(required to be provided via the ellipsis argument) results).</p>
</dd>
<dt><code><a href="base.html#topic+list">list</a></code>:</dt><dd><p><code><a href="base.html#topic+list">list</a></code> of length at least
one, where the first component is a <code><a href="base.html#topic+character">character</a></code>
string specifying the base name of a distribution which can be
sampled via prefix <code>"q"</code>; an example is <code>"exp"</code>
for which <code>"qexp"</code> exists for sampling. If the list is
of length larger than one, the remaining elements contain
additional parameters of the distribution; for <code>"exp"</code>,
for example, this can be the parameter <code>rate</code>.</p>
</dd>
<dt><code><a href="base.html#topic+function">function</a></code>:</dt><dd><p><code><a href="base.html#topic+function">function</a></code>
interpreted as the quantile function of the mixing
variable <code class="reqn">W</code>; internally, sampling is then done with the
inversion method by applying the provided function to U(0,1)
random variates.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="rnvmix_+3A_df">df</code></td>
<td>
<p>positive degress of freedom; can also be <code>Inf</code> in which
case the distribution is interpreted as the multivariate normal
distribution with mean vector <code>loc</code> and covariance matrix
<code>scale</code>).</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_loc">loc</code></td>
<td>
<p>location vector of dimension <code class="reqn">d</code>; this equals the mean
vector of a random vector following the specified normal variance
mixture distribution if and only if the latter exists.</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_scale">scale</code></td>
<td>
<p>scale matrix (a covariance matrix entering the
distribution as a parameter) of dimension <code class="reqn">(d, d)</code> (defaults to
<code class="reqn">d = 2</code>);
this equals the covariance matrix of a random vector following
the specified normal variance mixture distribution divided by
the expecation of the mixing variable <code class="reqn">W</code> if and only if the
former exists.
Note that <code>scale</code> must be positive definite; sampling from
singular normal variance mixtures can be achieved by providing
<code>factor</code>.</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_factor">factor</code></td>
<td>

<p><code class="reqn">(d, k)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> such that
<code>factor %*% t(factor)</code> equals <code>scale</code>; the non-square
case <code class="reqn">k \neq d</code> can be used to sample from singular
normal variance mixtures. Note that this notation coincides with
McNeil et al. (2015, Chapter 6). If not provided, <code>factor</code> is
internally determined via <code><a href="base.html#topic+chol">chol</a>()</code> (and multiplied
from the right to an <code class="reqn">(n, k)</code>-matrix of independent
standard normals to obtain a sample from a multivariate normal
with zero mean vector and covariance matrix <code>scale</code>).</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string indicating the method
to be used to obtain the sample. Available are:
</p>

<dl>
<dt><code>"PRNG"</code>:</dt><dd><p>pseudo-random numbers,</p>
</dd>
<dt><code>"sobol"</code>:</dt><dd><p>Sobol' sequence,</p>
</dd>
<dt><code>"ghalton"</code>:</dt><dd><p>generalized Halton sequence.</p>
</dd>
</dl>

<p>If <code>method = "PRNG"</code>, either <code>qmix</code> or <code>rmix</code> can be
provided. If both are provided, <code>rmix</code> is used and <code>qmix</code>
ignored. For the other two methods, sampling is done via inversion,
hence <code>qmix</code> has to be provided and <code>rmix</code> is ignored.
</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_skip">skip</code></td>
<td>
<p><code><a href="base.html#topic+integer">integer</a></code> specifying the number of points
to be skipped when <code>method = "sobol"</code>, see also example below.
</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_weights">weights</code></td>
<td>
<p><code class="reqn">d</code>-<code><a href="base.html#topic+numeric">numeric</a></code> vector of weights.</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_s">s</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> vector of length 1 or <code>n</code> giving the
value of the constrained sum; see below under details.</p>
</td></tr>
<tr><td><code id="rnvmix_+3A_...">...</code></td>
<td>
<p>additional arguments (for example, parameters) passed to
the underlying mixing distribution when <code>rmix</code> or <code>qmix</code>
is a <code><a href="base.html#topic+character">character</a></code> string or <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally used is <code>factor</code>, so <code>scale</code> is not required
to be provided if <code>factor</code> is given.
</p>
<p>The default factorization used to obtain <code>factor</code> is the Cholesky
decomposition via <code><a href="base.html#topic+chol">chol</a>()</code>. To this end, <code>scale</code>
needs to have full rank.
</p>
<p>Sampling from a singular normal variance mixture distribution can be
achieved by providing <code>factor</code>.
</p>
<p>The number of rows of <code>factor</code> equals the dimension <code class="reqn">d</code> of
the sample. Typically (but not necessarily), <code>factor</code> is square.
</p>
<p><code>rStudent()</code> and <code>rNorm()</code> are wrappers of
<code>rnvmix(, qmix = "inverse.gamma", df = df)</code> and
<code>rnvmix(, qmix = "constant", df = df)</code>, respectively.
</p>
<p>The function <code>rNorm_sumconstr()</code> can be used to sample from the
multivariate standard normal distribution under a weighted sum constraint;
the implementation is based on Algorithm 1 in Vrins (2018). Let
<code class="reqn">Z = (Z_1,\dots,Z_d)~N_d(0, I_d)</code>. The function <code>rNorm_sumconstr()</code>
then samples from <code class="reqn">Z | w^T Z = s</code> where <code class="reqn">w</code> and <code class="reqn">s</code> correspond
to the arguments <code>weights</code> and <code>s</code>. If supplied <code>s</code> is a vector
of length <code>n</code>, the i'th row of the returned matrix uses the constraint
<code class="reqn">w^T Z = s_i</code> where <code class="reqn">s_i</code> is the i'th element in <code>s</code>.
</p>


<h3>Value</h3>

<p><code>rnvmix()</code> returns an <code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code>
containing <code class="reqn">n</code> samples of the specified (via <code>mix</code>)
<code class="reqn">d</code>-dimensional multivariate normal variance mixture with
location vector <code>loc</code> and scale matrix <code>scale</code>
(a covariance matrix).
</p>
<p><code>rStudent()</code> returns samples from the <code class="reqn">d</code>-dimensional
multivariate Student <em>t</em> distribution with location vector
<code>loc</code> and scale matrix <code>scale</code>.
</p>
<p><code>rNorm()</code> returns samples from the <code class="reqn">d</code>-dimensional
multivariate normal distribution with mean vector
<code>loc</code> and covariance matrix <code>scale</code>.
</p>
<p><code>rNorm_sumconstr()</code> returns samples from the <code class="reqn">d</code>-dimensional
multivariate normal distribution conditional on the weighted sum being
constrained to <code>s</code>.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Vrins, E. (2018)
Sampling the Multivariate Standard Normal Distribution under a Weighted
Sum Constraint.
<em>Risks</em> 6(3), 64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dnvmix">dnvmix</a>()</code>, <code><a href="#topic+pnvmix">pnvmix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples for rnvmix() ######################################################

## Generate a random correlation matrix in d dimensions
d &lt;- 3
set.seed(157)
A &lt;- matrix(runif(d * d), ncol = d)
P &lt;- cov2cor(A %*% t(A))

## Draw random variates and compare
df &lt;- 3.5
n &lt;- 1000
set.seed(271)
X  &lt;- rnvmix(n, rmix = "inverse.gamma", df = df, scale = P) # with scale
set.seed(271)
X. &lt;- rnvmix(n, rmix = "inverse.gamma", df = df, factor = t(chol(P))) # with factor
stopifnot(all.equal(X, X.))

## Checking df = Inf
set.seed(271)
X &lt;- rnvmix(n, rmix = "constant", scale = P) # normal
set.seed(271)
X. &lt;- rnvmix(n, rmix = "inverse.gamma", scale = P, df = Inf) # t_infinity
stopifnot(all.equal(X, X.))

## Univariate case (dimension = number of rows of 'factor' = 1 here)
set.seed(271)
X.1d  &lt;- rnvmix(n, rmix = "inverse.gamma", df = df, factor = 1/2)
set.seed(271)
X.1d. &lt;- rnvmix(n, rmix = "inverse.gamma", df = df, factor = 1)/2 # manual scaling
stopifnot(all.equal(X.1d, X.1d.))

## Checking different ways of providing 'mix'
## 1) By providing a character string (and corresponding ellipsis arguments)
set.seed(271)
X.mix1 &lt;- rnvmix(n, rmix = "inverse.gamma", df = df, scale = P)
## 2) By providing a list; the first element has to be an existing distribution
##    with random number generator available with prefix "r"
rinverse.gamma &lt;- function(n, df) 1 / rgamma(n, shape = df/2, rate = df/2)
set.seed(271)
X.mix2 &lt;- rnvmix(n, rmix = list("inverse.gamma", df = df), scale = P)
## 3) The same without extra arguments (need the extra list() here to
##    distinguish from Case 1))
rinverseGamma &lt;- function(n) 1 / rgamma(n, shape = df/2, rate = df/2)
set.seed(271)
X.mix3 &lt;- rnvmix(n, rmix = list("inverseGamma"), scale = P)
## 4) By providing a quantile function
##    Note: P(1/Y &lt;= x) = P(Y &gt;= 1/x) = 1-F_Y(1/x) = y &lt;=&gt; x = 1/F_Y^-(1-y)
set.seed(271)
X.mix4 &lt;- rnvmix(n, qmix = function(p) 1/qgamma(1-p, shape = df/2, rate = df/2),
                 scale = P)
## 5) By providing random variates
set.seed(271) # if seed is set here, results are comparable to the above methods
W &lt;- rinverse.gamma(n, df = df)
X.mix5 &lt;- rnvmix(n, rmix = W, scale = P)
## Compare (note that X.mix4 is not 'all equal' with X.mix1 or the other samples)
## since rgamma() != qgamma(runif()) (or qgamma(1-runif()))
stopifnot(all.equal(X.mix2, X.mix1),
          all.equal(X.mix3, X.mix1),
          all.equal(X.mix5, X.mix1))

## For a singular normal variance mixture:
## Need to provide 'factor'
A &lt;- matrix( c(1, 0, 0, 1, 0, 1), ncol = 2, byrow = TRUE)
stopifnot(all.equal(dim(rnvmix(n, rmix = "constant", factor = A)),    c(n, 3)))
stopifnot(all.equal(dim(rnvmix(n, rmix = "constant", factor = t(A))), c(n, 2)))

## Using 'skip'. Need to reset the seed everytime to get the same shifts in "sobol".
## Note that when using method = "sobol", we have to provide 'qmix' instead of 'rmix'.
set.seed(271)
X.skip0 &lt;- rnvmix(n, qmix = "inverse.gamma", df = df, scale = P, method = "sobol")
set.seed(271)
X.skip1 &lt;- rnvmix(n, qmix = "inverse.gamma", df = df, scale = P, method = "sobol",
                  skip = n)
set.seed(271)
X.wo.skip &lt;- rnvmix(2*n, qmix = "inverse.gamma", df = df, scale = P, method = "sobol")
X.skip &lt;- rbind(X.skip0, X.skip1)
stopifnot(all.equal(X.wo.skip, X.skip))


### Examples for rStudent() and rNorm() ########################################

## Draw N(0, P) random variates by providing scale or factor and compare
n &lt;- 1000
set.seed(271)
X.n  &lt;- rNorm(n, scale = P) # providing scale
set.seed(271)
X.n. &lt;- rNorm(n, factor = t(chol(P))) # providing the factor
stopifnot(all.equal(X.n, X.n.))

## Univariate case (dimension = number of rows of 'factor' = 1 here)
set.seed(271)
X.n.1d  &lt;- rNorm(n, factor = 1/2)
set.seed(271)
X.n.1d. &lt;- rNorm(n, factor = 1)/2 # manual scaling
stopifnot(all.equal(X.n.1d, X.n.1d.))

## Draw t_3.5 random variates by providing scale or factor and compare
df &lt;- 3.5
n &lt;- 1000
set.seed(271)
X.t  &lt;- rStudent(n, df = df, scale = P) # providing scale
set.seed(271)
X.t. &lt;- rStudent(n, df = df, factor = t(chol(P))) # providing the factor
stopifnot(all.equal(X.t, X.t.))

## Univariate case (dimension = number of rows of 'factor' = 1 here)
set.seed(271)
X.t.1d  &lt;- rStudent(n, df = df, factor = 1/2)
set.seed(271)
X.t.1d. &lt;- rStudent(n, df = df, factor = 1)/2 # manual scaling
stopifnot(all.equal(X.t.1d, X.t.1d.))

## Check df = Inf
set.seed(271)
X.t &lt;- rStudent(n, df = Inf, scale = P)
set.seed(271)
X.n &lt;- rNorm(n, scale = P)
stopifnot(all.equal(X.t, X.n))

### Examples for rNorm_sumconstr() #############################################
set.seed(271)
weights &lt;- c(1, 1)
Z.constr &lt;- rNorm_sumconstr(n, weights = c(1, 1), s = 2)
stopifnot(all(rowSums(Z.constr ) == 2))
plot(Z.constr , xlab = expression(Z[1]), ylab = expression(Z[2]))
</code></pre>

<hr>
<h2 id='skewstudent'>Functionalities for the skew-t distribution and copula</h2><span id='topic+rskewt'></span><span id='topic+dskewt'></span><span id='topic+rskewtcopula'></span><span id='topic+dskewtcopula'></span>

<h3>Description</h3>

<p>Sampling and density evaluation for the multivariate skew-t distribution and copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rskewt(n, loc = rep(0, d), scale = diag(2), factor = NULL, gamma = rep(0, d),
       df = Inf, method = c("PRNG", "sobol", "ghalton"), skip = 0)
dskewt(x, loc = rep(0, d), scale = diag(2), gamma = rep(0, d), df,
       log = FALSE, scale.inv, ldet)

rskewtcopula(n, scale = diag(2), factor = NULL, gamma = rep(0, d), df = Inf,
             pseudo = TRUE, method = c("PRNG", "sobol", "ghalton"), skip = 0)
dskewtcopula(u, scale = diag(2), gamma = rep(0, d), df, log = FALSE,
             scale.inv, ldet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewstudent_+3A_u">u</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of evaluation points or data;
Have to be in <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_x">x</code></td>
<td>
<p><code class="reqn">(n, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> of evaluation points or data</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_n">n</code></td>
<td>
<p>sample size <code class="reqn">n</code> (positive integer).</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_df">df</code></td>
<td>
<p>positive degress of freedom; can also be <code>Inf</code> in which
case the copula is interpreted as the Gaussian copula.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_loc">loc</code></td>
<td>
<p>location of length <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_gamma">gamma</code></td>
<td>
<p>Skewness-vector of dimension <code class="reqn">d</code>; if <code>all(gamma == 0)</code>,
the classical t distribution or copula results.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_scale">scale</code></td>
<td>
<p>scale matrix (a covariance matrix entering the
distribution as a parameter) of dimension <code class="reqn">(d, d)</code> (defaults to
<code class="reqn">d = 2</code>). Note that <code>scale</code> must be positive definite,</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_factor">factor</code></td>
<td>

<p><code class="reqn">(d, d)</code>-<code><a href="base.html#topic+matrix">matrix</a></code> such that
<code>factor %*% t(factor)</code> equals <code>scale</code>.
If not provided, <code>factor</code> is internally determined via <code><a href="base.html#topic+chol">chol</a>()</code></p>
</td></tr>
<tr><td><code id="skewstudent_+3A_scale.inv">scale.inv</code></td>
<td>
<p>inverse of <code>scale</code>; if not provided, computed via
<code>pd.solve(scale)</code>.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_ldet">ldet</code></td>
<td>
<p><code>log(det(scale))</code>; if not provided, computed via <code>pd.solve(scale)</code>.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_log">log</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the logarithmic
density is to be computed.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_pseudo">pseudo</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>; if <code>TRUE</code>, copula samples are computed
via <code>pobs()</code> from a multivariate skew-t sample. If <code>FALSE</code>, the univariate skew t distribution functions are internally approximated via
<code>integrate()</code>; see details below.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
<tr><td><code id="skewstudent_+3A_skip">skip</code></td>
<td>
<p>see <code><a href="#topic+rnvmix">rnvmix</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functionalities for sampling from the multivariate skew-<em>t</em> distribution
and copula; the former has stochastic representation <code class="reqn">\mu + W\gamma + \sqrt{W}AZ</code>
where <code class="reqn">AA^T=scale</code>, <code class="reqn">W</code> follows an inverse-gamma distrubution with
parameters <code>df/2</code> and is independent of the <code class="reqn">d</code>-dimensional vector <code class="reqn">Z</code>
following a standard multivariate normal distribution. When <code class="reqn">gamma</code> is the
null-vector, the distribution becomes the multivariate <code class="reqn">t</code> distribution.
</p>
<p>A major computational challenge when working with the skew <em>t</em> copula is
the lack of an available distribution and quantile function of the univariate
skew <em>t</em> distribution. These are required in <code>rskewtcopula(, pobs = FALSE)</code>
and in <code>dskewtcopula()</code>. The unviarate skew <em>t</em> distribution and
quantile functions are currently implemented as described Yoshiba, T. (2018).
</p>
<p>The functions described here are currently being further developed to improve
stability, accuracy and speed, so that arguments may change in subsequent
versions of <code>nvmix</code>.
</p>


<h3>Value</h3>

<p><code class="reqn">n</code>-vector of (log-)density values and <code class="reqn">(n, d)</code>-matrix of samples, respectively.
</p>


<h3>Author(s)</h3>

<p>Erik Hintz, Marius Hofert and Christiane Lemieux</p>


<h3>References</h3>

<p>Hintz, E., Hofert, M. and Lemieux, C. (2020),
Grouped Normal Variance Mixtures.
<em>Risks</em> 8(4), 103.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2021),
Normal variance mixtures: Distribution, density and parameter estimation.
<em>Computational Statistics and Data Analysis</em> 157C, 107175.
</p>
<p>Hintz, E., Hofert, M. and Lemieux, C. (2022),
Multivariate Normal Variance Mixtures in <span class="rlang"><b>R</b></span>: The <span class="rlang"><b>R</b></span> Package nvmix.
<em>Journal of Statistical Software</em>, <a href="https://doi.org/10.18637/jss.v102.i02">doi:10.18637/jss.v102.i02</a>.
</p>
<p>McNeil, A. J., Frey, R. and Embrechts, P. (2015).
<em>Quantitative Risk Management: Concepts, Techniques, Tools</em>.
Princeton University Press.
</p>
<p>Yoshiba, T. (2018).
Maximum Likelihood Estimation of Skew-<em>t</em> Copulas with Its Applications to Stock
Returns.
<em>Journal of Statistical Computation and Simulation</em> 88 (13): 24892506.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rStudent">rStudent</a>()</code>, <code><a href="#topic+dStudent">dStudent</a>()</code>, <code><a href="#topic+rStudentcopula">rStudentcopula</a>()</code>, <code><a href="#topic+dStudentcopula">dStudentcopula</a>()</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sampling from the skew-t copula

n &lt;- 100 # sample size
d &lt;- 10 # dimension
rho &lt;- 0.5
scale &lt;- matrix(rho, ncol = d, nrow = d)
diag(scale) &lt;- 1 # scale
gamma &lt;- rep(1, d) # skewness
df &lt;- 7 # degrees-of-freedom parameter
set.seed(1) # same random numbers for both runs
system.time(samplecop_pobs &lt;- rskewtcopula(n, scale = scale, gamma = gamma,
                                           df = df, pseudo = TRUE))
set.seed(1)
system.time(samplecop_pskewt &lt;- rskewtcopula(n, scale = scale, gamma = gamma,
                                             df = df, pseudo = FALSE))
## Plot first two coordinates
layout(rbind(1:2))
plot(samplecop_pobs, xlab = expression(U[1]), ylab = expression(U[2]))
mtext("pobs = TRUE")
plot(samplecop_pskewt, xlab = expression(U[1]), ylab = expression(U[2]))
mtext("pobs = FALSE")
layout(1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
