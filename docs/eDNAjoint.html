<!DOCTYPE html><html lang="en"><head><title>Help for package eDNAjoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eDNAjoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eDNAjoint-package'><p>The 'eDNAjoint' package.</p></a></li>
<li><a href='#detection_calculate'><p>Calculate the survey effort necessary to detect species presence, given the</p>
species expected catch rate.</a></li>
<li><a href='#detection_plot'><p>Plot the survey effort necessary to detect species presence, given the</p>
species expected catch rate.</a></li>
<li><a href='#goby_data'><p>goby_data</p></a></li>
<li><a href='#green_crab_data'><p>green_crab_data</p></a></li>
<li><a href='#joint_model'><p>Specify and fit joint model using count data from traditional surveys and</p>
eDNA PCR data</a></li>
<li><a href='#joint_select'><p>Perform model selection using leave one out cross validation of model objects</p></a></li>
<li><a href='#joint_summarize'><p>Summarize posterior distributions of model parameters.</p></a></li>
<li><a href='#mu_critical'><p>Calculate mu_critical</p></a></li>
<li><a href='#traditional_model'><p>Specify and fit model using count data from traditional, non eDNA surveys</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Joint Modeling of Traditional and Environmental DNA Survey Data
in a Bayesian Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abigail G. Keller &lt;agkeller@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Models integrate environmental DNA (eDNA) detection data and traditional survey data to jointly estimate species catch rate (see package vignette: <a href="https://ednajoint.netlify.app/">https://ednajoint.netlify.app/</a>). Models can be used with count data via traditional survey methods (i.e., trapping, electrofishing, visual) and replicated eDNA detection/nondetection data via polymerase chain reaction (i.e., PCR or qPCR) from multiple survey locations. Estimated parameters include probability of a false positive eDNA detection, a site-level covariates that scale the sensitivity of eDNA surveys relative to traditional surveys, and catchability coefficients for traditional gear types. Models are implemented with a Bayesian framework (Markov chain Monte Carlo) using the 'Stan' probabilistic programming language.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/eDNAjoint">https://github.com/ropensci/eDNAjoint</a>,
<a href="https://docs.ropensci.org/eDNAjoint/">https://docs.ropensci.org/eDNAjoint/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/eDNAjoint/issues">https://github.com/ropensci/eDNAjoint/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayestestR, dplyr, ggplot2, lifecycle, loo, methods, Rcpp (&ge;
0.12.0), RcppParallel (&ge; 5.0.1), rlist, rstan (&ge; 2.26.23),
rstantools (&ge; 2.3.1.1), tidyr, scales</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.23), StanHeaders (&ge;
2.26.22)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesplot, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 03:54:33 UTC; jovyan</td>
</tr>
<tr>
<td>Author:</td>
<td>Abigail G. Keller [aut, cre],
  Ryan P. Kelly [ctb],
  Chitra M. Saraswati [rev],
  Saras M. Windecker [rev]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='eDNAjoint-package'>The 'eDNAjoint' package.</h2><span id='topic+eDNAjoint-package'></span><span id='topic+eDNAjoint'></span>

<h3>Description</h3>

<p>Models integrate environmental DNA (eDNA) detection data and
traditional survey data to jointly estimate species catch rate (see package
vignette: <a href="https://ednajoint.netlify.app/">https://ednajoint.netlify.app/</a>). Models can be used with count
data via traditional survey methods (i.e., trapping, electrofishing,
visual) and replicated eDNA detection/nondetection data via polymerase
chain reaction (i.e., PCR or qPCR) from multiple survey locations.
Estimated parameters include probability of a false positive eDNA
detection, a site-level covariates that scale the sensitivity of eDNA
surveys relative to traditional surveys, and catchability coefficients for
traditional gear types. Models are implemented with a Bayesian framework
(Markov chain Monte Carlo) using the 'Stan' probabilistic programming
language.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Abigail G. Keller <a href="mailto:agkeller@berkeley.edu">agkeller@berkeley.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Ryan P. Kelly <a href="mailto:rpkelly@uw.edu">rpkelly@uw.edu</a> [contributor]
</p>
</li>
<li><p> Chitra M. Saraswati [reviewer]
</p>
</li>
<li><p> Saras M. Windecker [reviewer]
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (NA). RStan: the R interface to Stan.
https://mc-stan.org
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/eDNAjoint">https://github.com/ropensci/eDNAjoint</a>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/eDNAjoint/">https://docs.ropensci.org/eDNAjoint/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/eDNAjoint/issues">https://github.com/ropensci/eDNAjoint/issues</a>
</p>
</li></ul>


<hr>
<h2 id='detection_calculate'>Calculate the survey effort necessary to detect species presence, given the
species expected catch rate.</h2><span id='topic+detection_calculate'></span>

<h3>Description</h3>

<p>This function calculates the number of survey effort units to necessary
detect species presence using median estimated parameter values from
joint_model(). Detecting species presence is defined
as producing at least one true positive eDNA detection or catching at least
one individual. See more examples in the
<a href="https://ednajoint.netlify.app/">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detection_calculate(
  model_fit,
  mu,
  cov_val = NULL,
  probability = 0.9,
  pcr_n = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detection_calculate_+3A_model_fit">model_fit</code></td>
<td>
<p>An object of class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="detection_calculate_+3A_mu">mu</code></td>
<td>
<p>A numeric vector of species densities/capture rates. If multiple
traditional gear types are represented in the model, mu is the catch rate
of gear type 1.</p>
</td></tr>
<tr><td><code id="detection_calculate_+3A_cov_val">cov_val</code></td>
<td>
<p>A numeric vector indicating the values of site-level
covariates to use for prediction. Default is NULL.</p>
</td></tr>
<tr><td><code id="detection_calculate_+3A_probability">probability</code></td>
<td>
<p>A numeric value indicating the probability of detecting
presence. The default is 0.9.</p>
</td></tr>
<tr><td><code id="detection_calculate_+3A_pcr_n">pcr_n</code></td>
<td>
<p>An integer indicating the number of PCR replicates per eDNA
sample. The default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary table of survey efforts necessary to detect species
presence, given mu, for each survey type.
</p>


<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
function is possible given the inputs. These checks include:
</p>

<ul>
<li><p>  Input model fit is an object of class 'stanfit'.
</p>
</li>
<li><p>  Input mu is a numeric vector.
</p>
</li>
<li><p>  Input probability is a univariate numeric value.
</p>
</li>
<li><p>  If model fit contains alpha, cov_val must be provided.
</p>
</li>
<li><p>  Input cov_val is numeric.
</p>
</li>
<li><p>  Input cov_val is the same length as the number of estimated
covariates.
</p>
</li>
<li><p>  Input model fit has converged (i.e. no divergent transitions after
warm-up).
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Ex. 1: Calculating necessary effort for detection with site-level
# covariates

# Load data
data(goby_data)

# Fit a model including 'Filter_time' and 'Salinity' site-level covariates
fit_cov &lt;- joint_model(data = goby_data, cov = c('Filter_time','Salinity'),
                       family = "poisson", p10_priors = c(1,20), q = FALSE,
                       multicore = FALSE)

# Calculate at the mean covariate values
# (covariates are standardized, so mean = 0)
detection_calculate(fit_cov$model, mu = seq(from = 0.1, to = 1, by = 0.1),
                    cov_val = c(0,0), pcr_n = 3)

# Calculate mu_critical at salinity 0.5 z-scores greater than the mean
detection_calculate(fit_cov$model, mu = seq(from = 0.1, to = 1, by = 0.1),
                    cov_val = c(0,0.5), pcr_n = 3)

# Ex. 2: Calculating necessary effort for detection with multiple traditional
# gear types

# Load data
data(green_crab_data)

# Fit a model with no site-level covariates
fit_q &lt;- joint_model(data = green_crab_data, cov = NULL, family = "negbin",
                     p10_priors = c(1,20), q = TRUE, multicore = FALSE)

# Calculate
detection_calculate(fit_q$model, mu = seq(from = 0.1, to = 1, by = 0.1),
                    cov_val = NULL, pcr_n = 3)

# Change probability of detecting presence to 0.95
detection_calculate(fit_q$model, mu = 0.1, cov_val = NULL,
                    probability = 0.95, pcr_n = 3)


</code></pre>

<hr>
<h2 id='detection_plot'>Plot the survey effort necessary to detect species presence, given the
species expected catch rate.</h2><span id='topic+detection_plot'></span>

<h3>Description</h3>

<p>This function plots the number of survey effort units to necessary detect
species presence, calculated using median estimated parameter values from
joint_model(). Detecting species presence is defined as producing
at least one true positive eDNA detection or catching at least one
individual. See more examples in the
<a href="https://ednajoint.netlify.app/">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detection_plot(
  model_fit,
  mu_min,
  mu_max,
  cov_val = NULL,
  probability = 0.9,
  pcr_n = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detection_plot_+3A_model_fit">model_fit</code></td>
<td>
<p>An object of class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="detection_plot_+3A_mu_min">mu_min</code></td>
<td>
<p>A value indicating the minimum expected species catch rate for
plotting. If multiple traditional gear types are represented in the model,
mu is the catch rate of gear type 1.</p>
</td></tr>
<tr><td><code id="detection_plot_+3A_mu_max">mu_max</code></td>
<td>
<p>A value indicating the maximum expected species catch rate for
plotting. If multiple traditional gear types are represented in the model,
mu is the catch rate of gear type 1.</p>
</td></tr>
<tr><td><code id="detection_plot_+3A_cov_val">cov_val</code></td>
<td>
<p>A numeric vector indicating the values of site-level
covariates to use for prediction. Default is NULL.</p>
</td></tr>
<tr><td><code id="detection_plot_+3A_probability">probability</code></td>
<td>
<p>A numeric value indicating the probability of detecting
presence. The default is 0.9.</p>
</td></tr>
<tr><td><code id="detection_plot_+3A_pcr_n">pcr_n</code></td>
<td>
<p>An integer indicating the number of PCR replicates per eDNA
sample. The default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying survey efforts necessary to detect species
presence, given mu, for each survey type.
</p>


<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
function is possible given the inputs. These checks include:
</p>

<ul>
<li><p>  Input model fit is an object of class 'stanfit'.
</p>
</li>
<li><p>  Input mu_min is a numeric value greater than 0.
</p>
</li>
<li><p>  Input mu_max is a numeric value.
</p>
</li>
<li><p>  If model fit contains alpha, cov_val must be provided.
</p>
</li>
<li><p>  Input cov_val is numeric.
</p>
</li>
<li><p>  Input cov_val is the same length as the number of estimated
covariates.
</p>
</li>
<li><p>  Input probability is a univariate numeric value.
</p>
</li>
<li><p>  Input model fit has converged (i.e. no divergent transitions after
warm-up).
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Ex. 1: Calculating necessary effort for detection with site-level
# covariates

# Load data
data(goby_data)

# Fit a model including 'Filter_time' and 'Salinity' site-level covariates
fit_cov &lt;- joint_model(data = goby_data, cov = c('Filter_time','Salinity'),
                       family = "poisson", p10_priors = c(1,20), q = FALSE,
                       multicore = FALSE)

# Plot at the mean covariate values (covariates are standardized, so mean=0)
detection_plot(fit_cov$model, mu_min = 0.1, mu_max = 1,
               cov_val = c(0,0), pcr_n = 3)

# Calculate mu_critical at salinity 0.5 z-scores greater than the mean
detection_plot(fit_cov$model, mu_min = 0.1, mu_max = 1, cov_val = c(0,0.5),
               pcr_n = 3)

# Ex. 2: Calculating necessary effort for detection with multiple
# traditional gear types

# Load data
data(green_crab_data)

# Fit a model with no site-level covariates
fit_q &lt;- joint_model(data = green_crab_data, cov = NULL, family = "negbin",
                     p10_priors = c(1,20), q = TRUE,
                     multicore = FALSE)

# Calculate
detection_plot(fit_q$model, mu_min = 0.1, mu_max = 1,
               cov_val = NULL, pcr_n = 3)

# Change probability of detecting presence to 0.95
detection_plot(fit_q$model, mu_min = 0.1, mu_max = 1, cov_val = NULL,
               probability = 0.95, pcr_n = 3)


</code></pre>

<hr>
<h2 id='goby_data'>goby_data</h2><span id='topic+goby_data'></span>

<h3>Description</h3>

<p>goby_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goby_data
</code></pre>


<h3>Format</h3>

<p>A list with four matrices representing eDNA sampling data (pcr_n
and pcr_k), seine sampling data (count), and site-level covariate data
(site_cov).
</p>

<dl>
<dt>pcr_n</dt><dd><p>Total number of eDNA qPCR replicates at each site (row) and
eDNA sample replicate (column). Data includes 39 total sites and a
maximum of 22 eDNA sample replicates. NA indicates that fewer eDNA
samples were collected than the maximum at a site.</p>
</dd>
<dt>pcr_k</dt><dd><p>Total number of positive eDNA qPCR detections at each site
(row) and eDNA sample replicate (column). Data includes 39 total sites
and a maximum of 22 eDNA sample replicates. NA indicates that fewer eDNA
samples were collected than the maximum at a site.</p>
</dd>
<dt>count</dt><dd><p>Count of goby individuals in seine samples at each site (row)
and seine sample replicate (column). Data includes 39 total sites and a
maximum of 22 seine replicates. NA indicates that fewer seine samples
were collected than the maximum at a site.</p>
</dd>
<dt>site_cov</dt><dd><p>Data representing site-level covariates at each site (row).
Data includes mean salinity at a site ('Salinity'), mean time to filter
eDNA samples ('Filter_time'), density of other fish species
('Other_fishes'), size of habitat ('Hab_size'), and presence of
vegetation ('Veg'). All non-integer covariate data is standardized.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://datadryad.org/dataset/doi:10.5061/dryad.6rs23">https://datadryad.org/dataset/doi:10.5061/dryad.6rs23</a>
</p>


<h3>References</h3>

<p>Schmelzle, M.C. and Kinziger, A.P. (2016). Using occupancy
modelling to compare environmental DNA to traditional field methods for
regional-scale monitoring of an endangered aquatic species. Molecular
Ecology Resources. 16(4): 895-908.
</p>

<hr>
<h2 id='green_crab_data'>green_crab_data</h2><span id='topic+green_crab_data'></span>

<h3>Description</h3>

<p>green_crab_data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>green_crab_data
</code></pre>


<h3>Format</h3>

<p>A list with four matrices representing eDNA sampling data (pcr_n and
pcr_k) and trap sampling data (count and count_type).
</p>

<dl>
<dt>pcr_n</dt><dd><p>Total number of eDNA qPCR replicates at each site (row) and
eDNA sample replicate (column). Data includes 20 total sites and 5 eDNA
sample replicates.</p>
</dd>
<dt>pcr_k</dt><dd><p>Total number of positive eDNA qPCR detections at each site
(row) and eDNA sample replicate (column). Data includes 20 total sites
and 5 eDNA sample replicates.</p>
</dd>
<dt>count</dt><dd><p>Count of green crab individuals in trap samples at each site
(row) and trap sample replicate (column). Data includes 20 total sites
and a maximum of 420 trap replicates. NA indicates that fewer trap
samples were collected than the maximum at a site.</p>
</dd>
<dt>count_type</dt><dd><p>Integer indicating the traditional gear type used at each
site (row) and trap sample replicate (column). '1' refers to Fukui traps,
and '2' refers to Minnow traps. Data includes 20 total sites and a
maximum of 420 trap replicates. NA indicates that fewer trap samples
were collected than the maximum at a site.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.6084/m9.figshare.15117102.v2">doi:10.6084/m9.figshare.15117102.v2</a>
</p>


<h3>References</h3>

<p>Keller, A.G., Grason, E.W., McDonald, P.S., Ramon-Laca, A.,
Kelly, R.P. (2022). Tracking an invasion front with environmental DNA.
Ecological Applications. 32(4): e2561. https://doi.org/10.1002/eap.2561
</p>

<hr>
<h2 id='joint_model'>Specify and fit joint model using count data from traditional surveys and
eDNA PCR data</h2><span id='topic+joint_model'></span>

<h3>Description</h3>

<p>This function implements a Bayesian model that integrates data from paired
eDNA and traditional surveys, as described in Keller et al. (2022)
&lt;doi.org/10.1002/eap.2561&gt;. The model estimates parameters including
the expected species catch rate and the probability of false positive eDNA
detection. This function allows for optional model variations, like inclusion
of site-level covariates that scale the sensitivity of eDNA sampling relative
to traditional sampling, as well as estimation of gear scaling coefficients
that scales the relative catchability of multiple traditional gear types.
Model is implemented using Bayesian inference using the <code>rstan</code> package,
which uses Hamiltonian Monte Carlo to simulate the posterior distributions.
See more examples in the
<a href="https://ednajoint.netlify.app/">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_model(
  data,
  cov = NULL,
  family = "poisson",
  p10_priors = c(1, 20),
  q = FALSE,
  phi_priors = NULL,
  multicore = FALSE,
  initial_values = NULL,
  n_chain = 4,
  n_warmup = 500,
  n_iter = 3000,
  thin = 1,
  adapt_delta = 0.9,
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_model_+3A_data">data</code></td>
<td>
<p>A list containing data necessary for model fitting. Valid tags
are <code>pcr_n</code>, <code>pcr_k</code>, <code>count</code>, <code>count_type</code>, and <code>site_cov</code>. <code>pcr_n</code> and
<code>pcr_k</code> are matrices or data frames with first dimension equal to the
number of sites (i) and second dimension equal to the maximum number of
eDNA samples at a given site (m). <code>pcr_n</code> contains the total number of
PCR replicates per site and eDNA sample, and <code>pcr_k</code> contains the total
number of positive PCR detections per site and eDNA sample. <code>count</code> is a
matrix or data frame of traditional survey count data, with first
dimension equal to the number of sites (i) and second dimension equal to
the maximum number of traditional survey replicates at a given site (j).
<code>count_type</code> is an optional matrix or data frame of integers indicating
gear type used in corresponding count data, with first dimension equal to
the number of sites (i) and second dimension equal to the maximum number
of traditional survey replicates at a given site. Values should be
integers beginning with 1 (referring to the first gear type) to n (last
gear type). <code>site_cov</code> is an optional matrix or data frame of site-level
covariate data, with first dimension equal to the number of sites (i).
<code>site_cov</code> should include informative column names. Empty cells should
be NA and will be removed during processing. Sites, i, should be consistent
in all PCR, count, and site covariate data.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_cov">cov</code></td>
<td>
<p>A character vector indicating the site-level covariates to include
in the model. Default value is NULL.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_family">family</code></td>
<td>
<p>The distribution class used to model traditional survey count
data. Options include poisson ('poisson'), negative binomial ('negbin'),
and gamma ('gamma'). Default value is 'poisson'.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_p10_priors">p10_priors</code></td>
<td>
<p>A numeric vector indicating beta distribution
hyperparameters (alpha, beta) used as the prior distribution for the eDNA
false positive probability (p10). Default vector is c(1,20).</p>
</td></tr>
<tr><td><code id="joint_model_+3A_q">q</code></td>
<td>
<p>A logical value indicating whether to estimate gear scaling
coefficients, q, for traditional survey gear types (TRUE) or to not
estimate gear scaling coefficients, q, for traditional survey gear types
(FALSE). Default value is FALSE.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_phi_priors">phi_priors</code></td>
<td>
<p>A numeric vector indicating gamma distribution
hyperparameters (shape, rate) used as the prior distribution for phi, the
overdispersion in the negative binomial distribution for traditional survey
gear data. Used when family = 'negbin.' If family = 'negbin', then
default vector is c(0.25,0.25), otherwise, default is NULL.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_multicore">multicore</code></td>
<td>
<p>A logical value indicating whether to parallelize chains
with multiple cores. Default is FALSE.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_initial_values">initial_values</code></td>
<td>
<p>A list of lists of initial values to use in MCMC. The
length should equal the number of MCMC chains. Initial values can be
provided for parameters: beta, p10 (log-scale), mu, q, alpha. If no
initial values are provided, default random values are drawn.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_n_chain">n_chain</code></td>
<td>
<p>Number of MCMC chains. Default value is 4.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_n_warmup">n_warmup</code></td>
<td>
<p>A positive integer specifying the number of warm-up MCMC
iterations. Default value is 500.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_n_iter">n_iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each
chain (including warmup). Default value is 3000.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples.
Default value is 1.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Numeric value between 0 and 1 indicating target average
acceptance probability used in <code>rstan::sampling</code>. Default value is 0.9.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_verbose">verbose</code></td>
<td>
<p>Logical value controlling the verbosity of output (i.e.,
warnings, messages, progress bar). Default is TRUE.</p>
</td></tr>
<tr><td><code id="joint_model_+3A_seed">seed</code></td>
<td>
<p>A positive integer seed used for random number generation in
MCMC. Default is NULL, which means the seed is generated from 1 to the
maximum integer supported by R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>

<ul>
<li><p> a model object of class <code>stanfit</code> returned by <code>rstan::sampling</code>
</p>
</li>
<li><p> initial values used in MCMC
</p>
</li></ul>



<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
model specification is possible given the data files. These checks include:
</p>

<ul>
<li><p>  All tags in data are valid (i.e., include pcr_n, pcr_k, count,
count_type, and site_cov).
</p>
</li>
<li><p>  Dimensions of pcr_n and pcr_k are equal, and dimensions of count and
count_type are equal (if count_type provided).
</p>
</li>
<li><p>  Number of sites in PCR and count data are equal.
</p>
</li>
<li><p>  All data are numeric (i.e., integer or NA).
</p>
</li>
<li><p>  Empty data cells (NA) match in pcr_n and pcr_k and in count and
count_type.
</p>
</li>
<li><p>  family is either 'poisson', 'negbin', or 'gamma'.
</p>
</li>
<li><p>  p10_priors and phi_priors (if used) is a vector of two numeric values.
</p>
</li>
<li><p>  site_cov has same number of rows as pcr_n and count, if present
</p>
</li>
<li><p>  site_cov is numeric, if present
</p>
</li>
<li><p>  cov values match column names in site_cov, if present
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Ex. 1: Implementing the joint model

# Load data
data(goby_data)

# Examine data in list
names(goby_data)

# Note that the surveyed sites (rows) should match in all data
dim(goby_data$pcr_n)[1]
dim(goby_data$count)[1]

# Fit a basic model with paired eDNA and traditional survey data.
# Count data is modeled using a poisson distribution.
fit &lt;- joint_model(data = goby_data, family = "poisson",
                   p10_priors = c(1, 20),
                   multicore = FALSE)

# Ex. 2: Implementing the joint model with site-level covariates

# With the same data, fit a model including 'Filter_time' and 'Salinity'
# site-level covariates
# These covariates will scale the sensitivity of eDNA sampling relative to
# traditional surveys
# Count data is modeled using a poisson distribution.
fit_cov &lt;- joint_model(data = goby_data, cov = c('Filter_time','Salinity'),
                       family = "poisson", p10_priors = c(1, 20),
                       multicore = FALSE)


# Ex. 3: Implementing the joint model with multiple traditional gear types

# Load data
data(green_crab_data)

# Examine data in list
names(green_crab_data)

# Note that the surveyed sites (rows) should match in all data
dim(green_crab_data$pcr_n)[1]
dim(green_crab_data$count)[1]

# Fit a model estimating a gear scaling coefficient for traditional survey
# gear types.
# This model does not assume all traditional survey methods have the same
# catchability.
# Count data is modeled using a negative binomial distribution.
fit_q &lt;- joint_model(data = green_crab_data, cov = NULL, family = "negbin",
                     p10_priors = c(1, 20), q = TRUE,
                     phi_priors = c(0.25, 0.25),
                     multicore = FALSE, initial_values = NULL,
                     n_chain = 4, n_warmup = 500,
                     n_iter = 3000, thin = 1, adapt_delta = 0.9,
                     verbose = TRUE, seed = 123)


</code></pre>

<hr>
<h2 id='joint_select'>Perform model selection using leave one out cross validation of model objects</h2><span id='topic+joint_select'></span>

<h3>Description</h3>

<p>This function performs leave one out cross validation of a list of model
fits using functions in the <code>loo</code> package, as described in Vehtari, Gelman,
and Gabry (2017) <a href="doi:10.1007/s11222-016-9696-4">doi:10.1007/s11222-016-9696-4</a>. Compare models fit using
<code>joint_model()</code> or models fits using <code>traditional_model()</code>. See more examples
in the <a href="https://ednajoint.netlify.app">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_select(model_fits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_select_+3A_model_fits">model_fits</code></td>
<td>
<p>A list containing model fits of class <code>stanfit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of delta elpd (expected log pointwise predictive density)
between model fits. Function is performed using the <code>loo</code> package.
</p>


<h3>Note</h3>

<p>Before model selection, this function makes the following check:
</p>

<ul>
<li><p> Input is a list of model fits of class 'stanfit'.
</p>
</li>
<li><p> All models compared were fit wither either <code>joint_model()</code> or all with
<code style="white-space: pre;">&#8288;traditional_model().&#8288;</code>
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(green_crab_data)

# Fit a model without estimating a gear scaling coefficient for traditional
# survey gear types.
# This model assumes all traditional survey methods have the same
# catchability.
# Count data is modeled using a poisson distribution.
fit_no_q &lt;- joint_model(data = green_crab_data, family = "poisson",
                        p10_priors = c(1,20), q = FALSE, multicore = FALSE)


# Fit a model estimating a gear scaling coefficient for traditional
# survey gear types.
# This model does not assume all traditional survey methods have the
# same catchability.
# Gear type 1 is used as the reference gear type.
# Count data is modeled using a negative binomial distribution.
fit_q &lt;- joint_model(data = green_crab_data, family = "negbin",
                     p10_priors = c(1,20), q = TRUE, multicore = FALSE)

# Perform model selection
joint_select(model_fits = list(fit_no_q$model, fit_q$model))


</code></pre>

<hr>
<h2 id='joint_summarize'>Summarize posterior distributions of model parameters.</h2><span id='topic+joint_summarize'></span>

<h3>Description</h3>

<p>This function summarizes the posterior distributions of specified parameters
from a model fit. Summary includes mean, sd, and specified quantiles, as
well as effective sample size (n_eff) and Rhat for estimated parameters. See
more examples in the
<a href="https://ednajoint.netlify.app">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_summarize(model_fit, par = "all", probs = c(0.025, 0.975), digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_summarize_+3A_model_fit">model_fit</code></td>
<td>
<p>An object of class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="joint_summarize_+3A_par">par</code></td>
<td>
<p>A character vector of parameter names. The default is 'all'.</p>
</td></tr>
<tr><td><code id="joint_summarize_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of quantiles of interest. The default is
c(0.025,0.975).</p>
</td></tr>
<tr><td><code id="joint_summarize_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of decimal
places to round values in summary table. Default value is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary table of parameter estimates.
</p>


<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
function is possible given the inputs. These checks include:
</p>

<ul>
<li><p>  Input model fit is an object of class 'stanfit'.
</p>
</li>
<li><p>  Input probs is a numeric vector.
</p>
</li>
<li><p>  Input par is a character vector.
</p>
</li>
<li><p>  Input par are present in fitted model.
</p>
</li>
<li><p>  Input model fit has converged (i.e. no divergent transitions after
warm-up).
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(green_crab_data)

# Fit a model
model_fit &lt;- joint_model(data = green_crab_data, family = "negbin", q = TRUE,
                         multicore = FALSE)

# Create summary table of all parameters
joint_summarize(model_fit$model)

# Summarize just 'p10' parameter
joint_summarize(model_fit$model, par = "p10", probs = c(0.025, 0.975),
                digits = 3)


</code></pre>

<hr>
<h2 id='mu_critical'>Calculate mu_critical</h2><span id='topic+mu_critical'></span>

<h3>Description</h3>

<p>This function uses the full posterior distributions of parameters estimated
by <code>joint_model()</code> to calculate mu_critical, or the expected catch rate at
which the probabilities of a false positive eDNA detection and true positive
eDNA detection are equal. See more examples in the
<a href="https://ednajoint.netlify.app">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu_critical(model_fit, cov_val = NULL, ci = 0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu_critical_+3A_model_fit">model_fit</code></td>
<td>
<p>An object of class <code>stanfit</code></p>
</td></tr>
<tr><td><code id="mu_critical_+3A_cov_val">cov_val</code></td>
<td>
<p>A numeric vector indicating the values of site-level
covariates to use for prediction. Default is NULL.</p>
</td></tr>
<tr><td><code id="mu_critical_+3A_ci">ci</code></td>
<td>
<p>Credible interval calculated using highest density interval (HDI).
Default is 0.9 (i.e., 90% credible interval).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with median mu_critical and lower and upper bounds on the
credible interval. If multiple gear types are used, a table of mu_critical
and lower and upper credible interval bounds is returned with one column
for each gear type.
</p>


<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
function is possible given the inputs. These checks include:
</p>

<ul>
<li><p>  Input model fit is an object of class 'stanfit'.
</p>
</li>
<li><p>  Input credible interval is a univariate numeric value greater than 0
and less than 1.
</p>
</li>
<li><p>  Input model fit contains p10 parameter.
</p>
</li>
<li><p>  If model fit contains alpha, cov_val must be provided.
</p>
</li>
<li><p>  Input cov_val is numeric.
</p>
</li>
<li><p>  Input cov_val is the same length as the number of estimated
covariates.
</p>
</li>
<li><p>  Input model fit has converged (i.e. no divergent transitions after
warm-up).
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Ex. 1: Calculating mu_critical with site-level covariates

# Load data
data(goby_data)

# Fit a model including 'Filter_time' and 'Salinity' site-level covariates
fit_cov &lt;- joint_model(data = goby_data, cov = c('Filter_time','Salinity'),
                       family = "poisson", p10_priors = c(1,20), q = FALSE,
                       multicore = FALSE)

# Calculate mu_critical at the mean covariate values (covariates are
# standardized, so mean = 0)
mu_critical(fit_cov$model, cov_val = c(0,0), ci = 0.9)

# Calculate mu_critical at habitat size 0.5 z-scores greater than the mean
mu_critical(fit_cov$model, cov_val = c(0,0.5), ci = 0.9)

# Ex. 2: Calculating mu_critical with multiple traditional gear types

# Load data
data(green_crab_data)

# Fit a model with no site-level covariates
fit_q &lt;- joint_model(data = green_crab_data, cov = NULL, family = "negbin",
                     p10_priors = c(1,20), q = TRUE, multicore = FALSE)

# Calculate mu_critical
mu_critical(fit_q$model, cov_val = NULL, ci = 0.9)


</code></pre>

<hr>
<h2 id='traditional_model'>Specify and fit model using count data from traditional, non eDNA surveys</h2><span id='topic+traditional_model'></span>

<h3>Description</h3>

<p>This function implements a Bayesian model that estimates expected species
catch rate using count data from traditional, non eDNA surveys. When
multiple traditional gear types are used, an optional variation allows
estimation of gear scaling coefficients, which scale the catchability of
gear types relative to the expected catch rate of a reference gear type.
Model is implemented using Bayesian inference using the <code>rstan</code> package,
which uses Hamiltonian Monte Carlo to simulate the posterior distributions.
See more examples in the
<a href="https://ednajoint.netlify.app">Package
Vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traditional_model(
  data,
  family = "poisson",
  q = FALSE,
  phi_priors = NULL,
  multicore = FALSE,
  initial_values = NULL,
  n_chain = 4,
  n_warmup = 500,
  n_iter = 3000,
  thin = 1,
  adapt_delta = 0.9,
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traditional_model_+3A_data">data</code></td>
<td>
<p>A list containing data necessary for model fitting. Valid tags
are <code>count</code> and <code>count_type</code>. <code>count</code> is a matrix or data frame of
traditional survey count data, with first dimension equal to the number of
sites (i) and second dimension equal to the maximum number of traditional
survey replicates at a given site (j). <code>count_type</code> is an optional matrix
or data frame of integers indicating gear type (k) used in corresponding
count data, with first dimension equal to the number of sites (i) and
second dimension equal to the maximum number of traditional survey
replicates at a given site (j). Values should be integers beginning with
1 (referring to the first gear type) to n (last gear type). Empty cells
should be NA and will be removed during processing. Sites, i, should be
consistent in all count data.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_family">family</code></td>
<td>
<p>The distribution class used to model traditional survey count
data. Options include poisson ('poisson'), negative binomial ('negbin'),
and gamma ('gamma'). Default value is 'poisson'.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_q">q</code></td>
<td>
<p>A logical value indicating whether to estimate gear scaling
coefficients, q, for traditional survey gear types (TRUE) or to not
estimate gear scaling coefficients, q, for traditional survey gear types
(FALSE). Default value is FALSE.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_phi_priors">phi_priors</code></td>
<td>
<p>A numeric vector indicating gamma distribution
hyperparameters (shape, rate) used as the prior distribution for phi, the
overdispersion in the negative binomial distribution for traditional survey
gear data. Used when family = 'negbin.' If family = 'negbin', then
default vector is c(0.25,0.25), otherwise, default is NULL.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_multicore">multicore</code></td>
<td>
<p>A logical value indicating whether to parallelize chains
with multiple cores. Default is FALSE.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_initial_values">initial_values</code></td>
<td>
<p>A list of lists of initial values to use in MCMC. The
length should equal the number of MCMC chains. Initial values can be
provided for parameters: mu and q. If no initial values are provided,
default random values are drawn.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_n_chain">n_chain</code></td>
<td>
<p>Number of MCMC chains. Default value is 4.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_n_warmup">n_warmup</code></td>
<td>
<p>A positive integer specifying the number of warm-up MCMC
iterations. Default value is 500.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_n_iter">n_iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each
chain (including warmup). Default value is 3000.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples.
Default value is 1.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>Numeric value between 0 and 1 indicating target average
acceptance probability used in <code>rstan::sampling</code>. Default value is 0.9.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_verbose">verbose</code></td>
<td>
<p>Logical value controlling the verbosity of output (i.e.,
warnings, messages, progress bar). Default is TRUE.</p>
</td></tr>
<tr><td><code id="traditional_model_+3A_seed">seed</code></td>
<td>
<p>A positive integer seed used for random number generation in
MCMC. Default is NULL, which means the seed is generated from 1 to the
maximum integer supported by R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>

<ul>
<li><p> a model object of class <code>stanfit</code> returned by <code>rstan::sampling</code>
</p>
</li>
<li><p> initial values used in MCMC
</p>
</li></ul>



<h3>Note</h3>

<p>Before fitting the model, this function checks to ensure that the
model specification is possible given the data files. These checks include:
</p>

<ul>
<li><p>  All tags in data are valid (i.e., include count and count_type).
</p>
</li>
<li><p>  Number of sites in count and count type data are equal.
</p>
</li>
<li><p>  All data are numeric (i.e., integer or NA).
</p>
</li>
<li><p>  Empty data cells (NA) match in count and count_type.
</p>
</li>
<li><p>  family is 'poisson', 'negbin', or 'gamma'.
</p>
</li>
<li><p>  phi_priors (if used) is a vector of two numeric values.
</p>
</li></ul>

<p>If any of these checks fail, the function returns an error message.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data(green_crab_data)

# Examine data in list
# This function uses only traditional survey count data and optionally
# the count type data
names(green_crab_data)

# Note that the surveyed sites (rows) should match in the data
dim(green_crab_data$count)[1]
dim(green_crab_data$count_type)[1]

# Fit a model without estimating a gear scaling coefficient for traditional
# survey gear types.
# This model assumes all traditional survey methods have the same
# catchability.
# Count data is modeled using a poisson distribution.
fit_no_q &lt;- traditional_model(data = green_crab_data, family = "poisson",
                              q = FALSE, phi_priors = NULL,
                              multicore = FALSE, verbose = TRUE)


# Fit a model estimating a gear scaling coefficient for traditional survey
# gear types.
# This model does not assume all traditional survey methods have the same
# catchability.
# Count data is modeled using a negative binomial distribution.
fit_q &lt;- traditional_model(data = green_crab_data, family = "negbin",
                           q = TRUE, phi_priors = c(0.25,0.25),
                           multicore = FALSE, initial_values = NULL,
                           n_chain = 4, n_warmup = 500, n_iter = 3000,
                           thin = 1, adapt_delta = 0.9, verbose = TRUE,
                           seed = 123)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
