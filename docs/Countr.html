<!DOCTYPE html><html><head><title>Help for package Countr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Countr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addBootSampleObject'><p>Create a bootsrap sample for coefficient estimates</p></a></li>
<li><a href='#alphagen'><p>Matrix of alpha terms</p></a></li>
<li><a href='#chiSq_gof'><p>Formal Chi-square goodness-of-fit test</p></a></li>
<li><a href='#chiSq_pearson'><p>Pearson Chi-Square test</p></a></li>
<li><a href='#compareToGLM'><p>Compare renewals fit to glm models fit</p></a></li>
<li><a href='#count_table'><p>Summary of a count variable</p></a></li>
<li><a href='#Countr-package'><p>Flexible Univariate Count Models Based on Renewal Processes</p></a></li>
<li><a href='#CountrFormula'><p>Create a formula for renewalCount</p></a></li>
<li><a href='#dCount_allProbs_bi'><p>Compute count probabilities using simple convolution</p></a></li>
<li><a href='#dCount_conv_bi'><p>Compute count probabilities using convolution</p></a></li>
<li><a href='#dCount_conv_loglik_bi'><p>Log-likelihood of a count probability computed by convolution (bi)</p></a></li>
<li><a href='#dCount_dePril_bi'><p>Compute count probabilities using dePril convolution (bi)</p></a></li>
<li><a href='#dCount_naive_bi'><p>Compute count probabilities using naive convolution (bi)</p></a></li>
<li><a href='#dmodifiedCount_bi'><p>Compute count probabilities based on modified renewal process (bi)</p></a></li>
<li><a href='#dWeibullCount'><p>Probability calculations for Weibull count models</p></a></li>
<li><a href='#dWeibullCount_mat'><p>Univariate Weibull Count Probability</p></a></li>
<li><a href='#dWeibullgammaCount_acc'><p>Fast Univariate Weibull Count Probability with gamma heterogeneity</p></a></li>
<li><a href='#dWeibullgammaCount_mat'><p>Univariate Weibull Count Probability with gamma heterogeneity</p></a></li>
<li><a href='#dWeibullgammaCount_mat_Covariates'><p>Univariate Weibull Count Probability with gamma and</p>
covariate heterogeneity</a></li>
<li><a href='#evCount_conv_bi'><p>Expected value and variance of renewal count process</p></a></li>
<li><a href='#fertility'><p>Fertility data</p></a></li>
<li><a href='#football'><p>Football data</p></a></li>
<li><a href='#frequency_plot'><p>Plot a frequency chart</p></a></li>
<li><a href='#getParNames'><p>Return the names of distribution parameters</p></a></li>
<li><a href='#predict.renewal'><p>Predict method for renewal objects</p></a></li>
<li><a href='#prob_predict'><p>Probability predictions</p></a></li>
<li><a href='#renewal'><p>Deprecated old name of <code>renewalCount()</code></p></a></li>
<li><a href='#renewal_methods'><p>Methods for renewal objects</p></a></li>
<li><a href='#renewal.control'><p>Creates the renewal control list</p></a></li>
<li><a href='#renewal.convPars'><p>Creates the convolution inputs setting</p></a></li>
<li><a href='#renewal.seriesPars'><p>Creates the series expansion inputs setting</p></a></li>
<li><a href='#renewal.weiMethod'><p>Check weibull computation algorithm</p></a></li>
<li><a href='#renewalCoef'><p>Get named vector of coefficients for renewal objects</p></a></li>
<li><a href='#renewalCoefList'><p>Split a vector using the prefixes of the names for grouping</p></a></li>
<li><a href='#renewalCount'><p>Fit renewal count processes regression models</p></a></li>
<li><a href='#renewalNames'><p>Get names of parameters of renewal regression models</p></a></li>
<li><a href='#residuals_plot'><p>Method to visualise the residuals</p></a></li>
<li><a href='#se.coef'><p>Extract Standard Errors of Model Coefficients</p></a></li>
<li><a href='#surv'><p>Wrapper to built-in survival functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Univariate Count Models Based on Renewal Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>3.5.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible univariate count models based on renewal processes. The
    models may include covariates and can be specified with familiar formula
    syntax as in glm() and package 'flexsurv'.  The methodology is described by
    Kharrat et all (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v090.i13">doi:10.18637/jss.v090.i13</a>&gt; (included as vignette
    'Countr_guide' in the package).
    If the suggested package 'pscl' is not available from CRAN, it can be
    installed with 'remotes::install_github("cran/pscl")'. It is no longer used
    by the functions in this package but is needed for some of the extended
    examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/Countr/">https://geobosh.github.io/Countr/</a> (doc),
<a href="https://github.com/GeoBosh/Countr">https://github.com/GeoBosh/Countr</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/Countr/issues">https://github.com/GeoBosh/Countr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, Rcpp (&ge; 0.11.3), flexsurv, Formula, VGAM, optimx,
numDeriv, boot, MASS, car, utils, Rdpack (&ge; 0.7-0), lattice,
RColorBrewer, dplyr, standardize, lmtest, xtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, pscl</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Countr-package.R' 'RcppExports.R' 'anc.R' 'coefnames.R'
'convCount_loglik.R' 'convCount_moments.R' 'convCount_probs.R'
'dWeibull.R' 'dWeibullgamma.R' 'data.R' 'probpredict.R'
'renewal_IV.R' 'renewal_tools.R' 'renewal_cstr.R' 'tools.R'
'renewal_methods.R'</td>
</tr>
<tr>
<td>Config/build/clean-inst-doc:</td>
<td>FALSE</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-14 13:19:17 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarak Kharrat [aut],
  Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-14 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addBootSampleObject'>Create a bootsrap sample for coefficient estimates</h2><span id='topic+addBootSampleObject'></span>

<h3>Description</h3>

<p>Create a boostrap sample from coefficient estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBootSampleObject(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBootSampleObject_+3A_object">object</code></td>
<td>
<p>an object to add boot object to.</p>
</td></tr>
<tr><td><code id="addBootSampleObject_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed to the <code>boot::boot()</code> function
other than <code>data</code> and <code>statistic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information in <code>object</code> is used to prepare the arguments and then
<code>boot</code> is called to generate the bootstrap sample.
The bootstrap sample is stored in <code>object</code> as component <code>"boot"</code>.
Arguments in <code>"..."</code> can be used customise the <code>boot()</code> call.
</p>


<h3>Value</h3>

<p><code>object</code> with additional component <code>"boot"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renewal_methods">renewal_methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see renewal_methods
</code></pre>

<hr>
<h2 id='alphagen'>Matrix of alpha terms</h2><span id='topic+alphagen'></span>

<h3>Description</h3>

<p>Matrix of alpha terms used internally by the different Weibull count
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphagen(cc, jrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphagen_+3A_cc">cc</code></td>
<td>
<p>numeric, shape parameter.</p>
</td></tr>
<tr><td><code id="alphagen_+3A_jrow">jrow</code></td>
<td>
<p>numeric, number of rows of the alpha matrix. See formulae (11) in
<em>McShane(2008)</em>.</p>
</td></tr>
<tr><td><code id="alphagen_+3A_ncol">ncol</code></td>
<td>
<p>numeric, number of columns of the alpha matrix. Note that the
first column corresponds to <code class="reqn">n=0</code>, <code class="reqn">n</code> being the count value, see
formulae (11) in <em>McShane(2008)</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is usually advisable to compute the alpha terms a minimum number of times
as it may be time consuming in general. Note that the alpha terms only depend
on the shape (c) parameter
</p>


<h3>Value</h3>

<p><code>jrow</code> x <code>ncol</code> (lower triangular) matrix of
<code class="reqn">\alpha_j^n</code> terms defined in <em>McShane(2008)</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## alphagen(0.994, 6, 8)

</code></pre>

<hr>
<h2 id='chiSq_gof'>Formal Chi-square goodness-of-fit test</h2><span id='topic+chiSq_gof'></span><span id='topic+chiSq_gof.renewal'></span><span id='topic+chiSq_gof.negbin'></span><span id='topic+chiSq_gof.glm'></span>

<h3>Description</h3>

<p>Carry out the formal chi-square goodness-of-fit test described by Cameron
(2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiSq_gof(object, breaks, ...)

## S3 method for class 'renewal'
chiSq_gof(object, breaks, ...)

## S3 method for class 'negbin'
chiSq_gof(object, breaks, ...)

## S3 method for class 'glm'
chiSq_gof(object, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chiSq_gof_+3A_object">object</code></td>
<td>
<p>an object from class <code>renewal</code>.</p>
</td></tr>
<tr><td><code id="chiSq_gof_+3A_breaks">breaks</code></td>
<td>
<p>integer values at which the breaks shoudl happen. The function
will compute the observed frequencies in the intervals <code>[breaks[i],
breaks[i + 1])</code>.</p>
</td></tr>
<tr><td><code id="chiSq_gof_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is a conditional moment test described in details in Cameron (2013,
Section 5.3.4). We compute the asymptotically equivalent outer product of the
gradient version which is justified for renewal models (fully parametric +
parameters based on MLE).
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>References</h3>

<p>Cameron AC, Trivedi PK (2013).
<em>Regression Analysis of Count Data</em>, volume 53.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chiSq_pearson">chiSq_pearson</a></code>
</p>

<hr>
<h2 id='chiSq_pearson'>Pearson Chi-Square test</h2><span id='topic+chiSq_pearson'></span><span id='topic+chiSq_pearson.renewal'></span><span id='topic+chiSq_pearson.glm'></span>

<h3>Description</h3>

<p>Carry out Pearson Chi-Square test and compute the Pearson statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiSq_pearson(object, ...)

## S3 method for class 'renewal'
chiSq_pearson(object, ...)

## S3 method for class 'glm'
chiSq_pearson(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chiSq_pearson_+3A_object">object</code></td>
<td>
<p>an object from class <code>renewal</code>.</p>
</td></tr>
<tr><td><code id="chiSq_pearson_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is inspired from Cameron(2013) Chapter 5.3.4. Observed and
fitted frequencies are computed and the contribution of every observed cell
to the Pearson's chi-square test statistic is reported. The idea is to check if
the fitted model has a tendancy to over or under predict some ranges of data
</p>


<h3>Value</h3>

<p>data.frame with 5 columns given the count values (<code>Counts</code>),
observed frequencies (<code>Actual</code>), model's prediction
(<code>Predicted</code>), the difference (<code>Diff</code>) and the contribution to
the Pearson's statistic (<code>Pearson</code>).
</p>


<h3>References</h3>

<p>Cameron AC, Trivedi PK (2013).
<em>Regression Analysis of Count Data</em>, volume 53.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chiSq_gof">chiSq_gof</a></code>
</p>

<hr>
<h2 id='compareToGLM'>Compare renewals fit to glm models fit</h2><span id='topic+compareToGLM'></span>

<h3>Description</h3>

<p>Compare renewals fit to glm models fit on the same data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareToGLM(poisson_model, breaks, nbinom_model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareToGLM_+3A_poisson_model">poisson_model</code></td>
<td>
<p>fitted Poisson glm model</p>
</td></tr>
<tr><td><code id="compareToGLM_+3A_breaks">breaks</code></td>
<td>
<p>integer values at which the breaks should happen. The function
will compute the observed frequencies in the intervals <code>[breaks[i],
breaks[i + 1])</code>.</p>
</td></tr>
<tr><td><code id="compareToGLM_+3A_nbinom_model">nbinom_model</code></td>
<td>
<p>fitted negative binomial (fitted using
<code>MASS::glm.nb()</code>). This argument is optional.</p>
</td></tr>
<tr><td><code id="compareToGLM_+3A_...">...</code></td>
<td>
<p>renewal models to be considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a data.frame similar to Table 5.6 in Cameron(2013),
using the observed frequencies and predictions from different
models. Supported models accepted are Poisson and negative binomial (fitted
using <code>MASS::glm.nb()</code>) from the glm family and any model from the
renewal family (passed in <code>...</code>).
</p>


<h3>Value</h3>

<p>data.frame with columns <code>Counts</code>, <code>Actual</code> (observed
probability) and then 2 columns per model passed (predicted probability
and pearson statistic) for the associated count value.
</p>


<h3>References</h3>

<p>Cameron AC, Trivedi PK (2013).
<em>Regression Analysis of Count Data</em>, volume 53.
Cambridge University Press.
</p>

<hr>
<h2 id='count_table'>Summary of a count variable</h2><span id='topic+count_table'></span>

<h3>Description</h3>

<p>Summary of a count variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_table(count, breaks, formatChar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_table_+3A_count">count</code></td>
<td>
<p>integer, observed count value for every individual in the
sample.</p>
</td></tr>
<tr><td><code id="count_table_+3A_breaks">breaks</code></td>
<td>
<p>integer, values at which the breaks should happen. The function
will compute the observed frequency in <code>[breaks[i], breaks[i + 1])</code>.</p>
</td></tr>
<tr><td><code id="count_table_+3A_formatchar">formatChar</code></td>
<td>
<p>logical, should the values be converted to character and
formatted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does a similar job to <code>table()</code> with more flexibility
introduced by the argument <code>breaks</code>. The user can decide how to break
the count values and decide to merge some cells if needed.
</p>


<h3>Value</h3>

<p><code>matrix</code> with 2 rows and <code>length(breaks)</code> columns.  The
column names are the cells names. The rows are the observed frequencies
and relative frequencies (probabilities).
</p>

<hr>
<h2 id='Countr-package'>Flexible Univariate Count Models Based on Renewal Processes</h2><span id='topic+Countr-package'></span><span id='topic+Countr'></span>

<h3>Description</h3>

<p>Flexible univariate count models based on renewal
processes. The models may include covariates and can be specified
with familiar formula syntax as in glm() and 'flexsurv'.
</p>


<h3>Details</h3>

<p>The methodology is described by
Kharrat et al. (2019).  The paper is included in
the package as vignette <code>vignette('Countr_guide_paper', package = "Countr")</code>).
</p>
<p>The main function is <code><a href="#topic+renewalCount">renewalCount</a></code>, see its documentation for
examples.
</p>
<p>Goodness of fit chi-square (likelihood ratio and Pearson) tests for glm and
count renewal models are implemented in <code><a href="#topic+chiSq_gof">chiSq_gof</a></code> and
<code><a href="#topic+chiSq_pearson">chiSq_pearson</a></code>.
</p>


<h3>References</h3>

<p>Baker R, Kharrat T (2017).
&ldquo;Event count distributions from renewal processes: fast computation of probabilities.&rdquo;
<em>IMA Journal of Management Mathematics</em>, <b>29</b>(4), 415-433.
ISSN 1471-678X, <a href="https://doi.org/10.1093/imaman/dpx008">doi:10.1093/imaman/dpx008</a>, https://academic.oup.com/imaman/article-pdf/29/4/415/25693854/dpx008.pdf.
</p>
<p>Boshnakov G, Kharrat T, McHale IG (2017).
&ldquo;A bivariate Weibull count model for forecasting association football scores.&rdquo;
<em>International Journal of Forecasting</em>, <b>33</b>(2), 458&ndash;466.
</p>
<p>Cameron AC, Trivedi PK (2013).
<em>Regression Analysis of Count Data</em>, volume 53.
Cambridge University Press.
</p>
<p>Kharrat T, Boshnakov GN, McHale I, Baker R (2019).
&ldquo;Flexible Regression Models for Count Data Based on Renewal Processes: The Countr Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>90</b>(13), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v090.i13">doi:10.18637/jss.v090.i13</a>.
</p>
<p>McShane B, Adrian M, Bradlow ET, Fader PS (2008).
&ldquo;Count models based on Weibull interarrival times.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>26</b>(3), 369&ndash;378.
</p>
<p>Winkelmann R (1995).
&ldquo;Duration dependence and dispersion in count-data models.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>13</b>(4), 467&ndash;474.
</p>

<hr>
<h2 id='CountrFormula'>Create a formula for renewalCount</h2><span id='topic+CountrFormula'></span>

<h3>Description</h3>

<p>Create a formula for renewalCount
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountrFormula(response, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountrFormula_+3A_response">response</code></td>
<td>
<p>the formula for the &quot;main&quot; parameter. It also specifies the
response variable.</p>
</td></tr>
<tr><td><code id="CountrFormula_+3A_...">...</code></td>
<td>
<p>additional arguments for the ancilliary parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Formula object suitable for argument <code>formula</code> of
<code>renewalCount()</code>.
</p>

<hr>
<h2 id='dCount_allProbs_bi'>Compute count probabilities using simple convolution</h2><span id='topic+dCount_allProbs_bi'></span><span id='topic+dCount_allProbs_user'></span>

<h3>Description</h3>

<p>Compute count probabilities using simple convolution (section 2) for the
built-in distributions
</p>
<p>Compute count probabilities using simple convolution (section 2) for user
passed survival functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCount_allProbs_bi(
  x,
  distPars,
  dist,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  logFlag = FALSE
)

dCount_allProbs_user(
  x,
  distPars,
  extrapolPars,
  survR,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  logFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCount_allProbs_bi_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_distpars">distPars</code></td>
<td>
<p><code>Rcpp::List</code> with distribution specific slots,
see details.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_dist">dist</code></td>
<td>
<p>character name of the built-in distribution, see details.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_time">time</code></td>
<td>
<p>double time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_logflag">logFlag</code></td>
<td>
<p>logical if <code>TRUE</code> the log-probability will be returned.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>ma::vec of length 2. The extrapolation values.</p>
</td></tr>
<tr><td><code id="dCount_allProbs_bi_+3A_survr">survR</code></td>
<td>
<p>Rcpp::Function user passed survival function; should have the
signature <code>function(t, distPars)</code> where <code>t</code> is a real number (&gt;0)
where the survival function is evaluated and <code>distPars</code> is a list of
distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine does convolutions to produce probabilities <code>probs(0)</code>,
... <code>probs(xmax)</code> using <code>nsteps</code> steps, and refines result by
Richardson extrapolation if <code>extrap</code> is <code>TRUE</code> using the
algorithm of section 2.
</p>


<h3>Value</h3>

<p>vector of probabilities P(x(i)) for i = 1, ..., n where n is
<code>length</code> of <code>x</code>.
</p>

<hr>
<h2 id='dCount_conv_bi'>Compute count probabilities using convolution</h2><span id='topic+dCount_conv_bi'></span><span id='topic+dCount_conv_user'></span>

<h3>Description</h3>

<p>Compute count probabilities using one of several convolution methods.
<code>dCount_conv_bi</code> does the computations for the distributions with
builtin support in this package.
</p>
<p><code>dCount_conv_user</code> does the same using a user defined survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCount_conv_bi(
  x,
  distPars,
  dist = c("weibull", "gamma", "gengamma", "burr"),
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE,
  log = FALSE
)

dCount_conv_user(
  x,
  distPars,
  extrapolPars,
  survR,
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE,
  log = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCount_conv_bi_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_distpars">distPars</code></td>
<td>
<p><code>Rcpp::List</code> with distribution specific slots,
see details.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_dist">dist</code></td>
<td>
<p>character name of the built-in distribution, see details.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_method">method</code></td>
<td>
<p>character string, the method to use, see Details.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer, number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_time">time</code></td>
<td>
<p>double, time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical, if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_log">log</code></td>
<td>
<p>logical, if <code>TRUE</code> the log-probability will be returned.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>vector of length 2, the extrapolation values.</p>
</td></tr>
<tr><td><code id="dCount_conv_bi_+3A_survr">survR</code></td>
<td>
<p>function, user supplied survival function; should have signature
<code>function(t, distPars)</code>, where <code>t</code> is a positive real number
(the time where the survival function is evaluated) and <code>distPars</code>
is a list of distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dCount_conv_bi</code> computes count probabilities using one of several
convolution methods for the distributions with builtin support in this
package.
</p>
<p>The following convolution methods are implemented: &quot;dePril&quot;, &quot;direct&quot;, and
&quot;naive&quot;.
</p>
<p>The builtin distributions currently are Weibull, gamma, generalised gamma and
Burr.
</p>




<h3>Value</h3>

<p>vector of probabilities <code class="reqn">P(x(i),\ i = 1, ..., n)</code> where <code class="reqn">n</code>
is the length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
lambda &lt;- 2.56
p0 &lt;- dpois(x, lambda)
ll &lt;- sum(dpois(x, lambda, TRUE))

err &lt;- 1e-6
## all-probs convolution approach
distPars &lt;- list(scale = lambda, shape = 1)
pmat_bi &lt;- dCount_conv_bi(x, distPars, "weibull", "direct",
                          nsteps = 200)

## user pwei
pwei_user &lt;- function(tt, distP) {
    alpha &lt;- exp(-log(distP[["scale"]]) / distP[["shape"]])
    pweibull(q = tt, scale = alpha, shape = distP[["shape"]],
             lower.tail = FALSE)
}

pmat_user &lt;- dCount_conv_user(x, distPars, c(1, 2), pwei_user, "direct",
                              nsteps = 200)
max((pmat_bi - p0)^2 / p0)
max((pmat_user - p0)^2 / p0)

## naive convolution approach
pmat_bi &lt;- dCount_conv_bi(x, distPars, "weibull", "naive",
                          nsteps = 200)
pmat_user &lt;- dCount_conv_user(x, distPars, c(1, 2), pwei_user, "naive",
                              nsteps = 200)
max((pmat_bi- p0)^2 / p0)
max((pmat_user- p0)^2 / p0)

## dePril conv approach
pmat_bi &lt;- dCount_conv_bi(x, distPars, "weibull", "dePril",
                          nsteps = 200)
pmat_user &lt;- dCount_conv_user(x, distPars, c(1, 2), pwei_user, "dePril",
                              nsteps = 200)
max((pmat_bi- p0)^2 / p0)
max((pmat_user- p0)^2 / p0)

</code></pre>

<hr>
<h2 id='dCount_conv_loglik_bi'>Log-likelihood of a count probability computed by convolution (bi)</h2><span id='topic+dCount_conv_loglik_bi'></span><span id='topic+dCount_conv_loglik_user'></span>

<h3>Description</h3>

<p>Compute the log-likelihood of a count model using  convolution
methods to compute the probabilities.
<code>dCount_conv_loglik_bi</code> is for the builtin distributions.
<code>dCount_conv_loglik_user</code> is for user defined survival functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCount_conv_loglik_bi(
  x,
  distPars,
  dist = c("weibull", "gamma", "gengamma", "burr"),
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE,
  na.rm = TRUE,
  weights = NULL
)

dCount_conv_loglik_user(
  x,
  distPars,
  extrapolPars,
  survR,
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE,
  na.rm = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCount_conv_loglik_bi_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_distpars">distPars</code></td>
<td>
<p>list of the same length as x with each slot being itself a
named list containing the distribution parameters corresponding to
<code>x[i]</code>.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_dist">dist</code></td>
<td>
<p>character name of the built-in distribution, see details.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_method">method</code></td>
<td>
<p>character, convolution method to be used; choices are
<code>"dePril"</code> (section 3.2), <code>"direct"</code> (section 2) or
<code>"naive"</code> (section 3.1).</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_time">time</code></td>
<td>
<p>double time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if TRUE, <code>NA</code>s (produced by taking the log of
very small probabilities) will be replaced by the smallest allowed
probability; default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_weights">weights</code></td>
<td>
<p>numeric, vector of weights to apply. If <code>NULL</code>, a vector
of ones.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>list of same length as x where each slot is a vector of
length 2 (the extrapolation values to be used) corresponding to
<code>x[i]</code>.</p>
</td></tr>
<tr><td><code id="dCount_conv_loglik_bi_+3A_survr">survR</code></td>
<td>
<p>a user defined survival function; should have the signature
<code>function(t, distPars)</code> where <code>t</code> is a real number (&gt;0) where
the survival function is evaluated and <code>distPars</code> is a list of
distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the log-likelihood of the count process
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0:10
lambda &lt;- 2.56
distPars &lt;- list(scale = lambda, shape = 1)
distParsList &lt;- lapply(seq(along = x), function(ind) distPars)
extrapolParsList &lt;- lapply(seq(along = x), function(ind) c(2, 1))
## user pwei
pwei_user &lt;- function(tt, distP) {
    alpha &lt;- exp(-log(distP[["scale"]]) / distP[["shape"]])
    pweibull(q = tt, scale = alpha, shape = distP[["shape"]],
             lower.tail = FALSE)
}

## log-likehood allProbs Poisson
dCount_conv_loglik_bi(x, distParsList,
                      "weibull", "direct", nsteps = 400)

dCount_conv_loglik_user(x, distParsList, extrapolParsList,
                        pwei_user, "direct", nsteps = 400)

## log-likehood naive Poisson
dCount_conv_loglik_bi(x, distParsList,
                      "weibull", "naive", nsteps = 400)

dCount_conv_loglik_user(x, distParsList, extrapolParsList,
                        pwei_user, "naive", nsteps = 400)

## log-likehood dePril Poisson
dCount_conv_loglik_bi(x, distParsList,
                      "weibull", "dePril", nsteps = 400)

dCount_conv_loglik_user(x, distParsList, extrapolParsList,
                        pwei_user, "dePril", nsteps = 400)
## see dCount_conv_loglik_bi()
</code></pre>

<hr>
<h2 id='dCount_dePril_bi'>Compute count probabilities using dePril convolution (bi)</h2><span id='topic+dCount_dePril_bi'></span><span id='topic+dCount_dePril_user'></span>

<h3>Description</h3>

<p>Compute count probabilities using dePril convolution (section 3.2) for the
built-in distributions
</p>
<p>Compute count probabilities using dePril convolution (section 3.2) for the
user passed survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCount_dePril_bi(
  x,
  distPars,
  dist,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)

dCount_dePril_user(
  x,
  distPars,
  extrapolPars,
  survR,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCount_dePril_bi_+3A_survr">survR</code></td>
<td>
<p>Rcpp::Function user passed survival function; should have the
signature <code>function(t, distPars)</code> where <code>t</code> is a real number (&gt;0)
where the survival function is evaluated and <code>distPars</code> is a list of
distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine does minimum number of convolution using dePril trick
to compute the count
probability P(x) sing <code>nsteps</code> steps, and refines result by
Richardson extrapolation if <code>extrap</code> is <code>TRUE</code> using the
algorithm of section 3.2.
</p>


<h3>Value</h3>

<p>vector of probabilities P(x(i)) for i = 1, ..., n where n is
<code>length</code> of <code>x</code>.
</p>

<hr>
<h2 id='dCount_naive_bi'>Compute count probabilities using naive convolution (bi)</h2><span id='topic+dCount_naive_bi'></span><span id='topic+dCount_naive_user'></span>

<h3>Description</h3>

<p>Compute count probabilities using naive convolution (section 3.1) for the
built-in distributions
</p>
<p>Compute count probabilities using naive convolution (section 3.1) for the
user passed survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dCount_naive_bi(
  x,
  distPars,
  dist,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)

dCount_naive_user(
  x,
  distPars,
  extrapolPars,
  survR,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dCount_naive_bi_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_distpars">distPars</code></td>
<td>
<p><code>Rcpp::List</code> with distribution specific slots,
see details.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_dist">dist</code></td>
<td>
<p>character name of the built-in distribution, see details.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_time">time</code></td>
<td>
<p>double time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_cdfout">cdfout</code></td>
<td>
<p>logical if <code>TRUE</code>, the cdf will be returned instead of
the count probability.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_logflag">logFlag</code></td>
<td>
<p>logical if <code>TRUE</code> the log-probability will be returned.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>ma::vec of length 2. The extrapolation values.</p>
</td></tr>
<tr><td><code id="dCount_naive_bi_+3A_survr">survR</code></td>
<td>
<p>Rcpp::Function user passed survival function; should have the
signature <code>function(t, distPars)</code> where <code>t</code> is a real number (&gt;0)
where the survival function is evaluated and <code>distPars</code> is a list of
distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine does minimum number of convolution to compute the count
probability P(x) sing <code>nsteps</code> steps, and refines result by
Richardson extrapolation if <code>extrap</code> is <code>TRUE</code> using the
algorithm of section 3.1.
</p>


<h3>Value</h3>

<p>vector of probabilities P(x(i)) for i = 1, ..., n where n is
<code>length</code> of <code>x</code>.
</p>

<hr>
<h2 id='dmodifiedCount_bi'>Compute count probabilities based on modified renewal process (bi)</h2><span id='topic+dmodifiedCount_bi'></span><span id='topic+dmodifiedCount_user'></span>

<h3>Description</h3>

<p>Compute count probabilities based on modified renewal process using
dePril algorithm.
<code>dmodifiedCount_bi</code> does it for the builtin distributions.
</p>


<p><code>dmodifiedCount_user</code> does the same for a user specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmodifiedCount_bi(
  x,
  distPars,
  dist,
  distPars0,
  dist0,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)

dmodifiedCount_user(
  x,
  distPars,
  survR,
  distPars0,
  survR0,
  extrapolPars,
  nsteps = 100L,
  time = 1,
  extrap = TRUE,
  cdfout = FALSE,
  logFlag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmodifiedCount_bi_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_distpars0">distPars0</code>, <code id="dmodifiedCount_bi_+3A_distpars">distPars</code></td>
<td>
<p><code>Rcpp::List</code> with distribution specific slots
for the first arrival and the rest of the process respectively.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_dist0">dist0</code>, <code id="dmodifiedCount_bi_+3A_dist">dist</code></td>
<td>
<p>character, name of the first and following survival
distributions.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_time">time</code></td>
<td>
<p>double time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_cdfout">cdfout</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_logflag">logFlag</code></td>
<td>
<p>logical if <code>TRUE</code> the log-probability will be returned.</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_survr0">survR0</code>, <code id="dmodifiedCount_bi_+3A_survr">survR</code></td>
<td>
<p>user supplied survival function; should have 
signature <code>function(t, distPars)</code>, where <code>t</code> is a positive real
number (the time at which the survival function is evaluated) and
<code>distPars</code> is a list of distribution parameters. It should return a
double value (first arrival and following arrivals respectively).</p>
</td></tr>
<tr><td><code id="dmodifiedCount_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>list of same length as <code>x</code>, where each slot is a
vector of length 2 (the extrapolation values to be used) corresponding to
<code>x[i]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the modified renewal process the first arrival is allowed to have
a different distribution from the  time between subsequent arrivals.
The renewal assumption is kept.
</p>


<h3>Value</h3>

<p>vector of probabilities P(x(i)) for i = 1, ..., n where n is
the length of <code>x</code>.
</p>

<hr>
<h2 id='dWeibullCount'>Probability calculations for Weibull count models</h2><span id='topic+dWeibullCount'></span><span id='topic+dWeibullCount_loglik'></span><span id='topic+evWeibullCount'></span>

<h3>Description</h3>

<p>Probability computations for the univariate Weibull count process. Several
methods are provided.
<code>dWeibullCount</code> computes probabilities.
</p>
<p><code>dWeibullCount_loglik</code> computes the log-likelihood.
</p>
<p><code>evWeibullCount</code> computes the expected value and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWeibullCount(
  x,
  shape,
  scale,
  method = c("series_acc", "series_mat", "conv_direct", "conv_naive", "conv_dePril"),
  time = 1,
  log = FALSE,
  conv_steps = 100,
  conv_extrap = TRUE,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10
)

dWeibullCount_loglik(
  x,
  shape,
  scale,
  method = c("series_acc", "series_mat", "conv_direct", "conv_naive", "conv_dePril"),
  time = 1,
  na.rm = TRUE,
  conv_steps = 100,
  conv_extrap = TRUE,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10,
  weights = NULL
)

evWeibullCount(
  xmax,
  shape,
  scale,
  method = c("series_acc", "series_mat", "conv_direct", "conv_naive", "conv_dePril"),
  time = 1,
  conv_steps = 100,
  conv_extrap = TRUE,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dWeibullCount_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_shape">shape</code></td>
<td>
<p>numeric (length 1), shape parameter of the Weibull count.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_scale">scale</code></td>
<td>
<p>numeric (length 1), scale parameter of the Weibull count.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_method">method</code></td>
<td>
<p>character, one of the available methods, see details.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_time">time</code></td>
<td>
<p>double, length of the observation window (defaults to 1).</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_log">log</code></td>
<td>
<p>logical, if TRUE, the log of the probability will be returned.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_conv_steps">conv_steps</code></td>
<td>
<p>numeric, number of steps used for the extrapolation.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_conv_extrap">conv_extrap</code></td>
<td>
<p>logical, should Richardson extrappolation be applied ?</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_series_terms">series_terms</code></td>
<td>
<p>numeric, number of terms in the series expansion.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_series_acc_niter">series_acc_niter</code></td>
<td>
<p>numeric, number of iterations in the
Euler-van Wijngaarden algorithm.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_series_acc_eps">series_acc_eps</code></td>
<td>
<p>numeric, tolerance of convergence in the
Euler-van Wijngaarden algorithm.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if TRUE <code>NA</code>'s (produced by taking the log of very
small probabilities) will be replaced by the smallest allowed probaility;
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_weights">weights</code></td>
<td>
<p>numeric, vector of weights to apply. If <code>NULL</code>, a vector
of one's will be applied.</p>
</td></tr>
<tr><td><code id="dWeibullCount_+3A_xmax">xmax</code></td>
<td>
<p>unsigned integer, maximum count to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>method</code> can be used to specify the desired method, as follows:
</p>

<dl>
<dt><code>"series_mat"</code></dt><dd><p>- series expansion using matrix techniques,</p>
</dd>
<dt><code>"series_acc"</code></dt><dd><p>- Euler-van Wijngaarden accelerated series expansion (default),</p>
</dd>
<dt><code>"conv_direc"t</code></dt><dd><p>- direct convolution method of section 2,</p>
</dd>
<dt><code>"conv_naive"</code></dt><dd><p>- naive convolurion described in section 3.1,</p>
</dd>
<dt><code>"conv_dePril"</code></dt><dd><p>- dePril convolution described in section 3.2.</p>
</dd>
</dl>

<p>The arguments have sensible default values.
</p>


<h3>Value</h3>

<p>for <code>dWeibullCount</code>, a vector of probabilities
<code class="reqn">P(x(i)), i = 1, \dots n</code>, where <code class="reqn">n =</code> <code>length(x)</code>.
</p>
<p>for <code>dWeibullCount_loglik</code>,
a double, the log-likelihood of the count process.
</p>
<p>for <code>evWeibullCount</code>, a list with components:
</p>
<table>
<tr><td><code>ExpectedValue</code></td>
<td>
<p>expected value,</p>
</td></tr>
<tr><td><code>Variance</code></td>
<td>
<p>variance.</p>
</td></tr>
</table>

<hr>
<h2 id='dWeibullCount_mat'>Univariate Weibull Count Probability</h2><span id='topic+dWeibullCount_mat'></span><span id='topic+dWeibullCount_acc'></span>

<h3>Description</h3>

<p>Univariate Weibull count probability computed using matrix techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWeibullCount_mat(x, shape, scale, time = 1, logFlag = FALSE, jmax = 50L)

dWeibullCount_acc(
  x,
  shape,
  scale,
  time = 1,
  logFlag = FALSE,
  jmax = 50L,
  nmax = 300L,
  eps = 1e-10,
  printa = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dWeibullCount_mat_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_shape">shape</code></td>
<td>
<p>numeric (length 1), shape parameter of the Weibull count.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_scale">scale</code></td>
<td>
<p>numeric (length 1), scale parameter of the Weibull count.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_time">time</code></td>
<td>
<p>double, length of the observation window (defaults to 1).</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_logflag">logFlag</code></td>
<td>
<p>logical, if TRUE, the log of the probability will be returned.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_jmax">jmax</code></td>
<td>
<p>integer, number of terms used to approximate the (infinite)
series.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_nmax">nmax</code></td>
<td>
<p>integer, an upper bound on the number of terms to be summed in
the Euler-van Wijngaarden sum; default is 300 terms.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_eps">eps</code></td>
<td>
<p>numeric, the desired accuracy to declare convergence.</p>
</td></tr>
<tr><td><code id="dWeibullCount_mat_+3A_printa">printa</code></td>
<td>
<p>logical, if <code>TRUE</code> print information about convergence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dWeibullCount_mat</code> implements formulae (11) of <em>McShane(2008)</em> to
compute the required probabilities.  For speed, the computations are
implemented in C++ and of matrix computations are used whenever possible.
This implementation is not efficient as it recomputes the alpha
matrix each time, which may slow down computation (among other things).
</p>
<p><code>dWeibullCount_acc</code> achieves a vast (several orders of magnitude) speed
improvement over <code>pWeibullCountOrig</code>. We achieve this by using Euler-van
Wijngaarden techniques for accelerating the convergence of alternating series
and tabulation of the alpha terms available in a pre-computed matrix (shipped
with the package).
</p>
<p>When computation time is an issue, we recommend the use of
<code>dWeibullCount_fast</code>. However, <code>pWeibullCountOrig</code> may be more
accurate, especially when <code>jmax</code> is large.
</p>


<h3>Value</h3>

<p>a vector of probabilities for each component of the count vector
<code>x</code>.
</p>

<hr>
<h2 id='dWeibullgammaCount_acc'>Fast Univariate Weibull Count Probability with gamma heterogeneity</h2><span id='topic+dWeibullgammaCount_acc'></span><span id='topic+dWeibullgammaCount'></span><span id='topic+dWeibullgammaCount_loglik'></span><span id='topic+evWeibullgammaCount'></span>

<h3>Description</h3>

<p>Probability computations for the univariate Weibull-gamma count processes. Several
methods are provided.
<code>dWeibullgammaCount</code> computes probabilities.
</p>
<p><code>dWeibullgammaCount_loglik</code> computes the log-likelihood.
</p>
<p><code>evWeibullgammaCount</code> computes the expected value and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWeibullgammaCount_acc(
  x,
  shape,
  r,
  alpha,
  time = 1,
  logFlag = FALSE,
  jmax = 100L,
  nmax = 300L,
  eps = 1e-10,
  printa = FALSE
)

dWeibullgammaCount(
  x,
  shape,
  shapeGam,
  scaleGam,
  Xcovar = NULL,
  beta = NULL,
  method = c("series_acc", "series_mat"),
  time = 1,
  log = FALSE,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10
)

dWeibullgammaCount_loglik(
  x,
  shape,
  shapeGam,
  scaleGam,
  Xcovar = NULL,
  beta = NULL,
  method = c("series_acc", "series_mat"),
  time = 1,
  na.rm = TRUE,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10,
  weights = NULL
)

evWeibullgammaCount(
  xmax,
  shape,
  shapeGam,
  scaleGam,
  Xcovar = NULL,
  beta = NULL,
  method = c("series_acc", "series_mat"),
  time = 1,
  series_terms = 50,
  series_acc_niter = 300,
  series_acc_eps = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dWeibullgammaCount_acc_+3A_x">x</code></td>
<td>
<p>integer (vector), the desired count values.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_shape">shape</code></td>
<td>
<p>numeric (length 1), shape parameter of the Weibull count.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_r">r</code></td>
<td>
<p>numeric shape of the gamma distribution</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_alpha">alpha</code></td>
<td>
<p>numeric rate of the gamma distribution</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_time">time</code></td>
<td>
<p>double, length of the observation window (defaults to 1).</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_logflag">logFlag</code></td>
<td>
<p>logical, if TRUE, the log of the probability will be returned.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_jmax">jmax</code></td>
<td>
<p>integer, number of terms used to approximate the (infinite)
series.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_nmax">nmax</code></td>
<td>
<p>integer, an upper bound on the number of terms to be summed in
the Euler-van Wijngaarden sum; default is 300 terms.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_eps">eps</code></td>
<td>
<p>numeric, the desired accuracy to declare convergence.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_printa">printa</code></td>
<td>
<p>logical, if <code>TRUE</code> print information about convergence.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_shapegam">shapeGam</code>, <code id="dWeibullgammaCount_acc_+3A_scalegam">scaleGam</code></td>
<td>
<p>numeric shape and scale parameters of the gamma
heterogeity function.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_xcovar">Xcovar</code></td>
<td>
<p>matrix the regressor values. Should have the same number of
rows as <code>length(x)</code>. If NULL, no regression will be considered.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_beta">beta</code></td>
<td>
<p>numeric regression coefficients. If NULL, no regression will be
considered.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_method">method</code></td>
<td>
<p>character one of the available methods. See details.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_log">log</code></td>
<td>
<p>logical, if TRUE, the log of the probability will be returned.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_series_terms">series_terms</code></td>
<td>
<p>numeric number of terms in the series expansion.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_series_acc_niter">series_acc_niter</code></td>
<td>
<p>numeric number of iteration in the Euler-van
Wijngaarden algorithm.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_series_acc_eps">series_acc_eps</code></td>
<td>
<p>numeric tolerance of convergence in the Euler-van
Wijngaarden algorithm.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if TRUE, <code>NA</code>'s (produced by taking the log of
very small probabilities) will be replaced by the smallest allowed
probaility; default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_weights">weights</code></td>
<td>
<p>numeric, vector of weights to apply. If <code>NULL</code>, one will
be applied.</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_acc_+3A_xmax">xmax</code></td>
<td>
<p>unsigned integer, maximum count to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The desired method can be specified by argument <code>method</code>, as follows:
</p>

<dl>
<dt><code>"series_mat"</code></dt><dd><p>series expansion using matrix techniques.</p>
</dd>
<dt><code>"series_acc"</code></dt><dd><p>Euler-van Wijngaarden accelerated series expansion.</p>
</dd>
</dl>

<p>The arguments have sensible default values.
</p>


<h3>Value</h3>

<p>for <code>dWeibullgammaCount</code>, a vector of probabilities
<code class="reqn">P(x(i)), i = 1, \dots n</code> where <code>n = length(x)</code>.
</p>
<p>for <code>dWeibullgammaCount_loglik</code>, double,
log-likelihood of the count process
</p>
<p>for <code>evWeibullgammaCount</code>, a list with components
<code>"ExpectedValue"</code> and <code>"Variance"</code>.
</p>

<hr>
<h2 id='dWeibullgammaCount_mat'>Univariate Weibull Count Probability with gamma heterogeneity</h2><span id='topic+dWeibullgammaCount_mat'></span>

<h3>Description</h3>

<p>Univariate Weibull Count Probability with gamma heterogeneity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWeibullgammaCount_mat(
  x,
  shape,
  r,
  alpha,
  time = 1,
  logFlag = FALSE,
  jmax = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dWeibullgammaCount_mat_+3A_r">r</code>, <code id="dWeibullgammaCount_mat_+3A_alpha">alpha</code></td>
<td>
<p>double gamma parameters</p>
</td></tr>
</table>

<hr>
<h2 id='dWeibullgammaCount_mat_Covariates'>Univariate Weibull Count Probability with gamma and
covariate heterogeneity</h2><span id='topic+dWeibullgammaCount_mat_Covariates'></span>

<h3>Description</h3>

<p>Univariate Weibull Count Probability with gamma and
covariate heterogeneity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWeibullgammaCount_mat_Covariates(
  x,
  cc,
  r,
  alpha,
  Xcovar,
  beta,
  t = 1,
  logFlag = FALSE,
  jmax = 100L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dWeibullgammaCount_mat_Covariates_+3A_x">x</code>, <code id="dWeibullgammaCount_mat_Covariates_+3A_cc">cc</code>, <code id="dWeibullgammaCount_mat_Covariates_+3A_t">t</code>, <code id="dWeibullgammaCount_mat_Covariates_+3A_logflag">logFlag</code>, <code id="dWeibullgammaCount_mat_Covariates_+3A_jmax">jmax</code></td>
<td>
<p>TODO
keywords internal</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_mat_Covariates_+3A_r">r</code></td>
<td>
<p>numeric shape of the gamma distribution</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_mat_Covariates_+3A_alpha">alpha</code></td>
<td>
<p>numeric rate of the gamma distribution</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_mat_Covariates_+3A_xcovar">Xcovar</code></td>
<td>
<p>matrix covariates value</p>
</td></tr>
<tr><td><code id="dWeibullgammaCount_mat_Covariates_+3A_beta">beta</code></td>
<td>
<p>numeric vector of slopes</p>
</td></tr>
</table>

<hr>
<h2 id='evCount_conv_bi'>Expected value and variance of renewal count process</h2><span id='topic+evCount_conv_bi'></span><span id='topic+evCount_conv_user'></span>

<h3>Description</h3>

<p>Compute numerically expected values and variances of renewal count processes.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>evCount_conv_bi(
  xmax,
  distPars,
  dist = c("weibull", "gamma", "gengamma", "burr"),
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE
)

evCount_conv_user(
  xmax,
  distPars,
  extrapolPars,
  survR,
  method = c("dePril", "direct", "naive"),
  nsteps = 100,
  time = 1,
  extrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evCount_conv_bi_+3A_xmax">xmax</code></td>
<td>
<p>unsigned integer maximum count to be used.</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_distpars">distPars</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_dist">dist</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_method">method</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_nsteps">nsteps</code></td>
<td>
<p>unsiged integer, number of steps used to compute the integral.</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_time">time</code></td>
<td>
<p>double, time at wich to compute the probabilities. Set to 1 by
default.</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_extrap">extrap</code></td>
<td>
<p>logical, if <code>TRUE</code>, Richardson extrapolation will be
applied to improve accuracy.</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_extrapolpars">extrapolPars</code></td>
<td>
<p>ma::vec of length 2. The extrapolation values.</p>
</td></tr>
<tr><td><code id="evCount_conv_bi_+3A_survr">survR</code></td>
<td>
<p>function, user supplied survival function; should have signature
<code>function(t, distPars)</code>, where <code>t</code> is a positive real number
(the time where the survival function is evaluated) and <code>distPars</code>
is a list of distribution parameters. It should return a double value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>evCount_conv_bi</code> computes the expected value and variance of renewal
count processes for the builtin distirbutions of inter-arrival times.
</p>
<p><code>evCount_conv_user</code> computes the expected value and variance for a user
specified distirbution of the inter-arrival times.
</p>


<h3>Value</h3>

<p>a named list with components <code>"ExpectedValue"</code> and <code>"Variance"</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>pwei_user &lt;- function(tt, distP) {
    alpha &lt;- exp(-log(distP[["scale"]]) / distP[["shape"]])
    pweibull(q = tt, scale = alpha, shape = distP[["shape"]],
             lower.tail = FALSE)
}

## ev convolution Poisson count
lambda &lt;- 2.56
beta &lt;- 1
distPars &lt;- list(scale = lambda, shape = beta)

evbi &lt;- evCount_conv_bi(20, distPars, dist = "weibull")
evu &lt;- evCount_conv_user(20, distPars, c(2, 2), pwei_user, "dePril")

c(evbi[["ExpectedValue"]], lambda)
c(evu[["ExpectedValue"]], lambda )
c(evbi[["Variance"]], lambda     )
c(evu[["Variance"]], lambda      )

## ev convolution weibull count
lambda &lt;- 2.56
beta &lt;- 1.35
distPars &lt;- list(scale = lambda, shape = beta)

evbi &lt;- evCount_conv_bi(20, distPars, dist = "weibull")
evu &lt;- evCount_conv_user(20, distPars, c(2.35, 2), pwei_user, "dePril")

x &lt;- 1:20
px &lt;- dCount_conv_bi(x, distPars, "weibull", "dePril",
                     nsteps = 100)
ev &lt;- sum(x * px)
var &lt;- sum(x^2 * px) - ev^2

c(evbi[["ExpectedValue"]], ev)
c(evu[["ExpectedValue"]], ev )
c(evbi[["Variance"]], var    )
c(evu[["Variance"]], var     )
</code></pre>

<hr>
<h2 id='fertility'>Fertility data</h2><span id='topic+fertility'></span>

<h3>Description</h3>

<p>Fertility data analysed by Winkelmann(1995). The data comes from the second
(1985) wave of German Socio-Economic Panel. The sample is formed by
1,243 women aged 44 or older in 1985. The response variable is the number of
children per woman and explanatory variables are described in more details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fertility
</code></pre>


<h3>Format</h3>

<p>A data frame with 9 variables (5 factors, 4 integers) and 1243 observations:
</p>

<dl>
<dt><code>children</code></dt><dd><p>integer; response variable: number of children
per woman (integer).</p>
</dd>
<dt><code>german</code></dt><dd><p>factor; is the mother German? (yes or no).</p>
</dd>
<dt><code>years_school</code></dt><dd><p>integer; education measured as years of schooling.</p>
</dd>
<dt><code>voc_train</code></dt><dd><p>factor; vocational training ? (yes or no)</p>
</dd>
<dt><code>university</code></dt><dd><p>factor; university education ? (yes or no)</p>
</dd>
<dt><code>religion</code></dt><dd><p>factor; mother's religion: Catholic, Protestant, Muslim
or Others (reference).</p>
</dd>
<dt><code>rural</code></dt><dd><p>factor; rural (yes or no ?)</p>
</dd>
<dt><code>year_birth</code></dt><dd><p>integer; year of birth (last 2 digits)</p>
</dd>
<dt><code>age_marriage</code></dt><dd><p>integer; age at marriage</p>
</dd>
</dl>

<p>For further details, see Winlemann(1995).
</p>


<h3>References</h3>

<p>Winkelmann R (1995).
&ldquo;Duration dependence and dispersion in count-data models.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>13</b>(4), 467&ndash;474.
</p>

<hr>
<h2 id='football'>Football data</h2><span id='topic+football'></span>

<h3>Description</h3>

<p>Final scores of all matches in the English Premier League from seasons
2009/2010 to 2016/2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>football
</code></pre>


<h3>Format</h3>

<p>a data.frame with 6 columns and 1104 observations:
</p>

<dl>
<dt><code>seasonId</code></dt><dd><p>integer season identifier (year of the first month of competition).</p>
</dd>
<dt><code>gameDate</code></dt><dd><p>POSIXct game date and time.</p>
</dd>
<dt><code>homeTeam,awayTeam</code></dt><dd><p>character home and away team name</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>homeTeamGoals,awayTeamGoals</code></dt><dd><p>integer number of goals scored by the home
and the away team.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were collected from <a href="https://www.football-data.co.uk/">https://www.football-data.co.uk/</a>
and slightly formatted and simplified.
</p>

<hr>
<h2 id='frequency_plot'>Plot a frequency chart</h2><span id='topic+frequency_plot'></span>

<h3>Description</h3>

<p>Plot a frequency chart to compare actual and predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequency_plot(count_labels, actual, pred, colours)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequency_plot_+3A_count_labels">count_labels</code></td>
<td>
<p>character, labels to be used.</p>
</td></tr>
<tr><td><code id="frequency_plot_+3A_actual">actual</code></td>
<td>
<p>numeric, the observed probabilities for the different count
specified in <code>count_labels</code>.</p>
</td></tr>
<tr><td><code id="frequency_plot_+3A_pred">pred</code></td>
<td>
<p>data.frame of predicted values. Should have the same number of
rows as actual and one column per model. The columns' names will be used
as labels for the different models.</p>
</td></tr>
<tr><td><code id="frequency_plot_+3A_colours">colours</code></td>
<td>
<p>character vector of colour codes with <code>length</code>
<code>ncol(pred)</code> + 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to compare actual and fitted values, a barchart plot is created.  It
is the user's responsibility to provide the count, observed and fitted
values.
</p>

<hr>
<h2 id='getParNames'>Return the names of distribution parameters</h2><span id='topic+getParNames'></span>

<h3>Description</h3>

<p>Return the names of the parameters of a count distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParNames(dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParNames_+3A_dist">dist</code></td>
<td>
<p>character, name of the distribution.</p>
</td></tr>
<tr><td><code id="getParNames_+3A_...">...</code></td>
<td>
<p>parameters to pass when dist == &quot;custom&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with the names of the distribution parameters.
</p>

<hr>
<h2 id='predict.renewal'>Predict method for renewal objects</h2><span id='topic+predict.renewal'></span>

<h3>Description</h3>

<p>Compute predictions from renewal objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'renewal'
predict(
  object,
  newdata = NULL,
  type = c("response", "prob"),
  se.fit = FALSE,
  terms = NULL,
  na.action = na.pass,
  time = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.renewal_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"lm"</code></p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict.  If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_type">type</code></td>
<td>
<p>type of prediction.  If equal to <code>"response"</code>, give the mean
probability associated with the individual covariates. If <code>"prob"</code>,
give the probability of the observed count.</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_se.fit">se.fit</code></td>
<td>
<p>A switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_terms">terms</code></td>
<td>
<p>If <code>type = "terms"</code>, which terms (default is all
terms), a <code><a href="base.html#topic+character">character</a></code> vector.</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing
values in <code>newdata</code>.  The default is to predict <code>NA</code>.</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_time">time</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="predict.renewal_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- system.file("extdata", "McShane_Wei_results_boot.RDS", package = "Countr")
object &lt;- readRDS(fn)
data &lt;- object$data
## old data
predOld.response &lt;- predict(object, type = "response", se.fit = TRUE)
predOld.prob &lt;- predict(object, type = "prob", se.fit = TRUE)

## newData (extracted from old Data)
newData &lt;- head(data)
predNew.response &lt;- predict(object, newdata = newData,
                            type = "response", se.fit = TRUE)
predNew.prob &lt;- predict(object, newdata = newData,
                        type = "prob", se.fit = TRUE)

cbind(head(predOld.response$values),
           head(predOld.response$se$scale),
           head(predOld.response$se$shape),
           predNew.response$values,
           predNew.response$se$scale,
           predNew.response$se$shape)

cbind(head(predOld.prob$values),
      head(predOld.prob$se$scale),
      head(predOld.prob$se$shape),
      predNew.prob$values,
      predNew.prob$se$scale,
      predNew.prob$se$shape)
</code></pre>

<hr>
<h2 id='prob_predict'>Probability predictions</h2><span id='topic+prob_predict'></span>

<h3>Description</h3>

<p>Compute probability predictions for discrete distribution models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_predict(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob_predict_+3A_obj">obj</code></td>
<td>
<p>object from a supported class.</p>
</td></tr>
<tr><td><code id="prob_predict_+3A_...">...</code></td>
<td>
<p>further arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an emergency replacement for pscl::predprob, since package 'pscl is
scheduled for removal from CRAN (in a couple of weeks) at the time of writing
this (2024-01-13).
</p>
<p>The function is exported but currently marked as internal, since the
arguments may be changed. When it is stable, it will be documented fully.
</p>

<hr>
<h2 id='renewal'>Deprecated old name of <code>renewalCount()</code></h2><span id='topic+renewal'></span>

<h3>Description</h3>

<p>Deprecated old name of <code>renewalCount()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewal(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal_+3A_...">...</code></td>
<td>
<p>same arguments as <code>renewalCount()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is now renamed to <code>renewalCount()</code>.
</p>

<hr>
<h2 id='renewal_methods'>Methods for renewal objects</h2><span id='topic+renewal_methods'></span><span id='topic+coef.renewal'></span><span id='topic+vcov.renewal'></span><span id='topic+residuals.renewal'></span><span id='topic+residuals_plot.renewal'></span><span id='topic+fitted.renewal'></span><span id='topic+confint.renewal'></span><span id='topic+summary.renewal'></span><span id='topic+print.renewal'></span><span id='topic+print.summary.renewal'></span><span id='topic+model.matrix.renewal'></span><span id='topic+logLik.renewal'></span><span id='topic+nobs.renewal'></span><span id='topic+extractAIC.renewal'></span><span id='topic+addBootSampleObject.renewal'></span><span id='topic+df.residual.renewal'></span>

<h3>Description</h3>

<p>Methods for renewal objects.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'renewal'
coef(object, ...)

## S3 method for class 'renewal'
vcov(object, ...)

## S3 method for class 'renewal'
residuals(object, type = c("pearson", "response", "prob"), ...)

## S3 method for class 'renewal'
residuals_plot(object, type = c("pearson", "response", "prob"), ...)

## S3 method for class 'renewal'
fitted(object, ...)

## S3 method for class 'renewal'
confint(
  object,
  parm,
  level = 0.95,
  type = c("asymptotic", "boot"),
  bootType = c("norm", "bca", "basic", "perc"),
  ...
)

## S3 method for class 'renewal'
summary(object, ...)

## S3 method for class 'renewal'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'summary.renewal'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  width = getOption("width"),
  ...
)

## S3 method for class 'renewal'
model.matrix(object, ...)

## S3 method for class 'renewal'
logLik(object, ...)

## S3 method for class 'renewal'
nobs(object, ...)

## S3 method for class 'renewal'
extractAIC(fit, scale, k = 2, ...)

## S3 method for class 'renewal'
addBootSampleObject(object, ...)

## S3 method for class 'renewal'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal_methods_+3A_object">object</code></td>
<td>
<p>an object from class <code>"renewal"</code>.</p>
</td></tr>
<tr><td><code id="renewal_methods_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
<tr><td><code id="renewal_methods_+3A_type">type</code>, <code id="renewal_methods_+3A_parm">parm</code>, <code id="renewal_methods_+3A_level">level</code>, <code id="renewal_methods_+3A_boottype">bootType</code>, <code id="renewal_methods_+3A_x">x</code>, <code id="renewal_methods_+3A_digits">digits</code></td>
<td>
<p>see the corresponding generics and section
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="renewal_methods_+3A_width">width</code></td>
<td>
<p>numeric width length.</p>
</td></tr>
<tr><td><code id="renewal_methods_+3A_fit">fit</code>, <code id="renewal_methods_+3A_scale">scale</code>, <code id="renewal_methods_+3A_k">k</code></td>
<td>
<p>same as in the generic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects from class <code>"renewal"</code> represent fitted count renewal models and
are created by calls to <code>"renewalCount()"</code>. There are methods for this class
for many of the familiar functions for interacting with fitted models.
</p>






<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- system.file("extdata", "McShane_Wei_results_boot.RDS", package = "Countr")
object &lt;- readRDS(fn)
class(object) # "renewal"

coef(object)
vcov(object)

## Pearson residuals: rescaled by sd
head(residuals(object, "pearson"))
## response residuals: not rescaled
head(residuals(object, "response"))

head(fitted(object))

## loglik, nobs, AIC, BIC
c(loglik = as.numeric(logLik(object)), nobs = nobs(object),
  AIC = AIC(object), BIC = BIC(object))

asym &lt;- se.coef(object, , "asymptotic")
boot &lt;- se.coef(object, , "boot")
cbind(asym, boot)
## CI for coefficients
asym &lt;- confint(object, type = "asymptotic")
## Commenting out for now, see the nite in the code of confint.renewal():
## boot &lt;- confint(object, type = "boot", bootType = "norm")
## list(asym = asym, boot = boot)
summary(object)
print(object)
## see renewal_methods
## see renewal_methods
</code></pre>

<hr>
<h2 id='renewal.control'>Creates the renewal control list</h2><span id='topic+renewal.control'></span>

<h3>Description</h3>

<p>Creates the renewal control list used by <code>renewal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewal.control(
  method = "nlminb",
  maxit = 1000,
  trace = 1,
  start = NULL,
  kkt = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal.control_+3A_method">method</code></td>
<td>
<p>character, one or more of the optimization methods accepted by
<code>optimx</code>. User can experiment with different algorithms and
the results associated with the best performing one will be retained.</p>
</td></tr>
<tr><td><code id="renewal.control_+3A_maxit">maxit</code></td>
<td>
<p>numeric, the maximum number of iterations in the optimization
routine.</p>
</td></tr>
<tr><td><code id="renewal.control_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. Should tracing information be printed to
the screen.</p>
</td></tr>
<tr><td><code id="renewal.control_+3A_start">start</code></td>
<td>
<p>(named) numeric, vector of starting values.</p>
</td></tr>
<tr><td><code id="renewal.control_+3A_kkt">kkt</code></td>
<td>
<p>locical should the Kuhn, Karush, Tucker optimality conditions be
tested? Default is <code>FALSE</code> to avoid numerical hessian computation.</p>
</td></tr>
<tr><td><code id="renewal.control_+3A_...">...</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes the user passed inputs, checks them (todo: actually, it
doesn't!) and returns an appropriate list that is used inside <code>renewal</code>
by the optimization routine, such as <code>optimx</code> among others.
</p>


<h3>Value</h3>

<p>a list with the control parameters used by <code>renewal</code>
</p>

<hr>
<h2 id='renewal.convPars'>Creates the convolution inputs setting</h2><span id='topic+renewal.convPars'></span>

<h3>Description</h3>

<p>Checks and creates the convolution inputs list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewal.convPars(convPars, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal.convPars_+3A_convpars">convPars</code></td>
<td>
<p>a list of convolution parameters arguments with slots
<code>nsteps</code>, <code>extrap</code> and <code>convMethod</code>, see
<code>dCount_conv_bi</code>. If NULL, default parameters will be applied.</p>
</td></tr>
<tr><td><code id="renewal.convPars_+3A_dist">dist</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list convolution inputs.
</p>

<hr>
<h2 id='renewal.seriesPars'>Creates the series expansion inputs setting</h2><span id='topic+renewal.seriesPars'></span>

<h3>Description</h3>

<p>Check and creates the series expansion inputs list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewal.seriesPars(seriesPars, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal.seriesPars_+3A_seriespars">seriesPars</code></td>
<td>
<p>list series expansion input parameters with slots
<code>terms</code> (number of terms in the series expansion), <code>iter</code>
(number of iteration in the accelerated series expansion algorithm) and
<code>eps</code> (tolerance in the accelerated series expansion algorithm),
Only used if <code>dist = "weibull"</code> and <code>weiMethod =
c("series_mat", "series_acc")</code>.</p>
</td></tr>
<tr><td><code id="renewal.seriesPars_+3A_long">long</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list series expansion inputs.
</p>

<hr>
<h2 id='renewal.weiMethod'>Check weibull computation algorithm</h2><span id='topic+renewal.weiMethod'></span>

<h3>Description</h3>

<p>Check weibull computation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewal.weiMethod(weiMethod)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewal.weiMethod_+3A_weimethod">weiMethod</code></td>
<td>
<p>character, desired  weibull method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a valid weibull computation method.
</p>

<hr>
<h2 id='renewalCoef'>Get named vector of coefficients for renewal objects</h2><span id='topic+renewalCoef'></span>

<h3>Description</h3>

<p>Get named vector of coefficients for renewal objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewalCoef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewalCoef_+3A_object">object</code></td>
<td>
<p>an object, there are methods for several classes, see Details.</p>
</td></tr>
<tr><td><code id="renewalCoef_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>renewalNames</code>, usually
something like <code>target = "weibull"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function for constructing named vector of coefficients
for renewal count models. Such vectors are needed, for example, for starting
values in the model fitting procedures. The simplest way to get a suitably
named vector is to take the coefficients of a fitted model but if the fitting
procedure requires initial values, this is seemingly a circular situation.
</p>
<p>The overall idea is to take coefficients specified by <code>object</code> and
transform them to coefficients suitable for a renewal count model as
specified by the arguments <code>"..."</code>. The provided methods eliminate the
need for tedius manual preparation of such vectors and in the most common
cases allow the user to do this in a single line.
</p>
<p>The default method extracts the coefficients of <code>object</code> using
</p>
<p><code>co &lt;- coef(object)</code> (an error is raised if this fails). It prepares a
named numeric vector with names requested by the arguments in <code>"..."</code>
and assigns <code>co</code> to the first <code>length(co)</code> elements of the prepared
vector. The net effect is that the coefficients of a model can be initialised
from the coefficients of a nested model. For example a Poisson regression
model can be used to initialise a Weibull count model. Of course the non-zero
shape parameter(s) of the Weibull model need to be set separately.
</p>
<p>If <code>object</code> is from class <code>glm</code>, the method is identical to the
default method.
</p>
<p>If object is from class <code><a href="#topic+renewalCoefList">renewalCoefList</a></code>, its elements are
simply concatenated in one long vector.
</p>


<h3>References</h3>

<p>Kharrat T, Boshnakov GN, McHale I, Baker R (2019).
&ldquo;Flexible Regression Models for Count Data Based on Renewal Processes: The Countr Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>90</b>(13), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v090.i13">doi:10.18637/jss.v090.i13</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renewalNames">renewalNames</a></code>
</p>

<hr>
<h2 id='renewalCoefList'>Split a vector using the prefixes of the names for grouping</h2><span id='topic+renewalCoefList'></span>

<h3>Description</h3>

<p>Split a vector using the prefixes of the names for grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewalCoefList(coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewalCoefList_+3A_coef">coef</code></td>
<td>
<p>a named vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the coefficients of renewal regression models are prefixed with
the names of the parameters to which they refer. This function splits such
vectors into a list with one component for each parameter. For example, for a
Weibull renewal regression model this will create a list with components
<code>"scale"</code> and <code>"shape"</code>.
</p>
<p>This is a convenience function allowing users to manipulate the coefficients
related to a parameter more easily. <code><a href="#topic+renewalCoef">renewalCoef</a></code> can convert
this list back to a vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renewalNames">renewalNames</a></code>, <code><a href="#topic+renewalCoef">renewalCoef</a></code>
</p>

<hr>
<h2 id='renewalCount'>Fit renewal count processes regression models</h2><span id='topic+renewalCount'></span>

<h3>Description</h3>

<p>Fit renewal regression models for count data via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewalCount(
  formula,
  data,
  subset,
  na.action,
  weights,
  offset,
  dist = c("weibull", "weibullgam", "custom", "gamma", "gengamma"),
  anc = NULL,
  convPars = NULL,
  link = NULL,
  time = 1,
  control = renewal.control(...),
  customPars = NULL,
  seriesPars = NULL,
  weiMethod = NULL,
  computeHessian = TRUE,
  standardise = FALSE,
  standardise_scale = 1,
  model = TRUE,
  y = TRUE,
  x = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewalCount_+3A_formula">formula</code></td>
<td>
<p>a formula object. If it is a standard formula object, the left
hand side specifies the response variable and the right hand sides
specifies the regression equation for the first parameter of the
conditional distribution. <code>formula</code> can also be used to specify the
ancilliary regressions, using the operator '|', see Details.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_data">data</code>, <code id="renewalCount_+3A_subset">subset</code>, <code id="renewalCount_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing via
<code>model.frame</code>.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of weights.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector with an a priori known component to be
included in the linear predictor of the count model. Currently not used.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_dist">dist</code></td>
<td>
<p>character, built-in distribution to be used as the inter-arrival
time distribution or <code>"custom"</code> for a user defined distribution, see
Details. Currently the built-in distributions are <code>"weibull"</code>,
<code>"weibullgam"</code>, <code>"gamma"</code>, <code>"gengamma"</code>
(generalized-gamma) and <code>"burr"</code>.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_anc">anc</code></td>
<td>
<p>a named list of formulas for ancillary regressions, if any,
otherwise <code>NULL</code>. The formulas associated with the (exact) parameter
names are used. The left-hand sides of the formulas in <code>anc</code> are
ignored.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_convpars">convPars</code></td>
<td>
<p>a list of convolution parameters arguments with slots
<code>nsteps</code>, <code>extrap</code> and <code>convMethod</code>, see
<code>dCount_conv_bi</code>. If NULL, default parameters will be applied.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_link">link</code></td>
<td>
<p>named list of character strings specifying the name of the link
functions to be used in the regression. If <code>NULL</code>, the canonical
link function will be used, i.e, <code>log</code> if the parameter is supposed
to be positive, identity otherwise.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_time">time</code></td>
<td>
<p>numeric, time at which the count is observed; default to unity
(1).</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code>renewal.control</code>.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_custompars">customPars</code></td>
<td>
<p>list, user inputs if <code>dist = "custom"</code>, see details.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_seriespars">seriesPars</code></td>
<td>
<p>list, series expansion input parameters with slots
<code>terms</code> (number of terms in the series expansion), <code>iter</code>
(number of iteration in the accelerated series expansion algorithm) and
<code>eps</code> (tolerance in the accelerated series expansion algorithm),
Only used if <code>dist = "weibull"</code> and <code>weiMethod =
c("series_mat", "series_acc")</code>.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_weimethod">weiMethod</code></td>
<td>
<p>character, computation method to be used if <code>dist =
"weibull"</code> or <code>"weibullgam"</code>, see <code>dWeibullCount</code> and
<code>dWeibullgammaCount</code>.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_computehessian">computeHessian</code></td>
<td>
<p>logical, should the hessian (and hence the covariance
matrix) be computed numerically at the fitted values.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_standardise">standardise</code></td>
<td>
<p>logical should the covariates be standardised using
<code>standardize::standardize()</code> function.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_standardise_scale">standardise_scale</code></td>
<td>
<p>numeric the desired scale for the covariates;
default to 1</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_model">model</code>, <code id="renewalCount_+3A_y">y</code>, <code id="renewalCount_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components of the
fit (model frame, response, model matrix) are returned.</p>
</td></tr>
<tr><td><code id="renewalCount_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>renewal.control</code> in the default setup.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>renewal</code> re-uses design and functionality of the basic R tools for
fitting regression model (<code>lm</code>, <code>glm</code>) and is highly inspired by
<code>hurdle()</code> and <code>zeroinfl()</code> from package <code>pscl</code>. Package
<code>Formula</code> is used to handle formulas.
</p>
<p>Argument <code>formula</code> is a <code>formula</code> object. In the simplest case its
left-hand side (lhs) designates the response variable and the right-hand side
the covariates for the first parameter of the distribution (as reported by
<code><a href="#topic+getParNames">getParNames</a></code>. In this case, covariates for the ancilliary
parameters are specified using argument <code>anc</code>.
</p>
<p>The ancilliary regressions, can also be specified in argument <code>formula</code>
by adding them to the righ-hand side, separated by the operator &lsquo;|&rsquo;.
For example <code>Y | shape ~ x + y | z</code> can be used in place of the pair
<code>Y ~ x + y</code> and <code>anc = list(shape = ~z)</code>. In most cases, the name
of the second parameter can be omitted, which for this example gives the
equivalent <code>Y ~ x + y | z</code>. The actual rule is that if the parameter is
missing from the left-hand side, it is inferred from the default parameter
list of the distribution.
</p>
<p>As another convenience, if the parameters are to to have the same covariates,
it is not necessary to repeat the rhs. For example, <code>Y | shape ~ x + y</code>
is equivalent to <code>Y | shape ~ x + y | x + y</code>. Note that this is applied
only to parameters listed on the lhs, so <code>Y ~ x + y</code> specifies
covariates only for the response variable and not any other parameters.
</p>
<p>Distributions for inter-arrival times supported internally by this package
can be chosen by setting argument <code>"dist"</code> to a suitable character
string.  Currently the built-in distributions are <code>"weibull"</code>,
<code>"weibullgam"</code>, <code>"gamma"</code>, <code>"gengamma"</code> (generalized-gamma)
and <code>"burr"</code>.
</p>
<p>Users can also provide their own inter-arrival distribution.  This is done by
setting argument <code>"dist"</code> to <code>"custom"</code>, specifying the initial
values and giving argument <code>customPars</code> as a list with the following
components:
</p>

<dl>
<dt>parNames</dt><dd><p>character, the names of the parameters of the distribution.
The location parameter should be the first one.</p>
</dd>
<dt>survivalFct</dt><dd><p>function object containing the survival function. It
should have signature <code>function(t, distPars)</code> where <code>t</code> is the
point where the survival function is evaluated and <code>distPars</code> is the
list of the distribution parameters. It should return a double value.</p>
</dd>
<dt>extrapolFct</dt><dd><p>function object computing the extrapolation values
(numeric of length 2) from the value of the distribution parameters (in
<code>distPars</code>). It should have signature <code>function(distPars)</code> and
return a numeric vector of length 2. Only required if the extrapolation
is set to <code>TRUE</code> in <code>convPars</code>.</p>
</dd>
</dl>

<p>Some checks are done to validate <code>customPars</code> but it is user's
responsibility to make sure the the functions have the appropriate
signatures.
</p>
<p><strong>Note:</strong> The Weibull-gamma distribution is an experimental version and
should be used with care! It is very sensitive to initial values and there is no
guarantee of convergence. It has also been reparameterized in terms of
<code class="reqn">(1/r, 1/\alpha, c)</code> instead of <code class="reqn">(r, \alpha,
c)</code>, where <code class="reqn">r</code> and <code class="reqn">\alpha</code> are the shape
and scale of the gamma distribution and <code class="reqn">c</code> is the shape of the Weibull
distribution.
</p>
<p><strong>(2017-08-04(Georgi) experimental feature:</strong> probability residuals in
component 'probResiduals'. I also added type 'prob' to the method for
residuals() to extract them.
</p>
<p>probResiduals[i] is currently 1 - Prob(Y[i] given the
covariates). &quot;one minus&quot;, so that values close to zero are &quot;good&quot;.  On its
own this is probably not very useful but when comparing two models, if one of
them has mostly smaller values than the other, there is some reason to claim
that the former is superior. For example (see below), gamModel &lt; poisModel in
3:1
</p>


<h3>Value</h3>

<p>An <code>S3</code> object of class &quot;renewal&quot;, which is a list with
components including:
</p>

<dl>
<dt>coefficients</dt><dd><p>values of the fitted coefficients.</p>
</dd>
<dt>residuals</dt><dd><p>vector of weighted residuals <code class="reqn">\omega * (observed -
    fitted)</code>.</p>
</dd>
<dt>fitted.values</dt><dd><p>vector of fitted means.</p>
</dd>
<dt>optim</dt><dd><p>data.frame output of <code>optimx</code>.</p>
</dd>
<dt>method</dt><dd><p>optimisation algorithm.</p>
</dd>
<dt>control</dt><dd><p>the control arguments, passed to <code>optimx</code>.</p>
</dd>
<dt>start</dt><dd><p>starting values, passed to <code>optimx</code>.</p>
</dd>
<dt>weights</dt><dd><p>weights to apply, if any.</p>
</dd>
<dt>n</dt><dd><p>number of observations (with weights &gt; 0).</p>
</dd>
<dt>iterations</dt><dd><p>number of iterations in the optimisation algorithm.</p>
</dd>
<dt>execTime</dt><dd><p>duration of the optimisation.</p>
</dd>
<dt>loglik</dt><dd><p>log-likelihood of the fitted model.</p>
</dd>
<dt>df.residual</dt><dd><p>residuals' degrees of freedom for the fitted model.</p>
</dd>
<dt>vcoc</dt><dd><p>convariance matrix of all coefficients, computed numerically
from the hessian at the fitted coefficients (if <code>computeHessian</code> is
<code>TRUE</code>).</p>
</dd>
<dt>dist</dt><dd><p>name of the inter-arrival distribution.</p>
</dd>
<dt>link</dt><dd><p>list, inverse link function corresponding to each parameter in
the inter-arrival distribution.</p>
</dd>
<dt>converged</dt><dd><p>logical, did the optimisation algorithm converge?</p>
</dd>
<dt>data</dt><dd><p>data used to fit the model.</p>
</dd>
<dt>formula</dt><dd><p>the original formula.</p>
</dd>
<dt>call</dt><dd><p>the original function call.</p>
</dd>
<dt>anc</dt><dd><p>named list of formulas to model regression on ancillary
parameters.</p>
</dd>
<dt>score_fct</dt><dd><p>function to compute the vector of scores defined in
Cameron(2013) equation 2.94.</p>
</dd>
<dt>convPars</dt><dd><p>convolution inputs used.</p>
</dd>
<dt>customPars</dt><dd><p>named list, user passed distribution inputs, see
Details.</p>
</dd>
<dt>time</dt><dd><p>observed window used, default is 1.0 (see inputs).</p>
</dd>
<dt>model</dt><dd><p>the full model frame (if <code>model = TRUE</code>).</p>
</dd>
<dt>y</dt><dd><p>the response count vector (if <code>y = TRUE</code>).</p>
</dd>
<dt>x</dt><dd><p>the model matrix (if <code>x = TRUE</code>).</p>
</dd>
</dl>



<h3>References</h3>

<p>Kharrat T, Boshnakov GN, McHale I, Baker R (2019).
&ldquo;Flexible Regression Models for Count Data Based on Renewal Processes: The Countr Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>90</b>(13), 1&ndash;35.
<a href="https://doi.org/10.18637/jss.v090.i13">doi:10.18637/jss.v090.i13</a>.
</p>
<p>Cameron AC, Trivedi PK (2013).
<em>Regression Analysis of Count Data</em>, volume 53.
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## may take some time to run depending on your CPU
data(football)
wei = renewalCount(formula = homeTeamGoals ~ 1,
                    data = football, dist = "weibull", weiMethod = "series_acc",
                    computeHessian = FALSE, control = renewal.control(trace = 0, 
                    method = "nlminb"))

## End(Not run)
</code></pre>

<hr>
<h2 id='renewalNames'>Get names of parameters of renewal regression models</h2><span id='topic+renewalNames'></span>

<h3>Description</h3>

<p>Get names of parameters of renewal regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renewalNames(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renewalNames_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="renewalNames_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>renewalNames</code> gives the a character vector of names of parameters for
renewal regression models. There are two main use scenarios:
<code>renewalNames(object, target = "dist")</code> and
<code>renewalNames(object,...)</code>. In the first scenario <code>target</code> can be a
count distribution, such as &quot;weibull&quot; or a parameter name, such as shape.  In
this case <code>renewalNames</code> transforms coefficient names of <code>object</code>
to those specified by <code>target</code>. In the second cenario the argument list
is the same that would be used to call <code>renewalCount</code>. In this case
<code>renewalNames</code> returns the names that would be used by renewalCount for
the coefficients of the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+renewalCoefList">renewalCoefList</a></code>, <code><a href="#topic+renewalCoef">renewalCoef</a></code>
</p>

<hr>
<h2 id='residuals_plot'>Method to visualise the residuals</h2><span id='topic+residuals_plot'></span>

<h3>Description</h3>

<p>A method to visualise the residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_plot(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_plot_+3A_object">object</code></td>
<td>
<p>object returned by one of the count modeling functions.</p>
</td></tr>
<tr><td><code id="residuals_plot_+3A_type">type</code></td>
<td>
<p>character type of residuals to be used.</p>
</td></tr>
<tr><td><code id="residuals_plot_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>

<hr>
<h2 id='se.coef'>Extract Standard Errors of Model Coefficients</h2><span id='topic+se.coef'></span><span id='topic+se.coef.renewal'></span>

<h3>Description</h3>

<p>Extract standard errors of model coefficients from objects returned by
count modeling functions.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>se.coef(object, parm, type, ...)

## S3 method for class 'renewal'
se.coef(object, parm, type = c("asymptotic", "boot"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.coef_+3A_object">object</code></td>
<td>
<p>an object returned by one of the count modeling functions.</p>
</td></tr>
<tr><td><code id="se.coef_+3A_parm">parm</code></td>
<td>
<p>parameter's name or index.</p>
</td></tr>
<tr><td><code id="se.coef_+3A_type">type</code></td>
<td>
<p>type of standard error: asymtotic normal standard errors
(<code>"asymptotic"</code>) or bootsrap (<code>"boot"</code>).</p>
</td></tr>
<tr><td><code id="se.coef_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for class <code>"renewal"</code> extracts standard errors of model
coefficients from objects returned by <code>renewal</code>.  When bootsrap standard
error are requested, the function checks for the bootsrap sample in
<code>object</code>. If it is not found, the bootsrap sample is created and a
warning is issued. Users can choose between asymtotic normal standard errors
(<code>asymptotic</code>) or bootsrap (<code>boot</code>).
</p>






<h3>Value</h3>

<p>a named numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for renewal_methods
</code></pre>

<hr>
<h2 id='surv'>Wrapper to built-in survival functions</h2><span id='topic+surv'></span>

<h3>Description</h3>

<p>Wrapper to built-in survival functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv(t, distPars, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_+3A_t">t</code></td>
<td>
<p>double, time point where the survival is to be evaluated at.</p>
</td></tr>
<tr><td><code id="surv_+3A_distpars">distPars</code></td>
<td>
<p><code>Rcpp::List</code> with distribution specific slots,
see details.</p>
</td></tr>
<tr><td><code id="surv_+3A_dist">dist</code></td>
<td>
<p>character name of the built-in distribution, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function wraps all builtin-survival distributions. User can choose
between the <code>weibull</code>, <code>gamma</code>, <code>gengamma</code>(generalized gamma)
and <code>burr</code> (Burr type XII distribution). It is the user responsibility
to pass the appropriate list of parameters as follows:
</p>

<dl>
<dt>weibull</dt><dd><p><code>scale</code> (the scale) and <code>shape</code> (the shape)
parameters.</p>
</dd>
<dt>burr</dt><dd><p><code>scale</code> (the scale) and <code>shape1</code> (the shape1) and
<code>shape2</code> (the shape2) parameters.</p>
</dd> 
<dt>gamma</dt><dd> <p><code>scale</code> (the scale) and <code>shape</code> (the shape)
parameter.</p>
</dd>
<dt>gengamma</dt><dd><p><code>mu</code> (location), <code>sigma</code> (scale) and <code>Q</code>
(shape) parameters.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a double, giving the value of the survival function at time point
<code>t</code> at the parameters' values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- 2.5
## weibull

distP &lt;- list(scale = 1.2, shape = 1.16)
alpha &lt;- exp(-log(distP[["scale"]]) / distP[["shape"]])
pweibull(q = tt, scale = alpha, shape = distP[["shape"]],
                      lower.tail = FALSE)
surv(tt, distP, "weibull") ## (almost) same

## gamma
distP &lt;- list(shape = 0.5, rate = 1.0 / 0.7)
pgamma(q = tt, rate = distP[["rate"]], shape = distP[["shape"]],
                    lower.tail = FALSE)
surv(tt, distP, "gamma")  ## (almost) same

## generalized gamma
distP &lt;- list(mu = 0.5, sigma = 0.7, Q = 0.7)
flexsurv::pgengamma(q = tt, mu = distP[["mu"]],
                    sigma = distP[["sigma"]],
                    Q = distP[["Q"]],
                    lower.tail = FALSE)
surv(tt, distP, "gengamma")  ## (almost) same

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
